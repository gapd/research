<?xml version="1.0"?><st-source><!-- Name: MemoryPolicyCheckerDbIdentifier: bear73DbTrace: 314421DevelopmentPrerequisites: #(#(#any 'SUnit' ''))PackageName: MemoryPolicyCheckerParcel: #('MemoryPolicyChecker')PrerequisiteDescriptions: #(#(#name 'SUnit' #componentType #package))PrerequisiteParcels: #(#('SUnit' ''))PrintStringCache: (7.8 - 1003,avalloud)Version: 7.8 - 1003Date: 10:51:27 AM January 7, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.1) of January 7, 2011 on January 7, 2011 at 10:51:27 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MemoryPolicyTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentObjectMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>MemoryPolicyTest</class-id><body>These test cases test various aspects of memory policy functionality.</body></comment><class><name>AbstractMemoryPolicyChecker</name><environment>Smalltalk</environment><super>MemoryPolicyTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>AbstractMemoryPolicyChecker</class-id><body>Policy checker test cases enforce various memory policy working assumptions.</body></comment><class><name>PotentialMemoryPolicyChecker</name><environment>Smalltalk</environment><super>AbstractMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>PotentialMemoryPolicyChecker</class-id><body>Potential memory policy checkers ensure the correct operation of memory policies that could potentially become the current memory policy.  Note that tests are refined to make assertions for many memory upper bound values.</body></comment><class><name>MediumGrainMemoryPolicyChecker</name><environment>Smalltalk</environment><super>PotentialMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>MediumGrainMemoryPolicyChecker</class-id><body>This test checks the medium grain memory policy.</body></comment><class><name>CurrentMemoryPolicyChecker</name><environment>Smalltalk</environment><super>AbstractMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>CurrentMemoryPolicyChecker</class-id><body>This policy checker ensures that the current memory policy is working correctly.  Note that the current memory policy is subject to additional tests because, being current, more assertions can be made about it.</body></comment><class><name>MemoryPolicyChecker</name><environment>Smalltalk</environment><super>PotentialMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>MemoryPolicyChecker</class-id><body>This test checks the class MemoryPolicy.</body></comment><class><name>LargeGrainMemoryPolicyChecker</name><environment>Smalltalk</environment><super>PotentialMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>LargeGrainMemoryPolicyChecker</class-id><body>This test checks the large grain memory policy.</body></comment><methods><class-id>MemoryPolicyTest</class-id> <category>setup - object memory</category><body package="MemoryPolicyChecker" selector="availableFreeOldSpaceBytes">availableFreeOldSpaceBytes	^self currentObjectMemory availableFreeOldSpaceBytes</body><body package="MemoryPolicyChecker" selector="bytesPerOOP">bytesPerOOP	^self currentObjectMemory bytesPerOOP</body><body package="MemoryPolicyChecker" selector="bytesPerOTE">bytesPerOTE	^self currentObjectMemory bytesPerOTE</body><body package="MemoryPolicyChecker" selector="currentHardLowSpaceLimit">currentHardLowSpaceLimit	^self objectMemory hardLowSpaceLimit</body><body package="MemoryPolicyChecker" selector="currentSoftLowSpaceLimit">currentSoftLowSpaceLimit	^self objectMemory softLowSpaceLimit</body><body package="MemoryPolicyChecker" selector="dynamicallyAllocatedFootprint">dynamicallyAllocatedFootprint	^self currentObjectMemory dynamicallyAllocatedFootprint</body><body package="MemoryPolicyChecker" selector="largeBytes">largeBytes	^self currentObjectMemory largeBytes</body><body package="MemoryPolicyChecker" selector="nativeStackSpills">nativeStackSpills	^self currentObjectMemory nativeStackSpills</body><body package="MemoryPolicyChecker" selector="newBytesAvailableForStorage">newBytesAvailableForStorage	^self currentObjectMemory newBytesAvailableForStorage</body><body package="MemoryPolicyChecker" selector="oldRtBytes">oldRtBytes	^self currentObjectMemory oldRtBytes</body><body package="MemoryPolicyChecker" selector="oldRtEntries">oldRtEntries	^self currentObjectMemory oldRtEntries</body><body package="MemoryPolicyChecker" selector="oldSegments">oldSegments	^self currentObjectMemory oldSegments</body><body package="MemoryPolicyChecker" selector="oldSpaceSegmentSizes">oldSpaceSegmentSizes	| answer |	answer := OrderedCollection new.	1 to: self oldSegments do:		[:each | answer add: (self currentObjectMemory oldSegmentSizeAt: each)].	^answer</body><body package="MemoryPolicyChecker" selector="rtBytes">rtBytes	^self currentObjectMemory rtBytes</body><body package="MemoryPolicyChecker" selector="rtEntries">rtEntries	^self currentObjectMemory rtEntries</body><body package="MemoryPolicyChecker" selector="stackBytes">stackBytes	^self currentObjectMemory stackBytes</body><body package="MemoryPolicyChecker" selector="stackZoneFlushBytes">stackZoneFlushBytes	^self currentObjectMemory stackZoneFlushBytes</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>setup</category><body package="MemoryPolicyChecker" selector="memoryPolicy">memoryPolicy	"Refine this method to retarget these tests for other, inactive memory policies"	^self objectMemory currentMemoryPolicy</body><body package="MemoryPolicyChecker" selector="minimumHardLowSpaceLimit">minimumHardLowSpaceLimit	^self newBytesAvailableForStorage		+ self stackZoneFlushBytes</body><body package="MemoryPolicyChecker" selector="objectMemory">objectMemory	^ObjectMemory</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>setup - memory policy</category><body package="MemoryPolicyChecker" selector="availableSpaceSafetyMargin">availableSpaceSafetyMargin	^self memoryPolicy availableSpaceSafetyMargin</body><body package="MemoryPolicyChecker" selector="contiguousSpaceSafetyMargin">contiguousSpaceSafetyMargin	^self memoryPolicy contiguousSpaceSafetyMargin</body><body package="MemoryPolicyChecker" selector="freeFixedMemoryUpperBound">freeFixedMemoryUpperBound	^self memoryPolicy freeFixedMemoryUpperBound</body><body package="MemoryPolicyChecker" selector="freeMemoryUpperBound">freeMemoryUpperBound	^self memoryPolicy freeMemoryUpperBound</body><body package="MemoryPolicyChecker" selector="growthRegimeUpperBound">growthRegimeUpperBound	^self memoryPolicy growthRegimeUpperBound</body><body package="MemoryPolicyChecker" selector="growthRetryDecrement">growthRetryDecrement	^self memoryPolicy growthRetryDecrement</body><body package="MemoryPolicyChecker" selector="idleLoopAllocationThreshold">idleLoopAllocationThreshold	^self memoryPolicy idleLoopAllocationThreshold</body><body package="MemoryPolicyChecker" selector="incrementalAllocationThreshold">incrementalAllocationThreshold	^self memoryPolicy incrementalAllocationThreshold</body><body package="MemoryPolicyChecker" selector="initHardLowSpaceLimit">initHardLowSpaceLimit	^self memoryPolicy initHardLowSpaceLimit</body><body package="MemoryPolicyChecker" selector="initSoftLowSpaceLimit">initSoftLowSpaceLimit	^self memoryPolicy initSoftLowSpaceLimit</body><body package="MemoryPolicyChecker" selector="memoryUpperBound">memoryUpperBound	^self memoryPolicy memoryUpperBound</body><body package="MemoryPolicyChecker" selector="minimumGrowthDueToAllocationFailure">minimumGrowthDueToAllocationFailure	^self memoryPolicy minimumGrowthDueToAllocationFailure</body><body package="MemoryPolicyChecker" selector="newHardLowSpaceLimit">newHardLowSpaceLimit	^self memoryPolicy newHardLowSpaceLimit</body><body package="MemoryPolicyChecker" selector="newSoftLowSpaceLimit">newSoftLowSpaceLimit	^self memoryPolicy newSoftLowSpaceLimit</body><body package="MemoryPolicyChecker" selector="oopSizeFactor">oopSizeFactor	^ObjectMemory is64Bit ifTrue: [2] ifFalse: [1]</body><body package="MemoryPolicyChecker" selector="preferredFixedGrowthIncrement">preferredFixedGrowthIncrement	^self memoryPolicy preferredFixedGrowthIncrement</body><body package="MemoryPolicyChecker" selector="preferredGrowthIncrement">preferredGrowthIncrement	^self memoryPolicy preferredGrowthIncrement</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>setup - sizes at startup</category><body package="MemoryPolicyChecker" selector="defaultSizesAtStartup">defaultSizesAtStartup	^self objectMemory defaultSizesAtStartup</body><body package="MemoryPolicyChecker" selector="sizesAtStartup">sizesAtStartup	^ObjectMemory sizesAtStartup</body><body package="MemoryPolicyChecker" selector="stackMultiplier">stackMultiplier	^self sizesAtStartup at: 4</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>accessing</category><body package="MemoryPolicyChecker" selector="currentObjectMemory">currentObjectMemory	currentObjectMemory notNil ifTrue: [^currentObjectMemory].	self currentObjectMemory: self objectMemory current.	^currentObjectMemory</body><body package="MemoryPolicyChecker" selector="currentObjectMemory:">currentObjectMemory: anObject	currentObjectMemory := anObject</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - growth regime upper bound</category><body package="MemoryPolicyChecker" selector="testGrowthRegimeUpperBoundIsLargeEnough">testGrowthRegimeUpperBoundIsLargeEnough	self		assert: self growthRegimeUpperBound &gt; self availableSpaceSafetyMargin		description: 'The memory upper bound should larger than the available space safety margin'.	self		assert: self growthRegimeUpperBound &gt; self contiguousSpaceSafetyMargin		description: 'The memory upper bound should larger than the contiguous space safety margin'.	self		assert: self growthRegimeUpperBound &gt; self preferredGrowthIncrement		description: 'The memory upper bound should larger than the preferredGrowthIncrement'.	self		assert: self memoryUpperBound &gt; (self growthRegimeUpperBound + self preferredGrowthIncrement)		description: 'The memory upper bound should be significantly larger than the growth regime upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - priorities</category><body package="MemoryPolicyChecker" selector="testLowSpacePriorityIsHigherThanFinalizationPriority">testLowSpacePriorityIsHigherThanFinalizationPriority	"See WeakArray class&gt;&gt;outerFinalizationLoop"	self		assert: Processor lowSpacePriority &gt; Processor lowIOPriority		description: 'Actual finalization work should yield to low space processing'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - free fixed memory upper bound</category><body package="MemoryPolicyChecker" selector="testFreeFixedMemoryUpperBoundIsLargeEnough">testFreeFixedMemoryUpperBoundIsLargeEnough	self		assert: self freeFixedMemoryUpperBound &gt;= 0		description: 'The free fixed memory upper bound should be positive'</body><body package="MemoryPolicyChecker" selector="testFreeFixedMemoryUpperBoundIsNotTooLarge">testFreeFixedMemoryUpperBoundIsNotTooLarge	self		assert: self memoryUpperBound &gt; self freeFixedMemoryUpperBound		description: 'The free fixed memory upper bound should be less than the memory upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing</category><body package="MemoryPolicyChecker" selector="testIdleLoopAllocationThresholdIsLargeEnough">testIdleLoopAllocationThresholdIsLargeEnough	self		assert: self idleLoopAllocationThreshold &gt; self newBytesAvailableForStorage		description: 'The idle loop allocation threshold should be larger than new space'.	self		assert: self idleLoopAllocationThreshold // 2 &gt;= self preferredGrowthIncrement		description: 'The idle loop allocation threshold seems too small'</body><body package="MemoryPolicyChecker" selector="testIncrementalAllocationThresholdIsLargeEnough">testIncrementalAllocationThresholdIsLargeEnough	self		assert: self incrementalAllocationThreshold * 10 &gt;= self preferredGrowthIncrement		description: 'The incremental allocation threshold seems too small'</body><body package="MemoryPolicyChecker" selector="testMemoryUpperBoundMinimum">testMemoryUpperBoundMinimum	self		assert: self memoryPolicy class defaultMemoryUpperBound &gt;= (64 bitShift: 20)		description: 'Memory policy class tested for memory upper bounds no less than 64mb'</body><body package="MemoryPolicyChecker" selector="testMemoryUpperBoundMinimumEnforced">testMemoryUpperBoundMinimumEnforced	| previousMemoryUpperBound minimumEnforced |	previousMemoryUpperBound := self memoryPolicy class defaultMemoryUpperBound.	self memoryPolicy class defaultMemoryUpperBound: 1.	minimumEnforced := self memoryPolicy class defaultMemoryUpperBound &gt; 1.	self memoryPolicy class defaultMemoryUpperBound: previousMemoryUpperBound.	self		assert: minimumEnforced		description: 'Memory policy class tested for memory upper bounds no less than 64mb'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - contiguous space safety margin</category><body package="MemoryPolicyChecker" selector="testContiguousSpaceSafetyMarginIsLargeEnough">testContiguousSpaceSafetyMarginIsLargeEnough	| allRtBytes |	allRtBytes := self rtBytes + self oldRtBytes.	self		assert: self contiguousSpaceSafetyMargin // 2 &gt; allRtBytes		description: 'The contiguous space safety margin should be increased to make sure the RTs can grow'.	self		assert: self contiguousSpaceSafetyMargin &gt; self newBytesAvailableForStorage		description: 'The contiguous space safety margin should be increased to make sure a worst case scavenge will succeed'.	self		assert: self contiguousSpaceSafetyMargin &gt;= (allRtBytes * 2 + self newBytesAvailableForStorage)		description: 'The contiguous space safety margin should be increased to avoid scavenger failure or failure to grow RTs'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - preferred growth increment</category><body package="MemoryPolicyChecker" selector="testGrowthRetryDecrementIsLargeEnough">testGrowthRetryDecrementIsLargeEnough	self		assert: self growthRetryDecrement * 100 &gt; self preferredGrowthIncrement		description: 'The growth retry decrement seems too small'.	self		assert: self growthRetryDecrement * 100 &gt; self preferredFixedGrowthIncrement		description: 'The growth retry decrement seems too small'.	self		assert: self growthRetryDecrement &gt; 16384		description: 'The growth retry decrement seems too small'</body><body package="MemoryPolicyChecker" selector="testGrowthRetryDecrementIsNotTooLarge">testGrowthRetryDecrementIsNotTooLarge	self		assert: self preferredGrowthIncrement // 10 &gt; self growthRetryDecrement		description: 'The growth retry decrement should be much smaller than the preferred growth increment'.	self		assert: self preferredFixedGrowthIncrement // 10 &gt; self growthRetryDecrement		description: 'The growth retry decrement should be much smaller than the preferred fixed growth increment'</body><body package="MemoryPolicyChecker" selector="testPreferredGrowthIncrementIsLargeEnough">testPreferredGrowthIncrementIsLargeEnough	self		assert: self preferredGrowthIncrement &gt;= self minimumHardLowSpaceLimit		description: 'The preferred growth increment must be greater than the minimum hard low space limit'.	self		assert: self preferredGrowthIncrement &gt;= self newHardLowSpaceLimit		description: 'The preferred growth increment must be greater than the hard low space limit'.	self		assert: self preferredGrowthIncrement &gt;= self newBytesAvailableForStorage		description: 'The preferred growth increment must be greater than new space'.	self		assert: self preferredGrowthIncrement &gt;= self contiguousSpaceSafetyMargin		description: 'The preferred growth increment must be greater than contiguous space safety margin'</body><body package="MemoryPolicyChecker" selector="testPreferredGrowthIncrementIsNotTooLarge">testPreferredGrowthIncrementIsNotTooLarge	self		assert: self preferredGrowthIncrement * 5 &lt; self memoryUpperBound		description: 'The preferred growth increment seems too large in comparison to the memory upper bound'</body><body package="MemoryPolicyChecker" selector="testPreferredGrowthIncrementLargerThanMinimumGranularity">testPreferredGrowthIncrementLargerThanMinimumGranularity	self		assert: self preferredGrowthIncrement &gt; self minimumGrowthDueToAllocationFailure		description: 'The preferred growth increment must be larger than the minimum granularity growth'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - sizes at startup</category><body package="MemoryPolicyChecker" selector="testOldSpaceHeadroom">testOldSpaceHeadroom	| sizes factors oldSpaceHeadroom edenBytes survivorBytes stackFlushBytes enoughRtBytes minimumOldSpaceHeadroom |	sizes := self defaultSizesAtStartup.	factors := self sizesAtStartup.	oldSpaceHeadroom := (sizes at: 6) * (factors at: 6).	edenBytes := (sizes at: 1) * (factors at: 1).	survivorBytes := (sizes at: 2) * (factors at: 2).	stackFlushBytes := self stackZoneFlushBytes / self stackBytes * (sizes at: 4) * (factors at: 4).	enoughRtBytes := self rtBytes + self oldRtBytes * 2.	minimumOldSpaceHeadroom := edenBytes + survivorBytes + stackFlushBytes + enoughRtBytes.	self		assert: oldSpaceHeadroom &gt; minimumOldSpaceHeadroom		description: 'The old space headroom should be increased so that the image can perform a worst case scenario scavenge at startup'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - free memory upper bound</category><body package="MemoryPolicyChecker" selector="testFreeMemoryUpperBoundIsLargeEnough">testFreeMemoryUpperBoundIsLargeEnough	self		assert: self freeMemoryUpperBound &gt; self availableSpaceSafetyMargin		description: 'The free memory upper bound should be larger than the available space safety margin'.	self		assert: self freeMemoryUpperBound &gt; self preferredGrowthIncrement		description: 'The free memory upper bound should be larger than the growth increment'.	self		assert: self freeMemoryUpperBound // 2 &gt;= self preferredGrowthIncrement		description: 'The free memory upper bound should be at least twice as large as the preferred growth increment'.	self		assert: self freeMemoryUpperBound &gt; self currentHardLowSpaceLimit		description: 'The free memory upper bound should be larger than the hard low space limit'.	self		assert: self freeMemoryUpperBound &gt; self initHardLowSpaceLimit		description: 'The free memory upper bound should be larger than the hard low space limit'.	self		assert: self freeMemoryUpperBound &gt; self newHardLowSpaceLimit		description: 'The free memory upper bound should be larger than the hard low space limit'.</body><body package="MemoryPolicyChecker" selector="testFreeMemoryUpperBoundIsNotTooLarge">testFreeMemoryUpperBoundIsNotTooLarge	self		assert: self memoryUpperBound &gt; self freeMemoryUpperBound		description: 'The free memory upper bound should be less than the memory upper bound'.	self		assert: self memoryUpperBound &gt; (self freeMemoryUpperBound + self availableSpaceSafetyMargin)		description: 'The free memory upper bound should be significantly less than the memory upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - preferred fixed growth increment</category><body package="MemoryPolicyChecker" selector="testPreferredFixedGrowthIncrementIsLargeEnough">testPreferredFixedGrowthIncrementIsLargeEnough	| minimumPreferredFixedGrowthIncrement |	minimumPreferredFixedGrowthIncrement := self defaultSizesAtStartup at: 7.	self		assert: self preferredFixedGrowthIncrement &gt;= minimumPreferredFixedGrowthIncrement		description: 'The preferred growth increment should be larger than the minimum fixed space headroom'</body><body package="MemoryPolicyChecker" selector="testPreferredFixedGrowthIncrementIsNotTooLarge">testPreferredFixedGrowthIncrementIsNotTooLarge	self		assert: self preferredFixedGrowthIncrement * 10 &lt; self memoryUpperBound		description: 'The preferred fixed growth increment seems too large in comparison to the memory upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker class</class-id> <category>testing</category><body package="MemoryPolicyChecker" selector="isAbstract">isAbstract	^self subclasses notEmpty</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - priorities</category><body package="MemoryPolicyChecker" selector="testLowSpacePriorityIsHigherThanFinalizationPriority">testLowSpacePriorityIsHigherThanFinalizationPriority	self evaluateTestMethod: [super testLowSpacePriorityIsHigherThanFinalizationPriority]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>setup</category><body package="MemoryPolicyChecker" selector="evaluateTestMethod:">evaluateTestMethod: aBlock	| previousBound policyClass |	policyClass := self memoryPolicy class.	previousBound := policyClass defaultMemoryUpperBound.	[		(64 bitShift: 20) to: (4 bitShift: 30) by: (32 bitShift: 20) do:			[:eachBound |				policyClass defaultMemoryUpperBound: eachBound.				aBlock value			]	] ensure: [policyClass defaultMemoryUpperBound: previousBound]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - contiguous space safety margin</category><body package="MemoryPolicyChecker" selector="testContiguousSpaceSafetyMarginIsLargeEnough">testContiguousSpaceSafetyMarginIsLargeEnough	self evaluateTestMethod: [super testContiguousSpaceSafetyMarginIsLargeEnough]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing</category><body package="MemoryPolicyChecker" selector="testIdleLoopAllocationThresholdIsLargeEnough">testIdleLoopAllocationThresholdIsLargeEnough	self evaluateTestMethod: [super testIdleLoopAllocationThresholdIsLargeEnough]</body><body package="MemoryPolicyChecker" selector="testIncrementalAllocationThresholdIsLargeEnough">testIncrementalAllocationThresholdIsLargeEnough	self evaluateTestMethod: [super testIncrementalAllocationThresholdIsLargeEnough]</body><body package="MemoryPolicyChecker" selector="testMemoryUpperBoundMinimum">testMemoryUpperBoundMinimum	self evaluateTestMethod: [super testMemoryUpperBoundMinimum]</body><body package="MemoryPolicyChecker" selector="testMemoryUpperBoundMinimumEnforced">testMemoryUpperBoundMinimumEnforced	self evaluateTestMethod: [super testMemoryUpperBoundMinimumEnforced]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - free fixed memory upper bound</category><body package="MemoryPolicyChecker" selector="testFreeFixedMemoryUpperBoundIsLargeEnough">testFreeFixedMemoryUpperBoundIsLargeEnough	self evaluateTestMethod: [super testFreeFixedMemoryUpperBoundIsLargeEnough]</body><body package="MemoryPolicyChecker" selector="testFreeFixedMemoryUpperBoundIsNotTooLarge">testFreeFixedMemoryUpperBoundIsNotTooLarge	self evaluateTestMethod: [super testFreeFixedMemoryUpperBoundIsNotTooLarge]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - preferred growth increment</category><body package="MemoryPolicyChecker" selector="testGrowthRetryDecrementIsLargeEnough">testGrowthRetryDecrementIsLargeEnough	self evaluateTestMethod: [super testGrowthRetryDecrementIsLargeEnough]</body><body package="MemoryPolicyChecker" selector="testGrowthRetryDecrementIsNotTooLarge">testGrowthRetryDecrementIsNotTooLarge	self evaluateTestMethod: [super testGrowthRetryDecrementIsNotTooLarge]</body><body package="MemoryPolicyChecker" selector="testPreferredGrowthIncrementIsLargeEnough">testPreferredGrowthIncrementIsLargeEnough	self evaluateTestMethod: [super testPreferredGrowthIncrementIsLargeEnough]</body><body package="MemoryPolicyChecker" selector="testPreferredGrowthIncrementIsNotTooLarge">testPreferredGrowthIncrementIsNotTooLarge	self evaluateTestMethod: [super testPreferredGrowthIncrementIsNotTooLarge]</body><body package="MemoryPolicyChecker" selector="testPreferredGrowthIncrementLargerThanMinimumGranularity">testPreferredGrowthIncrementLargerThanMinimumGranularity	self evaluateTestMethod: [super testPreferredGrowthIncrementLargerThanMinimumGranularity]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - free memory upper bound</category><body package="MemoryPolicyChecker" selector="testFreeMemoryUpperBoundIsLargeEnough">testFreeMemoryUpperBoundIsLargeEnough	self evaluateTestMethod: [super testFreeMemoryUpperBoundIsLargeEnough]</body><body package="MemoryPolicyChecker" selector="testFreeMemoryUpperBoundIsNotTooLarge">testFreeMemoryUpperBoundIsNotTooLarge	self evaluateTestMethod: [super testFreeMemoryUpperBoundIsNotTooLarge]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - redefinitions</category><body package="MemoryPolicyChecker" selector="testTestSelectors">testTestSelectors	"PotentialMemoryPolicyChecker should redefine all the inherited test methods	so they run with various memory upper bound values.  This is not an ideal	solution, but vanilla-SUnit tests are strongly desirable for this application"	self assert:		(PotentialMemoryPolicyChecker testSelectors asSet remove: #testTestSelectors; yourself)			= AbstractMemoryPolicyChecker testSelectors asSet</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - sizes at startup</category><body package="MemoryPolicyChecker" selector="testOldSpaceHeadroom">testOldSpaceHeadroom	self evaluateTestMethod: [super testOldSpaceHeadroom]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - growth regime upper bound</category><body package="MemoryPolicyChecker" selector="testGrowthRegimeUpperBoundIsLargeEnough">testGrowthRegimeUpperBoundIsLargeEnough	self evaluateTestMethod: [super testGrowthRegimeUpperBoundIsLargeEnough]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - preferred fixed growth increment</category><body package="MemoryPolicyChecker" selector="testPreferredFixedGrowthIncrementIsLargeEnough">testPreferredFixedGrowthIncrementIsLargeEnough	self evaluateTestMethod: [super testPreferredFixedGrowthIncrementIsLargeEnough]</body><body package="MemoryPolicyChecker" selector="testPreferredFixedGrowthIncrementIsNotTooLarge">testPreferredFixedGrowthIncrementIsNotTooLarge	self evaluateTestMethod: [super testPreferredFixedGrowthIncrementIsNotTooLarge]</body></methods><methods><class-id>MediumGrainMemoryPolicyChecker</class-id> <category>setup</category><body package="MemoryPolicyChecker" selector="memoryPolicy">memoryPolicy	^MediumGrainMemoryPolicy new</body></methods><methods><class-id>CurrentMemoryPolicyChecker</class-id> <category>testing - soft and hard limits</category><body package="MemoryPolicyChecker" selector="testCurrentHardLowSpaceLimitIsSufficient">testCurrentHardLowSpaceLimitIsSufficient	self		assert: self minimumHardLowSpaceLimit &lt;= self currentHardLowSpaceLimit		description: 'The hard low space limit is not high enough to prevent scavenger failure'</body><body package="MemoryPolicyChecker" selector="testCurrentSoftLowSpaceHigherThanHardLowSpace">testCurrentSoftLowSpaceHigherThanHardLowSpace	"Under some circumstances, the soft low space limit	may be zero, thus lower than the hard low space limit"	self currentSoftLowSpaceLimit = 0 ifTrue: [^self].	self		assert: self currentSoftLowSpaceLimit &gt; self currentHardLowSpaceLimit		description: 'The soft low space limit should be higher than the hard low space limit'</body><body package="MemoryPolicyChecker" selector="testInitialHardLowSpaceLimitIsSufficient">testInitialHardLowSpaceLimitIsSufficient	self		assert: self minimumHardLowSpaceLimit &lt;= self initHardLowSpaceLimit		description: 'The hard low space limit is not high enough to prevent scavenger failure'</body><body package="MemoryPolicyChecker" selector="testInitialSoftLowSpaceHigherThanHardLowSpace">testInitialSoftLowSpaceHigherThanHardLowSpace	"Under some circumstances, the soft low space limit	may be zero, thus lower than the hard low space limit"	self initSoftLowSpaceLimit = 0 ifTrue: [^self].	self		assert: self initSoftLowSpaceLimit &gt; self initHardLowSpaceLimit		description: 'The soft low space limit should be higher than the hard low space limit'</body><body package="MemoryPolicyChecker" selector="testNewHardLowSpaceLimitIsSufficient">testNewHardLowSpaceLimitIsSufficient	self		assert: self minimumHardLowSpaceLimit &lt;= self newHardLowSpaceLimit		description: 'The hard low space limit is not high enough to prevent scavenger failure'</body><body package="MemoryPolicyChecker" selector="testNewSoftLowSpaceHigherThanHardLowSpace">testNewSoftLowSpaceHigherThanHardLowSpace	"Under some circumstances, the soft low space limit	may be zero, thus lower than the hard low space limit"	self newSoftLowSpaceLimit = 0 ifTrue: [^self].	self		assert: self newSoftLowSpaceLimit &gt; self newHardLowSpaceLimit		description: 'The soft low space limit should be higher than the hard low space limit'</body></methods><methods><class-id>MemoryPolicyChecker</class-id> <category>setup</category><body package="MemoryPolicyChecker" selector="memoryPolicy">memoryPolicy	^MemoryPolicy new</body></methods><methods><class-id>MemoryPolicyChecker</class-id> <category>testing - preferred fixed growth increment</category><body package="MemoryPolicyChecker" selector="testPreferredFixedGrowthIncrementIsLargeEnough">testPreferredFixedGrowthIncrementIsLargeEnough	"The legacy memory policy does not have a preferred fixed growth increment"	^self</body><body package="MemoryPolicyChecker" selector="testPreferredFixedGrowthIncrementIsNotTooLarge">testPreferredFixedGrowthIncrementIsNotTooLarge	"The legacy memory policy does not have a preferred fixed growth increment"	^self</body></methods><methods><class-id>LargeGrainMemoryPolicyChecker</class-id> <category>setup</category><body package="MemoryPolicyChecker" selector="memoryPolicy">memoryPolicy	^LargeGrainMemoryPolicy new</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>