<?xml version="1.0"?><st-source><!-- Name: RBSUnitExtensionsNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This package adds an extension to the Source code tool. Whenever a test case is selected, it allows you to run that test case from the browser.DbIdentifier: bear73DbTrace: 311735DevelopmentPrerequisites: #(#(#any 'Browser-BrowserUI' '') #(#any 'SUnit' ''))PackageName: RBSUnitExtensionsParcel: #('RBSUnitExtensions')ParcelName: RBSUnitExtensionsPrerequisiteParcels: #(#('Browser-BrowserUI' '') #('SUnit' ''))PrintStringCache: (7.8 - 1003,smichael)Version: 7.8 - 1003Date: 7:04:46 AM December 3, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (dec10.1) of December 3, 2010 on December 3, 2010 at 7:04:46 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SUnitStatusBar</name><environment>Refactory.Browser</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCount result codeModel </inst-vars><class-inst-vars></class-inst-vars><imports>			private XProgramming.SUnit.*			</imports><category>Browser-Code Tools</category><attributes><package>RBSUnitExtensions</package></attributes></class><comment><class-id>Refactory.Browser.SUnitStatusBar</class-id><body>This adds a panel to the Refactoring Browser CodeTool.  The tool allows Run, Debug, or Profile of concrete subclasses of TestCase, by single or multi-select of individual test selectors, classes, protocols, packages, parcels or categories.  The tool obeys the #isAbstract and #shouldInheritSelectors directives on individual classes, allowing a concrete class to inherit either all or none of the test selectors in its superclass hierarchy (up to, but not including TestCase).Note that the test selector inheritance feature of the TestCase class is, contrary to standard Smalltalk expectations, NOT automatic.  A class must explicitly specify that it is to be considered an abstract test case (#isAbstract) or that, as a concrete class, it wishes to inherit tests from its superclasses (#shouldInheritSelectors).  The directive #shouldInheritSelectors is meaningless (and ignored) for abstract test cases, since their test selectors cannot be run directly from the abstract class.Instance Variables	codeModel		&lt;CodeModel&gt;	the code model of the tool to which this is added	result			&lt;TestResult&gt;	the result returned by the latest run	testCount		&lt;Integer&gt;		the number of tests remaining to run</body></comment><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>private</category><body package="RBSUnitExtensions" selector="canHaveTests:">canHaveTests: aClass	^(aClass inheritsFrom: TestCase) and: [aClass isAbstract not]</body><body package="RBSUnitExtensions" selector="classTestCases">classTestCases	"Answer all runnable test cases for the selected class or classes.  Since object names are ordered in NavigatorState (for normal modes of populating at least, regardless of the order the user selects them in the RB UI), these tests will be in class alphabetic order if selected in an alphabetically-ordered pane and in hierarchic order if selected in a hierarchic pane;  either way, the order will be the same as that presented to the user, which seems correct)."	^self testCasesFor: codeModel selectedClasses.</body><body package="RBSUnitExtensions" selector="protocolTestCases">protocolTestCases	"Answer all runnable test cases for the selected protocol or protocols."	| theClass protocolSelectors |	theClass := codeModel selectedClass.	theClass ifNil: [^OrderedCollection new].	(self canHaveTests: theClass) ifFalse: [^OrderedCollection new].	protocolSelectors := codeModel protocols inject: Set new into:		[:sum :protocol |		sum addAll: (codeModel environment selectorsFor: protocol in: theClass).		theClass shouldInheritSelectors ifTrue: 			[| pivot | pivot := theClass.			[pivot == pivot lookupHierarchyRoot] whileFalse:				[pivot := pivot superclass.				sum addAll: (codeModel environment selectorsFor: protocol in: pivot)]].		sum].	^(self testCasesFor: (Array with: theClass))		select: [:each | protocolSelectors includes: each selector]</body><body package="RBSUnitExtensions" selector="pundleTestCases">pundleTestCases	"Show all inherited test cases of defined classes and all directly defined test cases whose methods are defined by the selected pundles or are inherited from a method defined in the same pundle.  Present tests in the order in which they appear to the user, i.e. sorted by class name and selector name."	| testCases |	testCases := Set new.	codeModel pundles do:		[:eachPundle |		eachPundle leafItems do:			[:eachLeaf |			eachLeaf definedClasses do:				[:eachClass |				(self canHaveTests: eachClass) ifTrue:					[self testClass: eachClass definedIn: eachLeaf						testSelectorsDo: [:eachSel | testCases add: (eachClass selector: eachSel)]]].			eachLeaf extendedClasses do:				[:eachClass |				(self canHaveTests: eachClass) ifTrue:					[self testClass: eachClass extendedIn: eachLeaf						testSelectorsDo: [:eachSel | testCases add: (eachClass selector: eachSel)]]]]].	^testCases asSortedCollection</body><body package="RBSUnitExtensions" selector="pundleTestCasesExist">pundleTestCasesExist	"Answer if runnable test cases exist in classes in the selected pundle or pundles."	^codeModel pundles anySatisfy:		[:any |		self testCasesExistInAny: any definedClasses]</body><body package="RBSUnitExtensions" selector="selectorTestCases">selectorTestCases	"Answer all runnable test cases for the selected selectors.  (For RB performance, we drop out if the class of the first selected method is not a concrete test class, but if it is, we get the tests for all classes.)"	| classesAndAllTestSelectors |	(self canHaveTests: codeModel selectedClass) ifFalse: [^OrderedCollection new].	classesAndAllTestSelectors := IdentityDictionary new.	^(codeModel definitions select:		[:each |		each isForSharedVariable not and:			[each method notNil and:				[(classesAndAllTestSelectors					at: each inheritingClass					ifAbsentPut:						[(self canHaveTests: each inheritingClass)							ifFalse: [#()]							ifTrue: [each inheritingClass allTestSelectors]])					includes: each selector]]])		collect: [:each | each inheritingClass selector: each selector]</body><body package="RBSUnitExtensions" selector="setFailedLabel">setFailedLabel	self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed').	self updateForFailed</body><body package="RBSUnitExtensions" selector="setLabelColor:">setLabelColor: aColorValue	| label |	label := self labelWidget.	label		lookPreferences: (label lookPreferences backgroundColor: aColorValue)</body><body package="RBSUnitExtensions" selector="setPassedLabel">setPassedLabel	self setTestLabel: (#Passed &lt;&lt; #browser &gt;&gt; 'Passed').	self updateForPassed</body><body package="RBSUnitExtensions" selector="testCases">testCases	codeModel selector notNil ifTrue: [^self selectorTestCases].	codeModel protocol notNil ifTrue: [^self protocolTestCases].	codeModel selectedClass notNil ifTrue: [^self classTestCases].	codeModel pundle notNil ifTrue: [^self pundleTestCases].	^#()</body><body package="RBSUnitExtensions" selector="testCasesExistInAny:">testCasesExistInAny: classesCollection	"Answer if there are any concrete test cases in the classes listed in the argument."	^classesCollection anySatisfy:		[:any | self canHaveTests: any]</body><body package="RBSUnitExtensions" selector="testCasesFor:">testCasesFor: classesCollection	"Show all inherited test cases of classes defined in the selected pundles and all directly defined test cases whose methods are defined by the selected pundles or are inherited from a method defined in the same pundle.  Present tests in the order in which they appear to the user, i.e. sorted by class name (caller povides list in that order) and selector name."	| testCases leaves |	testCases := Set new.	leaves := codeModel pundles inject: Set new into:		[:sum :each | sum addAll: each leafItems; yourself].	classesCollection do:		[:eachClass || testSelectors | testSelectors := IdentitySet new.		(self canHaveTests: eachClass) ifTrue:			[leaves do:				[:eachLeaf |				(eachLeaf definesClass: eachClass)					ifTrue:						[self testClass: eachClass definedIn: eachLeaf							testSelectorsDo: [:eachSel | testSelectors add: eachSel]]					ifFalse:						[self testClass: eachClass extendedIn: eachLeaf							testSelectorsDo: [:eachSel | testSelectors add: eachSel]]].			testCases addAll:				(testSelectors asSortedCollection collect: [:eachSel | eachClass selector: eachSel])]].	^testCases</body><body package="RBSUnitExtensions" selector="testClass:definedIn:testSelectorsDo:">testClass: aClass definedIn: aPackageModel testSelectorsDo: aBlock	aClass allTestSelectors removeAll: aClass testSelectors; do: aBlock.	aClass testSelectors do:		[:eachSel |		(aPackageModel includesSelector: eachSel class: aClass) ifTrue:			[aBlock value: eachSel]].</body><body package="RBSUnitExtensions" selector="testClass:extendedIn:testSelectorsDo:">testClass: aClass extendedIn: aPackageModel testSelectorsDo: aBlock	aClass allTestSelectors removeAll: aClass testSelectors; do:		[:eachSel |		(aPackageModel			includesSelector: eachSel			class: (aClass whichClassIncludesSelector: eachSel)) ifTrue:				[aBlock value: eachSel]].	aClass testSelectors do:		[:eachSel |		(aPackageModel includesSelector: eachSel class: aClass) ifTrue:			[aBlock value: eachSel]].</body><body package="RBSUnitExtensions" selector="updateForAbstract">updateForAbstract	self setLabelColor: nil</body><body package="RBSUnitExtensions" selector="updateForFailed">updateForFailed	self setLabelColor: ColorValue red</body><body package="RBSUnitExtensions" selector="updateForNotRun">updateForNotRun	self setLabelColor: nil</body><body package="RBSUnitExtensions" selector="updateForPassed">updateForPassed	self setLabelColor: ColorValue green.	result := nil.</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>initialize-release</category><body package="RBSUnitExtensions" selector="actionDriver:">actionDriver: anActionSelector	^(PluggableAdaptor on: false asValue)		getBlock: [:m | m value]		putBlock: [:m :v | self perform: anActionSelector]		updateBlock: [:m :a :p | true]</body><body package="RBSUnitExtensions" selector="addButtons">addButtons	| button |	#(#runDefects #listDefects #profileTests #debugTests #runTests)		with: #('Run Defects' 'List Defects' 'Profile' 'Debug' 'Run')		do:			[:action :label | 			button := self lookPolicy actionButtonClass model: (self actionDriver: action).			button labelString: action &gt;&gt; label &lt;&lt; #browser.			self add: button].	self children last beDefault</body><body package="RBSUnitExtensions" selector="addLabel">addLabel	| label |	label := self lookPolicy passiveLabelClass new.	label widgetState isOpaque: true.	self add: ((WidgetWrapper on: label) widget: label)</body><body package="RBSUnitExtensions" selector="buttonCount">buttonCount	^self children size - 1 max: 0</body><body package="RBSUnitExtensions" selector="codeModel:">codeModel: aCodeModel	codeModel := aCodeModel</body><body package="RBSUnitExtensions" selector="initialize">initialize	super initialize.	self setLayout.	self addLabel.	self addButtons.	self setDesiredHeight.	self propertyAt: #row put: -1</body><body package="RBSUnitExtensions" selector="setDesiredHeight">setDesiredHeight	| maxHeight |	maxHeight := (self children collect: [:each | each preferredBounds height])		fold: [:a :b | a max: b].	self propertyAt: #desiredHeight put: maxHeight</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>testing</category><body package="RBSUnitExtensions" selector="canRunTests">canRunTests	^self isAbstractClassSelected not and: [self testCasesExist]</body><body package="RBSUnitExtensions" selector="codeComponentIncludesTest:">codeComponentIncludesTest: aCodeComponent 	^aCodeComponent definedClasses anySatisfy: [:each | each inheritsFrom: TestCase]</body><body package="RBSUnitExtensions" selector="defectsExist">defectsExist	^result notNil and: [result hasPassed not]</body><body package="RBSUnitExtensions" selector="hasTestsSelected">hasTestsSelected	(codeModel selectedClasses 		anySatisfy: [:each | each inheritsFrom: TestCase]) ifTrue: [^true].	codeModel objectNames notEmpty ifTrue: [^false].	(codeModel parcels 		anySatisfy: [:each | self codeComponentIncludesTest: each]) ifTrue: [^true].	^codeModel pundles 		anySatisfy: [:each | self codeComponentIncludesTest: each]</body><body package="RBSUnitExtensions" selector="isAbstractClassSelected">isAbstractClassSelected	^codeModel selectedClass notNil		and:			[(codeModel selectedClass respondsTo: #isAbstract)				and: [codeModel selectedClass isAbstract]]</body><body package="RBSUnitExtensions" selector="isProfilerLoaded">isProfilerLoaded	#{TimeProfiler} valueOrDo: [^false].	^true</body><body package="RBSUnitExtensions" selector="shouldNotRunTests">shouldNotRunTests	^self canRunTests not</body><body package="RBSUnitExtensions" selector="testCasesExist">testCasesExist	codeModel selector notNil ifTrue: [^self selectorTestCases notEmpty].	codeModel protocol notNil ifTrue: [^self protocolTestCases notEmpty].	codeModel selectedClass notNil ifTrue: [^self classTestCases notEmpty].	codeModel pundle notNil ifTrue: [^self pundleTestCasesExist].	^false</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>updating</category><body package="RBSUnitExtensions" selector="debugButton">debugButton	^self children at: 5</body><body package="RBSUnitExtensions" selector="listDefectsButton">listDefectsButton	^self children at: 3</body><body package="RBSUnitExtensions" selector="profileButton">profileButton	^self children at: 4</body><body package="RBSUnitExtensions" selector="runButton">runButton	^self children at: 6</body><body package="RBSUnitExtensions" selector="runDefectsButton">runDefectsButton	^self children at: 2</body><body package="RBSUnitExtensions" selector="setTestLabel:">setTestLabel: aString	| widget |	widget := self labelWidget.	widget widget labelString: aString.	widget repairDamage</body><body package="RBSUnitExtensions" selector="touch">touch	self		updateTestLabel;		updateButtons;		updateIsActive</body><body package="RBSUnitExtensions" selector="update:with:from:">update: aspectSymbol with: parameter from: sender	(testCount notNil and: [testCount &gt; 0]) ifTrue:		[testCount := testCount - 1.		self setTestLabel: ((#TestsRemaining1p &lt;&lt; #browser &gt;&gt; 'Tests Remaining : &lt;1p&gt;') expandMacrosWith: testCount)].</body><body package="RBSUnitExtensions" selector="updateButtons">updateButtons	self		updateRunButtons;		updateDefectButtons</body><body package="RBSUnitExtensions" selector="updateDefectButtons">updateDefectButtons	| enable |	enable := self defectsExist.	self runDefectsButton isEnabled: enable.	self listDefectsButton isEnabled: enable</body><body package="RBSUnitExtensions" selector="updateIsActive">updateIsActive	| isCurrentlyActive |	isCurrentlyActive := self canRunTests.	isCurrentlyActive = (self propertyAt: #isActive) ifTrue: [^self].	self propertyAt: #isActive put: isCurrentlyActive.	self changedPreferredBounds: nil</body><body package="RBSUnitExtensions" selector="updateRunButtons">updateRunButtons	| canRun |	canRun := self canRunTests.	self profileButton isEnabled: (canRun and: [self isProfilerLoaded]).	self debugButton isEnabled: canRun.	self runButton isEnabled: canRun</body><body package="RBSUnitExtensions" selector="updateTestLabel">updateTestLabel	| label |	self isAbstractClassSelected		ifTrue: [ 			self updateForAbstract.			label := (#NotRunAbstractTest &lt;&lt; #browser &gt;&gt; 'Abstract test class, cannot run') ] 		ifFalse: [			self updateForNotRun.			label := (#NotRunC1pTests &lt;&lt; #browser &gt;&gt; 'Not run: &lt;1p&gt; tests') 							expandMacrosWith: self testCases size ].	self setTestLabel: label</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>accessing</category><body package="RBSUnitExtensions" selector="labelWidget">labelWidget	^components first</body><body package="RBSUnitExtensions" selector="lookPolicy">lookPolicy	^self widgetPolicy lookPolicyClass new</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>displaying</category><body package="RBSUnitExtensions" selector="displayOn:">displayOn: aGC	self canRunTests ifTrue: [super displayOn: aGC]</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>actions</category><body package="RBSUnitExtensions" selector="debugTests">debugTests	| failed |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Debugging &lt;&lt; #browser &gt;&gt; 'Debugging').	failed := false.	testCount := self testCases size.	[[self testCases do: 		[:each | 		each debug.			(testCount notNil and: [testCount &gt; 0]) ifTrue:			[testCount := testCount - 1.			self setTestLabel: ((#TestsRemaining1p &lt;&lt; #browser&gt;&gt; 'Tests Remaining : &lt;1p&gt;') expandMacrosWith: testCount)]]] 		on: TestResult failure , TestResult error		do: 			[:ex | 			failed := true.			ex pass]] 			ifCurtailed: [self setFailedLabel].	failed ifTrue: [self setFailedLabel] ifFalse: [self setPassedLabel]</body><body package="RBSUnitExtensions" selector="listDefects">listDefects	self defectsExist ifTrue:		[self spawnTestResult: result].</body><body package="RBSUnitExtensions" selector="profileTests">profileTests	| profiler |	profiler := #{TimeProfiler} valueOrDo: [nil].	profiler isNil 		ifTrue: [^Dialog warn: (#ProfilerNotLoadedLoad &lt;&lt; #browser &gt;&gt; 'Profiler not loaded. Load the "AT Profiling" parcel.')].	profiler profile: [self runTests]</body><body package="RBSUnitExtensions" selector="runDefects">runDefects	| suite |	self defectsExist ifFalse: [^self].	suite := TestSuite new.	result errors do: [:each | suite addTest: each].	result failures do: [:each | suite addTest: each].	self runSuite: suite.</body><body package="RBSUnitExtensions" selector="runSuite:">runSuite: aTestSuite	"Currently, for all my callers, aTestSuite is necessarily a flat suite of test cases by construction;  if this changes, generalise the first line to give the right number of tests in the suite."	testCount := aTestSuite tests size.	aTestSuite addDependent: self.	[result := aTestSuite run] ifCurtailed: [result := nil].	self setTestLabel: (result isNil		ifTrue: [#TestRunWasCurtalled &lt;&lt; #browser &gt;&gt; 'Test run was curtailed']		ifFalse: [result displayString]).	codeModel navigate.	self defectsExist		ifFalse: [self updateForPassed]		ifTrue: [self updateForFailed].	self updateDefectButtons.</body><body package="RBSUnitExtensions" selector="runTests">runTests	| suite |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Running &lt;&lt; #browser &gt;&gt; 'Running').	suite := TestSuite new.	self testCases do: [:each | suite addTest: each].	self runSuite: suite.</body><body package="RBSUnitExtensions" selector="spawnTestResult:">spawnTestResult: aTestResult	| env |	env := MethodDefinitionEnvironment new.	aTestResult defects do: [:each | env addDefinition: each asDefinition].	env openEditor.</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>private-layout</category><body package="RBSUnitExtensions" selector="boxForButtonAt:in:">boxForButtonAt: index in: rectangle	| width |	width := self buttonWidthIn: rectangle.	^(rectangle right - ((self children size - index + 1) * width))		@ rectangle top extent: width @ rectangle height</body><body package="RBSUnitExtensions" selector="boxForLabelIn:">boxForLabelIn: rectangle	^rectangle origin		corner:			(rectangle right - (self buttonCount * (self buttonWidthIn: rectangle)))				@ rectangle bottom</body><body package="RBSUnitExtensions" selector="buttonWidthIn:">buttonWidthIn: aRectangle	| width |	aRectangle width isZero ifTrue: [^0].	width := self defaultButtonWidth.	width * self children size &gt; aRectangle width		ifTrue: [^aRectangle width / self children size].	^width</body><body package="RBSUnitExtensions" selector="defaultButtonWidth">defaultButtonWidth	^(self children allButFirst: 1)		inject: 0		into: [:accum :each | accum max: each preferredBounds width]</body><body package="RBSUnitExtensions" selector="setLayout">setLayout	self		childFramingBlock:			[:rectangle :child :index | 			index = 1				ifTrue: [self boxForLabelIn: rectangle]				ifFalse: [self boxForButtonAt: index in: rectangle]]</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>accessing</category><body package="RBSUnitExtensions" selector="initialMethodCategory">initialMethodCategory		^#testing</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>testing</category><body package="RBSUnitExtensions" selector="needsComment">needsComment		^false</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>comparing</category><body package="RBSUnitExtensions" selector="&lt;=">&lt;= aTestCase		^self class name = aTestCase class name		ifTrue: [testSelector &lt;= aTestCase selector]		ifFalse: [self class name &lt;= aTestCase class name]</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>converting</category><body package="RBSUnitExtensions" selector="asDefinition">asDefinition	"VW-specific, so defined here, not in base SUnit."	^(MethodDefinition class: self class selector: testSelector) resolve</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>printing</category><body package="RBSUnitExtensions" selector="displayString">displayString	^#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'		expandMacrosWith: self hasPassed		with: self runCount		with: self failureCount		with: self errorCount</body></methods><methods><class-id>Refactory.Browser.CodeModel class</class-id> <category>status parts</category><body package="RBSUnitExtensions" selector="sunitStatusBarClass">sunitStatusBarClass	&lt;status&gt;	^SUnitStatusBar</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestResult</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failures errors passed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>Panel</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layoutAlgorithm isInUpdate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Graphics-Visual Objects</package></attributes></class></st-source>