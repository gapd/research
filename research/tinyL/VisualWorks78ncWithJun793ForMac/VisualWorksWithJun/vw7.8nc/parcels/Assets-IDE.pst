<?xml version="1.0"?><st-source><!-- Name: Assets-IDENotice: Copyright © 2007 Cincom Systems, Inc.  All Rights Reserved.Comment: This package is meant to be used by a developer to build up and maintain Assets subclasses using the Smalltalk IDE. It provides a menu options in the browser's class menu for importing and synchronizing assets via directory selection.The package is separated from the core Assets package so that the external file importing/syncing behavior is not something a normal application needs to require as a prerequisite.The package extends the IDE to show one additional menu items:- "Sync Assets"This menu item is in the Class Menu. It will show up (i.e. it is completely hidden, not just disabled) only when Assets classes are selected. To begin importing your assets, create a subclass of Assets, select it and invoke 'Sync Assets' from the Class Menu.  If this is the first time you've synced it, it will prompt you for a directory to import from. After the first time, it will remember the directory for future syncing. Sync'ing involves checking the file's md5sum against what is stored in the method. If it does not match, the method is regenerated so that the once block again produces an object consistent with that of the file. In the event that a directory is synced against, there are asset methods for which no file was found, the user will be given the chance to remove these or let them stay.DbIdentifier: bear73DbTrace: 280757DevelopmentPrerequisites: #(#(#any 'Assets' '') #(#any 'ImageReaders' '') #(#any 'MD5' '') #(#any 'HashesBase' '') #(#any 'Browser-BrowserUI' ''))PackageName: Assets-IDEParcel: #('Assets-IDE')ParcelName: Assets-IDEPrerequisiteParcels: #(#('Assets' '') #('ImageReaders' '') #('MD5' '') #('HashesBase' '') #('Browser-BrowserUI' ''))PrintStringCache: (7.7.1 - 1,BaseSystem)Version: 7.7.1 - 1Date: 3:25:12 AM May 3, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.7.1 (apr10.4) of May 3, 2010 on May 3, 2010 at 3:25:12 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SpecificAssetImport</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>assetClass file </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Assets-IDE</package></attributes></class><comment><class-id>Tools.SpecificAssetImport</class-id><body>I am used to reflect about and manage an individual resource file. I provide support for filtering valid imports, checking if they are up to date, stubbing the initial method, computing the selector names, etc.Instance Variables:	assetClass	&lt;Assets&gt;	which class to define the asset for	file &lt;String&gt;   	the file (tail only) to be integrated</body></comment><class><name>ImportProgressOverlay</name><environment>Refactory.Browser</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label progress buffer mask </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Assets-IDE</category><attributes><package>Assets-IDE</package></attributes></class><comment><class-id>Refactory.Browser.ImportProgressOverlay</class-id><body>I am a temporary view that gets added on the top of the browser's view stack when the import operation is running.</body></comment><methods><class-id>Tools.SpecificAssetImport</class-id> <category>accessing</category><body package="Assets-IDE" selector="assetClass">assetClass	^assetClass</body><body package="Assets-IDE" selector="assetMethod">assetMethod	^assetClass class compiledMethodAt: self assetSelector</body><body package="Assets-IDE" selector="assetSelector">assetSelector	^self needsSpecialSelector 		ifTrue: [('_' , self idealAssetSelector) asSymbol]		ifFalse: [self idealAssetSelector]</body><body package="Assets-IDE" selector="compileImport">compileImport	| specificSource |	specificSource := assetClass perform: self importSelector				with: self fullFilename.	assetClass class compile: (self genericSourceAround: specificSource)</body><body package="Assets-IDE" selector="file">file	^file</body><body package="Assets-IDE" selector="fileExtension">fileExtension	"Return the file extension (all characters AFTER the last dot) of the file ivar. Leading and trailing dots don't count."	| dot |	dot := file lastIndexOf: $..	(dot &lt; file size and: [dot &gt; 1]) ifFalse: [^nil].	^(file allButFirst: dot) asLowercase</body><body package="Assets-IDE" selector="fullFilename">fullFilename	^(self assetClass getLastDirectory: nil) construct: file</body><body package="Assets-IDE" selector="idealAssetSelector">idealAssetSelector	"Return a selector that is mapped to the file name. Make sure we don't map to an infrastructure method."	| dot string |	dot := file lastIndexOf: $..	string := file first: dot - 1.	string first isDigit ifTrue: [string := '_' , string].	^(string 		collect: [:char | char isAlphaNumeric ifTrue: [char] ifFalse: [$_]]) 			asSymbol</body><body package="Assets-IDE" selector="importSelector">importSelector	"Determine the candidate method to be used to import a file of the type in aFilepath, don't actually worry about whether  the import method exists or not. Return nil if there is no extension."	^self fileExtension ifNotNil: [:type | ('import_' , type , ':') asSymbol]</body><body package="Assets-IDE" selector="sync">sync	self isSynced ifFalse: [self compileImport]</body><body package="Assets-IDE" selector="value">value	^self assetClass perform: self assetSelector</body></methods><methods><class-id>Tools.SpecificAssetImport</class-id> <category>initialize-release</category><body package="Assets-IDE" selector="assetClass:">assetClass: anAssetsClass 	assetClass := anAssetsClass</body><body package="Assets-IDE" selector="file:">file: aFiletail 	file := aFiletail</body></methods><methods><class-id>Tools.SpecificAssetImport</class-id> <category>private</category><body package="Assets-IDE" selector="currentResourceHash">currentResourceHash	"Return md5sum for the resource file associated with the asset named aSymbol. Return nil if no file is found."	| rs |	^(self fullFilename)		ifNotNil:			[:fullPath | 			fullPath definitelyExists				ifTrue:					[rs := fullPath readStream.					rs binary.					[Security.MD5 hashFrom: rs] ensure: [rs close]]				ifFalse: [nil]]</body><body package="Assets-IDE" selector="genericSourceAround:">genericSourceAround: aSourceString 	"Emit source code for aSymbol. Update the housekeeping tags and wrap a once block around specificSource."	^'&lt;1s&gt;	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	%&lt;file: &lt;2p&gt;&gt;	%&lt;md5sum: &lt;3p&gt;&gt;	^[&lt;4s&gt;] once' 		expandMacrosWith: self assetSelector		with: self file		with: self currentResourceHash		with: aSourceString</body><body package="Assets-IDE" selector="md5Tag">md5Tag	^Pragma named: #md5sum: inMethod: self assetMethod</body><body package="Assets-IDE" selector="rememberedHash">rememberedHash	^self md5Tag ifNotNil: [:tag | tag arguments first]</body><body package="Assets-IDE" selector="stubChange">stubChange	^Refactory.Browser.AddMethodChange 		compile: self stubSource		in: assetClass classBehavior		classified: self fileExtension , ' imports'</body><body package="Assets-IDE" selector="stubSource">stubSource	"Return the source code that would be used to initially define this method if it doesn't exist yet."	^'&lt;1s&gt;	%&lt;file: &lt;2p&gt;&gt;	^self error: ''This asset not integrated yet''' 		expandMacrosWith: self assetSelector		with: file</body></methods><methods><class-id>Tools.SpecificAssetImport</class-id> <category>testing</category><body package="Assets-IDE" selector="isDefined">isDefined	^assetClass respondsTo: self assetSelector</body><body package="Assets-IDE" selector="isSynced">isSynced	"If we can find the resource file, determine whether we're synced against it. Though somewhat fallacious, we term the case where the resource file cannot be currently located as 'synced'."	^self currentResourceHash		ifNil: [true]		ifNotNil: [:fileHash | self rememberedHash = fileHash]</body><body package="Assets-IDE" selector="isValid">isValid	"Will I even be something that my Assets class wishes or knows how to import?"	^file first ~= $.		and:			[self importSelector				ifNotNil: [:selector | assetClass respondsTo: selector]				ifNil: [false]]</body><body package="Assets-IDE" selector="needsSpecialSelector">needsSpecialSelector	^(Assets class whichClassIncludesSelector: self idealAssetSelector) notNil</body></methods><methods><class-id>Tools.SpecificAssetImport class</class-id> <category>instance creation</category><body package="Assets-IDE" selector="asset:file:">asset: anAssetsClass file: aFiletail 	^(self new)		assetClass: anAssetsClass;		file: aFiletail</body></methods><methods><class-id>Refactory.Browser.ImportProgressOverlay</class-id> <category>bounds accessing</category><body package="Assets-IDE" selector="endRadius">endRadius	^30</body><body package="Assets-IDE" selector="halfChordWidth">halfChordWidth	^150</body><body package="Assets-IDE" selector="preferredBounds">preferredBounds	^Screen default bounds</body></methods><methods><class-id>Refactory.Browser.ImportProgressOverlay</class-id> <category>initialize-release</category><body package="Assets-IDE" selector="initialize">initialize	super initialize.	progress := 0.</body></methods><methods><class-id>Refactory.Browser.ImportProgressOverlay</class-id> <category>displaying</category><body package="Assets-IDE" selector="buffer">buffer	(buffer notNil and: [buffer isOpen]) ifTrue: [^buffer].	buffer := Pixmap extent: self halfChordWidth @ self endRadius * 2.	^buffer</body><body package="Assets-IDE" selector="displayBackground:">displayBackground: aGC	| rectangle halfExtent center |	halfExtent := self halfChordWidth @ self endRadius.	center := self bounds center.	rectangle := center - halfExtent corner: center + halfExtent.	aGC paint: (ColorValue brightness: 0.1).	aGC		displayWedgeBoundedBy:				(rectangle leftCenter - halfExtent y					corner: rectangle leftCenter + halfExtent y)			startAngle: 90			sweepAngle: 180;		displayRectangle: (rectangle expandedBy: 1 @ 0);		displayWedgeBoundedBy:				(rectangle rightCenter - halfExtent y					corner: rectangle rightCenter + halfExtent y)			startAngle: 270			sweepAngle: 180</body><body package="Assets-IDE" selector="displayBuffer">displayBuffer	| gc |	gc := self buffer graphicsContext.	gc		paint: (ColorValue brightness: 0.2);		displayRectangle: self buffer bounds.	self displayProgress: gc.	self displayText: gc</body><body package="Assets-IDE" selector="displayOn:">displayOn: aGC	aGC		copyMaskedArea: self mask		fromPixelArray: self buffer		sourceOffset: Point zero		destinationOffset: (self bounds extent - self buffer extent) // 2</body><body package="Assets-IDE" selector="displayProgress:">displayProgress: gc	| angle |	gc		paint:			(ColorValue				hue: progress / 3				saturation: 1				brightness: 0.75).	angle := progress * 360.	gc		displayWedgeBoundedBy:			((Point zero corner: self endRadius asPoint * 2) insetBy: 5)		startAngle: 265 - angle		sweepAngle: angle</body><body package="Assets-IDE" selector="displayText:">displayText: aGC	label ifNil: [^self].	aGC		paint: (ColorValue brightness: 0.9);		display: label			at:				(self endRadius * 2 + 5) @ ((self buffer height - label height) // 2)</body><body package="Assets-IDE" selector="mask">mask	| gc |	(mask notNil and: [mask isOpen]) ifTrue: [^mask].	mask := Mask extent: self halfChordWidth @ self endRadius * 2.	mask background: CoverageValue transparent.	gc := mask graphicsContext.	gc paint: CoverageValue opaque.	gc		displayWedgeBoundedBy: (Point zero corner: self endRadius * 2)			startAngle: 0			sweepAngle: 360;		displayRectangle: (mask bounds insetBy: self endRadius @ 0);		displayWedgeBoundedBy:				((mask bounds width - (self endRadius * 2)) @ 0 corner: mask bounds corner)			startAngle: 0			sweepAngle: 360.	^mask</body><body package="Assets-IDE" selector="redisplay">redisplay	self isOpen ifFalse: [^self].	self displayBuffer.	self displayOn: self graphicsContext</body></methods><methods><class-id>Refactory.Browser.ImportProgressOverlay</class-id> <category>accessing</category><body package="Assets-IDE" selector="cleanUp">cleanUp	"Remove myself from my container. I'm assumed to be the last component of my topComponent."	self topComponent		ifNotNil:			[:window | window component remove: window component components last]</body><body package="Assets-IDE" selector="progress:">progress: aFraction	progress := aFraction.	self redisplay</body><body package="Assets-IDE" selector="text:">text: aText	label := Label		with: aText		attributes: (TextAttributes systemSized: 16).	self redisplay</body></methods><methods><class-id>Refactory.Browser.ImportProgressOverlay class</class-id> <category>instance creation</category><body package="Assets-IDE" selector="installOn:">installOn: aWindow 	"Place a new instance of me for temporary use as the last element in the windows component (assumed to be a CompositePart of some sort)."	| view |	view := self new.	aWindow component add: view in: (0 @ 0 corner: 1 @ 1).	^view</body></methods><methods><class-id>Graphics.Image</class-id> <category>editing utilitys</category><body package="Assets-IDE" selector="assetStoreString">assetStoreString	"It turns out that above about 16 unique colors we usually end up using more space storing the individual colors, rather than encoding them directly in the pixels."	| colors newPalette |	self depth = 1 ifTrue: [^self storeString].	colors := self uniqueColorValues.	newPalette := colors size &gt; 16		ifTrue: [FixedPalette rgb8Bit]		ifFalse: [MappedPalette withColors: colors asArray].	^(self copy convertToPalette: newPalette) storeString</body></methods><methods><class-id>Graphics.TextAttributes class</class-id> <category>instance creation</category><body package="Assets-IDE" selector="systemSized:">systemSized: anInteger 	"Return #system textAttributes with anInteger pixel size."	| style newQuery |	style := (self styleNamed: #pixelDefault) copy.	style setCharacterAttributes: style characterAttributes copy.	newQuery := (style characterAttributes defaultQueryFor: nil) copy.	newQuery pixelSize: anInteger.	style characterAttributes setDefaultQuery: newQuery.	style gridForFont: newQuery withLead: 0.	^style</body></methods><methods><class-id>Core.Assets class</class-id> <category>accessing</category><body package="Assets-IDE" selector="getLastDirectory:">getLastDirectory: ignored 	"We use a special selector to get this, so we can avoid cluttering up the unary message space which we want to leave as open as possible for asset selectors"	^lastDirectory</body></methods><methods><class-id>Core.Assets class</class-id> <category>import-types</category><body package="Assets-IDE" selector="import_bmp:">import_bmp: aFilename 	^self importImage: aFilename</body><body package="Assets-IDE" selector="import_gif:">import_gif: aFilename 	^self importMaskedImage: aFilename</body><body package="Assets-IDE" selector="import_jpeg:">import_jpeg: aFilename 	^self importImage: aFilename</body><body package="Assets-IDE" selector="import_jpg:">import_jpg: aFilename 	^self importImage: aFilename</body><body package="Assets-IDE" selector="import_png:">import_png: aFilename 	^self importMaskedImage: aFilename</body></methods><methods><class-id>Core.Assets class</class-id> <category>private-import-helpers</category><body package="Assets-IDE" selector="importBytes:">importBytes: aLogicalFile 	"This is not called by the default install, but is an example of another kind of import type."	| rs bytes ws |	rs := aLogicalFile readStream.	rs binary.	bytes := [rs contents] ensure: [rs close].	ws := String new writeStream.	ws nextPutAll: 'ByteArray fromNibbleString: '''.	bytes printNibblesOn: ws.	ws nextPut: $'.	^ws contents</body><body package="Assets-IDE" selector="importImage:">importImage: aLogicalFile	| reader |	reader := ImageReader fromFile: aLogicalFile.	^'CachedImage on: (&lt;1s&gt;)' expandMacrosWith: reader image assetStoreString</body><body package="Assets-IDE" selector="importMaskedImage:">importMaskedImage: aLogicalFile	| reader |	reader := ImageReader fromFile: aLogicalFile.	^'OpaqueImage			figure: (CachedImage on: (&lt;1s&gt;))			shape: (CachedImage on: (&lt;2s&gt;))'		expandMacrosWith: reader image assetStoreString		with: reader mask assetStoreString</body><body package="Assets-IDE" selector="importString:">importString: aLogicalFile 	"This is not called by the default install, but is an example of another kind of import type."	| rs string |	rs := aLogicalFile readStream.	rs lineEndAuto.	string := [rs contents] ensure: [rs close].	^string storeString</body></methods><methods><class-id>Core.Assets class</class-id> <category>accessing</category><body package="Assets-IDE" selector="lastDirectory:">lastDirectory: aDirectory	lastDirectory := aDirectory</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>private</category><body package="Assets-IDE" selector="checkForExtraneousAssets:">checkForExtraneousAssets: aCollectionOfImports	| stowaways victims change |	stowaways := self selectedClass classBehavior methodDictionary values				select: [:each | each attributeMessages anySatisfy: [:tag | tag selector = #file:]].	stowaways		removeAll: (aCollectionOfImports collect: [:each | each assetMethod]).	stowaways isEmpty ifTrue: [^self].	victims := self				promptForAssetMethodsToRemove: (stowaways						collect: [:each | each definition]) asSortedCollection.	victims isEmpty ifTrue: [^self].	change := CompositeRefactoryChange new.	victims		do: [:each | change removeMethod: each selector from: each implementingClass].	self performChange: change</body><body package="Assets-IDE" selector="isAssetClassSelected">isAssetClassSelected	^self selectedClass notNil 		and: [self selectedClass instanceBehavior includesBehavior: Assets]</body><body package="Assets-IDE" selector="promptForAssetMethodsToRemove:">promptForAssetMethodsToRemove: aSequenceOfMethodDefinitions 	| wrappers listModel dialog spec listWrapper resultHolder |	wrappers := OrderedCollection new.	listModel := MultiSelectionInList new.	listModel list: aSequenceOfMethodDefinitions.	dialog := SimpleDialog new.	spec := dialog interfaceSpecFor: #emptySpec.	dialog initializeBuilderFor: builder window.	(dialog builder)		add: spec window;		add: spec component.	dialog		initializeWindowFor: builder window;		setInitialGap;		addMessage: #AssetsNoLongerInDirectory &lt;&lt; #IDE					&gt;&gt; 'The following previously imported assetswere absent from the synced directory.'			centered: true;		addGap: 10.	listWrapper := dialog 				addMultiList: listModel				lines: 10				validation: [true].	listWrapper widget displayStringSelector: #selector.	dialog addGap: 5.	wrappers add: (dialog 				addLabels: (Array 						with: #AssetsRetainOrphans &lt;&lt; #IDE &gt;&gt; 'Let All Stay'						with: #AssetsRemoveSelectedOrphans &lt;&lt; #IDE &gt;&gt; 'Remove Selected'						with: #AssetsRemoveAllOrphans &lt;&lt; #IDE &gt;&gt; 'Remove All')				values: #(#letStay #removeSelected #removeAll)				default: #removeAll				storeInto: (resultHolder := #removeAll asValue)				takeKeyboard: true				equalize: true).	dialog addGap: 5.	dialog bottomAlignLowerEdge: listWrapper.	dialog bottomAlign: wrappers.	dialog preOpen.	dialog builder 		openDialogWithExtent: dialog builder window displayBox extent.	resultHolder value = #letStay ifTrue: [^Array new].	resultHolder value = #removeSelected ifTrue: [^listModel selections].	resultHolder value = #removeAll ifTrue: [^aSequenceOfMethodDefinitions].	self shouldNotImplement</body><body package="Assets-IDE" selector="setAssetsDirectory">setAssetsDirectory	| dialog currentDirectory |	currentDirectory := self selectedClass instanceBehavior getLastDirectory:			nil.	(InputState default shiftDown not		and: [currentDirectory notNil and: [currentDirectory isReadable]])		ifTrue: [^self].	dialog := ChooseDirectoryDialog new.	dialog		windowTitle:			#AssetsPickDirectory &lt;&lt; #IDE &gt;&gt;					'Choose directory which contains asset resource files'.	self selectedClass instanceBehavior lastDirectory: dialog select</body><body package="Assets-IDE" selector="syncAssets">syncAssets	| targetDirectory subFile imports change view lastUpdate |	self setAssetsDirectory.	(targetDirectory := self selectedClass instanceBehavior getLastDirectory:			nil) ifNil: [^self].	self selectClass: self selectedClass classBehavior.	imports := (targetDirectory directoryContents		select:			[:each | 			subFile := targetDirectory construct: each.			subFile isDirectory not and: [subFile isReadable]])		collect:			[:each | 			SpecificAssetImport				asset: self selectedClass instanceBehavior				file: each].	imports := imports select: [:each | each isValid].	view := ImportProgressOverlay installOn: builder window.	builder window component invalidateNow.	[change := CompositeRefactoryChange new.	imports		do: [:each | each isDefined ifFalse: [change addChange: each stubChange]].	change changesSize isZero		ifFalse:			[view text: #AssetsStubbing &lt;&lt; #IDE &gt;&gt; 'Creating initial imports...'.			self performChange: change].	lastUpdate := 0.	imports		keysAndValuesDo:			[:index :each | 			view text: (#AssetsSyncing &lt;&lt; #IDE &gt;&gt; 'Syncing &lt;1s&gt;' expandMacrosWith: each file).			each sync.			view progress: index asFloat / imports size].	view progress: 1.0.	self checkForExtraneousAssets: imports.	(Delay forMilliseconds: 60) wait] ensure: [view cleanUp].	self refreshLists</body></methods><methods><class-id>Tools.Pragma class</class-id> <category>instance creation</category><body package="Assets-IDE" selector="named:inMethod:">named: aTag inMethod: aCompiledCode	"Return a new instance of the receiver which can be used to reflect on the specific method tag named aTag. Return nil if there is none."	aCompiledCode attributeMessages		ifNotNil:			[:pragmaMessages | 			pragmaMessages				do:					[:pragmaMessage | 					pragmaMessage selector = aTag						ifTrue:							[^self new								message: pragmaMessage								methodDefinition: aCompiledCode definition]]].	^nil</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="Assets-IDE" selector="menuItemSyncAssets">menuItemSyncAssets	&lt;itemInMenu: #(#classMenu) position: 300.1&gt;	^(MenuItem labeled: #SyncAssets &gt;&gt; 'Sync Assets' &lt;&lt; #IDE)		hidden: [self isAssetClassSelected not];		value: #syncAssets</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedSelectors windowLabel </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>Image</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bits width height depth bitsPerPixel palette maxPixelValue rowByteSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class></st-source>