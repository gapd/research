<?xml version="1.0"?><st-source><!-- Name: MemoryPolicyTunerDbIdentifier: bear73DbTrace: 315094DevelopmentPrerequisites: #(#(#any 'MemoryPolicyChecker' ''))PackageName: MemoryPolicyTunerParcel: #('MemoryPolicyTuner')PrerequisiteDescriptions: #(#(#name 'MemoryPolicyChecker' #componentType #package))PrerequisiteParcels: #(#('MemoryPolicyChecker' ''))PrintStringCache: (7.8 - 1003,avalloud)Version: 7.8 - 1003Date: 10:51:39 AM January 7, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (jan11.1) of January 7, 2011 on January 7, 2011 at 10:51:39 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MemoryPolicyTuner</name><environment>Smalltalk</environment><super>MemoryPolicyTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyTuner</package></attributes></class><methods><class-id>MemoryPolicyTuner</class-id> <category>growth</category><body package="MemoryPolicyTuner" selector="testPreferredGrowthIncrement">testPreferredGrowthIncrement	self		assert: self memoryUpperBound // self preferredGrowthIncrement &lt; 32		description: 'The preferred growth increment should be increased to there are less segments'</body></methods><methods><class-id>MemoryPolicyTuner</class-id> <category>large space</category><body package="MemoryPolicyTuner" selector="largeClasses">largeClasses	| answer queue |	answer := OrderedCollection new.	queue := OrderedCollection withAll: Class rootsOfTheWorld.	[queue isEmpty] whileFalse:		[			| each |			each := queue removeLast.			(each isBits and: [each hasImmediateInstances not])				ifTrue: [answer add: each].			queue addAll: each subclasses		].	^answer</body><body package="MemoryPolicyTuner" selector="testLargeSpaceSizeIsReasonable">testLargeSpaceSizeIsReasonable	"It would be nice if large space held most of the large objects"	| largeObjectBytes |	largeObjectBytes := self largeClasses		inject: 0		into:			[:total :eachClass |				(eachClass allInstances					inject: 0					into:						[:sum :each |							each basicSize &gt; 1023								ifTrue:									[										| eachSize |										eachSize := each basicSize + self bytesPerOOP - 1											// self bytesPerOOP * self bytesPerOOP.										eachSize + sum]								ifFalse: [sum]						]				) + total			].	self		assert: self largeBytes * 2 &gt; largeObjectBytes		description: 'Consider increasing the size of large space, there are ', largeObjectBytes printString, ' bytes in large objects.'</body><body package="MemoryPolicyTuner" selector="testStackMultiplier">testStackMultiplier	| processes stackMultiplier |	processes := Process allInstances reject: [:any | any isTerminated].	stackMultiplier := self stackMultiplier.	self		assert: processes size / stackMultiplier &lt;= 5		description: 'The number of active processes should not exceed the stack multiplier times 5'</body></methods><methods><class-id>MemoryPolicyTuner</class-id> <category>free memory upper bound</category><body package="MemoryPolicyTuner" selector="testFreeMemoryUpperBoundAndGrowthIncrement">testFreeMemoryUpperBoundAndGrowthIncrement	"If this test fails, then an application past the growth regime can get in this cycle:		1.  Try to grow, fail.  GC does not clean up enough room.  Grow.		2.  After a bit, enough objects are collected and the memory policy shrinks the object memory.		3.  Go to 1.	"	self		assert: self freeMemoryUpperBound // 2 &gt; self preferredGrowthIncrement		description: 'The free memory upper bound should be at least twice the growth increment'</body><body package="MemoryPolicyTuner" selector="testFreeMemoryUpperBoundLargerThanOldSegments">testFreeMemoryUpperBoundLargerThanOldSegments	"If freeSpaceUpperBound is smaller than the smallest segment size,	the memory policy is going to find many many times that	freeMemory &gt; freeMemoryUpperBound, without finding a completely	empty segment, so it may uselessly try over and over to free memory"	| smallestOldSpaceSegment |	self assert: self oldSpaceSegmentSizes notEmpty.	smallestOldSpaceSegment := self oldSpaceSegmentSizes fold: [:x :y | x min: y].	self		assert: self freeMemoryUpperBound &gt; smallestOldSpaceSegment		description: 'The freeMemoryUpperBound should be larger than the smallest old segment'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>MemoryPolicyTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentObjectMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class></st-source>