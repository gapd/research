<?xml version="1.0"?><st-source><!-- Name: AT Integer ExtensionsNotice: Copyright © 2011-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This package provides a few of the most common number theory related methods for integers.DbIdentifier: bear73DbTrace: 315927PackageName: AT Integer ExtensionsParcel: #('AT Integer Extensions')PrintStringCache: (7.8 - 1003,aknight)Version: 7.8 - 1003Date: 12:23:50 PM January 14, 2011 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (jan11.2) of January 14, 2011 on January 14, 2011 at 12:23:50 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.Integer</class-id> <category>factorization and divisibility</category><body package="AT Integer Extensions" selector="choose:">choose: anInteger	"Answer the value of the binomial coefficient (self, anInteger)"	^(self fallingFactorial: anInteger) // anInteger factorial</body><body package="AT Integer Extensions" selector="div:">div: anInteger	"Answer the quotient of dividing the receiver by anInteger.	Follow the standard mathematical definition for quotient"	^self &gt;= 0		ifTrue: [self quo: anInteger]		ifFalse:			[				| answer |				answer := self quo: anInteger.				^answer * anInteger = self					ifTrue: [answer]					ifFalse: [answer - anInteger sign]			]</body><body package="AT Integer Extensions" selector="factorial">factorial	"Answer the factorial of the receiver.  For further information,	check Concrete Mathematics, by Graham, Knuth and Patashnik.	Examples:	0 factorial = 1	6 factorial = 6 * 5 * 4 * 3 * 2 * 1.	Use productTo: if self &gt; 120 because it's faster than an iteration"	| answer |	self &lt; 0 ifTrue:		[			^self class				raise: #domainErrorSignal				receiver: self				selector: #factorial				errorString: (#errFactorialInvalid &lt;&lt; #dialogs &gt;&gt; 'Factorial is invalid on negative numbers')		].	self &gt; 120 ifTrue: [^1 productTo: self].	answer := 1.	1 to: self do: [:each | answer := answer * each].	^answer</body><body package="AT Integer Extensions" selector="fallingFactorial:">fallingFactorial: anInteger	"Answer the falling factorial of anInteger terms, starting at anInteger.	For a definition of falling factorials, see Concrete Mathematics by	Graham, Knuth and Patashnik"	anInteger &lt; 0 ifTrue: [^1 / (self + 1 risingFactorial: anInteger negated)].	^self - anInteger + 1 productTo: self</body><body package="AT Integer Extensions" selector="isPrime">isPrime	"Answer whether the receiver has exactly two distinct positive divisors"	self &lt; 2 ifTrue: [^false].	self even ifTrue: [^self = 2].	3 to: self sqrtFloor do: [:each | self \\ each = 0 ifTrue: [^false]].	^true</body><body package="AT Integer Extensions" selector="mod:">mod: anInteger	"Answer the remainder of dividing the receiver by anInteger.	Follow the standard mathematical definition for remainder."	^self - ((self div: anInteger) * anInteger)</body><body package="AT Integer Extensions" selector="productTo:">productTo: anInteger	"Answer the product of all integers between self an anInteger.	If anInteger &lt; self, answer 1 because then the product is empty.	Use a binary approach because it is known to be much more	efficient than iteration when mildly large integers are involved"	| pivot |	self &gt; anInteger ifTrue: [^1].	self = anInteger ifTrue: [^self].	self + 1 = anInteger ifTrue: [^self + 1 * self].	pivot := self + anInteger // 2.	^(self productTo: pivot) * (pivot + 1 productTo: anInteger)</body><body package="AT Integer Extensions" selector="risingFactorial:">risingFactorial: anInteger	"Answer the rising factorial of anInteger terms, starting at anInteger.	For a definition of rising factorials, see Concrete Mathematics by	Graham, Knuth and Patashnik"	anInteger &lt; 0 ifTrue: [^1 / (self - 1 fallingFactorial: anInteger negated)].	^self productTo: self + anInteger - 1</body><body package="AT Integer Extensions" selector="sumTo:">sumTo: anInteger	"Answer the sum of all integers between the receiver	and anInteger.  If the sum has no terms, answer zero"	| numberOfSummands |	self &gt; anInteger ifTrue: [^0].	numberOfSummands := anInteger - self + 1.	^numberOfSummands + 1 * numberOfSummands // 2		+ (self - 1 * numberOfSummands)</body><body package="AT Integer Extensions" selector="sumTo:by:">sumTo: anInteger by: aStep	"Answer the sum of integers between the receiver	and anInteger, considering only every aStep-th	integer.  If the sum has no terms, answer zero"	| numberOfSummands largestTerm |	self &gt; anInteger ifTrue: [^0].	largestTerm := anInteger - self // aStep * aStep.	numberOfSummands := anInteger - self // aStep + 1.	^(largestTerm // aStep) * (largestTerm // aStep + 1) * aStep // 2		+ (self * numberOfSummands)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>