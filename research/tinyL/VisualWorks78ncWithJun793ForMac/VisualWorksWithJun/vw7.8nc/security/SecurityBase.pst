<?xml version="1.0"?><st-source><!-- Name: SecurityBaseNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This package declares the Security namespace and collects various generally useful extensions supporting the security frameworks.DbIdentifier: bear73DbTrace: 280601PackageName: SecurityBaseParcel: #('SecurityBase')ParcelName: SecurityBasePrintStringCache: (7.7.1 - 2,BaseSystem)Version: 7.7.1 - 2Date: 5:42:10 PM May 18, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.7.1 (may10.3) of May 18, 2010 on May 18, 2010 at 5:42:10 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Security</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SecurityBase</category><attributes><package>SecurityBase</package></attributes></name-space><class><name>ThirtyTwoBitRegister</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hi low </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>SecurityBase</package></attributes></class><comment><class-id>Security.ThirtyTwoBitRegister</class-id><body>Increases efficiency of computations on 32-bit numbers by avoiding overflow into the large intergers. Works by splitting the 32-bit value in half to which are guaranteed to fit into the SmallInteger range.Instance Variables:	hi	&lt;SmallInteger&gt; the more significant half of the register	low	&lt;SmallInteger&gt; the less significant half of the register</body></comment><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>accessing</category><body package="SecurityBase" selector="byte1">byte1	^hi bitShift: -8</body><body package="SecurityBase" selector="byte2">byte2	^hi bitAnd: 255</body><body package="SecurityBase" selector="byte3">byte3	^low bitShift: -8</body><body package="SecurityBase" selector="byte4">byte4	^low bitAnd: 255</body><body package="SecurityBase" selector="hi">hi	^ hi</body><body package="SecurityBase" selector="hi:">hi: anInteger	 hi := anInteger</body><body package="SecurityBase" selector="hi:low:">hi: anInteger1 low: anInteger2	 hi := anInteger1.	low := anInteger2</body><body package="SecurityBase" selector="low">low	^ low</body><body package="SecurityBase" selector="low:">low: anInteger	 low := anInteger</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>operations</category><body package="SecurityBase" selector="+=">+= aThirtyTwoBitRegister	"Replace my contents with the sum of the given register and my current contents."	low := low + aThirtyTwoBitRegister low.	hi := (hi + aThirtyTwoBitRegister hi			+ (low &gt; 16rFFFF ifTrue: [1] ifFalse: [0] )		) bitAnd: 16rFFFF.	low := low bitAnd: 16rFFFF</body><body package="SecurityBase" selector="&lt;&lt;">&lt;&lt; shift 	| tl |	shift &gt; 16		ifTrue: 			[hi := (low bitShift: shift - 16)						bitAnd: 65535.			low := 0]		ifFalse: 			[tl := low bitShift: shift - 16.			low := (low bitShift: shift)						bitAnd: 65535.			hi := ((hi bitShift: shift)						bitAnd: 65535)						+ tl]</body><body package="SecurityBase" selector="=">= aThirtyTwoBitRegister	"fixed for AR 47784 because the runtime package breaks with this etc. fastEqual: is implemeted to do the comparision with out the extra cycle of having to check the class name."        ^ self class == aThirtyTwoBitRegister class                and: [hi = aThirtyTwoBitRegister hi and: [low =aThirtyTwoBitRegister low]].</body><body package="SecurityBase" selector="&gt;&gt;">&gt;&gt; shift	low := low bitAnd: 16rffff.	low := ((hi bitShift: 16 - shift ) bitAnd: 16rFFFF) bitOr: (low bitShift: shift negated).	hi :=(hi bitShift: shift negated).</body><body package="SecurityBase" selector="addIn:">addIn: a32BitRegister"There's +=, but I want consistent naming and there's no good binary equivalent for xor"	low := low + a32BitRegister low.	hi := (hi + a32BitRegister hi			+ (low &gt; 16rFFFF ifTrue: [1] ifFalse: [0])		) bitAnd: 16rFFFF.	low := low bitAnd: 16rFFFF</body><body package="SecurityBase" selector="bitAnd:">bitAnd: aThirtyTwoBitRegister	hi := hi bitAnd: aThirtyTwoBitRegister hi.	low := low bitAnd: aThirtyTwoBitRegister low.</body><body package="SecurityBase" selector="bitInvert">bitInvert	hi := hi bitXor: 16rFFFF.	low := low bitXor: 16rFFFF.</body><body package="SecurityBase" selector="bitOr:">bitOr: aThirtyTwoBitRegister	hi := hi bitOr: aThirtyTwoBitRegister hi.	low := low bitOr: aThirtyTwoBitRegister low.</body><body package="SecurityBase" selector="bitXor:">bitXor: aThirtyTwoBitRegister	hi := hi bitXor: aThirtyTwoBitRegister hi.	low := low bitXor: aThirtyTwoBitRegister low.</body><body package="SecurityBase" selector="fastEqual:">fastEqual: aThirtyTwoBitRegister"Put here as a result of AR 47784 to have an = that doesn't have to do a class name comparison everytime "	^(hi = aThirtyTwoBitRegister hi) and:[ low = aThirtyTwoBitRegister low]</body><body package="SecurityBase" selector="leftRotateBy:">leftRotateBy: bits	| count |	count := bits \\ 32.	count &gt; 16		ifTrue: [ | left right newHi |			left := count - 16.			right := left - 16.			newHi := (low specialLeftShift: left) bitOr: (hi bitShift: right).			low := (hi specialLeftShift: left) bitOr: (low bitShift: right).			hi := newHi]		ifFalse: [ |  left right newHi |			left := count.			right := left - 16.			newHi := (hi specialLeftShift: left) bitOr: (low bitShift: right).			low := (low specialLeftShift: left) bitOr: (hi bitShift: right).			hi := newHi]</body><body package="SecurityBase" selector="rightRotateBy:">rightRotateBy: bits	^self leftRotateBy: 32 - bits</body><body package="SecurityBase" selector="set:">set: a32BitRegister	hi := a32BitRegister hi.	low := a32BitRegister low</body><body package="SecurityBase" selector="xorIn:">xorIn: a32BitRegister"Again added just for more consistent naming"	low := low bitXor: a32BitRegister low.	hi := hi bitXor: a32BitRegister hi</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>conversions</category><body package="SecurityBase" selector="asInteger">asInteger	"Answer the integer value"	| int |	int := LargePositiveInteger basicNew: 4.	int basicAt: 3 put: (hi bitAnd: 16rff).	int basicAt:4 put: ((hi bitShift: 0 - 8) bitAnd: 16rff).	int basicAt: 1 put: (low bitAnd: 16rff).	int basicAt:2 put: ((low bitShift: 0 - 8) bitAnd: 16rff).	^int	"^ (hi bitShift: 16) + low"</body><body package="SecurityBase" selector="load:">load: anInteger	"Set my contents to the value of given integer."	low := anInteger bitAnd: 16rFFFF.	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF."	self asInteger = anInteger		ifFalse: [self error: 'out of range: ', anInteger printString]."</body><body package="SecurityBase" selector="loadFrom:at:">loadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."	hi := ((aByteArray at: index) bitShift: 8) + ( aByteArray at: index + 1).	low := ((aByteArray at: index + 2) bitShift: 8) + ( aByteArray at: index + 3).</body><body package="SecurityBase" selector="reverseLoadFrom:at:">reverseLoadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use little-endian byte ordering)."	hi := ((aByteArray at: index+ 3) bitShift: 8) + ( aByteArray at: index + 2).	low := ((aByteArray at: index + 1) bitShift: 8) + ( aByteArray at: index ).</body><body package="SecurityBase" selector="reverseStoreTo:at:">reverseStoreTo: aByteArray at: index"Little-endian"	aByteArray		at: index put: (low bitAnd: 255);		at: index + 1 put: (low bitShift: -8);		at: index + 2 put: (hi bitAnd: 255);		at: index + 3 put: (hi bitShift: -8)</body><body package="SecurityBase" selector="storeTo:at:">storeTo: aByteArray at: index"Big-endian"	aByteArray		at: index put: (hi bitShift: -8);		at: index + 1 put: (hi bitAnd: 255);		at: index + 2 put: (low bitShift: -8);		at: index + 3 put: (low bitAnd: 255)</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>printing</category><body package="SecurityBase" selector="printOn:">printOn: aStream	"Print my contents in hex put an R in front to show that it is a register being printed."	aStream nextPutAll: (#RegisterPrefix &lt;&lt; #security &gt;&gt; 'R:') asString.	self asInteger printOn: aStream base: 16.	aStream nextPutAll: (#DecimalPrefix &lt;&lt; #security &gt;&gt; 'D:') asString.	self asInteger printOn: aStream base: 10.</body></methods><methods><class-id>Security.ThirtyTwoBitRegister class</class-id> <category>instance creation</category><body package="SecurityBase" selector="new">new	"Answer a new instance whose initial contents is zero."	^ super new load: 0</body></methods><methods><class-id>Core.LargeNegativeInteger</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArray">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	^self errorConvertingNegativeIntegerToBytes</body><body package="SecurityBase" selector="asBigEndianByteArrayPaddedTo:">asBigEndianByteArrayPaddedTo: numberOfBytes"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	^self errorConvertingNegativeIntegerToBytes</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArray">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	| remainder bytes |	self negative ifTrue: [ self errorConvertingNegativeIntegerToBytes ].	remainder := self.	bytes := ByteArray new: self digitLength.	bytes size to: 1 by: -1 do: [ :i |		bytes at: i put: (remainder bitAnd: 255).		remainder := remainder bitShift: -8 ].	^bytes</body><body package="SecurityBase" selector="specialLeftShift:">specialLeftShift: aShift	"Limit the results to the bottom 16 bits.  Ensure the bitShift: primitive succeeds in 32 bit images.  aShift must be between 0 and 16"	| mask |	aShift = 0 ifTrue: [^self].	mask := #(32767 16383 8191 4095 2047 1023 511 255 127 63 31 15 7 3 1 0) at: aShift.	^(self bitAnd: mask) bitShift: aShift</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArray">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	| answer top |	top := self basicSize + 1.	answer := ByteArray new: top - 1.	1 to: top - 1 do: [:i |		answer at: i put: (self basicAt: top - i)].	^answer</body><body package="SecurityBase" selector="asBigEndianByteArrayPaddedTo:">asBigEndianByteArrayPaddedTo: numberOfBytes"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	| answer top pad |	self basicSize &gt; numberOfBytes ifTrue: [ self errorInsufficientSpaceForIntegerToBytesConversion ].	top := self basicSize + 1.	pad := numberOfBytes - top + 1.	answer := ByteArray new: numberOfBytes.	1 to: top - 1 do: [:i |		answer at: pad + i put: (self basicAt: top - i)].	^answer</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>encryption</category><body package="SecurityBase" selector="fromHexString:">fromHexString: aString"(((self fromHexString: 'A00B0210FF00')))"	^self fromHexString: aString lowerCase: false</body><body package="SecurityBase" selector="fromHexString:lowerCase:">fromHexString: aString lowerCase: aBoolean"(((self fromHexString: 'A00B0210FF00')))"	| ba s lookup |	lookup := aBoolean		ifTrue: ['123456789abcdef']		ifFalse: ['123456789ABCDEF'].	ba := self new: aString size // 2.	s := aString readStream.	1 to: ba size do: [ :i || h l |		h := s next.		h := h = $0 ifTrue: [0] ifFalse: [lookup indexOf: h].		l := s next.		l := l = $0 ifTrue: [0] ifFalse: [lookup indexOf: l].		ba at: i put: ((h bitShift: 4) bitOr: l) ].	^ba</body></methods><methods><class-id>Core.ByteArray</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianInteger">asBigEndianInteger"Interpret the receiver as an unsigned integer in big-endian format. This is the reverse of #asBigEndianByteArray."	^(self reverse changeClassTo: LargePositiveInteger) compressed</body><body package="SecurityBase" selector="asHexString">asHexString"(((#[160 11 2 16 255 0] asHexString)))"	| lookup s ws |	lookup := '0123456789ABCDEF'.	s := String new: self size * 2.	ws := s writeStream.	self do: [ :b |		ws nextPut: (lookup at: (b bitShift: -4) + 1).		ws nextPut: (lookup at: (b bitAnd: 15) + 1) ].	^s</body><body package="SecurityBase" selector="asLargePositiveInteger">asLargePositiveInteger"WARNING! DEPRECATED! This method generates invalid large integers for short arrays. Use asBigEndianInteger instead.Do the reverse of #asBigEndianByteArray in LargePositiveInteger"	| int |	self deprecated: #(#version '7.7' #sunset '8.0' #use #asBigEndianInteger).	int := LargePositiveInteger basicNew: self size.	self keysAndValuesDo: [ :index :each | int basicAt: (self size + 1- index) put: each ].	^int</body></methods><methods><class-id>Core.Integer</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArrayPaddedTo:">asBigEndianByteArrayPaddedTo: anInteger"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	| ba counter number |	self negative ifTrue: [ self errorConvertingNegativeIntegerToBytes ].	ba := ByteArray new: anInteger.	counter := anInteger.	number := self.	[number &gt; 0] whileTrue: [		counter = 0 ifTrue: [ self errorInsufficientSpaceForIntegerToBytesConversion ].		ba at: counter put: (number bitAnd: 255).		counter := counter - 1.		number := number bitShift: -8 ].	^ba</body></methods><methods><class-id>Core.Integer</class-id> <category>deprecated</category><body package="SecurityBase" selector="asByteArray">asByteArray"WARNING: This selector is too ambiguous and is being deprecated. It will be removed in the next major release."	self deprecated: #(#version '7.2' #sunset '8.0' #use #asBigEndianByteArray).	^self asBigEndianByteArray</body><body package="SecurityBase" selector="asByteArrayPaddedTo:">asByteArrayPaddedTo: anInteger"WARNING: This selector is too ambiguous and is being deprecated. It will be removed in the next release."	^self asBigEndianByteArrayPaddedTo: anInteger</body></methods><methods><class-id>Core.Integer</class-id> <category>security</category><body package="SecurityBase" selector="errorConvertingNegativeIntegerToBytes">errorConvertingNegativeIntegerToBytes	self error: (#errCantConvertNegativeNumbers &lt;&lt; #security &gt;&gt; 'Cannot convert negative integer into a big-endian byte array').</body><body package="SecurityBase" selector="errorInsufficientSpaceForIntegerToBytesConversion">errorInsufficientSpaceForIntegerToBytesConversion	self error: (#InsufficientSize &lt;&lt; #security &gt;&gt; 'Not enough room for the whole number').</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>LargeNegativeInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>