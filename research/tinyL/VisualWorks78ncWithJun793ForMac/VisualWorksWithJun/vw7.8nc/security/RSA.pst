<?xml version="1.0"?><st-source><!-- Name: RSANotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This package implements RSA encryption as described in PKCS#1. The algorithm itself is represented by the class RSA and provides both encryption/decryption and signing/verification API. The keys can be generated with the RSAKeyGenerator and are instantiated as RSAPublicKey and RSAPrivateKey. For details please refer to the class comments.For standardized export/import and secure storage of private keys use the PKCS8 package.DbIdentifier: bear73DbTrace: 280600DevelopmentPrerequisites: #(#(#any 'SecurityBase' '') #(#any 'CiphersBase' ''))DisregardedPrerequisites: #(#(#name 'SHA' #componentType #package) #(#name 'MD5' #componentType #package))PackageName: RSAParcel: #('RSA')PrerequisiteDescriptions: #(#(#name 'SecurityBase' #componentType #package) #(#name 'CiphersBase' #componentType #package))PrerequisiteParcels: #(#('SecurityBase' '') #('CiphersBase' ''))PrintStringCache: (7.7.1 - 4,BaseSystem)Version: 7.7.1 - 4Date: 5:42:15 PM May 18, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.7.1 (may10.3) of May 18, 2010 on May 18, 2010 at 5:42:15 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>RSA</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>privateKey publicKey hash </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSA</class-id><body>This class implements the RSA algorithm as described in PKCS#1. It provides both encryption/decryption and signing/verification. Note that the same basic algorithm is used for both encryption and signing, therefore the result of signing is also a byte array, rather than a special "signature" object. Note that the PKCS#1 standard allows different hash functions to be used to compute a message digest for signing. Therefore one is expected to initialize the algorithm with one of #useSHA or #useMD5.Signing some data using MD5 digest would look as follows:	signatureBytes :=		RSA new			useMD5;			privateKey: anRSAPrivateKey;			sign: dataBytes.To verify the signature use following:	isAuthenticBoolean :=		RSA new			useMD5;			publicKey: anRSAPublicKey;			verify: signatureBytes of: dataBytesIf the algorithm is not configured with specific hash function, then the argument of the #sign: message is expected to be an externally computed digest of the original message. The RSA algorithm will skip the hashing step in that case. Same applies to the verification operation. This capability is used by SSL protocol which does the hashing in its own way.Encryption operations don't use hashing at all, so the #useMD5 or #useSHA are not necessary and have no effect on the encryption operations. Encryption is used in the usual way.	encryptedBytes :=		RSA new			publicKey: anRSAPublicKey;			encrypt: plainBytes				plainMessageBytes :=		RSA new			privateKey: anRSAPrivateKey;			decrypt: encryptedMessageBytesNote that the message size must not exceed the size of the key. Specifically when the message bytes are encoded into a large Integer (using the os2ip: method), the resulting number must be less than the key modulus (RSAKey&gt;&gt;n). The size of the encrypted message will usually match the size of the key, even if the plain message is much shorter.Instance Variables:	privateKey	&lt;RSAPrivateKey&gt; private key to use for decryption or signing	publicKey	&lt;RSAPublicKey&gt; public key to use for encryption or signature verification	hash	&lt;Hash&gt; a hash algorithm to use for signing</body></comment><class><name>RSAError</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAError</class-id><body>Common superclass of errors generated by the RSA algorithm.</body></comment><class><name>RSAKey</name><environment>Security</environment><super>Security.EncryptionKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAKey</class-id><body>Abstract superclass for RSA keys.Instance Variables	n	&lt;LargeInteger&gt; modulus, n=p*q, determins the size of the key and limits the size of data that can be encrypted, or size of the signature</body></comment><class><name>RSAPublicKey</name><environment>Security</environment><super>Security.RSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>e </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAPublicKey</class-id><body>Public RSA key can be used for two purposes: it can encrypt data for later decryption with corresponding private key; and it can verify a signature of some data which was previously generated using corresponding private key. The public exponent is purposely chosen small as it speeds up the encryption/verification operation significantly without compromising security.Instance Variables:	e	&lt;LargeInteger&gt;	public exponent, usually one of 3, 17, 65537</body></comment><class><name>RSAKeyGenerator</name><environment>Security</environment><super>Security.KeyGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mask q p n e d </inst-vars><class-inst-vars>e </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAKeyGenerator</class-id><body>The usual key sizes start from 512 bits and go up from there. The longer the key the more expensive are the cryptographic operations. Note however that 512 bit keys are considered weak given today's computers.The key generator employs a random number generator and an efficient primality test. The random generator is expected to generate large intergers of 160 bit size, a properly seeded DSSRandom is acceptable. The primality test is allowed to be probabilistic but the probability of false prime has to be less than 1/4^50. A properly initialized MillerRabin algorithm is acceptable. The probabilistic primality test can share its random generator with the key generator.The generator produces a couple of parameters, signalling various events along the way for observation. Finally it packages them up as RSAPublicKey and RSAPrivateKey, which are accessible using the #privateKey and #publicKey messages. To force the generator to produce a new pair of keys it has to be cleared using the #flush message.	| generator public private |	generator := RSAKeyGenerator keySize: 1024.	private := generator privateKey.	public := generator publicKey.	generator flushInstance Variables:	mask	&lt;LargeInteger&gt; a mask used to enforce the size of the prime factors p and q	q	&lt;LargeInteger&gt; a large prime of bit-length aproximately keySize // 2	p	&lt;LargeInteger&gt; a large prime of bit-length aproximately keySize // 2	n	&lt;LargeInteger&gt; modulus, n=p*q, of bit-length keySize	e	&lt;LargeInteger&gt; public exponent, usually one of 3, 17, 65537	d	&lt;LargeInteger&gt; private exponent, of large bit-lengthClass Instance Variables:	e	&lt;Integer&gt; default public exponent value (usually something like 3, 17, 65537)</body></comment><class><name>RSAMessageTooLong</name><environment>Security</environment><super>Security.RSAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAMessageTooLong</class-id><body>This error signals that an attempted encryption or signing operation has failed because the date that was provided exceeds the range granted by the bit-length of the key used for the operation.</body></comment><class><name>RSADecodingError</name><environment>Security</environment><super>Security.RSAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSADecodingError</class-id><body>This error signals a problem decoding and encrypted message. It means that the decryption step failed usually due to corrupt cipher-text or due to a wrong key being used to decrypt.</body></comment><class><name>RSAPrivateKey</name><environment>Security</environment><super>Security.RSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>d e p q dP dQ qInv otherFactors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAPrivateKey</class-id><body>Private RSA keys can be used for two purposes: it can decrypt data previously encrypted with corresponding public key; and it can generate a signature for specific data which can later be verified using corresponding public key.For standardized export/import and secure storage of private keys use the PKCS8 package.Instance Variables:	d	&lt;LargeInteger&gt; private exponent, of large bit-length	e	&lt;LargeInteger&gt; public exponent, usually one of 3, 17, 65537	p	&lt;LargeInteger&gt; the first factor of n	q	&lt;LargeInteger&gt; the second factor of n	dP	&lt;LargeInteger&gt; sub-exponent1, dP = d mod (p - 1)	dQ	&lt;LargeInteger&gt; sub-exponent2, dQ = d mod (q - 1)	qInv	&lt;LargeInteger&gt; CRT coefficient, qInv = 1/q mod p	otherFactors	&lt;Array&gt; additional factors of n, triplets including the factor, its sub-exponent and CRT coefficient</body></comment><methods><class-id>Security.RSA</class-id> <category>accessing</category><body package="RSA" selector="hashAlgorithm">hashAlgorithm	^hash</body><body package="RSA" selector="hashAlgorithm:">hashAlgorithm: aHash	hash := aHash</body><body package="RSA" selector="privateKey">privateKey	^privateKey</body><body package="RSA" selector="privateKey:">privateKey: anRSAPrivateKey	privateKey := anRSAPrivateKey</body><body package="RSA" selector="publicKey">publicKey	^publicKey</body><body package="RSA" selector="publicKey:">publicKey: anRSAPublicKey	publicKey := anRSAPublicKey</body><body package="RSA" selector="useMD5">useMD5	self hashAlgorithm: (		#{MD5}			ifDefinedDo: [:hashClass | hashClass new]			elseDo: [self error: 'MD5 must be loaded!'])</body><body package="RSA" selector="useSHA">useSHA	self hashAlgorithm: (		#{SHA}			ifDefinedDo: [:hashClass | hashClass new]			elseDo: [self error: 'SHA must be loaded!'])</body></methods><methods><class-id>Security.RSA</class-id> <category>private</category><body package="RSA" selector="getRandom">getRandom	| random generator|	random := 0.	generator := Random fastest seed: (Timestamp now asMilliseconds bitAnd: 65535) .	"make sure we have only non zero values"	[random = 0] whileTrue:[ random := (generator  next  * 256) floor].	^random</body></methods><methods><class-id>Security.RSA</class-id> <category>private-PKCS1 signing</category><body package="RSA" selector="signRSASP1:">signRSASP1: aMessageInteger	(aMessageInteger &lt; privateKey n) ifFalse: [self messageTooLong: aMessageInteger].	^privateKey exponentPowerOf: aMessageInteger</body><body package="RSA" selector="signRSASSA:">signRSASSA: aMessageArray	privateKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPrivateKeyToSign &lt;&lt; #security &gt;&gt; 'Private key needed for signing!') ].	^self i2osp: (			self signRSASP1: (				self	encodeByEMSA_PKCS1_V1_5: aMessageArray					size: (privateKey keySize - 1)))		intendedSize: privateKey keySize</body><body package="RSA" selector="signatureExceedsKeySize:">signatureExceedsKeySize: signature"This means the signature is not valid for the provided key, possibly transferred or decoded incorrectly."	RSAError new		messageText: #RSASignatureExceedsKeySize &lt;&lt; #security &gt;&gt; 'RSA signature size exceeds the key size!';		parameter: signature;		raise</body><body package="RSA" selector="verifyRSASSA:of:">verifyRSASSA: aSignatureArray of: aMessageArray		| signatureInteger |	publicKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPublicKeyToVerify &lt;&lt; #security &gt;&gt; 'Public key needed for signature verification!') ].	(aSignatureArray size &gt; publicKey keySize) ifTrue: [ self signatureExceedsKeySize: aSignatureArray ].	signatureInteger := self os2ip: aSignatureArray.	(signatureInteger &lt; publicKey n) ifFalse: [ self signatureExceedsKeySize: signatureInteger ].	^	(self encodeByEMSA_PKCS1_V1_5: aMessageArray			size: (publicKey keySize - 1)		) = (self verifyRSAVP1: signatureInteger)</body><body package="RSA" selector="verifyRSAVP1:">verifyRSAVP1: aSignatureInteger	(aSignatureInteger &lt; publicKey n) ifFalse: [self messageTooLong: aSignatureInteger].	^publicKey exponentPowerOf: aSignatureInteger</body></methods><methods><class-id>Security.RSA</class-id> <category>private-PKCS1 encoding methods</category><body package="RSA" selector="decodeByEME_PKCS1_V1_5:size:">decodeByEME_PKCS1_V1_5: emInteger size: emLen"This is EME-PKCS1-v1_5-Decode as defined in section 9.1.2.2 of PKCS#1 v2.0.	emInteger	&lt;LargePositiveInteger&gt;	EM, message to be decoded	emLen	&lt;Integer&gt;	the length of the encoded message	^&lt;ByteArray&gt;	M, the decoded messageA slight diversion from the spec is that as an optimization we directly decode the large integer instead of converting it to a byte array first.So this method actually corresponds to the following in terms of PKCS#1:	EME-PKCS1-v1_5-Decode(I2OSP(emInteger, emLen))"	| padStart answer |	emInteger digitLength &lt; 10 ifTrue: [		RSADecodingError new			messageText: (#RSAMessageTooShort &lt;&lt; #security &gt;&gt; 'Encoded message is too short!');			parameter: emInteger;			raise ].	(emInteger basicAt: emLen) = 2 ifFalse: [		RSADecodingError new			messageText: (#RSAInvalidPaddingPrefix &lt;&lt; #security &gt;&gt; 'Invalid padding prefix!');			parameter: emInteger;			raise ]. 	padStart := emLen - 1.	[	padStart isZero or: [ (emInteger basicAt: padStart) isZero ]	] whileFalse: [ padStart := padStart - 1]. 	padStart isZero ifTrue: [		RSADecodingError new			messageText: (#RSAMissingPaddingMarker &lt;&lt; #security &gt;&gt; 'Missing padding marker!');			parameter: emInteger;			raise ].	padStart &gt; (emLen - 9) ifTrue: [		RSADecodingError new			messageText: (#RSAPaddingTooShort &lt;&lt; #security &gt;&gt; 'Padding is too short!');			parameter: emInteger;			raise ].	answer := ByteArray new: padStart - 1.	1 to: padStart - 1 do: [ :i |		answer at: i put: (emInteger basicAt: padStart - i)].	^answer</body><body package="RSA" selector="encodeByEME_PKCS1_V1_5:size:">encodeByEME_PKCS1_V1_5: mBytes size: emLen "This is EME-PKCS1-v1_5-Encode as defined in 9.1.2.1 of PKCS#1 v2.0.	mBytes	&lt;ByteArray&gt;	M, message to be encoded, must be at most emLen-10 bytes long	emLen	&lt;Integer&gt;		intended byte length of the encoded message	^&lt;LargePositiveInteger&gt;	EM, the encoded messageA slight diversion from the spec is that as an optimization this method returns a large integer instead of a byte array, since that's what the result gets always converted to anyway.So this method actually corresponds to the following in terms of PKCS#1:	OS2IP(EME-PKCS1-v1_5-Encode(aByteArray, emLen)"	| em padStart random |	mBytes size &gt; (emLen - 10) ifTrue: [self messageTooLong: mBytes ].	em := LargePositiveInteger basicNew: emLen.	mBytes with: (mBytes size to: 1 by: -1) do: [:each :index |		"convert to largeinteger reserving the pad in the beginning ot the large int"		em basicAt: index put: each].	padStart := mBytes size + 1.	em basicAt: padStart put: 0.	"fill with some randoms they don't have to be cryptographic secure so our will do"	random := Random fastest seed: (Time microsecondClock bitAnd: 65535).	padStart + 1 to: emLen -1 do: [ :i |		em	basicAt: i			put: (random next * 255) floor + 1 "must be non-zero" ].	em basicAt: emLen put: 2.	^em</body><body package="RSA" selector="encodeByEMSA_PKCS1_V1_5:size:">encodeByEMSA_PKCS1_V1_5: aByteArray size: emLen"This is a slightly extended version of the PKCS#1 v1.5 'encoding method for signatures with appendix' (EMSA).The extension is to support RSA signing for SSL, where the digest is precomputed by the SSL rulesand passed in as the aMessageArray value. This is indicated by the nil value of the 'hash' instance variable,in which case the hashing part of this method is skipped and only the type 1 padding is applied.Another slight diversion from the spec is that as an optimization this method returns a large integer instead of a byte array,since that's what the result gets always converted to anyway.So this method actually corresponds to the following in terms of PKCS#1:	OS2IP(EMSA-PKCS1-v1_5-Encode(aMessageArray, emLen)"	| T int |	T := hash isNil		ifTrue: [ aByteArray ]		ifFalse: [ hash derEncodedDigestInfo, (hash byteHash: aByteArray) ].	(T size + 10 &gt; emLen) ifTrue: [self messageTooLong: aByteArray].	"Now produce the EM = 01 || PS || 00 || T , where PS is emLen- || T || - 2 bytes of 16rFF. In BIG ENDIAN !"	int := LargePositiveInteger basicNew: emLen.	" Our LargeIntegers are little endian, so we have to reverse the bytes"	T with: (T size to: 1 by: -1) do: [:each :index |		int basicAt: index put: each].	int basicAt: T size + 1 put: 0.	T size + 2 to: emLen - 1 do: [ :ind | int basicAt: ind put: 255].	int basicAt: emLen put: 1.	^int</body><body package="RSA" selector="messageTooLong:">messageTooLong: message"This means that the message length exceeds the size of the key."	RSAMessageTooLong new		messageText: (#RSAMessageTooLong &lt;&lt; #security &gt;&gt; 'Message is too long!');		parameter: message;		raise</body></methods><methods><class-id>Security.RSA</class-id> <category>private-PKCS1 encryption</category><body package="RSA" selector="decryptRSADP:">decryptRSADP: aMessageInteger	(aMessageInteger &lt; privateKey n) ifFalse: [self messageTooLong: aMessageInteger].	^privateKey exponentPowerOf: aMessageInteger</body><body package="RSA" selector="decryptRSAES:">decryptRSAES: aByteArray	| messageInteger encodedMessage |	privateKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPrivateKeyToDecrypt &lt;&lt; #security &gt;&gt; 'Private key needed for decryption!') ].	aByteArray size &gt; privateKey keySize ifTrue: [self messageTooLong: aByteArray].	messageInteger := self os2ip: aByteArray.	encodedMessage := self decryptRSADP: messageInteger.	^self decodeByEME_PKCS1_V1_5: encodedMessage size: (privateKey keySize - 1)</body><body package="RSA" selector="encryptRSAEP:">encryptRSAEP: aMessageInteger	(aMessageInteger &lt; publicKey n) ifFalse: [self messageTooLong: aMessageInteger].	^publicKey exponentPowerOf: aMessageInteger</body><body package="RSA" selector="encryptRSAES:">encryptRSAES: aByteArray	| encodedMessage encryptedMessage |	publicKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPublicKeyToEncrypt &lt;&lt; #security &gt;&gt; 'Public key needed for encryption!') ].	encodedMessage := self encodeByEME_PKCS1_V1_5: aByteArray size: (publicKey keySize - 1).	encryptedMessage := self encryptRSAEP: encodedMessage.	^self i2osp: encryptedMessage intendedSize: publicKey keySize.</body></methods><methods><class-id>Security.RSA</class-id> <category>services</category><body package="RSA" selector="decrypt:">decrypt: aByteArray"Decrypt aByteArray using the previously assigned private key."	^self decryptRSAES: aByteArray</body><body package="RSA" selector="encrypt:">encrypt: aByteArray"Encrypt aByteArray using the previously assigned public key."	^self encryptRSAES: aByteArray</body><body package="RSA" selector="sign:">sign: messageBytes"Compute a signature of messageBytes.If the 'hash' instance variable is nil then messageBytes is expected to be already a digest of apropriate size (generally up to the key size - 1 bytes) in which case the hashing step of the signing procedure is skipped."	^self signRSASSA: messageBytes</body><body package="RSA" selector="verify:of:">verify: signatureBytes of: messageBytes"Denies or confirms that signatureBytes is a signature of messageBytes.If the 'hash' instance variable is nil then messageBytes is expected to be already a digest of apropriate size (generally up to key size - 1 bytes) in which case the hashing step of the signing procedure is skipped."	^self verifyRSASSA: signatureBytes of: messageBytes</body></methods><methods><class-id>Security.RSA</class-id> <category>private-PKCS1 conversions</category><body package="RSA" selector="i2osp:intendedSize:">i2osp: largeInt intendedSize: size "This will convert the large integer to a byte array of specified size. In most cases this will be very simple since the result of the mod:exp: operation will be of the correct size. However occassionally it will be shorter, usually just a byte shorter. We have to check and if it isn't the right length we have to pad with leading zeros."	^largeInt asBigEndianByteArrayPaddedTo: size</body><body package="RSA" selector="os2ip:">os2ip: aByteArray"OS2IP converts an octet string to a nonegative integer."	^aByteArray asBigEndianInteger</body></methods><methods><class-id>Security.RSAKey</class-id> <category>accessing</category><body package="RSA" selector="keySize">keySize	^n digitLength</body><body package="RSA" selector="n">n	^n</body><body package="RSA" selector="n:">n: aValue	n := aValue</body></methods><methods><class-id>Security.RSAPublicKey</class-id> <category>accessing</category><body package="RSA" selector="e">e	^e</body><body package="RSA" selector="e:">e: aValue	e := aValue</body></methods><methods><class-id>Security.RSAPublicKey</class-id> <category>api</category><body package="RSA" selector="exponentPowerOf:">exponentPowerOf: aSignatureInteger	^aSignatureInteger raisedTo: self e modulo: self n</body></methods><methods><class-id>Security.RSAPublicKey class</class-id> <category>instance creation</category><body package="RSA" selector="e:n:">e: e n: n	^self new		e: e;		n: n;		yourself</body></methods><methods><class-id>Security.RSAKeyGenerator</class-id> <category>accessing</category><body package="RSA" selector="d">d	^d</body><body package="RSA" selector="e">e	^e ifNil: [ e := self class e ]</body><body package="RSA" selector="e:">e: anInteger"	anInteger &lt;Integer&gt; default public exponent value (usually something like 3, 17, 65537)"	e := anInteger</body><body package="RSA" selector="n">n	^n</body><body package="RSA" selector="p">p	^p</body><body package="RSA" selector="q">q	^q</body></methods><methods><class-id>Security.RSAKeyGenerator</class-id> <category>initialization</category><body package="RSA" selector="keySize:random:primalityTest:">keySize: bitLength random: aRandom primalityTest: pTest"	bitLength	&lt;SmallInteger&gt; the bit-length of the modulus n	aRandom	&lt;Random&gt; a random seed generator producing large intergers	pTest	&lt;PrimalityTest&gt; a probabilistic primality test"	super keySize: bitLength random: aRandom primalityTest: pTest.	mask := (1 bitShift: bitLength // 2 - 1) bitOr: 1.</body></methods><methods><class-id>Security.RSAKeyGenerator</class-id> <category>private</category><body package="RSA" selector="generateKeys">generateKeys	| product euclid |	q ifNil: [ self generateQ ].	[	product := (p - 1) * (q - 1).		euclid := EuclidAlgorithm with: self e with: product.		euclid doBasicAlgorithm.		euclid gcd = 1	] whileFalse: [		self triggerEvent: #rejectingQ: with: q.		p := q.		self generateQ ].	d := euclid firstCoefficient \\ product.	self triggerEvent: #generatedD:usingE: with: d with: e.	n := p * q.	self triggerEvent: #generatedN: with: n.</body><body package="RSA" selector="generateP">generateP	[	p := self nextRandom bitOr: mask.		self triggerEvent: #tryingP: with: p.		primalityTest value: p	] whileFalse.	self triggerEvent: #foundP: with: p</body><body package="RSA" selector="generateQ">generateQ	p ifNil: [ self generateP ].	[	q := self nextRandom bitOr: mask.		self triggerEvent: #tryingQ: with: q.		(primalityTest value: q) and: [ p ~= q ]	] whileFalse.	self triggerEvent: #foundQ: with: q</body><body package="RSA" selector="nextRandom">nextRandom	| bitSize x |	"Let's assume that the bit sizes are byte aligned"	bitSize := keySize // 16 "half of the modulus in bytes".	x := random next.	[ x basicSize &lt; bitSize ] whileTrue: [ | chunk |		chunk := random next.		x := (x bitShift: (chunk basicSize * 8)) bitOr: chunk ].	^(x basicSize &gt; bitSize)		ifTrue: [ x bitShift: (bitSize - x basicSize) * 8 ]		ifFalse: [ x ]</body></methods><methods><class-id>Security.RSAKeyGenerator</class-id> <category>services</category><body package="RSA" selector="flush">flush"Flush all the parameters to make sure next generation creates new ones"	q := p := n := e := d := nil</body><body package="RSA" selector="privateKey">privateKey	n ifNil: [ self generateKeys ].	^(RSAPrivateKey d: d n: n)		e: self e;		p: self p;		q: self q;		yourself</body><body package="RSA" selector="publicKey">publicKey	n ifNil: [ self generateKeys ].	^RSAPublicKey e: e n: n</body></methods><methods><class-id>Security.RSAKeyGenerator class</class-id> <category>accessing</category><body package="RSA" selector="defaultE">defaultE	^65537</body><body package="RSA" selector="e">e	^e ifNil: [^self defaultE]</body><body package="RSA" selector="e:">e: anInteger"	anInteger &lt;Integer&gt; default public exponent value (usually something like 3, 17, 65537)	self e: 3"	e := anInteger</body></methods><methods><class-id>Security.RSAKeyGenerator class</class-id> <category>events</category><body package="RSA" selector="eventsTriggered">eventsTriggered	^#(	tryingQ:		foundQ:		tryingP:		foundP:		rejectingQ:		generatedD:usingE:		generatedN:)</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>accessing</category><body package="RSA" selector="d">d	^d</body><body package="RSA" selector="d:">d: aValue	d := aValue</body><body package="RSA" selector="dp">dp	^dP ifNil: [ dP := d \\ ( p - 1 ) ]</body><body package="RSA" selector="dp:">dp: exp	dP := exp</body><body package="RSA" selector="dq">dq	^dQ ifNil: [ dQ := d \\ (q - 1) ]</body><body package="RSA" selector="dq:">dq: exp	dQ := exp</body><body package="RSA" selector="e">e	^e</body><body package="RSA" selector="e:">e: aNumber	e := aNumber</body><body package="RSA" selector="otherFactors">otherFactors	^otherFactors</body><body package="RSA" selector="otherFactors:">otherFactors: aSequenceOfTriplets"aSequenceOfTriplets is a sequenceable collection of #(ri di ti), where ri is a factor, di is its exponent and ti is its CRT coefficient"	otherFactors := aSequenceOfTriplets</body><body package="RSA" selector="p">p	^p</body><body package="RSA" selector="p:">p: aNumber	p := aNumber</body><body package="RSA" selector="q">q	^q</body><body package="RSA" selector="q:">q: aNumber	q := aNumber</body><body package="RSA" selector="qInv">qInv	^qInv ifNil: [ "qInv = 1 / q mod p"		qInv := (EuclidAlgorithm with: q with: p) doBasicAlgorithm; firstCoefficient.		qInv &lt; 0 ifTrue: [ qInv := qInv \\ p ].		qInv ]</body><body package="RSA" selector="qInv:">qInv: aNumber	qInv := aNumber</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>accessing-aliases</category><body package="RSA" selector="coefficient">coefficient	^self qInv</body><body package="RSA" selector="coefficient:">coefficient: aNumber	self qInv: aNumber</body><body package="RSA" selector="exponent1">exponent1	^self dp</body><body package="RSA" selector="exponent1:">exponent1: aNumber	self dp: aNumber</body><body package="RSA" selector="exponent2">exponent2	^self dq</body><body package="RSA" selector="exponent2:">exponent2: aNumber	self dq: aNumber</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>testing</category><body package="RSA" selector="isSecondForm">isSecondForm	^p notNil and: [ q notNil ]</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>services</category><body package="RSA" selector="exponentPowerOf:">exponentPowerOf: aLargeInteger	^(	self isSecondForm and: [		"We do not support multi-factor (&gt;2) keys yet"		otherFactors isNil ]	)	ifTrue: [ self fastExponentPowerOf: aLargeInteger ]		ifFalse: [ self simpleExponentPowerOf: aLargeInteger ]</body><body package="RSA" selector="fastExponentPowerOf:">fastExponentPowerOf: aLargeInteger"If we know factorization of the modulus n, the power can be computed several times faster exploiting Chinese Remainder Theorem.The description of the computation itself is included in PKCS#1 version 2.0 and up. It's referred to as the computation using the 'second form' of a private key."	 | h m m1 m2 |	"Split the the integer into the CRT factors and perform the exponentiation"	m1 := (aLargeInteger \\ p) raisedTo: self dp modulo: p.	m2 := (aLargeInteger \\ q) raisedTo: self dq modulo: q.	"Convert the result back to an integer using Garner's formula"	h :=  (((m1 - m2) \\ p) * self qInv) \\ p.	m :=  h * q + m2.	"This is what I believe the rest of the algorithm should look like for n with more than 2 factors.	But I'm not sure, the description in PKCS#1 v2.1 is pretty poor in that regard.	Given that such keys are rarely used it's safer to claim non-support for now.	This is reflected in the isSecondForm test.	otherFactors notNil ifTrue: [ | R prevRi |		R := p. prevRi := q.		otherFactors do: [ :triplet || ri di ti mi |			ri := triplet first.			di := triplet at: 2.			ti := triplet last.			mi := (aMessageInteger \\ ri) raisedTo: di modulo: ri.			R := R * prevRi.			h :=  (((mi - m) \\ ri) * ti) \\ ri.			m :=  h * R + m.			prevRi := ri ] ]."	^m</body><body package="RSA" selector="simpleExponentPowerOf:">simpleExponentPowerOf: aLargeInteger	^aLargeInteger raisedTo: d modulo: n</body></methods><methods><class-id>Security.RSAPrivateKey class</class-id> <category>instance creation</category><body package="RSA" selector="d:n:">d: d n: n	^self new		d: d;		n: n;		yourself</body></methods><methods><class-id>Security.SHA</class-id> <category>rsa</category><body package="RSA" selector="derEncodedDigestInfo">derEncodedDigestInfo	^#[48 33 48 9 6 5 43 14 3 2 26 5 0 4 20].</body></methods><methods><class-id>Security.MD5</class-id> <category>rsa</category><body package="RSA" selector="derEncodedDigestInfo">derEncodedDigestInfo	^#[48 32 48 12 6 8 42 134 72 134 247 13 2 5 5 0 4 16]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>SHA</name><environment>Security</environment><super>Security.SHAHash</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t k </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>SHA</package></attributes></class><class><name>AsymmetricCipher</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>EncryptionKey</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>KeyGenerator</name><environment>Security</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keySize random primalityTest </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>MD5</name><environment>Security</environment><super>Security.Hash</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b c d aa bb cc dd f ff m </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>MD5</package></attributes></class></st-source>