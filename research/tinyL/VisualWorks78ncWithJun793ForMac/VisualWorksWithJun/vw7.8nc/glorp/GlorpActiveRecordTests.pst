<?xml version="1.0"?><st-source><!-- Name: GlorpActiveRecordTestsNotice: LGPL(S)The code is Copyright (C) 2000-2003  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USAComment: This holds tests for the GlorpActiveRecord package.DbIdentifier: bear73DbTrace: 183582DevelopmentPrerequisites: #(#(#any 'GlorpActiveRecord' '') #(#any 'GlorpTest' ''))ExplicitPrerequisites: #('SUnit')IgnoredPrerequisites: #('SUnit-Bridge2SU2')PackageName: GlorpActiveRecordTestsParcel: #('GlorpActiveRecordTests')PrerequisiteParcels: #(#('GlorpActiveRecord' '') #('GlorpTest' ''))PrintStringCache: (7.7 - 10,mlucassmith)Version: 7.7 - 10Date: 6:43:30 AM August 5, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 6:43:30 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GlorpActiveRecordTests</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Glorp.*			private Glorp.ActiveRecords.*			</imports><category></category><attributes><package>GlorpActiveRecordTests</package></attributes></name-space><comment><name-space-id>GlorpActiveRecordTests</name-space-id><body></body></comment><class><name>BankAccount</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bankAccountNumber customers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.BankAccount</class-id><body></body></comment><class><name>ActiveRecordSessionResource</name><environment>GlorpActiveRecordTests</environment><super>Glorp.GlorpSessionResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.ActiveRecordSessionResource</class-id><body></body></comment><class><name>GlorpImmutabilityOnVWTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>Glorp.GlorpImmutabilityOnVWTest</class-id><body></body></comment><class><name>ActiveRecordTest</name><environment>GlorpActiveRecordTests</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id><body></body></comment><class><name>TestActiveRecordDescriptorSystem</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.TestActiveRecordDescriptorSystem</class-id><body></body></comment><class><name>InflectorTest</name><environment>GlorpActiveRecordTests</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testData inflector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.InflectorTest</class-id><body></body></comment><class><name>Person</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name address </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.Person</class-id><body></body></comment><class><name>Address</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>street houseNum </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.Address</class-id><body></body></comment><class><name>Customer</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name bankTransactions bankAccounts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.Customer</class-id><body></body></comment><class><name>ActiveRecordValidationTest</name><environment>GlorpActiveRecordTests</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session blogPostClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.ActiveRecordValidationTest</class-id><body></body></comment><class><name>TreeNode</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>treeNodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.TreeNode</class-id><body></body></comment><class><name>BankTransaction</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner amount serviceCharge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.BankTransaction</class-id><body></body></comment><class><name>BankAccountNumber</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bankCode branchNumber accountNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.BankAccountNumber</class-id><body></body></comment><methods><class-id>GlorpActiveRecordTests.BankAccount</class-id> <category>accessing</category><body package="GlorpActiveRecordTests" selector="bankAccountNumber">bankAccountNumber	^bankAccountNumber</body><body package="GlorpActiveRecordTests" selector="bankAccountNumber:">bankAccountNumber: anObject	bankAccountNumber := anObject</body><body package="GlorpActiveRecordTests" selector="customers">customers	^customers</body><body package="GlorpActiveRecordTests" selector="customers:">customers: anObject	customers := anObject</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordSessionResource</class-id> <category>setup</category><body package="GlorpActiveRecordTests" selector="glorpTestsSystem">glorpTestsSystem	GlorpDemoTablePopulatorResource current.	system isNil ifTrue: [		system := TestActiveRecordDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database].	^system.</body><body package="GlorpActiveRecordTests" selector="setUp">setUp	super setUp.	ActiveRecord setSession: session.</body><body package="GlorpActiveRecordTests" selector="tearDown">tearDown	super tearDown.	ActiveRecord setSession: nil.</body></methods><methods><class-id>Glorp.GlorpImmutabilityOnVWTest</class-id> <category>testing</category><body package="GlorpActiveRecordTests" selector="getTrackerList">getTrackerList	^(Dialect smalltalkAt: #'WriteBarriers.Tracker') trackers.</body><body package="GlorpActiveRecordTests" selector="testAutoRegistrationUsingImmutabilityFlag">testAutoRegistrationUsingImmutabilityFlag	| person |	Dialect isVisualWorks ifFalse: [^self].	session beginTransaction.	session useModificationTracker.	[ session modify: GlorpPerson example1 in: [].	session reset.	person := session readOneOf: GlorpPerson. 	session beginUnitOfWork.	person name: 'foo'.	self assert: (session isRegistered: person)] ensure: [session rollbackUnitOfWork. session rollbackTransaction].</body><body package="GlorpActiveRecordTests" selector="testAutoRegistrationUsingImmutabilityFlagFail">testAutoRegistrationUsingImmutabilityFlagFail	| person |	Dialect isVisualWorks ifFalse: [^self].	session beginTransaction.	[ session modify: GlorpPerson example1 in: [].	session reset.	person := session readOneOf: GlorpPerson. 	session beginUnitOfWork.	person name: 'Foo'.	self deny: (session isRegistered: person)] ensure: [			session rollbackUnitOfWork.	session rollbackTransaction].</body><body package="GlorpActiveRecordTests" selector="testAutoRegistrationUsingImmutabilityFlagStartingUnitOfWork">testAutoRegistrationUsingImmutabilityFlagStartingUnitOfWork	| person |	Dialect isVisualWorks ifFalse: [^self].	session beginTransaction.	session useModificationTracker.	[ session modify: GlorpPerson example1 in: [].	session reset.	person := session readOneOf: GlorpPerson. 	person name: 'foo'.	self assert: (session isRegistered: person)] ensure: [session rollbackUnitOfWork. session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpImmutabilityOnVWTest</class-id> <category>support</category><body package="GlorpActiveRecordTests" selector="tearDown">tearDown	session dontUseModificationTracker.	super tearDown.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests-tree nodes</category><body package="GlorpActiveRecordTests" selector="testDeleteTreeNode">testDeleteTreeNode	"Make sure we don't delete out of order"	| allNodes |	self writeNodeWithChildren.	allNodes := session readManyOf: TreeNode.	session inUnitOfWorkDo: [allNodes do: [:each | session delete: each]].</body><body package="GlorpActiveRecordTests" selector="testReadTreeNode">testReadTreeNode	| allNodes |	self writeNodeWithChildren.	allNodes := session readManyOf: TreeNode orderBy: #id.	self assert: (allNodes collect: [:each | each id]) asArray = #( 1 2 3).	self assert: allNodes first children size = 2.	self assert: (allNodes first children collect: [:each | each id]) asSortedCollection asArray = #( 2 3).	self assert: allNodes first children first children isEmpty.</body><body package="GlorpActiveRecordTests" selector="writeNodeWithChildren">writeNodeWithChildren	| |	(GlorpManyToManyDBTest new session: session; treeNodeClass: TreeNode) writeNodeWithChildren.	session reset.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests-bank</category><body package="GlorpActiveRecordTests" selector="testBankAccount">testBankAccount	| account accounts |	account := BankAccount new 		id: 123;		bankAccountNumber: BankAccountNumber example12345.	session modify: account in: [].	session reset.	accounts := session read: BankAccount.	self assert: accounts size = 1.	self assert: accounts first id = account id.	self assert: accounts first customers size = 0.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>Running</category><body package="GlorpActiveRecordTests" selector="setUp">setUp	super setUp.	session := ActiveRecordSessionResource current newSession.	session login.	session beginTransaction.</body><body package="GlorpActiveRecordTests" selector="tearDown">tearDown	super tearDown.	session isNil ifFalse: [		session rollbackTransaction.		session reset].	ActiveRecord resetAllProcessVariables.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests</category><body package="GlorpActiveRecordTests" selector="testCompare">testCompare	| person1 person1_2 person2 |	person1 := Person example1.	person1_2 := Person example1.	person2 := Person example2.	self deny: person1 = person2.	self assert: person1 = person1.	self assert: person1 = person1_2.	person1 := Person new.	person2 := Person new.	self deny: person1 = person2</body><body package="GlorpActiveRecordTests" selector="testDeletePerson">testDeletePerson	| person people |	person := Person example1.	session modify: person in: [].	session reset.	people := session read: Person.	session delete: people first.	session reset.	people := session read: Person.	self assert: people size = 0.</body><body package="GlorpActiveRecordTests" selector="testPersonWithAddress">testPersonWithAddress	| person people addresses |	person := Person example2.	session modify: person in: [].	session reset.	people := session read: Person.	self assert: people size = 1.	self assert: people first id = person id.	self assert: people first name = person name.	self assert: people first address notNil.		addresses := session read: Address where: [:each | each id = people first address id].	self assert: addresses size = 1.	self assert: addresses first == people first address yourSelf.	self assert: addresses first street = person address street.	self assert: addresses first houseNum = person address houseNum.</body><body package="GlorpActiveRecordTests" selector="testReadPersonNoAddress">testReadPersonNoAddress	| person people |	person := Person example1.	session modify: person in: [].	session reset.	people := session read: Person.	self assert: people size = 1.	self assert: people first id = person id.	self assert: people first name = person name.	self assert: people first address isNil.</body><body package="GlorpActiveRecordTests" selector="testWritePersonNoAddress">testWritePersonNoAddress	| person rows |	person := Person example1.	session modify: person in: [].	rows := session accessor executeSQLString: 'SELECT * FROM PERSON'.	self assert: rows size = 1.	self assert: rows first first = person id.	self assert: (rows first at: 2) = person name.</body><body package="GlorpActiveRecordTests" selector="testWritePersonWithAddress">testWritePersonWithAddress	| person rows |	person := Person example2.	session modify: person in: [].	rows := session accessor executeSQLString: 'SELECT * FROM PERSON'.	self assert: rows size = 1.	self assert: rows first first = person id.	self assert: (rows first at: 2) = person name.	self assert: (rows first at: 3) notNil.	rows := session accessor executeSQLString: 'SELECT * FROM GR_ADDRESS'.	self assert: rows size = 1.	self assert: rows first first = person address id.	self assert: (rows first at: 2) = person address street.	self assert: (rows first at: 3) = person address houseNum.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests-class side methods</category><body package="GlorpActiveRecordTests" selector="testFind">testFind	| person |	person := Person example2.	session modify: person in: [].	session reset.	person := Person find: 2.	self assert: person notNil.	self assert: person name = 'John Doe'.</body><body package="GlorpActiveRecordTests" selector="testFindAll">testFindAll	| person people |	person := Person example2.	session modify: person in: [].	session reset.	people := Person findAll.	self assert: people size = 1.	self assert: people first name = 'John Doe'.</body><body package="GlorpActiveRecordTests" selector="testFindWhere">testFindWhere	| person people |	person := Person example2.	session modify: person in: [].	session reset.	people := Person findWhere: [:each | each id = 2].	self assert: people size = 1.	self assert: people first name = 'John Doe'.	people := Person findWhere: [:each | each id = 1].	self assert: people size = 0.</body><body package="GlorpActiveRecordTests" selector="testSave">testSave	| person |	Person example2 bePersistent; commitUnitOfWork.	session reset.	person := session readOneOf: Person.	self assert: person notNil.	self assert: person name = 'John Doe'.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests-instance side find</category><body package="GlorpActiveRecordTests" selector="testFindQBEByPrimaryKey">testFindQBEByPrimaryKey	| qbe people person |	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 2; session: session.	people := qbe find.	self assert: people size = 1.	self assert: people first id = 2.</body><body package="GlorpActiveRecordTests" selector="testFindQBEByPrimaryKeyNotFound">testFindQBEByPrimaryKeyNotFound	| qbe people person |	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 1; session: session.	people := qbe find.	self assert: people size = 0.</body><body package="GlorpActiveRecordTests" selector="testFindQBETwoAttributes">testFindQBETwoAttributes	| qbe people person |	person := Person example1 session: session.	person bePersistent; commitUnitOfWork.	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 2; name: 'John Doe'; session: session.	people := qbe find.	self assert: people size = 1.	self assert: people first id = 2.</body><body package="GlorpActiveRecordTests" selector="testFindQBETwoAttributesNotFound">testFindQBETwoAttributesNotFound	| qbe people person |	person := Person example1 session: session.	person bePersistent; commitUnitOfWork.	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 1; name: 'John Doe'; session: session.	people := qbe find.	self assert: people size = 0.</body><body package="GlorpActiveRecordTests" selector="testFindQBEWildcard">testFindQBEWildcard	| qbe people person |	person := Person example1 session: session.	person bePersistent; commitUnitOfWork.	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new name: 'John%'; session: session.	people := qbe find.	self assert: people size = 1.	self assert: people first name = 'John Doe'.</body><body package="GlorpActiveRecordTests" selector="testQBEMatchAttribute">testQBEMatchAttribute	| expression |	expression := (Person new matchAttribute: MessageArchiver new to: 'John Doe') asGlorpExpression.	self assert: expression relation = #=.</body><body package="GlorpActiveRecordTests" selector="testQBEMatchAttributeWildcard">testQBEMatchAttributeWildcard	| expression |	expression := (Person new matchAttribute: MessageArchiver new to: 'John%') asGlorpExpression.	self assert: expression relation = #LIKE.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest class</class-id> <category>resources</category><body package="GlorpActiveRecordTests" selector="resources">resources	^Array with: ActiveRecordSessionResource.</body></methods><methods><class-id>GlorpActiveRecordTests.TestActiveRecordDescriptorSystem</class-id> <category>initialize</category><body package="GlorpActiveRecordTests" selector="initialize">initialize	super initialize.	inflector pluralTableNames: false.</body></methods><methods><class-id>GlorpActiveRecordTests.TestActiveRecordDescriptorSystem</class-id> <category>validation</category><body package="GlorpActiveRecordTests" selector="validate">validate	| nonGeneratedTables id |	super validate.	nonGeneratedTables := tables select: [:each | 		id := each fieldNamed: 'ID' ifAbsent: [nil] caseSensitive: false.		id isNil ifTrue: [true] ifFalse: [id type class ~~ GlorpSerialType]].	"Ick. We have to know how many there ought to be that don't match."	nonGeneratedTables size ~= 8 ifTrue: [self error: 'Incorrect field types for IDs'].</body></methods><methods><class-id>GlorpActiveRecordTests.TestActiveRecordDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpActiveRecordTests" selector="descriptorForAddress:">descriptorForAddress: aDescriptor	aDescriptor table: (self tableNamed: 'GR_ADDRESS').</body><body package="GlorpActiveRecordTests" selector="descriptorForBankAccount:">descriptorForBankAccount: aDescriptor	aDescriptor table: (self tableNamed: 'BANK_ACCT').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)		attributeName: #bankAccountNumber;		referenceClass: BankAccountNumber.</body><body package="GlorpActiveRecordTests" selector="descriptorForBankAccountNumber:">descriptorForBankAccountNumber: aDescriptor	aDescriptor table: (self tableNamed: 'BANK_ACCT').	self mappingNamed: #bankCode do: [:mapping |		mapping type: Integer].</body><body package="GlorpActiveRecordTests" selector="descriptorForBankTransaction:">descriptorForBankTransaction: aDescriptor	aDescriptor table: (self tableNamed: 'BANK_TRANS').</body><body package="GlorpActiveRecordTests" selector="descriptorForCustomer:">descriptorForCustomer: aDescriptor	aDescriptor table: (self tableNamed: 'GR_CUSTOMER').</body></methods><methods><class-id>GlorpActiveRecordTests.InflectorTest</class-id> <category>tests</category><body package="GlorpActiveRecordTests" selector="testCamelize">testCamelize 	self myTestData: self camelWithNamespaceToUnderscoreWithDotTestData.	self myTestData do: [:each | | camelized |		camelized := inflector camelize: each value.		 self assert: camelized = each key].</body><body package="GlorpActiveRecordTests" selector="testCamelizeWithModule">testCamelizeWithModule 	self myTestData: self camelWithNamespaceToUnderscoreWithDotTestData.	self myTestData do: [:each | | camelized |		camelized := inflector camelize: each value firstLetterInUppercase: true.		 self assert: camelized = each key].</body><body package="GlorpActiveRecordTests" selector="testClassify">testClassify  	self myTestData: self classNameToTableNameTestData.	self myTestData do: [:each | | className |		className := inflector classify: each value.		 self assert: className = each key].</body><body package="GlorpActiveRecordTests" selector="testClassifyNonPluralTables">testClassifyNonPluralTables	Inflector default pluralTableNames: false. 	self myTestData: self classNameToTableNameTestDataNonPlural.	self myTestData do: [:each | | className |		className := inflector classify: each value.		 self assert: className = each key].</body><body package="GlorpActiveRecordTests" selector="testDasherize">testDasherize 	self myTestData: self underscoresToDashesTestData.	self myTestData do: [:each | | dashed |		dashed := inflector dasherize: each key.		 self assert: dashed = each value].</body><body package="GlorpActiveRecordTests" selector="testDemodulize">testDemodulize 	self assert: 'Account' = (inflector demodulize: 'MyApplication::Billing::Account').</body><body package="GlorpActiveRecordTests" selector="testForeignKey">testForeignKey 	self myTestData: self classNameToForeignKeyWithUnderscoreTestData.	self myTestData do: [:each | | foreignKey |		foreignKey := inflector foreignKey: each key.		 self assert: foreignKey = each value].	self myTestData: self classNameToForeignKeyWithoutUnderscoreTestData.	self myTestData do: [:each | | foreignKey |		foreignKey := inflector foreignKey: each key separateWithUnderscore: false.		 self assert: foreignKey = each value].</body><body package="GlorpActiveRecordTests" selector="testGsub">testGsub 	self assert: ('hello' replaceRegex: '[aeiou]' withString: '*') = 'h*ll*'. 	self assert: ('hello' replaceRegex: '([aeiou])' withString: '&lt;\1&gt;') = 'h&lt;e&gt;ll&lt;o&gt;'. 	self assert: ('hello' replaceRegex: '.' withString: [:each | each first asInteger printString, ' ']) = '104 101 108 108 111 '.</body><body package="GlorpActiveRecordTests" selector="testHumanize">testHumanize 	self myTestData: self underscoreToHumanTestData.	self myTestData do: [:each | | human |		human := inflector humanize: each key.		 self assert: human = each value].</body><body package="GlorpActiveRecordTests" selector="testOrdinals">testOrdinals 	self myTestData: self ordinalTestData.	self myTestData do: [:each | | ordinalized |		ordinalized := inflector ordinalize: each key.		 self assert: ordinalized = each value].</body><body package="GlorpActiveRecordTests" selector="testPluralizePlurals">testPluralizePlurals  	self assert: ('plurals' = (inflector pluralize: 'plurals')).  	self assert: ('Plurals' = (inflector pluralize: 'Plurals')).</body><body package="GlorpActiveRecordTests" selector="testSingularToPlural">testSingularToPlural 	self myTestData: self singularToPluralTestData.	self myTestData do: [:each | | plural |		plural := inflector pluralize: each key.		 self assert: plural = each value].</body><body package="GlorpActiveRecordTests" selector="testTableize">testTableize 	self myTestData: self classNameToTableNameTestData.	self myTestData do: [:each |  | tableized |		tableized := inflector tableize: each key.		self assert: tableized = each value].</body><body package="GlorpActiveRecordTests" selector="testTableizeNonPlural">testTableizeNonPlural	Inflector default pluralTableNames: false. 	self myTestData: self classNameToTableNameTestDataNonPlural.	self myTestData do: [:each |  | tableized |		tableized := inflector tableize: each key.		self assert: tableized = each value].</body><body package="GlorpActiveRecordTests" selector="testUnderscore">testUnderscore 	self myTestData: self camelToUnderscoreTestData.	self myTestData do: [:each | self assert: (inflector underscore: each key) = each value]. 	self myTestData: self camelToUnderscoreWithoutReverseTestData.	self myTestData do: [:each | self assert: (inflector underscore: each key) = each value].</body><body package="GlorpActiveRecordTests" selector="testUnderscoreAsReverseOfDasherize">testUnderscoreAsReverseOfDasherize 	self myTestData: self underscoresToDashesTestData.	self myTestData do: [:each | | dashed |		dashed := inflector underscore: (inflector dasherize: each key).		self assert: (dashed = each key)].</body><body package="GlorpActiveRecordTests" selector="testUnderscoreToLowerCamel">testUnderscoreToLowerCamel 	self myTestData: self underscoreToLowerCamelTestData.	self myTestData do: [:each | | camelized |		camelized := inflector camelize: each key firstLetterInUppercase: false.		self assert: (camelized = each value)].</body><body package="GlorpActiveRecordTests" selector="testUnderscoreWithSlashes">testUnderscoreWithSlashes 	self myTestData: self camelWithModuleToUnderscoreWithSlashesTestData.	self myTestData do: [:each |  | underscored |		underscored := inflector underscore: each key.		self assert: underscored = each value].</body></methods><methods><class-id>GlorpActiveRecordTests.InflectorTest</class-id> <category>test data</category><body package="GlorpActiveRecordTests" selector="camelToUnderscoreTestData">camelToUnderscoreTestData	^#('Product' -&gt; 'product' 'SpecialGuest' -&gt; 'special_guest' 'ApplicationController' -&gt; 'application_controller' 'Area51Controller' -&gt; 'area51_controller')</body><body package="GlorpActiveRecordTests" selector="camelToUnderscoreWithoutReverseTestData">camelToUnderscoreWithoutReverseTestData	^#('HTMLTidy' -&gt; 'html_tidy' 'HTMLTidyGenerator' -&gt; 'html_tidy_generator' 'FreeBSD' -&gt; 'free_bsd' 'HTML' -&gt; 'html').</body><body package="GlorpActiveRecordTests" selector="camelWithModuleToUnderscoreWithSlashesTestData">camelWithModuleToUnderscoreWithSlashesTestData	^#('Admin::Product' -&gt; 'admin/product' 'Users::Commission::Department' -&gt; 'users/commission/department' 'UsersSection::CommissionDepartment' -&gt; 'users_section/commission_department').</body><body package="GlorpActiveRecordTests" selector="camelWithNamespaceToUnderscoreWithDotTestData">camelWithNamespaceToUnderscoreWithDotTestData	^#( 'Admin.Product' -&gt; 'admin.product' 'Users.Commission.Department' -&gt; 'users.commission.department' 'UsersSection.CommissionDepartment' -&gt; 'users_section.commission_department').</body><body package="GlorpActiveRecordTests" selector="classNameToForeignKeyWithUnderscoreTestData">classNameToForeignKeyWithUnderscoreTestData	^#( 'Person' -&gt; 'person_id' 'MyApplication::Billing::Account' -&gt; 'account_id').</body><body package="GlorpActiveRecordTests" selector="classNameToForeignKeyWithoutUnderscoreTestData">classNameToForeignKeyWithoutUnderscoreTestData	^#( 'Person' -&gt; 'personid'  'MyApplication::Billing::Account' -&gt; 'accountid').</body><body package="GlorpActiveRecordTests" selector="classNameToTableNameTestData">classNameToTableNameTestData	^#('PrimarySpokesman' -&gt; 'primary_spokesmen' 'NodeChild' -&gt; 'node_children' 'Address' -&gt; 'addresses').</body><body package="GlorpActiveRecordTests" selector="classNameToTableNameTestDataNonPlural">classNameToTableNameTestDataNonPlural	^#('PrimarySpokesman' -&gt; 'primary_spokesman' 'NodeChild' -&gt; 'node_child' 'Address' -&gt; 'address').</body><body package="GlorpActiveRecordTests" selector="ordinalTestData">ordinalTestData	^#('0' -&gt; '0th' '1' -&gt; '1st' '2' -&gt; '2nd' '3' -&gt; '3rd' '4' -&gt; '4th' '5' -&gt; '5th' '6' -&gt; '6th' '7' -&gt; '7th' '8' -&gt; '8th' '9' -&gt; '9th' '10' -&gt; '10th' '11' -&gt; '11th' '12' -&gt; '12th' '13' -&gt; '13th' '14' -&gt; '14th' '20' -&gt; '20th' '21' -&gt; '21st' '22' -&gt; '22nd' '23' -&gt; '23rd' '24' -&gt; '24th' '100' -&gt; '100th' '101' -&gt; '101st' '102' -&gt; '102nd' '103' -&gt; '103rd' '104' -&gt; '104th' '110' -&gt; '110th' '1000' -&gt; '1000th' '1001' -&gt; '1001st').</body><body package="GlorpActiveRecordTests" selector="singularToPluralTestData">singularToPluralTestData 	^#( 'search' -&gt; 'searches' 'switch' -&gt; 'switches' 'fix' -&gt; 'fixes' 'box' -&gt; 'boxes' 'process' -&gt; 'processes' 'address' -&gt; 'addresses' 'case' -&gt; 'cases' 'stack' -&gt; 'stacks' 'wish' -&gt; 'wishes' 'fish' -&gt; 'fish' 'category' -&gt; 'categories' 'query' -&gt; 'queries' 'ability' -&gt; 'abilities' 'agency' -&gt; 'agencies' 'movie' -&gt; 'movies' 'archive' -&gt; 'archives' 'index' -&gt; 'indices' 'wife' -&gt; 'wives' 'safe' -&gt; 'saves' 'half' -&gt; 'halves' 'move' -&gt; 'moves' 'salesperson' -&gt; 'salespeople' 'person' -&gt; 'people' 'spokesman' -&gt; 'spokesmen' 'man' -&gt; 'men' 'woman' -&gt; 'women' 'basis' -&gt; 'bases' 'diagnosis' -&gt; 'diagnoses' 'datum' -&gt; 'data' 'medium' -&gt; 'media' 'analysis' -&gt; 'analyses' 'node_child' -&gt; 'node_children' 'child' -&gt; 'children' 'experience' -&gt; 'experiences' 'day' -&gt; 'days' 'comment' -&gt; 'comments' 'foobar' -&gt; 'foobars' 'newsletter' -&gt; 'newsletters' 'old_news' -&gt; 'old_news' 'news' -&gt; 'news' 'series' -&gt; 'series' 'species' -&gt; 'species' 'quiz' -&gt; 'quizzes' 'perspective' -&gt; 'perspectives' 'ox' -&gt; 'oxen' 'photo' -&gt; 'photos' 'buffalo' -&gt; 'buffaloes' 'tomato' -&gt; 'tomatoes' 'dwarf' -&gt; 'dwarves' 'elf' -&gt; 'elves' 'information' -&gt; 'information' 'equipment' -&gt; 'equipment' 'bus' -&gt; 'buses' 'status' -&gt; 'statuses' 'status_code' -&gt; 'status_codes' 'mouse' -&gt; 'mice' 'louse' -&gt; 'lice' 'house' -&gt; 'houses' 'octopus' -&gt; 'octopi' 'virus' -&gt; 'viri' 'alias' -&gt; 'aliases' 'portfolio' -&gt; 'portfolios' 'vertex' -&gt; 'vertices' 'matrix' -&gt; 'matrices' 'axis' -&gt; 'axes' 'testis' -&gt; 'testes' 'crisis' -&gt; 'crises' 'rice' -&gt; 'rice' 'shoe' -&gt; 'shoes' 'horse' -&gt; 'horses' 'prize' -&gt; 'prizes' 'edge' -&gt; 'edges' 'address' -&gt; 'addresses').</body><body package="GlorpActiveRecordTests" selector="underscoreToHumanTestData">underscoreToHumanTestData	^#('employee_salary' -&gt; 'Employee salary' 'employee_id' -&gt; 'Employee' 'underground' -&gt; 'Underground').</body><body package="GlorpActiveRecordTests" selector="underscoreToLowerCamelTestData">underscoreToLowerCamelTestData	^#('product' -&gt; 'product' 'special_guest' -&gt; 'specialGuest' 'application_controller' -&gt; 'applicationController' 'area51_controller' -&gt; 'area51Controller').</body><body package="GlorpActiveRecordTests" selector="underscoresToDashesTestData">underscoresToDashesTestData	^#('street' -&gt; 'street' 'street_address' -&gt; 'street-address' 'person_street_address' -&gt; 'person-street-address')</body></methods><methods><class-id>GlorpActiveRecordTests.InflectorTest</class-id> <category>support</category><body package="GlorpActiveRecordTests" selector="myTestData">myTestData	^testData.</body><body package="GlorpActiveRecordTests" selector="myTestData:">myTestData: anArray	testData := OrderedCollection new.	1 to: anArray size by: 3 do: [:i |		testData add: ((anArray at: i) perform: (anArray at: i+1) with: (anArray at: i+2))].</body><body package="GlorpActiveRecordTests" selector="setUp">setUp	super setUp.	"Make sure we get the latest rules"	Inflector reset.	inflector := Inflector inflections.	inflector pluralTableNames: true.</body></methods><methods><class-id>GlorpActiveRecordTests.Person</class-id> <category>accessing</category><body package="GlorpActiveRecordTests" selector="address">address	^address</body><body package="GlorpActiveRecordTests" selector="address:">address: aString	address := aString</body><body package="GlorpActiveRecordTests" selector="id">id	^id</body><body package="GlorpActiveRecordTests" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpActiveRecordTests" selector="name">name	^name</body><body package="GlorpActiveRecordTests" selector="name:">name: aString	name := aString</body></methods><methods><class-id>GlorpActiveRecordTests.Person class</class-id> <category>examples</category><body package="GlorpActiveRecordTests" selector="example1">example1	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: nil.</body><body package="GlorpActiveRecordTests" selector="example2">example2	^self new		id: 2;		name: 'John Doe';		address: Address example2.</body></methods><methods><class-id>GlorpActiveRecordTests.Address</class-id> <category>accessing</category><body package="GlorpActiveRecordTests" selector="houseNum">houseNum	^houseNum</body><body package="GlorpActiveRecordTests" selector="houseNum:">houseNum: aString	houseNum := aString</body><body package="GlorpActiveRecordTests" selector="id">id	^id</body><body package="GlorpActiveRecordTests" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpActiveRecordTests" selector="street">street	^street</body><body package="GlorpActiveRecordTests" selector="street:">street: aString	street := aString</body></methods><methods><class-id>GlorpActiveRecordTests.Address class</class-id> <category>examples</category><body package="GlorpActiveRecordTests" selector="example2">example2	^self new		id: 2;		street: 'Nowhere';		houseNum: '1000'.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordValidationTest</class-id> <category>testing</category><body package="GlorpActiveRecordTests" selector="testNoTableFound">testNoTableFound	|  system |	system := TestActiveRecordDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.	self 		should: [session := system sessionForLogin: GlorpDatabaseLoginResource current login]		raise: Glorp.NoTableFound.	self assert: session isNil. 	[session := system sessionForLogin: GlorpDatabaseLoginResource current login.	self assert: true]		on: Glorp.NoTableFound		do: [ :ex | 			self assert: ( 'No table found for BlogPost, expected to see one of  #(''blog_post'' ''blog_posts'')' match: ex printString).			ex proceed ].	self assert: session notNil</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordValidationTest</class-id> <category>Running</category><body package="GlorpActiveRecordTests" selector="setUp">setUp	| none |	none := Store.Registry packageNamed: '(none)'.	Store.Policies packagePolicy 		forcePackage: none		while: [blogPostClass := Smalltalk.GlorpActiveRecordTests				defineClass: #BlogPost asSymbol				superclass: #'Glorp.ActiveRecords.ActiveRecord' asStrictReference				indexedType: #none				private: false				instanceVariableNames: ''				classInstanceVariableNames: ''				imports: ''				category: ' '. ].</body><body package="GlorpActiveRecordTests" selector="tearDown">tearDown	session ifNotNil: [ session logout].	(Refactory.Browser.RemoveClassChange removeClassName: blogPostClass fullName) execute.</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode</class-id> <category>printing</category><body package="GlorpActiveRecordTests" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(; print: id; nextPut: $).</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode</class-id> <category>accessing</category><body package="GlorpActiveRecordTests" selector="children">children	^self treeNodes</body><body package="GlorpActiveRecordTests" selector="id">id	^id</body><body package="GlorpActiveRecordTests" selector="id:">id: anObject	id := anObject</body><body package="GlorpActiveRecordTests" selector="treeNodes">treeNodes	^treeNodes.</body><body package="GlorpActiveRecordTests" selector="treeNodes:">treeNodes: aCollection	treeNodes := aCollection.</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode</class-id> <category>initialize</category><body package="GlorpActiveRecordTests" selector="initialize">initialize	super initialize.	treeNodes := OrderedCollection new.</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode class</class-id> <category>configuration</category><body package="GlorpActiveRecordTests" selector="hasAndBelongsToMany">hasAndBelongsToMany	^#(treeNodes).</body></methods><methods><class-id>GlorpActiveRecordTests.BankAccountNumber</class-id> <category>accessing</category><body package="GlorpActiveRecordTests" selector="accountNumber">accountNumber	^accountNumber</body><body package="GlorpActiveRecordTests" selector="accountNumber:">accountNumber: anObject	accountNumber := anObject</body><body package="GlorpActiveRecordTests" selector="bankCode">bankCode	^bankCode</body><body package="GlorpActiveRecordTests" selector="bankCode:">bankCode: anObject	bankCode := anObject</body><body package="GlorpActiveRecordTests" selector="branchNumber">branchNumber	^branchNumber</body><body package="GlorpActiveRecordTests" selector="branchNumber:">branchNumber: anObject	branchNumber := anObject</body></methods><methods><class-id>GlorpActiveRecordTests.BankAccountNumber class</class-id> <category>examples</category><body package="GlorpActiveRecordTests" selector="example12345">example12345	^self new		accountNumber: 12345;		bankCode: 4;		branchNumber: 777.</body></methods><methods><class-id>Glorp.GlorpDirectMappingDBTest</class-id> <category>tests</category><body package="GlorpActiveRecordTests" selector="testTwoMappingsToSubselectNonProxied">testTwoMappingsToSubselectNonProxied	"There are some awful sharing bugs that were manifesting with relationships that made use of the direct-to-subselect mapping. Let's actually test it on the mapping that manifested it, in mapping to the information_schema."	| constraint |	session system platform supportsInformationSchema ifFalse: [^self knownFailure].	[		session system: (MetadataDescriptorSystem forPlatform: session system platform).		((session system descriptorFor: DatabaseField) mappingForAttributeNamed: #isPrimaryKey) shouldProxy: false.		constraint := session readOneOf: ForeignKeyConstraint where: [:each | each name asLowercase = 'gr_message_to_gr_folder__ref2'].		"Note: proxies to booleans confuse if statements"		self assert: constraint sourceFields first isPrimaryKey yourSelf.		self assert: constraint sourceFields last isPrimaryKey yourSelf.		self assert: constraint targetFields first isPrimaryKey yourSelf.		self assert: constraint targetFields last isPrimaryKey yourSelf.		self assert: constraint sourceFields size = 2.		self assert: constraint targetFields size = 2.		self deny: (constraint targetFields includes: constraint sourceFields first).	 ]		ensure: [session rollbackTransaction].</body><body package="GlorpActiveRecordTests" selector="testTwoMappingsToSubselectProxied">testTwoMappingsToSubselectProxied	"There are some awful sharing bugs that were manifesting with relationships that made use of the direct-to-subselect mapping. Let's actually test it on the mapping that manifested it, in mapping to the information_schema."	| constraint |	session system platform supportsInformationSchema ifFalse: [^self knownFailure].	[		session system: (MetadataDescriptorSystem forPlatform: session system platform).		constraint := session readOneOf: ForeignKeyConstraint where: [:each | each name asLowercase = 'gr_message_to_gr_folder__ref2'].		"Note: proxies to booleans confuse if statements"		self assert: constraint sourceFields first isPrimaryKey yourSelf.		self assert: constraint sourceFields last isPrimaryKey yourSelf.		self assert: constraint targetFields first isPrimaryKey yourSelf.		self assert: constraint targetFields last isPrimaryKey yourSelf.		self assert: constraint sourceFields size = 2.		self assert: constraint targetFields size = 2.		self assert: constraint sourceFields first name = constraint targetFields first name.	 ]		ensure: [session rollbackTransaction].</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>GlorpSessionBasedTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>GlorpSessionResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ActiveRecord</name><environment>Glorp.ActiveRecords</environment><super>Glorp.PersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>GlorpDirectMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class></st-source>