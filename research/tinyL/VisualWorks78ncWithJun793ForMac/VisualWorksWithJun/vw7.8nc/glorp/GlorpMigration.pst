<?xml version="1.0"?><st-source><!-- Name: GlorpMigrationNotice: LGPL(S)The code is Copyright (C) 2008  Cincom SystemsThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USAComment: The package allows migrating from one schema version to another. The migration steps include - creating a new database schema descriptor- calculating changes between database schema versions- applying changes to a databaseCreating a new version of a database descriptor system.MyDescriptorSystem newDatabaseSchema: 'MyDescriptorSystem_V1'.The MyDescriptorSystem_V1 class will include all methods that describe tables from MyDescriptorSystem and a new method #migrationAncestor  that returns the MyDescriptorSystem. This method is used to calculate the migration path. For example.Load the WVExample-BlogServer package and execute:BlogDatabaseSchema newDatabaseSchema: ' MyBlogDatabaseSchema_v1'.There is MyBlogDatabaseSchema_v1 created in the WVExample-BlogServer package.Migration.In the new cloned version you can do some changes in the database schema and then migrate your database to a new version.Let's do some changes in your new class MyBlogDatabaseSchema_v1. For example you can add the new #filler column to your database table POSTS:tableForPOSTS: aTable	(aTable createFieldNamed: 'id' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'title' type: (platform varchar: 200).	aTable createFieldNamed: 'content' type: platform text.	aTable createFieldNamed: 'created' type: platform timestamp.	aTable createFieldNamed: 'filler' type: ( platform varchar: 20 )Now we can migrate to the new database schema.The migration API allows you to generate a migration script, review and update it before applying the schema changes to a database.To run our example now we need a database connection.Glorp.GlorpDatabaseLoginResource defaultLogin: ((Login new)		database: PostgreSQLPlatform new;		username: 'user';		password: 'xxxx';		connectString: 'localhost:5432_postgres').DatabaseAccessor loggingEnabled: true. <-  it helps to see the SQL statements in the system transcript.Initialize the source description system:session := BlogDatabaseSchema sessionForLogin: GlorpDatabaseLoginResource current login.sourceDescriptorSystem := session system.If your database doesn't have the POSTS and COMMENTS tables to run the example you need the create tables from the descriptor system.session recreateTables..Create an instance of the database descriptor we are going to migrate to:sourceDescriptorSystem := (MyBlogDatabaseSchema_v1 sessionForLogin: GlorpDatabaseLoginResource current login) system.Create a migration script to migrate from  BlogDatabaseSchema to MyBlogDatabaseSchema_v1:sourceDescriptorSystem createDefaultMigrationScriptFor: destinationDescriptorSystem.There is a new method in BlogDatabaseSchema:migrationScriptTo MyBlogDatabaseSchema_v1: aMigrationChangeSet	<migrationScriptTo: # MyBlogDatabaseSchema_v1>	aMigrationChangeSet addFieldNamed: 'filler' toTableNamed: 'posts'.You can modify the script before applying the schema changes to a database. Additional script API can be found in the MigrationChangeSet class in protocols such as 'api - add/drop field', 'api - add/drop foreign key' and etc.Having the migration script you can migrate to a new version:sourceDescriptorSystem migrateTo: destinationDescriptorSystem.DbIdentifier: bear73DbTrace: 186701DevelopmentPrerequisites: #(#(#bundle 'Glorp' '') #(#any 'Database' '') #(#any 'GlorpActiveRecord' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #()PackageName: GlorpMigrationParcel: #('GlorpMigration')PrerequisiteParcels: #(#('Database' '') #('GlorpActiveRecord' ''))PrintStringCache: (7.7 - 17,tkogan)Version: 7.7 - 17Date: 6:43:34 AM August 5, 2009 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.7 (aug09.0) of August 5, 2009 on August 5, 2009 at 6:43:34 AM </time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Migration</name><environment>Glorp</environment><private>false</private><imports>			private Glorp.*			</imports><category>GlorpMigration</category><attributes><package>GlorpMigration</package></attributes></name-space><comment><name-space-id>Glorp.Migration</name-space-id><body></body></comment><class><name>MigrationOperation</name><environment>Glorp.Migration</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseTable destination source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.MigrationOperation</class-id><body>MigrationOperation is an abstract class for migration operations. The operations know how to write a migration script and apply changes to a database.Subclasses must implement the following messages:	api		applyInSession:		writeFor:on:Instance Variables:	databaseTable	&lt;DatabaseTable&gt; database table	destination	&lt;DescriptorSystem&gt; destination system the operation is described in	source	&lt;DescriptorSystem&gt; source system the operation will be applied to</body></comment><class><name>AddField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField fieldType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.AddField</class-id><body>AddField adds a database column to a tableInstance Variables:	databaseField	&lt;DatabaseField&gt;	database field to add to a table	fieldType	&lt;GlorpDatabaseType&gt;	database field type</body></comment><class><name>ScriptError</name><environment>Glorp.Migration</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ScriptError</class-id><body>ScriptError will be raised while creating a migration operation from a script. The exception is resumable.</body></comment><class><name>DropForeignKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id><body>DropForeignKeyConstraint drops a foreign key constraintInstance Variables:	constraint	&lt;ForeignKeyConstraint&gt;	constraint to drop</body></comment><class><name>TableCopyForMigration</name><environment>Glorp.Migration</environment><super>Glorp.DatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.TableCopyForMigration</class-id><body>TableCopyForMigration is used to copy database tables to protect the original database definition.</body></comment><class><name>CopyTableData</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>destinationTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CopyTableData</class-id><body>CopyTableData copies data from #databaseTable to #destinationTableInstance Variables:	destinationTable	&lt;DatabaseTable&gt;	destination table</body></comment><class><name>CompositeMigrationOperation</name><environment>Glorp.Migration</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source destination </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CompositeMigrationOperation</class-id><body>CompositeMigrationOperation represents a multiple operations in steps in a chained migration. Say we are migrating from v.1 to v. 10 of a database schema along a migration path v.1, v.2, etc. Each of the intermediate migrations will be represented by instances of subclasses of CompositeMigrationOperation.Instance Variables:	destination	&lt;Symbol&gt;	symbolic name of the class that is the destination of the intermediate migration.	source	&lt;Symbol&gt;	symbolic name of the class that is the source of the intermediate migration.</body></comment><class><name>ScriptedOperations</name><environment>Glorp.Migration</environment><super>Glorp.Migration.CompositeMigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ScriptedOperations</class-id><body>ScriptedMigrationStep represents a single step in a chained migration. Say we are migrating from v.1 to v. 10 of a database schema. There are existing scripts to migrate from v.3 to v. 4, and v. 4 to v. 5. These two scripts will be represented by instances of ScriptedMigrationStep.Instance Variables:	selector	&lt;Symbol&gt; a script selector</body></comment><class><name>RenameTable</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newTableName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.RenameTable</class-id><body>RenameTable renames a database table.Instance Variables:	newTableName	&lt;String&gt;	new table name</body></comment><class><name>CalculatingChangeSetError</name><environment>Glorp.Migration</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source destination </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CalculatingChangeSetError</class-id><body>CalculatingChangeSetError will be raised while calculating a migration change set if - the source descriptor system has more than one script to migrate to the destination system- the source system migration path doesn't include the destination system.Instance Variables:	destination	&lt;DescriptorSystem&gt;	description of destination	source	&lt;DescriptorSystem&gt;	description of source</body></comment><class><name>CreatePrimaryKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id><body>CreatePrimaryKeyConstraint creates a primary key constraintInstance Variables:	constraint	&lt;PrimaryKeyConstraint&gt; primary key constraint</body></comment><class><name>CalculatedOperations</name><environment>Glorp.Migration</environment><super>Glorp.Migration.CompositeMigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CalculatedOperations</class-id><body>The following comment was cloned from the original comment of ScriptedMigrationStep==========================================================CalculatedMigrationStep represents a single step in a chained migration. Say we are migrating from v.1 to v. 10 of a database schema. There are no existing scripts to migrate from v.3 to v. 4, and v. 4 to v. 5. The corresponding migration steps will be represented by instances of CalculatedMigrationStep.</body></comment><class><name>MigrationScriptError</name><environment>Glorp.Migration</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.MigrationScriptError</class-id><body></body></comment><class><name>DropField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropField</class-id><body>DropField drops a database columnInstance Variables:	databaseField	&lt;DatabaseField&gt;	database field to drop</body></comment><class><name>RenameField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField newFieldName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.RenameField</class-id><body>RenameField renames a database fieldInstance Variables:	databaseField	&lt;DatabaseField&gt;	database field to rename 	newFieldName	&lt;String&gt;	 new field name</body></comment><class><name>DropTable</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropTable</class-id><body>DropTable drops a database table</body></comment><class><name>CreateTable</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CreateTable</class-id><body>CreateTable creates a database table</body></comment><class><name>MigrationError</name><environment>Glorp.Migration</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>migrationOperation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.MigrationError</class-id><body>MigrationError will be raise if an error occurs while applying changes to a database. The #messageText will try to retrive the database error description.Instance Variables:	migrationOperation	&lt;MigrationOperation&gt; currently executed migration operation </body></comment><class><name>ScriptErrors</name><environment>Glorp.Migration</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ScriptErrors</class-id><body>ScriptErrors collects all ScriptError's when the migration operations are created from a scriptInstance Variables:	selector	&lt;Symbol&gt;	script method selector </body></comment><class><name>MigrationChangeSet</name><environment>Glorp.Migration</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source destination operations destinationTables sourceTables currentDestination currentSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.MigrationChangeSet</class-id><body>MigrationChangeSet allows migrating from one database schema to another. The migration can include the following steps:- calculating changes from one database descriptor system to another as a collection of migration operations- the migration operations can be saved as a script and modified- the migration operations can be created from a migration script- applying the migration operations to the database.Instance Variables:	source	&lt;DescriptorSystem&gt; the source database schema	destination	&lt;DescriptorSystem&gt; the destination database schema	operations	&lt;(Collection of: MigrationOperation)&gt; individual operations are instances of MigrationOperation subclasses. When a MigrationChangeSet is applied, the migration operations get applied in the same order they have been previously added to the change set view #addOperation: method. Each of the API methods should result in exactly one #addOperation: message send.	destinationTables	&lt;Dictionary&gt; destinationTables hold migration copies of the &lt;DatabaseTable&gt; instances as set up by the destination schema.	sourceTables	&lt;Dictionary&gt; sourceTables hold migration copies of the &lt;DatabaseTable&gt; instances as set up by the source schema.	currentDestination	&lt;DescriptorSystem&gt; Intermediate destination	currentSource	&lt;DescriptorSystem&gt; Intermediate source. For the migration operations defined in scripts we need the script source and  destination if they are different from the original source and final destination. For example,  if we have migration path: v1-&gt;v2-&gt;v3-&gt;v4-&gt;v5 versions and v2 has a migration script to v3 that adds a new field. The information about this field type will be in the v3 version but may not be in the final v5.Calculating migration operations.- if there is no migration scripts between descriptor system version  V1 and VN the migration operations are calculated as difference between V1 and VN and all intermediate versions are ignored.- if there is a migration script for example in version V10 the migration operations are calculated in a few steps:	- collected operations from V1 to V10	- collected operations from V10 script	- collected operations from V10 to VNError handlingCalculatingChangeSetError will be raised while calculating a migration change set if - the source descriptor system has more than one script to migrate to the destination system- the source system migration path doesn't include the destination system.All script errors will be collected and raised as ScriptErrors.MigrationError will be raise if an error occurs while applying changes to a database. The #messageText will try to retrive the database error description.</body></comment><class><name>ExecuteSql</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ExecuteSql</class-id><body>ExecuteSql executes a database SQL statementInstance Variables:	sqlString	&lt;String&gt;	sqlString to execute</body></comment><class><name>CreateForeignKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id><body>CreateForeignKeyConstraint creates a foreign key contstraint Instance Variables:	constraint	&lt;ForeignKeyConstraint&gt; foreign key constraint</body></comment><class><name>AlterField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField isNullable isUnique isLockKey defaultValue type dropDefault </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.AlterField</class-id><body>AlterField alters a database column. Currently supported  #type, #defaultValue and #isNullable changes.Instance Variables:	databaseField	&lt;DatabaseField&gt;	database field	defaultValue	&lt;Object&gt;	if not nil the database field default value will be set to this value	dropDefault	&lt;Boolean&gt;	dropDefault if true the #defaultValue will be set to nil	isLockKey	&lt;Boolean&gt;	not suported	isNullable	&lt;Boolean&gt;	if true the database field will drop NOT NULL attribute. If false the database field will be altered with NOT NULL attribute.	isUnique	&lt;Boolean&gt;	not supported currently. 	type	&lt;GlorpDatabaseType&gt;	if not nil  the database field type will be changed to a new type</body></comment><class><name>CopyFieldData</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fromField toField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CopyFieldData</class-id><body>CopyFieldData copies database field data from #fromField to #toFieldInstance Variables:	fromField	&lt;DatabaseField&gt;	description of fromField	toField	&lt;DatabaseField&gt;	description of toField</body></comment><class><name>DropPrimaryKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id><body>DropPrimaryKeyConstraint drops a primary key constraint</body></comment><class><name>PopulateField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField fieldValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.PopulateField</class-id><body>PopulateField populates a database field with some data. If the field type is different than the #fieldValue type the database will raise an error.Instance Variables:	databaseField	&lt;DatabaseField&gt;	database field	fieldValue	&lt;Object&gt;	filed value</body></comment><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>accessing</category><body package="GlorpMigration" selector="databasePlatform">databasePlatform	^ self databaseTable platform</body><body package="GlorpMigration" selector="databaseTable">databaseTable	^databaseTable</body><body package="GlorpMigration" selector="databaseTable:">databaseTable: anObject	databaseTable := anObject</body><body package="GlorpMigration" selector="databaseTables">databaseTables	^ Array with: self databaseTable</body><body package="GlorpMigration" selector="destination">destination	^destination</body><body package="GlorpMigration" selector="destination:">destination: aSchema	destination := aSchema</body><body package="GlorpMigration" selector="source">source	^source</body><body package="GlorpMigration" selector="source:">source: aSchema	source := aSchema</body><body package="GlorpMigration" selector="tableName">tableName	^ self databaseTable name</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>testing</category><body package="GlorpMigration" selector="hasAddForeignKeyConstraintFor:">hasAddForeignKeyConstraintFor: aForeignKeyConstraint	^false</body><body package="GlorpMigration" selector="hasDropForeignKeyConstraintFor:">hasDropForeignKeyConstraintFor: aForeignKeyConstraint	^false</body><body package="GlorpMigration" selector="hasDropPrimaryKeyConstraintForFor:">hasDropPrimaryKeyConstraintForFor: aDatabaseTable	^false</body><body package="GlorpMigration" selector="isAlterField">isAlterField	^false</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>printing</category><body package="GlorpMigration" selector="printOn:">printOn: aStream	self writeFor: 'aMigrationChangeSet' on: aStream</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession"The method applies the database changes to a database  "	^ self subclassResponsibility</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream"The method writes the migration script "	^self subclassResponsibility</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>initialize-release</category><body package="GlorpMigration" selector="initialize">initialize</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>sorting</category><body package="GlorpMigration" selector="weigh">weigh	^100</body></methods><methods><class-id>Glorp.Migration.MigrationOperation class</class-id> <category>instance creation</category><body package="GlorpMigration" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.AddField</class-id> <category>accessing</category><body package="GlorpMigration" selector="bePrimaryKey">bePrimaryKey		databaseField ifNotNil: [databaseField bePrimaryKey]</body><body package="GlorpMigration" selector="databaseField">databaseField	^databaseField</body><body package="GlorpMigration" selector="databaseField:">databaseField: anObject	databaseField := anObject</body><body package="GlorpMigration" selector="fieldName">fieldName	^ self databaseField name</body><body package="GlorpMigration" selector="fieldType">fieldType	^fieldType</body><body package="GlorpMigration" selector="fieldType:">fieldType: anObject	fieldType := anObject</body></methods><methods><class-id>Glorp.Migration.AddField</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor 		addFields: (Array with: self databaseField)  		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream tab.	databaseField isPrimaryKey ifTrue: [ aStream nextPut: $(].	aStream		nextPutAll: argumentName;		space;		nextPutAll: 'addFieldNamed: ';		nextPutAll: self fieldName printString;		space;		nextPutAll: 'toTableNamed: ';		nextPutAll: self databaseField table name printString.	databaseField isPrimaryKey ifTrue: [ aStream nextPutAll: ') bePrimaryKey'].	aStream 		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.AddField</class-id> <category>sorting</category><body package="GlorpMigration" selector="weigh">weigh	^5</body></methods><methods><class-id>Glorp.Migration.ScriptError class</class-id> <category>testing</category><body package="GlorpMigration" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>accessing</category><body package="GlorpMigration" selector="constraint">constraint	^constraint</body><body package="GlorpMigration" selector="constraint:">constraint: aForeignKeyConstraint	constraint  := aForeignKeyConstraint</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor 		dropConstraint:  constraint  		ifError: [ :ex | ex "do nothing if no constraint exists" ].</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'dropForeignKeyFromTable: ';		nextPutAll: constraint  sourceFields first table name asUppercase printString;		space.		constraint  sourceFields size = 1		ifTrue: [aStream					nextPutAll: 'forField: ';					nextPutAll: constraint  sourceFields first name asUppercase printString]		ifFalse: [aStream nextPutAll: 'forAllFields: #( '.				constraint  sourceFields do: [ :f | aStream nextPutAll:  f name asUppercase printString, ' ' ].				aStream nextPutAll: ' )' ].	aStream		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>testing</category><body package="GlorpMigration" selector="hasDropForeignKeyConstraintFor:">hasDropForeignKeyConstraintFor: aForeignKeyConstraint	^constraint  isSimilarForeignKeyConstraint:  aForeignKeyConstraint</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration" selector="weigh">weigh	^10</body></methods><methods><class-id>Glorp.Migration.TableCopyForMigration</class-id> <category>accessing</category><body package="GlorpMigration" selector="migrationCopy">migrationCopy	^ self</body><body package="GlorpMigration" selector="postMigrationCopy">postMigrationCopy	"	Ensure that any collections that we might be operating upon during migration are copied	in order to protect the original database definition.	"	fields := fields copy.	foreignKeyConstraints := foreignKeyConstraints copy.	indexes := indexes copy.	lockKeyFields := lockKeyFields copy.	primaryKeyFields := primaryKeyFields copy</body></methods><methods><class-id>Glorp.Migration.CopyTableData</class-id> <category>accessing</category><body package="GlorpMigration" selector="destinationTable">destinationTable	^destinationTable</body><body package="GlorpMigration" selector="destinationTable:">destinationTable: anObject	destinationTable := anObject</body></methods><methods><class-id>Glorp.Migration.CopyTableData</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession		aGlorpSession accessor		copyDataFromTable: self databaseTable		toTable: self destinationTable		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'copyDataFromTableNamed: ';		nextPutAll: self tableName printString;		space;		nextPutAll: 'toTableNamed: ';		nextPutAll: self destinationTable name printString;		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>accessing</category><body package="GlorpMigration" selector="destination">destination	^destination</body><body package="GlorpMigration" selector="destination:">destination: anObject	destination := anObject</body><body package="GlorpMigration" selector="source">source	^source</body><body package="GlorpMigration" selector="source:">source: anObject	source := anObject</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>testing</category><body package="GlorpMigration" selector="isCalculated">isCalculated	^ false</body><body package="GlorpMigration" selector="isScripted">isScripted	^ false</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>initialize-release</category><body package="GlorpMigration" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>calculate changes</category><body package="GlorpMigration" selector="calculateChangeSetOperations:">calculateChangeSetOperations: aMigrationSet	self calculateChangesFor: aMigrationSet.	^aMigrationSet operations</body><body package="GlorpMigration" selector="calculateChangesFor:">calculateChangesFor: aMigrationSet	^self subclassResponsibility</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation class</class-id> <category>instance creation</category><body package="GlorpMigration" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>accessing</category><body package="GlorpMigration" selector="selector">selector		^selector</body><body package="GlorpMigration" selector="selector:">selector: anObject		selector := anObject</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>printing</category><body package="GlorpMigration" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: source name;		nextPut: $-;		nextPutAll: selector;		nextPut: $-;		nextPutAll: destination name;		nextPut: $).</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>testing</category><body package="GlorpMigration" selector="isScripted">isScripted	^ true</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>calculate changes</category><body package="GlorpMigration" selector="calculateChangesFor:">calculateChangesFor: aMigrationSet		aMigrationSet calculateChangesFor: aMigrationSet source usingScript: self selector</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations class</class-id> <category>instance creation</category><body package="GlorpMigration" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.RenameTable</class-id> <category>accessing</category><body package="GlorpMigration" selector="newTableName">newTableName	^newTableName</body><body package="GlorpMigration" selector="newTableName:">newTableName: anObject	newTableName := anObject</body></methods><methods><class-id>Glorp.Migration.RenameTable</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor		renameTable:  self databaseTable		to: self newTableName		inPlatform: self databasePlatform		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'renameTableNamed: ';		nextPutAll: self tableName printString;		space;		nextPutAll: 'to: ';		nextPutAll: self newTableName printString;		nextPutAll: '.';		cr</body></methods><methods><class-id>Glorp.Migration.CalculatingChangeSetError</class-id> <category>accessing</category><body package="GlorpMigration" selector="destination">destination	^destination</body><body package="GlorpMigration" selector="destination:">destination: anObject	destination := anObject</body><body package="GlorpMigration" selector="source">source	^source</body><body package="GlorpMigration" selector="source:">source: anObject	source := anObject</body></methods><methods><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id> <category>accessing</category><body package="GlorpMigration" selector="constraint">constraint	^constraint</body><body package="GlorpMigration" selector="constraint:">constraint: anObject	constraint := anObject</body></methods><methods><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor 		addConstraint: self  constraint  		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space.	self constraint primaryKeyFields size = 1		ifTrue: [aStream 					nextPutAll: 'setAsPrimaryKeyFieldNamed:  ', self constraint primaryKeyFields first name printString]		ifFalse: [aStream nextPutAll: 'setAsPrimaryKeyFieldsNamed:  #( '.				self constraint primaryKeyFields 					do: [ :each | aStream nextPutAll: each name printString] 					separatedBy: [aStream space].				aStream nextPut: $) ].	aStream			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self constraint  table name asUppercase printString;			space;			nextPut: $.;			cr</body></methods><methods><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration" selector="weigh">weigh	^20</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations</class-id> <category>testing</category><body package="GlorpMigration" selector="isCalculated">isCalculated	^ true</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations</class-id> <category>printing</category><body package="GlorpMigration" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: source name;		nextPutAll: '--';		nextPutAll: destination name;		nextPut: $).</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations</class-id> <category>calculate changes</category><body package="GlorpMigration" selector="calculateChangesFor:">calculateChangesFor: aMigrationSet	^aMigrationSet calculateOperations</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations class</class-id> <category>instance creation</category><body package="GlorpMigration" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.DropField</class-id> <category>accessing</category><body package="GlorpMigration" selector="databaseField">databaseField	^databaseField</body><body package="GlorpMigration" selector="databaseField:">databaseField: anObject	databaseField := anObject</body></methods><methods><class-id>Glorp.Migration.DropField</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor 		dropFields: (Array with: self databaseField) 		ifError: [ :ex | ex "do nothing if the field doesn't exist" ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'dropFieldNamed: ';		nextPutAll: self databaseField name printString;		space;		nextPutAll: 'fromTableNamed: ';		nextPutAll: self databaseField table name printString;		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.RenameField</class-id> <category>accessing</category><body package="GlorpMigration" selector="databaseField">databaseField		^databaseField</body><body package="GlorpMigration" selector="databaseField:">databaseField: aDatabaseField		databaseField := aDatabaseField</body><body package="GlorpMigration" selector="newFieldName">newFieldName	^newFieldName</body><body package="GlorpMigration" selector="newFieldName:">newFieldName: aString	newFieldName := aString</body></methods><methods><class-id>Glorp.Migration.RenameField</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor		renameField: self databaseField		to: self newFieldName		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'renameFieldNamed: ';		nextPutAll: self databaseField name printString;		space;		nextPutAll: 'inTableNamed: ';		nextPutAll: self databaseField table name printString;		space;		nextPutAll: 'to: ';		nextPutAll: self newFieldName printString;		nextPutAll: '.';		cr</body></methods><methods><class-id>Glorp.Migration.DropTable</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	| system |	aGlorpSession accessor dropTable: self databaseTable  ifError: [ :ex | ex pass ].	system := aGlorpSession system.	system platform areSequencesExplicitlyCreated		ifTrue: [( system allSequencesFor: ( OrderedCollection with:  self databaseTable))					do: [:each | 						aGlorpSession accessor dropSequence: each ifAbsent: [:ex | ex "so we can insert a breakpoint" ]]].</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' dropTableNamed: ';		nextPutAll: self tableName printString;		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.CreateTable</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession createTables: (OrderedCollection with: self databaseTable )</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' createTableNamed: ';		nextPutAll: self tableName printString;		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.MigrationError</class-id> <category>accessing</category><body package="GlorpMigration" selector="messageText">messageText	| stream |	stream := WriteStream on: String new.	migrationOperation 		ifNotNil: [stream := WriteStream on: String new.				stream nextPutAll: 'Can not execute the script line: '; cr.				migrationOperation writeFor: 'migration' on: stream.				stream cr].	stream nextPutAll: (self class messageTextFrom: self).	^stream contents</body><body package="GlorpMigration" selector="migrationOperation">migrationOperation	^migrationOperation</body><body package="GlorpMigration" selector="migrationOperation:">migrationOperation: anObject	migrationOperation := anObject</body></methods><methods><class-id>Glorp.Migration.MigrationError</class-id> <category>printing</category><body package="GlorpMigration" selector="description">description	^self messageText</body></methods><methods><class-id>Glorp.Migration.MigrationError class</class-id> <category>accessing</category><body package="GlorpMigration" selector="messageTextFrom:">messageTextFrom: exception	| stream dbError exceptionParameter |		(exceptionParameter := exception parameter) ifNil: [^exception messageText].	stream := WriteStream on: String new.	dbError := (exceptionParameter isKindOf: Collection) 		ifTrue: [exceptionParameter  first] 		ifFalse: [(exceptionParameter isKindOf: Exception) ifTrue: [exceptionParameter] ifFalse: [^exception messageText] ].	((dbError isKindOf: SpError) and: [dbError parameter notEmpty]) ifTrue: [dbError := dbError parameter first ].	(dbError isKindOf: ExternalDatabaseError)		ifTrue: [stream nextPutAll: exceptionParameter class name asString.				stream cr; nextPutAll: dbError dbmsErrorString]		ifFalse: [ stream nextPutAll: dbError messageText].	^stream contents</body></methods><methods><class-id>Glorp.Migration.ScriptErrors</class-id> <category>accessing</category><body package="GlorpMigration" selector="messageText">messageText	| stream |	parameter ifNil: [^nil ].	messageText		ifNil: [stream := WriteStream on: String new.			stream nextPutAll: 'Errors in ', selector printString, ' script'; cr.			parameter do: [ :each | stream nextPutAll: each description ; cr.].			messageText := stream contents].	^messageText</body><body package="GlorpMigration" selector="selector">selector	^selector</body><body package="GlorpMigration" selector="selector:">selector: anObject	selector := anObject</body></methods><methods><class-id>Glorp.Migration.ScriptErrors</class-id> <category>printing</category><body package="GlorpMigration" selector="description">description	^self messageText</body></methods><methods><class-id>Glorp.Migration.ScriptErrors class</class-id> <category>instance creation</category><body package="GlorpMigration" selector="errors:from:">errors: aCollection from: aSymbol	^self new		parameter: aCollection;		selector: aSymbol;		yourself</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>accessing</category><body package="GlorpMigration" selector="currentDestination">currentDestination	^currentDestination</body><body package="GlorpMigration" selector="currentSource">currentSource	^currentSource</body><body package="GlorpMigration" selector="destination">destination	^destination</body><body package="GlorpMigration" selector="destination:">destination: anObject	destination := anObject</body><body package="GlorpMigration" selector="destinationTableNamed:">destinationTableNamed: tableName	" Answer a table cached in destinationTables dictionary.	If absent, get it from the destination.	Use a migration copy so I don't mess up the original."	| tables |	tables := destinationTables at: self currentDestination class name ifAbsentPut: [Dictionary new].	^[tables		at: tableName asUppercase		ifAbsentPut: [ 			(self currentDestination				tableNamed: tableName				ifNone: [^ScriptError raiseRequestErrorString: ( 'Destination schema: &lt;1s&gt; . The table: &lt;2s&gt;  does not exist' expandMacrosWith: self currentDestination class name with: tableName)] ) 			migrationCopy ]	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: ( 'Destination schema: &lt;1s&gt; error: &lt;2s&gt;' expandMacrosWith: self currentDestination class name with:  ex messageText) ]</body><body package="GlorpMigration" selector="fieldNamed:from:">fieldNamed: aString from: aTable	aTable ifNil: [^nil].	^aTable 		fieldNamed: aString  		ifAbsent: [ScriptError raiseRequestErrorString: ('The field named &lt;1s&gt; does not exist' expandMacrosWith: aString)]</body><body package="GlorpMigration" selector="operations">operations	^operations</body><body package="GlorpMigration" selector="operations:">operations: anObject	operations := anObject</body><body package="GlorpMigration" selector="source">source	^source</body><body package="GlorpMigration" selector="source:">source: anObject	source := anObject</body><body package="GlorpMigration" selector="sourceTableNamed:">sourceTableNamed: tableName	" Answer a table cached in sourceTables dictionary.	If absent, get it from the source.	Use a migration copy so I don't mess up the original."	| tables |	tables := sourceTables at: self currentSource class name ifAbsentPut: [Dictionary new].	^[ tables		at: tableName asUppercase		ifAbsentPut: [ 					(self currentSource tableNamed: tableName 						ifNone: [^ScriptError raiseRequestErrorString: ( 'Source schema: &lt;1s&gt; . The table: &lt;2s&gt;  does not exist' expandMacrosWith: self currentSource class name with: tableName)] ) 					migrationCopy ]	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: ( 'Source schema: &lt;1s&gt; error: &lt;2s&gt;' expandMacrosWith: self currentSource class name with:  ex messageText)]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>migrate</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	self		whileInSession: aGlorpSession		do:  [ self basicApplyInSession: aGlorpSession ]</body><body package="GlorpMigration" selector="applyInSourceSession">applyInSourceSession	self applyInSession: self source session</body><body package="GlorpMigration" selector="basicApplyInSession:">basicApplyInSession: aGlorpSession	self operations do: [ :each |		[ each applyInSession: aGlorpSession ]			on: Error			do: [ :ex | (MigrationError new							migrationOperation: each;							parameter: ex;							yourself) raise] ]</body><body package="GlorpMigration" selector="whileInSession:do:">whileInSession: aGlorpSession do: aBlock	| loggedIn |	(loggedIn := aGlorpSession isLoggedIn)		ifFalse: [ aGlorpSession login ].	^ aBlock ensure: [		loggedIn ifFalse: [ aGlorpSession logout ] ]</body><body package="GlorpMigration" selector="whileInSourceSessionDo:">whileInSourceSessionDo: aBlock	^ self		whileInSession: self source session		do: aBlock</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>calculate changes</category><body package="GlorpMigration" selector="addCompositeOperation:from:to:">addCompositeOperation: aCompositeMigrationOperation from: sourceDescriptorSystem to: destinationDescriptorSystem	| changeSubSet |	changeSubSet := self 				newChangeSetFrom: (self getSystemFrom: sourceDescriptorSystem or: aCompositeMigrationOperation source) 				to: (self getSystemFrom: destinationDescriptorSystem or: aCompositeMigrationOperation destination).	^ operations		addAll: (aCompositeMigrationOperation calculateChangeSetOperations: changeSubSet );		yourself</body><body package="GlorpMigration" selector="addOperation:">addOperation: aMigrationOperation	aMigrationOperation source: self currentSource.	aMigrationOperation destination: self currentDestination.	^ self operations add: aMigrationOperation</body><body package="GlorpMigration" selector="calculateChangesFor:usingScript:">calculateChangesFor: aDescriptorSystem usingScript: messageSelector 	| errors |	errors := OrderedCollection new.	[aDescriptorSystem		perform: messageSelector		with: self.	] on: Glorp.Migration.ScriptError do: [ :ex | errors add: ex. ex resume ].	errors notEmpty ifTrue: [^(Glorp.Migration.ScriptErrors errors: errors from: messageSelector) raiseSignal ].</body><body package="GlorpMigration" selector="calculateMigrationScript">calculateMigrationScript	| scripts chains |	scripts := source class migrationPathWithScriptsTo: destination class.	scripts size = 1 ifTrue: [ 	^scripts first calculateChangeSetOperations: self].	chains := self calculateScriptChainsFrom: scripts.	chains do: [ :eachChain |		| firstStep lastStep |		firstStep := eachChain first.		lastStep := eachChain last.		" Yes I know I could use ifTrue:ifFalse: here, but in case we ended up with more types of steps,		successive ifTrue: seems like a better idea. "		firstStep isCalculated ifTrue: [			" all steps in the chain are calculated. It's a transitive operation, so let's set the first step's destination			to be the same as last step destination, and disregard all intermediate steps."			firstStep destination: lastStep destination.			self				addCompositeOperation: firstStep				from: source				to: destination ].		firstStep isScripted ifTrue: [			" all steps in the chain are scripted. Each of the scripts has its own set of operations that have to be			collected in the final change set (my operations). Iterate over the chain's steps. "			eachChain do: [ :eachStep |				self					addCompositeOperation: eachStep					from: source					to: destination] ] ]</body><body package="GlorpMigration" selector="calculateOperations">calculateOperations	^self		calculateOperationsFrom: self source		to: self destination</body><body package="GlorpMigration" selector="calculateOperationsFrom:to:">calculateOperationsFrom: aSource to: aDestination	| fromTables toTables toDelete toAdd toModify |	fromTables := aSource allTables copy.	toTables := aDestination allTables copy.	toDelete := fromTables reject: [:each | 	toTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toAdd := toTables reject: [:each | 	fromTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toModify := fromTables reject: [:each | (toDelete includes: each) or: [toAdd includes: each]].	self createTables: toAdd.	self dropTables: toDelete.	toModify do: [:each |			| newVersion |			newVersion := aDestination tableNamed: each sqlString.			self calculateUpdateTableFrom: each to: newVersion].	operations := operations asSortedCollection: [:a :b | a weigh &lt;= b weigh].</body><body package="GlorpMigration" selector="calculatePrimaryKeyOperationFrom:to:forceRecreation:">calculatePrimaryKeyOperationFrom: oldPrimaryConstraint to: newPrimaryConstraint forceRecreation: aBoolean		(oldPrimaryConstraint isNil and: [newPrimaryConstraint isNil]) 	ifTrue: [^nil].	(oldPrimaryConstraint notNil and: [newPrimaryConstraint isNil])		ifTrue: 	[^self dropPrimaryKeyFromTableNamed: oldPrimaryConstraint table name].	(oldPrimaryConstraint isNil and: [newPrimaryConstraint notNil])		ifTrue: [^self addPrimaryKeyConstraint: newPrimaryConstraint].	aBoolean | (oldPrimaryConstraint isTheSameAs: newPrimaryConstraint) not		ifTrue: [(self findAllForeignKeyConstraintsTo: oldPrimaryConstraint table in: source) do: [:each | self dropForeignKeyConstraint: each.].			self dropPrimaryKeyFromTableNamed: newPrimaryConstraint table name.			self addPrimaryKeyConstraint: newPrimaryConstraint.			(self findAllForeignKeyConstraintsTo: newPrimaryConstraint table in: destination)				do: [ :constraint |					self addForeignKeyConstraint: ((self 						newForeignKeyConstraintFor: constraint sourceFields						from: newPrimaryConstraint fields 						suffixExpression: constraint suffixExpression) 						name: constraint name; 						yourself).]]</body><body package="GlorpMigration" selector="calculateScriptChainsFrom:">calculateScriptChainsFrom: migrationPathWithScripts	^ migrationPathWithScripts piecesCutWhere: [ :eachMigrationStep :next | eachMigrationStep class ~= next class ]</body><body package="GlorpMigration" selector="calculateUpdateFieldFrom:to:">calculateUpdateFieldFrom: sourceField to: destField	| changes |	changes := AlterField new databaseField: destField; yourself.	changes validateModificationsFrom: sourceField sourceField: destField.	changes isModified ifTrue: [self addOperation: changes].	^changes isModified</body><body package="GlorpMigration" selector="calculateUpdateTableFrom:to:">calculateUpdateTableFrom: aTable to: newTable	"Calculate the migration change set between aTable and newTable"	| newFields deletedFields modifiedFields newConstraints deletedConstraints primaryKeyNeedsRecreating |	newConstraints := newTable foreignKeyConstraints reject: [:each | aTable hasForeignKeyConstraintTheSameAs: each].	deletedConstraints := aTable foreignKeyConstraints reject: [:each | newTable hasForeignKeyConstraintTheSameAs: each].	newFields := newTable fields reject: [:each | aTable hasFieldNamed: each name].	deletedFields := aTable fields reject: [:each | newTable hasFieldNamed: each name].	"Possibly modified fields"	modifiedFields := newTable fields reject: [:each | newFields includes: each].	"Really modified fields "	modifiedFields := modifiedFields select: [:each | self calculateUpdateFieldFrom: (aTable fieldNamed: each name) to: each.].	primaryKeyNeedsRecreating := newFields anySatisfy: [:each | newTable primaryKeyFields includes: each].	primaryKeyNeedsRecreating := primaryKeyNeedsRecreating | (deletedFields anySatisfy: [:each | aTable primaryKeyFields includes: each]).	self 		calculatePrimaryKeyOperationFrom: aTable primaryKeyConstraints  		to: newTable primaryKeyConstraints 		forceRecreation: primaryKeyNeedsRecreating.		self dropForeignKeyConstraints: deletedConstraints.	self dropFields: deletedFields.	self addFields: newFields.	self addForeignKeyConstraints:  newConstraints.</body><body package="GlorpMigration" selector="findAllForeignKeyConstraintsTo:in:">findAllForeignKeyConstraintsTo: aTable in: aSchema	| foreignFields |	foreignFields := OrderedCollection new.	aSchema allTables do: [:table |		table foreignKeyConstraints do: [:constraint | 	(constraint refersToTable: aTable) ifTrue: [foreignFields add: constraint]]].	^foreignFields</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>printing</category><body package="GlorpMigration" selector="asMigrationScriptOn:">asMigrationScriptOn: variableName	| stream |	stream := WriteStream on: String new.	self writeScriptOn: stream withArgument: variableName.	^stream contents</body><body package="GlorpMigration" selector="generateDefaultMigrationScriptSource:">generateDefaultMigrationScriptSource: methodSelector	| argumentName stream |	stream := WriteStream on: String new.	argumentName := 'aMigrationChangeSet'.	self		writeMethodHeaderFor: methodSelector withArgument: argumentName on: stream;		writePragmaOn: stream;		writeScriptOn: stream withArgument: argumentName.	^stream contents</body><body package="GlorpMigration" selector="printOn:">printOn: aStream		aStream nextPutAll: 'Migration set from:'.		source ifNotNil: [ aStream nextPutAll: source class name].	aStream nextPutAll: ' to:'.		destination ifNotNil: [aStream nextPutAll: destination class name].	operations ifNotNil: [aStream cr.						operations do: [ :op | op printOn: aStream]]</body><body package="GlorpMigration" selector="writeMethodHeaderFor:withArgument:on:">writeMethodHeaderFor: methodSelector withArgument: argumentName on: aStream	aStream		nextPutAll: methodSelector;		space;		nextPutAll: argumentName;		cr</body><body package="GlorpMigration" selector="writePragmaOn:">writePragmaOn: aStream	aStream		tab;		nextPutAll: '&lt;', self source class migrationPragmaSelector, ' ', self destination class name printString, '&gt;' ;		cr</body><body package="GlorpMigration" selector="writeScriptOn:withArgument:">writeScriptOn: aStream withArgument: argumentName	| sourceClass destinationClass |	destinationClass := destination class.	sourceClass := source class.	operations do: [ :eachOperation | 		(eachOperation source class ~= sourceClass			or: [eachOperation destination class ~= destinationClass])			ifTrue: [aStream 					crtab; 					nextPutAll: argumentName, ' operationsFrom: ', eachOperation source class  fullName printString; 					nextPutAll: ' to: ', eachOperation destination class  fullName printString, '.'; 					cr.				sourceClass := eachOperation source class.				destinationClass := eachOperation destination class ].		eachOperation writeFor: argumentName on: aStream ]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>initialize-release</category><body package="GlorpMigration" selector="from:to:">from: sourceSystemDescriptor to: destinationSystemDescriptor	source := sourceSystemDescriptor.	destination := destinationSystemDescriptor.	currentDestination := destinationSystemDescriptor.	currentSource := sourceSystemDescriptor</body><body package="GlorpMigration" selector="initialize">initialize	operations := OrderedCollection new.	sourceTables := Dictionary new.	destinationTables := Dictionary new.</body><body package="GlorpMigration" selector="newChangeSetFrom:to:">newChangeSetFrom: aSource to: aDestination	^ self species new		from: aSource to: aDestination;		yourself.</body><body package="GlorpMigration" selector="operationsFrom:to:">operationsFrom: sourceSchemaString to: destinationSchemaString		(currentSource class fullName = sourceSchemaString		and: [currentDestination class fullName = destinationSchemaString]) ifTrue: [^nil ].	currentDestination := destinationSchemaString asSymbol asQualifiedReference valueOrDo: [^self error: ( 'There is no qualified reference for:  &lt;1s&gt;' expandMacrosWith: destinationSchemaString)].	currentDestination := currentDestination forPlatform: destination platform.	destination session system: currentDestination.	currentSource := sourceSchemaString asSymbol asQualifiedReference valueOrDo: [^self error: ( 'There is no qualified reference for:  &lt;1s&gt;' expandMacrosWith: sourceSchemaString)].	currentSource := currentSource forPlatform: source platform.	source session system: currentSource.</body><body package="GlorpMigration" selector="resetOperations">resetOperations	operations := OrderedCollection new</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - alter field</category><body package="GlorpMigration" selector="changeTypeForFieldNamed:inTableNamed:to:">changeTypeForFieldNamed: fieldName inTableNamed: sourceTableName to: aBlockOrGlorpDatabaseType"Changes the database field type. aBlockOrGlorpDatabaseType parameter can be  GlorpDatabaseType or Block. The block should return an object of GlorpDatabaseType"	^[ self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setTypeTo:		value: (aBlockOrGlorpDatabaseType isGlorpType 					ifTrue: [aBlockOrGlorpDatabaseType] 					ifFalse: [aBlockOrGlorpDatabaseType value: source platform])	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #changeTypeForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration" selector="dropDefaultValueForFieldNamed:inTableNamed:">dropDefaultValueForFieldNamed: fieldName inTableNamed: sourceTableName "Drops the  database field default value in the table"	^ [self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #dropDefaultValue		value: nil		] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #dropDefaultValueForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration" selector="setDefaultValueForFieldNamed:inTableNamed:to:">setDefaultValueForFieldNamed: fieldName inTableNamed: sourceTableName to: anObject"Sets the  database field default value in the table"	^ [self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setDefaultValueTo:		value: anObject		] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #setDefaultValueForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration" selector="setNotNullableForFieldNamed:inTableNamed:">setNotNullableForFieldNamed: fieldName inTableNamed: sourceTableName "Sets NOT NULL for the database field  in the table"	^[ self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setNotNullable		value: nil	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #setNotNullableForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration" selector="setNullableForFieldNamed:inTableNamed:">setNullableForFieldNamed: fieldName inTableNamed: sourceTableName "Sets NULL for the database field  in the table"	^[ self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setNullable		value: nil	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #setNullableForFieldNamed:inTableNamed:to: ', ex messageText].</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - add/drop field</category><body package="GlorpMigration" selector="addField:">addField: aDatabaseField"Adds a database field to a table. The parameter has to be Glorp.DatabaseField "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #addField: parameter' ].	^self addOperation: (AddField new							databaseField: aDatabaseField;							yourself)</body><body package="GlorpMigration" selector="addFieldNamed:toTable:">addFieldNamed: fieldName toTable: aDatabaseTable"Adds a database field with the specified name to a table. The first parameter is a string, the second one is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #addFieldNamed:toTable: second parameter'].	^ self addField: (self fieldNamed: fieldName from: aDatabaseTable)</body><body package="GlorpMigration" selector="addFieldNamed:toTableNamed:">addFieldNamed: fieldName toTableNamed: tableName"Adds a database field to a table. Both parameters are strings "	^ self addFieldNamed: fieldName toTable:  (self destinationTableNamed: tableName)</body><body package="GlorpMigration" selector="addFields:">addFields: aCollection"Adds a database fields to a table. The parameter has to be a collection of  Glorp.DatabaseField "	aCollection do: [ :eachField | self addField: eachField ]</body><body package="GlorpMigration" selector="createFieldNamed:type:inTableNamed:">createFieldNamed: fieldName type: aBlockOrGlorpDatabaseType inTableNamed: tableName "Creates a new database field in a table."	^self 		createFieldNamed: fieldName 		type: aBlockOrGlorpDatabaseType		inTableNamed: tableName		with: nil</body><body package="GlorpMigration" selector="createFieldNamed:type:inTableNamed:with:">createFieldNamed: fieldName type: aBlockOrGlorpDatabaseType inTableNamed: tableName with: aBlock"Creates a new database field in a table. The type parameter has to be GlorpDatabaseType object or a Block. The block should return an object of GlorpDatabaseType . The database field will be passed to aBlock to allow changing the field attributes"	| newField |	[newField :=  (self destinationTableNamed: tableName)					createFieldNamed: fieldName					type:  (aBlockOrGlorpDatabaseType isGlorpType 							ifTrue: [aBlockOrGlorpDatabaseType] 							ifFalse: [aBlockOrGlorpDatabaseType value: source platform]).	aBlock ifNotNil: [ :theBlock | 	theBlock cull: newField ].		] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	^ self addField: newField</body><body package="GlorpMigration" selector="dropField:">dropField: aDatabaseField"Drops a database field to a table. The parameter has to be Glorp.DatabaseField "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #dropField: parameter'].	^ self addOperation: (DropField new							databaseField: aDatabaseField;							yourself)</body><body package="GlorpMigration" selector="dropFieldNamed:fromTable:">dropFieldNamed: fieldName fromTable: aDatabaseTable"Drops a database field from a table. The first parameter is a string, the second one is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #dropFieldNamed:fromTable: second parameter'].	^self dropField: (self fieldNamed: fieldName from: aDatabaseTable)</body><body package="GlorpMigration" selector="dropFieldNamed:fromTableNamed:">dropFieldNamed: fieldName fromTableNamed: sourceTableName"Drops a database field from a table. Both parameters are strings "	^ self		dropFieldNamed: fieldName		fromTable: (self sourceTableNamed: sourceTableName)</body><body package="GlorpMigration" selector="dropFields:">dropFields: aCollection"Drops a database fields from a table. The parameter has to be a collection of  Glorp.DatabaseField "	aCollection do: [ :eachField | self dropField: eachField ]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - add/drop foreign key</category><body package="GlorpMigration" selector="addForeignKeyConstraint:">addForeignKeyConstraint: aForeignKeyConstraint"Adds a database foreign key constraints to a table. The parameter has to be Glorp.ForeignKeyConstraint "	(aForeignKeyConstraint isKindOf: ForeignKeyConstraint) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.ForeignKeyConstraint object in #addForeignKeyConstraint: parameter' ].	(self operations detect:[ :op | op hasAddForeignKeyConstraintFor: aForeignKeyConstraint ] ifNone: [nil]) notNil ifTrue: [^nil].	^ self addOperation: (CreateForeignKeyConstraint new							constraint: aForeignKeyConstraint;							yourself)</body><body package="GlorpMigration" selector="addForeignKeyConstraints:">addForeignKeyConstraints: collForeignKeyConstraints"Adds database foreign key constraints to a table. The parameter is a collection of Glorp.ForeignKeyConstraint"	collForeignKeyConstraints do: [ :each | self addForeignKeyConstraint:  each ]</body><body package="GlorpMigration" selector="addForeignKeyFromTable:fromAllFields:toTable:toAllFields:suffixExpression:">addForeignKeyFromTable: sourceTable fromAllFields: collSourceFieldNames toTable: targetTable toAllFields: collTargetFieldNames suffixExpression: expString"Adds a database foreign key constraints from sourceTable fields to targetTable fields. All parameters are strings"	| constraint table sourceFields dtable targetFields |	(table := self sourceTableNamed: sourceTable) ifNil: [^nil].	sourceFields := OrderedCollection new.	collSourceFieldNames do: [ :fname | sourceFields add: ((self fieldNamed: fname from: table) ifNil: [^nil] )].	(dtable := self destinationTableNamed: targetTable) ifNil: [^nil].	targetFields := OrderedCollection new.	collTargetFieldNames do: [	:fname | targetFields add: ((self fieldNamed: fname from: dtable)  ifNil: [^nil])].	[constraint := table 					addForeignKeyFromAll: sourceFields 					toAll: targetFields					suffixExpression: expString.	] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	^self addForeignKeyConstraint: constraint</body><body package="GlorpMigration" selector="addForeignKeyFromTable:fromField:toTable:toField:">addForeignKeyFromTable: sourceTableName fromField: sourceFieldName toTable: targetTableName toField: targetFieldName"Adds a database foreign key constraints from sourceTable fields to targetTable fields. All parameters are strings"	^self 		addForeignKeyFromTable: sourceTableName 		fromField: sourceFieldName 		toTable: targetTableName 		toField: targetFieldName 		suffixExpression: nil</body><body package="GlorpMigration" selector="addForeignKeyFromTable:fromField:toTable:toField:suffixExpression:">addForeignKeyFromTable: sourceTableName fromField: sourceFieldName toTable: targetTableName toField: targetFieldName suffixExpression: expString		^self		addForeignKeyFromTable: sourceTableName		fromFields: (OrderedCollection with: sourceFieldName)		toTable: targetTableName		toFields: (OrderedCollection with: targetFieldName)		suffixExpression: expString</body><body package="GlorpMigration" selector="addForeignKeyFromTable:fromFields:toTable:toFields:">addForeignKeyFromTable: sourceTable fromFields: collSourceFieldNames toTable: targetTable toFields: collTargetFieldNames		^self addForeignKeyFromTable: sourceTable fromFields: collSourceFieldNames		toTable: targetTable toFields: collTargetFieldNames suffixExpression: nil</body><body package="GlorpMigration" selector="addForeignKeyFromTable:fromFields:toTable:toFields:suffixExpression:">addForeignKeyFromTable: aTable fromFields: sourceFieldNames toTable: refTable toFields: targetFieldNames suffixExpression: expString"Adds a database foreign key constraints from sourceTable fields to targetTable fields. All parameters are strings"	| constraint table sourceFields dtable targetFields newFK |	(table := self destinationTableNamed: aTable) ifNil: [^nil].	sourceFields := OrderedCollection new.	sourceFieldNames do: [ :fname | sourceFields add: ((self fieldNamed: fname from: table) ifNil: [^nil] )].	(dtable := self destinationTableNamed: refTable) ifNil: [^nil].	targetFields := OrderedCollection new.	targetFieldNames do: [	:fname | targetFields add: ((self fieldNamed: fname from: dtable)  ifNil: [^nil])].	(sourceFields size ~=  targetFields size) 		ifTrue: [^ScriptError raiseRequestErrorString: ( 'Can not create ForeignKeyConstraint for: &lt;1s&gt; from: &lt;2s&gt;. Number ofreferencing columns must match referenced columns' expandMacrosWith: sourceFieldNames printString with: targetFieldNames printString)  ].	newFK := self newForeignKeyConstraintFor: sourceFields from: targetFields suffixExpression: expString.	[constraint := table foreignKeyConstraints 		detect: [ :each |  each isSimilarForeignKeyConstraint: newFK ] 		ifNone: [table 					addForeignKeyFromAll: sourceFields 					toAll: targetFields					suffixExpression: expString]	] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	^self addForeignKeyConstraint: constraint</body><body package="GlorpMigration" selector="dropForeignKeyConstraint:">dropForeignKeyConstraint: aForeignKeyConstraint"Drops a database foreign key constraints from a table. The parameter has to be Glorp.ForeignKeyConstraint "	(aForeignKeyConstraint isKindOf: ForeignKeyConstraint) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.ForeignKeyConstraint object in #dropForeignKeyConstraint: parameter' ].		(self operations detect:[ :op | op hasDropForeignKeyConstraintFor: aForeignKeyConstraint ] ifNone: [nil]) notNil ifTrue: [^nil].		^ self addOperation: (DropForeignKeyConstraint new							constraint: aForeignKeyConstraint;							yourself)</body><body package="GlorpMigration" selector="dropForeignKeyConstraints:">dropForeignKeyConstraints: collForeignKeyConstraints"Drops database foreign key constraints from a table. The parameter has to be a collection of Glorp.ForeignKeyConstraint "	 collForeignKeyConstraints do: [ :each | self dropForeignKeyConstraint: each ]</body><body package="GlorpMigration" selector="dropForeignKeyFromTable:forAllFields:">dropForeignKeyFromTable: sourceTableName forAllFields: collFieldNames"Drops a database foreign key constraints from a table for the fields. #sourceTableName parameter is a string. #collFieldNames is collection of strings"	| constraints table |	(table := self sourceTableNamed: sourceTableName) ifNil: [^nil].	constraints := OrderedCollection new.	[collFieldNames 		do: [ :sf | (table foreignKeyConstraintsForField: (self fieldNamed: sf from: table)) 					ifNotNil: [ :coll | constraints addAll: coll ]].	] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	self dropForeignKeyConstraints: constraints</body><body package="GlorpMigration" selector="dropForeignKeyFromTable:forField:">dropForeignKeyFromTable: sourceTableName forField: sourceFieldName"Drops a database foreign key constraints from a table for the field. Both parameters are strings"	self dropForeignKeyFromTable: sourceTableName forAllFields: (OrderedCollection with: sourceFieldName)</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - create/drop table</category><body package="GlorpMigration" selector="createTable:">createTable: aDatabaseTable"Creates the database table. The parameter is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #createTable: parameter' ].		^self addOperation:		(CreateTable new			databaseTable: aDatabaseTable migrationCopy;				yourself)</body><body package="GlorpMigration" selector="createTableNamed:">createTableNamed: destinationTableName"Creates the database table. The parameter is a string "	^self createTable: (self destinationTableNamed: destinationTableName)</body><body package="GlorpMigration" selector="createTables:">createTables: aCollection"Creates database tables. The parameter is collection of Glorp.DatabaseTable "		aCollection do: [ :each | self createTable: each ]</body><body package="GlorpMigration" selector="createTablesNamed:">createTablesNamed: aCollection"Creates database tables. The parameter is a collection of strings "	aCollection do: [ :eachName | self createTableNamed: eachName ]</body><body package="GlorpMigration" selector="dropTable:">dropTable: aDatabaseTable"Drops the database table. The parameter is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #dropTable: parameter' ].			^self addOperation: (DropTable new		databaseTable: aDatabaseTable migrationCopy;		yourself)</body><body package="GlorpMigration" selector="dropTableNamed:">dropTableNamed: tableName"Drops the database table. The parameter is a string "	^ self dropTable: (self sourceTableNamed: tableName)</body><body package="GlorpMigration" selector="dropTables:">dropTables: aCollection"Drops database tables. The parameter is collection of Glorp.DatabaseTable "		aCollection do: [ :each | self dropTable: each ]</body><body package="GlorpMigration" selector="dropTablesNamed:">dropTablesNamed: aCollection"Drops database tables. The parameter is collection of strings "		aCollection do: [ :each | self dropTableNamed: each ]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - copy/add data</category><body package="GlorpMigration" selector="copyDataFromField:toField:">copyDataFromField: fromDatabaseField toField: toDatabaseField "Copies database field data to another field. The parameters are Glorp.DatabaseField "	(fromDatabaseField isNil or: [toDatabaseField isNil]) ifTrue: [^nil].	((fromDatabaseField isKindOf: DatabaseField) 		and: [toDatabaseField isKindOf: DatabaseField])		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #copyDataFromField:toField: parameters' ].	^ self addOperation: (CopyFieldData new		fromField: fromDatabaseField;		toField: toDatabaseField;		yourself)</body><body package="GlorpMigration" selector="copyDataFromFieldNamed:toFieldNamed:inTableNamed:">copyDataFromFieldNamed: fromFieldName toFieldNamed: toFieldName inTableNamed: tableName"Copies database field data to another field. The parameters are strings"	 self		copyDataFromField: (self fieldNamed: fromFieldName from: (self sourceTableNamed: tableName))		toField:  (self fieldNamed: toFieldName from: (self destinationTableNamed: tableName))</body><body package="GlorpMigration" selector="copyDataFromTable:toTable:">copyDataFromTable: fromDatabaseTable toTable: toDatabaseTable"Copies database table data to another table. The parameters are Glorp.DatabaseTable "	(fromDatabaseTable isNil or: [ toDatabaseTable isNil]) ifTrue: [^nil].	((fromDatabaseTable isKindOf: DatabaseTable) 		and: [toDatabaseTable isKindOf: DatabaseTable])		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #copyDataFromTable:toTable: parameters' ].	^ self addOperation: (CopyTableData new		databaseTable: fromDatabaseTable;		destinationTable: toDatabaseTable;		yourself)</body><body package="GlorpMigration" selector="copyDataFromTableNamed:toTableNamed:">copyDataFromTableNamed: fromTableName toTableNamed: toTableName"Copies database table data to another table. The parameters are strings "	^ self		copyDataFromTable: (self sourceTableNamed: fromTableName)		toTable: (self destinationTableNamed: toTableName)</body><body package="GlorpMigration" selector="populateField:with:">populateField: aDatabaseField with: aValue"Populates database field with data. The first parameter is Glorp.DatabaseField. aValue has to match the database field type "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in populateField:with: parameters' ].	^ self addOperation: (PopulateField new		databaseField: aDatabaseField;		fieldValue: aValue;		yourself)</body><body package="GlorpMigration" selector="populateFieldNamed:inTableNamed:with:">populateFieldNamed: fieldName inTableNamed: tableName with: aValue"Populates database field with data. The first two parameters are strings. aValue has to match the database field type "	^ self		populateField: (self fieldNamed: fieldName from: (self destinationTableNamed: tableName))		with: aValue</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - add/drop primary key</category><body package="GlorpMigration" selector="addPrimaryKeyConstraint:">addPrimaryKeyConstraint: aPrimaryKeyConstraint"Adds a database primary key constraints to a table. The parameter has to be Glorp.PrimaryKeyConstraint "	(aPrimaryKeyConstraint isKindOf: PrimaryKeyConstraint) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.PrimaryKeyConstraint object in #addPrimaryKeyConstraint: parameter' ].	^self addOperation:(CreatePrimaryKeyConstraint new							constraint: aPrimaryKeyConstraint;							yourself )</body><body package="GlorpMigration" selector="dropPrimaryKeyFromTableNamed:">dropPrimaryKeyFromTableNamed: sourceTableName"Drops database primary key constraints from a table. The parameter is string"	|  table |	(table := self sourceTableNamed: sourceTableName) ifNil: [^nil].	table hasPrimaryKeyConstraints ifFalse: [^ScriptError raiseRequestErrorString: ('Drop Primary keys error: There is no primary keys in the table &lt;1s&gt;' expandMacrosWith: sourceTableName )].	self addOperation:(DropPrimaryKeyConstraint new						databaseTable: table;						yourself)</body><body package="GlorpMigration" selector="setAsPrimaryKeyFieldNamed:inTableNamed:">setAsPrimaryKeyFieldNamed: sourceFieldName inTableNamed: sourceTableName"Adds the field to a primary key constraints in the table. Both parameters are strings"	self setAsPrimaryKeyFieldsNamed: (OrderedCollection with: sourceFieldName)  inTableNamed: sourceTableName</body><body package="GlorpMigration" selector="setAsPrimaryKeyFieldsNamed:inTableNamed:">setAsPrimaryKeyFieldsNamed: collSourceFieldNames inTableNamed: sourceTableName "Adds the fields to primary key constraints in the table. Both parameters are strings"	|  table fields field |	(table := self sourceTableNamed: sourceTableName) ifNil: [^nil].	fields := collSourceFieldNames		collect: [ :each | 			(field := self fieldNamed: each from: table) ifNil: [^nil].			(field isPrimaryKey 				and: [(self operations anySatisfy: [ :operation  | operation hasDropPrimaryKeyConstraintForFor: field table ]) not ])					ifTrue: [^ScriptError raiseRequestErrorString: ('The field &lt;1s&gt; is already the primary key in the table &lt;2s&gt;' expandMacrosWith: each with: sourceTableName )].				field].	self addPrimaryKeyConstraint: ( PrimaryKeyConstraint forTable: table fields: fields)</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - execute sql</category><body package="GlorpMigration" selector="execute:">execute: sqlString"Executes the SQL statement. The parameter is string" 	sqlString isEmpty ifTrue: [^nil].	^ self addOperation: (ExecuteSql new		sqlString: sqlString;		yourself)</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - rename</category><body package="GlorpMigration" selector="renameField:to:">renameField: aDatabaseField to: newFieldName"Renames a database field to newFieldName. The first parameter is Glorp.DatabaseField "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #renameField:to: parameter' ].	^ self addOperation: (RenameField new		databaseField: aDatabaseField;		newFieldName: newFieldName;		yourself)</body><body package="GlorpMigration" selector="renameFieldNamed:inTableNamed:to:">renameFieldNamed: oldFieldName inTableNamed: tableName to: newFieldName"Renames a database field to newFieldName in the table. All parameters are strings "	^ self		renameField: ( self fieldNamed:oldFieldName from: (self sourceTableNamed: tableName))		to: newFieldName</body><body package="GlorpMigration" selector="renameTable:to:">renameTable: aDatabaseTable to: newTableName"Renames the database table  to newTableName. The parameter is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #renameTable:to: parameter' ].		^ self addOperation: (RenameTable new		databaseTable: aDatabaseTable;		newTableName: newTableName;		yourself)</body><body package="GlorpMigration" selector="renameTableNamed:to:">renameTableNamed: oldTableName to: newTableName"Renames the database table to newTableName. All parameters are strings "	^ self		renameTable: (self sourceTableNamed: oldTableName)		to: newTableName</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>private</category><body package="GlorpMigration" selector="alterFieldNamed:in:attribute:value:">alterFieldNamed: fieldName in: tableName attribute: aSymbol value: anObject	| operation aDatabaseField table |	(table := self sourceTableNamed: tableName) ifNil: [^nil].	(aDatabaseField := self fieldNamed: fieldName from: table) ifNil: [^nil].	operation := self operations 					detect: [ :op | op isAlterField and: [op accept: aDatabaseField]] 					ifNone: [self addOperation: (AlterField new databaseField: aDatabaseField; yourself )].	anObject		ifNil: [operation perform: aSymbol]		ifNotNil: [operation perform: aSymbol with: anObject ]</body><body package="GlorpMigration" selector="getSystemFrom:or:">getSystemFrom: aDescriptorSystem or: aDescriptorClass	^ aDescriptorClass = aDescriptorSystem class		ifTrue: [aDescriptorSystem]		ifFalse: [ (aDescriptorClass sessionForLogin: aDescriptorSystem session currentLogin) system]</body><body package="GlorpMigration" selector="newForeignKeyConstraintFor:from:suffixExpression:">newForeignKeyConstraintFor: sourceFields from: targetFields suffixExpression: suffixExpression	^ForeignKeyConstraint		sourceFields: sourceFields		targetFields: targetFields 		suffixExpression:  suffixExpression</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet class</class-id> <category>instance creation</category><body package="GlorpMigration" selector="from:to:">from: sourceSystemDescriptor to: destinationSystemDescriptor	^ self new		from: sourceSystemDescriptor to: destinationSystemDescriptor;		yourself</body><body package="GlorpMigration" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.ExecuteSql</class-id> <category>accessing</category><body package="GlorpMigration" selector="sqlString">sqlString	^sqlString</body><body package="GlorpMigration" selector="sqlString:">sqlString: anObject	sqlString := anObject</body></methods><methods><class-id>Glorp.Migration.ExecuteSql</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor doDDLOperation: [		aGlorpSession accessor executeSQLStringNoResult: self sqlString ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' execute: ';		nextPutAll: self sqlString printString;		nextPut: $.;		cr.</body></methods><methods><class-id>Glorp.Migration.ExecuteSql</class-id> <category>initialize-release</category><body package="GlorpMigration" selector="initialize">initialize	super initialize.	sqlString := nil.</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>accessing</category><body package="GlorpMigration" selector="constraint">constraint	^constraint</body><body package="GlorpMigration" selector="constraint:">constraint: aForeignKeyConstraint	constraint :=  aForeignKeyConstraint</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor 		addConstraint: constraint 		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream		aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'addForeignKeyFromTable: ';			nextPutAll: constraint  sourceFields first table name asUppercase printString;			space.		(constraint  sourceFields size = 1 and: [constraint  targetFields size = 1])			ifTrue: [aStream						nextPutAll: 'fromField: ';						nextPutAll: constraint  sourceFields first name asUppercase printString]			ifFalse: [aStream nextPutAll: 'fromFields: #( '.					constraint  sourceFields do: [ :f | aStream nextPutAll:  f name asUppercase printString, ' ' ].					aStream nextPutAll: ' ) ' ].		aStream			space;			nextPutAll: 'toTable: ';			nextPutAll: constraint  targetFields first table name asUppercase printString;			space.		(constraint  sourceFields size = 1 and: [constraint  targetFields size = 1])			ifTrue: [aStream						nextPutAll: 'toField: ';						nextPutAll: constraint  targetFields first name asUppercase printString]			ifFalse: [aStream nextPutAll: 'toFields: #( '.					constraint  targetFields do: [ :f | aStream nextPutAll:  f name asUppercase printString, ' ' ].					aStream nextPutAll: ' )' ].		constraint   suffixExpression			ifNotNil: [ :exp |					aStream						space;						nextPutAll: ' suffixExpression: ';						nextPutAll: exp printString;						nextPut: $.].		aStream 			nextPut: $.;			cr</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>testing</category><body package="GlorpMigration" selector="hasAddForeignKeyConstraintFor:">hasAddForeignKeyConstraintFor: aForeignKeyConstraint	^constraint  isSimilarForeignKeyConstraint:  aForeignKeyConstraint</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration" selector="weigh">weigh	^25</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>testing</category><body package="GlorpMigration" selector="accept:">accept: aDatabaseField	^self databaseField name = aDatabaseField name		and: [self databaseField table name = aDatabaseField table name]</body><body package="GlorpMigration" selector="isAlterField">isAlterField	^true</body><body package="GlorpMigration" selector="isModified">isModified	^isNullable notNil		or: [ isUnique notNil			or: [ isLockKey notNil 				or: [ defaultValue notNil					or: [ type notNil 						or: [dropDefault notNil ]]]]]</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>accessing</category><body package="GlorpMigration" selector="databaseField">databaseField	^databaseField</body><body package="GlorpMigration" selector="databaseField:">databaseField: anObject	databaseField := anObject</body><body package="GlorpMigration" selector="dropDefaultValue">dropDefaultValue	dropDefault := true</body><body package="GlorpMigration" selector="fieldName">fieldName	^self databaseField name printString</body><body package="GlorpMigration" selector="setDefaultValueTo:">setDefaultValueTo: anObject		defaultValue := anObject</body><body package="GlorpMigration" selector="setNotNullable">setNotNullable	isNullable := false</body><body package="GlorpMigration" selector="setNullable">setNullable	databaseField isPrimaryKey ifFalse: [ isNullable := true ]</body><body package="GlorpMigration" selector="setTypeTo:">setTypeTo: aType		type := aType</body><body package="GlorpMigration" selector="tableName">tableName	^self databaseField table name printString</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>api</category><body package="GlorpMigration" selector="applyInMySQLSession:">applyInMySQLSession: aGlorpSession	"The migration change mechanism generates a series of discrete changes to the field.	But some DB platforms (eg., MySQL) require complete column specification for any change.	This method places all the changes into a single 'alter' statement. Piecewise, each	successive statement would undo the previous one."		| accessor newField |	accessor := aGlorpSession accessor.	self isModified		ifTrue:			[newField := self databaseField copy.			dropDefault ifNotNil: [newField defaultValue: nil].			defaultValue				ifNotNil: [:val | newField defaultValue: defaultValue].			type ifNotNil: [:val | newField type: val].			isNullable ifNotNil: [:val | newField beNullable: val].			"isUnique ifNotNil: [:val | newField isUnique: val]."			"Write the change(s) to the DB by generating an 'alter' statement.			Use nullable attribute, whether it's changed or not, since any will do."			newField isNullable				ifTrue:					[accessor						alterFieldDropNotNull: newField						ifError: [:ex | ex pass]]				ifFalse:					[accessor						alterFieldSetNotNull: newField						ifError: [:ex | ex pass]].			"For MySQL, the UNIQUE constraint, if removing, must be dropped in its own statement."			"isUnique ifNotNil: [:val | val ifFalse:				[accessor					alterFieldDropUnique: self databaseField							ifError: [:ex | ex pass]]]"]</body><body package="GlorpMigration" selector="applyInSQLServerSession:">applyInSQLServerSession: aGlorpSession	"Combine the [NOT] NULL change with the type change because MS-SQLServer requires both type and NULL together.	Changing DEFAULT means first dropping the existing constraint, if any, and then adding the new one.	Currently, changing/dropping the default value is unsupported with SQL Server."	| accessor |	accessor := aGlorpSession accessor.	"mustDropDefault := (dropDefault notNil) or: [defaultValue notNil and: [self databaseField hasColumnDefaultConstraint]].	mustDropDefault ifTrue: 		[accessor alterFieldDropDefault: self databaseField ifError: [ :ex | ex pass ]].	defaultValue ifNotNil: 		[ :val | accessor alterField: self databaseField setDefault: defaultValue ifError: [ :ex | ex pass ]]."	((isNullable notNil) or: [type notNil]) ifTrue:			[|tempField mustSetNullable|				tempField := self databaseField copy.				type ifNotNil: [:val | tempField type: val].				isNullable ifNotNil: [:val | tempField beNullable: val].				mustSetNullable := isNullable isNil ifTrue: [true] ifFalse: [isNullable].				mustSetNullable					ifTrue: [accessor alterFieldDropNotNull: tempField ifError: [ :ex | ex pass]]					ifFalse: [accessor alterFieldSetNotNull: tempField ifError: [ :ex |  ex pass ]]].	"isUnique ifNotNil: [ :val |  		val 			ifTrue: [accessor alterFieldSetUnique: self databaseField ifError: [ :ex | ex pass]]			ifFalse: [accessor alterFieldDropUnique: self databaseField ifError: [ :ex |  ex pass ]]]."</body><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	"Apply the [NOT] NULL change before the type change because MS-SQLServer wants the type included for that change."	| accessor |	accessor := aGlorpSession accessor.	aGlorpSession platform class = Glorp.MySQLPlatform ifTrue: [^self applyInMySQLSession: aGlorpSession].	aGlorpSession platform class = Glorp.SQLServerPlatform ifTrue: [^self applyInSQLServerSession: aGlorpSession].	dropDefault ifNotNil: 		[accessor alterFieldDropDefault: self databaseField ifError: [ :ex | ex pass ]].	defaultValue ifNotNil: 		[ :val | accessor alterField: self databaseField setDefault: defaultValue ifError: [ :ex | ex pass ]].	isNullable ifNotNil: [ :val |  		val 			ifTrue: [accessor alterFieldDropNotNull: self databaseField ifError: [ :ex | ex pass]]			ifFalse: [accessor alterFieldSetNotNull: self databaseField ifError: [ :ex |  ex pass ]]].	type ifNotNil: 		[ :val | accessor alterField: self databaseField newType: val ifError: [ :ex | ex pass]].	"isUnique ifNotNil: [ :val |  		val 			ifTrue: [accessor alterFieldSetUnique: self databaseField ifError: [ :ex | ex pass]]			ifFalse: [accessor alterFieldDropUnique: self databaseField ifError: [ :ex |  ex pass ]]]."</body><body package="GlorpMigration" selector="writeDefaultValueFor:on:">writeDefaultValueFor: argumentName on: aStream	defaultValue ifNotNil: 		[aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'setDefaultValueForFieldNamed: ';			nextPutAll: self fieldName;			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self tableName;			space;			nextPutAll: 'to: ';			nextPutAll: defaultValue printString;			nextPut: $.;			cr ].</body><body package="GlorpMigration" selector="writeDropDefaultFor:on:">writeDropDefaultFor: argumentName on: aStream	dropDefault ifNotNil: 		[aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'dropDefaultValueForFieldNamed: ';			nextPutAll: self fieldName;			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self tableName;			nextPut: $.;			cr ].</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	self writeIsNullableFor: argumentName on: aStream.	self writeTypeFor: argumentName on: aStream.	self writeDropDefaultFor: argumentName on: aStream.	self writeDefaultValueFor: argumentName on: aStream.</body><body package="GlorpMigration" selector="writeIsNullableFor:on:">writeIsNullableFor: argumentName on: aStream	isNullable ifNotNil: [ :val |  		aStream tab.		val 			ifTrue: [aStream					nextPutAll: argumentName;					space;					nextPutAll: 'setNullableForFieldNamed: ';					nextPutAll: self fieldName;					space;					nextPutAll: 'inTableNamed: ';					nextPutAll: self tableName;					nextPut: $. ]			ifFalse: [aStream						nextPutAll: argumentName;						space;						nextPutAll: 'setNotNullableForFieldNamed: ';						nextPutAll: self fieldName;						space;						nextPutAll: 'inTableNamed: ';						nextPutAll: self tableName;						nextPut: $.].			aStream cr].</body><body package="GlorpMigration" selector="writeTypeFor:on:">writeTypeFor: argumentName on: aStream	type ifNotNil: 		[ aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'changeTypeForFieldNamed: ';			nextPutAll: self fieldName;			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self tableName;			space;			nextPutAll: 'to: ';			nextPutAll: '[ :dbplatform | dbplatform  ', type platformSelector, '].';			cr ].</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>validation</category><body package="GlorpMigration" selector="validateModificationsFrom:sourceField:">validateModificationsFrom: sourceField sourceField: destField	(sourceField isTheSameTypeAs: destField ) ifFalse: [type := destField type ].	(sourceField isPrimaryKey not and: [ destField isPrimaryKey not			and: [sourceField isNullable ~= destField isNullable ]])				ifTrue: [ isNullable := destField isNullable ].	sourceField defaultValue = destField defaultValue 		ifFalse: [ destField defaultValue ifNil: [dropDefault := true].				defaultValue := destField defaultValue ]."Not supported yetThe rest of the column properties is platform dependent and should be calculated depending on db	sourceField isUnique = destField isUnique ifFalse: [ isUnique := destField isUnique].	sourceField isLockKey = destField isLockKey ifFalse: [isLockKey := destField isLockKey]."</body></methods><methods><class-id>Glorp.Migration.CopyFieldData</class-id> <category>accessing</category><body package="GlorpMigration" selector="fromField">fromField	^fromField</body><body package="GlorpMigration" selector="fromField:">fromField: anObject	fromField := anObject</body><body package="GlorpMigration" selector="tableName">tableName	^ self toField table name</body><body package="GlorpMigration" selector="toField">toField	^toField</body><body package="GlorpMigration" selector="toField:">toField: anObject	toField := anObject</body></methods><methods><class-id>Glorp.Migration.CopyFieldData</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession		aGlorpSession accessor		copyDataFromField: self fromField		toField: self toField		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'copyDataFromFieldNamed: ';		nextPutAll: self fromField name printString;		space;		nextPutAll: 'toFieldNamed: ';		nextPutAll: self toField name printString;		space;		nextPutAll: 'inTableNamed: ';		nextPutAll: self tableName printString;		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	aGlorpSession accessor 		dropConstraint: databaseTable primaryKeyConstraints  		ifError: [ :ex | ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' dropPrimaryKeyFromTableNamed: ';		nextPutAll: databaseTable name printString;		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id> <category>testing</category><body package="GlorpMigration" selector="hasDropPrimaryKeyConstraintForFor:">hasDropPrimaryKeyConstraintForFor: aDatabaseTable		^databaseTable name asUppercase = aDatabaseTable name asUppercase</body></methods><methods><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration" selector="weigh">weigh	^15</body></methods><methods><class-id>Glorp.Migration.PopulateField</class-id> <category>accessing</category><body package="GlorpMigration" selector="databaseField">databaseField	^databaseField</body><body package="GlorpMigration" selector="databaseField:">databaseField: anObject	databaseField := anObject</body><body package="GlorpMigration" selector="fieldName">fieldName	^ self databaseField name</body><body package="GlorpMigration" selector="fieldValue">fieldValue	^fieldValue</body><body package="GlorpMigration" selector="fieldValue:">fieldValue: anObject	fieldValue := anObject</body></methods><methods><class-id>Glorp.Migration.PopulateField</class-id> <category>api</category><body package="GlorpMigration" selector="applyInSession:">applyInSession: aGlorpSession	" Could a more appripriate (Glorp based) protocol than straight SQL be used here?"	aGlorpSession accessor		populateField: self databaseField		with: self fieldValue		ifError: [ :ex |  ex pass ]</body><body package="GlorpMigration" selector="writeFor:on:">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'populateFieldNamed: ';		nextPutAll: self fieldName printString;		space;		nextPutAll: 'inTableNamed: ';		nextPutAll: self databaseField table name printString;		space;		nextPutAll: 'with: ';		nextPutAll: self fieldValue printString;		nextPut: $.;		cr.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GlorpMigration" selector="isGlorpType">isGlorpType	^false</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>testing</category><body package="GlorpMigration" selector="isSimilarForeignKeyConstraint:">isSimilarForeignKeyConstraint: aConstraint	self sourceFields size ~= aConstraint sourceFields size ifTrue: [^false].	self sourceFields with: aConstraint sourceFields do: [:field1 :field2 | 		(field1 matchesField: field2) ifFalse: [^false]].	self targetFields size ~= aConstraint targetFields size ifTrue: [^false].	self targetFields with: aConstraint targetFields do: [:field1 :field2 | 		(field1 matchesField: field2) ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.Class</class-id> <category>cloning</category><body package="GlorpMigration" selector="cloneClassDefinition:">cloneClassDefinition: aString 	^self  definitionMessage		argumentAt: 1 put: aString;		evaluate</body><body package="GlorpMigration" selector="cloneMethodsInto:excluding:">cloneMethodsInto: newClass excluding: aBlock	| theClass  excluding |	theClass := newClass isMeta ifTrue: [ self class ] ifFalse: [self ].	theClass  selectorsAndMethodsDo: 			[:sel :meth | 			excluding := false.			aBlock ifNotNil: [ excluding := aBlock value: theClass value: meth ].			excluding ifFalse: [newClass								compile: meth getSource								classified: (theClass whichCategoryIncludesSelector: sel)]].</body><body package="GlorpMigration" selector="cloneSharesInto:">cloneSharesInto: newClass 	self asNameSpace dataBindings do: 		[:each | 		newClass			defineSharedVariable:  each key			private: each isPrivate 			constant: each  isConstant 			category: each category 			initializer: ( each hasInitializer ifTrue: [each method  getSource ] ifFalse: [nil]) ].</body><body package="GlorpMigration" selector="cloneWithName:">cloneWithName: aString"The method clones a new class with the specified name"	^self cloneWithName: aString comment: ''</body><body package="GlorpMigration" selector="cloneWithName:comment:">cloneWithName: aString comment: commentString"The method clones a new class with the specified name and comments"	^self cloneWithName: aString comment: commentString excluding: nil</body><body package="GlorpMigration" selector="cloneWithName:comment:excluding:">cloneWithName: aString comment: commentString excluding: aBlock"The method clones a new class with the specified name and comments excluding methods based on the criteria defined by aBlock. The aBlock is two arguments block where the first argument is the class and second one is a compiled method. If the block value returns false for the compliled method the method is not cloned. The new class is created in the class package"	^self 		cloneWithName: aString 		comment: commentString 		excluding: aBlock 		inPackage: (Store.Registry containingPackageForClass: self ) name</body><body package="GlorpMigration" selector="cloneWithName:comment:excluding:inPackage:">cloneWithName: aString comment: commentString excluding: aBlock inPackage: packageName"The method clones a new class with the specified name and comments excluding methods based on the criteria defined by aBlock. The aBlock is two arguments block where the first argument is the class and second one is a compiled method. If the block value returns false for the compliled method the method is not cloned. The new class in created in the package specified by packageName argument"	| newClass |	(self environment bindingFor: aString asSymbol) notNil 		ifTrue: [^self error: ('Can not clone the class The class name: &lt;1s&gt; is already exist!' expandMacrosWith: aString) ].	^Store.Policies packagePolicy 		forcePackage: (Store.Registry packageNamedOrCreate: packageName ) 		while: 			[ 	newClass := self cloneClassDefinition: aString.				newClass comment:  (' &lt;1s&gt; &lt;n&gt; &lt;2s&gt;' expandMacrosWith: commentString with: self  comment asString).				self					cloneMethodsInto: newClass excluding: aBlock;					cloneMethodsInto: newClass class excluding: aBlock;					cloneSharesInto: newClass .				newClass			 ].</body><body package="GlorpMigration" selector="cloneWithName:comment:inPackage:">cloneWithName: aString comment: commentString inPackage: packageName"The method clones a new class with the specified name and comments. The new class in created in the package specified by packageName argument"	^self 		cloneWithName: aString 		comment: commentString 		excluding: nil 		inPackage: packageName</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services columns</category><body package="GlorpMigration" selector="printSqlStatementToRenameColumn:to:on:">printSqlStatementToRenameColumn: oldColumn to: newColumnName on: aStream	" SQL Server statement is	sp_rename &lt;schema.table.oldColumn&gt;, &lt;newColumn&gt;, 'COLUMN'."		| oldColumnName |	oldColumnName := (self ddlTableNameFor: oldColumn table) , '.'		, (self nameForColumn: oldColumn name).	^self		sp_renameFrom: oldColumnName		to: (self nameForColumn: newColumnName)		type: 'COLUMN'		on: aStream</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services tables</category><body package="GlorpMigration" selector="printSqlStatementToRenameTable:to:on:">printSqlStatementToRenameTable: aDatabaseTable to: newTableName on: aStream	" SQL Server statement is	sp_rename &lt;oldTableName&gt;, &lt;newTableName&gt;, 'OBJECT'."	^self sp_renameFrom: (self ddlTableNameFor: aDatabaseTable) to: newTableName type: 'OBJECT' on: aStream</body><body package="GlorpMigration" selector="sp_renameFrom:to:type:on:">sp_renameFrom: oldName to: newName type: aType on: aStream	" SQL Server statement is	sp_rename &lt;oldTableName&gt;, &lt;newTableName&gt;, 'OBJECT'.	Tables are OBJECTs, Columns are type COLUMN."	aStream		nextPutAll: 'sp_rename ';		nextPutAll: oldName;		nextPutAll: ', ';		nextPutAll: newName;		nextPutAll: ', ';		nextPutAll: aType</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'timestamp'</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'char:', width printString .</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration" selector="calculateSynchronizeChangeSetFor:">calculateSynchronizeChangeSetFor: aCollection"The method calculates a change set between database tables and this descriptor and applies the changes to the database"	| systemFromDB migrationChangeSet |	systemFromDB := self databaseCopyWithTables: aCollection.	migrationChangeSet := Glorp.Migration.MigrationChangeSet from: systemFromDB to: self.	^ migrationChangeSet		calculateOperations;		yourself</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>private</category><body package="GlorpMigration" selector="databaseCopyWithTables:">databaseCopyWithTables: aCollection	^ ActiveRecordDescriptorSystem new		getSessionAndPlatformFrom: self;		readTablesFromDatabase: (aCollection collect: [ :eachTable | eachTable name ]);		yourself.</body><body package="GlorpMigration" selector="getSessionAndPlatformFrom:">getSessionAndPlatformFrom: aDescriptorSystem	self		session: aDescriptorSystem session;		platform: aDescriptorSystem platform;		useDirectAccessForMapping: aDescriptorSystem useDirectAccessForMapping;		useJoinsForAnySatisfy: aDescriptorSystem useJoinsForAnySatisfy</body><body package="GlorpMigration" selector="readTablesFromDatabase:">readTablesFromDatabase: tableNames	tableNames do: [ :eachName |		(self tableNamedFromDatabase: eachName) ifNotNil: [ :databaseTable |			tables at: eachName asUppercase put: databaseTable ] ].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>api-migration</category><body package="GlorpMigration" selector="migrationCopy">migrationCopy	^ (self copy changeClassTo: Glorp.Migration.TableCopyForMigration) postMigrationCopy</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'time'</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'double'</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'clob'</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>private</category><body package="GlorpMigration" selector="allMigrationPragmas">allMigrationPragmas	^Pragma allNamed: self migrationPragmaSelector in: self</body><body package="GlorpMigration" selector="completeMigrationPathUntil:">completeMigrationPathUntil: aBlock	| nextAncestor |	nextAncestor := self.	[ nextAncestor isNil ] whileFalse: [		(aBlock value:  nextAncestor) 			ifTrue: [nextAncestor := nil]			ifFalse: [nextAncestor := nextAncestor migrationAncestor ]].</body><body package="GlorpMigration" selector="defaultDeltaScriptSelectorFor:">defaultDeltaScriptSelectorFor: anotherDescriptorSystemClass	^(self migrationPragmaSelector copyFrom: 1 to: self migrationPragmaSelector size - 1), anotherDescriptorSystemClass name, ':'</body><body package="GlorpMigration" selector="isMigrationAncestorOf:">isMigrationAncestorOf: aDescriptorSystem	^self migrationAncestor = aDescriptorSystem 		or: [self migrationAncestor notNil and: [self migrationAncestor isMigrationAncestorOf:  aDescriptorSystem]]</body><body package="GlorpMigration" selector="isMigrationDescendantOf:">isMigrationDescendantOf: aDescriptorSystem	^aDescriptorSystem migrationAncestor = self 		or: [aDescriptorSystem migrationAncestor notNil and: [aDescriptorSystem migrationAncestor isMigrationAncestorOf:  self]]</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>accessing</category><body package="GlorpMigration" selector="migrationAncestor">migrationAncestor"To be able to migrate from one version to another one this method has to return the previous version of a descriptor system"	^nil</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>private</category><body package="GlorpMigration" selector="migrationPathTo:">migrationPathTo: destinationDescriptorSystem	| migrationPath |	migrationPath := OrderedCollection new.	(self  isMigrationDescendantOf: destinationDescriptorSystem) 		ifTrue: [ destinationDescriptorSystem completeMigrationPathUntil: [ :cl | migrationPath addFirst: cl. cl = self ] ].	(self  isMigrationAncestorOf: destinationDescriptorSystem) 		ifTrue: [ self completeMigrationPathUntil: [ :cl | migrationPath add: cl. cl = destinationDescriptorSystem ] ].	^migrationPath isEmpty 		ifTrue: [(Glorp.Migration.CalculatingChangeSetError new				source: self ;				destination: destinationDescriptorSystem;				errorString: ( 'The databaseSchemas &lt;1s&gt; and &lt;2s&gt; are not in a direct migration path.' expandMacrosWith: self name with: destinationDescriptorSystem name );					yourself) raise ]		ifFalse: [migrationPath]</body><body package="GlorpMigration" selector="migrationPathWithScriptsTo:">migrationPathWithScriptsTo: destinationDescriptorSystem	| migrationPath scripts |	migrationPath := self migrationPathTo:  destinationDescriptorSystem.	scripts := OrderedCollection new.	1 to: migrationPath size - 1		do: [ :ind | | src dest pragmas |			src := migrationPath at: ind.			dest := migrationPath at: ind + 1.			pragmas := src migrationPragmasFor: dest.			pragmas size &gt; 1 ifTrue: [ ^(Glorp.Migration.CalculatingChangeSetError new					source: src;					destination: dest;					errorString: ( 'The descriptor system &lt;1s&gt; has more than one migration script for &lt;2s&gt; ' expandMacrosWith: src name with: dest name );					yourself) raise ].			pragmas notEmpty				ifTrue: [ scripts add: (Glorp.Migration.ScriptedOperations new					source: src;					destination: dest;					selector: pragmas first selector;					yourself) ]				ifFalse: [scripts add: (Glorp.Migration.CalculatedOperations new					source: src;					destination: dest;					yourself) ]			].	^ scripts</body><body package="GlorpMigration" selector="migrationPragmaSelector">migrationPragmaSelector	^ #migrationScriptTo:</body><body package="GlorpMigration" selector="migrationPragmasFor:">migrationPragmasFor: aDescriptorSystemClass		^self allMigrationPragmas select: [ :eachPragma |		(eachPragma argumentAt: 1)  = aDescriptorSystemClass name ]</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>cloning</category><body package="GlorpMigration" selector="newSchema:">newSchema: newName" The method clones a new version of the database descriptor. This descriptor system will be specified as an ancestor in the new class #migrationAncestor method."	| newClass |	newClass := self		cloneWithName: newName		comment: ('Cloned from &lt;1s&gt; on &lt;2s&gt;' expandMacrosWith: self name with: Timestamp now printString)		excluding: [ :cl :meth | 					( cl isMeta not and: ['migration scripts' match: (cl whichCategoryIncludesSelector: meth selector) asString])						or: [cl isMeta and: [meth selector = #migrationAncestor ]]	 ].		newClass class 			compile: 'migrationAncestor	"The schema ancestor. The method is used in the schema migration "	^', self name asString			classified: #accessing.	^newClass</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration" selector="allMigrationPragmas">allMigrationPragmas	^ self class allMigrationPragmas</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration" selector="calculateSynchronizeChangeSet">calculateSynchronizeChangeSet"Calculates a change set between the database tables and tables description"	^ self calculateSynchronizeChangeSetFor: self allTables</body><body package="GlorpMigration" selector="calculateSynchronizeChangeSetFor:">calculateSynchronizeChangeSetFor: aCollection	" Simple DescriptorSystem doesn't know how to do this. Do nothing."</body><body package="GlorpMigration" selector="createDefaultMigrationScript:for:">createDefaultMigrationScript: methodSelector for: anotherDescriptorSystem"Creates a default migration script with specified method selector. The script method will be created with a pragma which argument is the destination descriptor system name"		| source |	source := self		generateDefaultMigrationScriptSource: methodSelector		for: anotherDescriptorSystem.	self class		compile: source		classified: #'migration scripts'.	^self		detectMigrationPragma: methodSelector		for: anotherDescriptorSystem class		ifNone: [Glorp.Migration.MigrationScriptError raiseErrorString: 'Failed to create the default migration script for: ', anotherDescriptorSystem class name ]</body><body package="GlorpMigration" selector="createDefaultMigrationScriptFor:">createDefaultMigrationScriptFor: anotherDescriptorSystem"Creates a default migration script and saves it in the method  #migrationScriptToAnotherDescriptorSystemName. The script method will be created with a pragma which argument is the destination descriptor system name"	^self 		createDefaultMigrationScript: (self defaultDeltaScriptSelectorFor: anotherDescriptorSystem )  		for: anotherDescriptorSystem</body><body package="GlorpMigration" selector="createMigrationChangeSetFor:">createMigrationChangeSetFor: anotherDescriptorSystem"Creates a migration change set to migrate to another descriptor system "		^ (self newMigrationChangeSetFor: anotherDescriptorSystem)		calculateMigrationScript;		yourself</body><body package="GlorpMigration" selector="createScriptAndMigrateTo:">createScriptAndMigrateTo: anotherDescriptorSystem"Creates a default migration script, saves it in the method  #migrationScriptToAnotherDescriptorSystemName and applies the script changes to a database"	| pragma |	pragma := self 		detectMigrationPragmaFor: anotherDescriptorSystem class		ifNone: 	[self createDefaultMigrationScriptFor: anotherDescriptorSystem  ].	self		migrateTo: anotherDescriptorSystem		using: pragma selector</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration" selector="defaultDeltaScriptSelectorFor:">defaultDeltaScriptSelectorFor: anotherDescriptorSystem	^ self class defaultDeltaScriptSelectorFor: anotherDescriptorSystem class</body><body package="GlorpMigration" selector="detectMigrationPragma:for:ifNone:">detectMigrationPragma: methodSelector for: aDescriptorSystemClass ifNone: aBlock		^ (self migrationPragmasFor: aDescriptorSystemClass)		detect: [ :eachPragma | eachPragma method selector = methodSelector asSymbol ]		ifNone: aBlock</body><body package="GlorpMigration" selector="detectMigrationPragmaFor:ifNone:">detectMigrationPragmaFor: aDescriptorSystemClass ifNone: aBlock	" It's a little counter-intuitive here. If #migrationPragmasFor: aDescriptorSystemClass	returns a non-empty collection, it will automatically satisfy the 'detect' condition.	Therefore, we just put 'true' in the detect block.	"	^ (self migrationPragmasFor: aDescriptorSystemClass)		detect: [ :p |  true ]		ifNone: aBlock</body><body package="GlorpMigration" selector="generateDefaultMigrationScriptSource:for:">generateDefaultMigrationScriptSource: methodSelector for: anotherDescriptorSystem"Creates a mogration script source"			^ (self createMigrationChangeSetFor: anotherDescriptorSystem) generateDefaultMigrationScriptSource: methodSelector</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>testing</category><body package="GlorpMigration" selector="hasTables">hasTables	^tables notEmpty</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration" selector="migrateTo:">migrateTo: anotherDescriptorSystem"Creates a default migration script and applies the script changes to a database"	^(self createMigrationChangeSetFor: anotherDescriptorSystem)		applyInSession: self session</body><body package="GlorpMigration" selector="migrateTo:using:">migrateTo: anotherDescriptorSystem using: messageSelector"Applies the migration script from the specified method to a database"	(self newMigrationChangeSetFor: anotherDescriptorSystem)		calculateChangesFor: self usingScript: messageSelector;		applyInSession: self session</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration" selector="migrationPragmaSelector">migrationPragmaSelector	^ self class migrationPragmaSelector</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration" selector="migrationPragmasFor:">migrationPragmasFor: aDescriptorSystemClass		^self class migrationPragmasFor: aDescriptorSystemClass</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration" selector="newMigrationChangeSetFor:">newMigrationChangeSetFor: aSystemDescriptor	" Answer a new instance of the migration object "	^ Glorp.Migration.MigrationChangeSet from: self to: aSystemDescriptor</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration" selector="recreateTables">recreateTables"The method drops all database tables and recreates them from this descriptor "	self recreateTables: self allTables</body><body package="GlorpMigration" selector="recreateTables:">recreateTables: aCollection"The method drops specified tables and recreates them from this descriptor "	self session recreateTables: aCollection</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'serial'</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'boolean'</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>testing</category><body package="GlorpMigration" selector="isGlorpType">isGlorpType	^true</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^self typeString</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'timetz'</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>accessing</category><body package="GlorpMigration" selector="platformSelector">platformSelector	^'varchar: ', width printString.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services columns</category><body package="GlorpMigration" selector="createAlterColumnStatement:newType:usingExpression:">createAlterColumnStatement: aField newType: aType usingExpression: expression	"With CHANGE COLUMN, MySQL requires the OLD and NEW column names, even if you're just changing the type.	There is no USING clause, so nonNil expression may need to be examined further."		| newField sqlStatementStream |	newField := aField copy.	newField type: aType.	sqlStatementStream := WriteStream on: String new.	self printSqlStatementToAlterColumn: aField to: newField on:			sqlStatementStream.	^sqlStatementStream contents</body><body package="GlorpMigration" selector="createAlterColumnStatementDropNotNull:">createAlterColumnStatementDropNotNull: aField	| newField sqlStatementStream |	newField := aField copy.	newField beNullable: true.	sqlStatementStream := WriteStream on: String new.	self printSqlStatementToAlterColumn: aField to: newField on:			sqlStatementStream.	^sqlStatementStream contents</body><body package="GlorpMigration" selector="createAlterColumnStatementSetNotNull:">createAlterColumnStatementSetNotNull: aField	"MySQL uses CHANGE oldName newName type spec instead of: ALTER COLUMN...TYPE."		| newField sqlStatementStream |	newField := aField copy.	newField beNullable: false.	sqlStatementStream := WriteStream on: String new.	self printSqlStatementToAlterColumn: aField to: newField on:			sqlStatementStream.	^sqlStatementStream contents</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services constraints</category><body package="GlorpMigration" selector="createConstraintDropStatement:">createConstraintDropStatement: aConstraint	"MySQL is apparently case-sensitive when dropping constraint names.	The constraints that we create are typically uppercase, but the constraint names we read	from the meta descriptors tend to be lowercase (for some reason)."	| aStream |	aConstraint shouldCreateInDatabase ifFalse: [^''].	aStream := WriteStream on: (String new: 50).	aStream nextPutAll: 'ALTER TABLE '.	self printDDLTableNameFor: aConstraint table on: aStream.	aStream		nextPutAll: ' DROP ';		nextPutAll: (self keywordForConstraintsWhenDropping: aConstraint);		nextPut: $ .	(aConstraint class = PrimaryKeyConstraint)		ifFalse: [aStream nextPutAll: aConstraint name asUppercase].	^aStream contents.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services columns</category><body package="GlorpMigration" selector="defaultUniqueConstraintNameFor:">defaultUniqueConstraintNameFor: aField	"Return the presumed name of a UNIQUE constraint for aField."		| constraintName |	constraintName := aField name.	^self capitalWritingOfColumnName		ifTrue: [constraintName asUppercase]		ifFalse: [constraintName]</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>constants</category><body package="GlorpMigration" selector="keywordForConstraintsWhenDropping:">keywordForConstraintsWhenDropping: aConstraint	"Return the term we use to describe a constraint when dropping them. This is required because MySQL wants you to use 'DROP FOREIGN KEY' or ''PRIMARY KEY' rather than the ANSI 'DROP CONSTRAINT'. Other constraints are treated by MySQL as column attributes (part of the column's type specification)."		^aConstraint class = PrimaryKeyConstraint		ifTrue: ['PRIMARY KEY']		ifFalse:			[aConstraint class = ForeignKeyConstraint				ifTrue: ['FOREIGN KEY']				ifFalse: [self error: 'Invalid constraint being dropped for MySQL.']]</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services columns</category><body package="GlorpMigration" selector="printColumn:on:">printColumn: eachGlorpDatabaseField on: sqlStatementStream	"Print the column specification for the CREATE TABLE statement.	Don't show a default value for serial columns, since their semanitics are different."	sqlStatementStream		space;		nextPutAll: (self nameForColumn: eachGlorpDatabaseField name);		space.	self printColumnTypeSpec: eachGlorpDatabaseField on: sqlStatementStream</body><body package="GlorpMigration" selector="printColumnTypeSpec:on:">printColumnTypeSpec: eachGlorpDatabaseField on: sqlStatementStream	"Print the column type specification for the CREATE/ALTER TABLE statement.	Don't show a default value for serial columns, since their semanitics are different."		sqlStatementStream		nextPutAll: eachGlorpDatabaseField typeString;		space;		nextPutAll:				(eachGlorpDatabaseField type isSerial						ifTrue: ['']						ifFalse:							[self sqlTextForDEFAULT: eachGlorpDatabaseField defaultValue]);		space;		nextPutAll:				(eachGlorpDatabaseField isNullable						ifTrue: [self sqlTextForNULLAttributeConstraint]						ifFalse: [self sqlTextForNOTNULLAttributeConstraint]);		space;		nextPutAll:				(eachGlorpDatabaseField isUnique						ifTrue: [self sqlTextForUNIQUEAttributeConstraint]						ifFalse: [self sqlTextForNOTUNIQUEAttributeConstraint])</body><body package="GlorpMigration" selector="printSqlStatementToAlterColumn:to:on:">printSqlStatementToAlterColumn: oldColumn to: newColumn on: aStream	"If you want to change a column name or type, use the CHANGE clause, followed by full type spec."		aStream		nextPutAll: 'ALTER TABLE ';		nextPutAll: (self ddlTableNameFor: oldColumn table);		nextPutAll: ' CHANGE ';		nextPutAll: (self nameForColumn: oldColumn name);		space;		nextPutAll: (self nameForColumn: newColumn name);		space.	self printColumnTypeSpec: newColumn on: aStream</body><body package="GlorpMigration" selector="printSqlStatementToRenameColumn:to:on:">printSqlStatementToRenameColumn: oldColumn to: newColumnName on: aStream	"If you want to change a column name or type, use the CHANGE clause, followed by full type spec."		| newColumn |	newColumn := oldColumn copy.	newColumn name: newColumnName.	self printSqlStatementToAlterColumn: oldColumn to: newColumn on: aStream</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>pragmas</category><body package="GlorpMigration" selector="pragmas">pragmas	&lt;pragmas: #instance&gt;	^#( migrationScriptTo: )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpDatabaseType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform selector typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpTimeStampType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>MySQLPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>ForeignKeyConstraint</name><environment>Glorp</environment><super>Glorp.DatabaseTableConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suffixExpression sourceFields targetFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GlorpVarCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>GlorpError</name><environment>Glorp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>GlorpClobType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>GlorpSerialType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generated sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpTimeType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpBooleanType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpDoubleType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpPGTimeWithTimeZoneType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class></st-source>