<?xml version="1.0"?><st-source><!-- Name: GlorpTestNotice: LGPL(S)The code is Copyright (C) 2000-2003  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USABundleName: GlorpTestBundleStructure: a Store.BundleForParcelComment: This is part of the GLORP system, an open-source library (LGPL(S)) for persisting Smalltalk objects in relational databases. For more information see the #notice property, the accompanying files and/or the web sites http://www.glorp.org or http://www.sourceforge.net/projects/glorp The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USADevelopmentPrerequisites: #(#(#any 'Glorp' '') #(#any 'SUnit' ''))Parcel: nilParcelName: GlorpTestPrerequisiteParcels: #(#('Glorp' '') #('SUnit' ''))Version: 7.8 - 1001Date: 12:01:27 PM December 21, 2010 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (dec10.3) of December 21, 2010 on December 21, 2010 at 12:01:27 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GlorpTestNamespace</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></name-space><class><name>GlorpTestCase</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseTypeIndividualDBTests</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type stType connection session table </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>AbstractLOBTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTextTest</name><environment>Glorp</environment><super>Glorp.AbstractLOBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpDatabaseBasedTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpSessionBasedTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpObjectComparisonJoinsTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itinerary1 itinerary2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpInventoryItem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpNonperishableItem</name><environment>Glorp</environment><super>Glorp.GlorpInventoryItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serialNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpFloat8Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpNoProxyCollectionReadTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDatabaseAccessorTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpImageFile</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title bits thumbnailBits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCommitOrderTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t1 t2 t3 t1id t2id t3id platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTestModelClass</name><environment>Glorp</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTestModelClass</class-id><body>An abstract superclass providing convenience methods for domain objects to facilitate testing.</body></comment><class><name>GlorpSQLPrintingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpStringTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpStringTest</class-id><body>Test string extensions in Glorp.</body></comment><class><name>GlorpMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpEmbeddedMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpEmbeddedMappingDBTest</class-id><body>This exercises the EmbeddedValueOneToOneMapping.</body></comment><class><name>GlorpNumericTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpBankAccount</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id accountNumber accountHolders eventsReceived </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpRowMapForMementosTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowMap a1 a2 b1 b2 table1 row1 row2 transaction c1 c2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpWritingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpRowDifferencingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session currentObject currentObjectRowMap correspondenceMap differenceMap mementoObject mementoObjectRowMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpInsertUpdateTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDateTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpSessionResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTimeTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpOwner</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id slave slaves </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpClobTest</name><environment>Glorp</environment><super>Glorp.AbstractLOBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTypeTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpCursoredCollectionDBTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpBook</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id description copiesInStock version title author </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpErrorTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpAddress</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id street number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTracingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tracing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpOneToManyDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId emailId1 emailId2 emailId3 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTimestampTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTestDescriptorSystem</name><environment>Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTestDescriptorSystem</class-id><body>This is an abstract superclass for all descriptor systems whose tables should be set up as part of the standard GLORP testing process. See GlorpDemoTablePopulatorResource.</body></comment><class><name>GlorpDocumentDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpDocumentDescriptorSystem</class-id><body>This is a test descriptor system for documents with attachments that have their attachment bytes in a separate table, so reading them can be deferred. Neither attachments nor attachmentBytes have references to their containing document, but do have primary keys as foreign keys to it. When writing, this exhibited a problem that if you didn't read the bytes, then the attachment was written properly, because it could get its documentId primary key component from the proxy to the attachmentBytes. But if you had read the attachmentBytes, then it tried to get the value from the attachmentBytes object, which didn't know about that value. So it couldn't find the primary key of the attachment, and therefore assumed it was new.</body></comment><class><name>GlorpVideoDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpVideoDescriptorSystem</class-id><body>This descriptor system represents a video rental/sales store which sells both online and in a physical store. The interesting bit is that there is no customer table, but there is a customer object. In the database, orders and credit status are linked directly to the store. We synthesize a customer object out of those relationships.</body></comment><class><name>GlorpFilteredInheritanceTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session allEmployees </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMessage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>folder user subject contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseLoginTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>login accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpJoinTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression compoundExpression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpReadingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpReadingTest</class-id><body>This tests the full reading mechanism, writing out some rows manually and then doing various read operations.Instance Variables:	session	&lt;Session&gt;		system	&lt;GlorpDemoDescriptorSystem&gt;	</body></comment><class><name>GlorpVarchar10Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTransformedTime</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id time </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTransformedTime</class-id><body>This class just holds a time, but that time is transformed into a representation in seconds in the database.Instance Variables:	id	&lt;Integer&gt;	The primary key	time	&lt;Time&gt;	The time</body></comment><class><name>GlorpWorkerDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpMockSession</name><environment>Glorp</environment><super>Glorp.GlorpSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpProxyTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session proxy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpNumeric52Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpFolder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user name messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBlobTest</name><environment>Glorp</environment><super>Glorp.AbstractLOBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTypeTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpObjectMappedToImaginaryTableTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>example example2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpQueryUnionTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpQueryUnionTest</class-id><body>This tests the ability to do a union operation on queries, returning results corresponding to multiple different queries.</body></comment><class><name>GlorpDocument</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id whatever attachments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpExpressionBasicPropertiesTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpEncyclopediaEntry</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id text title mediaType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCoreExtensionsTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpConditionalMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpBooleanTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpVideoCustomer</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dateOfBirth onlinePurchases inStorePurchases inStoreRentals store creditStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabasePlatformTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpRecordWithUpdateTime</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name updateTime updateSomeOtherThing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpRecordWithUpdateTime</class-id><body>This is a model class that has a timestamp which is updated each time it is written.Instance Variables:	id	&lt;Integer&gt;	The primary key	name	&lt;String&gt;	a name	updateTime	&lt;Timestamp&gt;	When we were last updated.</body></comment><class><name>GlorpTax</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name taxes supertax </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpAdHocMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping person descriptor table money rowMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpOneToOneDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpCollectionTypesDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><class><name>GlorpNumeric5ZeroTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpVideoCreditStatus</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>customer balanceOwing dateOwing comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpVideoCreditStatus</class-id><body>There is a possibility of one of these for each customer in a Store. If there is no credit owing or owed, then there is no record. Otherwise the record exists and records the total amount. This is pretty unlikely as a model of credit, but suits our purposes by providing a 1-1 relationship that may or may not exist.Instance Variables:	balanceOwing	&lt;Number&gt;		comments	&lt;String&gt;		customer	&lt;Customer&gt;	dateOwing	&lt;Date&gt;</body></comment><class><name>GlorpOffice</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id employees street employeeOfMonth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpInheritanceDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpAttachmentBytes</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>content </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpWorkingStiff</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpEmployee</name><environment>Glorp</environment><super>Glorp.GlorpWorkingStiff</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTransientEmployee</name><environment>Glorp</environment><super>Glorp.GlorpEmployee</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTransientEmployee</class-id><body>GlorpTransientEmployee is used to test that not all subclasses need to be persistent in inheritance mapping.</body></comment><class><name>GlorpPartialWritesTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTableTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptors dbPlatform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpPerson</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name address emailAddresses hasEmail </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDictionaryMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBasicTax</name><environment>Glorp</environment><super>Glorp.GlorpTax</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCompositeKeyTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDatabaseSequenceTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence table row2 row1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpEncyclopediaBioEntry</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner title text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpManager</name><environment>Glorp</environment><super>Glorp.GlorpEmployee</super><private>false</private><indexed-type>none</indexed-type><inst-vars>branch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpAttributeModelTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpAttachment</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index mimeType attachmentBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpEncyclopediaDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id><body>This is a set of test descriptors for dealing with different variations of dictionary mappings.</body></comment><class><name>GlorpExpressionTableAliasingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpHorizontalInheritanceTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpReadingDifferentCollectionsThroughMappingsTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpReadingDifferentCollectionsThroughMappingsWithClassModelsTest</name><environment>Glorp</environment><super>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTestModelsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTestModelsPackage</class-id><body>This class represents package information for the GlorpTestModels package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>GlorpVirtualCollectionBasicTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDeleteTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpDeleteTest</class-id><body>This tests deletions.</body></comment><class><name>GlorpExampleSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBankExampleSystem</name><environment>Glorp</environment><super>Glorp.GlorpExampleSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDemoDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpLinkTableAnywhereDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpDemoDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpLinkTableAnywhereDescriptorSystem</class-id><body>This is the same as the demo descriptor system, but with small modifications to use link tables in different places.</body></comment><class><name>GlorpVarchar2Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpCompositeKeyDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id><body>This is a system designed to test the use of composite keys. Its model is an email message system, where we have users, folders, keyed by name and owning user, and messages, keyed by a message id, folder name, and owning user.</body></comment><class><name>GlorpQueryTableAliasingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query expression elementBuilder session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMessageCollectorTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpWorker</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name pendingJobs finishedJobs priorityJobs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseBasicTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTaggableObject</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpImage</name><environment>Glorp</environment><super>Glorp.GlorpTaggableObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id location </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseTableTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTravelAgent</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name agency </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTravelAgent</class-id><body>This represents a travel agent. Travel agents are very simple, but have their agency embedded in their table, even though we expect the agencies to be unique instances, and to have multiple agents.Instance Variables:	agency	&lt;GlorpTravelAgency&gt;	description of agency	id	&lt;Integer&gt;	description of id	name	&lt;String&gt;	description of name</body></comment><class><name>GlorpFloat4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpSlave</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpConditionalMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping descriptor mapping1 mapping2 mapping3 newMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpConditionalMappingTest</class-id><body>This tests the conditional mapping basic API without going to the database.</body></comment><class><name>GlorpSurcharge</name><environment>Glorp</environment><super>Glorp.GlorpTax</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpNullCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpNullCommand</class-id><body>This represents a command with no additional syntax, basically just a stream. Useful for testing the generation of chunks of SQL.</body></comment><class><name>GlorpUser</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name folders </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp TestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpItinerary</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id reservation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpItinerary</class-id><body>An itinerary holds onto a single reservation. It may not make much sense, but we need to test another layer of indirection.</body></comment><class><name>GlorpThingOne</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><comment><class-id>Glorp.GlorpThingOne</class-id><body>This just exists to be put in collections.Instance Variables:	id	&lt;SmallInteger&gt;	description of id	name	&lt;String&gt;	description of name</body></comment><class><name>GlorpWarehouse</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id address currentItem items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpWeakCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mourned </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpGettingPrimaryKeyFromMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpBookstoreCustomer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name accountNumber booksOnOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpUnassembledItem</name><environment>Glorp</environment><super>Glorp.GlorpNonperishableItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>assemblyCost </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBasicMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping person </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>DefaultableThing</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id boolean integer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDescriptorSystemWithNamespaces</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			GlorpTestNamespace.*			</imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpExpressionJoiningTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source target base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDBTypeTestsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTypeTests</package></attributes></class><comment><class-id>Glorp.GlorpDBTypeTestsPackage</class-id><body>This class represents package information for the GlorpDBTypeTests package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>GlorpVariableTypeTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpVariableTypeTest</class-id><body>This exercises trying to map to objects that might be of multiple types, not related by inheritance. </body></comment><class><name>GlorpGallery</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name images </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpReadingDifferentCollectionsTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session singleQuery allQuery singleResult allResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpOptimisticLockingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpPerishableItem</name><environment>Glorp</environment><super>Glorp.GlorpInventoryItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>age </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpPoultry</name><environment>Glorp</environment><super>Glorp.GlorpPerishableItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>featherColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpChar2Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpPublisherEmployee</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name jobTitle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpLockingDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBankAccountNumber</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bankCode branchNumber accountNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpRowMapUnificationTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t1 t2 t3 f1 f2 f3 o1 o2 o3 rowMap platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTestClassInNamespace</name><environment>GlorpTestNamespace</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpConstantValueInRelationshipTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpCollectionTypesWithClassModelsDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpCollectionTypesDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><class><name>GlorpMediaType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name mimeType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpVarchar1Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTag</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id key label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpVideoStore</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name customers purchases rentals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDirectMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBreadthFirstTopologicalSortTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unsorted sorted groupA groupB groupC </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDescriptorSystemWithNamespacePoolDictionaryDeclarer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpPublisher</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name titles titlesWithNumberInStock titlesWithNumberInStockLink employees differentBunchOfEmployeesById </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDialectTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpDialectTest</class-id><body>Tests the portability methods in the Dialect class.</body></comment><class><name>GlorpTimedExpiryCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpInt8Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpObjectMappedToFunctionTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpFilteringQueryDBTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpCollectionTypeModelsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><comment><class-id>Glorp.GlorpCollectionTypeModelsPackage</class-id><body>This class represents package information for the GlorpCollectionTypeModels package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>GlorpTypeComparisonTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpExpressionIterationTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpSessionTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpFilteringQueryTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDatabaseIndexTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTimedStrongCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpJob</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpReadingPersonWithEmailAddressesTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session personRow addressRow emailAddress1Row emailAddress2Row id1 id2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpInt2Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpQueryStub</name><environment>Glorp</environment><super>Glorp.AbstractReadQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpQueryStub</class-id><body>A test class. This behaves like a query, but doesn't go to the database, it just returns whatever it was told to return on its creation, regardless of the parameters or session.Instance Variables:	result	&lt;Object&gt;	The thing we should return.</body></comment><class><name>GlorpEncyclopedia</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name entries biographicalEntries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpVideoPurchase</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title price inStore customer store </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpPrimaryKeyExpressionWithConstantTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression compoundExpression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpPassenger</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name frequentFlyerMiles airline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpConstantMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappingToClass mappingToRow mappingToSession slot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpCustomer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name transactions accounts accountsSortedById accountsSortedByIdDescending eventsReceived seenPostFetch seenPreWrite seenPostWrite seenExpiry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpUnitOfWorkTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpLineWorker</name><environment>Glorp</environment><super>Glorp.GlorpEmployee</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productionLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTreeNode</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpProxyEqualityTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session proxy proxy2 stub2 stub </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpRowMapForMementosCollectionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction rowMap collection newCollection copy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCursoredCollectionTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpAirline</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTestsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpTestsPackage</class-id><body>This class represents package information for the GlorpTests package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>GlorpAirlineMeal</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id description ingredients </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDeleteInUnitOfWorkTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unitOfWork </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>IdentityHashPrintingObject</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.IdentityHashPrintingObject</class-id><body>This is just an object we can easily identify by identity, used for transaction test debugging. We can put these into a transaction and easily distinguish them from their copies.</body></comment><class><name>TestCommandPermission</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTravelAgency</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name agents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTravelAgency</class-id><body>This represents a travel agency. The interesting persistence feature of these is that they are embedded in the agent table, but also treated as unique objects with their own relationships.Instance Variables:	agents	&lt;Collection of: GlorpTravelAgent&gt;	description of agents	name	&lt;String&gt;	description of name</body></comment><class><name>GlorpSelectCommandTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTransformedFieldValueWrapperTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inner outer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpThingWithLotsOfDifferentCollections</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id array orderedCollection set bag sortedCollection name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><class><name>GlorpEmailAddress</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id user host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpObjectTransactionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpExpressionTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBreadthFirstTopologicalSortItem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent id relatedItems status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpManyToManyDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>customer customerId accountId1 accountId2 accountId3 treeNodeClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpSortedCollectionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpReservation</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id passenger passengers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpReadQueryTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpVarchar4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpMockAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpVariableTypeTestSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpVariableTypeTestSystem</class-id><body>This is a system for testing variable relationships. That is, where we have a relationship that might be one type of object, or might be another, depending on some criteria. The objects are not related by inheritance. Our example is a relationship to images, where if the images are small we retrieve them directly, but if they are larger we only retrieve minimal information about them.3</body></comment><class><name>GlorpRowMapTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowMap a1 b1 table1 row2 platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBankTransaction</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id owner amount serviceCharge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpExpressionRebuildingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>original newBase rebuilt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpQueryCopyingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query expression elementBuilder session newQuery </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpCommandTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDirectMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpBankBranch</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accounts branchNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTimedProxyReaperTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reaper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpChar4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpVideoRental</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title dueDate price customer store </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseLoginResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessor login </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpNumeric5Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpObjectComparisonSubselectTest</name><environment>Glorp</environment><super>Glorp.GlorpObjectComparisonJoinsTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTestUpdatingTimestampInRecord</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpRegionalManager</name><environment>Glorp</environment><super>Glorp.GlorpManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>region </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpFakeElementBuilder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDatabaseTypeDBTests</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type stType connection session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpDescriptorTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMappingFromClassModelTests</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpObjectWithNoAccessors</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTypeTestsModelClass</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id test </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpServiceCharge</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCompressedMoney</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id array </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseSessionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDescriptorValidationTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpOwnerSlaveTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDBTestsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpDBTestsPackage</class-id><body>This class represents package information for the GlorpDBTests package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>GlorpImageLink</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title thumbnailBits fullImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpSimpleQueryTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpInt4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpDemoTablePopulatorResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>login </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpIntegerTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpMoney</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currency amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><shared-variable><name>DefaultLogin</name><environment>Glorp.GlorpDatabaseLoginResource</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpDBTests</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Glorp.GlorpDemoDescriptorSystem</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpTestModels</package></attributes></shared-variable><shared-variable><name>NeedsSetup</name><environment>Glorp.GlorpDemoTablePopulatorResource</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpDBTests</package></attributes></shared-variable><methods><class-id>Glorp.GlorpTestCase</class-id> <category>hacks</category><body package="GlorpTestModels" selector="knownFailure">knownFailure	"This does nothing, but makes it easier to search for known failures."	^self.</body><body package="GlorpTestModels" selector="unfinished">unfinished</body></methods><methods><class-id>Glorp.GlorpTestCase class</class-id> <category>testing</category><body package="GlorpTestModels" selector="isAbstract">isAbstract	^self sunitName = #GlorpTestCase</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>accessing</category><body package="GlorpDBTypeTests" selector="platform">platform	^connection platform</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>setUp</category><body package="GlorpDBTypeTests" selector="createTypeTestTable">createTypeTestTable	| system |	connection doDDLOperation: [		connection			dropTableNamed: 'TYPETESTS'			ifAbsent: [:ex | ex return: nil].		table := DatabaseTable named: 'TYPETESTS'.		table			createFieldNamed: 'test'			type: type.		(table createFieldNamed: 'id' type: session system platform inMemorySequence) bePrimaryKey.		connection			createTable: table			ifError:				[:ex | 				Transcript show: 'CANNOT CREATE TABLE'.             		self signalFailure: ex messageText.				ex return: nil].	].	system := self systemFor: table.	session system: system.	^table.</body><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	self subclassResponsibility.</body><body package="GlorpDBTypeTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	connection := session accessor.	type := self defaultDatabaseType.	table := self createTypeTestTable.</body><body package="GlorpDBTypeTests" selector="systemFor:">systemFor: aTable	| system descriptor mapping model |	system := DynamicDescriptorSystem new.	model := system addClassModelFor: GlorpTypeTestsModelClass.	model newAttributeNamed: #id.	model newAttributeNamed: #test type: stType.	system privateTableAt: aTable name put: aTable.	descriptor := Descriptor new.	descriptor system: system.	descriptor classModel: model.	descriptor table: aTable.	descriptor		addMapping: (DirectMapping from: #id to: (aTable fieldNamed: 'id')).	stType isNil		ifTrue:			[mapping := DirectMapping from: #test to: (aTable fieldNamed: 'test')]		ifFalse:			[mapping := DirectMapping				from: #test				type: stType				to: (aTable fieldNamed: 'test')].	descriptor addMapping: mapping.	system privateDescriptorAt: GlorpTypeTestsModelClass put: descriptor.	^system.</body><body package="GlorpDBTypeTests" selector="tearDown">tearDown	super tearDown.	session doDDLOperation: [		connection			dropTableNamed: 'TYPETESTS'			ifAbsent: [:ex | ex return: nil]].	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>initializing</category><body package="GlorpDBTypeTests" selector="initialize">initialize</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>helpers</category><body package="GlorpDBTypeTests" selector="compareFloatInModel:with:">compareFloatInModel: read with: original	read isNil ifTrue: [^false].	read test = original ifTrue: [^true].	read test isNil ifTrue: [^false].	^(read test - original) abs &lt;= 0.00001.</body><body package="GlorpDBTypeTests" selector="helpTestExplicitReadBackFor:">helpTestExplicitReadBackFor: dbOutValue	"Read back the row with the given value, using an explicit where clause."	| queryStream result |	queryStream := SQLStringSelectCommand sqlString: String new parameters: #() useBinding: false session: session.	queryStream nextPutAll: 'SELECT TEST,ID FROM TYPETESTS WHERE TEST '.	queryStream nextPutAll: (dbOutValue isNil ifTrue: [' IS '] ifFalse: [' = ']).	type print: dbOutValue on: queryStream.	result := connection executeSQLString: queryStream contents.	result isEmpty ifTrue: [^nil].	^(result atIndex: 1) atIndex: 1.</body><body package="GlorpDBTypeTests" selector="helpTestFloat:">helpTestFloat: anObject	"Don't try and read back an equal float, it'll likely fail on precision issues"	self		helpTestValue: anObject		compareModelWith:			[:read :original | self compareFloatInModel: read with: original]		compareWith:			[:read :original | original isNil or: [(read - original) abs &lt;= 0.00001]].</body><body package="GlorpDBTypeTests" selector="helpTestInvalidValue:">helpTestInvalidValue: anObject	self helpTestValue: anObject		compareModelWith: [:read :original | read isNil or: [ read test ~= original ]]		compareWith: [:read :original | read ~= original]</body><body package="GlorpDBTypeTests" selector="helpTestValue:">helpTestValue: anObject 	"Don't try and read back an equal float, it'll likely fail on precision issues"	self 		helpTestValue: anObject		compareModelWith: 			[:read :original | 			read notNil and: 					[(original isKindOf: Float) or: 							[original class == Dialect doublePrecisionFloatClass 								or: [read test = original]]]]		compareWith: [:read :original | read = original]</body><body package="GlorpDBTypeTests" selector="helpTestValue:compareModelWith:compareWith:">helpTestValue: anObject compareModelWith: modelBlock compareWith: aBlock 	self 		helpTestValueWithSQLWrite: anObject		compareModelWith: modelBlock		compareWith: aBlock.	self 		helpTestValueWithUnitOfWorkWrite: anObject		compareModelWith: modelBlock</body><body package="GlorpDBTypeTests" selector="helpTestValue:compareWith:">helpTestValue: anObject compareWith: aBlock 	self 		helpTestValue: anObject		compareModelWith: [:read :original | true]		compareWith: aBlock</body><body package="GlorpDBTypeTests" selector="helpTestValueWithSQLWrite:compareModelWith:compareWith:">helpTestValueWithSQLWrite: anObject compareModelWith: modelBlock compareWith: aBlock	| dbInValue readObject row converter dbOutValue typeTestModel system dbInValue2 readObject2 command |	system := self systemFor: table.	session system: system.	row := DatabaseRow newForTable: table.	row owner: GlorpTypeTestsModelClass new.	converter := type converterForStType: (stType isNil ifTrue: [anObject class] ifFalse: [stType]).	dbOutValue := converter convert: anObject toDatabaseRepresentationAs: type.	row atFieldNamed: 'test' put: dbOutValue.	self inTransactionDo: [	session writeRow: row.	command := SQLStringCommand new setSQLString:  'SELECT TEST, ID FROM TYPETESTS'.	command maximumLobSizeToRetrieveDirectly: ((dbOutValue class = ByteArray or: [dbOutValue isString]) ifTrue: [dbOutValue size] ifFalse: [42]).	dbInValue := (session accessor executeCommand: command) first atIndex: 1.	readObject := converter convert: dbInValue fromDatabaseRepresentationAs: type.	(session platform canUseInWhereClause: dbOutValue type: type) ifTrue: [		dbInValue2 := self helpTestExplicitReadBackFor: dbOutValue.		readObject2 := converter convert: dbInValue2 fromDatabaseRepresentationAs: type].	(session platform canUseInWhereClause: anObject type: type) ifTrue: [		typeTestModel := self readBackModelWithValue: anObject.		self assert: (modelBlock value: typeTestModel value: anObject)]	].	self assert: (aBlock value: readObject value: anObject).	readObject2 isNil ifFalse: [		self assert: (aBlock value: readObject2 value: anObject)].</body><body package="GlorpDBTypeTests" selector="helpTestValueWithUnitOfWorkWrite:compareModelWith:">helpTestValueWithUnitOfWorkWrite: anObject compareModelWith: aBlock	| typeTestModel system model |	system := self systemFor: table.	session system: system.	self inTransactionDo: [	session beginUnitOfWork.	model := GlorpTypeTestsModelClass new test: anObject.	session register: model.	session commitUnitOfWork.	session reset.	(session platform canUseInWhereClause: anObject type: type) ifTrue: [		typeTestModel := self readBackModelWithValue: anObject.		self assert: (aBlock value: typeTestModel value: anObject)]].</body><body package="GlorpDBTypeTests" selector="inTransactionDo:">inTransactionDo: aBlock	"Like the one in session, but always rollback."	| alreadyInTransaction result |	[ 	alreadyInTransaction := session isInTransaction.	alreadyInTransaction ifFalse: [session beginTransaction].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	alreadyInTransaction ifFalse: [session rollbackTransaction]]		ifCurtailed:			[alreadyInTransaction ifFalse: [session rollbackTransaction]].	^result.</body><body package="GlorpDBTypeTests" selector="readBackModelWithValue:">readBackModelWithValue: anObject	^session		readOneOf: GlorpTypeTestsModelClass		where: [:each | each test = anObject].</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests class</class-id> <category>resources</category><body package="GlorpDBTypeTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.AbstractLOBTest</class-id> <category>private</category><body package="GlorpDBTypeTests" selector="adjustForMaximumSize:">adjustForMaximumSize: aValue	^aValue size &gt; session platform maximumQueryValueSize 		ifTrue: [(aValue copyFrom: 1 to: session platform maximumQueryValueSize - 2), '%']		ifFalse: [aValue].</body><body package="GlorpDBTypeTests" selector="convertToTypeFrom:">convertToTypeFrom: anObject	"For SQL-Server, return the function which converts anObject's value to my type."		^anObject		ifNotNil:			[FunctionExpression for: #convertTo: withArguments: (Array with: anObject asGlorpExpression) basedOn: type asGlorpExpression system: session system]</body><body package="GlorpDBTypeTests" selector="helpTestExplicitReadBackFor:">helpTestExplicitReadBackFor: dbOutValue	"Read back the row with the given value, using an explicit where clause."	| queryStream result compareClause|	queryStream := SQLStringSelectCommand sqlString: nil parameters: #() useBinding: session useBinding session: session.	queryStream nextPutAll: 'SELECT TEST,ID FROM TYPETESTS WHERE TEST'.	compareClause := self platform isSQLServerPlatform ifTrue: [' = '] ifFalse: [' LIKE '].	queryStream nextPutAll: (dbOutValue isNil ifTrue: [' IS '] ifFalse: [compareClause]).	(dbOutValue notNil and: [type requiresCast]) ifTrue: [queryStream nextPutAll: ' CAST ('].	(self platform isSQLServerPlatform and: [dbOutValue notNil and: [type requiresConvertToVarbinary]])		ifTrue: [queryStream nextPutAll: ' CONVERT(varbinary(max),'].	(queryStream canBind: dbOutValue to: type) 		ifTrue: [			queryStream parameters: (Array with: dbOutValue).			queryStream nextPutAll: '?']		ifFalse: [type print: dbOutValue on: queryStream].	(dbOutValue notNil and: [type requiresCast]) ifTrue: [		queryStream nextPutAll: ' AS '.		queryStream nextPutAll: type queryType typeName.		queryStream nextPutAll: ')'].	(self platform isSQLServerPlatform and: [dbOutValue notNil and: [type requiresConvertToVarbinary]])		ifTrue: [queryStream nextPutAll: ')'].	result := connection executeCommand: queryStream.	result isEmpty ifTrue: [^nil].	^(result atIndex: 1) atIndex: 1.</body><body package="GlorpDBTypeTests" selector="helpTestValue:compareModelWith:compareWith:">helpTestValue: anObject compareModelWith: modelBlock compareWith: aBlock 	| dbOutValue |	dbOutValue := self adjustForMaximumSize: anObject.	^super helpTestValue: dbOutValue compareModelWith: modelBlock compareWith: aBlock.</body><body package="GlorpDBTypeTests" selector="readBackModelWithValue:">readBackModelWithValue: anObject	"For SQL-Server, use CONVERT (which is easier than CAST for now), with = instead of LIKE."		^self platform isSQLServerPlatform		ifTrue:			[| converted |			converted := self convertToTypeFrom: anObject.			session				readOneOf: GlorpTypeTestsModelClass				where: [:each | each test = converted]]		ifFalse:			[session				readOneOf: GlorpTypeTestsModelClass				where: [:each | each test like: anObject]]	"^session		readOneOf: GlorpTypeTestsModelClass		where: [:each | each test like: (Cast value: anObject as: type queryType)]."</body></methods><methods><class-id>Glorp.GlorpTextTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform text</body></methods><methods><class-id>Glorp.GlorpTextTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="longString">longString	"Make a significant sized stringlob. 64k+ a bit should do"	| stream |	stream := WriteStream on: (String new: 10000).	(((2 raisedTo: 16) + 100.0) / 255.0) ceiling timesRepeat: [		stream nextPutAll: self string255].	^stream contents.</body><body package="GlorpDBTypeTests" selector="string255">string255	^'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu'.</body><body package="GlorpDBTypeTests" selector="testLargeText">testLargeText	"For Access, the long test here not only fails, it messes up the driver so that other tests fail"	(session platform class == AccessPlatform and: [session useBinding not])		ifTrue: [^self].	self helpTestValue: self longString.</body><body package="GlorpDBTypeTests" selector="testSymbol">testSymbol	"Test that we can store a Symbol as text. This is particularly interesting because then we have to go through a non-empty type converter, and those need to take into account that text type, although a string type, probably doesn't have a maximum width."	stType := Symbol.	self helpTestValue: #'ASymbolStoredAsText'.</body><body package="GlorpDBTypeTests" selector="testText">testText"	self helpTestValue: nil."	self helpTestValue: 'Now is the time for all good squeakers to come to the aid of the mouse'.</body></methods><methods><class-id>Glorp.GlorpDatabaseBasedTest</class-id> <category>support</category><body package="GlorpTests" selector="assert:equalsIgnoringOuterBrackets:">assert: aBrackettedString equalsIgnoringOuterBrackets: anotherString	self assert: aBrackettedString =		(anotherString first = $(			ifTrue: [anotherString]			ifFalse: ['(', anotherString, ')'])</body><body package="GlorpDBTests" selector="setUp">setUp	system := GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.	system session: GlorpMockSession new.	system session system: system.</body></methods><methods><class-id>Glorp.GlorpSessionBasedTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	system session: session.	session system: system.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session isNil ifFalse: [session reset. session resetPermissions].	session := nil.</body></methods><methods><class-id>Glorp.GlorpSessionBasedTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpSessionResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpObjectComparisonJoinsTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testBasicEqualNil">testBasicEqualNil	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passenger isNIL].	self assert: reservations size = 1.	self assert: reservations first id = 7.</body><body package="GlorpDBTests" selector="testBasicNotNil">testBasicNotNil	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passenger notNIL].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests" selector="testEqualNil">testEqualNil	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger isNIL]].	self assert: reservations size = 1.	self assert: reservations first id = 7.</body><body package="GlorpDBTests" selector="testEqualToIdsInExpression">testEqualToIdsInExpression	"Just to verify that this works when not directly comparing objects"	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger id = each passenger id]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests" selector="testEqualToObjectInExpression">testEqualToObjectInExpression	"A somewhat contrived example of comparing two relationships that should end up with the same object, because they're actually mapped the same way. But will fail if the passenger is nil"	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger = each passenger]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests" selector="testEqualToObjectInMemory">testEqualToObjectInMemory	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger = itinerary1 reservation passenger]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests" selector="testNotEqualToObjectInExpression">testNotEqualToObjectInExpression	"A somewhat contrived example of comparing two relationships that should end up with the same object, because they're actually mapped the same way. But will fail if the passenger is nil, because nil ~= nil"	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger ~= each passenger]].	self assert: reservations isEmpty.</body><body package="GlorpDBTests" selector="testNotEqualToObjectInMemory">testNotEqualToObjectInMemory	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger ~= (GlorpPassenger new id: 7)]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests" selector="testNotNil">testNotNil	| reservations |	reservations := session readManyOf: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger notNIL]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body></methods><methods><class-id>Glorp.GlorpObjectComparisonJoinsTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session system useJoinsForAnySatisfy: true.	session beginTransaction.	itinerary1 := GlorpItinerary example1.	itinerary2 := GlorpItinerary example2.	itinerary2 reservation passenger: nil.	itinerary2 reservation passengers: #().	session transact: [		session register: itinerary1.		session register: itinerary2].</body><body package="GlorpDBTests" selector="tearDown">tearDown		session rollbackTransaction.	itinerary1 := nil.	itinerary2 := nil.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpInventoryItem</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpInventoryItem</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: id printString.	aStream nextPut: $,.	aStream nextPutAll: name printString.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpNonperishableItem</class-id> <category>accessing</category><body package="GlorpTestModels" selector="serialNumber">serialNumber	^serialNumber</body><body package="GlorpTestModels" selector="serialNumber:">serialNumber: anObject	serialNumber := anObject</body></methods><methods><class-id>Glorp.GlorpFloat8Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform float8</body><body package="GlorpDBTypeTests" selector="testFloat8">testFloat8	type := (self platform) double.	self helpTestFloat: nil.	self helpTestValue: (Dialect coerceToDoublePrecisionFloat: 3.14) compareWith: [:read :original |		read - original &lt;= 0.0000001].</body></methods><methods><class-id>Glorp.GlorpNoProxyCollectionReadTest</class-id> <category>tests</category><body package="GlorpTests" selector="testReadCollectionWithoutProxies">testReadCollectionWithoutProxies	"before running this test change RelationshipMapping&gt;&gt;initialize shouldProxy := false"	| persons session |	session := GlorpSessionResource current newSession.	session platform supportsMultipleOpenCursors ifFalse: [^self].	(session system descriptorFor: GlorpPerson) mappings do: [:each | (each respondsTo: #shouldProxy: ) 		ifTrue: [each shouldProxy: false]].	session beginTransaction.	[session beginUnitOfWork.	session register: GlorpPerson example1.	session register: GlorpPerson example2.	session commitUnitOfWork.	session reset.	persons := session readManyOf: GlorpPerson.	self assert: persons size = 2] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpDatabaseAccessorTest</class-id> <category>tests</category><body package="GlorpTests" selector="testLoggingSwitch">testLoggingSwitch	| currentSetting accessor |	currentSetting := DatabaseAccessor loggingEnabled.	accessor := DatabaseAccessor new.	[DatabaseAccessor loggingEnabled: true.	self assert: accessor logging.	DatabaseAccessor loggingEnabled: false.	self deny: accessor logging.	accessor logging: true.	self assert: accessor logging.	accessor logging: false.	self deny: accessor logging.	DatabaseAccessor loggingEnabled: true.	self deny: accessor logging] ensure: [DatabaseAccessor loggingEnabled: currentSetting].</body></methods><methods><class-id>Glorp.GlorpImageFile</class-id> <category>accessing</category><body package="GlorpTestModels" selector="bits">bits	^bits</body><body package="GlorpTestModels" selector="bits:">bits: anObject	bits := anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="thumbnailBits:">thumbnailBits: aByteArray	thumbnailBits := aByteArray</body><body package="GlorpTestModels" selector="title">title	^title</body><body package="GlorpTestModels" selector="title:">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpImageFile</class-id> <category>testing</category><body package="GlorpTestModels" selector="isLarge">isLarge	^bits size &gt; 10.</body><body package="GlorpTestModels" selector="thumbnailBits">thumbnailBits	thumbnailBits isNil ifTrue: [thumbnailBits := bits copyFrom: 1 to: 5].	^thumbnailBits.</body></methods><methods><class-id>Glorp.GlorpImageFile class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		title: 'example1';		bits: #[1 2 3 4 5].</body><body package="GlorpTestModels" selector="example2">example2	^self new		title: 'example2';		bits: #[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15].</body></methods><methods><class-id>Glorp.GlorpCommitOrderTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	platform := system platform.	t1 := DatabaseTable new name: 'T1'.	t1id := (t1 createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	t2 := DatabaseTable new name: 'T2'.	t2id := (t2 createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	t3 := DatabaseTable new name: 'T3'.	t3id := (t3 createFieldNamed: 'ID' type: platform int4) bePrimaryKey.</body></methods><methods><class-id>Glorp.GlorpCommitOrderTest</class-id> <category>tests</category><body package="GlorpTests" selector="testCommitOrder">testCommitOrder	| sorter |	sorter := TableSorter for: (Array with: (system tableNamed: 'BANK_TRANS') with: (system tableNamed: 'GR_CUSTOMER')).	self assert: sorter sort first name = 'GR_CUSTOMER'.</body><body package="GlorpTests" selector="testCommitOrder2">testCommitOrder2	"Test for a cycle between t1 and t2 with t3 also pointing to both. Order of t1, t2 is indeterminate, but t3 should be last"	| table1 table1id table2 table2id t2fk t3fk t3fk2 sorter t1fk |	table1 := DatabaseTable new name: 'T1'.	table1id := (table1 createFieldNamed: 'ID' type: platform inMemorySequence) bePrimaryKey.	table2 := DatabaseTable new name: 'T2'.	table2id := (table2 createFieldNamed: 'ID' type: platform inMemorySequence) bePrimaryKey.	t1fk := table1 createFieldNamed: 'T2_ID' type: platform int4.	table1 addForeignKeyFrom: t1fk to: table2id.	t2fk := table2 createFieldNamed: 'T1_ID' type: platform int4.	table2 addForeignKeyFrom: t2fk to: table1id.	t3 := DatabaseTable new name: 'T3'.	t3fk := t3 createFieldNamed: 'T2_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk to: table2id.	t3fk2 := t3 createFieldNamed: 'T1_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk2 to: table1id.	sorter := TableSorter for: (Array with: t3 with: table2 with: table1).	self assert: sorter sort last name = 'T3'.</body><body package="GlorpTests" selector="testCommitOrderNonSequencedFieldsDontCount">testCommitOrderNonSequencedFieldsDontCount	"Test for a cycle between t1 and t2 with t3 also pointing to both, but with nothing sequenced. Order should be completely indeterminate. We rely on the topological sort being predictable and depending on the insert order so that if we feed objects with no dependencies in in different orders we should get different results."	| t1fk t2fk t3fk t3fk2 sorter sorter2 |	t1fk := t1 createFieldNamed: 'T2_ID' type: platform int4.	t1 addForeignKeyFrom: t1fk to: (t2id).	t2fk := t2 createFieldNamed: 'T1_ID' type: platform int4.	t2 addForeignKeyFrom: t2fk to: (t1id).	t3 := DatabaseTable new name: 'T3'.	t3fk := t3 createFieldNamed: 'T2_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk to: (t2id).	t3fk2 := t3 createFieldNamed: 'T1_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk2 to: (t1id).	sorter := TableSorter for: (Array with: t3 with: t2 with: t1).	sorter2 := TableSorter for: (Array with: t1 with: t2 with: t3).	self assert: sorter sort first ~= sorter2 sort first.</body></methods><methods><class-id>Glorp.GlorpSQLPrintingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testDatePrinting">testDatePrinting	| date stream |	date := Dialect newDateWithYears: 1997 months: 11 days: 14.	stream := WriteStream on: String new.	date glorpPrintSQLOn: stream.	self assert: stream contents = '''1997-11-14'''.	date := Dialect newDateWithYears: 2002 months: 5 days: 2.	stream := WriteStream on: String new.	date glorpPrintSQLOn: stream.	self assert: stream contents = '''2002-05-02'''.</body></methods><methods><class-id>Glorp.GlorpSQLPrintingTest</class-id> <category>As yet unclassified</category><body package="GlorpTests" selector="testGroupWriting">testGroupWriting	| system platform row1 row2 command string session |	platform := PostgreSQLPlatform new.	session := GlorpDemoDescriptorSystem sessionForLogin: (Login new database: platform).	system := session system.	platform useBinding: false.	row1 := DatabaseRow newForTable: (system tableNamed: 'GR_ADDRESS').	row1 atFieldNamed: 'ID' put: 1.	row2 := DatabaseRow newForTable: (system tableNamed: 'GR_ADDRESS').	row2 atFieldNamed: 'ID' put: 2.	command := InsertCommand forRows: (Array with: row1 with: row2) useBinding: false session: session.	string := command sqlString.	self assert: (string includes: $;).	self assert: string = 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (1,NULL,NULL); INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (2,NULL,NULL)'.</body></methods><methods><class-id>Glorp.GlorpStringTest</class-id> <category>tests</category><body package="GlorpTests" selector="testGlorpIsCollection">testGlorpIsCollection	self deny: 'abc' glorpIsCollection.	self deny: Object new glorpIsCollection.	self deny: $a glorpIsCollection.	self assert: #() glorpIsCollection.</body><body package="GlorpTests" selector="testLikePercent">testLikePercent	self deny: ('abc' like: 'def').	self assert: ('' like: '%').	self assert: ('abc' like: '%').	self assert: ('abc' like: '%bc').	self deny: ('abc' like: 'a%ac').	self assert: ('aaababc' like: '%bc').	self assert: ('abcd' like: 'ab%cd').	self assert: ('abcdef' like: 'ab%ef').	self assert: ('abcdef' like: 'ab%ef%').	self assert: ('abcdefg' like: 'ab%ef%').</body><body package="GlorpTests" selector="testLikeUnderscore">testLikeUnderscore	self deny: ('' like: '_').	self assert: ('a' like: '_').	self assert: ('abc' like: '_bc').	self deny: ('aaababc' like: '_bc').	self deny: ('abcd' like: 'ab_cd').	self assert: ('abcd' like: 'a_cd').	self assert: ('abcdef' like: 'ab__ef').	self assert: ('abcdef' like: 'ab__ef%').	self assert: ('abcdefg' like: 'ab%ef_').	self deny: ('abcdefgh' like: 'ab%ef_').</body></methods><methods><class-id>Glorp.GlorpMappingDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="inTransactionDo:">inTransactionDo: aBlock	[session beginTransaction.	aBlock value] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session reset.	session resetPermissions.	session := nil.	system := nil.</body></methods><methods><class-id>Glorp.GlorpMappingDBTest</class-id> <category>Running</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := session system.</body></methods><methods><class-id>Glorp.GlorpMappingDBTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpMappingDBTest class</class-id> <category>testing</category><body package="GlorpDBTests" selector="isAbstract">isAbstract	^self sunitName = #GlorpMappingDBTest</body></methods><methods><class-id>Glorp.GlorpEmbeddedMappingDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session beginTransaction.	self writeAgents.	session reset.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests" selector="writeAgents">writeAgents	| agent1 agent2 agent3 |	agent1 := GlorpTravelAgent new id: 1; name: 'Agent One'.	agent1 agency: (GlorpTravelAgency new name: 'Agency One').	agent2 := GlorpTravelAgent new id: 2; name: 'Agent Two'.	agent2 agency: agent1 agency.	agent3 := GlorpTravelAgent new id: 3; name: 'Agent Three'.	agent3 agency: (GlorpTravelAgency new name: 'Agency Two').	session modify: (Array with: agent1 with: agent2 with: agent3) in: [].</body></methods><methods><class-id>Glorp.GlorpEmbeddedMappingDBTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testModifyAgents">testModifyAgents	| agents |	agents := session read: GlorpTravelAgent orderBy: #id.	session modify: agents in: [		agents first name: 'Something Else'.		(agents at: 2) name: 'something else again'].	session reset.	agents := session read: GlorpTravelAgent orderBy: #id.	self assert: agents size = 3.	self assert: agents first agency yourSelf = (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf == (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf = agents last agency yourSelf.	self assert: agents first name = 'Something Else'.	self assert: (agents at: 2) name = 'something else again'.</body><body package="GlorpDBTests" selector="testModifyAgentsReadOnlyAgency">testModifyAgentsReadOnlyAgency	"Test that if the agency mappings are all read-only, that we don't cause an error by trying to generate entries in the row map for its primary keys."	(session system descriptorFor: GlorpTravelAgency) mappings do: [:each | each beReadOnly].	[self testModifyAgents] ensure: [		(session system descriptorFor: GlorpTravelAgency) mappings do: [:each | each readOnly: false]].</body><body package="GlorpDBTests" selector="testReadAgents">testReadAgents	| agents |	agents := session read: GlorpTravelAgent orderBy: #id.	self assert: agents size = 3.	self assert: agents first agency yourSelf = (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf == (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf = agents last agency yourSelf.</body></methods><methods><class-id>Glorp.GlorpNumericTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testNumeric">testNumeric	| floatSelector |	self helpTestFloat: 12.		self helpTestFloat: nil.	self helpTestFloat: (Dialect readFixedPointFrom: '12345678').	self platform supportsDecimalsOnAllNumerics ifTrue: [		self helpTestValue: 3.14  compareWith: [:read :original |			read - original &lt;= 0.00001]]		ifFalse: [self helpTestInvalidValue: 3.14].	floatSelector := self platform supportsDecimalsOnAllNumerics ifTrue: [#helpTestFloat:] ifFalse: [#helpTestInvalidValue:].	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat:  321.12).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: 321.123).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: (Dialect readFixedPointFrom: '321.123456789')).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: 3.14).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: 3.1).	self perform: floatSelector with: (Dialect readFixedPointFrom:  '321.12').	self perform: floatSelector with: (Dialect readFixedPointFrom: '321.123').	self perform: floatSelector with: (Dialect readFixedPointFrom: '3.14').	self perform: floatSelector with: (Dialect readFixedPointFrom: '3.1').</body></methods><methods><class-id>Glorp.GlorpNumericTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	"DB2 default precision is only 5, which needs to be increased for this test."	^self platform isDB2Platform		ifTrue: [self platform numeric precision: 10]		ifFalse: [self platform numeric]</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>accessing</category><body package="GlorpTestModels" selector="accountHolders">accountHolders	^accountHolders.</body><body package="GlorpTestModels" selector="accountNumber">accountNumber	^accountNumber</body><body package="GlorpTestModels" selector="accountNumber:">accountNumber: anAccountNumber 	accountNumber := anAccountNumber</body><body package="GlorpTestModels" selector="basicAddHolder:">basicAddHolder: aCustomer	accountHolders add: aCustomer.</body><body package="GlorpTestModels" selector="basicRemoveHolder:">basicRemoveHolder: aCustomer	accountHolders remove: aCustomer.</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: '(id=';		print: id;		nextPut: $).</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>initialize</category><body package="GlorpTestModels" selector="initialize">initialize	accountHolders := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>comparing</category><body package="GlorpTestModels" selector="&lt;=">&lt;= anAccount	^self accountNumber accountNumber &lt;= anAccount accountNumber accountNumber.</body></methods><methods><class-id>Glorp.GlorpBankAccount class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new 		id: 123;		accountNumber: GlorpBankAccountNumber example12345.</body></methods><methods><class-id>Glorp.GlorpBankAccount class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosTest</class-id> <category>tests</category><body package="GlorpTests" selector="testAdjustMultipleRowMapKey">testAdjustMultipleRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := MultipleRowMapKey with: a1 with: b1 with: c1.	adjustedKey := rowMapKey adjustIn: rowMap correspondenceMap.	self assert: (adjustedKey keys includes: a2).	self assert: (adjustedKey keys includes: b2).	self assert: (adjustedKey keys includes: c2).</body><body package="GlorpTests" selector="testAdjustRowMapKey">testAdjustRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := RowMapKey new.	rowMapKey key1: a1; key2: b1.	adjustedKey := rowMapKey adjustIn: rowMap correspondenceMap.	self assert: (adjustedKey key1 == a2).	self assert: (adjustedKey key2 == b2).</body><body package="GlorpTests" selector="testReverseAdjustMultipleRowMapKey">testReverseAdjustMultipleRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := MultipleRowMapKey with: a2 with: b2 with: c2.	adjustedKey := rowMapKey reverseAdjustIn: rowMap.	self assert: (adjustedKey keys includes: a1).	self assert: (adjustedKey keys includes: b1).	self assert: (adjustedKey keys includes: c1).</body><body package="GlorpTests" selector="testReverseAdjustRowMapKey">testReverseAdjustRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := RowMapKey new.	rowMapKey key1: a2; key2: b2.	adjustedKey := rowMapKey reverseAdjustIn: rowMap.	self assert: (adjustedKey key1 == a1).	self assert: (adjustedKey key2 == b1).</body><body package="GlorpTests" selector="testRowForTableMultiple">testRowForTableMultiple	| rowMapKey row |	rowMapKey := MultipleRowMapKey with: a1 with: b1 with: c1.	row := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row1 := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row2 := rowMap rowForTable: table1 withKey: rowMapKey.	self assert: row == row1.	self assert: row == row2.</body><body package="GlorpTests" selector="testRowForTableSingle">testRowForTableSingle	| rowMapKey row |	rowMapKey := RowMapKey new.	rowMapKey key1: a1; key2: b1.	row := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row1 := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row2 := rowMap rowForTable: table1 withKey: rowMapKey.	self assert: row == row1.	self assert: row == row2.</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	a1 := IdentityHashPrintingObject new.	b1 := IdentityHashPrintingObject new.	c1 := IdentityHashPrintingObject new.	transaction := ObjectTransaction new.	transaction register: a1.	transaction register: b1.	transaction register: c1.	a2 := transaction undoMap at: a1.	b2 := transaction undoMap at: b1.	c2 := transaction undoMap at: c1.	rowMap := RowMapForMementos withCorrespondenceMap: transaction undoMap.	table1 := DatabaseTable new.	row1 := 'row1'.	row2 := 'row2'.</body></methods><methods><class-id>Glorp.GlorpWritingTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testLargeWrite">testLargeWrite	"This is really just a performance test. No assertions. It should take on the order of 10 seconds. If it starts taking 10 minutes, it indicates a potential problem...."	| customer |	session beginTransaction.	[customer := GlorpCustomer new.	customer name: 'foo'.     customer id: 123.	1 to: 5000 do: [:i | | transaction |		transaction := GlorpBankTransaction new.		transaction amount amount: i.		customer addTransaction: transaction].	session beginUnitOfWork.	session register: customer.	session commitUnitOfWork]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testMultipleWritesAndReads">testMultipleWritesAndReads	"Trying to narrow down on a problem with SQLiteEXDI"	| names customers |	session beginTransaction.	[session beginUnitOfWork.	names := OrderedCollection new.	1 to: 10		do: 			[:i | 			| nm |			nm := 'John Doe ' , i printString.			names add: nm.			session register: ((GlorpCustomer new)									id: i;									name: nm;									yourself)].	session commitUnitOfWork.	customers := session readManyOf: GlorpCustomer.	self assert: (names asSortedCollection isSameSequenceAs: (customers collect: [:ea | ea name]) asSortedCollection).	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testRegistrationFromWrittenObject">testRegistrationFromWrittenObject	| customer trans transactions |	session beginTransaction.	[customer := GlorpCustomer new.	customer name: 'foo'.     customer id: 123.	session beginUnitOfWork.	session register: customer.	session commitUnitOfWork.	trans := GlorpBankTransaction new.	session beginUnitOfWork.	session readOneOf: GlorpCustomer where: [:each | each id = customer id].	customer addTransaction: trans.	session commitUnitOfWork.	transactions := session accessor executeSQLString: 'SELECT ID FROM BANK_TRANS WHERE OWNER_ID = ', customer id printString.	self assert: transactions size = 1.	self assert: (trans id = (transactions first atIndex: 1))]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpWritingTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpMappingTest</class-id> <category>tests</category><body package="GlorpTests" selector="helperForMergedOneToOneReversingWriteOrder:">helperForMergedOneToOneReversingWriteOrder: aBoolean 	| account accountTable row |	account := GlorpBankExampleSystem new objectNumber: 1 ofClass: GlorpBankAccount.	accountTable := system tableNamed: 'BANK_ACCT'.	aBoolean 		ifTrue: 			[self write: account.			self write: account accountNumber]		ifFalse: 			[self write: account accountNumber.			self write: account].	self assert: (rowMap includesRowForTable: accountTable withKey: account).	self assert: (rowMap includesRowForTable: accountTable				withKey: account accountNumber).	row := self rowFor: account.	self assert: (row at: (accountTable fieldNamed: 'ID')) = account id.	(Array with: row with: (self rowFor: account accountNumber)) do: 			[:each | 			self assert: (each at: (accountTable fieldNamed: 'BANK_CODE')) 						= account accountNumber bankCode.			self assert: (each at: (accountTable fieldNamed: 'BRANCH_NO')) 						= account accountNumber branchNumber.			self assert: (each at: (accountTable fieldNamed: 'ACCT_NO')) 						= account accountNumber accountNumber].	self assert: (rowMap numberOfEntriesForTable: accountTable) = 2</body><body package="GlorpTests" selector="helperForNestedMergedOneToOneReversingWriteOrder:">helperForNestedMergedOneToOneReversingWriteOrder: aBoolean 	| trans transTable moneyTable row fieldNames fieldValues |	trans := GlorpBankExampleSystem new objectNumber: 1				ofClass: GlorpBankTransaction.	transTable := system tableNamed: 'BANK_TRANS'.	moneyTable := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	aBoolean 		ifTrue: 			[self write: trans.			self write: trans amount.			self write: trans serviceCharge.			self write: trans serviceCharge amount]		ifFalse: 			[self write: trans serviceCharge amount.			self write: trans serviceCharge.			self write: trans amount.			self write: trans].	self 		assert: (rowMap rowForTable: transTable withKey: trans) shouldBeWritten.	self 		assert: (rowMap rowForTable: transTable withKey: trans serviceCharge) 				shouldBeWritten not.	self 		assert: (rowMap rowForTable: moneyTable withKey: trans amount) 				shouldBeWritten not.	self 		assert: (rowMap rowForTable: moneyTable withKey: trans serviceCharge amount) 				shouldBeWritten not.	row := self rowFor: trans.	self assert: (row at: (transTable fieldNamed: 'ID')) = trans id.	fieldNames := #('AMT_CURR' 'AMT_AMT' 'SRVC_DESC' 'SRVC_AMT_CURR' 'SRVC_AMT_AMT').	fieldValues := (Array 				with: trans amount currency asString				with: trans amount amount				with: trans serviceCharge description) 					, (Array with: trans serviceCharge amount currency asString							with: trans serviceCharge amount amount).	fieldNames with: fieldValues		do: [:fieldName :value | self assert: (row at: (transTable fieldNamed: fieldName)) = value].	self assert: (rowMap numberOfEntriesForTable: transTable) = 2.	self assert: (rowMap numberOfEntriesForTable: moneyTable) = 2</body><body package="GlorpTests" selector="testManyToMany">testManyToMany	| customer customerTable accountTable linkTable linkRow |	customer := GlorpBankExampleSystem new objectNumber: 1 ofClass: GlorpCustomer.	rowMap := RowMap new.	customerTable := system tableNamed: 'GR_CUSTOMER'.	accountTable := system tableNamed: 'BANK_ACCT'.	linkTable := system tableNamed: 'CUSTOMER_ACCT_LINK'.	self write: customer.	customer accounts do: [:each | 		self write: each].	self assert: (rowMap includesRowForTable: customerTable withKey: customer).	customer accounts do: [:each |		self assert: (rowMap includesRowForTable: accountTable withKey: each).		self assert: (rowMap includesRowForTable: linkTable withKey: (RowMapKey new key1: customer; key2: each))].	customer accounts do: [:each | | rowMapKey |		self assert: ((self rowFor: each) at: (accountTable fieldNamed: 'ID')) = each id.		rowMapKey := RowMapKey new key1: customer; key2: each.		linkRow := rowMap rowForTable: linkTable withKey: rowMapKey.		self assert: (linkRow at: (linkTable fieldNamed: 'ACCT_ID')) = each id.		self assert: (linkRow at: (linkTable fieldNamed: 'CUSTOMER_ID')) = customer id.		].	self assert: ((self rowFor: customer) at: (customerTable fieldNamed: 'ID')) = customer id.	self assert: ((rowMap numberOfEntriesForTable: linkTable) = 2).	self assert: ((rowMap numberOfEntriesForTable: customerTable) = 1).</body><body package="GlorpTests" selector="testMergedOneToOne">testMergedOneToOne	self helperForMergedOneToOneReversingWriteOrder: false</body><body package="GlorpTests" selector="testMergedOneToOneReversingWrites">testMergedOneToOneReversingWrites	self helperForMergedOneToOneReversingWriteOrder: true</body><body package="GlorpTests" selector="testMissingDescriptor">testMissingDescriptor	self assert: (system descriptorFor: nil) isNil.	self assert: (system descriptorFor: UndefinedObject) isNil.	self assert: (system descriptorFor: 3) isNil</body><body package="GlorpTests" selector="testMultipleTableCreation">testMultipleTableCreation		| descriptor table passenger table2 row1 row2 |	descriptor := system descriptorFor: GlorpPassenger.	passenger := GlorpPassenger example1.	rowMap := RowMap new.	table := system existingTableNamed: 'PASSENGER'.	table2 := system existingTableNamed: 'FREQUENT_FLYER'.	descriptor createRowsFor: passenger in: rowMap.	self assert: (rowMap includesRowForTable: table withKey: passenger).	self assert: (rowMap includesRowForTable: table2 withKey: passenger).	row1 := rowMap rowForTable: table withKey: passenger.	self assert: (row1 at: (table fieldNamed: 'ID'))			= passenger id.	self assert: (row1 at: (table fieldNamed: 'NAME'))			= passenger name.	row2 := rowMap rowForTable: table2 withKey: passenger.	self assert: (row2 at: (table2 fieldNamed: 'ID'))			= passenger id.	self assert: (row2 at: (table2 fieldNamed: 'POINTS')) = passenger frequentFlyerPoints.	self assert: rowMap numberOfEntries = 3</body><body package="GlorpTests" selector="testMultipleTableCreationWithOneMissing">testMultipleTableCreationWithOneMissing		| descriptor table passenger table2 row1 |	descriptor := system descriptorFor: GlorpPassenger.	passenger := GlorpPassenger example1.	passenger frequentFlyerPoints: nil.	passenger airline: nil.	rowMap := RowMap new.	table := system existingTableNamed: 'PASSENGER'.	table2 := system existingTableNamed: 'FREQUENT_FLYER'.	descriptor createRowsFor: passenger in: rowMap.	self assert: (rowMap includesRowForTable: table withKey: passenger).	self deny: (rowMap includesRowForTable: table2 withKey: passenger).	row1 := rowMap rowForTable: table withKey: passenger.	self assert: (row1 at: (table fieldNamed: 'ID'))			= passenger id.	self assert: (row1 at: (table fieldNamed: 'NAME'))			= passenger name.	self assert: rowMap numberOfEntries = 1.</body><body package="GlorpTests" selector="testNestedMergedOneToOne">testNestedMergedOneToOne	self helperForNestedMergedOneToOneReversingWriteOrder: false</body><body package="GlorpTests" selector="testNestedMergedOneToOneReversingWriteOrder">testNestedMergedOneToOneReversingWriteOrder	self helperForNestedMergedOneToOneReversingWriteOrder: true.</body><body package="GlorpTests" selector="testNilOneToOne">testNilOneToOne		| person  personTable addressTable |	person := GlorpPerson example1.	person address: nil.	self write: person.	self write: person address.	personTable := system existingTableNamed: 'PERSON'.	addressTable := system existingTableNamed: 'GR_ADDRESS'.	self assert: (rowMap includesRowForTable: personTable withKey: person).	self deny: (rowMap includesRowForTable: addressTable withKey: person address).	self assert: rowMap numberOfEntries = 1.</body><body package="GlorpTests" selector="testOneToMany">testOneToMany	| customer customerTable transactionTable |	customer := GlorpCustomer example1.	rowMap := RowMap new.	customerTable := system tableNamed: 'GR_CUSTOMER'.	transactionTable := system tableNamed: 'BANK_TRANS'.	self write: customer.	customer transactions do: [:each |		self write: each].	self assert: (rowMap includesRowForTable: customerTable withKey: customer).	customer transactions do: [:each |		self assert: (rowMap includesRowForTable: transactionTable withKey: each)].	customer transactions do: [:each |		self assert: ((self rowFor: each) at: (transactionTable fieldNamed: 'OWNER_ID')) = customer id].	self assert: ((self rowFor: customer) at: (customerTable fieldNamed: 'ID')) = customer id.</body><body package="GlorpTests" selector="testOneToOne">testOneToOne		| person  personTable addressTable |	person := GlorpPerson example1.	self write: person.	self write: person address.	personTable := system existingTableNamed: 'PERSON'.	addressTable := system existingTableNamed: 'GR_ADDRESS'.	self assert: (rowMap includesRowForTable: personTable withKey: person).	self assert: (rowMap includesRowForTable: addressTable withKey: person address).	self assert: ((self rowFor: person address) at: (addressTable fieldNamed: 'ID')) = person address id.	self assert: ((self rowFor: person) at: (personTable fieldNamed: 'ADDRESS_ID')) = person address id.	self assert: rowMap numberOfEntries = 2.</body><body package="GlorpTests" selector="testOneToOneWithProxy">testOneToOneWithProxy	| person  personTable addressTable proxy stub |	person := GlorpPerson example1.	proxy := Proxy new.	proxy session: GlorpSession new.	stub := GlorpQueryStub returningOneOf: GlorpAddress where: [:address | address id = 1].	stub result: person address.	proxy query: stub.	person address: proxy.	self deny: person address isInstantiated.	self write: person.	personTable := system existingTableNamed: 'PERSON'.	addressTable := system existingTableNamed: 'GR_ADDRESS'.	self assert: (rowMap includesRowForTable: personTable withKey: person).	self deny: (rowMap includesRowForTable: addressTable withKey: person address).	self deny: ((self rowFor: person) hasValueFor: (personTable fieldNamed: 'ADDRESS_ID')).	self assert: rowMap numberOfEntries = 1.</body><body package="GlorpTests" selector="testRowCreation">testRowCreation	| descriptor person row table  |	descriptor := system descriptorFor: GlorpPerson.	person := GlorpPerson example1.	rowMap := RowMap new.	table := system existingTableNamed: 'PERSON'.	descriptor createRowsFor: person in: rowMap.	self assert: (rowMap includesRowForTable: table withKey: person).	row := rowMap rowForTable: table withKey: person.	self assert: (row at: (table fieldNamed: 'ID')) = person id.	self assert: (row at: (table fieldNamed: 'NAME')) = person name.	self assert: rowMap numberOfEntries = 2.</body></methods><methods><class-id>Glorp.GlorpMappingTest</class-id> <category>support</category><body package="GlorpTests" selector="rowFor:">rowFor: anObject	| descriptor |	descriptor := system descriptorFor: anObject.	descriptor isNil ifTrue: [^nil].	^rowMap rowForTable: descriptor table withKey: anObject.</body><body package="GlorpTests" selector="setUp">setUp	super setUp.	rowMap := RowMap new.</body><body package="GlorpTests" selector="write:">write: anObject	| descriptor |	descriptor := system descriptorFor: anObject. 	descriptor isNil ifTrue: [^self].	descriptor createRowsFor: anObject in: rowMap.</body></methods><methods><class-id>Glorp.GlorpRowDifferencingTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="computeDifference">computeDifference	currentObjectRowMap := self generateRowMapFor: currentObject.	correspondenceMap := self correspond: currentObject to: mementoObject.	mementoObjectRowMap := self generateMementoRowMapFor: mementoObject withCorrespondenceMap: correspondenceMap.	differenceMap := currentObjectRowMap differenceFrom: mementoObjectRowMap.</body><body package="GlorpDBTests" selector="testDifferenceFromAnotherObject">testDifferenceFromAnotherObject	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example2.	self computeDifference.	self assert: differenceMap numberOfEntries = 2.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1</body><body package="GlorpDBTests" selector="testDifferenceFromSameObjectWithAddedComponent">testDifferenceFromSameObjectWithAddedComponent"	Commenting these out because I think the setup is just wrong.currentObject := Person example1.	mementoObject := Person example1WithNoAddress.	self computeDifference.	self assert: differenceMap numberOfEntries = 2.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1"</body><body package="GlorpDBTests" selector="testDifferenceFromSameObjectWithChangedAttribute">testDifferenceFromSameObjectWithChangedAttribute	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example1WithDifferentName.	self computeDifference.	self assert: differenceMap numberOfEntries = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1</body><body package="GlorpDBTests" selector="testDifferenceFromSameObjectWithChangedComponent">testDifferenceFromSameObjectWithChangedComponent	"Commenting these out because I think the setup is just wrong"	"currentObject := Person example1.	mementoObject := Person example1WithDifferentAddress.	currentObjectRowMap := self generateRowMapFor: currentObject."	"Before changes occur, all original objects are registered with the unit of work.  		To mimic that, the original person's address needs to be added to current (after changes) ""	self addRowsFor: mementoObject address to: currentObjectRowMap.	correspondenceMap := self correspond: currentObject to: mementoObject.	correspondenceMap at: mementoObject address put: mementoObject address.	correspondenceMap removeKey: currentObject address.	mementoObjectRowMap := self generateMementoRowMapFor: mementoObject withCorrespondenceMap: correspondenceMap.	differenceMap := currentObjectRowMap differenceFrom: mementoObjectRowMap.	self assert: differenceMap numberOfEntries = 2.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1"</body><body package="GlorpDBTests" selector="testDifferenceFromSameObjectWithChangedComponentAttribute">testDifferenceFromSameObjectWithChangedComponentAttribute	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example1WithChangedAddress.	self computeDifference.	self assert: differenceMap numberOfEntries = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1</body><body package="GlorpDBTests" selector="testDifferenceFromSameObjectWithDeletedComponent">testDifferenceFromSameObjectWithDeletedComponent	"Commenting these out because I think the setup is just wrong""	currentObject := Person example1WithNoAddress.	mementoObject := Person example1.	self computeDifference.	self assert: differenceMap numberOfEntries = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1"</body><body package="GlorpDBTests" selector="testEquality">testEquality	| addressRow1 addressRow2 |	addressRow1 := session system exampleAddressRow.	addressRow2 := session system exampleAddressRowWithDifferentStreet.	self assert: (addressRow1 equals: addressRow1).	self assert: (addressRow1 equals: addressRow2) not.</body><body package="GlorpDBTests" selector="testNoDifference2">testNoDifference2	| |	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example1.	self computeDifference.	self assert: differenceMap numberOfEntries = 0.</body></methods><methods><class-id>Glorp.GlorpRowDifferencingTest</class-id> <category>support</category><body package="GlorpDBTests" selector="addRowsFor:to:">addRowsFor: object to: rowMap 	| descriptor |	descriptor := system descriptorFor: object class.	descriptor createRowsFor: object in: rowMap.</body><body package="GlorpDBTests" selector="correspond:to:">correspond: person1 to: person2 	| correspondanceMap |	correspondanceMap := IdentityDictionary new.	correspondanceMap at: person1 put: person2.	person1 address notNil ifTrue: 		[correspondanceMap at: person1 address put: person2 address.		"Now fix it up so this actually looks like a real memento"		person2 address: person1 address].	^correspondanceMap</body><body package="GlorpDBTests" selector="generateMementoRowMapFor:withCorrespondenceMap:">generateMementoRowMapFor: person withCorrespondenceMap: aDictionary	| rowMap |	rowMap := RowMapForMementos withCorrespondenceMap: aDictionary.	self addRowsFor: person to: rowMap.	(person address notNil and: [(aDictionary at: person address ifAbsent: [nil]) notNil]) ifTrue: [self addRowsFor: (aDictionary at: person address) to: rowMap].	^rowMap</body><body package="GlorpDBTests" selector="generateRowMapFor:">generateRowMapFor: person 	| rowMap |	rowMap := RowMap new.	self addRowsFor: person to: rowMap.	person address notNil ifTrue: [self addRowsFor: person address to: rowMap].	^rowMap</body><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := session system.	session beginUnitOfWork.</body></methods><methods><class-id>Glorp.GlorpInsertUpdateTest</class-id> <category>support</category><body package="GlorpDBTests" selector="rowFor:">rowFor: anObject	| rowMap rows |	rowMap := RowMap new.	session createRowsFor: anObject in: rowMap.	rows := rowMap rowsForKey: anObject.	self assert: rows size = 1.	^rows first.</body><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.</body></methods><methods><class-id>Glorp.GlorpInsertUpdateTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testFunctionalInsertUpdateForInsert">testFunctionalInsertUpdateForInsert	| testObject |	[session beginTransaction.	session beginUnitOfWork.	testObject := GlorpCustomer example1.	testObject id: 876.	session register: testObject.	session commitUnitOfWork.	self assert: (testObject seenPreWrite = true).	self assert: (testObject seenPostWrite = true).	session beginUnitOfWork.	session register: testObject.	testObject name: 'Change of name'.	session commitUnitOfWork]		ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testRowOwnership">testRowOwnership	| aCustomer rowMap |	aCustomer := GlorpCustomer new.	rowMap := RowMap new.	(session descriptorFor: GlorpCustomer) createRowsFor: aCustomer in: rowMap.	rowMap rowsDo: [:each | 		self assert: each owner = aCustomer].</body><body package="GlorpDBTests" selector="testShouldInsertForInsert">testShouldInsertForInsert	| testObject row |	testObject := GlorpCustomer example1.	testObject id: 876.	row :=self rowFor: testObject.	self assert: (session shouldInsert: row).</body><body package="GlorpDBTests" selector="testShouldInsertForUpdate">testShouldInsertForUpdate	| testObject row |	session beginUnitOfWork.	testObject := GlorpCustomer example1.	testObject id: 876.	session cacheAt: 876 put: testObject.	row :=self rowFor: testObject.	self deny: (session shouldInsert: row).</body></methods><methods><class-id>Glorp.GlorpInsertUpdateTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpDateTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform date</body></methods><methods><class-id>Glorp.GlorpDateTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testDate">testDate	| date |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding date test for VisualAge'. ^self].	date := Date today.	stType := Date.	self helpTestValue: date.	self helpTestValue: nil.</body><body package="GlorpDBTypeTests" selector="testDateCast">testDateCast	"SQLite does not have time-related types:  they are all mapped to strings.  I have not debugged why this test fails yet but assume it is completely unrealistic to expect a string to be cast to a timestamp."	| date model |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding date test for VisualAge'. ^self].	date := Date today.	session transact: [session register: (GlorpTypeTestsModelClass new test: date)].	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform date) = date].	self deny: model isNil		description: 'This test will fail on SQLite which has no DB Date type;  see test comment'.	self assert: model test = date.	model := 	model := session platform isDB2Platform		ifTrue:			[session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test timestamp: (each test time0)) = date]]		ifFalse:			[session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform timestamp) = date]].	self deny: model isNil.	self assert: model test = date.	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | each test asDate = date].	self deny: model isNil.	self assert: model test = date.</body></methods><methods><class-id>Glorp.GlorpSessionResource</class-id> <category>accessing</category><body package="GlorpDBTests" selector="newSession">newSession	self setUp.	^self session.</body><body package="GlorpDBTests" selector="session">session	^session.</body></methods><methods><class-id>Glorp.GlorpSessionResource</class-id> <category>setup</category><body package="GlorpDBTests" selector="glorpTestsSystem">glorpTestsSystem	"We want to prep the GlorpDemoTablePopulatorResource but subclasses using different systems may not;  put it here where it will be overridden."	GlorpDemoTablePopulatorResource current.	^GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database</body><body package="GlorpDBTests" selector="setAccessor">setAccessor		session accessor: GlorpDatabaseLoginResource current accessor.</body><body package="GlorpDBTests" selector="setUp">setUp		super setUp.	session := self glorpTestsSystem		sessionForLogin: GlorpDatabaseLoginResource current login.	self setAccessor.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.		session logout.</body></methods><methods><class-id>Glorp.GlorpSessionResource class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpTimeTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform time</body></methods><methods><class-id>Glorp.GlorpTimeTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testTime">testTime	self helpTestValue: nil.	self		helpTestValue: Time now		compareWith:			[:read :original | 			(read hours = original hours and: [read minutes = original minutes])				and: [read seconds truncated = original seconds truncated]].</body></methods><methods><class-id>Glorp.GlorpOwner</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id.</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject.</body><body package="GlorpTestModels" selector="slave">slave	^slave.</body><body package="GlorpTestModels" selector="slave:">slave: anObject	slave := anObject.</body><body package="GlorpTestModels" selector="slaves">slaves	^slaves.</body><body package="GlorpTestModels" selector="slaves:">slaves: anObject	slaves := anObject.</body></methods><methods><class-id>Glorp.GlorpClobTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="longString">longString	"Make a significant sized stringlob. 64k+ a bit should do"	| stream |	stream := WriteStream on: (String new: 10000).	(((2 raisedTo: 16) + 100.0) / 255.0) ceiling timesRepeat: [		stream nextPutAll: self string255].	^stream contents.</body><body package="GlorpDBTypeTests" selector="string255">string255	^'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu'.</body><body package="GlorpDBTypeTests" selector="testClob">testClob	self helpTestValue: nil.	self helpTestValue: 'abcdef'.</body><body package="GlorpDBTypeTests" selector="testLargeClob">testLargeClob	"The long test here not only fails, it messes up the driver so that other tests fail"	(session platform class == AccessPlatform and: [session useBinding not])		ifTrue: [^self].	self helpTestValue: self longString.</body></methods><methods><class-id>Glorp.GlorpClobTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform clob.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionDBTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testParallelStreams">testParallelStreams	| query person query2 stream1 stream2 address person2 address2 |	session platform supportsMultipleOpenCursors ifFalse: [^self].	query := Query returningManyOf: GlorpPerson.	query orderBy: [:each | each id].	query collectionType: GlorpCursoredStream.	query2 := Query returningManyOf: GlorpAddress.	query2 orderBy: [:each | each id].	query2 collectionType: GlorpCursoredStream.	stream1 := session execute: query.	self assert: session privateGetCache numberOfElements = 0.	stream2 := session execute: query2.	person := stream1 next.	self assert: session privateGetCache numberOfElements = 1.	self assert: person id = 86.	address := stream2 next.	self assert: address id = 1.	self assert: address street = 'Alpha'.	self assert: session privateGetCache numberOfElements = 2.	person2 := stream1 next.	address2 := stream2 next.	self assert: person2 class == GlorpPerson.	self assert: address2 class == GlorpAddress.	self assert: address2 street = 'Beta'."SQLite allows multiple processes to have the database file open at once, and multiple processes can read the database at once.  Thus we let that platform return true to #supportsMultipleOpenCursors.  When a process wants to write, it must lock the entire database file for the duration of its update (normally a few milliseconds, during which other processes wait on the writer to finish, then continue).  However this database locking is therefore dependent on the OS file-system and can show issues.  This test, after passing all its assertions, has been seen to fail in tearDown's rollback of the transaction due to 'database is locked'.  The presumption is that both cursors rollback and so appear like competing writes even though neither is really.   Releasing the cursors ends contention and lets the rollback succeed."	session platform class == SQLite3Platform ifTrue:		[stream1 release. stream1 := nil.		stream2 release. stream2 := nil].</body><body package="GlorpDBTests" selector="testReadAsStream">testReadAsStream	| query stream person restOfPeople |	query := Query returningManyOf: GlorpPerson.	query orderBy: [:each | each id].	query collectionType: GlorpCursoredStream.	stream := session execute: query.	self assert: session privateGetCache numberOfElements = 0.	person := stream next.	self assert: session privateGetCache numberOfElements = 1.	self assert: person id = 86.	restOfPeople := stream upToEnd.	self assert: restOfPeople size = 2.	self assert: session privateGetCache numberOfElements = 3.</body><body package="GlorpDBTests" selector="testReadEmptyStream">testReadEmptyStream	| query stream person |	query := Query returningManyOf: GlorpPerson where: [:each | each id = 999].	query collectionType: GlorpCursoredStream.	stream := session execute: query.	self assert: session privateGetCache numberOfElements = 0.	person := stream next.	self assert: session privateGetCache numberOfElements = 0.	self assert: person isNil.	self assert: stream atEnd.</body><body package="GlorpDBTests" selector="testReadLiteralEmptyStream">testReadLiteralEmptyStream	| query stream person |	query := Query returningManyOf: GlorpPerson where: false.	query collectionType: GlorpCursoredStream.	stream := session execute: query.	self assert: session privateGetCache numberOfElements = 0.	person := stream next.	self assert: session privateGetCache numberOfElements = 0.	self assert: person isNil.	self assert: stream atEnd.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	session := GlorpSessionResource current newSession.	session beginTransaction.	self writePersonRows.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests" selector="writePersonRows">writePersonRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.</body></methods><methods><class-id>Glorp.GlorpBook</class-id> <category>accessing</category><body package="GlorpTestModels" selector="author">author	^author</body><body package="GlorpTestModels" selector="author:">author: aString	author := aString</body><body package="GlorpTestModels" selector="copiesInStock">copiesInStock	^copiesInStock</body><body package="GlorpTestModels" selector="copiesInStock:">copiesInStock: anInteger	copiesInStock := anInteger</body><body package="GlorpTestModels" selector="description">description	^description</body><body package="GlorpTestModels" selector="description:">description: aString	description := aString</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpTestModels" selector="title">title	^title</body><body package="GlorpTestModels" selector="title:">title: aString	title := aString.</body><body package="GlorpTestModels" selector="version">version	^version</body><body package="GlorpTestModels" selector="version:">version: anInteger	version := anInteger</body></methods><methods><class-id>Glorp.GlorpErrorTest</class-id> <category>tests</category><body package="GlorpTests" selector="testMessageTextVW">testMessageTextVW	| innerException text outerException error |	Dialect isVisualWorks ifFalse: [^self].	text := 'Something is horribly wrong'.	error := (Dialect smalltalkAt: #ExternalDatabaseError) new dbmsErrorString: text.	outerException := GlorpDatabaseReadError new databaseError: (Array with: error).	[outerException signal] on: GlorpError do: [:ex |			self assert: ex messageText = text].		innerException := (Dialect smalltalkAt: #ExternalDatabaseException) new.	innerException parameter: (Array with: error).	[DatabaseAccessor new handleError: innerException for: InsertCommand new ] on: GlorpError do: [:ex |			self assert: ex messageText = text.		ex return: nil].</body></methods><methods><class-id>Glorp.GlorpAddress</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', id printString, ',', street printString, ',' , number printString, ')'.</body></methods><methods><class-id>Glorp.GlorpAddress</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels" selector="number">number	"Private - Answer the value of the receiver's ''number'' instance variable."	^number</body><body package="GlorpTestModels" selector="number:">number: anObject	"Private - Set the value of the receiver's ''number'' instance variable to the argument, anObject."	number := anObject</body><body package="GlorpTestModels" selector="street">street	"Private - Answer the value of the receiver's ''street'' instance variable."	^street</body><body package="GlorpTestModels" selector="street:">street: anObject	"Private - Set the value of the receiver's ''street'' instance variable to the argument, anObject."	street := anObject</body></methods><methods><class-id>Glorp.GlorpAddress</class-id> <category>notification</category><body package="GlorpTestModels" selector="glorpNoticeOfExpiryIn:">glorpNoticeOfExpiryIn: aSession</body></methods><methods><class-id>Glorp.GlorpAddress class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		id: 1;		street: 'West 47th Ave';		number: '2042'.</body><body package="GlorpTestModels" selector="example1WithChangedAddress">example1WithChangedAddress	^self new		id: 1;		street: 'Garden of the Gods';		number: '99999'.</body><body package="GlorpTestModels" selector="example2">example2	^self new		id: 2;		street: 'Nowhere';		number: '1000'.</body></methods><methods><class-id>Glorp.GlorpAddress class</class-id> <category>glorp setup</category><body package="GlorpTestModels" selector="glorpSetupClassModel:forSystem:">glorpSetupClassModel: aClassModel forSystem: aDescriptorSystem 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #street.	aClassModel newAttributeNamed: #number.</body><body package="GlorpTestModels" selector="glorpSetupDescriptor:forSystem:">glorpSetupDescriptor: aDescriptor forSystem: aDescriptorSystem 	| table |	table := aDescriptorSystem tableNamed: 'GR_ADDRESS'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID'));		addMapping: (DirectMapping from: #street to: (table fieldNamed: 'STREET'));		addMapping: (DirectMapping from: #number to: (table fieldNamed: 'HOUSE_NUM'))</body></methods><methods><class-id>Glorp.GlorpTracingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testAddDuplicateTracings">testAddDuplicateTracings	| all |	tracing addExpression: (tracing base get: #foo).	tracing addExpression: (tracing base get: #foo).	all := tracing allTracings.	self assert: all size = 2.	self assert: all first == tracing base.</body><body package="GlorpTests" selector="testAddRecursiveTracings">testAddRecursiveTracings	| all |	tracing addExpression: (tracing base get: #foo).	tracing addExpression: ((tracing base get: #foo) get: #bar).	all := tracing allTracings.	self assert: all size = 3.	self assert: all first == tracing base.	self assert: all last base == (all at: 2).</body><body package="GlorpTests" selector="testAddTracing">testAddTracing	| all |	tracing addExpression: (tracing base get: #foo).	all := tracing allTracings.	self assert: all size = 2.	self assert: all first == tracing base.	self assert: all last == (tracing base get: #foo).</body><body package="GlorpTests" selector="testAddTwoTracings">testAddTwoTracings	tracing addExpression: (tracing base get: #foo).	tracing addExpression: (tracing base get: #bar).	self assert: tracing allTracings size = 3.	self assert: tracing allTracings first == tracing base.</body></methods><methods><class-id>Glorp.GlorpTracingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	tracing := Tracing new.	tracing setup.</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="checkEmailAddresses:">checkEmailAddresses: emailAddresses	| sorted numberOfAddresses |	numberOfAddresses := (emailId1 isNil ifTrue: [0] ifFalse: [1]) + (emailId2 isNil ifTrue: [0] ifFalse: [1]) + (emailId3 isNil ifTrue: [0] ifFalse: [1]).	self assert: emailAddresses size = numberOfAddresses.	sorted := emailAddresses asSortedCollection: [:a :b | a id &lt;= b id].	emailId1 isNil ifFalse: [self assert: sorted first id = emailId1].	emailId2 isNil ifFalse: [self assert: (sorted at: 2) id = emailId2].	emailId3 isNil ifFalse: [self assert: sorted last id = emailId3].	self assert: (emailAddresses collect: [:each | each id]) asSet size = emailAddresses size.</body><body package="GlorpDBTests" selector="checkNumberOfEmailAddressesInDB:">checkNumberOfEmailAddressesInDB: numberOfAddresses	| databaseAddresses |	databaseAddresses := session accessor executeSQLString: 'SELECT * FROM EMAIL_ADDRESS'.	self assert: databaseAddresses size = numberOfAddresses.</body><body package="GlorpDBTests" selector="inUnitOfWorkDo:initializeWith:">inUnitOfWorkDo: aBlock initializeWith: initBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	initBlock value.	session beginUnitOfWork.	self readPerson.	aBlock value.	session commitUnitOfWork.	session reset.</body><body package="GlorpDBTests" selector="readPerson">readPerson	| results query |	query := Query		returningManyOf: GlorpPerson		where: [:pers | pers id = personId].	results := query executeIn: session.	self assert: results size = 1.	person := results first.</body><body package="GlorpDBTests" selector="tearDown">tearDown	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #emailAddresses) isExclusive: false.	super tearDown.</body><body package="GlorpDBTests" selector="writePersonWithEmailAddresses">writePersonWithEmailAddresses	| addressRow personRow emailAddress1Row emailAddress2Row |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	personRow := session system examplePersonRow1.	personId := personRow atFieldNamed: 'ID'.	session writeRow: personRow.	emailAddress1Row := session system exampleEmailAddressRow1.	emailAddress2Row := session system exampleEmailAddressRow2.	emailId1 := emailAddress1Row at: (emailAddress1Row table fieldNamed: 'ID').	emailId2 := emailAddress2Row at: (emailAddress2Row table fieldNamed: 'ID').	session writeRow: emailAddress1Row.	session writeRow: emailAddress2Row.</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-read</category><body package="GlorpDBTests" selector="testReadActionWithCollection">testReadActionWithCollection	| collection |	self		inTransactionDo:			[collection := OrderedCollection new.			self writePersonWithEmailAddresses.			((session system descriptorFor: GlorpPerson)				mappingForAttributeNamed: #emailAddresses)				proxyAction:					[:owner :object | object do: [:each | collection add: owner -&gt; each]].			person := session readOneOf: GlorpPerson.			person emailAddresses yourSelf.			self assert: collection size = 2.			self assert: collection first = (person -&gt; person emailAddresses first).			self assert: collection last = (person -&gt; person emailAddresses last)].</body><body package="GlorpDBTests" selector="testReadJustTheEmailAddressNotThePersonAndWriteBackWithChanges">testReadJustTheEmailAddressNotThePersonAndWriteBackWithChanges	| addresses addressRows |	"We won't have the person object to set a value for the PERSON_ID field. Ensure that we don't write a null for that field, or otherwise modify things."	self inTransactionDo: [			self writePersonWithEmailAddresses.		session beginUnitOfWork.		addresses := session readManyOf: GlorpEmailAddress.		addresses do: [:each | each host: 'bar.org'].		self assert: ((session privateGetCache cacheForClass: GlorpPerson) at: 3 ifAbsent: [nil]) isNil.		session commitUnitOfWork.		addressRows := session accessor executeSQLString: 'SELECT PERSON_ID, HOST_NAME from EMAIL_ADDRESS'.		self assert: addressRows size = 2.		addressRows do: [:each | 			self assert: (each atIndex: 1) = 3.			self assert: (each atIndex: 2) = 'bar.org'].].</body><body package="GlorpDBTests" selector="testReadJustTheEmailAddressNotThePersonAndWriteBackWithNoChanges">testReadJustTheEmailAddressNotThePersonAndWriteBackWithNoChanges	| addresses addressRows |	"We won't have the person object to set a value for the PERSON_ID field. Ensure that we don't write a null for that field, or otherwise modify things."	self inTransactionDo: [			self writePersonWithEmailAddresses.		session beginUnitOfWork.		addresses := session readManyOf: GlorpEmailAddress.		self assert: ((session privateGetCache cacheForClass: GlorpPerson) at: 3 ifAbsent: [nil]) isNil.		session commitUnitOfWork.		addressRows := session accessor executeSQLString: 'SELECT PERSON_ID from EMAIL_ADDRESS'.		self assert: addressRows size = 2.		addressRows do: [:each | self assert: (each atIndex: 1) = 3].].</body><body package="GlorpDBTests" selector="testReadPersonAndAddEmailAddress">testReadPersonAndAddEmailAddress	| |	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [person emailAddresses add: (GlorpEmailAddress new id: 99876; user: 'postmaster'; host: 'foo.com')]				initializeWith: [self writePersonWithEmailAddresses].			emailId3 := 99876.			self readPerson.			self checkEmailAddresses: person emailAddresses].</body><body package="GlorpDBTests" selector="testReadPersonAndAddEmailAddressProxy">testReadPersonAndAddEmailAddressProxy	| address |	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| query |					query := Query						readOneOf: GlorpEmailAddress						where: [:each | each id = 99876].					query proxyType: Proxy.					address := session execute: query.					address yourself.					person emailAddresses add: address.					self assert: person emailAddresses last class == Proxy]				initializeWith:					[self writePersonWithEmailAddresses.					session						transact:							[(GlorpEmailAddress new)								id: 99876;								user: 'postmaster';								host: 'foo.com'].						session reset].			emailId3 := 99876.			self readPerson.			self checkEmailAddresses: person emailAddresses].</body><body package="GlorpDBTests" selector="testReadPersonAndAddEmailAddressTwice">testReadPersonAndAddEmailAddressTwice	| personRow addressRow |	self		inTransactionDo:			[self				inUnitOfWorkDo:					[person emailAddresses						add:							((GlorpEmailAddress new)								id: 99876;								user: 'postmaster';								host: 'foo.com')]				initializeWith:					[addressRow := session system exampleAddressRow.					session writeRow: addressRow.					personRow := session system examplePersonRow1.					personId := personRow atFieldNamed: 'ID'.					session writeRow: personRow].			self				inUnitOfWorkDo:					[person emailAddresses						add:							((GlorpEmailAddress new)								id: 99991;								user: 'someone';								host: 'foo.com')]				initializeWith: [].			emailId1 := 99876.			emailId2 := 99991.			self readPerson.			self checkEmailAddresses: person emailAddresses].</body><body package="GlorpDBTests" selector="testReadPersonAndDeleteEmailAddress">testReadPersonAndDeleteEmailAddress	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [					session delete: person emailAddresses last. 					person emailAddresses removeLast. ]				initializeWith: [self writePersonWithEmailAddresses].			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 1].</body><body package="GlorpDBTests" selector="testReadPersonAndRemoveEmailAddress">testReadPersonAndRemoveEmailAddress	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [person emailAddresses removeLast]				initializeWith: [self writePersonWithEmailAddresses].			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests" selector="testReadPersonAndReplaceEmailAddressesWithDifferent">testReadPersonAndReplaceEmailAddressesWithDifferent	| |	self		inTransactionDo:			[self 				inUnitOfWorkDo: [					person emailAddresses: (Array with: (GlorpEmailAddress new id: 99876; user: 'postmaster'; host: 'foo.com')) ]				initializeWith: [self writePersonWithEmailAddresses].			emailId1 := 99876.			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 3].</body><body package="GlorpDBTests" selector="testReadPersonAndReplaceEmailAddressesWithRemoval">testReadPersonAndReplaceEmailAddressesWithRemoval	| |	self		inTransactionDo:			[self 				inUnitOfWorkDo: [					person emailAddresses: (Array with: person emailAddresses first) ]				initializeWith: [self writePersonWithEmailAddresses].			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests" selector="testReadPersonAndReplaceInstantiatedEmailAddressesWithEmpty">testReadPersonAndReplaceInstantiatedEmailAddressesWithEmpty	| |	self		inTransactionDo:			[self 				inUnitOfWorkDo: [					person emailAddresses yourSelf. 					person emailAddresses: #(). ]				initializeWith: [self writePersonWithEmailAddresses].			emailId1 := nil.			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests" selector="testReadPersonAndReplaceUninstantiatedEmailAddressesWithEmpty">testReadPersonAndReplaceUninstantiatedEmailAddressesWithEmpty	| |	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [person emailAddresses: #().]				initializeWith: [self writePersonWithEmailAddresses].			emailId1 := nil.			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests" selector="testReadPersonWithEmailAddresses">testReadPersonWithEmailAddresses	| query result emailAddresses |	self		inTransactionDo:			[self writePersonWithEmailAddresses.			query := Query				returningOneOf: GlorpPerson				where: [:eachPerson | eachPerson id = personId].			result := query executeIn: session.			emailAddresses := result emailAddresses getValue.			self checkEmailAddresses: emailAddresses].</body><body package="GlorpDBTests" selector="testReadPersonWithIsEmptySubselectToEmailAddresses">testReadPersonWithIsEmptySubselectToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				readManyOf: GlorpPerson				where:					[:eachPerson | eachPerson emailAddresses isEmpty].			self assert: people size = 1].</body><body package="GlorpDBTests" selector="testReadPersonWithNotEmptySubselectToEmailAddresses">testReadPersonWithNotEmptySubselectToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				readManyOf: GlorpPerson				where:					[:eachPerson | eachPerson emailAddresses notEmpty].			self assert: people size = 2].</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-write</category><body package="GlorpDBTests" selector="testUpdatePersonWithNilEmailAddressesAndExclusiveRelationship">testUpdatePersonWithNilEmailAddressesAndExclusiveRelationship	| newPerson |	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #emailAddresses) beExclusive.	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		session modify: person in: [person emailAddresses: nil].		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests" selector="testWritePersonWithEmailAddresses">testWritePersonWithEmailAddresses	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		newPerson id: 231.		personId := 231.			newPerson emailAddresses: OrderedCollection new.		newPerson emailAddresses add: (GlorpEmailAddress new id: 2; user: 'one'; host: 'blorch.ca').		newPerson emailAddresses add: (GlorpEmailAddress new id: 3; user: 'two'; host: 'blorch.ca').		emailId1 := 2.		emailId2 := 3.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self checkEmailAddresses: person emailAddresses.		self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests" selector="testWritePersonWithNilEmailAddresses">testWritePersonWithNilEmailAddresses	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		newPerson emailAddresses: nil.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests" selector="testWritePersonWithNilEmailAddressesAndExclusiveRelationship">testWritePersonWithNilEmailAddressesAndExclusiveRelationship	| newPerson |	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #emailAddresses) beExclusive.	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		newPerson emailAddresses: nil.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests" selector="testWritePersonWithNoEmailAddresses">testWritePersonWithNoEmailAddresses	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests" selector="testWritePersonWithNoEmailAddresses2">testWritePersonWithNoEmailAddresses2	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		newPerson emailAddresses: OrderedCollection new.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-join</category><body package="GlorpDBTests" selector="setUpSomeExtraPeople">setUpSomeExtraPeople	self		inUnitOfWorkDo:			[| otherPerson |			session register: (GlorpPerson new id: 9924365).			otherPerson := GlorpPerson new id: 12121.			otherPerson				emailAddresses:					(OrderedCollection						with:							((GlorpEmailAddress new)								id: 7;								host: 'asdfasdf')).			session register: otherPerson]		initializeWith: [self writePersonWithEmailAddresses].</body><body package="GlorpDBTests" selector="testReadPersonWithJoinToEmailAddresses">testReadPersonWithJoinToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				readManyOf: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyJoin: [:eachEmail | eachEmail host = 'objectpeople.com']].			self assert: people size = 1].</body><body package="GlorpDBTests" selector="testReadPersonWithNegativeJoinToEmailAddresses">testReadPersonWithNegativeJoinToEmailAddresses	"Read with a negative condition. Note that this excludes the person with no e-mail addresses, as we're not doing an outer join"	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				readManyOf: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyJoin: [:eachEmail | eachEmail host ~= 'objectpeople.com']].			self assert: people size = 2].</body><body package="GlorpDBTests" selector="testReadPersonWithNegativeSubselectToEmailAddresses">testReadPersonWithNegativeSubselectToEmailAddresses	"Read with a negative condition. Note that this excludes the person with no e-mail addresses, as we're not doing an outer join"	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				readManyOf: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyExists: [:eachEmail | eachEmail host ~= 'objectpeople.com']].			self assert: people size = 2].</body><body package="GlorpDBTests" selector="testReadPersonWithSubselectToEmailAddresses">testReadPersonWithSubselectToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				readManyOf: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyExists: [:eachEmail | eachEmail host = 'objectpeople.com']].			self assert: people size = 1].</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testReadPersonWithExistsWithAlsoFetch">testReadPersonWithExistsWithAlsoFetch	| people query |	self inTransactionDo: 			[self setUpSomeExtraPeople.			query := ReadQuery readManyOf: GlorpPerson						where: 							[:eachPerson | 							eachPerson emailAddresses 								anySatisfyExists: [:eachEmail | eachEmail host = 'objectpeople.com']].			query alsoFetch: [:e | e address].			people := query executeIn: session.			self assert: people size = 1]</body><body package="GlorpDBTests" selector="testReadPersonWithJoinWithAlsoFetch">testReadPersonWithJoinWithAlsoFetch	| people query |	self inTransactionDo: 			[self setUpSomeExtraPeople.			query := ReadQuery readManyOf: GlorpPerson						where: 							[:eachPerson | 							eachPerson emailAddresses anySatisfyJoin: 									[:eachEmail | 									eachEmail host = 'objectpeople.com' | (eachEmail host = 'cs.uiuc.edu')]].			query alsoFetch: [:e | e address].			people := query executeIn: session.			self assert: people size = 1]</body></methods><methods><class-id>Glorp.GlorpTimestampTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform timestamp</body></methods><methods><class-id>Glorp.GlorpTimestampTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="compareTime:to:">compareTime: read to: original	"GNU Smalltalk seems to be quite lone in following the ANSI standard..."	| zeroDuration max min |	Dialect isGNU		ifTrue: [			zeroDuration := (Smalltalk at: #Duration) zero.			^(read offset: zeroDuration) = (original offset: zeroDuration)].	"MS SQL Server fails randomly because it has a resolution of 3 ms only."	session platform class = SQLServerPlatform ifTrue: [		max := original addMilliseconds: 3.		min := original addMilliseconds: -3.		^read between: min and: max].	"Otherwise"	^session platform supportsMillisecondsInTimes 		ifTrue: [read = original]		ifFalse: [read = original or: [read = (original addMilliseconds: (-1 * original milliseconds))]].</body><body package="GlorpDBTypeTests" selector="testTimeStamp">testTimeStamp	"This has to be UTC because postgres has time zones and will try and compensate"	| time |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding timestamp test for VisualAge'. ^self].	time := Dialect timestampNow.	session platform supportsMillisecondsInTimes		ifFalse: [time millisecond: 0].	self helpTestValue: nil.	self		helpTestValue: time		compareWith:			[:read :original | 			"MS SQL Server fails randomly because it has a resolution of 3 ms only."			"GNU Smalltalk seems to be quite lone in following the ANSI standard..."			self compareTime: read to: original].</body><body package="GlorpDBTypeTests" selector="testTimeStampBetweenAnd">testTimeStampBetweenAnd	| record time newRecord |	session system: (GlorpDemoDescriptorSystem forPlatform: session platform).	self		inTransactionDo:			[record := (GlorpRecordWithUpdateTime new)				id: 12;				name: 'thing'.			session modify: record in: [].			session reset.			record := session readOneOf: GlorpRecordWithUpdateTime.			time := record updateTime.			session reset.			newRecord := session				readOneOf: GlorpRecordWithUpdateTime				where:					[:each | 					each updateTime						between: (time subtractSeconds: 1)						and: (time addSeconds: 1)].			self assert: newRecord id = record id.].</body><body package="GlorpDBTypeTests" selector="testTimeStampCast">testTimeStampCast	"SQLite does not have time-related types:  they are all mapped to strings.  I have not debugged why this test fails yet but assume it is completely unrealistic to expect a string to be cast to a timestamp."	| timestamp model |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding testTimestampCast for VisualAge'. ^self].	timestamp := Dialect timestampNow.	timestamp millisecond: 0.	session transact: [session register: (GlorpTypeTestsModelClass new test: timestamp)].	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform timestamp) = timestamp].	self deny: model isNil		description: 'This test will fail on SQLite which has no DB Timestamp type;  see test comment'.	self assert: (self compareTime: model test to: timestamp).	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform date) = timestamp].	self deny: model isNil.	self assert: (self compareTime: model test to: timestamp).	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | each test asTimestamp = timestamp].	self deny: model isNil.	self assert: (self compareTime: model test to: timestamp).</body><body package="GlorpDBTypeTests" selector="testTimeStampCompare">testTimeStampCompare	| record time newRecord |	session system: (GlorpDemoDescriptorSystem forPlatform: session platform).	self		inTransactionDo:			[record := (GlorpRecordWithUpdateTime new)				id: 12;				name: 'thing'.			session modify: record in: [].			session reset.			record := session readOneOf: GlorpRecordWithUpdateTime.			time := record updateTime.			session reset.			newRecord := session				readOneOf: GlorpRecordWithUpdateTime				where:					[:each | 						(each updateTime &gt; (time subtractSeconds: 1))						&amp; (each updateTime &lt; (time addSeconds: 1))].			self assert: newRecord id = record id].</body></methods><methods><class-id>Glorp.GlorpDocumentDescriptorSystem</class-id> <category>glorp</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('document' 'attachment' 'attachmentbytes')</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: GlorpDocument;		add: GlorpAttachment;		add: GlorpAttachmentBytes;		yourself</body><body package="GlorpTestModels" selector="tableForATTACHMENT:">tableForATTACHMENT: aTable 	| d |	d := (aTable createFieldNamed: 'document_id' type: platform int4) 				bePrimaryKey.	(aTable createFieldNamed: 'indexInDocument' type: platform int) bePrimaryKey.	aTable createFieldNamed: 'mimetype' type: (platform varchar: 32).	"FK Constraints"	aTable addForeignKeyFrom: d		to: ((self tableNamed: 'document') fieldNamed: 'id')</body><body package="GlorpTestModels" selector="tableForATTACHMENTBYTES:">tableForATTACHMENTBYTES: aTable 	| d i |	d := (aTable createFieldNamed: 'attachment_document_id'				type: platform int4) bePrimaryKey.	i := (aTable createFieldNamed: 'attachment_index' type: platform int) 				bePrimaryKey.	aTable createFieldNamed: 'content' type: platform text.	"FK"	aTable 		addForeignKeyFrom: d		to: ((self tableNamed: 'attachment') fieldNamed: 'document_id')		from: i		to: ((self tableNamed: 'attachment') fieldNamed: 'indexInDocument')</body><body package="GlorpTestModels" selector="tableForDOCUMENT:">tableForDOCUMENT: aTable 	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey.	aTable createFieldNamed: 'whatever' type: (platform integer).</body></methods><methods><class-id>Glorp.GlorpDocumentDescriptorSystem class</class-id> <category>none</category><body package="GlorpTestModels" selector="doTest">doTest	"   AADescriptor doTest    "	| glorpSession doc |	glorpSession := self connectToDatabase.	"Try #1 -- this works as advertized"	doc := self readDocumentAndAttachmentsFrom: glorpSession.	"Something changed? Should not."	glorpSession modify: doc in: [].	doc := nil.	glorpSession accessor logout.	glorpSession := self connectToDatabase.	"Try #2 -- this makes Glorp believe the attachment was changed"	doc := self readDocumentAndAttachmentsFrom: glorpSession.	doc attachments do: 			[:ea | 			"Force attachmentBytes to be instanciated"			Transcript nextPutAll: '----&gt; ', ea attachmentBytes content; cr].	"Something changed? Should not, but does."	"Glorp now tries to update the attachment AND save the attachmentBytes again. Boom"	glorpSession modify: doc in: [].	glorpSession accessor logout</body><body package="GlorpTestModels" selector="readDocumentAndAttachmentsFrom:">readDocumentAndAttachmentsFrom: glorpSession 	| doc |	doc := glorpSession readOneOf: GlorpDocument.	Transcript		cr;		nextPutAll: '---&gt; Read document ' , doc id printString;		cr.	doc attachments do: 			[:att | 			Transcript				cr;				nextPutAll: '------&gt; Attachment ' , att index printString , ' ' 							, att mimeType;				cr].	^doc</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels" selector="exampleCreditStatus1">exampleCreditStatus1	| example |	example := GlorpVideoCreditStatus new.		example balanceOwing: 12.00.	example dateOwing: (Date today addDays: -1).	example comments: 'One'.	^example.</body><body package="GlorpTestModels" selector="exampleCreditStatus2">exampleCreditStatus2	| example |	example := GlorpVideoCreditStatus new.		example balanceOwing: 22.00.	example dateOwing: (Date today addDays: -1).	example comments: 'Two'.	^example.</body><body package="GlorpTestModels" selector="exampleCreditStatus3">exampleCreditStatus3	| example |	example := GlorpVideoCreditStatus new.		example balanceOwing: 33.00.	example dateOwing: (Date today addDays: -1).	example comments: 'Three'.	^example.</body><body package="GlorpTestModels" selector="exampleCustomer1">exampleCustomer1	"A customer with only online purchases"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Adrian'.	customer dateOfBirth: (Date today subtractDays: (10 * 365)).	customer addOnlinePurchase: self exampleOnlinePurchase1.	customer addOnlinePurchase: self exampleOnlinePurchase2.	^customer.</body><body package="GlorpTestModels" selector="exampleCustomer2">exampleCustomer2	"A customer with only inStore purchases"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Bob'.	customer dateOfBirth: (Date today subtractDays: (20 * 365)).	customer addInStorePurchase: self exampleInStorePurchase1.	^customer.</body><body package="GlorpTestModels" selector="exampleCustomer3">exampleCustomer3	"A customer with only rentals"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Carol'.	customer dateOfBirth: (Date today subtractDays: (30 * 365)).	customer addRental: self exampleInStoreRental1.	^customer.</body><body package="GlorpTestModels" selector="exampleCustomer4">exampleCustomer4	"A customer with only credit"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'David'.	customer dateOfBirth: (Date today subtractDays: (40 * 365)).	customer creditStatus: self exampleCreditStatus1.	^customer.</body><body package="GlorpTestModels" selector="exampleCustomer5">exampleCustomer5	"A customer with purchases and rentals"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Eleanor'.	customer dateOfBirth: (Date today subtractDays: 50 * 365).	customer addInStorePurchase: self exampleInStorePurchase2.	customer addInStorePurchase: self exampleInStorePurchase3.	customer addRental: self exampleInStoreRental2.	^customer.</body><body package="GlorpTestModels" selector="exampleCustomer6">exampleCustomer6	"A customer with purchases and credit"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Francois'.	customer dateOfBirth: (Date today subtractDays: 60 * 365).	customer addInStorePurchase: self exampleInStorePurchase4.	customer addInStorePurchase: self exampleInStorePurchase5.	customer creditStatus: self exampleCreditStatus2.	^customer.</body><body package="GlorpTestModels" selector="exampleCustomer7">exampleCustomer7	"A customer with everything"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'George'.	customer dateOfBirth: (Date today subtractDays: 70 * 365).	customer addInStorePurchase: self exampleInStorePurchase6.	customer addOnlinePurchase: self exampleOnlinePurchase3.	customer addRental: self exampleInStoreRental3.	customer addRental: self exampleInStoreRental4.	customer creditStatus: self exampleCreditStatus3.	^customer.</body><body package="GlorpTestModels" selector="exampleCustomer8">exampleCustomer8	"A customer with just a single purchase"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Hieronymous'.	customer dateOfBirth: (Date today subtractDays: 80 * 365).	customer addInStorePurchase: self exampleInStorePurchase7.	^customer.</body><body package="GlorpTestModels" selector="exampleInStorePurchase1">exampleInStorePurchase1	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 101.	purchase title: 'An American in Paris'.	purchase price: 1.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels" selector="exampleInStorePurchase2">exampleInStorePurchase2	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 102.	purchase title: 'Brazil'.	purchase price: 2.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels" selector="exampleInStorePurchase3">exampleInStorePurchase3	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 103.	purchase title: 'Cambodia, Swimming To'.	purchase price: 3.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels" selector="exampleInStorePurchase4">exampleInStorePurchase4	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 104.	purchase title: 'Dogma'.	purchase price: 4.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels" selector="exampleInStorePurchase5">exampleInStorePurchase5	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 105.	purchase title: 'ET'.	purchase price: 5.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels" selector="exampleInStorePurchase6">exampleInStorePurchase6	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 106.	purchase title: 'Fargo'.	purchase price: 6.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels" selector="exampleInStorePurchase7">exampleInStorePurchase7	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 107.	purchase title: 'Glengarry GlenRoss'.	purchase price: 7.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels" selector="exampleInStoreRental1">exampleInStoreRental1	| rental |	rental := GlorpVideoRental new.	rental id: 1001.	rental title: 'Amelie'.	rental price: 21.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels" selector="exampleInStoreRental2">exampleInStoreRental2	| rental |	rental := GlorpVideoRental new.	rental id: 1002.	rental title: 'Best in Show'.	rental price: 22.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels" selector="exampleInStoreRental3">exampleInStoreRental3	| rental |	rental := GlorpVideoRental new.	rental id: 1003.	rental title: 'Charlie Brown Christmas'.	rental price: 23.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels" selector="exampleInStoreRental4">exampleInStoreRental4	| rental |	rental := GlorpVideoRental new.	rental id: 1004.	rental title: 'Down By Law'.	rental price: 24.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels" selector="exampleOnlinePurchase1">exampleOnlinePurchase1	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 1.	purchase title: 'All About Eve'.	purchase price: 1.11.	purchase inStore: false.	^purchase.</body><body package="GlorpTestModels" selector="exampleOnlinePurchase2">exampleOnlinePurchase2	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 2.	purchase title: 'Butch Cassidy and the Sundance Kid'.	purchase price: 2.22.	purchase inStore: false.	^purchase.</body><body package="GlorpTestModels" selector="exampleOnlinePurchase3">exampleOnlinePurchase3	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 3.	purchase title: 'Cabaret'.	purchase price: 3.33.	purchase inStore: false.	^purchase.</body><body package="GlorpTestModels" selector="exampleStore1">exampleStore1	"self new exampleStore1"	| example |	example := GlorpVideoStore new.	example name: 'Als Video'.	example id: 1.	example customers: (Array with: self exampleCustomer1 with: self exampleCustomer2 with: self exampleCustomer3 with: self exampleCustomer4), (Array with: self exampleCustomer5 with: self exampleCustomer6 with: self exampleCustomer7).	example computeCollections.	^example.</body><body package="GlorpTestModels" selector="exampleStore2">exampleStore2	"self new exampleStore2"	| example |	example := GlorpVideoStore new.	example name: 'Bonzai Video'.	example id: 2.	example customers: (Array with: self exampleCustomer8).	example computeCollections.	^example.</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels" selector="descriptorForGlorpVideoCreditStatus:">descriptorForGlorpVideoCreditStatus: aDescriptor	| table |	table := self tableNamed: 'VIDEO_CREDIT_STATUS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #balanceOwing to: (table fieldNamed: 'BALANCE').	(aDescriptor newMapping: DirectMapping) from: #dateOwing to: (table fieldNamed: 'DATE_OWING').	(aDescriptor newMapping: DirectMapping) from: #comments to: (table fieldNamed: 'COMMENTS').	(aDescriptor newMapping: OneToOneMapping)			attributeName: #customer.</body><body package="GlorpTestModels" selector="descriptorForGlorpVideoCustomer:">descriptorForGlorpVideoCustomer: aDescriptor	| table linkTable purchaseTable |	table := self tableNamed: 'VIDEO_CUSTOMER'.	linkTable := self tableNamed: 'VIDEO_PURCHASE_LINK'.	purchaseTable := self tableNamed: 'VIDEO_PURCHASE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'CUSTOMERNAME').	(aDescriptor newMapping: DirectMapping) from: #dateOfBirth to: (table fieldNamed: 'BIRTHDATE').	(aDescriptor newMapping: OneToOneMapping)			attributeName: #store.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #creditStatus.	(aDescriptor newMapping: ToManyMapping)		attributeName: #inStoreRentals.	(aDescriptor newMapping: ToManyMapping)		useLinkTable;		attributeName: #inStorePurchases;		linkTableJoin: (Join 			from: (table fieldNamed: 'STORE_ID')			to: (linkTable fieldNamed: 'STORE_ID'));		targetTableJoin: (Join			from: (table fieldNamed: 'CUSTOMERNAME')			to: (purchaseTable fieldNamed: 'CUSTOMERNAME')			from: (table fieldNamed: 'BIRTHDATE')			to: (purchaseTable fieldNamed: 'CUSTOMERBIRTHDATE')			from: 'T'			to: (purchaseTable fieldNamed: 'IN_STORE'));			constructRowMapKeyAs: [:customer :purchase | 					MultipleRowMapKey with: customer with: purchase with: customer videoStore yourself].	(aDescriptor newMapping: ToManyMapping)		useLinkTable;		attributeName: #onlinePurchases;		linkTableJoin: (Join 			from: (table fieldNamed: 'STORE_ID')			to: (linkTable fieldNamed: 'STORE_ID'));		targetTableJoin: (Join 				from: (table fieldNamed: 'CUSTOMERNAME')			to: (purchaseTable fieldNamed: 'CUSTOMERNAME')			from: (table fieldNamed: 'BIRTHDATE')			to: (purchaseTable fieldNamed: 'CUSTOMERBIRTHDATE')			from: 'F'			to: (purchaseTable fieldNamed: 'IN_STORE'));			constructRowMapKeyAs: [:customer :purchase | 					MultipleRowMapKey with: customer with: purchase with: customer videoStore yourself].	"A complicated way of saying that the Store plus one other attribute has to be there"	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #inStorePurchases.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #inStoreRentals.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #onlinePurchases.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #creditStatus.	aDescriptor buildReplacementTableSelect.</body><body package="GlorpTestModels" selector="descriptorForGlorpVideoPurchase:">descriptorForGlorpVideoPurchase: aDescriptor	| table |	table := self tableNamed: 'VIDEO_PURCHASE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #title to: (table fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #price to: (table fieldNamed: 'PRICE').	(aDescriptor newMapping: DirectMapping) from: #inStore to: (table fieldNamed: 'IN_STORE').	(aDescriptor newMapping: OneToOneMapping)			useLinkTable;			attributeName: #store;			constructRowMapKeyAs: [:purchase :store | 					MultipleRowMapKey with: purchase with: store with: purchase customer yourself].	(aDescriptor newMapping: OneToOneMapping)		attributeName: #customer.</body><body package="GlorpTestModels" selector="descriptorForGlorpVideoRental:">descriptorForGlorpVideoRental: aDescriptor	| table |	table := self tableNamed: 'VIDEO_RENTAL'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #title to: (table fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #dueDate to: (table fieldNamed: 'DUE_DATE').	(aDescriptor newMapping: DirectMapping) from: #price to: (table fieldNamed: 'PRICE').	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #customerName to: (table fieldNamed: 'CUSTOMERNAME').	(aDescriptor newMapping: OneToOneMapping)		attributeName: #customer.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #store.</body><body package="GlorpTestModels" selector="descriptorForGlorpVideoStore:">descriptorForGlorpVideoStore: aDescriptor	| table |	table := self tableNamed: 'VIDEO_STORE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: ToManyMapping)			attributeName: #customers;			join: (Join				from: (table fieldNamed: 'ID')				to: ((self tableNamed: 'VIDEO_CUSTOMER') fieldNamed: 'STORE_ID')).	"The relationship to purchases is different from the one in customer, which distinguishes online from inStore"	(aDescriptor newMapping: ToManyMapping)		useLinkTable;		attributeName: #purchases;		constructRowMapKeyAs: [:store :purchase | 					MultipleRowMapKey with: store with: purchase with: purchase customer yourself].	"No relationship to rentals at all"</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>accessing</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('VIDEO_STORE' 'VIDEO_PURCHASE' 'VIDEO_RENTAL' 'VIDEO_PURCHASE_LINK' 'VIDEO_CUSTOMER' 'VIDEO_CREDIT_STATUS').</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: GlorpVideoStore;		add: GlorpVideoCreditStatus;		add: GlorpVideoCustomer;		add: GlorpVideoPurchase;		add: GlorpVideoRental;		yourself</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels" selector="tableForVIDEO_CREDIT_STATUS:">tableForVIDEO_CREDIT_STATUS: aTable	| customerTable custName custDate storeId |	customerTable := self tableNamed: 'VIDEO_CUSTOMER'.	custName := (aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50))		bePrimaryKey.	custDate := (aTable createFieldNamed: 'CUSTOMERBIRTHDATE' type: platform date) bePrimaryKey.	storeId := (aTable createFieldNamed: 'STORE_ID' type: platform int4) bePrimaryKey.	aTable addForeignKeyFrom: custName		to: (customerTable fieldNamed: 'CUSTOMERNAME')		from: custDate		to: (customerTable fieldNamed: 'BIRTHDATE')		from: storeId		to: (customerTable fieldNamed: 'STORE_ID') .	aTable addForeignKeyFrom: storeId to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID').	aTable createFieldNamed: 'BALANCE' type: (platform double).	aTable createFieldNamed: 'DATE_OWING' type: platform date.	aTable createFieldNamed: 'COMMENTS' type: (platform varchar: 50).</body><body package="GlorpTestModels" selector="tableForVIDEO_CUSTOMER:">tableForVIDEO_CUSTOMER: aTable	"Note: This table is imaginary"	| storeId |	aTable isImaginary: true.	(aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50))		bePrimaryKey.	(aTable createFieldNamed: 'BIRTHDATE' type: platform date) bePrimaryKey.	storeId := (aTable createFieldNamed: 'STORE_ID' type: (platform int4)) bePrimaryKey.	aTable addForeignKeyFrom: storeId		to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID')</body><body package="GlorpTestModels" selector="tableForVIDEO_PURCHASE:">tableForVIDEO_PURCHASE: aTable	| custName custDate customerTable |	(aTable createFieldNamed: 'ID' type: (platform int4)) bePrimaryKey.	customerTable := self tableNamed: 'VIDEO_CUSTOMER'.	custName := aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50).	custDate := aTable createFieldNamed: 'CUSTOMERBIRTHDATE' type: platform date.	aTable addForeignKeyFrom: custName		to: (customerTable fieldNamed: 'CUSTOMERNAME')		from: custDate		to: (customerTable fieldNamed: 'BIRTHDATE').	aTable createFieldNamed: 'TITLE' type: (platform varchar: 50).		aTable createFieldNamed: 'PRICE' type: (platform double).	aTable createFieldNamed: 'IN_STORE' type: (platform char: 1).</body><body package="GlorpTestModels" selector="tableForVIDEO_PURCHASE_LINK:">tableForVIDEO_PURCHASE_LINK: aTable	| storeId purchaseId |	purchaseId := aTable createFieldNamed: 'PURCHASE_ID' type: platform int4.	storeId := aTable createFieldNamed: 'STORE_ID' type: (platform int4).	aTable addForeignKeyFrom: storeId		to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID').	aTable addForeignKeyFrom: purchaseId		to: ((self tableNamed: 'VIDEO_PURCHASE') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForVIDEO_RENTAL:">tableForVIDEO_RENTAL: aTable	| custName custDate storeId customerTable |	(aTable createFieldNamed: 'ID' type: (platform int4)) bePrimaryKey.	customerTable := self tableNamed: 'VIDEO_CUSTOMER'.	custName := aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50).	custDate := aTable createFieldNamed: 'CUSTOMERBIRTHDATE' type: platform date.	storeId := aTable createFieldNamed: 'STORE_ID' type: (platform int4).	aTable addForeignKeyFrom: custName		to: (customerTable fieldNamed: 'CUSTOMERNAME')		from: custDate		to: (customerTable fieldNamed: 'BIRTHDATE')		from: storeId		to: (customerTable fieldNamed: 'STORE_ID').	aTable addForeignKeyFrom: storeId to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID').	aTable createFieldNamed: 'TITLE' type: (platform varchar: 50).		aTable createFieldNamed: 'DUE_DATE' type: platform date.	aTable createFieldNamed: 'PRICE' type: (platform double).</body><body package="GlorpTestModels" selector="tableForVIDEO_STORE:">tableForVIDEO_STORE: aTable	(aTable createFieldNamed: 'ID' type: (platform int4)) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varchar: 20).</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>class models</category><body package="GlorpTestModels" selector="classModelForGlorpVideoCreditStatus:">classModelForGlorpVideoCreditStatus: aClassModel	aClassModel newAttributeNamed: #customer type: GlorpVideoCustomer.	aClassModel newAttributeNamed: #store type: GlorpVideoStore.	aClassModel newAttributeNamed: #balanceOwing type: Number.	aClassModel newAttributeNamed: #dateOwing type: Date.	aClassModel newAttributeNamed: #comments type: String.</body><body package="GlorpTestModels" selector="classModelForGlorpVideoCustomer:">classModelForGlorpVideoCustomer: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #dateOfBirth type: Date.	aClassModel newAttributeNamed: #onlinePurchases collectionOf: GlorpVideoPurchase.	aClassModel newAttributeNamed: #inStorePurchases collectionOf: GlorpVideoPurchase.	aClassModel newAttributeNamed: #inStoreRentals collectionOf: GlorpVideoRental.		aClassModel newAttributeNamed: #store type: GlorpVideoStore.	aClassModel newAttributeNamed: #creditStatus type: GlorpVideoCreditStatus.</body><body package="GlorpTestModels" selector="classModelForGlorpVideoPurchase:">classModelForGlorpVideoPurchase: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #title type: String.	aClassModel newAttributeNamed: #price type: Number.	aClassModel newAttributeNamed: #inStore type: Boolean.	aClassModel newAttributeNamed: #customer type: GlorpVideoCustomer.		aClassModel newAttributeNamed: #store type: GlorpVideoStore.</body><body package="GlorpTestModels" selector="classModelForGlorpVideoRental:">classModelForGlorpVideoRental: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #title type: String.	aClassModel newAttributeNamed: #price type: Number.	aClassModel newAttributeNamed: #dueDate type: Date.	aClassModel newAttributeNamed: #customer type: GlorpVideoCustomer.	aClassModel newAttributeNamed: #store type: GlorpVideoStore.</body><body package="GlorpTestModels" selector="classModelForGlorpVideoStore:">classModelForGlorpVideoStore: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #purchases collectionOf: GlorpVideoPurchase.	aClassModel newAttributeNamed: #customers collectionOf: GlorpVideoCustomer.</body></methods><methods><class-id>Glorp.GlorpFilteredInheritanceTest</class-id> <category>tests</category><body package="GlorpTests" selector="compareEmployees:">compareEmployees: employees	employees do: [:each |		| corresponding |		corresponding := allEmployees detect: [:eachOriginal | each id = eachOriginal id].		self assert: corresponding = each].</body><body package="GlorpTests" selector="makeSupertaxIn:">makeSupertaxIn: aCollection	| previous newTax |	previous := aCollection last.	newTax := (GlorpBasicTax new)		name: (String with: (Character value: previous name first asInteger + 1));		yourself.	previous addTax: newTax.	aCollection add: newTax.</body><body package="GlorpTests" selector="testCacheLookup">testCacheLookup	"Ask for an Employee which should be from the cache and which should return a Manager."	| manager employee |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	manager := session readOneOf: GlorpManager				where: [:each | each id = 3 ].	self assert: (session cacheLookupForClass: GlorpEmployee key: 3) == manager.	employee := session readOneOf: GlorpEmployee				where: [:each | each id = 3 ].	self assert: employee == manager.	manager := session readOneOf: GlorpRegionalManager				where: [:each | each id = 12 ].	employee := session readOneOf: GlorpEmployee				where: [:each | each id = 12 ].	self assert: employee == manager.	employee := session readOneOf: GlorpManager				where: [:each | each id = 11 ].	manager := session readOneOf: GlorpEmployee				where: [:each | each id = 11 ].	self assert: employee == manager.	"Test that the cache refuses to return an object which is not of the proper class or subclass."	employee := session readOneOf: GlorpEmployee				where: [:each | each id = 4 ].	self assert: (session privateGetCache lookupClass: GlorpRegionalManager key: 4 ifAbsent: []) isNil.	manager := session readOneOf: GlorpRegionalManager				where: [:each | each id = 4 ].	self assert: manager isNil.	"Proxys seem to try a cache lookup before they execute their query...can we write a test which fails due to this?"] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests" selector="testDirectQuery">testDirectQuery	"Ask for all Employees, see if we get subclasses too"	| employees offices |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	employees := true 				ifTrue: [session readManyOf: GlorpEmployee where: [:each | each name = 'Bob']]				ifFalse: [session halt readManyOf: GlorpEmployee].	self assert: employees size = 8.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpEmployee]) size = 1.	self assert: (employees select: [:emp | emp isMemberOf: GlorpManager]) size = 2.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpLineWorker]) size = 4.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpRegionalManager]) size 				= 1.	self compareEmployees: employees.	session initializeCache.	offices := session readOneOf: GlorpOffice				where: [:each | each employeeOfMonth name = 'Bob'].	"There is no regional manager with id = 4 but we can ensure that the type info is getting into the query's key by asking for one and seeing that it doesn't exist"	session initializeCache.	self 		assert: (session readOneOf: GlorpRegionalManager where: [:each | each id = 4]) 				== nil] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests" selector="testDirectQuery2">testDirectQuery2	"Ask for all Employees, see if we get subclasses too"	| employees |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	employees := session readManyOf: GlorpEmployee.	self assert: employees size = 12.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpEmployee]) size = 2.	self assert: (employees select: [:emp | emp isMemberOf: GlorpManager]) size = 3.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpLineWorker]) size = 5.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpRegionalManager]) size 				= 2.] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests" selector="testDirectQueryWithAbstractClass">testDirectQueryWithAbstractClass	| fromdb |	session beginTransaction.	[session inUnitOfWorkDo: [	session register: (GlorpBasicTax new name: 'Tax'; yourself).								session register: (GlorpSurcharge new name: 'Surcharge'; yourself)].	session reset.	fromdb := session readManyOf: GlorpTax.	self assert: fromdb size = 2.	self assert: (fromdb select: [:emp | emp isMemberOf: GlorpTax]) isEmpty.	self assert: (fromdb select: [:emp | emp isMemberOf: GlorpBasicTax]) size = 1.	self assert: (fromdb select: [:emp | emp isMemberOf: GlorpSurcharge]) size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests" selector="testNotInSelect">testNotInSelect	"Ask for an Employee which should be from the cache and which should return a Manager."	| testEmployees |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	testEmployees := session readManyOf: GlorpManager				where: [:each | each id notIn: #(1 2 3)].	self assert: testEmployees notEmpty	"Proxys seem to try a cache lookup before they execute their query...can we write a test which fails due to this?"] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests" selector="testOrderBy">testOrderBy	| employees query |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	query := Query returningManyOf: GlorpEmployee				where: [:each | each id &lt;= 4].	query orderBy: #name.	query orderBy: #id.	employees := session execute: query.	self assert: (employees asSortedCollection: [:a :b | a name = b name ifTrue: [		a id &lt;= b id] ifFalse: [a name &lt; b name]]) asArray = employees]			ensure: [session rollbackTransaction]</body><body package="GlorpTests" selector="testRelationshipQuery">testRelationshipQuery	"Ask for all Employees in a given office and test that the return types are correct."	| employees office |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	office := session readOneOf: GlorpOffice				where: [:each | each id = 1 ].	employees := office employees.	self assert: employees size = 6.	self assert: (employees select: [:emp | emp isMemberOf: GlorpEmployee]) size = 2.	self assert: (employees select: [:emp | emp isMemberOf: GlorpManager]) size = 1.	self assert: (employees select: [:emp | emp isMemberOf: GlorpLineWorker]) size = 2.	self assert: (employees select: [:emp | emp isMemberOf: GlorpRegionalManager]) size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests" selector="testTaxInsertOrdering">testTaxInsertOrdering	| taxes first |	taxes := OrderedCollection new.	first := (GlorpBasicTax new)		name: 'A';		yourself.	taxes add: first.	10 timesRepeat: [self makeSupertaxIn: taxes].	[session beginTransaction.	session inUnitOfWorkDo: [session registerAll: taxes]]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpFilteredInheritanceTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	session system: (GlorpInheritanceDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database).</body><body package="GlorpTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.</body><body package="GlorpTests" selector="writeTestHarness">writeTestHarness	| office1 office2  eom1 eom2 jim bob |	session register: (office1 := GlorpOffice new id: 1; yourself).	session register: (office2 := GlorpOffice new id: 2; yourself).	office1 addEmployee: (eom1 := GlorpEmployee new id: 1; name: 'Bob'; yourself).	office1 addEmployee: (GlorpEmployee new id: 2; name: 'Jim'; yourself).	office1 addEmployee: (GlorpManager new id: 3; name: 'Bob'; branch: 'West'; yourself).	office2 addEmployee: (eom2 := GlorpManager new id: 4; name: 'Steve'; branch: 'East'; yourself).	office2 addEmployee: (GlorpManager new id: 5; name: 'Bob'; branch: 'South'; yourself).	office1 addEmployee: (GlorpLineWorker new id: 6; name: 'Wally'; productionLine: 'Gold'; yourself).	office1 addEmployee: (GlorpLineWorker new id: 7; name: 'Bob'; productionLine: 'Silver'; yourself).	office2 addEmployee: (GlorpLineWorker new id: 8; name: 'Bob'; productionLine: 'Tin'; yourself).	office2 addEmployee: (GlorpLineWorker new id: 9; name: 'Bob'; productionLine: 'Copper'; yourself).	office2 addEmployee: (GlorpLineWorker new id: 10; name: 'Bob'; productionLine: 'Steel'; yourself).	office1 addEmployee: (GlorpRegionalManager new id: 11; name: 'Bob'; branch: 'South'; region: 'MidWest'; yourself).	office2 addEmployee: (GlorpRegionalManager new id: 12; name: 'Mike'; branch: 'North'; region: 'NorthEast'; yourself).	office1 employeeOfMonth: eom1.	office2 employeeOfMonth: eom2.	session register: (jim := GlorpWorkingStiff new id: 13; name: 'Jim'; yourself).	session register: (bob := GlorpWorkingStiff new id: 14; name: 'Bob'; yourself).	allEmployees := (Array with: jim with: bob), office1 employees, office2 employees.</body></methods><methods><class-id>Glorp.GlorpFilteredInheritanceTest class</class-id> <category>resources</category><body package="GlorpTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpMessage</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	folder := nil.	user := nil.	subject := ''.	contents := ''.</body></methods><methods><class-id>Glorp.GlorpMessage</class-id> <category>accessing</category><body package="GlorpTestModels" selector="contents">contents	^contents</body><body package="GlorpTestModels" selector="contents:">contents: aString	contents := aString</body><body package="GlorpTestModels" selector="folder">folder	^folder</body><body package="GlorpTestModels" selector="folder:">folder: aGlorpFolder	folder := aGlorpFolder</body><body package="GlorpTestModels" selector="folderName">folderName	^self folder name.</body><body package="GlorpTestModels" selector="subject">subject	^subject</body><body package="GlorpTestModels" selector="subject:">subject: aString	subject := aString</body><body package="GlorpTestModels" selector="user">user	^user</body><body package="GlorpTestModels" selector="user:">user: aGlorpUser	user := aGlorpUser</body><body package="GlorpTestModels" selector="userId">userId	^self user id.</body></methods><methods><class-id>Glorp.GlorpMessage class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testLogin">testLogin	self assert: self accessor isLoggedIn not.	self accessor login.	self assert: self accessor isLoggedIn.	self accessor logout.	self assert: self accessor isLoggedIn not</body><body package="GlorpDBTests" selector="testSecureLoginDiscardsPassword">testSecureLoginDiscardsPassword	| oldValue |	self assert: self accessor isLoggedIn not.	oldValue := self accessor currentLogin secure.	[self accessor currentLogin secure: true.	self accessor login.	self assert: accessor currentLogin password isNil.	self accessor logout]		ensure: [self accessor currentLogin secure: oldValue].</body><body package="GlorpDBTests" selector="testUnsecureLoginDoesNotDiscardPassword">testUnsecureLoginDoesNotDiscardPassword	| oldValue |	self assert: self accessor isLoggedIn not.	oldValue := self accessor currentLogin secure.	[self accessor currentLogin secure: false.	self accessor login.	self assert: accessor currentLogin password notNil.	self accessor logout]		ensure: [self accessor currentLogin secure: oldValue].</body><body package="GlorpDBTests" selector="testUnsuccessfulLogin">testUnsuccessfulLogin	| anotherAccessor invalidLogin |	"Some databases can't fail to log in."	login database supportsAuthentication ifFalse: [^self].	invalidLogin := GlorpDatabaseLoginResource defaultLogin copy.	invalidLogin		password: 'you will never ever guess this password';		username: 'not a valid user name'.	anotherAccessor := DatabaseAccessor forLogin: invalidLogin.	self assert: anotherAccessor isLoggedIn not.	anotherAccessor loginIfError: [:ex | ].	Dialect isVisualAge		"The isLoggedIn is unreliable under VA, can return false positive"		ifFalse: [self assert: anotherAccessor isLoggedIn not]		ifTrue: [Transcript cr; show: self class name, '&gt;&gt;testUnsuccessfulLogin skips a trivial isLoggedIn check, saying it was unreliable under VA55, could return false positive, later versions not yet verified'].	anotherAccessor logout.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest</class-id> <category>accessing</category><body package="GlorpDBTests" selector="accessor">accessor	^accessor.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	login := GlorpDatabaseLoginResource defaultLogin copy.	accessor := DatabaseAccessor forLogin: login.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource.</body></methods><methods><class-id>Glorp.GlorpJoinTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	expression := Join 		from: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID')		to: ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	compoundExpression := Join		from: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID')		to: ((system tableNamed: 'PERSON') fieldNamed: 'NAME').	compoundExpression		addSource: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		target: ((system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID').</body></methods><methods><class-id>Glorp.GlorpJoinTest</class-id> <category>tests</category><body package="GlorpTests" selector="testAsExpressionCompound">testAsExpressionCompound		| e personTable accountTable |	personTable := system tableNamed: 'PERSON'.	accountTable := system tableNamed: 'BANK_ACCT'.	e := compoundExpression asGeneralGlorpExpression.	self assert: (e isKindOf: RelationExpression).	self assert: e relation == #AND.	self assert: (e leftChild isKindOf: RelationExpression).	self assert: (e leftChild relation == #=).	self assert: (e leftChild leftChild isKindOf: FieldExpression).	self assert: e leftChild leftChild field == (personTable fieldNamed: 'NAME').	self assert: (e leftChild rightChild isKindOf: ParameterExpression).	self assert: e leftChild rightChild field == (accountTable fieldNamed: 'ID').	self assert: (e rightChild isKindOf: RelationExpression).	self assert: (e rightChild relation == #=).	self assert: (e rightChild leftChild isKindOf: FieldExpression).	self assert: e rightChild leftChild field == (personTable fieldNamed: 'ADDRESS_ID').	self assert: (e rightChild rightChild isKindOf: ParameterExpression).	self assert: e rightChild rightChild field = (accountTable fieldNamed: 'BANK_CODE').</body><body package="GlorpTests" selector="testAsExpressionSingle">testAsExpressionSingle		| e field param |	e := expression asGeneralGlorpExpression.	self assert: (e isKindOf: RelationExpression).	self assert: e relation == #=.	field := e leftChild.	self assert: (field isKindOf: FieldExpression).	self assert: field field == ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	param := e rightChild.	self assert: (param isKindOf: ParameterExpression).	self assert: param field == ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID').</body><body package="GlorpTests" selector="testCompoundSQLPrinting">testCompoundSQLPrinting	| stream params|	stream := WriteStream on: (String new: 100).	params := Dictionary new.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID') put: 1.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE') put: 3.	compoundExpression printSQLOn: stream withParameters: params.	self assert: stream contents = 'PERSON.NAME = 1 AND PERSON.ADDRESS_ID = 3'.</body><body package="GlorpTests" selector="testCreation">testCreation	self assert: expression allSourceFields size = 1.	self assert: expression allSourceFields first == ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID').</body><body package="GlorpTests" selector="testParameterCount">testParameterCount	self assert: expression numberOfParameters = 1.	self assert: compoundExpression numberOfParameters = 2.</body><body package="GlorpTests" selector="testSQLPrinting">testSQLPrinting	| stream params |	stream := WriteStream on: (String new: 100).	params := Dictionary new.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID') put: 'abc'.	expression printSQLOn: stream withParameters: params.	self assert: stream contents = 'CUSTOMER_ACCT_LINK.ACCT_ID = ''abc'''</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>support</category><body package="GlorpDBTests" selector="checkExpiryTime">checkExpiryTime	""	| rowToWrite address modifiedRow expiryTime newExpiryTime |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	expiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	(Delay forSeconds: 1) wait.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	newExpiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	self assert: newExpiryTime &gt; expiryTime.	self assert: address street = 'Paseo Montril'] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="checkExpiryTime:">checkExpiryTime: aBlock	""	| rowToWrite address modifiedRow expiryTime newExpiryTime |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	expiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	(Delay forSeconds: 1) wait.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	newExpiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	aBlock value: expiryTime value: newExpiryTime value: address] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="checkRefreshDoing:">checkRefreshDoing: aBlock	"Check that we refresh correctly doing the action specified by aBlock"	| rowToWrite address modifiedRow |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	aBlock value: address.	self assert: address street = 'Something Else'.] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="helperForTestReadEmbeddedOneToOne">helperForTestReadEmbeddedOneToOne	| transRow query result |		[session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	query := Query returningOneOf: GlorpBankTransaction				where: [:each | each id = each id].	result := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: result serviceCharge notNil.	self assert: result serviceCharge description = 'additional overcharge'.	self assert: result amount currency = #CDN.	self assert: result amount amount = 7.	self assert: result serviceCharge amount currency = #USD.	self assert: result serviceCharge amount amount = 2.	^result.</body><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := session system.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.	system := nil.</body><body package="GlorpDBTests" selector="write2CustomerRowsWith3Transactions">write2CustomerRowsWith3Transactions	| table row aGlorpDemoDescriptorSystem |	session system writeCustomerWithDualAccountOwners.	aGlorpDemoDescriptorSystem := session system.	table := aGlorpDemoDescriptorSystem tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'CDN'.	row atFieldNamed: 'AMT_AMT' put: 9.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'CHF'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'USD'.	row atFieldNamed: 'AMT_AMT' put: 10.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'CHF'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'EUR'.	row atFieldNamed: 'AMT_AMT' put: 11.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'EUR'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 28.	session writeRow: row.</body><body package="GlorpDBTests" selector="writeCustomer1Rows">writeCustomer1Rows	^system writeCustomer1Rows.</body><body package="GlorpDBTests" selector="writeCustomer1RowsWith2Transactions">writeCustomer1RowsWith2Transactions	| table row aGlorpDemoDescriptorSystem |	self writeCustomer1RowsWithTransactions.	aGlorpDemoDescriptorSystem := session system.	table := aGlorpDemoDescriptorSystem tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'USD'.	row atFieldNamed: 'AMT_AMT' put: 9.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'CHF'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.</body><body package="GlorpDBTests" selector="writeCustomer1RowsWithTransactions">writeCustomer1RowsWithTransactions	| table row aGlorpDemoDescriptorSystem |	self writeCustomer1Rows.	aGlorpDemoDescriptorSystem := session system.	table := aGlorpDemoDescriptorSystem tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'CDN'.	row atFieldNamed: 'AMT_AMT' put: 7.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'USD'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.</body><body package="GlorpDBTests" selector="writeReservationData">writeReservationData	session beginUnitOfWork.	session register: GlorpItinerary example1.	session register: GlorpItinerary example2.	session commitUnitOfWork.	session writeRow: session system examplePassengerRow.	session initializeCache</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-refreshing</category><body package="GlorpDBTests" selector="testExpiryTimeNotReset">testExpiryTimeNotReset	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeoutSeconds: 3.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkExpiryTime: [:expiryTime :newExpiryTime :address | 		self assert: newExpiryTime = expiryTime.		self assert: address street = 'Paseo Montril'].</body><body package="GlorpDBTests" selector="testExpiryTimeReset">testExpiryTimeReset	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeoutSeconds: 4.	cachePolicy expiryAction: #remove.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkExpiryTime: [:expiryTime :newExpiryTime :address | 		self assert: newExpiryTime &gt; expiryTime.		self assert: address street = 'Paseo Montril'].</body><body package="GlorpDBTests" selector="testExpiryTimeReset2">testExpiryTimeReset2	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeoutSeconds: 4.	cachePolicy expiryAction: #notifyAndRemove.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkExpiryTime: [:expiryTime :newExpiryTime :address | 		self assert: newExpiryTime &gt; expiryTime.		self assert: address street = 'Paseo Montril'].</body><body package="GlorpDBTests" selector="testNonRefreshAddress">testNonRefreshAddress	"Test that if we don't set the refresh flag on the query we don't re-read the data"	| query rowToWrite address modifiedRow |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	query := Query returningOneOf: GlorpAddress where: [:each | each id = 123].	query executeIn: session.	self assert: address street = 'Paseo Montril'.] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testRefreshAddress">testRefreshAddress	"Check that we refresh correctly when the refresh flag is set"	| query rowToWrite address modifiedRow |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	query := Query returningOneOf: GlorpAddress where: [:each | each id = 123].	query shouldRefresh: true.	query executeIn: session.	self assert: address street = 'Something Else'.] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testSessionRefresh">testSessionRefresh	"Check that we refresh correctly when the refresh flag is set"	self checkRefreshDoing: [:anAddress | session refresh: anAddress].</body><body package="GlorpDBTests" selector="testSessionRefreshOnExpiry">testSessionRefreshOnExpiry	"Check that we refresh correctly when an object has expired"	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session readOneOf: GlorpAddress where: [:each | each id = 123]].</body><body package="GlorpDBTests" selector="testSessionRefreshOnExpiryWithCacheLookupOnly">testSessionRefreshOnExpiryWithCacheLookupOnly	"Check that we refresh correctly when an object has expired, doing only a cache lookup, not an explicit read"	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session privateGetCache lookupClass: GlorpAddress key: 123 ifAbsent: [nil]].</body><body package="GlorpDBTests" selector="testSessionRefreshOnProxyExpiry">testSessionRefreshOnProxyExpiry	"Check that we refresh correctly when an object has expired"	| cachePolicy |	cachePolicy := TimedStrongCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session readOneOf: GlorpAddress where: [:each | each id = 123]].</body><body package="GlorpDBTests" selector="testSessionRefreshOnProxyExpiryWithCacheLookupOnly">testSessionRefreshOnProxyExpiryWithCacheLookupOnly	"Check that we refresh correctly when an object has expired, doing only a cache lookup, not an explicit read"	| cachePolicy |	cachePolicy := TimedStrongCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session privateGetCache lookupClass: GlorpAddress key: 123 ifAbsent: [nil]].</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testCompoundAND">testCompoundAND	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpAddress				where: [:address | address id &lt; 124 AND: (address id  &gt; 122) AND: (address id ~= nil)].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests" selector="testConversionOnConstantQueryParams">testConversionOnConstantQueryParams	| query result transRow | 		[	session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	query := Query returningManyOf: GlorpBankTransaction where: [:trans | trans amount currency = #CDN].	result := session execute: query.	self assert: result size = 1.	self assert: result first amount amount = 7] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testConversionOnConstantQueryParams2">testConversionOnConstantQueryParams2	| query result transRow |		[	session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	query := Query returningManyOf: GlorpBankTransaction where: [:trans | trans amount amount = 7].	result := session execute: query.	self assert: result size = 1.	self assert: result first amount amount = 7] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeleteWithEmbedded">testDeleteWithEmbedded	| transaction uow |		[session beginTransaction.	session beginUnitOfWork.	self writeCustomer1RowsWithTransactions.	transaction := (session readManyOf: GlorpBankTransaction) first.	session delete: transaction.	uow := session privateGetCurrentUnitOfWork.	self assert: (uow willDelete: transaction).	self assert: (uow willDelete: transaction amount).	self assert: (uow willDelete: transaction serviceCharge).	self assert: (uow willDelete: transaction serviceCharge amount).	session commitUnitOfWork] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeletedObjectsNotReadInManyQuery">testDeletedObjectsNotReadInManyQuery	| query anAccount accounts someAccountId |	[session beginTransaction.	someAccountId := self writeCustomer1Rows first.	session beginUnitOfWork.	query := Query returningOneOf: GlorpBankAccount				where: [:each | each id = someAccountId].	anAccount := session execute: query.	self assert: anAccount class == GlorpBankAccount.	self assert: anAccount id = someAccountId.	session delete: anAccount.	accounts := session readManyOf: GlorpBankAccount.	self assert: accounts size = 1.	self deny: (accounts includes: anAccount).	self deny: (accounts anySatisfy: [:each | each id = someAccountId]).] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeletedObjectsNotReadInOneQuery">testDeletedObjectsNotReadInOneQuery	| query anAccount someAccountId account |	[session beginTransaction.	someAccountId := self writeCustomer1Rows first.	session beginUnitOfWork.	query := Query returningOneOf: GlorpBankAccount				where: [:each | each id = someAccountId].	anAccount := session execute: query.	self assert: anAccount class == GlorpBankAccount.	self assert: anAccount id = someAccountId.	session delete: anAccount.	account := session readOneOf: GlorpBankAccount where: [:each | each id = someAccountId].	self assert: account isNil] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testNonIntrusiveAlsoFetch">testNonIntrusiveAlsoFetch	| alsoFetchQuery query results | 	"If a platform has no outer joins (!) we cannot execute	 this test."	(session system platform supportsANSIJoins or: [		session system platform useMicrosoftOuterJoins or: [		session system platform useOracleOuterJoins ]])			ifFalse: [ ^self ].	[session beginTransaction.	session beginUnitOfWork.	session register: GlorpPerson example1.	session register: (GlorpPerson example1							id: 2;							address: nil;							yourself).	session commitUnitOfWork.	alsoFetchQuery := Query						returningManyOf: GlorpPerson						where: nil.	alsoFetchQuery alsoFetch: [:ea | ea address asOuterJoin].	query := Query					returningManyOf: GlorpPerson					where: nil.	results := alsoFetchQuery executeIn: session.	self assert: results size = 2.	results := query executeIn: session.	self assert: results size = 2] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testQueryHasLimit">testQueryHasLimit	self deny: (SimpleQuery returningManyOf: GlorpAddress) hasLimit.	self assert: (SimpleQuery returningManyOf: GlorpAddress limit: 10) hasLimit.	self assert: (SimpleQuery returningManyOf: GlorpAddress limit: -10) hasLimit.	self assert: (SimpleQuery returningManyOf: GlorpAddress) limitMakesSense.	self assert: (SimpleQuery returningManyOf: GlorpAddress limit: 10) limitMakesSense.	self deny: (SimpleQuery returningManyOf: GlorpAddress limit: 0) limitMakesSense.	self deny: (SimpleQuery returningManyOf: GlorpAddress limit: -10) limitMakesSense.</body><body package="GlorpDBTests" selector="testQueryHasOffset">testQueryHasOffset	self deny: (SimpleQuery returningManyOf: GlorpAddress) hasOffset.	self assert: ((SimpleQuery returningManyOf: GlorpAddress) offset: 10; yourself) hasOffset.	self deny: ((SimpleQuery returningManyOf: GlorpAddress) offset: 0; yourself) hasOffset.	self deny: ((SimpleQuery returningManyOf: GlorpAddress) offset: -10; yourself) hasOffset.</body><body package="GlorpDBTests" selector="testReadAccountsWithCompoundAnySatisfyExists">testReadAccountsWithCompoundAnySatisfyExists	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			account accountHolders anySatisfyExists: [:each | (each id = 27) &amp; (each name = 'aCustomer')]].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithCompoundAnySatisfyJoin">testReadAccountsWithCompoundAnySatisfyJoin	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			account accountHolders anySatisfyJoin: [:each | (each id = 27) &amp; (each name = 'aCustomer')]].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithMultipleAnySatisfyExists">testReadAccountsWithMultipleAnySatisfyExists	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyExists: [:each | each id = 24]) 				| (account accountHolders anySatisfyExists: [:each | each id = 27])].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithMultipleAnySatisfyJoin">testReadAccountsWithMultipleAnySatisfyJoin	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyJoin: [:each | each id = 24]) 				| (account accountHolders anySatisfyJoin: [:each | each id = 27])].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithMultipleAnySatisfyMixed1">testReadAccountsWithMultipleAnySatisfyMixed1	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyJoin: [:each | each id = 24]) 				| (account accountHolders anySatisfyExists: [:each | each id = 27])].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithMultipleAnySatisfyMixed2">testReadAccountsWithMultipleAnySatisfyMixed2	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyExists: [:each | each id = 24]) 				| (account accountHolders anySatisfyJoin: [:each | each id = 27])].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithNestedAnySatisfyExists">testReadAccountsWithNestedAnySatisfyExists	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyExists: [:each | each transactions anySatisfyExists: [:eachTrans |			eachTrans id ~= nil]]].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithNestedAnySatisfyJoin">testReadAccountsWithNestedAnySatisfyJoin	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyJoin: [:each | each transactions anySatisfyJoin: [:eachTrans |			eachTrans id ~= nil]]].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithNestedAnySatisfyMixed1">testReadAccountsWithNestedAnySatisfyMixed1	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyExists: [:each | each transactions anySatisfyJoin: [:eachTrans |			eachTrans id ~= nil]]].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAccountsWithNestedAnySatisfyMixed2">testReadAccountsWithNestedAnySatisfyMixed2	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyJoin: [:each | each transactions anySatisfyExists: [:eachTrans |			eachTrans id ~= nil]]].	query := Query returningManyOf: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAdHoc">testReadAdHoc 	| queryTime table row time idField times |		[	session beginTransaction.		table := session system tableNamed: 'TRANSFORMED_TIME'.	row := DatabaseRow newForTable: table.	idField := (table fieldNamed: 'ID').	row at: idField put: 3.	time := Time now.	row at: (table fieldNamed: 'TIMEFIELD') put: time asSeconds.	session writeRow: row.	queryTime := GlorpTransformedTime  new id: 3; time: time.	times := session readManyOf: GlorpTransformedTime where: [:each | each time = time].	self assert: times size = 1.	self assert: times first time asSeconds = time asSeconds.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAdHocProxied">testReadAdHocProxied	| table row time idField times time2 |	((session system descriptorFor: GlorpTransformedTime) mappingForAttributeNamed: #time) shouldProxy: true.	[	session beginTransaction.		table := session system tableNamed: 'TRANSFORMED_TIME'.	row := DatabaseRow newForTable: table.	idField := (table fieldNamed: 'ID').	row at: idField put: 3.	time := Time now.	row at: (table fieldNamed: 'TIMEFIELD') put: time asSeconds.	session writeRow: row.	row := DatabaseRow newForTable: table.	row at: idField put: 4.	time2 := Dialect addSeconds: 10 to: Time now.	row at: (table fieldNamed: 'TIMEFIELD') put: time2 asSeconds.	session writeRow: row.	times := session read: GlorpTransformedTime orderBy: [:each | each time].	self assert: times size = 2.	self assert: times first time class == AdHocProxy.	self assert: times first time asSeconds = time asSeconds.	self assert: times last time asSeconds = time2 asSeconds.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadAddress">testReadAddress	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpAddress				where: [:address | address id = 123].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests" selector="testReadAddressProxy">testReadAddressProxy	| object query results rowToWrite proxy | 	[session beginTransaction.		rowToWrite := session system exampleAddressRow.		session writeRow: rowToWrite.		query := (Query			returningManyOf: GlorpAddress			where: ([:address | address id = 123]) ) returnProxies: true.		results := query executeIn: session.		self assert: (results size = 1).		proxy := results first.		object := proxy getValue]	ensure: [session rollbackTransaction].	self assert: (proxy isGlorpProxy).	self assert: (object class = GlorpAddress).	self assert: (object id = 123).	self assert: (object street = 'Paseo Montril').	self assert: (object number = '10185').</body><body package="GlorpDBTests" selector="testReadAddressProxyAlreadyInMemory">testReadAddressProxyAlreadyInMemory	"Check that if the object is already in memory we don't create a proxy for it, just return the instance Unless explicitly asked, in which case we return a proxy."	| object object2 query results rowToWrite |	[session beginTransaction.		rowToWrite := session system exampleAddressRow.		session writeRow: rowToWrite.		object := session readOneOf: GlorpAddress where: [:address | address id = 123].		self deny: (object class inheritsFrom: Proxy).		object2 := session readOneOf: GlorpAddress where: [:address | address id = 123].		self deny: (object class inheritsFrom: Proxy).		self assert: object2 == object.		object := nil.		object2 := nil.		Dialect garbageCollect.		(Delay forSeconds: 2) wait.		query := (Query			returningManyOf: GlorpAddress			where: ([:address | address id = 123]) ) returnProxies: true.		results := query executeIn: session.		session accessor denyReads.		self assert: (results size = 1).		object := results first]	ensure: [session rollbackTransaction].	self assert: (object class = Proxy).	self deny: object isInstantiated.	self assert: (object id = 123).	self assert: (object street = 'Paseo Montril').	self assert: (object number = '10185').	session accessor permitEverything.</body><body package="GlorpDBTests" selector="testReadAddressSubstring">testReadAddressSubstring	| object query results rowToWrite results2 |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpAddress				where: [:address | (address street copyFrom: 1 to: 5) = 'Paseo'].	results := query executeIn: session.	query := Query returningManyOf: GlorpAddress				where: [:address | (address street copyFrom: 7 to: 13) = 'Montril'].	results2 := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'.	self assert: results2 size = 1.	self assert: results2 first = results first.</body><body package="GlorpDBTests" selector="testReadAllAddress">testReadAllAddress	| object results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	results := session readManyOf: GlorpAddress] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests" selector="testReadCompressedMoney">testReadCompressedMoney	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleCompressedMoneyRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpCompressedMoney				where: [:money | money id ~= 0].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpCompressedMoney.	self assert: object amount = 12.	self assert: object currency = 'CDN'.</body><body package="GlorpDBTests" selector="testReadCompressedMoney2">testReadCompressedMoney2	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleCompressedMoneyRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpCompressedMoney				where: [:money | money = (GlorpCompressedMoney new id: 123; currency: 'CDN'; amount: 12)].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpCompressedMoney.	self assert: object amount = 12.	self assert: object currency = 'CDN'.</body><body package="GlorpDBTests" selector="testReadCustomerAndAddTransaction">testReadCustomerAndAddTransaction	| query  customer accountIds newCustomer rawRows |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	session beginUnitOfWork.	query := Query returningOneOf: GlorpCustomer				where: [:person | person id = 27].	customer := session execute: query.	customer addTransaction: GlorpBankTransaction example1.	session commitUnitOfWork.	newCustomer := session execute: query.	self assert: customer == newCustomer.	self assert: customer transactions first owner yourSelf == customer.	rawRows := session accessor executeSQLString: 'SELECT ID, NAME FROM GR_CUSTOMER'.	self assert: rawRows size = 1.	self assert: (rawRows first atIndex: 1) = 27.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadCustomerWithAccounts">testReadCustomerWithAccounts	| query id1 id2 result accounts backRef1 backRef2 accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query returningOneOf: GlorpCustomer				where: [:person | person id = 27].	result := session execute: query.	self assert: result seenPostFetch = true.	accounts := result accounts getValue.	self assert: accounts size = 2.	self assert: (accounts first id = id1 or: [accounts last id = id1]).	self assert: (accounts first id = id2 or: [accounts last id = id2]).	self assert: accounts first id ~= accounts last id.	backRef1 := accounts first accountHolders getValue.	self assert: backRef1 size = 1.	self assert: backRef1 first = result.	backRef2 := accounts first accountHolders getValue.	self assert: backRef2 size = 1.	self assert: backRef2 first = result] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadCustomerWithAnySatisfyExists">testReadCustomerWithAnySatisfyExists	| query result accounts |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpCustomer				where: 					[:person | 					person accounts anySatisfyExists: [:each | each accountNumber branchNumber &gt; 0]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2.	query := Query returningManyOf: GlorpCustomer				where: 					[:person | 					person accounts anySatisfy: [:each | each accountNumber branchNumber = 2]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadCustomerWithAnySatisfyJoin">testReadCustomerWithAnySatisfyJoin	| query result accounts |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpCustomer				where: 					[:person | 					person accounts anySatisfyJoin: [:each | each accountNumber branchNumber &gt; 0]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2.	query := Query returningManyOf: GlorpCustomer				where: 					[:person | 					person accounts anySatisfy: [:each | each accountNumber branchNumber = 2]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadCustomerWithIncludes">testReadCustomerWithIncludes	| query result accounts account |		[session beginTransaction.	self writeCustomer1Rows.	account := session readOneOf: GlorpBankAccount where: [:each | each accountNumber branchNumber = 2].	query := Query returningManyOf: GlorpCustomer				where: 					[:person | 					person accounts includes: account].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: (accounts includes: account).	self assert: accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadCustomerWithMultipleAnySatisfyExists">testReadCustomerWithMultipleAnySatisfyExists	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:person | 			(person accounts anySatisfyExists: [:each | each accountNumber branchNumber = 2]) 				&amp; (person accounts 						anySatisfyExists: [:each | each accountNumber branchNumber = 3])].	query := Query returningManyOf: GlorpCustomer where: block.	result := session execute: query.	self assert: result size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadCustomerWithMultipleAnySatisfyJoin">testReadCustomerWithMultipleAnySatisfyJoin	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:person | 			(person accounts anySatisfyJoin: [:each | each accountNumber branchNumber = 2]) 				&amp; (person accounts 						anySatisfyJoin: [:each | each accountNumber branchNumber = 3])].	query := Query returningManyOf: GlorpCustomer where: block.	result := session execute: query.	self assert: result size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadEmbeddedObjectDirectly">testReadEmbeddedObjectDirectly	| serviceCharges transRow |		[	session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	transRow := session system exampleBankTransactionRow2.	session writeRow: transRow.	serviceCharges := session readManyOf: GlorpServiceCharge.	self assert: serviceCharges size = 2.	self deny: serviceCharges first == serviceCharges last.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadEmbeddedOneToOne">testReadEmbeddedOneToOne	self helperForTestReadEmbeddedOneToOne.</body><body package="GlorpDBTests" selector="testReadMultiFieldAdHoc">testReadMultiFieldAdHoc	| object query results rowToWrite row2 |		[session beginTransaction.	rowToWrite := session system exampleCompressedMoneyRow.	row2 := session system exampleCompressedMoneyRow2.	session writeRow: rowToWrite.	session writeRow: row2.	query := Query returningManyOf: GlorpCompressedMoney				where: [:money | money array = #('CDN' 12)].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpCompressedMoney.	self assert: object amount = 12.	self assert: object currency = 'CDN'.</body><body package="GlorpDBTests" selector="testReadMultipleObjectsManyToMany1">testReadMultipleObjectsManyToMany1	| query result account |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpBankAccount.	query alsoFetch: [:each | each accountHolders].	result := query executeIn: session.	self assert: result size = 2.	account := result first.	self deny: account accountHolders isGlorpProxy.	self assert: account accountHolders size = 1.	self assert: (account accountHolders first == (result last accountHolders first))] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadMultipleObjectsManyToMany2">testReadMultipleObjectsManyToMany2	| query result customer |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpCustomer.	query retrieve: [:each | each ].	query alsoFetch: [:each | each accounts].	result := query executeIn: session.	self assert: result size = 1.	customer := result first.	self deny: customer accounts class isGlorpProxy.	self assert: customer accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadMultipleObjectsManyToMany3">testReadMultipleObjectsManyToMany3	| query result customer array |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpCustomer.	query retrieve: [:each | each ].	query retrieve: [:each | each accounts].	result := query executeIn: session.	self assert: result size = 1.	array := result first.	customer := array first.	self deny: customer accounts isGlorpProxy.	self assert: customer accounts size = 2.	self assert: customer accounts == array last] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadMultipleObjectsManyToMany4">testReadMultipleObjectsManyToMany4	"If we read just a to-many relation, then it doesn't get knitted and we just get a collection of the target"	| query result |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpCustomer where: [:each | each id ~= 7].	query retrieve: [:each | each accounts].	result := query executeIn: session.	self assert: result size = 2.	self assert: session privateGetCache numberOfElements = 2.	self assert: (result allSatisfy: [:each | each class == GlorpBankAccount]).	self assert: result first ~= result last] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadMultipleObjectsToManyAlsoFetchTwoLevels">testReadMultipleObjectsToManyAlsoFetchTwoLevels	| query result account transactions |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	session beginUnitOfWork.	query := Query returningManyOf: GlorpBankAccount.	query alsoFetch: [:each | each accountHolders].	query alsoFetch: [:each | each accountHolders transactions].	result := query executeIn: session.	self assert: result size = 2.	account := result detect: [:each | each id = 9874].	self deny: result first == result last.	self deny: account accountHolders isGlorpProxy.	self assert: account accountHolders size = 1.	transactions := account accountHolders first transactions.	self deny: transactions isGlorpProxy.	self assert: transactions size = 2.	self assert: account accountHolders first == (result at: 2) accountHolders first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadPassenger">testReadPassenger	| passengerRow1 passengerRow2 query result |		[session beginTransaction.	passengerRow1 := session system examplePassengerRow.	session writeRow: passengerRow1.	passengerRow2 := session system exampleFrequentFlyerRow.	session writeRow: passengerRow2.	query := Query returningOneOf: GlorpPassenger				where: [:passenger | passenger id = 1].	result := query executeIn: session.	self assert: result id = 1.	self assert: result name = 'Some Passenger'.	self assert: result frequentFlyerPoints = 10000] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadRelationshipField">testReadRelationshipField	| query results |		[session beginTransaction.	query := Query returningManyOf: GlorpItinerary where: [:each | ((each getTable: 'ITINERARY') getField: 'RES_ID') = nil].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 0.</body><body package="GlorpDBTests" selector="testReadReservationWithJoinToPassenger">testReadReservationWithJoinToPassenger	| reservations |		[session beginTransaction.	self writeReservationData.	session beginUnitOfWork.	reservations := session readManyOf: GlorpReservation				where: [:each | each passenger id = 3].	self assert: reservations size = 1.	self assert: reservations first passengers size = 1.] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadReservationWithPassenger">testReadReservationWithPassenger		| reservation passenger reservations |	[session beginTransaction.	self writeReservationData.	session beginUnitOfWork.	"This doesn't validate so well. We want to make sure that the passenger table read uses a join and gets back only the one row, but it's hard to test that. Putting in an error check in the query for readOne... that returns multiple would work, but is kind of intrusive"	reservations := session readManyOf: GlorpReservation where: [:each | each id = 2].	self assert: reservations size = 1.	reservation := reservations first.	passenger := reservation passenger.	passenger id.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadTransactionsWithIndependentSubselect">testReadTransactionsWithIndependentSubselect	| query result query2 matchingResult |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query returningManyOf: GlorpBankTransaction where: [:each |		each exists: (Query readManyOf: GlorpCustomer where: [:eachCustomer |			(eachCustomer id = each owner id) &amp; (eachCustomer name = 'anotherCustomer')])].	query orderBy: [:each | each owner name].	"Another way of saying the same thing"	query2 := Query returningManyOf: GlorpBankTransaction where: [:each | each owner name = 'anotherCustomer'].	result := session execute: query.	matchingResult := session execute: query2.	self assert: result size = matchingResult size.	result with: matchingResult do: [:one :other |		self assert: one = other]] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadTransactionsWithIndependentSubselectAndNot">testReadTransactionsWithIndependentSubselectAndNot	| query result query2 matchingResult |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query returningManyOf: GlorpBankTransaction where: [:each |		each notExists: (Query readManyOf: GlorpCustomer where: [:eachCustomer |			(eachCustomer id = each owner id) &amp; (eachCustomer name = 'anotherCustomer')])].	query orderBy: [:each | each owner name].	"Another way of saying the same thing"	query2 := Query returningManyOf: GlorpBankTransaction where: [:each | each owner name ~= 'anotherCustomer'].	query2 orderBy: [:each | each owner name].	result := session execute: query.	matchingResult := session execute: query2.	self assert: result size = matchingResult size.	result with: matchingResult do: [:one :other |		self assert: one = other]] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadTransactionsWithMaxSubselect">testReadTransactionsWithMaxSubselect	| query result |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query returningManyOf: GlorpBankTransaction where: [:each |		each amount amount = ((Query readManyOf: GlorpBankTransaction			where: [:eachTrans | eachTrans owner = each owner]) 				retrieve: [:eachTrans | eachTrans amount amount max])].	query orderBy: [:each | each owner name].	result := session execute: query.	self assert: result size = 2.	self assert: result first amount amount = 10.	self assert: result last amount amount = 11.	self assert: result first owner id ~= result last owner id] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadTransactionsWithMaxSubselectAndRetrieveMax">testReadTransactionsWithMaxSubselectAndRetrieveMax	| query result |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query returningManyOf: GlorpBankTransaction where: [:each |		each amount amount = ((Query readManyOf: GlorpBankTransaction			where: [:eachTrans | eachTrans owner = each owner]) 				retrieveMax: [:eachTrans | eachTrans amount amount])].	query orderBy: [:each | each owner name].	result := session execute: query.	self assert: result size = 2.	self assert: result first amount amount = 10.	self assert: result last amount amount = 11.	self assert: result first owner id ~= result last owner id] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadWithCacheHits">testReadWithCacheHits	| query addressRow result1 result2 |		[session beginTransaction.	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	query := Query returningOneOf: GlorpAddress				where: [:address | address id = 123].	result1 := query executeIn: session.	result2 := query executeIn: session.	self assert: result1 == result2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadWithFalseWhereClause">testReadWithFalseWhereClause	| query id1 id2 result accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query returningManyOf: GlorpBankAccount				where: false.	result := session execute: query.	self assert: result size = 0] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadWithLimit">testReadWithLimit	| results |	session platform supportsLimit ifFalse: [^self].	results := Set new.	[session beginTransaction.	session		inUnitOfWorkDo:			[(1 to: 5) do: [:i | session register: ((GlorpAddress new)													id: i;													yourself)]].	results		add: (session execute: (SimpleQuery returningManyOf: GlorpAddress limit: 3)) size;		add: (session execute: (SimpleQuery returningManyOf: GlorpAddress where: true limit: 3)) size;		add: (session execute: (SimpleQuery readManyOf: GlorpAddress limit: 3)) size;		add: (session execute: (SimpleQuery readManyOf: GlorpAddress where: true limit: 3)) size;		add: (session readManyOf: GlorpAddress limit: 3) size;		add: (session readManyOf: GlorpAddress where: true limit: 3) size.	self assert: (results allSatisfy: [:ea | ea = 3])] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadWithLimitAndOffset">testReadWithLimitAndOffset	session platform supportsOffset ifFalse: [^self].	[session beginTransaction.	session		inUnitOfWorkDo:			[(1 to: 5) do: [:i | session register: ((GlorpAddress new)													id: i;													yourself)]].	self assert: (session execute: ((SimpleQuery returningManyOf: GlorpAddress limit: 2)									offset: 2;									yourself)) size = 2.	self assert: (session execute: ((SimpleQuery returningManyOf: GlorpAddress limit: 0)									offset: 2;									yourself)) size = 0.	self assert: (session execute: ((SimpleQuery returningManyOf: GlorpAddress)									offset: 6;									yourself)) size = 0] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadWithNilWhereClause">testReadWithNilWhereClause	| query id1 id2 result accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query returningManyOf: GlorpBankAccount				where: nil.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadWithObjectEqualityToEmbeddedObject">testReadWithObjectEqualityToEmbeddedObject	| query result |	 	[session beginTransaction.	self writeCustomer1RowsWith2Transactions.	query := Query	returningManyOf: GlorpBankTransaction	where: [:trans | trans amount = (GlorpMoney currency: #CDN amount: 7)].	result := session execute: query.	self assert: result size = 1.	self assert: result first amount amount = 7.	self assert: result first amount currency = #CDN] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadWithObjectEqualityToEmbeddedObjectNested">testReadWithObjectEqualityToEmbeddedObjectNested	| query result |	 	[session beginTransaction.	self writeCustomer1RowsWith2Transactions.	query := Query		 returningManyOf: GlorpBankTransaction	where: [:trans | trans serviceCharge amount = (GlorpMoney currency: #CHF amount: 2)].	result := session execute: query.	self assert: result size = 1.	self assert: result first serviceCharge amount amount = 2.	self assert: result first serviceCharge amount currency = #CHF] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testReadWithOffset">testReadWithOffset	session platform supportsOffset ifFalse: [^self].	[session beginTransaction.	session		inUnitOfWorkDo:			[(1 to: 5) do: [:i | session register: ((GlorpAddress new)													id: i;													yourself)]].	self assert: (session execute: ((SimpleQuery returningManyOf: GlorpAddress)									offset: 2;									yourself)) size = 3] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadWithTrueWhereClause">testReadWithTrueWhereClause	| query id1 id2 result accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query returningManyOf: GlorpBankAccount				where: true.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testRegisteringWithEmbeddedMapping">testRegisteringWithEmbeddedMapping	| bankTrans |	session beginUnitOfWork.	bankTrans := self helperForTestReadEmbeddedOneToOne.	self assert: (session isRegistered: bankTrans).	self assert: (session isRegistered: bankTrans serviceCharge).	self assert: (session isRegistered: bankTrans serviceCharge amount).</body><body package="GlorpDBTests" selector="testSequencePolicyForInsert">testSequencePolicyForInsert	| testObject |	GlorpInMemorySequenceDatabaseType reset.	[session beginTransaction.	session beginUnitOfWork.	testObject := GlorpAirline new.	session register: testObject.	session commitUnitOfWork.	self assert: testObject id = 1]		ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testShortCircuitEmptyReturnWhenLimitMeansNoResults">testShortCircuitEmptyReturnWhenLimitMeansNoResults	self deny: (SimpleQuery returningManyOf: GlorpAddress limit: 3) shortCircuitEmptyReturn.	self assert: (SimpleQuery returningManyOf: GlorpAddress limit: 0) shortCircuitEmptyReturn.	self assert: (SimpleQuery returningManyOf: GlorpAddress limit: -3) shortCircuitEmptyReturn</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>accessing</category><body package="GlorpDBTests" selector="session">session	^session.</body><body package="GlorpDBTests" selector="session:">session: anObject	session := anObject</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-functions</category><body package="GlorpDBTests" selector="testCount">testCount	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each id count].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 3.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCountOnRelatedAttribute">testCountOnRelatedAttribute	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each accountHolders id count].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 2.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCountStar">testCountStar	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each countStar].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 3.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCountStarInRetrieveWithConstants">testCountStarInRetrieveWithConstants	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query returningManyOf: GlorpBankAccount.	query session: session.	query retrieve: [:each | each countStar].	query retrieve: [:each | 'X'].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = #(3 'X').	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCountStarOnRelatedObject">testCountStarOnRelatedObject	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each accountHolders countStar].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 2.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCountStarOnRelatedObjectAttribute">testCountStarOnRelatedObjectAttribute	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each accountHolders id countStar].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 2.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCountStarOnRelatedObjectWithGroupBy">testCountStarOnRelatedObjectWithGroupBy	| query result extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each accountHolders countStar].	query groupBy: [:each | each id].	result := query executeIn: session.	self assert: result = #(1 1 )] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testMax">testMax	| query result account |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each accountNumber accountNumber max].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = '4'.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testMin">testMin	| query result account |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each accountNumber accountNumber min].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = '3'.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testSum">testSum	| query result |		[session beginTransaction.	self writeCustomer1Rows.	query := Query returningManyOf: GlorpBankAccount.	query retrieve: [:each | each accountNumber branchNumber sum].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 5] 			ensure: [session rollbackTransaction]</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-in</category><body package="GlorpDBTests" selector="testInFromJoin">testInFromJoin	| query result |	[session beginTransaction.	self writeReservationData.	query := Query returningManyOf: GlorpItinerary where: [:each | each reservation passengers 		anySatisfyJoin: [:eachPassenger | eachPassenger airline id in: #(73 74)]].	result := session execute: query.	self assert: (result allSatisfy: [:each | each reservation passengers anySatisfy: [:eachPassenger | #(73 74) includes: eachPassenger airline id]]).	self assert: result size = 2] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testInFromSubselect">testInFromSubselect	| query result |	[session beginTransaction.	self writeReservationData.	query := Query returningManyOf: GlorpItinerary where: [:each | each reservation passengers 		anySatisfyExists: [:eachPassenger | eachPassenger airline id in: #(73 74)]].	result := session execute: query.	self assert: (result allSatisfy: [:each | each reservation passengers anySatisfy: [:eachPassenger | #(73 74) includes: eachPassenger airline id]]).	self assert: result size = 2] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-sql</category><body package="GlorpDBTests" selector="testCustomSQLInAccountsMapping">testCustomSQLInAccountsMapping	"Test using custom sql for the mapping's query. This will only work if using binding."	| query id1 id2 result accounts backRef1 backRef2 accountIds |	session useBinding ifFalse: [^self].	((session system descriptorFor: GlorpCustomer) 		mappingForAttributeNamed: #accounts)			query sql: 'SELECT t1.ID, t1.BANK_CODE, t1.BRANCH_NO, t1.ACCT_NO FROM BANK_ACCT t1, CUSTOMER_ACCT_LINK t2 WHERE ((t2.ACCT_ID = t1.ID) AND (t2.CUSTOMER_ID = ?))'.	[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query returningOneOf: GlorpCustomer				where: [:person | person id = 27].	result := session execute: query.	accounts := result accounts getValue.	self assert: accounts size = 2.	self assert: (accounts first id = id1 or: [accounts last id = id1]).	self assert: (accounts first id = id2 or: [accounts last id = id2]).	self assert: accounts first id ~= accounts last id.	backRef1 := accounts first accountHolders getValue.	self assert: backRef1 size = 1.	self assert: backRef1 first = result.	backRef2 := accounts first accountHolders getValue.	self assert: backRef2 size = 1.	self assert: backRef2 first = result] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCustomSQLInAddressMapping">testCustomSQLInAddressMapping	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpAddress.	query sql: 'select id, street, house_num from gr_address where id = 123'.	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests" selector="testReadAddressWithCustomSQL">testReadAddressWithCustomSQL	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpAddress.	query sql: 'select id, street, house_num from gr_address where id = 123'.	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests" selector="testReadAddressWithCustomSQLBinding">testReadAddressWithCustomSQLBinding	"Test that we can bind to custom SQL. If not binding, don't run this test."	| object query results rowToWrite |		session useBinding ifFalse: [^self].	[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query returningManyOf: GlorpAddress.	query sql: 'select id, street, house_num from gr_address where id = ?'.	results := query executeWithParameters: #(123) in: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body></methods><methods><class-id>Glorp.GlorpReadingTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpVarchar10Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform varchar: 10.</body></methods><methods><class-id>Glorp.GlorpVarchar10Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testVarCharWithEscapedCharacters">testVarCharWithEscapedCharacters	stType := String.	self helpTestValue: nil.	#($\ $~ $` $! $@ $# $$ $% $^ $&amp; $* $( $) $_ $- $+ $= $| $} ${ $] $[ $" $' $: $; $? $/ $&gt; $. $&lt; $,)		do: [:ea | self helpTestValue: 'abc' , (String with: ea) , 'def']</body></methods><methods><class-id>Glorp.GlorpTransformedTime</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="time">time	^time</body><body package="GlorpTestModels" selector="time:">time: anObject	time := anObject</body></methods><methods><class-id>Glorp.GlorpTransformedTime</class-id> <category>initialize</category><body package="GlorpTestModels" selector="initialize">initialize	time := Time now.</body></methods><methods><class-id>Glorp.GlorpTransformedTime class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels" selector="exampleJobRow:finished:">exampleJobRow: anInteger finished: aBoolean	| table row |	table := self tableNamed: 'GLORP_JOB'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: anInteger.	row at: (table fieldNamed: 'DESCRIPTION') put: 'Job ', anInteger printString.	row at: (table fieldNamed: 'FINISHED') put: (aBoolean ifTrue: ['Y'] ifFalse: ['N']).	row at: (table fieldNamed: 'OWNER_ID') put: 1234.	^row.</body><body package="GlorpTestModels" selector="exampleLinkRow1">exampleLinkRow1	| table row |	table := self tableNamed: 'GLORP_WORKER_JOB_LINK'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'WORKER_ID') put: 1234.	row at: (table fieldNamed: 'JOB_ID') put: 2.	row at: (table fieldNamed: 'PRIORITY') put: 'N'.	^row.</body><body package="GlorpTestModels" selector="exampleLinkRow2">exampleLinkRow2	| table row |	table := self tableNamed: 'GLORP_WORKER_JOB_LINK'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'WORKER_ID') put: 1234.	row at: (table fieldNamed: 'JOB_ID') put: 3.	row at: (table fieldNamed: 'PRIORITY') put: 'Y'.	^row.</body><body package="GlorpTestModels" selector="exampleWorkerRow">exampleWorkerRow	| table row |	table := self tableNamed: 'GLORP_WORKER'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 1234.	row at: (table fieldNamed: 'NAME') put: 'John Worker'.	^row.</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('GLORP_WORKER' 'GLORP_JOB' 'GLORP_WORKER_JOB_LINK').</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: GlorpJob;		add: GlorpWorker;		yourself</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels" selector="tableForGLORP_JOB:">tableForGLORP_JOB: aTable	| ownerId |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'DESCRIPTION' type: (platform varChar: 40).	aTable createFieldNamed: 'FINISHED' type: (platform varChar: 1).	ownerId := aTable createFieldNamed: 'OWNER_ID' type: platform int4.	aTable addForeignKeyFrom: ownerId		to: ((self tableNamed: 'GLORP_WORKER') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForGLORP_WORKER:">tableForGLORP_WORKER: aTable	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body><body package="GlorpTestModels" selector="tableForGLORP_WORKER_JOB_LINK:">tableForGLORP_WORKER_JOB_LINK: aTable	| workerId jobId |	workerId := aTable createFieldNamed: 'WORKER_ID' type: platform int4.	aTable addForeignKeyFrom: workerId		to: ((self tableNamed: 'GLORP_WORKER') fieldNamed: 'ID').	jobId := aTable createFieldNamed: 'JOB_ID' type: platform int4.	aTable addForeignKeyFrom: jobId		to: ((self tableNamed: 'GLORP_JOB') fieldNamed: 'ID').	aTable createFieldNamed: 'PRIORITY' type: (platform varChar: 1).</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels" selector="descriptorForGlorpJob:">descriptorForGlorpJob: aDescriptor 	"Note that the job table contains a FINISHED field, but the GlorpJob object doesn't. This field is determined only by membership in the finished or pending collections. In this particular case it's not very useful from a domain perspective, but it's interesting to be able to map. Similarly, whether a job is priority or not is not in the domain object, and is stored in the link table defining the relationship"	| table |	table := self tableNamed: 'GLORP_JOB'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id				to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #description				to: (table fieldNamed: 'DESCRIPTION')).</body><body package="GlorpTestModels" selector="descriptorForGlorpWorker:">descriptorForGlorpWorker: aDescriptor 	| table linkTable |	table := self tableNamed: 'GLORP_WORKER'.	aDescriptor table: table.	aDescriptor 		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor 		addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: ((OneToManyMapping new)				attributeName: #pendingJobs;				referenceClass: GlorpJob;				join: (self workerCriteriaWithConstant: 'N' in: table)).	aDescriptor addMapping: ((OneToManyMapping new)				attributeName: #finishedJobs;				referenceClass: GlorpJob;				join: (self workerCriteriaWithConstant: 'Y' in: table)).	linkTable := self tableNamed: 'GLORP_WORKER_JOB_LINK'.	"Note that priorityJobs may include finished jobs as well, and instances may occur in both this collection and the other two"	aDescriptor addMapping: ((ManyToManyMapping new)				attributeName: #priorityJobs;				referenceClass: GlorpJob;				join: (Join 							from: (table fieldNamed: 'ID')							to: (linkTable fieldNamed: 'WORKER_ID')							from: 'Y'							to: (linkTable fieldNamed: 'PRIORITY'))).</body><body package="GlorpTestModels" selector="workerCriteriaWithConstant:in:">workerCriteriaWithConstant: aString in: table 	^Join 		from: (table fieldNamed: 'ID')		to: ((self tableNamed: 'GLORP_JOB') fieldNamed: 'OWNER_ID')		from: aString		to: ((self tableNamed: 'GLORP_JOB') fieldNamed: 'FINISHED').</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>accessing</category><body package="GlorpDBTests" selector="accessor">accessor	^GlorpMockAccessor new.</body><body package="GlorpDBTests" selector="rows">rows	^rows.</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>initialize</category><body package="GlorpDBTests" selector="initialize">initialize	super initialize.	rows := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>testing</category><body package="GlorpDBTests" selector="useBinding">useBinding	^true.</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>read/write</category><body package="GlorpDBTests" selector="writeHomogeneousRows:">writeHomogeneousRows: aCollection	aCollection do: [:each | self writeRow: each].	^true.</body><body package="GlorpDBTests" selector="writeRow:">writeRow: aRow	aRow shouldBeWritten ifFalse: [^true].	aRow preWriteAssignSequencesUsing: self.	rows add: aRow.	aRow postWriteAssignSequencesUsing: self accessor.	^true.</body></methods><methods><class-id>Glorp.GlorpMockSession class</class-id> <category>instance creation</category><body package="GlorpDBTests" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpProxyTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testAdHocProxy">testAdHocProxy	"Some dialects (e.g. VA) inline yourself so we must send yourSelf."	| p |	p := AdHocProxy readBlock: ['instantiated!'].	self assert: p printString = '{uninstantiated AdHocProxy}'.	self assert: p isInstantiated not.	p yourSelf.	self assert: p isInstantiated.	self assert: p printString = '{''instantiated!''}'.	p uninstantiate.	self deny: p isInstantiated.</body><body package="GlorpDBTests" selector="testCreation">testCreation	| otherProxy |	self deny: proxy isInstantiated.	otherProxy := Proxy new.	self deny: otherProxy isInstantiated.</body><body package="GlorpDBTests" selector="testInstantiationFromStub">testInstantiationFromStub	self assert: (proxy getValue notNil).	self assert: proxy = 42.	self assert: proxy isInstantiated.</body><body package="GlorpDBTests" selector="testPrintingInstantiated">testPrintingInstantiated	proxy getValue.	self assert: proxy printString = ('{', proxy getValue printString, '}').</body><body package="GlorpDBTests" selector="testPrintingUninstantiated">testPrintingUninstantiated	self assert: proxy printString = '{uninstantiated GlorpAddress}'.</body><body package="GlorpDBTests" selector="testPrintingUninstantiatedCollection">testPrintingUninstantiatedCollection	proxy query readsOneObject: false.	self assert: proxy printString = '{uninstantiated collection of GlorpAddress}'.</body></methods><methods><class-id>Glorp.GlorpProxyTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	| stub |	super setUp.	session := GlorpSessionResource current newSession.	proxy := Proxy new.	proxy session: session.	stub := GlorpQueryStub returningOneOf: GlorpAddress where: [:address | address id = 1].	stub result: 42.	proxy query: stub.	proxy parameters: #().</body></methods><methods><class-id>Glorp.GlorpProxyTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpNumeric52Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testNumeric52">testNumeric52	self platform supportsVariableSizedNumerics ifFalse: [^self].	self helpTestFloat: nil.	self helpTestFloat: 12.	self helpTestFloat: 321.12.	self helpTestInvalidValue: 17.098.	self helpTestFloat: 3.14.	self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 12).	self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 321.12).	self helpTestInvalidValue: (Dialect coerceToDoublePrecisionFloat: 17.098).	self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 3.14).	self helpTestFloat: (Dialect readFixedPointFrom: '321.12').	self helpTestInvalidValue: (Dialect readFixedPointFrom: '321.123').	self helpTestFloat: (Dialect readFixedPointFrom: '3.14').	self helpTestFloat: (Dialect readFixedPointFrom: '3.1' ).</body></methods><methods><class-id>Glorp.GlorpNumeric52Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^(self platform numeric)		precision: 5;		scale: 2.</body></methods><methods><class-id>Glorp.GlorpFolder</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	user := nil.	messages := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpFolder</class-id> <category>accessing</category><body package="GlorpTestModels" selector="messages">messages	^messages</body><body package="GlorpTestModels" selector="messages:">messages: aCollection	messages := aCollection</body><body package="GlorpTestModels" selector="name">name	^name.</body><body package="GlorpTestModels" selector="name:">name: aString	name := aString.</body><body package="GlorpTestModels" selector="user">user	^user</body><body package="GlorpTestModels" selector="user:">user: aGlorpUser	user := aGlorpUser</body><body package="GlorpTestModels" selector="userId">userId	^self user id.</body></methods><methods><class-id>Glorp.GlorpFolder class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpBlobTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform blob.</body></methods><methods><class-id>Glorp.GlorpBlobTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="adjustForMaximumSize:">adjustForMaximumSize: anObject	^anObject.</body><body package="GlorpDBTypeTests" selector="blob255">blob255	^ByteArray withAll: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255)</body><body package="GlorpDBTypeTests" selector="largeBlob">largeBlob	"Make a significant sized blob. 64k+ a bit should do"	| blobStream |	blobStream := WriteStream on: (ByteArray new: 10000).	(((2 raisedTo: 16) + 100.0) / 255.0) ceiling timesRepeat: [		blobStream nextPutAll: self blob255].	^blobStream contents.</body><body package="GlorpDBTypeTests" selector="mediumlargeBlob">mediumlargeBlob	"Make a Blob just under 32K in size"	"self new mediumlargeBlob"	| blobStream |	blobStream := WriteStream on: (ByteArray new: 10000).	(((2 raisedTo: 15) - 600.0) / 255.0) ceiling timesRepeat: [		blobStream nextPutAll: self blob255].	^blobStream contents.</body><body package="GlorpDBTypeTests" selector="testBlob">testBlob	self helpTestValue: nil.	self helpTestValue: (ByteArray withAll: #(1 2 3 4 255)).	stType := String.	self helpTestValue: 'abcdef'.</body><body package="GlorpDBTypeTests" selector="testBlobWithSubstring">testBlobWithSubstring	"Test our ability to query with substring against a blob. This is severely limited in Postgresql, and may be limited in others.	The compare blocks once looked clean, like this:		[:each | (each test copyFrom: 1 to: 3) = 'hgf'].	but the DB2 compare blocks would need to look like this:		[:each | (each test copyFrom: 1 to: 3) like: 'hgf'].	Rather than duplicate the blocks, the operator was switched to:		[:each | (each test copyFrom: 1 to: 3) perform: compare with: 'hgf'].	which results in the desired SQL, although in code it looks unpleasant."	| result system compare |	session platform supportsStringQueryOnBlobs ifFalse: [^self knownFailure].	compare := session platform isDB2Platform		ifTrue: [ #like: ]		ifFalse: [ #= ].	stType := String.	self inTransactionDo: [		system := self systemFor: table.		session system: system.		session inUnitOfWorkDo: [			| model |			model := GlorpTypeTestsModelClass new test: 'hgfedcbazyx'.			session register: model].		session reset.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 1 to: 3) perform: compare with: 'hgf'].		self assert: result size = 1.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 1 to: 3) perform: compare with: 'abc'].		self assert: result size = 0.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 4 to: 6) perform: compare with: 'edc'].		self assert: result size = 1.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 7 to: 9) perform: compare with: 'baz'].		self assert: result size = 1.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 1 to: 6) perform: compare with: 'hgfedc'].		self assert: result size = 1].</body><body package="GlorpDBTypeTests" selector="testDefaultBlobPrinting">testDefaultBlobPrinting	"Test out default (SQL-92 syntax) byte array printing"	| stream |	stream := WriteStream on: String new.	type := type copy.	type platform: DatabasePlatform new.	type print: (ByteArray with: 0) on: stream.	self assert: stream contents = 'X''00'''.	stream reset.	type print: (ByteArray with: 16rFF) on: stream.	self assert: stream contents = 'X''FF'''.	stream reset.	type print: (ByteArray with: 16r47) on: stream.	self assert: stream contents = 'X''47'''.	stream reset.	type print: (ByteArray withAll: #(1 2 16rFE)) asByteArray on: stream.	self assert: stream contents = 'X''0102FE'''.</body><body package="GlorpDBTypeTests" selector="testLargeBlob">testLargeBlob	| blob |	blob := self mediumlargeBlob.	(session platform useBinding not and: [blob size &gt; session platform maximumQueryValueSize])		ifTrue: [Transcript cr; show: '******* Skipping large unbound blob test']		ifFalse: [self helpTestValue: blob].	blob := self largeBlob.	(session platform useBinding not and: [blob size &gt; session platform maximumQueryValueSize])		ifFalse: [self helpTestValue: blob].</body></methods><methods><class-id>Glorp.GlorpObjectMappedToImaginaryTableTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="queryForComplexSubselectRead2:">queryForComplexSubselectRead2: anInteger	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table. The gist of the query is stores where more than anInteger different customers have made rentals"	| q1 q2 q3 |	q1 := Query		readManyOf: GlorpVideoStore		where: [:store | 			q2 := Query				count: GlorpVideoCustomer				where: [:customer | 					q3 := Query						readManyOf: GlorpVideoRental						where: [:rental | rental customer = customer AND: (rental store = store)].					q3 retrieve: [:trade | trade customerName].					customer name in: q3].			(store getConstant: anInteger) &lt;= q2].	^q1.</body><body package="GlorpDBTests" selector="queryForComplexSubselectRead:">queryForComplexSubselectRead: anInteger	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table. The gist of the query is stores where more than anInteger different customers have made rentals"	| q1 q2 q3 |	q1 := Query		readManyOf: GlorpVideoStore		where: [:store | 			q2 := Query				count: GlorpVideoCustomer				where: [:customer | 					q3 := Query						readManyOf: GlorpVideoRental						where: [:rental | rental store = store].					q3 retrieve: [:trade | trade customerName].					customer name in: q3].			(store getConstant: anInteger) &lt;= q2].	^q1.</body><body package="GlorpDBTests" selector="testComplexSubselectRead">testComplexSubselectRead	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table"	| |	self assert: (session execute: (self queryForComplexSubselectRead: 3)) size = 1.	self assert: (session execute: (self queryForComplexSubselectRead: 4)) size = 0.</body><body package="GlorpDBTests" selector="testComplexSubselectRead2">testComplexSubselectRead2	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table"	| |	self assert: (session execute: (self queryForComplexSubselectRead2: 1)) size = 1.	self assert: (session execute: (self queryForComplexSubselectRead2: 0)) size = 2.</body><body package="GlorpDBTests" selector="testReadBackAllCustomer">testReadBackAllCustomer	| customers |	customers := session readManyOf: GlorpVideoCustomer.	self assert: ((customers collect: [:each | each name]) asSortedCollection asArray) = #('Adrian' 'Bob' 'Carol' 'David' 'Eleanor' 'Francois' 'George' 'Hieronymous').</body><body package="GlorpDBTests" selector="testReadBackEntireExample">testReadBackEntireExample	| store |	store := session readOneOf: GlorpVideoStore where: [:each | each id = 1].	example assertEqual: store.</body><body package="GlorpDBTests" selector="testReadCustomerWhere">testReadCustomerWhere	| customers |	customers := session readManyOf: GlorpVideoCustomer where: [:each | each name like: '%an%'].	self assert: ((customers collect: [:each | each name]) asSortedCollection asArray) = #('Adrian'  'Eleanor' 'Francois').</body><body package="GlorpDBTests" selector="testReadCustomerWhereWithJoin">testReadCustomerWhereWithJoin	| customers |	customers := session readManyOf: GlorpVideoCustomer where: [:each | each onlinePurchases anySatisfy: [:eachPurchase | eachPurchase price &gt; 2]].	self assert: ((customers collect: [:each | each name]) asSortedCollection asArray) = #('Adrian'  'George' ).</body><body package="GlorpDBTests" selector="testSelectByBoolean">testSelectByBoolean	| inStore notInStore inStoreImplied notInStoreImplied |	inStore := session read: GlorpVideoPurchase where: [:each | each inStore = true].	notInStore := session read: GlorpVideoPurchase where: [:each | each inStore = false].	self assert: inStore size = 7.	self assert: notInStore size = 3.	inStoreImplied := session read: GlorpVideoPurchase where: [:each | each inStore].	notInStoreImplied := session read: GlorpVideoPurchase where: [:each | each inStore not].	self assert: inStoreImplied size = 7.	self assert: notInStoreImplied size = 3.</body><body package="GlorpDBTests" selector="testWrite">testWrite	"Write and validate that it basically got written correctly, in terms of number and keys of db rows"	| storeRows storeRow purchaseRows purchaseKeys rentalRows rentalKeys |	storeRows := session accessor		executeSQLString: 'SELECT * FROM VIDEO_STORE'.	storeRows := storeRows asSortedCollection: [:a :b | a first &lt;= b first].	self assert: storeRows size = 2.	storeRow := storeRows first.	self assert: storeRow size = 2.	self assert: storeRow first = 1.	self assert: storeRow last = 'Als Video'.	storeRow := storeRows last.	self assert: storeRow first = 2.	self assert: storeRow last = 'Bonzai Video'.	purchaseRows := session accessor		executeSQLString: 'SELECT * FROM VIDEO_PURCHASE'.	self assert: purchaseRows size = 10.	purchaseKeys := (purchaseRows collect: [:each | each atIndex: 1])		asSortedCollection.	self assert: purchaseKeys asArray = #(1 2 3 101 102 103 104 105 106 107).	rentalRows := session accessor		executeSQLString: 'SELECT * FROM VIDEO_RENTAL'.	self assert: rentalRows size = 4.	rentalKeys := (rentalRows collect: [:each | each atIndex: 1])		asSortedCollection.	self assert: rentalKeys asArray = #(1001 1002 1003 1004).</body></methods><methods><class-id>Glorp.GlorpObjectMappedToImaginaryTableTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	system := GlorpVideoDescriptorSystem forPlatform: session platform.	session system: system.	session beginTransaction.	example := system exampleStore1.	example2 := system exampleStore2.	session inUnitOfWorkDo: [session register: example. session register: example2.].	session reset.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpQueryUnionTest</class-id> <category>tests-functional</category><body package="GlorpDBTests" selector="testBasicExcept">testBasicExcept	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	query2 := Query returningManyOf: GlorpAddress where: [:each | each id = 2].		union := query1 except: query2.	result := session execute: union.	self assert: result size = 1.</body><body package="GlorpDBTests" selector="testBasicExcept2">testBasicExcept2	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id in: #(1 2)].		query2 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	union := query1 except: query2.	result := session execute: union.	self assert: result size = 1.	self assert: result first id = 2.</body><body package="GlorpDBTests" selector="testBasicExcept3">testBasicExcept3	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	query2 := Query returningManyOf: GlorpAddress where: [:each | each street = 'Alpha'].		union := query1 except: query2.	result := session execute: union.	self assert: result size = 0.</body><body package="GlorpDBTests" selector="testBasicIntersect">testBasicIntersect	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	query2 := Query returningManyOf: GlorpAddress where: [:each | each id = 2].		union := query1 intersect: query2.	result := session execute: union.	self assert: result size = 0.</body><body package="GlorpDBTests" selector="testBasicIntersect2">testBasicIntersect2	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	query2 := Query returningManyOf: GlorpAddress where: [:each | each id in: #(1 2)].		union := query1 intersect: query2.	result := session execute: union.	self assert: result size = 1.</body><body package="GlorpDBTests" selector="testBasicIntersect3">testBasicIntersect3	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	query2 := Query returningManyOf: GlorpAddress where: [:each | each street = 'Alpha'].		union := query1 intersect: query2.	result := session execute: union.	self assert: result size = 1.</body><body package="GlorpDBTests" selector="testBasicUnion">testBasicUnion	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	query2 := Query returningManyOf: GlorpAddress where: [:each | each id = 2].		union := query1 unionAll: query2.	result := session execute: union.	self assert: result size = 2.	self assert: result first id = 1.	self assert: result last id = 2.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests" selector="testOrderByInUnion">testOrderByInUnion	| query1 query2 union result |	self writePeople.	query1 := Query returningManyOf: GlorpAddress where: [:each | each id &gt; 1].	query1 retrieve: #id.	query2 := Query returningManyOf: GlorpPerson.	query2 retrieve: [:each | each id].	union := query1 unionAll: query2.	union orderBy: [:each | each id descending].	result := session execute: union.	self assert: result = #(87 86 3 2).</body><body package="GlorpDBTests" selector="testThreeWayUnion">testThreeWayUnion	| query1 query2 union result query3 |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	query2 := Query returningManyOf: GlorpAddress where: [:each | each id = 2].		query3 := Query returningManyOf: GlorpAddress where: [:each | each id = 3].		union := (query1 unionAll: query2) unionAll: query3.	union orderBy: [:each | each id].	result := session execute: union.	self assert: result size = 3.	self assert: result first id = 1.	self assert: result last id = 3.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests" selector="testUnionWithEmpty">testUnionWithEmpty	| query1 query2 union result |	query1 := Query returningManyOf: GlorpAddress where: false.	query2 := Query returningManyOf: GlorpAddress where: [:each | each id = 2].		union := query1 unionAll: query2.	result := session execute: union.	self assert: result size = 1.	self assert: result first id = 2.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests" selector="testUnionWithParameters">testUnionWithParameters	| query1 query2 union result field1 dict |	field1 := (system tableNamed: 'GR_ADDRESS') fieldNamed: 'ID'.	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = (each parameter: field1)].	query2 := Query returningManyOf: GlorpAddress where: [:each | each id = ((each parameter: field1) + 1)].		union := query1 unionAll: query2.	union orderBy: [:each | each id].	dict := Dictionary new at: field1 put: 2; yourself.	result := union executeWithParameters: dict in: session.	self assert: result size = 2.	self assert: result first id = 2.	self assert: result last id = 3.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests" selector="testUnionWithRetrieveDisaparateResults">testUnionWithRetrieveDisaparateResults	| query1 query2 union result |	self writePeople.	query1 := Query returningManyOf: GlorpAddress.	query1 retrieve: #id.	query2 := Query returningManyOf: GlorpPerson.	query2 retrieve: #id.	union := query1 unionAll: query2.	result := session execute: union.	self assert: result asSortedCollection asArray = #(1 2 3 86 87).</body><body package="GlorpDBTests" selector="testUnionWithRetrieveThoroughlyDisaparateResults">testUnionWithRetrieveThoroughlyDisaparateResults	"Fields from mismatched tables"	| query1 query2 union result |	self writePeople.	query1 := Query returningManyOf: GlorpAddress.	query1 retrieve: [:each | each street].	query2 := Query returningManyOf: GlorpPerson.	query2 retrieve: [:each | each name].	union := query1 unionAll: query2.	result := session execute: union.	self assert: result asSortedCollection asArray = #('Alpha' 'Beta' 'Gamma' 'person1' 'person2').</body><body package="GlorpDBTests" selector="testUnionWithRetrieveThoroughlyDisaparateResults2">testUnionWithRetrieveThoroughlyDisaparateResults2	"The tables will get aliased differently, make sure that works"	| query1 query2 union result |	self writePeople.	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 2].	query1 retrieve: [:each | each street].	query2 := Query returningManyOf: GlorpPerson where: [:each | each id = 87].	query2 retrieve: [:each | each address street].	union := query1 unionAll: query2.	result := session execute: union.	self assert: result asSortedCollection asArray = #('Beta' 'Gamma').</body></methods><methods><class-id>Glorp.GlorpQueryUnionTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session beginTransaction.	self writeAddressOrderingRows.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests" selector="writeAddressOrderingRows">writeAddressOrderingRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.</body><body package="GlorpDBTests" selector="writePeople">writePeople	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.</body></methods><methods><class-id>Glorp.GlorpQueryUnionTest</class-id> <category>tests-unit</category><body package="GlorpDBTests" selector="testCompoundCommandCreate">testCompoundCommandCreate	| query1 union command |	query1 := Query returningManyOf: GlorpAddress.	union := query1 unionAll: query1.	union session: session.	command := union sqlWith: #().	self assert: command class == CompoundSelectCommand.</body><body package="GlorpDBTests" selector="testCreateCompoundQuery">testCreateCompoundQuery	| query1 union |	query1 := Query returningManyOf: GlorpAddress.	union := query1 unionAll: query1.	self assert: union class == CompoundQuery.</body><body package="GlorpDBTests" selector="testUnionSQL">testUnionSQL	"Use expandMacros to avoid platform-specific line-end conventions blocking string matching."	| query1 union command |	query1 := Query returningManyOf: GlorpAddress where: [:each | each id = 1].	union := query1 unionAll: query1.	union session: session.	command := union sqlWith: #().	self assert: ('SELECT * FROM (*SELECT *&lt;n&gt; FROM GR_ADDRESS t1&lt;n&gt; WHERE *t1.ID = * UNION ALL *SELECT *&lt;n&gt; FROM GR_ADDRESS t1&lt;n&gt; WHERE *t1.ID = *' expandMacros match: command sqlString).</body></methods><methods><class-id>Glorp.GlorpDocument</class-id> <category>accessing</category><body package="GlorpTestModels" selector="attachments">attachments	^attachments</body><body package="GlorpTestModels" selector="attachments:">attachments: anObject	attachments := anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpDocument</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	attachments := OrderedCollection new.	whatever := 3.</body></methods><methods><class-id>Glorp.GlorpDocument class</class-id> <category>glorp</category><body package="GlorpTestModels" selector="glorpSetupClassModel:forSystem:">glorpSetupClassModel: model forSystem: system 	model		newAttributeNamed: #id;		newAttributeNamed: #whatever;		newAttributeNamed: #attachments			collection: OrderedCollection			of: GlorpAttachment</body><body package="GlorpTestModels" selector="glorpSetupDescriptor:forSystem:">glorpSetupDescriptor: aDesc forSystem: system 	| t |	t := system tableNamed: 'document'.	aDesc table: t.	(aDesc newMapping: DirectMapping) from: #id to: (t fieldNamed: 'id').	(aDesc newMapping: DirectMapping) from: #whatever to: (t fieldNamed: 'whatever').	(aDesc newMapping: OneToManyMapping)		attributeName: #attachments;		orderBy: [:ea | ea index]</body></methods><methods><class-id>Glorp.GlorpExpressionBasicPropertiesTest</class-id> <category>tests</category><body package="GlorpTests" selector="testHasDescriptorForBase">testHasDescriptorForBase	| exp |	self assert: base hasDescriptor.	exp := [:a | a ] asGlorpExpressionOn: base.	self assert: exp hasDescriptor.</body><body package="GlorpTests" selector="testHasDescriptorForDirect">testHasDescriptorForDirect	| exp |	exp := [:a | a id ] asGlorpExpressionOn: base.	self deny: exp hasDescriptor.</body><body package="GlorpTests" selector="testHasDescriptorForOneToMany">testHasDescriptorForOneToMany	| exp |	exp := [:a | a emailAddresses ] asGlorpExpressionOn: base.	self assert: exp hasDescriptor.</body><body package="GlorpTests" selector="testHasDescriptorForOneToOne">testHasDescriptorForOneToOne	| exp |	exp := [:a | a address ] asGlorpExpressionOn: base.	self assert: exp hasDescriptor.</body><body package="GlorpTests" selector="testHasDescriptorForPrimaryKeyExpression">testHasDescriptorForPrimaryKeyExpression	| exp |	exp := Join new.	self deny: exp hasDescriptor.</body><body package="GlorpTests" selector="testHasDescriptorForRelation">testHasDescriptorForRelation	| exp |	exp := [:a | a = 3] asGlorpExpressionOn: base.	self deny: exp hasDescriptor.</body><body package="GlorpTests" selector="testHasDescriptorForTwoLevelDirect">testHasDescriptorForTwoLevelDirect	| exp |	exp := [:a | a address street] asGlorpExpressionOn: base.	self deny: exp hasDescriptor.	self assert: exp base hasDescriptor.</body><body package="GlorpTests" selector="testHasDescriptorForUninitializedBase">testHasDescriptorForUninitializedBase	self deny: BaseExpression new hasDescriptor.</body></methods><methods><class-id>Glorp.GlorpExpressionBasicPropertiesTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	base := BaseExpression new descriptor: (		(GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database)			descriptorFor: GlorpPerson)</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: aSmallInteger 	id := aSmallInteger.</body><body package="GlorpTestModels" selector="mediaType">mediaType	^mediaType</body><body package="GlorpTestModels" selector="mediaType:">mediaType: anObject	mediaType := anObject</body><body package="GlorpTestModels" selector="text">text	^text</body><body package="GlorpTestModels" selector="text:">text: aString 	text := aString.</body><body package="GlorpTestModels" selector="title">title	^title</body><body package="GlorpTestModels" selector="title:">title: aString 	title := aString</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	title isNil ifFalse: [aStream nextPutAll: title].	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	mediaType := GlorpMediaType text</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		id: 1;		name: 'One';		text: 'The first number (not counting zero)'.</body><body package="GlorpTestModels" selector="example2">example2	^self new		id: 2;		name: 'Two';		text: 'The second number (comes after 1)'.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry class</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="new">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpCoreExtensionsTest</class-id> <category>tests</category><body package="GlorpTests" selector="testGlorpIsCollection">testGlorpIsCollection	self deny: Object new glorpIsCollection.	self assert: Collection new glorpIsCollection</body></methods><methods><class-id>Glorp.GlorpBooleanTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testBoolean">testBoolean	stType := Boolean.	self helpTestValue: nil compareWith: [:read :original |		self platform usesNullForFalse ifTrue: [read = false] ifFalse: [read = nil]].	self helpTestValue: true.	self helpTestValue: false.</body></methods><methods><class-id>Glorp.GlorpBooleanTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform boolean.</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="addInStorePurchase:">addInStorePurchase: aPurchase	inStorePurchases add: aPurchase.	aPurchase customer: self.</body><body package="GlorpTestModels" selector="addOnlinePurchase:">addOnlinePurchase: aPurchase	onlinePurchases add: aPurchase.	aPurchase customer: self.</body><body package="GlorpTestModels" selector="addRental:">addRental: aRental	inStoreRentals add: aRental.	aRental customer: self.</body><body package="GlorpTestModels" selector="dateOfBirth">dateOfBirth	^dateOfBirth.</body><body package="GlorpTestModels" selector="dateOfBirth:">dateOfBirth: aDate	dateOfBirth := aDate.</body><body package="GlorpTestModels" selector="name">name	^name.</body><body package="GlorpTestModels" selector="name:">name: aString	name := aString.</body><body package="GlorpTestModels" selector="purchases">purchases	^inStorePurchases, onlinePurchases.</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>accessing</category><body package="GlorpTestModels" selector="creditStatus">creditStatus	^creditStatus</body><body package="GlorpTestModels" selector="creditStatus:">creditStatus: aCreditStatus	creditStatus := aCreditStatus.	creditStatus isNil ifFalse: [creditStatus customer: self].</body><body package="GlorpTestModels" selector="inStorePurchases">inStorePurchases	^inStorePurchases</body><body package="GlorpTestModels" selector="inStorePurchases:">inStorePurchases: anObject	inStorePurchases := anObject</body><body package="GlorpTestModels" selector="inStoreRentals">inStoreRentals	^inStoreRentals.</body><body package="GlorpTestModels" selector="onlinePurchases">onlinePurchases	^onlinePurchases</body><body package="GlorpTestModels" selector="onlinePurchases:">onlinePurchases: anObject	onlinePurchases := anObject</body><body package="GlorpTestModels" selector="store:">store: anObject	store := anObject</body><body package="GlorpTestModels" selector="videoStore">videoStore	^store</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	onlinePurchases := OrderedCollection new.	inStorePurchases :=OrderedCollection new.	inStoreRentals := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>testing</category><body package="GlorpTestModels" selector="assertEqual:">assertEqual: aCustomer	onlinePurchases assertEqual: aCustomer onlinePurchases.	inStorePurchases assertEqual: aCustomer inStorePurchases.	inStoreRentals assertEqual: aCustomer inStoreRentals.	creditStatus assertEqual: aCustomer creditStatus.	self assert: store id = aCustomer videoStore id.	self assert: name = aCustomer name.	self assert: dateOfBirth = aCustomer dateOfBirth.</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: (name isNil ifTrue: [''] ifFalse: [name]).	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>comparing</category><body package="GlorpTestModels" selector="&lt;=">&lt;= aVideoCustomer	^self name &lt; aVideoCustomer name	or: [self name = aVideoCustomer name		and: [self dateOfBirth &lt;= aVideoCustomer dateOfBirth]]</body></methods><methods><class-id>Glorp.GlorpVideoCustomer class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpDatabasePlatformTest</class-id> <category>tests</category><body package="GlorpTests" selector="addToString:">addToString: aString	"Append a couple of special characters. The result will utf-8 encode to be 3 characters longer than its number of characters"	^aString, (String with: (Character value: 16r2022) "bullet point" with: (Character value: 16r0131) "Turkish i with no dot")"If PostgreSQL, or another DB returning true to measuresStringFieldWidthsInBytes, is provided in VA, this test must alter tohandle incompatible protocol between VW, which lacks Character&gt;&gt;asString and VA, in which String&gt;&gt;with:with: will not handledouble-byte entries.  The VA could be implemented as	^aString, (Character value: 16r2022) asString, (Character value: 16r0131) asString"</body><body package="GlorpTests" selector="helpTestPrintTimestamp:">helpTestPrintTimestamp: aTimestampString	| aStream ts timestamp |	ts := DatabasePlatform new readTimestamp: aTimestampString for: nil.	aStream := WriteStream on: String new.	DatabasePlatform new printDate: ts isoFormatOn: aStream.	aStream nextPut: Character space.	DatabasePlatform new printTime: ts isoFormatOn: aStream milliseconds: true.	timestamp := aStream contents.	self assert: timestamp = aTimestampString.</body><body package="GlorpTests" selector="string20">string20	| platform |	platform := Dialect isVisualAge		ifTrue:			[Transcript cr; show: self class name, '&gt;&gt;string20: testing Oracle, not PostgreSQL'.			OraclePlatform new]		ifFalse: [PostgreSQLPlatform new].	platform characterEncoding: #'utf-8'.	^platform varchar: 20.</body><body package="GlorpTests" selector="testNumericCoercion">testNumericCoercion	| type platform num |	type := GlorpNumericType new scale: 5; precision: 2.	platform := DatabasePlatform new.	num := Dialect coerceToDoublePrecisionFloat: (123456 / 100).	self assert: (platform convertToNumber: num for: type) = num.	num := Dialect coerceToDoublePrecisionFloat: (123450 / 100).	self assert: (platform convertToNumber: num for: type) = num.	num := Dialect coerceToDoublePrecisionFloat: (123450 / 1000).	self assert: (platform convertToNumber: num for: type) = num.	num := Dialect coerceToDoublePrecisionFloat: (123456 / 1000).	self deny: (platform convertToNumber: num for: type) = num.</body><body package="GlorpTests" selector="testPrintTimestamp">testPrintTimestamp	| strings |	strings := #( '2005-01-01 21:29:28.337'  '2005-01-01 01:02:00.037'  '2005-01-01 21:29:28.002'  '2005-01-01 21:29:28.001').	strings do: [:each |		self helpTestPrintTimestamp: each].</body><body package="GlorpTests" selector="testReadTimestamp">testReadTimestamp	| ts |	ts := DatabasePlatform new readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self assert: ts asSeconds = 3224158168.	self assert: ([ts asMilliseconds = 3224158168337 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #asMilliseconds ]).	ts := DatabasePlatform new readTimestamp: '2003-03-13 15:29:28.337-05' for: nil.	self assert: ts asSeconds = 3225022168.	self assert: ([ts asMilliseconds = 3225022168337]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #asMilliseconds ])</body><body package="GlorpTests" selector="testReadTimestampNoMS">testReadTimestampNoMS	| ts |	ts := DatabasePlatform new readTimestamp: '2003-03-03 15:29:28-05' for: nil.	self assert: ts year = 2003.	self assert: ts monthIndex = 3.	self assert: ts dayOfMonth = 3.	self assert: ts hour = 15.	self assert: ts minute = 29.	self assert: ts second truncated = 28.	self assert: ([ ts milliseconds = 0 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests" selector="testReadTimestampNoMSNoTZ">testReadTimestampNoMSNoTZ	| ts |	ts := DatabasePlatform new readTimestamp: '2003-03-03 15:29:28' for: nil.	self assert: ts year = 2003.	self assert: ts monthIndex = 3.	self assert: ts dayOfMonth = 3.	self assert: ts hour = 15.	self assert: ts minute = 29.	self assert: ts second truncated = 28.	self assert: ([ ts milliseconds = 0 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests" selector="testReadTimestampNoTZ">testReadTimestampNoTZ	| ts |	ts := DatabasePlatform new readTimestamp: '1975-08-13 21:29:28.337' for: nil.	self assert: ts year = 1975.	self assert: ts monthIndex = 8.	self assert: ts dayOfMonth = 13.	self assert: ts hour = 21.	self assert: ts minute = 29.	self assert: ts second truncated = 28.	self assert: ([ ts milliseconds =  337]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests" selector="testReadTimestampOverflowDays">testReadTimestampOverflowDays	| ts |	ts := DatabasePlatform new readTimestamp: '1975-08-13 21:29:28.337-05' for: nil.	self assert: ts year = 1975.	self assert: ts monthIndex = 8.	self assert: ts dayOfMonth = 13.	self assert: ts hour = 21.	self assert: ts minute = 29.	self assert: ts second truncated = 28.	self assert: ([ ts milliseconds = 337 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests" selector="testTrimString1">testTrimString1	"Normal ascii"	| type plat |	type := self string20.	plat := type platform.	self assert: (plat trimString: 'abcdefghi' for: type) = 'abcdefghi'.	self assert: (plat trimString: 'abcdefghijklmnopqrst' for: type) = 'abcdefghijklmnopqrst'.	self assert: (plat trimString: 'abcdefghijklmnopqrstu' for: type) = 'abcdefghijklmnopqrst'.	self assert: (plat trimString: 'abcdefghijklmnopqrstuvwxy' for: type) = 'abcdefghijklmnopqrst'.</body><body package="GlorpTests" selector="testTrimString2">testTrimString2	"Some special characters"	| type plat string |	Dialect isVisualAge ifTrue: [Transcript cr; show: self class name; show: '&gt;&gt;testTrimString2 skipped in VA'. ^self].	type := self string20.	plat := type platform.	string := self addToString: 'abcdefghi'.	self assert: (plat trimString: string for: type) = string.	string := self addToString: 'abcdefghijklmno'.	self assert: (plat trimString: string for: type) = string.	string := self addToString: 'abcdefghijklmnop'.	self assert: (plat trimString: string for: type) = (string copyFrom: 1 to: string size -1).	string := self addToString: 'abcdefghijklmnopq'.	self assert: (plat trimString: string for: type) = (string copyFrom: 1 to: string size -1).	string := (String new: 100000) atAllPut: $a.	self assert: (plat trimString: string for: type) = 'aaaaaaaaaaaaaaaaaaaa'</body></methods><methods><class-id>Glorp.GlorpRecordWithUpdateTime</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id.</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger.</body><body package="GlorpTestModels" selector="name">name	^name.</body><body package="GlorpTestModels" selector="name:">name: aString	name := aString.</body><body package="GlorpTestModels" selector="updateSomeOtherThing">updateSomeOtherThing	^updateSomeOtherThing</body><body package="GlorpTestModels" selector="updateSomeOtherThing:">updateSomeOtherThing: aString	updateSomeOtherThing := aString</body><body package="GlorpTestModels" selector="updateTime">updateTime	^updateTime.</body></methods><methods><class-id>Glorp.GlorpTax</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject.</body><body package="GlorpTestModels" selector="supertax">supertax	^supertax</body><body package="GlorpTestModels" selector="taxes">taxes	taxes ifNil: [taxes := IdentitySet new].	^taxes.</body></methods><methods><class-id>Glorp.GlorpTax</class-id> <category>add/remove</category><body package="GlorpTestModels" selector="addTax:">addTax: aTax	self taxes add: aTax.	aTax supertax: self.</body></methods><methods><class-id>Glorp.GlorpTax</class-id> <category>private</category><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject.</body><body package="GlorpTestModels" selector="supertax:">supertax: anObject	supertax := anObject.</body></methods><methods><class-id>Glorp.GlorpTax class</class-id> <category>glorp</category><body package="GlorpTestModels" selector="glorpCommonSetupDescriptor:forSystem:">glorpCommonSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping:			((OneToManyMapping new)				attributeName: #taxes;				referenceClass: GlorpTax;				join: (Join from: (table fieldNamed: 'ID') to: (table fieldNamed: 'TAX_ID'))).	aDescriptor addMapping:			((OneToOneMapping new)				attributeName: #supertax;				referenceClass: GlorpTax;				join: (Join from: (table fieldNamed: 'TAX_ID') to: (table fieldNamed: 'ID'))).</body><body package="GlorpTestModels" selector="glorpSetupDescriptor:forSystem:">glorpSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	aDescriptor table: table.	"(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		keyedBy: 'XXX'		field: (table fieldNamed: 'TYPE')."	(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		abstract: true</body><body package="GlorpTestModels" selector="glorpTypeResolver">glorpTypeResolver	^FilteredTypeResolver forRootClass: GlorpTax.</body></methods><methods><class-id>Glorp.GlorpAdHocMappingTest</class-id> <category>tests</category><body package="GlorpTests" selector="moneyNegatingMappingTo:in:">moneyNegatingMappingTo: amountField in: aDescriptor 	mapping := aDescriptor newMapping: AdHocMapping.	mapping		forAttribute: #amount		fromDb: [:row :elementBuilder :context | (elementBuilder valueOfField: (context translateField: amountField) in: row) negated]		toDb: [:rows :attribute :attributeRows | (rows at: table) at: amountField put: attribute negated]		mappingFields: (Array with: amountField).	^mapping.</body><body package="GlorpTests" selector="testNegateMappingRead">testNegateMappingRead	| amountField inputRow builder |	descriptor := system descriptorFor: GlorpMoney.	table := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	amountField := table fieldNamed: 'AMOUNT'.	mapping := self moneyNegatingMappingTo: amountField in: descriptor.	descriptor addMapping: mapping.	money := GlorpMoney basicNew.	inputRow := #('US' 1).	builder := ElementBuilder new.	builder row: inputRow.	mapping mapObject: money inElementBuilder: builder.	self assert: money amount = -1.</body><body package="GlorpTests" selector="testNegateMappingWrite">testNegateMappingWrite	| amountField outputRow |	descriptor := system descriptorFor: GlorpMoney.	table := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	amountField := table fieldNamed: 'AMOUNT'.	mapping := self moneyNegatingMappingTo: amountField in: descriptor.	descriptor table: table.	descriptor addMapping: mapping.	money := GlorpMoney forAmount: 3.	rowMap := RowMap new.	mapping mapFromObject: money intoRowsIn: rowMap.	outputRow := rowMap rowForTable: table withKey: money.	self assert: (outputRow at: (table fieldNamed: 'AMOUNT')) = -3</body><body package="GlorpTests" selector="testSplitMappingRead">testSplitMappingRead	| inputRow builder |	money := GlorpCompressedMoney basicNew.	mapping := (system descriptorFor: GlorpCompressedMoney)		mappingForAttributeNamed: #array.	inputRow := #(432 'US' 1).	builder := ElementBuilder new.	builder row: inputRow.	mapping mapObject: money inElementBuilder: builder.	self assert: money amount = 1.	self assert: money currency = 'US'.</body><body package="GlorpTests" selector="testSplitMappingWrite">testSplitMappingWrite	| outputRow |	money := GlorpCompressedMoney currency: 'DM' amount: 99.	mapping := (system descriptorFor: GlorpCompressedMoney) 				mappingForAttributeNamed: #array.	rowMap := RowMap new.	mapping mapFromObject: money intoRowsIn: rowMap.	table := mapping descriptor primaryTable.	outputRow := rowMap rowForTable: table withKey: money.	self assert: (outputRow at: (table fieldNamed: 'AMOUNT')) = 99.	self assert: (outputRow at: (table fieldNamed: 'CURRENCY_NAME')) = 'DM'</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-read</category><body package="GlorpDBTests" selector="additionalTests">additionalTests	"It would be good to have tests here for a foreign key 'pointing' the other direction. Also composite keys (once those work)"</body><body package="GlorpDBTests" selector="testReRegisteringAfterUpdate">testReRegisteringAfterUpdate	"Test that even if we re-register the object after it's been modified, we still write the changes."	self		inTransactionDo:			[self writePersonWithAddress.			session reset.			session beginUnitOfWork.			person := (session read: GlorpPerson) first.			person name: 'new name'.			session register: person.			session commitUnitOfWork.			session reset.			self readPerson.			self assert: person name = 'new name'].</body><body package="GlorpDBTests" selector="testReadAction">testReadAction	| collection |	self		inTransactionDo:			[collection := OrderedCollection new.			self writePersonWithAddress.			((session system descriptorFor: GlorpPerson)				mappingForAttributeNamed: #address)				proxyAction: [:owner :object | collection add: owner -&gt; object].			person := session readOneOf: GlorpPerson.			person address yourSelf.			self assert: collection size = 1.			self assert: collection first = (person -&gt; person address yourSelf)].</body><body package="GlorpDBTests" selector="testReadPersonAndAddAddress">testReadPersonAndAddAddress	self inTransactionDo: [		self 			inUnitOfWorkDo: [person address: (GlorpAddress new id: 5555; street: 'hello'; number: 'world')]			initializeWith: [self writeHomelessPerson].		self readPerson.		self checkPerson].</body><body package="GlorpDBTests" selector="testReadPersonAndAddBogusCollectionInsteadOfAddress">testReadPersonAndAddBogusCollectionInsteadOfAddress	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person address: #()]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests" selector="testReadPersonAndAddBogusObjectInsteadOfAddress">testReadPersonAndAddBogusObjectInsteadOfAddress	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person address: GlorpPerson new]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests" selector="testReadPersonAndAddBogusObjectInsteadOfEmailAddresses">testReadPersonAndAddBogusObjectInsteadOfEmailAddresses	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person emailAddresses: 42]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests" selector="testReadPersonAndAddBogusObjectInsteadOfEmailAddresses2">testReadPersonAndAddBogusObjectInsteadOfEmailAddresses2	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person emailAddresses: GlorpEmailAddress new]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests" selector="testReadPersonAndRemoveAddress">testReadPersonAndRemoveAddress	self inTransactionDo: [		self inUnitOfWorkDo: [			session delete: person address.			person address: nil.].		self readPerson.		self checkPerson.		self checkNoAddress.		self checkNoAddressesInDB].</body><body package="GlorpDBTests" selector="testReadPersonAndReplaceAddress">testReadPersonAndReplaceAddress	self inTransactionDo:		[self inUnitOfWorkDo: 			[person	address: ((GlorpAddress new) id: 12; street: 'foo'; number: '1234')].		self readPerson.		self checkPerson.		self assert: person address isGlorpProxy.		self assert: person address getValue id = 12.		self assert: person address getValue street = 'foo'.].</body><body package="GlorpDBTests" selector="testReadPersonAndReplaceAdressWithDifferentProxy">testReadPersonAndReplaceAdressWithDifferentProxy	| proxy |	self inTransactionDo: 			[			session writeRow: session system exampleAddressRowForOrdering1.			self inUnitOfWorkDo: 					[ | field |					proxy := Proxy new.					proxy query: person address query copy.					field := (session system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID'.					proxy parameters: (IdentityDictionary new at: field put: 1; yourself).					proxy session: person address session.					person address: proxy].			self readPerson.			self checkPerson.			self assert: person address isGlorpProxy.			self assert: person address getValue notNil.			self assert: person address getValue id = 1]</body><body package="GlorpDBTests" selector="testReadPersonAndReplaceAdressWithProxy">testReadPersonAndReplaceAdressWithProxy	| proxy |	self inTransactionDo: 			[self inUnitOfWorkDo: 					[proxy := Proxy new.					proxy query: person address query copy.					proxy parameters: person address parameters copy.					proxy session: person address session.					person address: proxy].			self readPerson.			self checkPerson.			self assert: person address isGlorpProxy.			self assert: person address getValue notNil.			self assert: person address getValue id = 123]</body><body package="GlorpDBTests" selector="testReadPersonAndUpdateName">testReadPersonAndUpdateName	"Test to make sure that if we never instantiate the address, we don't have problems with that relationship"	self inTransactionDo:		[self inUnitOfWorkDo: 			[person	name: 'new name'].		self deny: person address isInstantiated.		session reset.		self readPerson.		self assert: person name = 'new name'.		self assert: person address isGlorpProxy.		self assert: person address getValue id = 123.		self assert: person address getValue street = 'Paseo Montril'.].</body><body package="GlorpDBTests" selector="testReadPersonWithAddress">testReadPersonWithAddress	self inTransactionDo: [		self writePersonWithAddress.		self readPerson.		self checkPerson.		self checkAddress].</body><body package="GlorpDBTests" selector="testReadPersonWithoutAddress">testReadPersonWithoutAddress	self inTransactionDo: [		self writeHomelessPerson.		self writeAddress.		self readPerson.		self checkPerson.		self checkNoAddress].</body><body package="GlorpDBTests" selector="testReadWithCacheHitFromExpression">testReadWithCacheHitFromExpression	self		inTransactionDo:			[self				inUnitOfWorkDo:					[self assert: person address yourSelf id = 123.					session accessor permitNothing.					session readOneOf: GlorpAddress where: [:each | each id = 123]]].</body><body package="GlorpDBTests" selector="testReadWithCacheHitFromJoin">testReadWithCacheHitFromJoin	self inTransactionDo: [		self 			inUnitOfWorkDo: [				session readOneOf: GlorpAddress.				session accessor permitNothing.				self assert: (person address yourSelf id = 123)]].</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="checkAddress">checkAddress	self assert: person address isGlorpProxy.	self assert: person address getValue id = 123.	^self assert: person address getValue class == GlorpAddress.</body><body package="GlorpDBTests" selector="checkNoAddress">checkNoAddress	self deny: person address isGlorpProxy.	self assert: person address == nil.</body><body package="GlorpDBTests" selector="checkNoAddressesInDB">checkNoAddressesInDB	| addresses addressKeys |	addresses := session accessor executeSQLString: 'SELECT * FROM GR_ADDRESS'.	self assert: addresses isEmpty.	addressKeys := session accessor executeSQLString: 'SELECT ADDRESS_ID FROM PERSON'.	self assert: (addressKeys size = 1).	self assert: (addressKeys first atIndex: 1) = nil.</body><body package="GlorpDBTests" selector="checkPerson">checkPerson	self assert: person class = GlorpPerson.	self assert: person id = personId.	self assert: person name = 'aPerson'.</body><body package="GlorpDBTests" selector="inUnitOfWorkDo:">inUnitOfWorkDo: aBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	self inUnitOfWorkDo: aBlock initializeWith: [self writePersonWithAddress].</body><body package="GlorpDBTests" selector="inUnitOfWorkDo:initializeWith:">inUnitOfWorkDo: aBlock initializeWith: initBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	initBlock value.	session beginUnitOfWork.	self readPerson.	aBlock value.	session commitUnitOfWork.	session reset.</body><body package="GlorpDBTests" selector="readPerson">readPerson	| results query |	query := Query		returningManyOf: GlorpPerson		where: [:pers | pers id = personId].	results := query executeIn: session.	self assert: results size = 1.	person := results first.</body><body package="GlorpDBTests" selector="writeAddress">writeAddress	| addressRow |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.</body><body package="GlorpDBTests" selector="writeHomefulPerson">writeHomefulPerson	| personRow |	personRow := session system examplePersonRow1.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests" selector="writeHomelessPerson">writeHomelessPerson	| personRow |	personRow := session system examplePersonRow2.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests" selector="writePersonWithAddress">writePersonWithAddress	self writeAddress.	self writeHomefulPerson.</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-join</category><body package="GlorpDBTests" selector="testReadPersonWithJoinToAddress">testReadPersonWithJoinToAddress	| people |	self inTransactionDo: [		self writePersonWithAddress.		people := session readManyOf: GlorpPerson where: [:eachPerson | eachPerson address street = 'Paseo Montril'].		self assert: people size = 1.		person := people first.		self assert: person address street = 'Paseo Montril'.		self assert: person address id = 123].</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-write</category><body package="GlorpDBTests" selector="testWritePersonWithAddress">testWritePersonWithAddress	|newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		personId := newPerson id.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person id = newPerson id.		self assert: person name = newPerson name.		self assert: person address id = newPerson address id.		self assert: person address street = newPerson address street].</body><body package="GlorpDBTests" selector="testWritePersonWithoutAddress">testWritePersonWithoutAddress	|newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		newPerson address: nil.		personId := newPerson id.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person id = newPerson id.		self assert: person name = newPerson name.		self assert: person address yourSelf == nil.		self checkNoAddressesInDB].</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-link table</category><body package="GlorpDBTests" selector="testLinkTableRead">testLinkTableRead	| customers |	system := GlorpLinkTableAnywhereDescriptorSystem forPlatform: system platform.	session system: system.	self inTransactionDo: [		self writeCustomersWithOneAccountEach.		session reset.		customers := session readManyOf: GlorpCustomer.		self assert: ((customers collect: [:each | each accounts id]) asSortedCollection asArray = #(22 9874))].</body><body package="GlorpDBTests" selector="testLinkTableWrite">testLinkTableWrite	system := GlorpLinkTableAnywhereDescriptorSystem		forPlatform: system platform.	session system: system.	self		inTransactionDo:			[| rows row |			self				inUnitOfWorkDo:					[| cust1 acct1 |					cust1 := GlorpCustomer new.					cust1 id: 2.					cust1 name: 'Violet Baudelaire'.					acct1 := GlorpBankAccount new.					acct1 id: 3.					cust1 accounts: acct1.					session register: cust1].			session reset.			rows := session accessor				executeSQLString:					'select * from GR_CUSTOMER t1, BANK_ACCT t2, CUSTOMER_ACCT_LINK t3 WHERE t3.ACCT_ID = t2.ID AND t3.CUSTOMER_ID = t1.ID'.			self assert: rows size = 1.			row := rows first.			self assert: (row asArray = (OrderedCollection new add: 2; add: 'Violet Baudelaire'; add: 3; add: nil; add: nil; add: nil; add: 2; add: 3; yourself) asArray)].</body><body package="GlorpDBTests" selector="writeCustomersWithOneAccountEach">writeCustomersWithOneAccountEach	| customerRow accountRow1 accountRow2 linkRow1 linkRow2 customerRow2 |	customerRow := session system exampleCustomerRow1.	customerRow2 := session system exampleCustomerRow2.	accountRow1 := session system exampleAccountRow1. 	accountRow2 := session system exampleAccountRow3.	linkRow1 := session system exampleCALinkRow1.	linkRow2 := session system exampleCALinkRow3.	session writeRow: customerRow.	session writeRow: customerRow2.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: linkRow1.	session writeRow: linkRow2.</body></methods><methods><class-id>Glorp.GlorpCollectionTypesDescriptorSystem</class-id> <category>tables</category><body package="GlorpCollectionTypeModels" selector="linkTable">linkTable	^self tableNamed: 'GR_THING_LINK'.</body><body package="GlorpCollectionTypeModels" selector="ownerTable">ownerTable	^self tableNamed: 'GR_THINGWITHCOLLECTIONS'.</body><body package="GlorpCollectionTypeModels" selector="tableForGR_THINGONE:">tableForGR_THINGONE: aTable	| setOwnerId arrayOwnerId |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	setOwnerId := aTable createFieldNamed: 'SET_OWNER' type: platform int4.	aTable addForeignKeyFrom: setOwnerId		to: (self ownerTable fieldNamed: 'ID').	arrayOwnerId := aTable createFieldNamed: 'ARRAY_OWNER' type: platform int4.	aTable addForeignKeyFrom: arrayOwnerId		to: (self ownerTable fieldNamed: 'ID').	aTable createFieldNamed: 'ARRAY_POSITION' type: platform int4.</body><body package="GlorpCollectionTypeModels" selector="tableForGR_THINGWITHCOLLECTIONS:">tableForGR_THINGWITHCOLLECTIONS: aTable	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body><body package="GlorpCollectionTypeModels" selector="tableForGR_THING_LINK:">tableForGR_THING_LINK: aTable	| ownerId thingId |	ownerId := aTable createFieldNamed: 'OWNER_ID' type: platform int4.	aTable addForeignKeyFrom: ownerId to: (self ownerTable fieldNamed: 'ID').	thingId := aTable createFieldNamed: 'THING_ID' type: platform int4.	aTable		addForeignKeyFrom: thingId		to: (self thingOneTable fieldNamed: 'ID').	aTable createFieldNamed: 'TYPE' type: (platform char: 1).	aTable createFieldNamed: 'POSITION' type: platform int4.</body><body package="GlorpCollectionTypeModels" selector="thingOneTable">thingOneTable	^self tableNamed: 'GR_THINGONE'.</body></methods><methods><class-id>Glorp.GlorpCollectionTypesDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpCollectionTypeModels" selector="descriptorForGlorpThingOne:">descriptorForGlorpThingOne: aDescriptor 	aDescriptor table: self thingOneTable.	aDescriptor addMapping: (DirectMapping from: #id to: (self thingOneTable fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (self thingOneTable fieldNamed: 'NAME')).</body><body package="GlorpCollectionTypeModels" selector="descriptorForGlorpThingWithLotsOfDifferentCollections:">descriptorForGlorpThingWithLotsOfDifferentCollections: aDescriptor	| ocMapping |	aDescriptor table: self ownerTable.	aDescriptor		addMapping:			(DirectMapping from: #id to: (self ownerTable fieldNamed: 'ID')).	aDescriptor		addMapping:			(DirectMapping from: #name to: (self ownerTable fieldNamed: 'NAME')).	aDescriptor		addMapping:			((OneToManyMapping new)				attributeName: #array;				referenceClass: GlorpThingOne;				collectionType: Array;				orderBy: [:each | (each getTable: self thingOneTable) getField: 'ARRAY_POSITION'];				writeTheOrderField;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self thingOneTable fieldNamed: 'ARRAY_OWNER'))).	aDescriptor		addMapping:			((OneToManyMapping new)				attributeName: #set;				referenceClass: GlorpThingOne;				collectionType: Set;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self thingOneTable fieldNamed: 'SET_OWNER'))).	ocMapping := ((ManyToManyMapping new)				attributeName: #orderedCollection;				referenceClass: GlorpThingOne;				collectionType: OrderedCollection;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self linkTable fieldNamed: 'OWNER_ID')								from: 'O'								to: (self linkTable fieldNamed: 'TYPE'))).	ocMapping orderBy: [:each | (each getTable: self linkTable) getField: 'POSITION'].	ocMapping writeTheOrderField.	aDescriptor addMapping: ocMapping.	aDescriptor		addMapping:			((ManyToManyMapping new)				attributeName: #bag;				referenceClass: GlorpThingOne;				collectionType: Bag;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self linkTable fieldNamed: 'OWNER_ID')								from: 'B'								to: (self linkTable fieldNamed: 'TYPE'))).	aDescriptor		addMapping:			((ManyToManyMapping new)				attributeName: #sortedCollection;				referenceClass: GlorpThingOne;				collectionType: SortedCollection;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self linkTable fieldNamed: 'OWNER_ID')								from: 'S'								to: (self linkTable fieldNamed: 'TYPE'))).</body></methods><methods><class-id>Glorp.GlorpCollectionTypesDescriptorSystem</class-id> <category>accessing</category><body package="GlorpCollectionTypeModels" selector="allTableNames">allTableNames	^#('GR_THINGWITHCOLLECTIONS' 'GR_THINGONE' 'GR_THING_LINK').</body><body package="GlorpCollectionTypeModels" selector="constructAllClasses">constructAllClasses	^super constructAllClasses add: GlorpThingWithLotsOfDifferentCollections; add: GlorpThingOne; yourself.</body></methods><methods><class-id>Glorp.GlorpNumeric5ZeroTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform numeric precision: 5; scale: 0.</body><body package="GlorpDBTypeTests" selector="testNumeric5Zero">testNumeric5Zero	self platform supportsVariableSizedNumerics ifFalse: [^self].	self helpTestFloat: nil.	self helpTestFloat: 12.		self helpTestFloat: 10991.			self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 3.0).	self helpTestInvalidValue: (Dialect coerceToDoublePrecisionFloat: 321.12).	self helpTestFloat: (Dialect readFixedPointFrom: '3.0').	self helpTestInvalidValue: (Dialect readFixedPointFrom: '321.12').	self helpTestInvalidValue: 3.14.</body></methods><methods><class-id>Glorp.GlorpVideoCreditStatus</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="balanceOwing">balanceOwing	^balanceOwing.</body><body package="GlorpTestModels" selector="balanceOwing:">balanceOwing: aNumber	balanceOwing := aNumber.</body><body package="GlorpTestModels" selector="comments">comments	^comments.</body><body package="GlorpTestModels" selector="comments:">comments: aString	comments := aString.</body><body package="GlorpTestModels" selector="customer">customer	^customer.</body><body package="GlorpTestModels" selector="customer:">customer: aCustomer	customer := aCustomer.</body><body package="GlorpTestModels" selector="dateOwing">dateOwing	^dateOwing.</body><body package="GlorpTestModels" selector="dateOwing:">dateOwing: aDate	dateOwing := aDate.</body></methods><methods><class-id>Glorp.GlorpVideoCreditStatus</class-id> <category>testing</category><body package="GlorpTestModels" selector="assertEqual:">assertEqual: aCreditStatus	self assert: customer name = aCreditStatus customer name.	self assert: customer dateOfBirth = aCreditStatus customer dateOfBirth.	self assert: balanceOwing = aCreditStatus balanceOwing.	self assert: dateOwing = aCreditStatus dateOwing.	self assert: comments = aCreditStatus comments.</body></methods><methods><class-id>Glorp.GlorpOffice</class-id> <category>accessing</category><body package="GlorpTestModels" selector="addEmployee:">addEmployee: anEmployee	self employees add: anEmployee.</body><body package="GlorpTestModels" selector="employeeOfMonth">employeeOfMonth	^employeeOfMonth</body><body package="GlorpTestModels" selector="employeeOfMonth:">employeeOfMonth: anObject	employeeOfMonth := anObject</body><body package="GlorpTestModels" selector="employees">employees	employees isNil ifTrue: [ employees := OrderedCollection new ].	^employees</body><body package="GlorpTestModels" selector="employees:">employees: anObject	employees := anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="street">street	^street</body><body package="GlorpTestModels" selector="street:">street: aString	street := aString</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels" selector="tableForEMPLOYEE:">tableForEMPLOYEE: aTable	| officeId |	aTable name: 'EMPLOYEE'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	officeId := aTable createFieldNamed: 'OFFICE_ID' type: platform int4.	aTable addForeignKeyFrom: officeId		to: ((self tableNamed: 'OFFICE') fieldNamed: 'ID').	aTable createFieldNamed: 'EMPLOYEE_TYPE' type: (platform varChar: 20).	aTable createFieldNamed: 'BRANCH' type: (platform varChar: 20).	aTable createFieldNamed: 'REGION' type: (platform varChar: 20).	aTable createFieldNamed: 'PRODUCTION_LINE' type: (platform varChar: 20).</body><body package="GlorpTestModels" selector="tableForNONPERISHABLE_ITEM:">tableForNONPERISHABLE_ITEM: aTable	aTable name: 'NONPERISHABLE_ITEM'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'SERIAL_NUMBER' type: platform int4.</body><body package="GlorpTestModels" selector="tableForOFFICE:">tableForOFFICE: aTable	| empOfMonth |	aTable name: 'OFFICE'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	empOfMonth := aTable createFieldNamed: 'EMPLOYEE_OF_MONTH' type: platform int4.	"Cheat by removing this, because it makes a cycle that we can't really handle yet"	"aTable addForeignKeyFrom: empOfMonth		to: ((self tableNamed: 'EMPLOYEE') fieldNamed: 'ID')."</body><body package="GlorpTestModels" selector="tableForPERISHABLE_ITEM:">tableForPERISHABLE_ITEM: aTable	aTable name: 'PERISHABLE_ITEM'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'AGE' type: platform int4.</body><body package="GlorpTestModels" selector="tableForPOULTRY:">tableForPOULTRY: aTable	aTable name: 'POULTRY'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'AGE' type: platform int4.	aTable createFieldNamed: 'FEATHER_COLOR' type: (platform varChar: 20).</body><body package="GlorpTestModels" selector="tableForTAX:">tableForTAX: aTable	| superTaxId |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: platform text.	aTable createFieldNamed: 'TYPE' type: (platform varchar: 16).	superTaxId := aTable createFieldNamed: 'TAX_ID' type: platform int4.	aTable addForeignKeyFrom: superTaxId to: ((self tableNamed: 'TAX') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForUNASSEMBLED_ITEM:">tableForUNASSEMBLED_ITEM: aTable	aTable name: 'UNASSEMBLED_ITEM'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'SERIAL_NUMBER' type: platform int4.	aTable createFieldNamed: 'ASSEM_COST' type: platform int4.</body><body package="GlorpTestModels" selector="tableForWAREHOUSE:">tableForWAREHOUSE: aTable	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'ADDRESS' type: (platform varChar: 50).	aTable createFieldNamed: 'CURRENT_ITEM_ID' type: platform int4.</body><body package="GlorpTestModels" selector="tableForWAREHOUSE_ITEM_LINK:">tableForWAREHOUSE_ITEM_LINK: aTable	| warehouseId |	warehouseId := aTable createFieldNamed: 'WAREHOUSE_ID' type: platform int4.	aTable addForeignKeyFrom: warehouseId to: ((self tableNamed: 'WAREHOUSE') fieldNamed: 'ID').	aTable createFieldNamed: 'ITEM_ID' type: platform int4.</body><body package="GlorpTestModels" selector="tableForWORKING_STIFF:">tableForWORKING_STIFF: aTable	aTable name: 'WORKING_STIFF'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>descriptors/employees</category><body package="GlorpTestModels" selector="classModelForGlorpWarehouse:">classModelForGlorpWarehouse: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #address.	aClassModel newAttributeNamed: #currentItem type: GlorpInventoryItem.	aClassModel newAttributeNamed: #items collectionOf: GlorpInventoryItem.</body><body package="GlorpTestModels" selector="descriptorForGlorpEmployee:">descriptorForGlorpEmployee: aDescriptor	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'E' field: (table fieldNamed: 'EMPLOYEE_TYPE').	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpInventoryItem:">descriptorForGlorpInventoryItem: aDescriptor	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor abstract: true.	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpLineWorker:">descriptorForGlorpLineWorker: aDescriptor	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'W' field: (table fieldNamed: 'EMPLOYEE_TYPE').	aDescriptor addMapping: (DirectMapping from: #productionLine to: (table fieldNamed: 'PRODUCTION_LINE')).	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpManager:">descriptorForGlorpManager: aDescriptor	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #branch to: (table fieldNamed: 'BRANCH')).	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'M' field: (table fieldNamed: 'EMPLOYEE_TYPE').	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpNonperishableItem:">descriptorForGlorpNonperishableItem: aDescriptor	| table |	table := self tableNamed: 'NONPERISHABLE_ITEM'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #serialNumber to: (table fieldNamed: 'SERIAL_NUMBER')).	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor.	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpOffice:">descriptorForGlorpOffice: aDescriptor	| table |	table := self tableNamed: 'OFFICE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (OneToManyMapping new			attributeName: #employees;			referenceClass: GlorpEmployee;			join: (Join 				from: (table fieldNamed: 'ID')				to: ((self tableNamed: 'EMPLOYEE') fieldNamed: 'OFFICE_ID'))).	aDescriptor addMapping: (OneToOneMapping new		attributeName: #employeeOfMonth;		referenceClass: GlorpEmployee;		join: (Join				from: (table fieldNamed: 'EMPLOYEE_OF_MONTH')				to: ((self tableNamed: 'EMPLOYEE') fieldNamed: 'ID'))).	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpPerishableItem:">descriptorForGlorpPerishableItem: aDescriptor	| table |	table := self tableNamed: 'PERISHABLE_ITEM'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #age to: (table fieldNamed: 'AGE')).	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor.	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpPoultry:">descriptorForGlorpPoultry: aDescriptor	"Poultry does not participate in the InventoryItem heirarchy (ie it will not be retrieved when asking for an InventoryItem)"	| table |	table := self tableNamed: 'POULTRY'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #age to: (table fieldNamed: 'AGE')).	aDescriptor addMapping: (DirectMapping from: #featherColor to: (table fieldNamed: 'FEATHER_COLOR')).	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpRegionalManager:">descriptorForGlorpRegionalManager: aDescriptor	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #branch to: (table fieldNamed: 'BRANCH')).	aDescriptor addMapping: (DirectMapping from: #region to: (table fieldNamed: 'REGION')).	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'R' field: (table fieldNamed: 'EMPLOYEE_TYPE').	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpUnassembledItem:">descriptorForGlorpUnassembledItem: aDescriptor	| table |	table := self tableNamed: 'UNASSEMBLED_ITEM'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #serialNumber to: (table fieldNamed: 'SERIAL_NUMBER')).	aDescriptor addMapping: (DirectMapping from: #assemblyCost to: (table fieldNamed: 'ASSEM_COST')).	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor.	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpWarehouse:">descriptorForGlorpWarehouse: aDescriptor	| table linkTable |	table := self tableNamed: 'WAREHOUSE'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor		addMapping:			(DirectMapping from: #address to: (table fieldNamed: 'ADDRESS')).	(aDescriptor newMapping: OneToOneMapping) 		attributeName: #currentItem;		join: (self polymorphicJoinToItemFromField: (table fieldNamed: 'CURRENT_ITEM_ID')).			linkTable := self tableNamed: 'WAREHOUSE_ITEM_LINK'.	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #items;		join:				(Join						from: (table fieldNamed: 'ID')						to: (linkTable fieldNamed: 'WAREHOUSE_ID'));		reverseJoin: (self polymorphicJoinToItemFromField: (linkTable fieldNamed: 'ITEM_ID')).	^aDescriptor.</body><body package="GlorpTestModels" selector="descriptorForGlorpWorkingStiff:">descriptorForGlorpWorkingStiff: aDescriptor	"Working stiff does not participate in the Employee type mapping scheme (it uses its own table)"	| table |	table := self tableNamed: 'WORKING_STIFF'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	^aDescriptor</body><body package="GlorpTestModels" selector="polymorphicJoinToItemFromField:">polymorphicJoinToItemFromField: aField	"Return a polymorphic join to the GlorpInventoryItem subclasses from the given field."	| polymorphicJoin |	polymorphicJoin := VariableJoin new.	(Array with: GlorpNonperishableItem with: GlorpPerishableItem with: GlorpUnassembledItem)		do:			[:eachClass | 			polymorphicJoin				addJoinFor: eachClass				as:					(Join						from: aField						to: ((self descriptorFor: eachClass) primaryTable fieldNamed: 'ID'))].	^polymorphicJoin</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>type resolvers</category><body package="GlorpTestModels" selector="typeResolverForGlorpInventoryItem">typeResolverForGlorpInventoryItem	^HorizontalTypeResolver forRootClass: GlorpInventoryItem.</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>misc</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('EMPLOYEE' 'OFFICE' 'PERISHABLE_ITEM' 'NONPERISHABLE_ITEM' 'UNASSEMBLED_ITEM' 'WORKING_STIFF' 'POULTRY' 'TAX' 'WAREHOUSE' 'WAREHOUSE_ITEM_LINK'  'GLORP_IMAGE' 'GLORP_TAG' 'GLORP_TAGS').</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: GlorpOffice;		add: GlorpEmployee;		add: GlorpManager;		add: GlorpRegionalManager;		add: GlorpLineWorker;		add: GlorpInventoryItem;		add: GlorpPerishableItem;		add: GlorpNonperishableItem;		add: GlorpUnassembledItem;		add: GlorpWorkingStiff;		add: GlorpPoultry;		add: GlorpTax;		add: GlorpBasicTax;		add: GlorpSurcharge;		add: GlorpWarehouse;		add: GlorpTag;		add: GlorpTaggableObject;		add: GlorpImage;		yourself</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>as yet unclassified</category><body package="GlorpTestModels" selector="classModelForGlorpImage:">classModelForGlorpImage: aClassModel 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #location.	aClassModel newAttributeNamed: #tags collectionOf: GlorpTag.</body><body package="GlorpTestModels" selector="classModelForGlorpTag:">classModelForGlorpTag: aClassModel 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #key.	aClassModel newAttributeNamed: #label</body><body package="GlorpTestModels" selector="classModelForGlorpTaggableObject:">classModelForGlorpTaggableObject: aClassModel</body><body package="GlorpTestModels" selector="descriptorForGlorpImage:">descriptorForGlorpImage: aDescriptor 	| table |	table := self tableNamed: 'GLORP_IMAGE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'id').	(aDescriptor newMapping: DirectMapping)		from: #location		to: (table fieldNamed: 'location').	(aDescriptor newMapping: ManyToManyMapping) attributeName: #tags;		 referenceClass: GlorpTag;				join: (Join				from: (table fieldNamed: 'id')				to: ((self tableNamed: 'IMAGETAGS')						fieldNamed: 'obj_id')).	(self typeResolverFor: GlorpTaggableObject)		register: aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpTag:">descriptorForGlorpTag: aDescriptor 	| table |	table := self tableNamed: 'GLORP_TAG'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'id').	(aDescriptor newMapping: DirectMapping)		from: #key		to: (table fieldNamed: 'key').	(aDescriptor newMapping: DirectMapping)		from: #label		to: (table fieldNamed: 'label').</body><body package="GlorpTestModels" selector="descriptorForGlorpTaggableObject:">descriptorForGlorpTaggableObject: aDescriptor 	(self typeResolverFor: GlorpTaggableObject)		register: aDescriptor		abstract: true</body><body package="GlorpTestModels" selector="tableForGLORP_IMAGE:">tableForGLORP_IMAGE: aTable 	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey.	aTable		createFieldNamed: 'location'		type: (platform varChar: 250).</body><body package="GlorpTestModels" selector="tableForGLORP_TAG:">tableForGLORP_TAG: aTable 	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey.	aTable		createFieldNamed: 'key'		type: (platform varChar: 200).	aTable		createFieldNamed: 'label'		type: (platform varChar: 200).</body><body package="GlorpTestModels" selector="tableForGLORP_TAGS:">tableForGLORP_TAGS: aTable 	| tagKey tagObjKey |	tagKey := aTable createFieldNamed: 'tag_id' type: platform int4.	aTable		addForeignKeyFrom: tagKey		to: ((self tableNamed: 'GLORP_TAG')				fieldNamed: 'id').	tagObjKey := aTable createFieldNamed: 'obj_id' type: platform int4.	aTable		addForeignKeyFrom: tagObjKey		to: ((self tableNamed: 'GLORP_IMAGE')				fieldNamed: 'id')</body><body package="GlorpTestModels" selector="tableForIMAGETAGS:">tableForIMAGETAGS: aTable 	| tagKey tagObjKey |	tagKey := aTable createFieldNamed: 'tag_id' type: platform int4.	aTable		addForeignKeyFrom: tagKey		to: ((self tableNamed: 'GLORP_TAG')				fieldNamed: 'id').	tagObjKey := aTable createFieldNamed: 'obj_id' type: platform int4.	aTable		addForeignKeyFrom: tagObjKey		to: ((self tableNamed: 'GLORP_IMAGE')				fieldNamed: 'id')</body><body package="GlorpTestModels" selector="typeResolverForGlorpTaggableObject">typeResolverForGlorpTaggableObject   ^(HorizontalTypeResolver forRootClass: GlorpTaggableObject).</body></methods><methods><class-id>Glorp.GlorpAttachmentBytes</class-id> <category>accessing</category><body package="GlorpTestModels" selector="content">content	^content</body><body package="GlorpTestModels" selector="content:">content: anObject	content := anObject</body></methods><methods><class-id>Glorp.GlorpAttachmentBytes class</class-id> <category>glorp</category><body package="GlorpTestModels" selector="glorpSetupClassModel:forSystem:">glorpSetupClassModel: model forSystem: system 	model newAttributeNamed: #content</body><body package="GlorpTestModels" selector="glorpSetupDescriptor:forSystem:">glorpSetupDescriptor: aDesc forSystem: system 	| t |	t := system tableNamed: 'attachmentbytes'.	aDesc table: t.	(aDesc newMapping: DirectMapping) from: #content		to: (t fieldNamed: 'content')</body></methods><methods><class-id>Glorp.GlorpWorkingStiff</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpWorkingStiff</class-id> <category>comparing</category><body package="GlorpTestModels" selector="=">= aWorkingStiff	^self class = aWorkingStiff class and: [id = aWorkingStiff id and: [name = aWorkingStiff name]].</body></methods><methods><class-id>Glorp.GlorpEmployee class</class-id> <category>glorp setup</category><body package="GlorpTestModels" selector="glorpTypeResolver">glorpTypeResolver	^FilteredTypeResolver forRootClass: GlorpEmployee</body></methods><methods><class-id>Glorp.GlorpPartialWritesTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testNoDifferenceNoWrite">testNoDifferenceNoWriteself todo</body><body package="GlorpDBTests" selector="testWritingNewObject">testWritingNewObjectself todo</body><body package="GlorpDBTests" selector="testWritingObjectWithAddedComponent">testWritingObjectWithAddedComponentself todo</body><body package="GlorpDBTests" selector="testWritingObjectWithChangedAttribute">testWritingObjectWithChangedAttributeself todo</body><body package="GlorpDBTests" selector="testWritingObjectWithChangedComponent">testWritingObjectWithChangedComponentself todo</body><body package="GlorpDBTests" selector="testWritingObjectWithChangedComponentAttribute">testWritingObjectWithChangedComponentAttributeself todo</body><body package="GlorpDBTests" selector="testWritingObjectWithDeletedComponent">testWritingObjectWithDeletedComponentself todo</body><body package="GlorpDBTests" selector="testWritingObjectWithDeletedRelationship">testWritingObjectWithDeletedRelationshipself todo</body></methods><methods><class-id>Glorp.GlorpPartialWritesTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.</body></methods><methods><class-id>Glorp.GlorpTableTest</class-id> <category>tests</category><body package="GlorpTests" selector="testBasicSequencing">testBasicSequencing	| row |	row := DatabaseRow newForTable: (system tableNamed: 'STUFF').	row preWriteAssignSequencesUsing: nil.	row postWriteAssignSequencesUsing: nil.	self assert: (row at: ((system tableNamed: 'STUFF') fieldNamed: 'ID')) = 1.</body><body package="GlorpTests" selector="testCircularFieldRefs">testCircularFieldRefs	| field table1 table2 |	table1 := DatabaseTable named: 'BAR'.	field := table1 createFieldNamed: 'FOO' type: dbPlatform int4.	table2 := DatabaseTable named: 'BLETCH'.	table1 addForeignKeyFrom: field to: (table2 createFieldNamed: 'FLIRP' type: dbPlatform int4).	self assert: (table2 fieldNamed: 'FLIRP') = table1 foreignKeyConstraints first targetFields first.</body><body package="GlorpTests" selector="testConstraintCreation">testConstraintCreation	| constraint dropWord |	constraint := ForeignKeyConstraint		sourceField: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		targetField: ((system tableNamed: 'PERSON') fieldNamed: 'ID').	self assert: constraint creationString =		( 'CONSTRAINT ', constraint name, ' FOREIGN KEY (BANK_CODE) REFERENCES PERSON (ID)').	dropWord := self keywordForConstraintsWhenDropping: constraint onPlatform: dbPlatform.		dbPlatform supportsAlterTableForConstraints ifTrue:		[self assert: constraint dropString =			( 'ALTER TABLE BANK_ACCT DROP ', dropWord, ' ', constraint name)].	constraint := ForeignKeyConstraint		sourceField: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		targetField: ((system tableNamed: 'PERSON') fieldNamed: 'ID')		suffixExpression: 'ON DELETE CASCADE'.	self assert: constraint creationString = ('CONSTRAINT ', constraint name, ' FOREIGN KEY (BANK_CODE) REFERENCES PERSON (ID) ON DELETE CASCADE').	dbPlatform supportsAlterTableForConstraints ifTrue:		[self assert: constraint dropString = ('ALTER TABLE BANK_ACCT DROP ', dropWord, ' ',  constraint name)].</body><body package="GlorpTests" selector="testConstraintNonCreation">testConstraintNonCreation	| constraint |	constraint := ForeignKeyConstraint 		sourceField: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		targetField: ((system tableNamed: 'PERSON') fieldNamed: 'ID').	constraint shouldCreateInDatabase: false.	self assert: constraint creationString = ''.	self assert: constraint dropString = ''.</body><body package="GlorpTests" selector="testFieldTable">testFieldTable	| field table |	field := DatabaseField named: 'FOO' type: dbPlatform int4.	table := DatabaseTable named: 'BAR'.	table addField: field.	self assert: (table fieldNamed: 'FOO') = field.</body><body package="GlorpTests" selector="testForeignKeyFieldAPI">testForeignKeyFieldAPI	"SQLite does not support foreign keys but it will parse them;  this test passes on SQLite."	| table1 table2 fieldCustAddr fieldAddrId constraint |	table1 := DatabaseTable named: 'Customer'.	(table1 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	fieldCustAddr := table1 createFieldNamed: 'ADDRESS' type: dbPlatform int4.	table2 := DatabaseTable named: 'Address'.	fieldAddrId := (table2 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	table2 createFieldNamed: 'Street' type: dbPlatform varChar.	constraint := table1 addForeignKeyFrom: fieldCustAddr toTable: table2.	self assert: (table2 fieldNamed: 'ID') = table1 foreignKeyConstraints first targetFields first.	self assert: constraint name =  'Customer_A_TO_Address_ID_REF1'.	table1 := DatabaseTable named: 'Customer'.	(table1 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	fieldCustAddr := table1 createFieldNamed: 'ADDRESS' type: dbPlatform int4.	table2 := DatabaseTable named: 'Address'.	fieldAddrId := (table2 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	table2 createFieldNamed: 'Street' type: dbPlatform varChar.	table1 addForeignKeyFrom: fieldCustAddr toField: fieldAddrId.	self assert: (table2 fieldNamed: 'ID') = table1 foreignKeyConstraints first targetFields first.</body><body package="GlorpTests" selector="testPrimaryKeyFields">testPrimaryKeyFields	| pkFields table |	table := system tableNamed: 'BANK_TRANS'.	pkFields := table primaryKeyFields.	self assert: pkFields size = 1.	self assert: (pkFields at: 1) == (table fieldNamed: 'ID').</body><body package="GlorpTests" selector="testPrimaryKeyFields2">testPrimaryKeyFields2	| table field |	table := DatabaseTable new.	field := (DatabaseField named: 'FRED' type: (dbPlatform varChar: 10))		bePrimaryKey.	table addField: field.	self assert: table primaryKeyFields size = 1.	self assert: (table primaryKeyFields at: 1) == field.</body><body package="GlorpTests" selector="testPrimaryKeyFieldsNoPK">testPrimaryKeyFieldsNoPK	| pkFields table |	table := system tableNamed: 'CUSTOMER_ACCT_LINK'.	pkFields := table primaryKeyFields.	self assert: pkFields size = 0.</body><body package="GlorpTests" selector="testPrintingWithParent">testPrintingWithParent	| t t1 |	t := system tableNamed: 'GR_CUSTOMER'.	t1 := t copy.	t1 parent: t.	t1 name: 'foo'.	self assert: t1 sqlTableName = 'GR_CUSTOMER foo'.</body><body package="GlorpTests" selector="testPrintingWithoutParent">testPrintingWithoutParent	| t t1 |	t := system tableNamed: 'GR_CUSTOMER'.	self assert: t sqlTableName = 'GR_CUSTOMER'.</body><body package="GlorpTests" selector="testRowCreation">testRowCreation	| row |	row := system examplePersonRow1.	self assert: (row at: (row table fieldNamed: 'ID')) = 3.</body><body package="GlorpTests" selector="testTwoSequences">testTwoSequences	| row1 row2 table idField |	table := system tableNamed: 'STUFF'.	row1 := DatabaseRow newForTable: table.	row2 := DatabaseRow newForTable: table.	row1 preWriteAssignSequencesUsing: nil.	row1 postWriteAssignSequencesUsing: nil.	row2 preWriteAssignSequencesUsing: nil.	row2 postWriteAssignSequencesUsing: nil.	idField := table fieldNamed: 'ID'.	self assert: (row1 at: idField) = 1.	self assert: (row2 at: idField) = 2.</body></methods><methods><class-id>Glorp.GlorpTableTest</class-id> <category>support</category><body package="GlorpTests" selector="keywordForConstraintsWhenDropping:onPlatform:">keywordForConstraintsWhenDropping: aConstraint onPlatform: aDatabasePlatform	"This method returns the term to test against independently of #writeConstraintToDrop:onStream:.  The logic is that ANSI uses 'DROP CONSTRAINT but MySQL uses		'DROP PRIMARY KEY' for primary key constraints (and then says don't name the constraint name in the drop statement!)		'DROP FOREIGN KEY'  for foreign key constraints		'DROP KEY' for unique constraints (it also supports DROP INDEX for this)"	(aDatabasePlatform isKindOf: MySQLPlatform) ifFalse: [^'CONSTRAINT'].	aConstraint isForeignKeyConstraint ifTrue: [^'FOREIGN KEY'].	aConstraint isPrimaryKeyConstraint ifTrue: [^'PRIMARY KEY'].	^'KEY'</body><body package="GlorpTests" selector="setUp">setUp	super setUp.	descriptors := system allDescriptors.	dbPlatform := system platform.	GlorpInMemorySequenceDatabaseType reset</body></methods><methods><class-id>Glorp.GlorpPerson</class-id> <category>accessing</category><body package="GlorpTestModels" selector="address">address	"Private - Answer the value of the receiver's ''address'' instance variable."	^address</body><body package="GlorpTestModels" selector="address:">address: anObject	"Private - Set the value of the receiver's ''address'' instance variable to the argument, anObject."	address := anObject</body><body package="GlorpTestModels" selector="emailAddresses">emailAddresses	^emailAddresses</body><body package="GlorpTestModels" selector="emailAddresses:">emailAddresses: aCollection	emailAddresses := aCollection</body><body package="GlorpTestModels" selector="hasEmail">hasEmail	^hasEmail</body><body package="GlorpTestModels" selector="hasEmail:">hasEmail: aBoolean	hasEmail := aBoolean</body><body package="GlorpTestModels" selector="id">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels" selector="name">name	"Private - Answer the value of the receiver's ''name'' instance variable."	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	"Private - Set the value of the receiver's ''name'' instance variable to the argument, anObject."	name := anObject</body></methods><methods><class-id>Glorp.GlorpPerson</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: id printString, ',', (name ifNil: ['']).	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.GlorpPerson class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: GlorpAddress example1.</body><body package="GlorpTestModels" selector="example1WithChangedAddress">example1WithChangedAddress	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: GlorpAddress example1WithChangedAddress.</body><body package="GlorpTestModels" selector="example1WithDifferentAddress">example1WithDifferentAddress	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: GlorpAddress example2.</body><body package="GlorpTestModels" selector="example1WithDifferentName">example1WithDifferentName	^self new		id: 1; 		name: 'John Doe';		address: GlorpAddress example1.</body><body package="GlorpTestModels" selector="example1WithNoAddress">example1WithNoAddress	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: nil.</body><body package="GlorpTestModels" selector="example2">example2	^self new		id: 2;		name: 'John Doe';		address: GlorpAddress example2.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testCasesToWrite">testCasesToWrite	"How des a dictionary mapping relate to 1:many vs many:many.	dictionary of strings to strings	dictionary of strings to objects	dictionary of objects to objects	keys always have to be related to values somehow, because I can't extract the association otherwise. Both might also be associated to source.    You should be able to use the topological sort to determine the create/delete order of tables as well"</body><body package="GlorpTests" selector="testCollectionKeyQuery">testCollectionKeyQuery	| encyclopedias matches |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset."	matches := session read: GlorpEncyclopedia	 where: [:each | each entries anySatisfy: [:eachEntry |		((eachEntry getTable: 'ENCYC_ENTRY_LINK') getField: 'REFERENCE_NO') = 'unique']]."	matches := session read: GlorpEncyclopedia	 where: [:each | each entries anySatisfy: [:eachEntry |		eachEntry key = 'unique']].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests" selector="testCollectionValueQuery">testCollectionValueQuery	| encyclopedias matches |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	matches := session read: GlorpEncyclopedia where: [:each | each entries anySatisfy: [:eachEntry |		eachEntry value title = 'Vehicular Fish Decay']].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests" selector="testCollectionValueQueryWithImpliedValue">testCollectionValueQueryWithImpliedValue	| encyclopedias matches |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	matches := session read: GlorpEncyclopedia where: [:each | each entries anySatisfy: [:eachEntry |		eachEntry title = 'Vehicular Fish Decay']].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests" selector="testCollectionValueQueryWithImpliedValueAndObjectEquality">testCollectionValueQueryWithImpliedValueAndObjectEquality	| encyclopedias matches entry |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	entry := session readOneOf: GlorpEncyclopediaEntry where: [:each | each title = 'Vehicular Fish Decay'].	matches := session read: GlorpEncyclopedia where: [:each | each entries anySatisfy: [:eachEntry |		eachEntry = entry]].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests" selector="testQueryWithDictionaryType">testQueryWithDictionaryType	| encyclopedias query dict linkTable entryTable refField linkTableField idField |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	linkTable := session system tableNamed: 'ENCYC_ENTRY_LINK'.	entryTable := session system tableNamed: 'ENCYC_ENTRY'.	refField := linkTable fieldNamed: 'REFERENCE_NO'.	linkTableField := linkTable fieldNamed: 'ENCYC_ENTRY_ID'.	idField := entryTable fieldNamed: 'ID'.	query := Query readManyOf: GlorpEncyclopediaEntry.	query where: [:each | ((each getTable: linkTable) getField: linkTableField) = ((each getTable: entryTable) getField: idField)].	query retrieveDictionaryWithKey: [:each | (each getTable: linkTable) getField: refField] value: [:each | each].	dict := session execute: query.	self assert: dict class == Dictionary.	self assert: dict size = 5.	self assert: (dict at: 'abcde') id = 'two'.	self assert: (dict at: 'abcde') == (dict at: 'edcba').</body><body package="GlorpTests" selector="testReadWithAlsoFetch">testReadWithAlsoFetch	| encyclopedias query readBackEncyclopedias |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	query := Query readManyOf: GlorpEncyclopedia.	query orderBy: [:each | each name].	query alsoFetch: [:each | each entries asOuterJoin].	readBackEncyclopedias := session execute: query.	session accessor denyReads.	self verifyEncyclopedias: readBackEncyclopedias.</body><body package="GlorpTests" selector="testReadWithRetrieve">testReadWithRetrieve	| encyclopedias query readBackEncyclopedias |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	query := Query readManyOf: GlorpEncyclopedia.	query orderBy: [:each | each name].	query retrieve: [:each | each].	query retrieve: [:each | each entries asOuterJoin].	readBackEncyclopedias := session execute: query.	session accessor denyReads.	self assert: readBackEncyclopedias size = 6.	self verifyEncyclopedias: ((readBackEncyclopedias collect: [:each | each first]) asSet asSortedCollection: [:a :b | a name &lt;= b name]).	readBackEncyclopedias do: [:eachArray |		eachArray last key isNil 			ifTrue: [self assert: eachArray first entries isEmpty]			ifFalse: [self assert: (eachArray first entries at: eachArray last key) = eachArray last value]].</body><body package="GlorpTests" selector="testUpdate">testUpdate	| encyclopedias canadian allEntryRows allLinkRows |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	session accessor denyCommands: (Array with: DeleteCommand).	session inUnitOfWorkDo: [		| newEntry |		canadian := session readOneOf: GlorpEncyclopedia where: [:each | each name like: 'The Ca%'].		newEntry := GlorpEncyclopediaEntry new			id: 'seven';			title: 'The Latest Entry';			text: 'This is all about the very newest stuff'.		canadian entries at: 'unique' put: newEntry].	self assert: (canadian entries at: 'abcde') id = 'two'.	self assert: (canadian entries at: '12345') id = 'one'.	self assert: (canadian entries at: 'unique') id = 'seven'.	self assert: (canadian entries at: 'unique') title = 'The Latest Entry'.	allEntryRows := session accessor executeSQLString: 'select * from ENCYC_ENTRY'.	"We didn't actually delete the 'three' entry"	self assert: allEntryRows size = 4.	allLinkRows := session accessor executeSQLString: 'select * from ENCYC_ENTRY_LINK'.	"But we should have only our 3 link table rows, plus 2 for the other encyclopedia"	self assert: allLinkRows size = 5.</body><body package="GlorpTests" selector="testUpdateNonLinkTable">testUpdateNonLinkTable	"Test updating a dictionary where we don't have a link table, but the target table refers back to the containing object."	| encyclopedias canadian bio newBio |	encyclopedias := session system exampleEncyclopedias.	bio := GlorpEncyclopediaBioEntry new title: 'Alan Kay'; text: 'A stub'.	encyclopedias first biographicalEntries at: bio title put: bio.	session transact: [session register: encyclopedias].	session reset.	session inUnitOfWorkDo: [		canadian := session readOneOf: GlorpEncyclopedia where: [:each | each name like: 'The Ca%'].		newBio := GlorpEncyclopediaBioEntry new			title: 'Alan Kay';			text: 'a bit more information'.		canadian biographicalEntries at: 'Alan Kay' put: newBio].	session reset.	canadian := session readOneOf: GlorpEncyclopedia where: [:each | each name like: 'The Ca%'].	self assert: canadian biographicalEntries size = 1.	self assert: (canadian biographicalEntries at: 'Alan Kay') text = 'a bit more information'.	self assert: (session count: GlorpEncyclopediaBioEntry) = 1.</body><body package="GlorpTests" selector="testWriteAndReadBack">testWriteAndReadBack	| encyclopedias query readBackEncyclopedias |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	query := Query readManyOf: GlorpEncyclopedia.	query orderBy: [:each | each name].	readBackEncyclopedias := session execute: query.	self verifyEncyclopedias: readBackEncyclopedias.</body><body package="GlorpTests" selector="verifyEncyclopedias:">verifyEncyclopedias: readBackEncyclopedias	| plagiarists canadian |	self assert: readBackEncyclopedias size = 3.	canadian := readBackEncyclopedias first.	self assert: canadian name = 'The Canadian Encyclopedia'.	self assert: canadian entries size = 3.	self assert: (canadian entries at: 'abcde') id = 'two'.	self assert: (canadian entries at: '12345') id = 'one'.	self assert: (canadian entries at: 'unique') id = 'three'.	plagiarists := readBackEncyclopedias at: 2.	self assert: plagiarists entries size = 2.	self		assert:			(plagiarists entries at: '54321') = (canadian entries at: '12345').	self		assert:			(plagiarists entries at: 'edcba') = (canadian entries at: 'abcde').	self assert: readBackEncyclopedias last entries isEmpty.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	session system: (GlorpEncyclopediaDescriptorSystem forPlatform: session platform).	session beginTransaction.</body><body package="GlorpTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests-simple reference classes</category><body package="GlorpTests" selector="testDeleteSimpleTypeOneToMany">testDeleteSimpleTypeOneToMany	| publishers publisher |	self assert: (session read: GlorpPublisher) isEmpty.	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titles: (publisher titles copyWithout: 'Mastering ENVY/Developer')].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: publisher titles size = 2.	self assert: publisher titles asSortedCollection = (session system examplePublisher1 titles copyWithout: 'Mastering ENVY/Developer') asSortedCollection.</body><body package="GlorpTests" selector="testSimpleTypeOneToMany">testSimpleTypeOneToMany	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id = 1].	publishers do: [:each | 		each titles do: [:eachTitle | self assert: eachTitle isString]].	self assert: publishers first titles size = 3.	self assert: publishers first titles asSortedCollection = session system examplePublisher1 titles asSortedCollection.</body><body package="GlorpTests" selector="testSimpleTypeOneToManyComplexQuerying">testSimpleTypeOneToManyComplexQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titles sqlCount = 3].	self assert: publishers size = 1.	self assert: publishers first titles size = 3.	self assert: (publishers first titles includes: 'Mastering ENVY/Developer').</body><body package="GlorpTests" selector="testSimpleTypeOneToManyQuerying">testSimpleTypeOneToManyQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titles anySatisfy: [:x | x like: 'Master%' ]].	self assert: publishers size = 1.	self assert: (publishers first titles anySatisfy: [:each | each like: 'Master%']).</body><body package="GlorpTests" selector="testSimpleTypeOneToManyQueryingIncludes">testSimpleTypeOneToManyQueryingIncludes	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titles includes: 'Mastering ENVY/Developer' ].	self assert: publishers size = 1.	self assert: (publishers first titles includes: 'Mastering ENVY/Developer').</body><body package="GlorpTests" selector="testSimpleTypeOneToManyQueryingWithFilteredReads">testSimpleTypeOneToManyQueryingWithFilteredReads	| publishers publisherOne publisher2 |	((session system descriptorFor: GlorpPublisher) mappingForAttributeNamed: #titles) useFilteredRead.	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id &lt; 3].	self assert: publishers size = 2.	publisherOne := publishers detect: [:each | each id = 1].	self assert: publisherOne titles size = 3.	self assert: (publisherOne titles includes: 'Mastering ENVY/Developer').	session accessor denyReads.	publisher2 := publishers detect: [:each | each id = 2].	self assert: publisher2 titles first = 'A book'.</body><body package="GlorpTests" selector="testUpdateSimpleTypeOneToMany">testUpdateSimpleTypeOneToMany	| publishers publisher |	self assert: (session read: GlorpPublisher) isEmpty.	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titles: (Array with: 'New Improved Book'), publisher titles].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: publisher titles size = 4.	self assert: publisher titles asSortedCollection = (session system examplePublisher1 titles , (Array with: 'New Improved Book')) asSortedCollection.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests-simple reference dictionary</category><body package="GlorpTests" selector="testSimpleTypeDictionary">testSimpleTypeDictionary	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id = 1].	publishers do: [:each | 		each titlesWithNumberInStock keysAndValuesDo: [:eachTitle :eachNumber | 				self assert: eachTitle isString.			self assert: eachNumber = 2]].	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: publishers first titlesWithNumberInStock keys asSortedCollection = session system examplePublisher1 titles asSortedCollection."	publishers do: [:each | 		each titlesWithNumberInStockLink keysAndValuesDo: [:eachTitle :eachNumber | 				self assert: eachTitle isString.			self assert: eachNumber = 2]].	self assert: publishers first titlesWithNumberInStockLink size = 3.	self assert: publishers first titlesWithNumberInStockLink keys asSortedCollection = session system examplePublisher1 titles asSortedCollection."</body><body package="GlorpTests" selector="testSimpleTypeDictionaryComplexQuerying">testSimpleTypeDictionaryComplexQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock sqlCount = 3].	self assert: publishers size = 1.	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: (publishers first titlesWithNumberInStock keys includes: 'Mastering ENVY/Developer')."	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStockLink sqlCount &gt; 0].	publishers := publishers asSortedCollection: [:a :b | a name &lt;= b name].	self assert: publishers size = 2.	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: (publishers first titlesWithNumberInStock keys includes: 'Mastering ENVY/Developer')."</body><body package="GlorpTests" selector="testSimpleTypeDictionaryQuerying">testSimpleTypeDictionaryQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:x | x key like: 'Master%']].	self assert: publishers size = 1.	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: (publishers first titlesWithNumberInStock keys includes: 'Mastering ENVY/Developer')."	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:x | x value  = 2]].	self assert: publishers size = 1.	self assert: publishers first id = 1."</body><body package="GlorpTests" selector="testSimpleTypeDictionaryQueryingWithAlsoFetch">testSimpleTypeDictionaryQueryingWithAlsoFetch	| publishers publisherOne publisher2 q |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	q := Query read: GlorpPublisher where: [:each | each id &lt; 3].	q orderBy: [:each | each id].	q alsoFetch: [:each | each titlesWithNumberInStock].	publishers := session execute: q.	session accessor denyReads.		self assert: publishers asSet size = 2.	publisherOne := publishers detect: [:each | each id = 1].	self assert: publisherOne titlesWithNumberInStock size = 3.	self assert: (publisherOne titlesWithNumberInStock includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStock values asArray = #(2 2 2)).	publisher2 := publishers detect: [:each | each id = 2].	self assert: publisher2 titlesWithNumberInStock keys asArray first = 'A book'.	self assert: (publisher2 titlesWithNumberInStock at: 'A book') = 200.</body><body package="GlorpTests" selector="testSimpleTypeDictionaryQueryingWithFilteredReads">testSimpleTypeDictionaryQueryingWithFilteredReads	| publishers publisherOne publisher2 |	((session system descriptorFor: GlorpPublisher) mappingForAttributeNamed: #titlesWithNumberInStock) useFilteredRead.	"((session system descriptorFor: GlorpPublisher) mappingForAttributeNamed: #titlesWithNumberInStockLink) useFilteredRead."	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id &lt; 3].	self assert: publishers size = 2.	publisherOne := publishers detect: [:each | each id = 1].	self assert: publisherOne titlesWithNumberInStock size = 3.	self assert: (publisherOne titlesWithNumberInStock includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStock values asArray = #(2 2 2))."	self assert: publisherOne titlesWithNumberInStockLink size = 3.	self assert: (publisherOne titlesWithNumberInStockLink includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStockLink values asArray = #(2 2 2))."	session accessor denyReads.	publisher2 := publishers detect: [:each | each id = 2].	self assert: publisher2 titlesWithNumberInStock keys asArray first = 'A book'."	self assert: publisher2 titlesWithNumberInStockLink keys asArray first = 'A book'."	self assert: (publisher2 titlesWithNumberInStock at: 'A book') = 200."	self assert: (publisher2 titlesWithNumberInStockLink at: 'A book') = 200."</body><body package="GlorpTests" selector="testSimpleTypeDictionaryQueryingWithRetrieve">testSimpleTypeDictionaryQueryingWithRetrieve	| publishers publisherOne publisher2 q actualPublishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	q := Query read: GlorpPublisher where: [:each | each id &lt; 3].	q retrieve: [:each | each].	q retrieve: [:each | each titlesWithNumberInStock].	publishers := session execute: q.		actualPublishers := publishers collect: [:each | each first].	self assert: actualPublishers asSet size = 2.	publisherOne := actualPublishers detect: [:each | each id = 1].	self assert: publisherOne titlesWithNumberInStock size = 3.	self assert: (publisherOne titlesWithNumberInStock includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStock values asArray = #(2 2 2)).	publisher2 := actualPublishers detect: [:each | each id = 2].	self assert: publisher2 titlesWithNumberInStock keys asArray first = 'A book'.	self assert: (publisher2 titlesWithNumberInStock at: 'A book') = 200.</body><body package="GlorpTests" selector="testSimpleTypeDictionaryRead">testSimpleTypeDictionaryRead	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:eachTitleAssociation |		eachTitleAssociation value = 2]].	self assert: publishers size = 1.</body><body package="GlorpTests" selector="testSimpleTypeDictionaryReadWithImpliedValue">testSimpleTypeDictionaryReadWithImpliedValue	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:eachTitleAssociation |		eachTitleAssociation = 2]].	self assert: publishers size = 1.</body><body package="GlorpTests" selector="testUpdateSimpleTypeDictionaryAdding">testUpdateSimpleTypeDictionaryAdding	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStock at: 'New Book' put: 1].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStock at: 'New Book') = 1.	self assert: publisher titlesWithNumberInStock size = 4.</body><body package="GlorpTests" selector="testUpdateSimpleTypeDictionaryDeleting">testUpdateSimpleTypeDictionaryDeleting	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStock removeKey: 'Mastering ENVY/Developer'].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStock at: 'Mastering ENVY/Developer' ifAbsent: [999]) = 999.	self assert: publisher titlesWithNumberInStock size = 2.</body><body package="GlorpTests" selector="testUpdateSimpleTypeDictionaryLinkModifying">testUpdateSimpleTypeDictionaryLinkModifying"	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStockLink at: 'Mastering ENVY/Developer' put: 123].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStockLink at: 'Mastering ENVY/Developer') = 123."	"It can't find how to delete properly, because it doesn't know the primary key of the old record, and we don't have it recorded anywhere in the image"	"self assert: (session accessor executeSQLString: 'SELECT * FROM PUBLISHER_TITLE2') size = 4.	self assert: (session accessor executeSQLString: 'SELECT * FROM PUB_TITLE_LINK') size = 4."</body><body package="GlorpTests" selector="testUpdateSimpleTypeDictionaryLinkedAdding">testUpdateSimpleTypeDictionaryLinkedAdding"	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStockLink at: 'New Book' put: 1].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStockLink at: 'New Book') = 1.	self assert: publisher titlesWithNumberInStockLink size = 4."</body><body package="GlorpTests" selector="testUpdateSimpleTypeDictionaryLinkedDeleting">testUpdateSimpleTypeDictionaryLinkedDeleting"	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStockLink removeKey: 'Mastering ENVY/Developer'].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStockLink at: 'Mastering ENVY/Developer' ifAbsent: [999]) = 999.	self assert: publisher titlesWithNumberInStockLink size = 2."</body><body package="GlorpTests" selector="testUpdateSimpleTypeDictionaryModifying">testUpdateSimpleTypeDictionaryModifying	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStock at: 'Mastering ENVY/Developer' put: 123].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStock at: 'Mastering ENVY/Developer') = 123.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests-key in different tables</category><body package="GlorpTests" selector="testWriteAndReadBackKeyInLinkTable">testWriteAndReadBackKeyInLinkTable	| query readBackPublishers publishers withEmps |	publishers := session system examplePublishers.	session transact: [session register: publishers].	session reset.	query := Query readManyOf: GlorpPublisher.	query orderBy: [:each | each name].	readBackPublishers := session execute: query.	self assert: readBackPublishers size = 3.	withEmps := readBackPublishers at: 2.	self assert: withEmps name = 'Cambridge'.	self assert: withEmps differentBunchOfEmployeesById size = 2.	self assert: withEmps differentBunchOfEmployeesById keys asSortedCollection asArray = #(3 4).	self assert: (withEmps differentBunchOfEmployeesById at: 3) name = 'Contractor 1'.	self assert: (withEmps differentBunchOfEmployeesById at: 4) name = 'Contractor 2'.</body><body package="GlorpTests" selector="testWriteAndReadBackKeyInTargetTable">testWriteAndReadBackKeyInTargetTable	| query readBackPublishers publishers withEmps |	publishers := session system examplePublishers.	session transact: [session register: publishers].	session reset.	query := Query readManyOf: GlorpPublisher.	query orderBy: [:each | each name].	readBackPublishers := session execute: query.	self assert: readBackPublishers size = 3.	withEmps := readBackPublishers at: 2.	self assert: withEmps name = 'Cambridge'.	self assert: withEmps employees size = 2.	self assert: withEmps employees keys asSortedCollection asArray = #('CEO' 'Editor').	self assert: (withEmps employees at: 'CEO') name = 'The Boss'.	self assert: (withEmps employees at: 'Editor') name = 'Somebody'.</body></methods><methods><class-id>Glorp.GlorpBasicTax class</class-id> <category>glorp</category><body package="GlorpTestModels" selector="glorpSetupDescriptor:forSystem:">glorpSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	self glorpCommonSetupDescriptor: aDescriptor forSystem: aSystem.	(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		keyedBy: 'T'		field: (table fieldNamed: 'TYPE').</body></methods><methods><class-id>Glorp.GlorpCompositeKeyTest</class-id> <category>tests- basic reading</category><body package="GlorpDBTests" selector="testAlsoFetch">testAlsoFetch	| users |	users := session readManyOf: GlorpUser.</body><body package="GlorpDBTests" selector="testBasicReadFolder">testBasicReadFolder	| folders |	folders := (session readManyOf: GlorpFolder) asSortedCollection: [:a :b | a name &lt;= b name].	self assert: folders size = 3.	self assert: folders first name = 'One'.	self assert: folders last name = 'Two'.</body><body package="GlorpDBTests" selector="testBasicReadMessage">testBasicReadMessage	| messages |	messages := (session readManyOf: GlorpMessage) asSortedCollection: [:a :b | a subject &lt;= b subject].	self assert: messages size = 3.	self assert: messages first subject = 'also goes in folder 1'.	self assert: (messages at: 2) subject = 'goes in folder 1'.	self assert: messages last subject = 'goes in folder 2'.</body><body package="GlorpDBTests" selector="testBasicReadUser">testBasicReadUser	| users |	users := (session readManyOf: GlorpUser) asSortedCollection: [:a :b | a id &lt;= b id].	self assert: users size = 2.	self assert: users first name = 'User One'.	self assert: users last name = 'User Two'.</body><body package="GlorpDBTests" selector="testFaulting">testFaulting	| users user1 sortedFolders user2 |	users := session readManyOf: GlorpUser.	user1 := users detect: [:each | each id = 1].	self assert: user1 folders size = 2.	sortedFolders := user1 folders asSortedCollection: [:a :b | a name &lt; b name].	self assert: sortedFolders first name = 'One'.	user2 := users detect: [:each | each id = 2].	self assert: user2 folders first messages first subject = 'goes in folder 2'.</body><body package="GlorpDBTests" selector="testFolderIdentity">testFolderIdentity	| folders |	folders := session readManyOf: GlorpFolder.	folders do: [:each | | individualFolders individualFolder otherIndividualFolder|		individualFolders := session readManyOf: GlorpFolder where: [:eachFolder | eachFolder = each].		self assert: individualFolders size = 1.		individualFolder := individualFolders first.		otherIndividualFolder := session readOneOf: GlorpFolder where: [:eachFolder | eachFolder = each].		self assert: individualFolder == each.		self assert: otherIndividualFolder == individualFolder].</body><body package="GlorpDBTests" selector="testMessageIdentity">testMessageIdentity	| messages |	messages := session readManyOf: GlorpMessage.	messages do: [:each | | individualMessages individualMessage otherIndividualMessage|		individualMessages := session readManyOf: GlorpMessage where: [:eachMessage | eachMessage = each].		self assert: individualMessages size = 1.		individualMessage := individualMessages first.		otherIndividualMessage := session readOneOf: GlorpMessage where: [:eachMessage | eachMessage = each].		self assert: individualMessage == each.		self assert: otherIndividualMessage == individualMessage].</body><body package="GlorpDBTests" selector="testReadWithCacheHitFromExpression">testReadWithCacheHitFromExpression	| message |	session reset.	message := session readOneOf: GlorpMessage where: [:each | each subject = 'goes in folder 1'].	self assert: message folder name = 'One'.	session accessor permitNothing.	session readOneOf: GlorpFolder where: [:each | each user id = 1 &amp; (each name = 'One')].</body><body package="GlorpDBTests" selector="testReadWithCacheHitFromJoin">testReadWithCacheHitFromJoin	| message |	session reset.	message := session readOneOf: GlorpMessage where: [:each | each subject = 'goes in folder 1'].	session readOneOf: GlorpFolder where: [:each | each user id = 1 &amp; (each name = 'One')].	session accessor permitNothing.	self assert: message folder name = 'One'.</body><body package="GlorpDBTests" selector="testReadWithCacheHitFromParameterizedExpression">testReadWithCacheHitFromParameterizedExpression	| message query |	session reset.	message := session readOneOf: GlorpMessage where: [:each | each subject = 'goes in folder 1'].	self assert: message folder name = 'One'.	session accessor permitNothing.	query := Query readOneOf: GlorpFolder where: [:each | each user id = (each parameter: 1)  &amp; (each name = (each parameter: 2))].	query executeWithParameters: #(1 'One') in: session.</body><body package="GlorpDBTests" selector="testReadWithJoins">testReadWithJoins	| users |	users := session readManyOf: GlorpUser where: [:each | each folders anySatisfyJoin: [:eachFolder |		eachFolder messages anySatisfyJoin: [:eachMessage | eachMessage subject = 'goes in folder 1']]].	self assert: users size = 1.	self assert: users first id = 1.</body><body package="GlorpDBTests" selector="testReadWithSubselect">testReadWithSubselect	| users |	users := session readManyOf: GlorpUser where: [:each | each folders anySatisfyExists: [:eachFolder |		eachFolder messages anySatisfyExists: [:eachMessage | eachMessage subject = 'goes in folder 1']]].	self assert: users size = 1.	self assert: users first id = 1.</body><body package="GlorpDBTests" selector="testReadWithSubselectAndINClause">testReadWithSubselectAndINClause	| users |	self should: [		users := session readManyOf: GlorpUser where: [:each | 			each folders anySatisfyExists: [:eachFolder |				| q |				q := Query read: GlorpFolder.				eachFolder in: q]]]		raise: GlorpInvalidExpressionError.</body><body package="GlorpDBTests" selector="testUserIdentity">testUserIdentity	| users |	users := session readManyOf: GlorpUser.	users		do:			[:each | 			| individualUser otherIndividualUser individualUsers |			individualUsers := session				readManyOf: GlorpUser				where: [:eachIndividual | eachIndividual id = each id].			self assert: individualUsers size = 1.			individualUser := individualUsers first.			otherIndividualUser := session				readOneOf: GlorpUser				where: [:eachIndividual | eachIndividual id = each id].			self assert: individualUser == each.			self assert: otherIndividualUser == individualUser].</body><body package="GlorpDBTests" selector="testUserIdentityViaMessage">testUserIdentityViaMessage	| users |	users := session readManyOf: GlorpUser.	users		do:			[:each | 			each folders				do:					[:eachFolder | 					eachFolder messages						do: [:eachMessage | 							self assert: eachMessage folder yourSelf == eachFolder.							self assert: eachMessage user yourSelf == each]]].</body><body package="GlorpDBTests" selector="testUserIdentityViaMessageInUnitOfWork">testUserIdentityViaMessageInUnitOfWork	session beginUnitOfWork.	[self testUserIdentityViaMessage] ensure: [session rollbackUnitOfWork].</body></methods><methods><class-id>Glorp.GlorpCompositeKeyTest</class-id> <category>setup</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	system := (GlorpCompositeKeyDescriptorSystem forPlatform: session platform).	session system: system.	session beginTransaction.	session transact: [session register: system example1].	session reset.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	session resetPermissions.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpDatabaseSequenceTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="assignSequences">assignSequences	| accessor |	accessor := session isNil ifFalse: [session accessor].	row1 preWriteAssignSequencesUsing: session.	row1 postWriteAssignSequencesUsing: accessor.	row2 preWriteAssignSequencesUsing: session.	row2 postWriteAssignSequencesUsing: accessor</body><body package="GlorpDBTests" selector="row1Value">row1Value	^row1 atFieldNamed: 'ID'.</body><body package="GlorpDBTests" selector="row2Value">row2Value	^row2 atFieldNamed: 'ID'.</body><body package="GlorpDBTests" selector="testGetNextValue">testGetNextValue	session platform usesIdentityColumns ifTrue: [^self].	self assignSequences.	self assert: self row2Value = (self row1Value + 1).</body><body package="GlorpDBTests" selector="testReserveEmpty">testReserveEmpty	session platform usesIdentityColumns ifTrue: [^self].	sequence reserveSequenceNumbers: 2 in: session for: table.	session := nil.	self assignSequences.	self assert: self row1Value + 1 = self row2Value.</body><body package="GlorpDBTests" selector="testReserveUsingTable">testReserveUsingTable	session platform usesIdentityColumns ifTrue: [^self].	[session beginTransaction.	self writeTransactionRow: 65.	self writeTransactionRow: 66.	self writeTransactionRow: 67.	sequence		reserveSequenceNumbers: 7		in: session		for: table] ensure: [session rollbackTransaction].	session := nil.	self assignSequences.	self assert: self row1Value + 1 = self row2Value.</body><body package="GlorpDBTests" selector="testReservedNumberAllocation">testReservedNumberAllocation	session := nil.	sequence reservedNumbers add: 23; add: 24.	self assignSequences.	self assert: self row1Value = 23.	self assert: self row2Value = 24.</body><body package="GlorpDBTests" selector="writeTransactionRow:">writeTransactionRow: anInteger	| tempRow |	tempRow := DatabaseRow newForTable: table.	session platform usesIdentityColumns ifFalse: [		tempRow atFieldNamed: 'ID' put: anInteger].	tempRow atFieldNamed: 'AMT_CURR' put: 'CDN'.	session writeRow: tempRow.</body></methods><methods><class-id>Glorp.GlorpDatabaseSequenceTest</class-id> <category>setup</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	table := session system tableNamed: 'BANK_TRANS'.	sequence := (table fieldNamed: 'ID') type sequence.	row1 := DatabaseRow newForTable: table.	row2 := DatabaseRow newForTable: table.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaBioEntry</class-id> <category>accessing</category><body package="GlorpTestModels" selector="text">text	^text</body><body package="GlorpTestModels" selector="text:">text: anObject	text := anObject</body><body package="GlorpTestModels" selector="title">title	^title</body><body package="GlorpTestModels" selector="title:">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpEncyclopediaBioEntry</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize</body></methods><methods><class-id>Glorp.GlorpEncyclopediaBioEntry class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpManager</class-id> <category>accessing</category><body package="GlorpTestModels" selector="branch">branch	^branch</body><body package="GlorpTestModels" selector="branch:">branch: anObject	branch := anObject</body></methods><methods><class-id>Glorp.GlorpManager</class-id> <category>comparing</category><body package="GlorpTestModels" selector="=">= aManager	^super = aManager and: [branch = aManager branch].</body></methods><methods><class-id>Glorp.GlorpAttributeModelTest</class-id> <category>tests</category><body package="GlorpTests" selector="testDictionaryTypes">testDictionaryTypes	| attributeModel obj classModel dict model |	dict := Dictionary new at: #one put: 'two'; yourself.	obj := 1@dict.	classModel := GlorpClassModel for: Point.	attributeModel := classModel newAttributeNamed: #y dictionaryFrom: Symbol to: String.	model := classModel attributeNamed: #y.	self assert: model == attributeModel.	self assert: model keyType == Symbol.	self assert: model type == String.	self assert: dict == (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: nil.	self assert: nil == (attributeModel getValueFrom: obj).</body><body package="GlorpTests" selector="testGetSetAssociation">testGetSetAssociation	| attributeModel obj classModel |	obj := nil-&gt;2.	classModel := GlorpClassModel for: Association.	attributeModel := classModel newAttributeNamed: #value.	attributeModel useDirectAccess: true.	self assert: 2 == (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: 3.	self assert: 3 == (attributeModel getValueFrom: obj).	attributeModel useDirectAccess: false.	self assert: 3 == (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: 2.	self assert: 2 == (attributeModel getValueFrom: obj).</body><body package="GlorpTests" selector="testGetSetObject">testGetSetObject	| attributeModel obj classModel |	obj := (GlorpObjectWithNoAccessors new)								extremelyPrivateValue: 'Glorp';								yourself.	classModel := GlorpClassModel for: GlorpObjectWithNoAccessors.	attributeModel := classModel newAttributeNamed: #alue.	attributeModel useDirectAccess: true.	self assert: 'Glorp' = (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: 'GLORP'.	self assert: 'GLORP' = (attributeModel getValueFrom: obj).	attributeModel useDirectAccess: false.	self should: [attributeModel getValueFrom: obj] raise: Dialect error.	self should: [attributeModel setValueIn: obj to: 'Glorp'] raise: Dialect error.</body><body package="GlorpTests" selector="testPreserveAttributes">testPreserveAttributes	| attributeModel classModel descriptor mapping table field system |	system := DynamicDescriptorSystem new.	classModel := system addClassModelFor: Association.	attributeModel := classModel newAttributeNamed: #key.	descriptor := Descriptor new.	descriptor classModel: classModel.	table := DatabaseTable named: 'FRED'.	field := table createFieldNamed: 'BARNEY' type: OraclePlatform new int4.	mapping := DirectMapping from: #key type: Object to: field.	self assert: mapping attributeAccessor useDirectAccess.	self assert: attributeModel useDirectAccess.	mapping attributeAccessor useDirectAccess: false.	self assert: mapping attribute type == Object.	descriptor addMapping: mapping.	self assert: mapping attribute == attributeModel.	self assert: mapping attribute == mapping attributeAccessor.	self assert: attributeModel type == Object.	self deny: attributeModel useDirectAccess.</body></methods><methods><class-id>Glorp.GlorpAttachment</class-id> <category>accessing</category><body package="GlorpTestModels" selector="attachmentBytes">attachmentBytes	^attachmentBytes</body><body package="GlorpTestModels" selector="attachmentBytes:">attachmentBytes: anObject	attachmentBytes := anObject</body><body package="GlorpTestModels" selector="index">index	^index</body><body package="GlorpTestModels" selector="index:">index: anObject	index := anObject</body><body package="GlorpTestModels" selector="mimeType">mimeType	^mimeType</body><body package="GlorpTestModels" selector="mimeType:">mimeType: anObject	mimeType := anObject</body></methods><methods><class-id>Glorp.GlorpAttachment class</class-id> <category>glorp</category><body package="GlorpTestModels" selector="glorpSetupClassModel:forSystem:">glorpSetupClassModel: model forSystem: system 	model		newAttributeNamed: #index;		newAttributeNamed: #mimeType;		newAttributeNamed: #attachmentBytes type: GlorpAttachmentBytes</body><body package="GlorpTestModels" selector="glorpSetupDescriptor:forSystem:">glorpSetupDescriptor: aDesc forSystem: system 	| t |	t := system tableNamed: 'attachment'.	aDesc table: t.	(aDesc newMapping: DirectMapping) from: #index		to: (t fieldNamed: 'indexInDocument').	(aDesc newMapping: DirectMapping) from: #mimeType		to: (t fieldNamed: 'mimetype').	(aDesc newMapping: OneToOneMapping) attributeName: #attachmentBytes</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels" selector="exampleEncyclopedias">exampleEncyclopedias	"self new exampleEncyclopedias"	| encyc1 entry1 entry2 entry3 encyc2 encyc3 |	encyc1 := GlorpEncyclopedia new id: 3; name: 'The Canadian Encyclopedia'.	entry1 := self exampleEntry1.	entry2 := self exampleEntry2.	entry3 := self exampleEntry3.	encyc1 articleAt: '12345' put: entry1.	encyc1 articleAt: 'abcde' put: entry2.	encyc1 articleAt: 'unique' put: entry3.	encyc2 := GlorpEncyclopedia new id: 4; name: 'The Plagiarists Compendium'.	encyc2 articleAt: '54321' put: entry1.	encyc2 articleAt: 'edcba' put: entry2.	encyc3 := GlorpEncyclopedia new id: 5; name: 'The Very Frugal Dictionary'.	^Array with: encyc1 with: encyc2 with: encyc3.</body><body package="GlorpTestModels" selector="exampleEntry1">exampleEntry1	^GlorpEncyclopediaEntry new 		id: 'one';		title: 'All About Ants';		text: 'Ants are, like, these little tiny creatures. Gross.'.</body><body package="GlorpTestModels" selector="exampleEntry2">exampleEntry2	^GlorpEncyclopediaEntry new 		id: 'two';		title: 'Computer Programming Languages';		text: 'There are many different computer programming languages. The best one is Smalltalk.'.</body><body package="GlorpTestModels" selector="exampleEntry3">exampleEntry3	^GlorpEncyclopediaEntry new 		id: 'three';		title: 'Vehicular Fish Decay';		text: 'Do you know what happens if you leave a fish too long in an elevator? Well heres a clue. Fish is biodegradable. That means it rots.'.</body><body package="GlorpTestModels" selector="examplePublisher1">examplePublisher1	"Put in the copies to avoid an issue with reverting immutable objects."	^GlorpPublisher new 		id: 1;		name: 'Cambridge';		titles: (Array with: 'Mastering ENVY/Developer' copy with: 'Principia Mathematica' copy with:  'Metadata-Based Persistence for Dummies' copy);		titlesWithNumberInStock: (Dictionary new			at:  'Mastering ENVY/Developer' put: 2;			at: 'Principia Mathematica' put: 2;			at: 'Metadata-Based Persistence for Dummies' put: 2;			yourself);		employees: (Dictionary new			at: 'CEO' put: (GlorpPublisherEmployee new id: 1; name: 'The Boss'; jobTitle: 'CEO');			at: 'Editor' put: (GlorpPublisherEmployee new id: 2; name: 'Somebody'; jobTitle: 'Editor');			yourself);		differentBunchOfEmployeesById: (Dictionary new			at: 3 put: (GlorpPublisherEmployee new id: 3; name: 'Contractor 1'; jobTitle: 'Contractor');			at: 4 put: (GlorpPublisherEmployee new id: 4; name: 'Contractor 2'; jobTitle: 'Contractor');			yourself);		yourself.</body><body package="GlorpTestModels" selector="examplePublisher2">examplePublisher2	^GlorpPublisher new 		id: 2;		name: 'Harper Collins';		titles: (Array with: 'A book' copy);		titlesWithNumberInStock: (Dictionary new			at:  'A book' copy put: 200;			yourself).</body><body package="GlorpTestModels" selector="examplePublisher3">examplePublisher3	^GlorpPublisher new 		id: 3;		name: 'A New Publishing company';		titles: #().</body><body package="GlorpTestModels" selector="examplePublishers">examplePublishers	^Array with: self examplePublisher1 with: self examplePublisher2 with: self examplePublisher3.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels" selector="tableForENCYC:">tableForENCYC: aTable 	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body><body package="GlorpTestModels" selector="tableForENCYC_BIO:">tableForENCYC_BIO: aTable 	| encycId |	(aTable createFieldNamed: 'TITLE' type: (platform varChar: 50)) bePrimaryKey.	encycId := aTable createFieldNamed: 'ENCYC_ID' type: platform integer.	encycId bePrimaryKey.	aTable addForeignKeyFrom: encycId to: ((self tableNamed: 'ENCYC') fieldNamed: 'ID').	aTable createFieldNamed: 'ENTRY_TEXT' type: (platform varChar: 50).</body><body package="GlorpTestModels" selector="tableForENCYC_ENTRY:">tableForENCYC_ENTRY: aTable 	(aTable createFieldNamed: 'ID' type: (platform varChar: 50)) bePrimaryKey.	aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).	aTable createFieldNamed: 'ENTRY_TEXT' type: (platform varChar: 200).	aTable createFieldNamed: 'MEDIA_TYPE_NAME' type: (platform varChar: 100).	aTable createFieldNamed: 'MEDIA_TYPE_MIME' type: (platform varChar: 100).</body><body package="GlorpTestModels" selector="tableForENCYC_ENTRY_LINK:">tableForENCYC_ENTRY_LINK: aTable 	| encycId entryId |	encycId := aTable createFieldNamed: 'ENCYC_ID' type: platform int4.	encycId bePrimaryKey.	aTable addForeignKeyFrom: encycId to: ((self tableNamed: 'ENCYC') fieldNamed: 'ID').	entryId := aTable createFieldNamed: 'ENCYC_ENTRY_ID' type: (platform varChar: 50).	aTable addForeignKeyFrom: entryId to: ((self tableNamed: 'ENCYC_ENTRY') fieldNamed: 'ID').	(aTable createFieldNamed: 'REFERENCE_NO' type: (platform varChar: 10)) bePrimaryKey.</body><body package="GlorpTestModels" selector="tableForGR_PUBLISHER:">tableForGR_PUBLISHER: aTable 	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body><body package="GlorpTestModels" selector="tableForIMAGINARY_MEDIA_TYPE:">tableForIMAGINARY_MEDIA_TYPE: aTable 	aTable isImaginary: true.  	aTable createFieldNamed: 'MEDIA_TYPE_NAME' type: (platform varChar: 100).	aTable createFieldNamed: 'MEDIA_TYPE_MIME' type: (platform varChar: 100).</body><body package="GlorpTestModels" selector="tableForPUBLISHER_EMP:">tableForPUBLISHER_EMP: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).		aTable createFieldNamed: 'JOBTITLE' type: (platform varChar: 50).</body><body package="GlorpTestModels" selector="tableForPUBLISHER_TITLE2:">tableForPUBLISHER_TITLE2: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).</body><body package="GlorpTestModels" selector="tableForPUBLISHER_TITLE:">tableForPUBLISHER_TITLE: aTable 	| pubId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	aTable createFieldNamed: 'POSITION' type: (platform int4).		aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).</body><body package="GlorpTestModels" selector="tableForPUB_EMP_LINK:">tableForPUB_EMP_LINK: aTable 	| pubId titleId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	titleId := aTable createFieldNamed: 'EMP_ID' type: platform int4.	aTable addForeignKeyFrom: titleId  to: ((self tableNamed: 'PUBLISHER_EMP') fieldNamed: 'ID').	aTable createFieldNamed: 'FOO' type: (platform varchar: 5).</body><body package="GlorpTestModels" selector="tableForPUB_TITLES_STOCK:">tableForPUB_TITLES_STOCK: aTable 	| pubId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).	aTable createFieldNamed: 'STOCK' type: platform int4.</body><body package="GlorpTestModels" selector="tableForPUB_TITLE_LINK:">tableForPUB_TITLE_LINK: aTable 	| pubId titleId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	titleId := aTable createFieldNamed: 'TITLE_ID' type: platform int4.	aTable addForeignKeyFrom: titleId  to: ((self tableNamed: 'PUBLISHER_TITLE2') fieldNamed: 'ID').	aTable createFieldNamed: 'STOCK' type: platform int4.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels" selector="classModelForGlorpEncyclopedia:">classModelForGlorpEncyclopedia: aClassModel  	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name. 	aClassModel newAttributeNamed: #entries dictionaryFrom: String to: GlorpEncyclopediaEntry.	"A slightly contrived way of having a mapping to a type of entries that don't use a link table."	aClassModel newAttributeNamed: #biographicalEntries dictionaryFrom: String to: GlorpEncyclopediaBioEntry.</body><body package="GlorpTestModels" selector="classModelForGlorpEncyclopediaBioEntry:">classModelForGlorpEncyclopediaBioEntry: aClassModel 	aClassModel newAttributeNamed: #owner type: GlorpEncyclopedia.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #text.</body><body package="GlorpTestModels" selector="classModelForGlorpEncyclopediaEntry:">classModelForGlorpEncyclopediaEntry: aClassModel 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #text.	aClassModel newAttributeNamed: #mediaType type: GlorpMediaType</body><body package="GlorpTestModels" selector="classModelForGlorpMediaType:">classModelForGlorpMediaType: aClassModel 	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #mimeType</body><body package="GlorpTestModels" selector="classModelForGlorpPublisher:">classModelForGlorpPublisher: aClassModel  	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name. 	aClassModel newAttributeNamed: #titles collection: Array of: String.	aClassModel newAttributeNamed: #titlesWithNumberInStock dictionaryFrom: String to: Integer.	aClassModel newAttributeNamed: #employees dictionaryFrom: String to: GlorpPublisherEmployee.	aClassModel newAttributeNamed: #differentBunchOfEmployeesById dictionaryFrom: Integer to: GlorpPublisherEmployee."	aClassModel newAttributeNamed: #titlesWithNumberInStockLink collection: Dictionary of: Integer."</body><body package="GlorpTestModels" selector="classModelForGlorpPublisherEmployee:">classModelForGlorpPublisherEmployee: aClassModel  	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name. 	aClassModel newAttributeNamed: #position.</body><body package="GlorpTestModels" selector="descriptorForGlorpEncyclopedia:">descriptorForGlorpEncyclopedia: aDescriptor 	| table linkTable |	table := self tableNamed: 'ENCYC'.	linkTable := self tableNamed: 'ENCYC_ENTRY_LINK'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: BasicDictionaryMapping)		attributeName: #entries;		referenceClass: GlorpEncyclopediaEntry;		keyField: (linkTable fieldNamed: 'REFERENCE_NO');		linkFields: (Array 					with: (linkTable fieldNamed: 'ENCYC_ENTRY_ID')).	(aDescriptor newMapping: DictionaryMapping)		attributeName: #biographicalEntries;		referenceClass: GlorpEncyclopediaBioEntry;		usesLinkTable: false;		beExclusive;		keyField: ((self tableNamed: 'ENCYC_BIO') fieldNamed: 'TITLE').</body><body package="GlorpTestModels" selector="descriptorForGlorpEncyclopediaBioEntry:">descriptorForGlorpEncyclopediaBioEntry: aDescriptor 	| entryTable |	entryTable := self tableNamed: 'ENCYC_BIO'.	aDescriptor table: entryTable.	"It's important that we have a mapping for the owner here, because we're expecting these entries to be deleted, and we can't delete them without knowing the primary keys."	(aDescriptor newMapping: OneToOneMapping)		attributeName: #owner;		beReadOnly.	(aDescriptor newMapping: DirectMapping) from: #title		to: (entryTable fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #text		to: (entryTable fieldNamed: 'ENTRY_TEXT').</body><body package="GlorpTestModels" selector="descriptorForGlorpEncyclopediaEntry:">descriptorForGlorpEncyclopediaEntry: aDescriptor 	| entryTable |	entryTable := self tableNamed: 'ENCYC_ENTRY'.	aDescriptor table: entryTable.	(aDescriptor newMapping: DirectMapping) from: #id		to: (entryTable fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #title		to: (entryTable fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #text		to: (entryTable fieldNamed: 'ENTRY_TEXT').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)		attributeName: #mediaType;		referenceClass: GlorpMediaType;		fieldTranslation: ((Join new)					addSource: (entryTable fieldNamed: 'MEDIA_TYPE_NAME')						target: ((self tableNamed: 'IMAGINARY_MEDIA_TYPE') 								fieldNamed: 'MEDIA_TYPE_NAME');					addSource: (entryTable fieldNamed: 'MEDIA_TYPE_MIME')						target: ((self tableNamed: 'IMAGINARY_MEDIA_TYPE') 								fieldNamed: 'MEDIA_TYPE_MIME');					yourself).	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpMediaType:">descriptorForGlorpMediaType: aDescriptor 	| table |	table := self tableNamed: 'IMAGINARY_MEDIA_TYPE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'MEDIA_TYPE_NAME').	(aDescriptor newMapping: DirectMapping) from: #mimeType		to: (table fieldNamed: 'MEDIA_TYPE_MIME')</body><body package="GlorpTestModels" selector="descriptorForGlorpPublisher:">descriptorForGlorpPublisher: aDescriptor 	| table titleTable titleStockTable linkTable |	table := self tableNamed: 'GR_PUBLISHER'.	titleTable := self tableNamed: 'PUBLISHER_TITLE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectToManyMapping)		attributeName: #titles;		resultField: (titleTable fieldNamed: 'TITLE');		writeTheOrderField;		orderBy: [:each | (each getTable: titleTable) getField: 'POSITION'];		join: (Join from: (table fieldNamed: 'ID') to: (titleTable fieldNamed: 'PUBLISHER_ID')).	titleStockTable := self tableNamed: 'PUB_TITLES_STOCK'.	(aDescriptor newMapping: DictionaryMapping)		attributeName: #titlesWithNumberInStock;		usesLinkTable: false;		keyField: (titleStockTable fieldNamed: 'TITLE');		valueField: (titleStockTable fieldNamed: 'STOCK');		join: (Join from: (table fieldNamed: 'ID') to: (titleStockTable fieldNamed: 'PUBLISHER_ID')).	linkTable := self tableNamed: 'PUB_EMP_LINK'.	(aDescriptor newMapping: DictionaryMapping)		attributeName: #employees;		usesLinkTable: true;		keyField: ((self tableNamed: 'PUBLISHER_EMP' ) fieldNamed: 'JOBTITLE');		join: (Join 			from: (table fieldNamed: 'ID')			to: (linkTable fieldNamed: 'PUBLISHER_ID')			from: 'A'			to: (linkTable fieldNamed: 'FOO')).	(aDescriptor newMapping: DictionaryMapping)		attributeName: #differentBunchOfEmployeesById;		usesLinkTable: true;		join: (Join 			from: (table fieldNamed: 'ID')			to: (linkTable fieldNamed: 'PUBLISHER_ID')			from: 'B'			to: (linkTable fieldNamed: 'FOO'));		keyField: ((self tableNamed: 'PUB_EMP_LINK') fieldNamed: 'EMP_ID').		"	titleStockLinkTable := self tableNamed: 'PUB_TITLE_LINK'.	titleTable2 := self tableNamed: 'PUBLISHER_TITLE2'.	(aDescriptor newMapping: DictionaryMapping)		attributeName: #titlesWithNumberInStockLink;		usesLinkTable: true;		keyField: (titleTable2 fieldNamed: 'TITLE');		valueField: (titleStockLinkTable fieldNamed: 'STOCK');		linkTableJoin: (Join from: (table fieldNamed: 'ID') to: (titleStockLinkTable fieldNamed: 'PUBLISHER_ID'))."</body><body package="GlorpTestModels" selector="descriptorForGlorpPublisherEmployee:">descriptorForGlorpPublisherEmployee: aDescriptor 	| table |	table := self tableNamed: 'PUBLISHER_EMP'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectMapping) from: #jobTitle		to: (table fieldNamed: 'JOBTITLE').</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('ENCYC' 'ENCYC_ENTRY' 'ENCYC_ENTRY_LINK' 'IMAGINARY_MEDIA_TYPE' 'GR_PUBLISHER' 'PUBLISHER_TITLE' 'PUB_TITLES_STOCK' 'PUB_TITLE_LINK' 'PUBLISHER_TITLE2' 'PUB_EMP_LINK' 'PUBLISHER_EMP').</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: GlorpEncyclopedia;		add: GlorpMediaType;		add: GlorpEncyclopediaEntry;		add: GlorpPublisher;		add: GlorpPublisherEmployee;		yourself</body></methods><methods><class-id>Glorp.GlorpExpressionTableAliasingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testBase">testBase	exp := BaseExpression new.	exp descriptor: (system descriptorFor: GlorpCustomer).	self helpTestBasicAliasing: (system tableNamed: 'GR_CUSTOMER').</body><body package="GlorpTests" selector="testMapping">testMapping	| base |	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	exp := base get: 'transactions'.	self helpTestBasicAliasing: (system tableNamed: 'BANK_TRANS').</body><body package="GlorpTests" selector="testTable">testTable	| base transTable |	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	transTable := system tableNamed: 'BANK_TRANS'.	exp := base getTable: transTable.	self helpTestBasicAliasing: transTable</body><body package="GlorpTests" selector="testTableSameAsBase">testTableSameAsBase	| base custTable |	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	custTable := system tableNamed: 'GR_CUSTOMER'.	exp := base getTable: custTable.	self deny: exp hasTableAliases.	exp assignTableAliasesStartingAt: 1 prefix: ''.	base assignTableAliasesStartingAt: 42 prefix: nil.	self deny: exp hasTableAliases.	self assert: (exp aliasedTableFor: custTable) name = 't42'.</body></methods><methods><class-id>Glorp.GlorpExpressionTableAliasingTest</class-id> <category>support</category><body package="GlorpTests" selector="helpTestBasicAliasing:">helpTestBasicAliasing: aTable	self deny: exp hasTableAliases.	exp assignTableAliasesStartingAt: 1 prefix: 's1t'.	self assert: exp hasTableAliases.	self assert: exp tableAliases size = 1.	self assert: (exp tableAliases at: aTable) name = 's1t1'.</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest</class-id> <category>tests</category><body package="GlorpTests" selector="testClassSelection">testClassSelection	| classes |	classes := (session system descriptorFor: GlorpInventoryItem) classesRequiringIndependentQueries collect: [:each | each name ].	self assert: classes size = 3.	#(#GlorpNonperishableItem #GlorpPerishableItem #GlorpUnassembledItem) do: [:name |		self assert: (classes includes: name) ].	classes := (session system descriptorFor: GlorpPerishableItem) classesRequiringIndependentQueries collect: [:each | each name ].	self assert: classes size = 1.	#(#GlorpPerishableItem) do: [:name |		self assert: (classes includes: name) ].	classes := (session system descriptorFor: GlorpNonperishableItem) classesRequiringIndependentQueries collect: [:each | each name ].	self assert: classes size = 2.	#(#GlorpNonperishableItem #GlorpUnassembledItem) do: [:name |		self assert: (classes includes: name)].</body><body package="GlorpTests" selector="testDirectQuery">testDirectQuery	| items query |	self writeTestHarness.	query := Query readManyOf: GlorpInventoryItem				where: [:each | each name = 'TV'].	items := session execute: query.	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpNonperishableItem]) size = 1.	session reset.	items := session readManyOf: GlorpInventoryItem				where: [:each | each name = 'bicycle'].	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpUnassembledItem]) size = 1.	session reset.	items := session readManyOf: GlorpPerishableItem				where: [:each | each name = 'bicycle'].	self assert: items size = 0.</body><body package="GlorpTests" selector="testDirectSingleQueryForSubclasses">testDirectSingleQueryForSubclasses	| items query |	self writeTestHarness.	(session system descriptorFor: GlorpInventoryItem) typeResolver useSingleQuery: true.	query := Query readManyOf: GlorpInventoryItem				where: [:each | each name = 'TV'].	items := session execute: query.	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpNonperishableItem]) size = 1.	session reset.	items := session readManyOf: GlorpInventoryItem				where: [:each | each name = 'bicycle'].	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpUnassembledItem]) size = 1.	session reset.	items := session readManyOf: GlorpPerishableItem				where: [:each | each name = 'bicycle'].	self assert: items size = 0.</body><body package="GlorpTests" selector="testDirectSingleQueryForSubclassesNoWhereClause">testDirectSingleQueryForSubclassesNoWhereClause	| items query normalResult filtered |	self writeTestHarness.	(session system descriptorFor: GlorpInventoryItem) typeResolver useSingleQuery: true.	query := Query readManyOf: GlorpInventoryItem.	items := session execute: query.	self assert: items size = 7.	GlorpInventoryItem allSubclasses do: [:each |		normalResult := session read: each.		filtered := items select: [:other | other isKindOf: each].		self assert: normalResult size = filtered size].</body><body package="GlorpTests" selector="testNilVariableJoin">testNilVariableJoin	| warehouse |	self writeTestHarness.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	session beginUnitOfWork.	session register: warehouse.	warehouse currentItem: nil.	session commitUnitOfWork.	session reset.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	self assert: warehouse currentItem isNil</body><body package="GlorpTests" selector="testOrderBy">testOrderBy	"We can't use database-level ordering in horizontal inheritance because it does multiple queries. We could, I suppose, sort after the fact, but we don't right now"	| items query |	query := Query returningManyOf: GlorpInventoryItem				where: [:each | each id &lt;= 4].	query orderBy: #name.	self should: [items := session execute: query] raise: Dialect error.</body><body package="GlorpTests" selector="testReadNonAbstractPolymorphic">testReadNonAbstractPolymorphic	"This test excercises a problem that existed with MappingExpression caching its mapping	and which was then copied to the newly created MappingExpressions for subclasses.	This isn't a problem when reading from an abstract class since there are no mappings to cache."	| wagon |		self writeTestHarness.	wagon := session readOneOf: GlorpNonperishableItem where: [:each | each name = 'wagon'].	self should: [wagon serialNumber = 99958]</body><body package="GlorpTests" selector="testReadRelationship">testReadRelationship	| warehouse |		self writeTestHarness.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	self assert: warehouse address = '123 Some Ave.'.	self assert: warehouse currentItem name = 'squash'.	self assert: (warehouse items collect: [:each | each name]) asSortedCollection asArray = #('apples' 'bicycle' 'fridge').</body><body package="GlorpTests" selector="testReadRelationshipSingleQuery">testReadRelationshipSingleQuery	| warehouse |	(session system descriptorFor: GlorpInventoryItem) typeResolver useSingleQuery: true.		self writeTestHarness.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	self assert: warehouse address = '123 Some Ave.'.	self assert: warehouse currentItem name = 'squash'.	self assert: (warehouse items collect: [:each | each name]) asSortedCollection asArray = #('apples' 'bicycle' 'fridge').</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest</class-id> <category>tests - tags</category><body package="GlorpTests" selector="testForwardLookup">testForwardLookup	| image |	self writeTestHarnessForTags.	image := session				readOneOf: GlorpImage				where: [:each | each location = 'testlocation'].	self assert: image tags size = 2.	self assert: (image tags contains: [:tag| tag key = 'first']).	self assert: (image tags contains: [:tag| tag key = 'second']).</body><body package="GlorpTests" selector="testReverseLookup">testReverseLookup	| image |	self writeTestHarnessForTags.	image := session				readOneOf: GlorpImage				where: [:each | each tags anySatisfy: [:tag| tag key = 'third']].	self assert: image tags size = 2.	self assert: (image tags contains: [:tag| tag key = 'first'])not.	self assert: (image tags contains: [:tag| tag key = 'second']).</body><body package="GlorpTests" selector="testTagObjectLookup">testTagObjectLookup	| image |	self writeTestHarnessForTags.	image := session				readOneOf: GlorpTaggableObject				where: [:each | each tags						anySatisfy: [:tag | tag key = 'third']].	self assert: image tags size = 2.	self assert: (image tags			contains: [:tag | tag key = 'first']) not.	self		assert: (image tags				contains: [:tag | tag key = 'second'])</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	session system: (GlorpInheritanceDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database).	session beginTransaction.</body><body package="GlorpTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.	session reset.</body><body package="GlorpTests" selector="writeTestHarness">writeTestHarness	| squash apples fridge bicycle warehouse |	session inUnitOfWorkDo: [	session register: (squash := GlorpPerishableItem new id: 1; name: 'squash'; age: 10; yourself).	session register: (GlorpPerishableItem new id: 2; name: 'zucchini'; age: 14; yourself).	session register: (apples := GlorpPerishableItem new id: 3; name: 'apples'; age: 4; yourself).	session register: (GlorpNonperishableItem new id: 4; name: 'TV'; serialNumber: 56893; yourself).	session register: (fridge := GlorpNonperishableItem new id: 5; name: 'fridge'; serialNumber: 12345; yourself).	session register: (bicycle := GlorpUnassembledItem new id: 6; name: 'bicycle'; serialNumber: 83754; assemblyCost: 100; yourself).	session register: (GlorpUnassembledItem new id: 7; name: 'wagon'; serialNumber: 99958; assemblyCost: 20; yourself).	warehouse := GlorpWarehouse new.	warehouse address: '123 Some Ave.'.	warehouse currentItem: squash.	warehouse items: (Array with: apples with: fridge with: bicycle).	session register: warehouse].	session reset.</body><body package="GlorpTests" selector="writeTestHarnessForTags">writeTestHarnessForTags	| tag1 tag2 tag3 image1 image2 |	session inUnitOfWorkDo: [		tag1 := GlorpTag new label: 'First'; generateKeyFromLabel.		tag2 := GlorpTag new label: 'Second'; generateKeyFromLabel.		tag3 := GlorpTag new label: 'Third'; generateKeyFromLabel.		image1 := GlorpImage new location: 'testlocation'.		session register: image1.			image1 tags add: tag1.		image1 tags add: tag2.			image2 := GlorpImage new location: 'testlocation2'.		session register: image2.			image2 tags add: tag2.		image2 tags add: tag3].	session reset.</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest class</class-id> <category>resources</category><body package="GlorpTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest</class-id> <category>setup</category><body package="GlorpDBTests" selector="descriptorClass">descriptorClass	^GlorpCollectionTypesDescriptorSystem.</body><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := self descriptorClass forPlatform: session platform.	session system: system.	session beginTransaction.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session rollbackTransaction.</body><body package="GlorpDBTests" selector="writeMore">writeMore	| other |	session transact: [		session register: GlorpThingWithLotsOfDifferentCollections example1.		other := GlorpThingWithLotsOfDifferentCollections example1.		other name: 'barney'.		session register: other].</body><body package="GlorpDBTests" selector="writeRows">writeRows	session transact: [		session register: GlorpThingWithLotsOfDifferentCollections example1].</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testReadBack">testReadBack	"Some dialects (e.g. VA) inline yourself so we must send yourSelf."	| thing list |	self writeRows.	session reset.	list := session readManyOf: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing array size = 3.	self		assert:			(self validateFor: thing array against: #('array1' 'array2' 'array3')).	self assert: thing array yourSelf class = Array.	self assert: thing set size = 2.	self assert: thing set yourSelf class = Set.	self assert: (self validateFor: thing set against: #('set1' 'set2')).	self assert: thing orderedCollection size = 2.	self assert: thing orderedCollection yourSelf class = OrderedCollection.	self		assert:			(self				validateFor: thing orderedCollection				against: #('orderedCollection1' 'orderedCollection2')).	self assert: thing orderedCollection first name = 'orderedCollection1'.	self assert: thing bag size = 2.	self assert: thing bag yourSelf class = Bag.	self assert: (self validateFor: thing bag against: #('bag1' 'bag2')).	self assert: thing sortedCollection size = 4.	self assert: thing sortedCollection yourSelf class = SortedCollection.	self assert:			(thing sortedCollection collect: [:each | each name]) asArray				= #('sorted1' 'sorted2' 'sorted3' 'sorted4').</body><body package="GlorpDBTests" selector="testReadBackOneOfSeveral">testReadBackOneOfSeveral	"Some dialects (e.g. VA) inline yourself so we must send yourSelf."	| thing list |	self writeMore.	session reset.	list := session readManyOf: GlorpThingWithLotsOfDifferentCollections where: [:each | each name = 'fred'].	self assert: list size = 1.	thing := list first.	self assert: thing array size = 3.	self		assert:			(self validateFor: thing array against: #('array1' 'array2' 'array3')).	self assert: thing array yourSelf class = Array.	self assert: thing set size = 2.	self assert: thing set yourSelf class = Set.	self assert: (self validateFor: thing set against: #('set1' 'set2')).	self assert: thing orderedCollection size = 2.	self assert: thing orderedCollection yourSelf class = OrderedCollection.	self		assert:			(self				validateFor: thing orderedCollection				against: #('orderedCollection1' 'orderedCollection2')).	self assert: thing bag size = 2.	self assert: thing bag yourSelf class = Bag.	self assert: (self validateFor: thing bag against: #('bag1' 'bag2')).	self assert: thing sortedCollection size = 4.	self assert: thing sortedCollection yourSelf class = SortedCollection.	self assert:			(thing sortedCollection collect: [:each | each name]) asArray				= #('sorted1' 'sorted2' 'sorted3' 'sorted4').</body><body package="GlorpDBTests" selector="testReadCollectionWithOrder">testReadCollectionWithOrder	| thing list |	session transact: [session register: GlorpThingWithLotsOfDifferentCollections exampleForOrdering].	session reset.	list := session readManyOf: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing orderedCollection size = 6.	self		assert:			(thing orderedCollection collect: [:each | each name]) asArray = #('oc6' 'oc5' 'oc4' 'oc3' 'oc7' 'oc8')</body><body package="GlorpDBTests" selector="testReadManyToManyWithOrder">testReadManyToManyWithOrder	| thing list |	session transact: [session register: GlorpThingWithLotsOfDifferentCollections exampleForOrdering].	session reset.	list := session readManyOf: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing orderedCollection size = 6.	self		assert:			(thing orderedCollection collect: [:each | each name]) asArray = #('oc6' 'oc5' 'oc4' 'oc3' 'oc7' 'oc8')</body><body package="GlorpDBTests" selector="testReadOneToManyWithOrder">testReadOneToManyWithOrder	| thing list |	session transact: [session register: GlorpThingWithLotsOfDifferentCollections exampleForOrdering].	session reset.	list := session readManyOf: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing array size = 6.	self		assert:			(thing array collect: [:each | each name]) asArray = #('a1' 'a2' 'a3' 'a9' 'a8' 'a7')</body><body package="GlorpDBTests" selector="validateFor:against:">validateFor: aCollection against: expectedArrayContents	^(aCollection collect: [:each | each name]) asSortedCollection asArray		= expectedArrayContents.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsWithClassModelsTest</class-id> <category>setup</category><body package="GlorpDBTests" selector="descriptorClass">descriptorClass	^GlorpCollectionTypesWithClassModelsDescriptorSystem.</body></methods><methods><class-id>Glorp.GlorpTestModelsPackage class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.GlorpVirtualCollectionBasicTest</class-id> <category>support</category><body package="GlorpDBTests" selector="realObjects">realObjects	"Get the real objects from a virtual collection without resorting to any of its mechanisms except do:, so we can validate against more complex things."	^self realObjectsFrom: vc.</body><body package="GlorpDBTests" selector="realObjectsFrom:">realObjectsFrom: aVirtualCollection	"Get the real objects from a virtual collection without resorting to any of its mechanisms except do:, so we can validate against more complex things."	| all |	all := OrderedCollection new.	aVirtualCollection do: [:each | all add: each].	^all.</body><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session beginTransaction.	self writePersonRows.	vc := session virtualCollectionOf: GlorpPerson.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests" selector="writePersonRows">writePersonRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.</body></methods><methods><class-id>Glorp.GlorpVirtualCollectionBasicTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testCollect">testCollect	| ids |	ids := vc collect: [:each | each id].		self assert: ids size = 3.	ids do: [:each | self assert: each isInteger].</body><body package="GlorpDBTests" selector="testCreation">testCreation		self assert: vc notNil.	self should: [vc isKindOf: GlorpVirtualCollection].</body><body package="GlorpDBTests" selector="testDo">testDo	| all |	all := OrderedCollection new.	vc do: [:each |		self assert: (each isKindOf: GlorpPerson).		all add: each.		].	self assert: all size = 3.	self assert: all asSet size = 3.	self assert: (all collect: [:each | each id]) asSortedCollection asArray = #(86 87 88).</body><body package="GlorpDBTests" selector="testInject">testInject	| sumofIds |	sumofIds := vc inject: 0 into: [:sum :each | sum + each id].	self assert: sumofIds = (86 + 87 + 88).</body><body package="GlorpDBTests" selector="testIsEmpty">testIsEmpty	| vc2 |	self deny: vc isEmpty.	vc2 := vc select: [:each | each id = 98].	self assert: vc2 isEmpty.</body><body package="GlorpDBTests" selector="testReject">testReject	| vc2 |	vc2 := vc reject: [:each | each id &gt; 87 ].	self deny: vc isInstantiated.	self deny: vc2 isInstantiated.	self assert: vc2 size = 2.	self deny: vc isInstantiated.	self assert: vc size = 3.	self assert: (self realObjectsFrom: vc2) size = 2.</body><body package="GlorpDBTests" selector="testSelect">testSelect	| vc2 |	vc2 := vc select: [:each | each id &lt;= 87 ].	self deny: vc isInstantiated.	self deny: vc2 isInstantiated.	self assert: vc2 size = 2.	self deny: vc isInstantiated.	self assert: vc size = 3.	self assert: (self realObjectsFrom: vc2) size = 2.</body></methods><methods><class-id>Glorp.GlorpDeleteTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="checkCustomerDeletedInDatabase">checkCustomerDeletedInDatabase	| result |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_CUSTOMER WHERE ID=1'.	self assert: result isEmpty</body><body package="GlorpDBTests" selector="checkCustomerNotInCache">checkCustomerNotInCache	self assert: (session cacheLookupForClass: GlorpCustomer key: 1) isNil</body><body package="GlorpDBTests" selector="checkCustomerStillInCache">checkCustomerStillInCache	self assert: (session cacheLookupForClass: GlorpCustomer key: 1) notNil</body><body package="GlorpDBTests" selector="checkFoldersDeletedInDatabase">checkFoldersDeletedInDatabase	| result generalResult |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result isEmpty.	generalResult := session accessor 				executeSQLString: 'SELECT * FROM GR_FOLDER'.	self assert: generalResult size = 1.</body><body package="GlorpDBTests" selector="checkFoldersExistInDatabase">checkFoldersExistInDatabase	| result |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result size = 2.</body><body package="GlorpDBTests" selector="checkFoldersNotInCache">checkFoldersNotInCache	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One')) isNil.	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One-A')) isNil.</body><body package="GlorpDBTests" selector="checkMessagesDeletedInDatabase">checkMessagesDeletedInDatabase	| result generalResult |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_MESSAGE WHERE USER_ID = 1'.	self assert: result isEmpty.	generalResult := session accessor 				executeSQLString: 'SELECT * FROM GR_MESSAGE'.	self assert: generalResult size = 1.</body><body package="GlorpDBTests" selector="checkPersonDeletedInDatabase">checkPersonDeletedInDatabase	| result |	result := session accessor 				executeSQLString: 'SELECT * FROM PERSON WHERE ID=1'.	self assert: result isEmpty</body><body package="GlorpDBTests" selector="doDeleteAndDoubleAddOfFoldersFor:">doDeleteAndDoubleAddOfFoldersFor: user	| new2 removed new |	^session		modify: user		in:			[user folders do: [:each | each printString].			removed := user folders detect: [:each | each name = 'One'].			user folders remove: removed.			new := GlorpFolder new name: 'One'.			new user: user.			user folders add: new.			new2 := GlorpFolder new name: 'One'.			new2 user: user.			user folders add: new2].</body><body package="GlorpDBTests" selector="setUpCustomer">setUpCustomer	session beginTransaction.	session accessor 		executeSQLStringNoResult: 'INSERT INTO GR_CUSTOMER VALUES (1,''Fred Flintstone'')'.	^session readOneOf: GlorpCustomer where: [:each | each id = 1].</body><body package="GlorpDBTests" selector="setUpPersonWithAddress">setUpPersonWithAddress	session beginTransaction.	session accessor 		executeSQLStringNoResult: 'INSERT INTO GR_ADDRESS VALUES (2,''Paseo Montril'', ''999'')'.	session accessor 		executeSQLStringNoResult: 'INSERT INTO PERSON VALUES (1,''Fred Flintstone'', 2)'.	^session readOneOf: GlorpPerson where: [:each | each id = 1].</body><body package="GlorpDBTests" selector="testCascadingDeleteAcrossNil">testCascadingDeleteAcrossNil	| person addressRows personRows |	session inTransactionDo: [session accessor dropConstraint: (session system tableNamed: 'PERSON') foreignKeyConstraints first].	[	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #address) beExclusive.	self setUpPersonWithAddress .	session accessor executeSQLString: 'delete from GR_ADDRESS where ID = 2'.	session reset.	person := session readOneOf: GlorpPerson.	"First, make sure this doesn't walkback"	[session beginUnitOfWork.	session delete: person] ensure: [session commitUnitOfWork].	"Now make sure the address is left"	addressRows := session accessor executeSQLString: 'SELECT * FROM GR_ADDRESS'.	self assert: addressRows isEmpty.	personRows :=  session accessor executeSQLString: 'SELECT * FROM PERSON'.	self assert: personRows isEmpty.		] 		ensure: [			session rollbackTransaction.			session inTransactionDo: [session accessor createTableFKConstraints: (session system tableNamed: 'PERSON') ifError: [self halt]]]</body><body package="GlorpDBTests" selector="testCascadingDeleteInstantiating">testCascadingDeleteInstantiating	| user |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session beginUnitOfWork.	user folders do: [:each | each printString].	session delete: user.	session commitUnitOfWork.	self checkFoldersNotInCache.	self checkFoldersDeletedInDatabase.	self checkMessagesDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testCascadingDeleteWithoutInstantiating">testCascadingDeleteWithoutInstantiating	| user |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session beginUnitOfWork.	session delete: user.	session commitUnitOfWork.	self checkFoldersNotInCache.	self checkFoldersDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeleteAndReinsertTwiceWhenRemovingFromAnExclusiveCollection">testDeleteAndReinsertTwiceWhenRemovingFromAnExclusiveCollection	"Make sure that if we add a new thing twice, we get the expected failure of a primary key conflict."	| user |	[self setUpFolders.	self checkFoldersExistInDatabase.	user := session		readOneOf: GlorpUser		where: [:each | each name = 'User One'].	self		should: [self doDeleteAndDoubleAddOfFoldersFor: user]		raise: GlorpDatabaseWriteError] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testDeleteAndReinsertWhenRemovingFromAnExclusiveCollection">testDeleteAndReinsertWhenRemovingFromAnExclusiveCollection	"Test that if we delete something and then re-insert with the same primary key, that it gets converted to an update. This is not really advisable as something to do, since you're really violating the primary key = object identity correspondence, but it can reasonably happen if you're using domain primary keys, link tables reified as objects, or other circumstances"	| user removed result generalResult new |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session modify: user in: [		user folders do: [:each | each printString].		removed := user folders detect: [:each | each name = 'One'].		user folders remove: removed.		new := GlorpFolder new name: 'One'.		new user: user.		user folders add: new].	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One')) == new.	result := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result size = 2.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER'.	self assert: generalResult size = 3.	result := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE WHERE USER_ID = 1'.	self assert: result isEmpty.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE'.	self assert: generalResult size = 1.] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeleteFromAnExclusiveCollectionContainingNil">testDeleteFromAnExclusiveCollectionContainingNil	| user removed |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session modify: user in: [		user folders do: [:each | each printString].		removed := user folders detect: [:each | each name = 'One'].		user folders remove: removed.		user folders add: nil]	"The only assertion is that we shouldn't be crashing here."	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeleteMultipleTable">testDeleteMultipleTable	| passengerRow1 passengerRow2 passenger rows frequentFlyerRow1 frequentFlyerRow2 |		[	session beginTransaction.	passengerRow1 := session system examplePassengerRow.	session writeRow: passengerRow1.	frequentFlyerRow1 := session system exampleFrequentFlyerRow.	session writeRow: frequentFlyerRow1.	passengerRow2 := session system examplePassengerRow2.	session writeRow: passengerRow2.	frequentFlyerRow2 := session system exampleFrequentFlyerRow2.	session writeRow: frequentFlyerRow2.	passenger := session readOneOf: GlorpPassenger.	session delete: passenger.	rows := session accessor executeSQLString: 'SELECT * FROM FREQUENT_FLYER'.	self assert: rows size = 1.	rows := session accessor executeSQLString: 'SELECT * FROM PASSENGER'.	self assert: rows size = 1.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeleteMultipleTableWithOneMissing">testDeleteMultipleTableWithOneMissing	| passengerRow1 passengerRow2 passenger rows frequentFlyerRow2 |		[	session beginTransaction.	passengerRow1 := session system examplePassengerRow.	session writeRow: passengerRow1.	passengerRow2 := session system examplePassengerRow2.	session writeRow: passengerRow2.	frequentFlyerRow2 := session system exampleFrequentFlyerRow2.	session writeRow: frequentFlyerRow2.	passenger := session readOneOf: GlorpPassenger where: [:each | each id = 1].	session delete: passenger.	rows := session accessor executeSQLString: 'SELECT * FROM FREQUENT_FLYER'.	self assert: rows size = 1.	rows := session accessor executeSQLString: 'SELECT * FROM PASSENGER'.	self assert: rows size = 1.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testDeleteWhenRemovingFromAnExclusiveCollection">testDeleteWhenRemovingFromAnExclusiveCollection	| user removed result generalResult |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session modify: user in: [		user folders do: [:each | each printString].		removed := user folders detect: [:each | each name = 'One'].		user folders remove: removed].	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One')) isNil.	result := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result size = 1.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER'.	self assert: generalResult size = 2.	result := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE WHERE USER_ID = 1'.	self assert: result isEmpty.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE'.	self assert: generalResult size = 1.] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testNormalDeleteOnFolders">testNormalDeleteOnFolders	| user |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session beginUnitOfWork.	session delete: user.	user folders do: [:each | 		session delete: each.		each messages do: [:eachMessage |			session delete: eachMessage]].	session commitUnitOfWork.	self checkFoldersNotInCache.	self checkFoldersDeletedInDatabase.	self checkMessagesDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testUnitOfWorkDelete">testUnitOfWorkDelete	| customer result |		[customer := self setUpCustomer.	session beginUnitOfWork.	session delete: customer.	result := session accessor 				executeSQLString: 'SELECT * FROM GR_CUSTOMER WHERE ID=1'.	self assert: result size = 1.	self 		assert: (session readOneOf: GlorpCustomer where: [:each | each id = 1]) isNil.	self checkCustomerStillInCache.	session commitUnitOfWork.	self checkCustomerNotInCache.	self checkCustomerDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testUnitOfWorkDeleteOrder">testUnitOfWorkDeleteOrder	| person |		[person := self setUpPersonWithAddress.	session beginUnitOfWork.	session delete: person.	session delete: person address.	session commitUnitOfWork.	self checkPersonDeletedInDatabase.] 			ensure: [session rollbackTransaction]</body></methods><methods><class-id>Glorp.GlorpDeleteTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests" selector="setUpFolders">setUpFolders	session system: (GlorpCompositeKeyDescriptorSystem forPlatform: session platform).	session beginTransaction.	session transact: [session register: session system example1].	session reset.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpExampleSystem</class-id> <category>initialize</category><body package="GlorpTestModels" selector="initialize">initialize	objects := Dictionary new.</body></methods><methods><class-id>Glorp.GlorpExampleSystem</class-id> <category>misc</category><body package="GlorpTestModels" selector="lookupObject:ofClass:ifAbsentPut:">lookupObject: aNumber ofClass: aClass ifAbsentPut: absentBlock	^(objects at: aClass ifAbsentPut: [Dictionary new]) at: aNumber ifAbsentPut: absentBlock.</body></methods><methods><class-id>Glorp.GlorpExampleSystem</class-id> <category>api</category><body package="GlorpTestModels" selector="objectNumber:ofClass:">objectNumber: aNumber ofClass: aClass	| symbol instance|	instance := self lookupObject: aNumber ofClass: aClass ifAbsentPut: [aClass new].	symbol := ('example', aClass name, 'Number', aNumber printString, ':') asSymbol.	self perform: symbol with: instance.	^instance.</body></methods><methods><class-id>Glorp.GlorpExampleSystem class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpBankExampleSystem</class-id> <category>examples</category><body package="GlorpTestModels" selector="exampleGlorpAddressNumber1:">exampleGlorpAddressNumber1: anAddress	anAddress id: 12.	anAddress street: 'Paseo Montril'.	anAddress number: '10185'.</body><body package="GlorpTestModels" selector="exampleGlorpBankAccountNumber1:">exampleGlorpBankAccountNumber1: anAccount	anAccount id: 1.	anAccount accountNumber: (self objectNumber: 1 ofClass: GlorpBankAccountNumber).</body><body package="GlorpTestModels" selector="exampleGlorpBankAccountNumber2:">exampleGlorpBankAccountNumber2: anAccount	anAccount id: 2.	anAccount accountNumber: (self objectNumber: 2 ofClass: GlorpBankAccountNumber).</body><body package="GlorpTestModels" selector="exampleGlorpBankAccountNumberNumber1:">exampleGlorpBankAccountNumberNumber1: aBankAccountNumber	aBankAccountNumber bankCode: '004'.	aBankAccountNumber branchNumber: 0342.	aBankAccountNumber accountNumber: '12345'.</body><body package="GlorpTestModels" selector="exampleGlorpBankAccountNumberNumber2:">exampleGlorpBankAccountNumberNumber2: aBankAccountNumber	aBankAccountNumber bankCode: '004'.	aBankAccountNumber branchNumber: 0342.	aBankAccountNumber accountNumber: '01010'.</body><body package="GlorpTestModels" selector="exampleGlorpBankTransactionNumber1:">exampleGlorpBankTransactionNumber1: aTrans	"Nothing to initialize"</body><body package="GlorpTestModels" selector="exampleGlorpBankTransactionNumber2:">exampleGlorpBankTransactionNumber2: aTrans	"Nothing to initialize"</body><body package="GlorpTestModels" selector="exampleGlorpCustomerNumber1:">exampleGlorpCustomerNumber1: aCustomer	aCustomer id: 1.	aCustomer name: 'Fred Flintstone'.	aCustomer addTransaction: (self objectNumber: 1 ofClass: GlorpBankTransaction).	aCustomer addTransaction: (self objectNumber: 2 ofClass: GlorpBankTransaction).	aCustomer addAccount: (self objectNumber: 1 ofClass: GlorpBankAccount).	aCustomer addAccount: (self objectNumber: 2 ofClass: GlorpBankAccount).</body><body package="GlorpTestModels" selector="exampleGlorpEmailAddressNumber1:">exampleGlorpEmailAddressNumber1: anEmailAddress 	anEmailAddress id: 2.	anEmailAddress user: 'foo'.	anEmailAddress host: 'bar.com'</body><body package="GlorpTestModels" selector="exampleGlorpPersonNumber1:">exampleGlorpPersonNumber1: aPerson 	aPerson id: 1.	aPerson name: 'Barney Rubble'.	aPerson address: (self objectNumber: 1 ofClass: GlorpAddress).		aPerson emailAddress: (self objectNumber: 1 ofClass: GlorpEmailAddress).</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels" selector="tableForBANK_ACCT:">tableForBANK_ACCT: aTable	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'BANK_CODE' type: (platform varChar: 10).	aTable createFieldNamed: 'BRANCH_NO' type: (platform int4).	aTable createFieldNamed: 'ACCT_NO' type: (platform varChar: 10).</body><body package="GlorpTestModels" selector="tableForBANK_TRANS:">tableForBANK_TRANS: aTable 	| ownerId |	(aTable createFieldNamed: 'ID' type: platform serial)		bePrimaryKey.	ownerId := aTable createFieldNamed: 'OWNER_ID' type: platform int4.	aTable addForeignKeyFrom: ownerId		to: ((self tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	aTable createFieldNamed: 'AMT_CURR' type: (platform varChar: 5).	aTable createFieldNamed: 'AMT_AMT' type: platform int4.	aTable createFieldNamed: 'SRVC_DESC' type: (platform varChar: 30).	aTable createFieldNamed: 'SRVC_AMT_CURR' type: (platform varChar: 5).	aTable createFieldNamed: 'SRVC_AMT_AMT' type: platform int4.</body><body package="GlorpTestModels" selector="tableForCOMPRESSED_MONEY_TABLE:">tableForCOMPRESSED_MONEY_TABLE: aTable	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'CURRENCY_NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'AMOUNT' type: platform int4.</body><body package="GlorpTestModels" selector="tableForCUSTOMER_ACCT_LINK:">tableForCUSTOMER_ACCT_LINK: aTable	| customerId accountId |	customerId := (aTable createFieldNamed: 'CUSTOMER_ID' type: platform int4).	aTable addForeignKeyFrom: customerId to: ((self tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	accountId := aTable createFieldNamed: 'ACCT_ID' type: platform int4.	aTable addForeignKeyFrom: accountId to: ((self tableNamed: 'BANK_ACCT') fieldNamed: 'ID').	aTable addIndexForFields: (Array with: customerId with: accountId).</body><body package="GlorpTestModels" selector="tableForEMAIL_ADDRESS:">tableForEMAIL_ADDRESS: aTable	| personId |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	(aTable createFieldNamed: 'USER_NAME' type: (platform varChar: 20)) beIndexed.	aTable createFieldNamed: 'HOST_NAME' type: (platform varChar: 20).	personId := aTable createFieldNamed: 'PERSON_ID' type: platform int4.	personId beIndexed.	(aTable addForeignKeyFrom: personId to: ((self tableNamed: 'PERSON') fieldNamed: 'ID')).</body><body package="GlorpTestModels" selector="tableForFKADDRESS:">tableForFKADDRESS: aTable 	| contact |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	contact := aTable createFieldNamed: 'CONTACT_ID' type: platform int4.	aTable addForeignKeyFrom: contact		to: ((self tableNamed: 'FKCONTACT') fieldNamed: 'ID')</body><body package="GlorpTestModels" selector="tableForFKCONTACT:">tableForFKCONTACT: aTable 	| address |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	address := aTable createFieldNamed: 'ADDRESS_ID' type: platform int4.	aTable addForeignKeyFrom: address		to: ((self tableNamed: 'FKADDRESS') fieldNamed: 'ID')</body><body package="GlorpTestModels" selector="tableForGR_ADDRESS:">tableForGR_ADDRESS: aTable 	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'STREET' type: (platform varChar: 20).	aTable createFieldNamed: 'HOUSE_NUM' type: (platform varChar: 20)</body><body package="GlorpTestModels" selector="tableForGR_CUSTOMER:">tableForGR_CUSTOMER: aTable 	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20)</body><body package="GlorpTestModels" selector="tableForMONEY_IMAGINARY_TABLE:">tableForMONEY_IMAGINARY_TABLE: aTable	aTable isImaginary: true.	aTable createFieldNamed: 'CURRENCY' type: (platform varChar: 5).	aTable createFieldNamed: 'AMOUNT' type: platform int4</body><body package="GlorpTestModels" selector="tableForPERSON:">tableForPERSON: aTable	| addrId|	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	addrId := aTable createFieldNamed: 'ADDRESS_ID' type: platform int4.	aTable addForeignKeyFrom: addrId to: ((self tableNamed: 'GR_ADDRESS') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForSTUFF:">tableForSTUFF: aTable 	(aTable createFieldNamed: 'ID' type: platform inMemorySequence)		bePrimaryKey.	aTable createFieldNamed: 'THING' type: (platform varChar: 20)</body><body package="GlorpTestModels" selector="tableForTRANSFORMED_TIME:">tableForTRANSFORMED_TIME: aTable	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'TIMEFIELD' type: platform int4.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels" selector="exampleAccountRow1">exampleAccountRow1	| accountTable row |	accountTable := self tableNamed: 'BANK_ACCT'.	row := DatabaseRow newForTable: accountTable.	row at: (accountTable fieldNamed: 'ID') put: 9874.	row at: (accountTable fieldNamed: 'BANK_CODE') put: '1'.	row at: (accountTable fieldNamed: 'BRANCH_NO') put: 2.	row at: (accountTable fieldNamed: 'ACCT_NO') put: '3'.	^row.</body><body package="GlorpTestModels" selector="exampleAccountRow2">exampleAccountRow2	| accountTable row |	accountTable := self tableNamed: 'BANK_ACCT'.	row := DatabaseRow newForTable: accountTable.	row at: (accountTable fieldNamed: 'ID') put: 6.	row at: (accountTable fieldNamed: 'BANK_CODE') put: '2'.	row at: (accountTable fieldNamed: 'BRANCH_NO') put: 3.	row at: (accountTable fieldNamed: 'ACCT_NO') put: '4'.	^row.</body><body package="GlorpTestModels" selector="exampleAccountRow3">exampleAccountRow3	| accountTable row |	accountTable := self tableNamed: 'BANK_ACCT'.	row := DatabaseRow newForTable: accountTable.	row at: (accountTable fieldNamed: 'ID') put: 22.	row at: (accountTable fieldNamed: 'BANK_CODE') put: '2'.	row at: (accountTable fieldNamed: 'BRANCH_NO') put: 712.	row at: (accountTable fieldNamed: 'ACCT_NO') put: '5551212'.	^row.</body><body package="GlorpTestModels" selector="exampleAddressRow">exampleAddressRow	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 123.	row at: (addressTable fieldNamed: 'STREET') put: 'Paseo Montril'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '10185'.	^row</body><body package="GlorpTestModels" selector="exampleAddressRowForOrdering1">exampleAddressRowForOrdering1	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 1.	row at: (addressTable fieldNamed: 'STREET') put: 'Alpha'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '300'.	^row</body><body package="GlorpTestModels" selector="exampleAddressRowForOrdering2">exampleAddressRowForOrdering2	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 2.	row at: (addressTable fieldNamed: 'STREET') put: 'Beta'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '200'.	^row</body><body package="GlorpTestModels" selector="exampleAddressRowForOrdering3">exampleAddressRowForOrdering3	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 3.	row at: (addressTable fieldNamed: 'STREET') put: 'Gamma'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '100'.	^row</body><body package="GlorpTestModels" selector="exampleAddressRowForOrdering4">exampleAddressRowForOrdering4	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 6.	row at: (addressTable fieldNamed: 'STREET') put: 'Beta'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '120'.	^row</body><body package="GlorpTestModels" selector="exampleAddressRowForOrdering5">exampleAddressRowForOrdering5	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 4.	row at: (addressTable fieldNamed: 'STREET') put: 'Beta'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '130'.	^row</body><body package="GlorpTestModels" selector="exampleAddressRowWithDifferentStreet">exampleAddressRowWithDifferentStreet	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 123.	row at: (addressTable fieldNamed: 'STREET') put: 'Garden of the Gods'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '10185'.	^row</body><body package="GlorpTestModels" selector="exampleBankTransactionRow">exampleBankTransactionRow	| table row |	table := self tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'OWNER_ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'CDN'.	row atFieldNamed: 'AMT_AMT' put: 7.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'USD'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	^row</body><body package="GlorpTestModels" selector="exampleBankTransactionRow2">exampleBankTransactionRow2	| table row |	table := self tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'OWNER_ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'EUR'.	row atFieldNamed: 'AMT_AMT' put: 45.	row atFieldNamed: 'SRVC_DESC' put: 'deposit'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'EUR'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 1.	^row</body><body package="GlorpTestModels" selector="exampleCALinkRow1">exampleCALinkRow1	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 9874.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 27.	^row.</body><body package="GlorpTestModels" selector="exampleCALinkRow2">exampleCALinkRow2	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 6.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 27.	^row.</body><body package="GlorpTestModels" selector="exampleCALinkRow3">exampleCALinkRow3	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 22.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 28.	^row.</body><body package="GlorpTestModels" selector="exampleCALinkRow4">exampleCALinkRow4	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 6.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 28.	^row.</body><body package="GlorpTestModels" selector="exampleCompressedMoneyRow">exampleCompressedMoneyRow	| table row |	table := self  tableNamed: 'COMPRESSED_MONEY_TABLE'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 123.	row at: (table fieldNamed: 'AMOUNT') put: 12.	row at: (table fieldNamed: 'CURRENCY_NAME') put: 'CDN'.	^row</body><body package="GlorpTestModels" selector="exampleCompressedMoneyRow2">exampleCompressedMoneyRow2	| table row |	table := self  tableNamed: 'COMPRESSED_MONEY_TABLE'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 124.	row at: (table fieldNamed: 'AMOUNT') put: 15.	row at: (table fieldNamed: 'CURRENCY_NAME') put: 'CDN'.	^row</body><body package="GlorpTestModels" selector="exampleCustomerRow1">exampleCustomerRow1	| customerTable row |	customerTable := self tableNamed: 'GR_CUSTOMER'.	row := DatabaseRow newForTable: customerTable.	row at: (customerTable fieldNamed: 'ID') put: 27.	row at: (customerTable fieldNamed: 'NAME') put: 'aCustomer'.	^row.</body><body package="GlorpTestModels" selector="exampleCustomerRow2">exampleCustomerRow2	| customerTable row |	customerTable := self tableNamed: 'GR_CUSTOMER'.	row := DatabaseRow newForTable: customerTable.	row at: (customerTable fieldNamed: 'ID') put: 28.	row at: (customerTable fieldNamed: 'NAME') put: 'anotherCustomer'.	^row.</body><body package="GlorpTestModels" selector="exampleEmailAddressRow1">exampleEmailAddressRow1	| personTable row |	personTable := self tableNamed: 'EMAIL_ADDRESS'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 42.	row at: (personTable fieldNamed: 'USER_NAME') put: 'alan'.	row at: (personTable fieldNamed: 'HOST_NAME') put: 'objectpeople.com'.	row at: (personTable fieldNamed: 'PERSON_ID') put: 3.	^row.</body><body package="GlorpTestModels" selector="exampleEmailAddressRow2">exampleEmailAddressRow2	| personTable row |	personTable := self tableNamed: 'EMAIL_ADDRESS'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 54321.	row at: (personTable fieldNamed: 'USER_NAME') put: 'johnson'.	row at: (personTable fieldNamed: 'HOST_NAME') put: 'cs.uiuc.edu'.	row at: (personTable fieldNamed: 'PERSON_ID') put: 3.	^row.</body><body package="GlorpTestModels" selector="exampleFrequentFlyerRow">exampleFrequentFlyerRow	| ffTable row |	ffTable := self tableNamed: 'FREQUENT_FLYER'.	row := DatabaseRow newForTable: ffTable.	row at: (ffTable fieldNamed: 'ID') put: 1.	row at: (ffTable fieldNamed: 'POINTS') put: 10000.	row at: (ffTable fieldNamed: 'AIRLINE_ID') put: nil.	^row.</body><body package="GlorpTestModels" selector="exampleFrequentFlyerRow2">exampleFrequentFlyerRow2	| ffTable row |	ffTable := self tableNamed: 'FREQUENT_FLYER'.	row := DatabaseRow newForTable: ffTable.	row at: (ffTable fieldNamed: 'ID') put: 2.	row at: (ffTable fieldNamed: 'POINTS') put: 7.	row at: (ffTable fieldNamed: 'AIRLINE_ID') put: nil.	^row.</body><body package="GlorpTestModels" selector="exampleModifiedAddressRow">exampleModifiedAddressRow	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 123.	row at: (addressTable fieldNamed: 'STREET') put: 'Something Else'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '10185'.	^row</body><body package="GlorpTestModels" selector="examplePassengerRow">examplePassengerRow	| passengerTable row |	passengerTable := self tableNamed: 'PASSENGER'.	row := DatabaseRow newForTable: passengerTable.	row at: (passengerTable fieldNamed: 'ID') put: 1.	row at: (passengerTable fieldNamed: 'NAME') put: 'Some Passenger'.	^row.</body><body package="GlorpTestModels" selector="examplePassengerRow2">examplePassengerRow2	| passengerTable row |	passengerTable := self tableNamed: 'PASSENGER'.	row := DatabaseRow newForTable: passengerTable.	row at: (passengerTable fieldNamed: 'ID') put: 2.	row at: (passengerTable fieldNamed: 'NAME') put: 'Another Passenger'.	^row.</body><body package="GlorpTestModels" selector="examplePersonRow1">examplePersonRow1	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 3.	row at: (personTable fieldNamed: 'NAME') put: 'aPerson'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 123.	^row.</body><body package="GlorpTestModels" selector="examplePersonRow2">examplePersonRow2	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 4.	row at: (personTable fieldNamed: 'NAME') put: 'aPerson'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: nil.	^row.</body><body package="GlorpTestModels" selector="examplePersonRowForOrdering1">examplePersonRowForOrdering1	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 86.	row at: (personTable fieldNamed: 'NAME') put: 'person1'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 2.	^row.</body><body package="GlorpTestModels" selector="examplePersonRowForOrdering2">examplePersonRowForOrdering2	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 87.	row at: (personTable fieldNamed: 'NAME') put: 'person2'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 3.	^row.</body><body package="GlorpTestModels" selector="examplePersonRowForOrdering3">examplePersonRowForOrdering3	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 88.	row at: (personTable fieldNamed: 'NAME') put: 'person3'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 1.	^row.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>tables/airline</category><body package="GlorpTestModels" selector="tableForAIRLINE:">tableForAIRLINE: aTable	(aTable createFieldNamed: 'ID' type: platform inMemorySequence) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20)</body><body package="GlorpTestModels" selector="tableForAIRLINE_MEAL:">tableForAIRLINE_MEAL: aTable	aTable createFieldNamed: 'ID' type: platform int4.	aTable createFieldNamed: 'DESCR' type: (platform varChar: 20).	aTable createFieldNamed: 'FLIGHT_ID' type: platform int4</body><body package="GlorpTestModels" selector="tableForFLIGHT:">tableForFLIGHT: aTable	aTable name: 'FLIGHT'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'FLIGHT_NUM' type: platform int4</body><body package="GlorpTestModels" selector="tableForFLIGHT_PASS:">tableForFLIGHT_PASS: aTable	| flight pass airline |	aTable name: 'FLIGHT_PASS'.	flight := aTable createFieldNamed: 'FLIGHT_ID' type: platform int4.	aTable addForeignKeyFrom: flight		to: ((self tableNamed: 'FLIGHT') fieldNamed: 'ID').	pass := aTable createFieldNamed: 'PASS_ID' type: platform int4.	aTable addForeignKeyFrom: pass		to: ((self tableNamed: 'PASSENGER') fieldNamed: 'ID').	airline := aTable createFieldNamed: 'AIRLINE_ID' type: platform int4.	aTable addForeignKeyFrom: airline		to: ((self tableNamed: 'AIRLINE') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForFREQUENT_FLYER:">tableForFREQUENT_FLYER: aTable 	| airlineId |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'POINTS' type: platform int4.	airlineId := aTable createFieldNamed: 'AIRLINE_ID' type: platform int4.	aTable addForeignKeyFrom: airlineId to: ((self tableNamed: 'AIRLINE') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForGR_TRAVEL_AGENT:">tableForGR_TRAVEL_AGENT: aTable 	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'AGENT_NAME' type: (platform varchar: 50).	aTable createFieldNamed: 'AGENCY_NAME' type: (platform varchar: 50).</body><body package="GlorpTestModels" selector="tableForITINERARY:">tableForITINERARY: aTable 	| res |	(aTable createFieldNamed: 'ID' type: platform serial)		bePrimaryKey.	res := aTable createFieldNamed: 'RES_ID' type: (platform int4).	aTable addForeignKeyFrom: res		to: ((self tableNamed: 'RESERVATION') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForPASSENGER:">tableForPASSENGER: aTable	| |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20)</body><body package="GlorpTestModels" selector="tableForRESERVATION:">tableForRESERVATION: aTable 	| pass |	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	pass := aTable createFieldNamed: 'PASS_ID' type: (platform int4).	aTable addForeignKeyFrom: pass		to: ((self tableNamed: 'PASSENGER') fieldNamed: 'ID').</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/other</category><body package="GlorpTestModels" selector="classModelForDefaultableThing:">classModelForDefaultableThing: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #boolean type: Boolean.	aClassModel newAttributeNamed: #integer type: Integer.</body><body package="GlorpTestModels" selector="classModelForGlorpRecordWithUpdateTime:">classModelForGlorpRecordWithUpdateTime: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #updateTime type: Timestamp.	aClassModel newAttributeNamed: #updateSomeOtherThing type: String.</body><body package="GlorpTestModels" selector="descriptorForDefaultableThing:">descriptorForDefaultableThing: aDescriptor	| table |	table := self tableNamed: 'DEFAULTABLE_THING'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #boolean		to: (table fieldNamed: 'MY_BOOL').	(aDescriptor newMapping: DirectMapping)		from: #integer		to: (table fieldNamed: 'MY_INT').</body><body package="GlorpTestModels" selector="descriptorForGlorpCompressedMoney:">descriptorForGlorpCompressedMoney: aDescriptor 	| table currencyField amountField |	table := self tableNamed: 'COMPRESSED_MONEY_TABLE'.	aDescriptor 		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	currencyField := table fieldNamed: 'CURRENCY_NAME'.	amountField := table fieldNamed: 'AMOUNT'.	aDescriptor table: table.	aDescriptor addMapping: (AdHocMapping 				forAttribute: #array				fromDb: 					[:row :elementBuilder :context| 					Array with: (elementBuilder valueOfField: (context translateField: currencyField) in: row)						with: (elementBuilder valueOfField: (context translateField: amountField) in: row)]				toDb: 					[:rows :attribute :attributeRows | 					(rows at: table) at: currencyField put: (attribute at: 1).					(rows at: table) at: amountField put: (attribute at: 2)]				mappingFields: (Array with: currencyField with: amountField)).	"Note that position won't work if we have a join. We need to take the elementbuilder into account"	^aDescriptor</body><body package="GlorpTestModels" selector="descriptorForGlorpRecordWithUpdateTime:">descriptorForGlorpRecordWithUpdateTime: aDescriptor	| table |	table := self tableNamed: 'RECORD_WITH_UPDATE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectMapping)		from: #updateTime		to: (table fieldNamed: 'UPDATE_TIME').	(aDescriptor newMapping: DirectMapping)		from: #updateSomeOtherThing		to: (table fieldNamed: 'UPDATE_OTHER_THING').</body><body package="GlorpTestModels" selector="descriptorForGlorpTransformedTime:">descriptorForGlorpTransformedTime: aDescriptor 	| table timeField |	table := self tableNamed: 'TRANSFORMED_TIME'.	aDescriptor 		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	timeField := table fieldNamed: 'TIMEFIELD'.	aDescriptor table: table.	aDescriptor addMapping: (AdHocMapping 				forAttribute: #time				fromDb: 					[:row :elementBuilder :context| 					Time fromSeconds: (elementBuilder valueOfField: (context translateField: timeField) in: row) ]				toDb: 					[:rows :attribute :attributeRows | 					(rows at: table) at: timeField put: attribute asSeconds]				mappingFields: (Array with: timeField)).	"Note that position won't work if we have a join. We need to take the elementbuilder into account"	^aDescriptor</body><body package="GlorpTestModels" selector="tableForDEFAULTABLE_THING:">tableForDEFAULTABLE_THING: aTable 	| boolean converter |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	boolean := aTable createFieldNamed: 'MY_BOOL' type: (platform boolean).	"We want a default value for this field, but we can't just use a boolean, because in some database we can represent that directly, but in others it will need to be converted to an integer. And likewise we can't just use an integer, so we need to do an explicit conversion."	converter := boolean converterForStType: Boolean.	boolean defaultValue: (converter convert: false toDatabaseRepresentationAs: boolean type).	(aTable createFieldNamed: 'MY_INT' type: (platform int4)) defaultValue: 4.</body><body package="GlorpTestModels" selector="tableForRECORD_WITH_UPDATE:">tableForRECORD_WITH_UPDATE: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	(aTable createFieldNamed: 'NAME' type: (platform varchar: 20)).	aTable createFieldNamed: 'UPDATE_TIME' type: (platform versionFieldFor: platform timestamp) generateOverExistingValues.	"OK, it's not much of a comment, we just print the current time. Note that this field is completely unmapped"	aTable createFieldNamed: 'UPDATE_COMMENT' type: (platform generatorFor: (platform varchar: 20) withBlock: [Time now printString]) generateOverExistingValues.	"But this one *is* mapped"	aTable createFieldNamed: 'UPDATE_OTHER_THING' type: (platform generatorFor: (platform varchar: 20) withBlock: [Time now printString]) generateOverExistingValues.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/bank</category><body package="GlorpTestModels" selector="classModelForGlorpBankAccount:">classModelForGlorpBankAccount: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #accountNumber type: GlorpBankAccountNumber.	aClassModel newAttributeNamed: #accountHolders collectionOf: GlorpCustomer.</body><body package="GlorpTestModels" selector="classModelForGlorpBankAccountNumber:">classModelForGlorpBankAccountNumber: aClassModel	aClassModel newAttributeNamed: #bankCode.	aClassModel newAttributeNamed: #branchNumber.	aClassModel newAttributeNamed: #accountNumber.</body><body package="GlorpTestModels" selector="classModelForGlorpBankBranch:">classModelForGlorpBankBranch: aClassModel	aClassModel newAttributeNamed: #branchNumber.	aClassModel newAttributeNamed: #accounts collectionOf: GlorpBankAccount.</body><body package="GlorpTestModels" selector="classModelForGlorpBankTransaction:">classModelForGlorpBankTransaction: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #owner type: GlorpCustomer.	aClassModel newAttributeNamed: #amount type: GlorpMoney.	aClassModel newAttributeNamed: #serviceCharge type: GlorpServiceCharge.</body><body package="GlorpTestModels" selector="classModelForGlorpCustomer:">classModelForGlorpCustomer: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #transactions collectionOf: GlorpBankTransaction.	aClassModel newAttributeNamed: #accounts collectionOf: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedById collectionOf: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedByIdDescending collectionOf: GlorpBankAccount.</body><body package="GlorpTestModels" selector="classModelForGlorpEmailAddress:">classModelForGlorpEmailAddress: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #user.	aClassModel newAttributeNamed: #host.</body><body package="GlorpTestModels" selector="classModelForGlorpMoney:">classModelForGlorpMoney: aClassModel	aClassModel newAttributeNamed: #currency.	aClassModel newAttributeNamed: #amount.</body><body package="GlorpTestModels" selector="classModelForGlorpPerson:">classModelForGlorpPerson: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #address type: GlorpAddress.	aClassModel newAttributeNamed: #emailAddresses collectionOf: GlorpEmailAddress.</body><body package="GlorpTestModels" selector="classModelForGlorpServiceCharge:">classModelForGlorpServiceCharge: aClassModel	aClassModel newAttributeNamed: #description.	aClassModel newAttributeNamed: #amount type: GlorpMoney.</body><body package="GlorpTestModels" selector="descriptorForGlorpBankAccount:">descriptorForGlorpBankAccount: aDescriptor 	| table |	table := self tableNamed: 'BANK_ACCT'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id				to: (table fieldNamed: 'ID').	(aDescriptor newMapping: ToManyMapping)				attributeName: #accountHolders;				useLinkTable.	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #accountNumber.</body><body package="GlorpTestModels" selector="descriptorForGlorpBankAccountNumber:">descriptorForGlorpBankAccountNumber: aDescriptor	| table |	table := self tableNamed: 'BANK_ACCT'.	aDescriptor table: table."	aDescriptor addMapping: ((DirectMapping from: #bankCode to: (table fieldNamed: 'BANK_CODE')) type: Integer)."	(aDescriptor newMapping: DirectMapping) from: #bankCode to: (table fieldNamed: 'BANK_CODE').	(aDescriptor newMapping: DirectMapping) from: #branchNumber to: (table fieldNamed: 'BRANCH_NO').	(aDescriptor newMapping: DirectMapping) from: #accountNumber to: (table fieldNamed: 'ACCT_NO').</body><body package="GlorpTestModels" selector="descriptorForGlorpBankBranch:">descriptorForGlorpBankBranch: aDescriptor	| table distinctBranchNumber mapping |	table := self tableNamed: 'BANK_ACCT'.	aDescriptor table: table.	distinctBranchNumber := [:each | ((each getTable: table) getField: (table fieldNamed: 'BRANCH_NO')) distinct] asGlorpExpression.	mapping := aDescriptor newMapping: DirectMapping.	mapping from: #branchNumber to: distinctBranchNumber.	mapping readOnly: true.	aDescriptor keyFields: (Array with: distinctBranchNumber).	(aDescriptor newMapping: ToManyMapping)		attributeName: #accounts;		readOnly: true;		join: 						(Join								from: distinctBranchNumber								to: (table fieldNamed: 'BRANCH_NO')).</body><body package="GlorpTestModels" selector="descriptorForGlorpBankTransaction:">descriptorForGlorpBankTransaction: aDescriptor	| table | 	table := self tableNamed: 'BANK_TRANS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id				to: (table fieldNamed: 'ID').	(aDescriptor newMapping: OneToOneMapping)				attributeName: #owner.	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #amount;				fieldTranslation: ((Join new)							addSource: (table fieldNamed: 'AMT_AMT')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'AMOUNT');							addSource: (table fieldNamed: 'AMT_CURR')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'CURRENCY');							yourself).	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #serviceCharge.</body><body package="GlorpTestModels" selector="descriptorForGlorpCustomer:">descriptorForGlorpCustomer: aDescriptor	| table |	table := self tableNamed: 'GR_CUSTOMER'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME'); shouldProxy: true.	(aDescriptor newMapping: ToManyMapping)			attributeName: #transactions.	(aDescriptor newMapping: ToManyMapping)			attributeName: #accounts;			useLinkTable.	"Two additional relationships, there to test ordering within a mapping, where the order is determined by a field in the link table"	(aDescriptor newMapping: ToManyMapping)			attributeName: #accountsSortedById;			readOnly: true;			useLinkTable;			orderBy: [:each | (each getTable: 'CUSTOMER_ACCT_LINK') getField: 'ACCT_ID'].	(aDescriptor newMapping: ManyToManyMapping)			attributeName: #accountsSortedByIdDescending;			readOnly: true;			useLinkTable;			orderBy: [:each | ((each getTable: 'CUSTOMER_ACCT_LINK') getField: 'ACCT_ID') descending].</body><body package="GlorpTestModels" selector="descriptorForGlorpEmailAddress:">descriptorForGlorpEmailAddress: aDescriptor	| table |	table := self tableNamed: 'EMAIL_ADDRESS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #user to: (table fieldNamed: 'USER_NAME').	(aDescriptor newMapping: DirectMapping) from: #host to: (table fieldNamed: 'HOST_NAME').</body><body package="GlorpTestModels" selector="descriptorForGlorpMoney:">descriptorForGlorpMoney: aDescriptor	| table |	table := self tableNamed: 'MONEY_IMAGINARY_TABLE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #currency type: Symbol to: (table fieldNamed: 'CURRENCY').	(aDescriptor newMapping: DirectMapping) from: #amount to: (table fieldNamed: 'AMOUNT').	^aDescriptor.</body><body package="GlorpTestModels" selector="descriptorForGlorpPerson:">descriptorForGlorpPerson: aDescriptor	| table |	table := self tableNamed: 'PERSON'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #addressId to: (table fieldNamed: 'ADDRESS_ID').	(aDescriptor newMapping: OneToOneMapping)			attributeName: #address.	(aDescriptor newMapping: ToManyMapping)			attributeName: #emailAddresses;			orderBy: #id.</body><body package="GlorpTestModels" selector="descriptorForGlorpServiceCharge:">descriptorForGlorpServiceCharge: aDescriptor 		| table |	table := self tableNamed: 'BANK_TRANS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #description				to: (table fieldNamed: 'SRVC_DESC').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #amount;				fieldTranslation: ((Join new)							addSource: (table fieldNamed: 'SRVC_AMT_AMT')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'AMOUNT');							addSource: (table fieldNamed: 'SRVC_AMT_CURR')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'CURRENCY');							yourself).</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/airline</category><body package="GlorpTestModels" selector="descriptorForGlorpAirline:">descriptorForGlorpAirline: aDescriptor 	aDescriptor table: (self tableNamed: 'AIRLINE').	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #name.</body><body package="GlorpTestModels" selector="descriptorForGlorpItinerary:">descriptorForGlorpItinerary: aDescriptor 	aDescriptor table: (self tableNamed: 'ITINERARY').	aDescriptor directMappingFor: #id.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #reservation.</body><body package="GlorpTestModels" selector="descriptorForGlorpPassenger:">descriptorForGlorpPassenger: aDescriptor 	| passTable ffTable ffMiles airlineMapping |	passTable := self tableNamed: 'PASSENGER'.	ffTable := self tableNamed: 'FREQUENT_FLYER'.	aDescriptor table: passTable.	aDescriptor addTable: ffTable.	aDescriptor addMultipleTableJoin: (			Join 			from: (passTable fieldNamed: 'ID')			to: (ffTable fieldNamed: 'ID')) beOuterJoin.	(aDescriptor newMapping: DirectMapping) from: #id to: (passTable fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (passTable fieldNamed: 'NAME').	ffMiles := aDescriptor newMapping: ConditionalMapping.	ffMiles 		forField: (ffTable fieldNamed: 'POINTS')		attribute: [:object | object frequentFlyerPoints]		if: [:x | x notNil]		useMapping: ((ffMiles newMapping: DirectMapping) from: #frequentFlyerMiles to: (ffTable fieldNamed: 'POINTS')).	ffMiles otherwise: (ffMiles newMapping: ConstantMapping).		airlineMapping := aDescriptor newMapping: ConditionalMapping.	airlineMapping		forField: (ffTable fieldNamed: 'AIRLINE_ID')		attribute: [:object | object airline]		if: [:x | x notNil]		useMapping: ((airlineMapping newMapping: OneToOneMapping) attributeName: #airline).	airlineMapping otherwise: (airlineMapping newMapping: ConstantMapping).</body><body package="GlorpTestModels" selector="descriptorForGlorpReservation:">descriptorForGlorpReservation: aDescriptor 	| table |	table := self tableNamed: 'RESERVATION'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	"The res-&gt;passenger relationship is actually 1-1, but map it as both 1-1 and 1-many so that we can more easily verify that only one object comes back, i.e. that joins are being done correctly"	(aDescriptor newMapping: OneToManyMapping)			attributeName: #passengers.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #passenger.</body><body package="GlorpTestModels" selector="descriptorForGlorpTravelAgency:">descriptorForGlorpTravelAgency: aDescriptor	| table |	table := self tableNamed: 'GR_TRAVEL_AGENT'.	aDescriptor table: table.	aDescriptor directMapping from: #name to: (table fieldNamed: 'AGENCY_NAME').	aDescriptor toManyMapping			attributeName: #agents;			join: (Join from: (table fieldNamed: 'AGENCY_NAME') to: (table fieldNamed: 'AGENCY_NAME')).</body><body package="GlorpTestModels" selector="descriptorForGlorpTravelAgent:">descriptorForGlorpTravelAgent: aDescriptor	| table |	table := self tableNamed: 'GR_TRAVEL_AGENT'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #name to: (table fieldNamed: 'AGENT_NAME').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)			attributeName: #agency.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>owner</category><body package="GlorpTestModels" selector="descriptorForGlorpOwner:">descriptorForGlorpOwner: aDescriptor	| table slaveTable |	table := self tableNamed: 'GLORP_OWNER'.	slaveTable := self tableNamed: 'GLORP_SLAVE'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID'));		addMapping:				((OneToManyMapping new)						attributeName: #slaves;						referenceClass: GlorpSlave;						collectionType: OrderedCollection;						orderBy:								[:each | (each getTable: 'GLORP_SLAVE') getField: 'POSITION_IN_OWNER'];						writeTheOrderField;						mappingCriteria:								(Join										from: (table fieldNamed: 'ID')										to: (slaveTable fieldNamed: 'OWNER_ID')));		addMapping:				((OneToOneMapping new)						attributeName: #slave;						referenceClass: GlorpSlave;						mappingCriteria:								(Join										from: (table fieldNamed: 'SLAVE_ID')										to: (slaveTable fieldNamed: 'ID'))).</body><body package="GlorpTestModels" selector="descriptorForGlorpSlave:">descriptorForGlorpSlave: aDescriptor	| table |	table := self tableNamed: 'GLORP_SLAVE'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).</body><body package="GlorpTestModels" selector="tableForGLORP_OWNER:">tableForGLORP_OWNER: aTable	| field |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	field := aTable createFieldNamed: 'SLAVE_ID' type: platform int4.	aTable		addForeignKeyFrom: field		to: ((self tableNamed: 'GLORP_SLAVE') fieldNamed: 'ID').</body><body package="GlorpTestModels" selector="tableForGLORP_SLAVE:">tableForGLORP_SLAVE: aTable	| field constraint |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'POSITION_IN_OWNER' type: platform int4.	field := aTable createFieldNamed: 'OWNER_ID' type: platform int4.	"Don't actually create this constraint because it causes a cycle that can confuse our sorting mechanism."	"constraint := aTable		addForeignKeyFrom: field		to: ((self tableNamed: 'GLORP_OWNER') fieldNamed: 'ID').	constraint shouldCreateInDatabase: false."</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/tree nodes</category><body package="GlorpTestModels" selector="classModelForGlorpTreeNode:">classModelForGlorpTreeNode: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #children collectionOf: GlorpTreeNode.</body><body package="GlorpTestModels" selector="descriptorForGlorpTreeNode:">descriptorForGlorpTreeNode: aDescriptor	| table |	table := self tableNamed: 'TREE_NODE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: ToManyMapping)		attributeName: #children;		useLinkTable;		join:				(Join						from: (table fieldNamed: 'ID')						to: ((self tableNamed: 'TREE_NODE_LINK') fieldNamed: 'PARENT')).</body><body package="GlorpTestModels" selector="tableForTREE_NODE:">tableForTREE_NODE: aTable	| |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.</body><body package="GlorpTestModels" selector="tableForTREE_NODE_LINK:">tableForTREE_NODE_LINK: aTable	| parent child |	parent := (aTable createFieldNamed: 'PARENT' type: platform int4) bePrimaryKey.	(aTable addForeignKeyFrom: parent		to: ((self tableNamed: 'TREE_NODE') fieldNamed: 'ID')) "shouldCreateInDatabase: false"  .	child := (aTable createFieldNamed: 'CHILD' type: platform int4) bePrimaryKey.	(aTable addForeignKeyFrom: child		to: ((self tableNamed: 'TREE_NODE') fieldNamed: 'ID')) "shouldCreateInDatabase: false".</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>class models/airline</category><body package="GlorpTestModels" selector="classModelForGlorpAirline:">classModelForGlorpAirline: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.</body><body package="GlorpTestModels" selector="classModelForGlorpItinerary:">classModelForGlorpItinerary: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #reservation type: GlorpReservation.</body><body package="GlorpTestModels" selector="classModelForGlorpPassenger:">classModelForGlorpPassenger: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #frequentFlyerMiles.	aClassModel newAttributeNamed: #airline type: GlorpAirline.</body><body package="GlorpTestModels" selector="classModelForGlorpReservation:">classModelForGlorpReservation: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #passengers collectionOf: GlorpPassenger.	aClassModel newAttributeNamed: #passenger type: GlorpPassenger.</body><body package="GlorpTestModels" selector="classModelForGlorpTravelAgency:">classModelForGlorpTravelAgency: aClassModel	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #agents collectionOf: GlorpTravelAgent.</body><body package="GlorpTestModels" selector="classModelForGlorpTravelAgent:">classModelForGlorpTravelAgent: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #agency type: GlorpTravelAgency.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('GR_ADDRESS' 'PERSON' 'GR_CUSTOMER' 'BANK_TRANS' 'BANK_ACCT' 'CUSTOMER_ACCT_LINK' 'EMAIL_ADDRESS' 'STUFF' 'PASSENGER' 'AIRLINE' 'FREQUENT_FLYER' 'COMPRESSED_MONEY_TABLE' 'RESERVATION' 'ITINERARY' 'TRANSFORMED_TIME' 'FKCONTACT' 'FKADDRESS' 'GLORP_OWNER' 'GLORP_SLAVE' 'TREE_NODE' 'TREE_NODE_LINK' 'RECORD_WITH_UPDATE' 'GR_TRAVEL_AGENT').</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	"This includes a list of classes as an example, but we don't actually use most of them, because the superclass method will figure it out if the descriptor methods are written in this class."	^(super constructAllClasses) 		add: GlorpAddress;		yourself."	^(super constructAllClasses)		add: GlorpPerson;		add: GlorpAddress;		add: GlorpCustomer;		add: GlorpBankTransaction;		add: GlorpBankAccount;		add: GlorpMoney;		add: GlorpCompressedMoney;		add: GlorpServiceCharge;		add: GlorpBankAccountNumber;		add: GlorpEmailAddress;		add: GlorpPassenger;		add: GlorpAirline;		add: GlorpReservation;		add: GlorpItinerary;		add: GlorpTransformedTime;		add: GlorpBankBranch;		add: GlorpOwner;		add: GlorpSlave;		add: GlorpTreeNode;		add: GlorpRecordWithUpdateTime;		add: GlorpTravelAgent;		add: GlorpTravelAgency;		yourself."</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>support</category><body package="GlorpDBTests" selector="writeCustomer1Rows">writeCustomer1Rows	| linkRow2 id2 id1 accountRow1 customerRow accountRow2 linkRow1 |	customerRow := self exampleCustomerRow1.	accountRow1 := self exampleAccountRow1.	accountRow2 := self exampleAccountRow2.	linkRow1 := self exampleCALinkRow1.	linkRow2 := self exampleCALinkRow2.	session writeRow: customerRow.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: linkRow1.	session writeRow: linkRow2.	id1 := accountRow1 at: (accountRow1 table fieldNamed: 'ID').	id2 := accountRow2 at: (accountRow2 table fieldNamed: 'ID').	^Array with: id1 with: id2.</body><body package="GlorpDBTests" selector="writeCustomerWithDualAccountOwners">writeCustomerWithDualAccountOwners	| linkRow2 id2 id1 accountRow1 accountRow2 linkRow1 customer1Row customer2Row linkRow4 |	customer1Row := self exampleCustomerRow1.	customer2Row := self exampleCustomerRow2.	accountRow1 := self exampleAccountRow1.	accountRow2 := self exampleAccountRow2.	linkRow1 := self exampleCALinkRow1.	linkRow2 := self exampleCALinkRow2.	linkRow4 := self exampleCALinkRow4.	session writeRow: customer1Row.	session writeRow: customer2Row.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: linkRow1.	session writeRow: linkRow2.	session writeRow: linkRow4.	id1 := accountRow1 at: (accountRow1 table fieldNamed: 'ID').	id2 := accountRow2 at: (accountRow2 table fieldNamed: 'ID').	^Array with: id1 with: id2.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>test support</category><body package="GlorpTests" selector="testIDLessThan5:">testIDLessThan5: aValue	"A test method, used for conditional mapping tests"	^aValue &lt; 5.</body><body package="GlorpTests" selector="testIDMoreThan5:">testIDMoreThan5: aValue	"A test method, used for conditional mapping tests"	^aValue &gt; 5.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem class</class-id> <category>accessing</category><body package="GlorpTestModels" selector="default">default	Default isNil ifTrue: [Default := self new].	^Default</body></methods><methods><class-id>Glorp.GlorpLinkTableAnywhereDescriptorSystem</class-id> <category>descriptors/bank</category><body package="GlorpTestModels" selector="classModelForGlorpCustomer:">classModelForGlorpCustomer: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #transactions collectionOf: GlorpBankTransaction.	"Note: accounts is a 1-1 in this model"	aClassModel newAttributeNamed: #accounts type: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedById collectionOf: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedByIdDescending collectionOf: GlorpBankAccount.</body><body package="GlorpTestModels" selector="descriptorForGlorpCustomer:">descriptorForGlorpCustomer: aDescriptor	| table |	table := self tableNamed: 'GR_CUSTOMER'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: OneToManyMapping)			attributeName: #transactions;			referenceClass: GlorpBankTransaction.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #accounts;			referenceClass: GlorpBankAccount;			usesLinkTable: true.</body></methods><methods><class-id>Glorp.GlorpVarchar2Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform varchar: 2.</body></methods><methods><class-id>Glorp.GlorpVarchar2Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testVarChar2">testVarChar2	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	self helpTestInvalidValue: 'abc'.	self helpTestInvalidValue: 'abcd'.	self helpTestInvalidValue: 'abcde'.</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>accessing</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('GR_USER' 'GR_FOLDER' 'GR_MESSAGE').</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: GlorpUser;		add: GlorpFolder;		add: GlorpMessage;		yourself</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels" selector="tableForGR_FOLDER:">tableForGR_FOLDER: aTable 	| userId |	userId := aTable createFieldNamed: 'USER_ID' type: platform integer.	userId bePrimaryKey.	aTable addForeignKeyFrom: userId		to: ((self tableNamed: 'GR_USER') fieldNamed: 'ID').	(aTable createFieldNamed: 'NAME' type: (platform varChar: 50)) bePrimaryKey.</body><body package="GlorpTestModels" selector="tableForGR_MESSAGE:">tableForGR_MESSAGE: aTable 	| userId folderName |	userId := aTable createFieldNamed: 'USER_ID' type: platform integer.	userId bePrimaryKey.	folderName := aTable createFieldNamed: 'FOLDER_NAME' type: (platform varChar: 50).	folderName bePrimaryKey.	aTable addForeignKeyFrom: userId		to: ((self tableNamed: 'GR_USER') fieldNamed: 'ID').	aTable addForeignKeyFrom: userId		to: ((self tableNamed: 'GR_FOLDER') fieldNamed: 'USER_ID')		from: folderName		to: ((self tableNamed: 'GR_FOLDER') fieldNamed: 'NAME').	(aTable createFieldNamed: 'SUBJECT' type: (platform varChar: 50)) bePrimaryKey.	aTable createFieldNamed: 'CONTENTS' type: (platform varChar: 100).</body><body package="GlorpTestModels" selector="tableForGR_USER:">tableForGR_USER: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform integer)		bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	| user1 user2 folder1 folder1a folder2 message1 message2 message3 |	user1 := GlorpUser new id: 1; name: 'User One'.	user2 := GlorpUser new id: 2; name: 'User Two'.	folder1 := GlorpFolder new name: 'One'; user: user1.	user1 folders add: folder1.	folder1a := GlorpFolder new name: 'One-A'; user: user1.	user1 folders add: folder1a.	folder2 := GlorpFolder new name: 'Two'; user: user2.	user2 folders add: folder2.		message1 := GlorpMessage new subject: 'goes in folder 1'; user: user1; folder: folder1.	folder1 messages add: message1.	message2 := GlorpMessage new subject: 'also goes in folder 1'; user: user1; folder: folder1.	folder1 messages add: message2.	message3 := GlorpMessage new subject: 'goes in folder 2'; user: user2; folder: folder2.	folder2 messages add: message3.	^Array with: user1 with: user2.</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels" selector="descriptorForGlorpFolder:">descriptorForGlorpFolder: aDescriptor	| table userMapping messageMapping |	table := self tableNamed: 'GR_FOLDER'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	userMapping := OneToOneMapping new		attributeName: #user;		referenceClass: GlorpUser."		join: (Join from: (table fieldNamed: 'USER_ID') to: (userTable fieldNamed: 'ID'))."	aDescriptor addMapping: userMapping.	messageMapping := OneToManyMapping new		attributeName: #messages;		referenceClass: GlorpMessage."		join: (Join 			from: (table fieldNamed: 'USER_ID')			to: (messageTable fieldNamed: 'USER_ID') 				from: (table fieldNamed: 'NAME')			to: (messageTable fieldNamed: 'FOLDER_NAME'))."	messageMapping beExclusive.	aDescriptor addMapping: messageMapping.</body><body package="GlorpTestModels" selector="descriptorForGlorpMessage:">descriptorForGlorpMessage: aDescriptor	| table userMapping folderMapping |	table := self tableNamed: 'GR_MESSAGE'.	aDescriptor table: table.	self tableNamed: 'GR_USER'.	self tableNamed: 'GR_FOLDER'.	aDescriptor addMapping: (DirectMapping from: #subject to: (table fieldNamed: 'SUBJECT')).	aDescriptor addMapping: (DirectMapping from: #contents to: (table fieldNamed: 'CONTENTS')).	userMapping := OneToOneMapping new		attributeName: #user;		referenceClass: GlorpUser."		mappingCriteria: (Join from: (table fieldNamed: 'USER_ID') to: (userTable fieldNamed: 'ID'))."	aDescriptor addMapping: userMapping.	folderMapping := OneToOneMapping new		attributeName: #folder;		referenceClass: GlorpFolder.	"Let it figure this out for itself""		mappingCriteria: (Join 			from: (table fieldNamed: 'USER_ID')			to: (userTable fieldNamed: 'ID') 				from: (table fieldNamed: 'NAME')			to: (folderTable fieldNamed: 'FOLDER_NAME'))."	aDescriptor addMapping: folderMapping.</body><body package="GlorpTestModels" selector="descriptorForGlorpUser:">descriptorForGlorpUser: aDescriptor	| table folderMapping |	table := self tableNamed: 'GR_USER'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	folderMapping := OneToManyMapping new		attributeName: #folders;		referenceClass: GlorpFolder."		mappingCriteria: 						(Join								from: (table fieldNamed: 'ID')								to: (folderTable fieldNamed: 'USER_ID'))."	folderMapping beExclusive.	aDescriptor addMapping: folderMapping.</body></methods><methods><class-id>Glorp.GlorpQueryTableAliasingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testAliasWithEmbeddedMapping">testAliasWithEmbeddedMapping	self unfinished.</body><body package="GlorpTests" selector="testBuildingObject">testBuildingObject	| customer |	elementBuilder instance: GlorpCustomer new.	elementBuilder requiresPopulating: true.	elementBuilder buildObjectFrom: #(12 'Name').	customer := elementBuilder instance.	self assert: customer class == GlorpCustomer.	self assert: customer id = 12.	self assert: customer name = 'Name'.</body><body package="GlorpTests" selector="testElementBuilderFields">testElementBuilderFields	elementBuilder fieldsForSelectStatement 		do: [:each | self assert: each table name = 't1']</body><body package="GlorpTests" selector="testExpressionTableAlias">testExpressionTableAlias	| fields |	fields := expression translateFields: expression descriptor mappedFields.	fields do: [:each | self assert: each table name = 't1']</body><body package="GlorpTests" selector="testQueryPrintingFields">testQueryPrintingFields	| stream |	query 		initResultClass: GlorpCustomer		whereClause: expression		singleObject: true.	query limit: nil.	query setupTracing.	query computeFields.	stream := String new writeStream.	query printSelectFieldsOn: stream.	self assert: stream contents = 't1.ID, t1.NAME'</body><body package="GlorpTests" selector="testQueryPrintingSimpleWhereClause">testQueryPrintingSimpleWhereClause	| string |	string := self helpTestPrintingWhereClause: ((expression get: #name) get: #= withArguments: #('Fred')).	self assert: '(t1.NAME = ''Fred'')' equalsIgnoringOuterBrackets: string.</body><body package="GlorpTests" selector="testQueryPrintingTables">testQueryPrintingTables	| stream string |	query 		initResultClass: GlorpCustomer		whereClause: expression		singleObject: true.	query setupTracing.	query computeFields.	stream := String new writeStream.	query printTablesOn: stream.	string := stream contents.	self assert: string = '&lt;n&gt; FROM GR_CUSTOMER t1' expandMacros.</body></methods><methods><class-id>Glorp.GlorpQueryTableAliasingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	query := SimpleQuery new.	expression := BaseExpression new.	expression descriptor: (system descriptorFor: GlorpCustomer).	(expression descriptor mappingForAttributeNamed: #name) shouldProxy: false.	elementBuilder := ObjectBuilder for: expression in: query.	expression aliasTable: (system tableNamed: 'GR_CUSTOMER') to: 't1'.	session := GlorpSession new.	session system: system.	query session: system session.</body></methods><methods><class-id>Glorp.GlorpQueryTableAliasingTest</class-id> <category>As yet unclassified</category><body package="GlorpTests" selector="helpTestPrintingWhereClause:">helpTestPrintingWhereClause: anExpression	| command |	query 		initResultClass: GlorpCustomer		whereClause: expression		singleObject: true.	query setupTracing.	query computeFields.	command := GlorpNullCommand useBinding: false session: session.	anExpression			printSQLOn: command		withParameters: Dictionary new.	^command sqlString.</body></methods><methods><class-id>Glorp.GlorpMessageCollectorTest</class-id> <category>tests</category><body package="GlorpTests" selector="messageCollectorDNUObjectStudio">messageCollectorDNUObjectStudio	| caught |	caught := false.	[collector basicDoesNotUnderstand: #foo args: #()] on: MessageNotUnderstood		do: [:signal | caught := true. signal sunitExitWith: nil].	self assert: caught</body><body package="GlorpTests" selector="testExpressionCreation">testExpressionCreation	| exp |	exp := collector foo asGlorpExpression.	self assert: exp name == #foo.	self assert: exp base class == BaseExpression</body><body package="GlorpTests" selector="testMessageCollectorDNU">testMessageCollectorDNU	| message caught |	Dialect isObjectStudio ifTrue: [		^self messageCollectorDNUObjectStudio].	message := Message selector: #foo arguments: #().	caught := false.	[collector basicDoesNotUnderstand: message] on: MessageNotUnderstood		do: [:signal | caught := true. signal sunitExitWith: nil].	self assert: caught</body><body package="GlorpTests" selector="testMessageIntercept">testMessageIntercept	| foo |	foo := collector foo.	self assert: foo privateGlorpSelector == #foo.	self assert: foo privateGlorpReceiver == collector.</body></methods><methods><class-id>Glorp.GlorpMessageCollectorTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	collector := MessageArchiver new</body></methods><methods><class-id>Glorp.GlorpWorker</class-id> <category>initialize/release</category><body package="GlorpTestModels" selector="initialize">initialize	pendingJobs := OrderedCollection new.	finishedJobs := OrderedCollection new.	priorityJobs := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpWorker</class-id> <category>accessing</category><body package="GlorpTestModels" selector="finishedJobs">finishedJobs	^finishedJobs</body><body package="GlorpTestModels" selector="finishedJobs:">finishedJobs: anObject	finishedJobs := anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body><body package="GlorpTestModels" selector="pendingJobs">pendingJobs	^pendingJobs</body><body package="GlorpTestModels" selector="pendingJobs:">pendingJobs: anObject	pendingJobs := anObject</body><body package="GlorpTestModels" selector="priorityJobs">priorityJobs	^priorityJobs</body><body package="GlorpTestModels" selector="priorityJobs:">priorityJobs: anObject	priorityJobs := anObject</body></methods><methods><class-id>Glorp.GlorpWorker class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest</class-id> <category>support</category><body package="GlorpDBTests" selector="databaseLoginResource">databaseLoginResource	^GlorpDatabaseLoginResource current.</body><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	system := GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testBeginTransactionWithCommit">testBeginTransactionWithCommit	self assert: self accessor isInTransaction not.	self accessor beginTransaction.	self assert: self accessor isInTransaction.	self accessor commitTransaction.	self assert: self accessor isInTransaction not</body><body package="GlorpDBTests" selector="testBeginTransactionWithRollback">testBeginTransactionWithRollback	self assert: self accessor isInTransaction not.	self accessor beginTransaction.	self assert: self accessor isInTransaction.	self accessor rollbackTransaction.	self assert: self accessor isInTransaction not</body><body package="GlorpDBTests" selector="testCreateTable">testCreateTable	| selectResult presentFlag |	presentFlag := true.	[[self accessor beginTransaction.	self accessor		executeSQLStringNoResult: 'CREATE TABLE GLORP_TEST_CREATE (ID varchar(4))'] 		ensure: [self accessor commitTransaction].	selectResult := self accessor		executeSQLString: 'SELECT * FROM GLORP_TEST_CREATE'.	self assert: selectResult isEmpty]		ensure:			[[self accessor				beginTransaction;				dropTableNamed: 'GLORP_TEST_CREATE'					ifAbsent: [:ex |presentFlag := false. ex sunitExitWith: nil]]				ensure: [self accessor commitTransaction]].	self assert: presentFlag		description: 'Tried to drop the created table but it was already absent'.</body><body package="GlorpDBTests" selector="testDropMissingTable">testDropMissingTable	| absentFlag |	absentFlag := false.	[self accessor beginTransaction.	self accessor 		dropTableNamed: 'GLORP_TEST_DROP' 		ifAbsent: [:ex  | absentFlag := true. ex sunitExitWith: nil]]	ensure: [self accessor rollbackTransaction].	self assert: absentFlag</body><body package="GlorpDBTests" selector="testNameBinding">testNameBinding	| selectResult |	"This is more of a low-level db functionality test than a glorp test, but it's convenient to be able ot write it here"	Dialect isVisualWorks ifFalse: [^self].	[self accessor beginTransaction.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (10,''abc'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (20,''def'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (30,''ghi'')'.	selectResult := self accessor 		executeSQLString: 'SELECT * FROM STUFF WHERE ID = :key OR ID = :value'			binding: 10-&gt;30.	self assert: selectResult size = 2]		ensure: [self accessor rollbackTransaction].</body><body package="GlorpDBTests" selector="testPositionalBinding">testPositionalBinding	| selectResult | 	"This is more of a low-level db functionality test than a glorp test, but it's convenient to be able ot write it here"	Dialect isVisualWorks ifFalse: [^self].	[self accessor beginTransaction.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (10,''abc'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (20,''def'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (30,''ghi'')'.	selectResult := self accessor 		executeSQLString: 'SELECT * FROM STUFF WHERE ID = :2 OR ID = :17'			binding: #(nil 10 nil nil nil nil nil nil nil nil nil nil nil nil nil nil 20).	self assert: selectResult size = 2]		ensure: [self accessor rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadEmpty">testReadEmpty	| results |	results := self accessor				executeSQLString: 'SELECT * FROM PERSON'.	self assert: results size = 0</body><body package="GlorpDBTests" selector="testReadStatement">testReadStatement	| results |	results := self accessor				executeSQLString: 'SELECT * FROM STUFF ORDER BY ID'.	self assert: results size = 5.	self assert: results first size = 2.	self assert: results first last =  'abc'</body><body package="GlorpDBTests" selector="testRollbackRemovesData">testRollbackRemovesData	"Just to make sure I'm not losing my mind"	| numAddresses newNumAddresses|	numAddresses := (self accessor executeSQLString: 'SELECT * FROM GR_ADDRESS') size.	self accessor beginTransaction.	self accessor executeSQLStringNoResult: 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (111,''Main Street'',''77777'')'.	newNumAddresses := (self accessor executeSQLString: 'SELECT * FROM GR_ADDRESS') size.	self assert: newNumAddresses = (numAddresses + 1).	self accessor rollbackTransaction.	self assert: numAddresses = (self accessor executeSQLString: 'SELECT * FROM GR_ADDRESS') size.</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest</class-id> <category>accessing</category><body package="GlorpDBTests" selector="accessor">accessor	^self databaseLoginResource accessor</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpTaggableObject</class-id> <category>as yet unclassified</category><body package="GlorpTestModels" selector="initialize">initialize	tags := OrderedCollection new.</body><body package="GlorpTestModels" selector="tags">tags	^ tags</body><body package="GlorpTestModels" selector="tags:">tags: someTags	tags := someTags</body></methods><methods><class-id>Glorp.GlorpTaggableObject class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpImage</class-id> <category>as yet unclassified</category><body package="GlorpTestModels" selector="location">location	^ location</body><body package="GlorpTestModels" selector="location:">location: aLocation	location := aLocation</body></methods><methods><class-id>Glorp.GlorpImage class</class-id> <category>as yet unclassified</category><body package="GlorpTestModels" selector="fromStream:">fromStream: aStream	^ self new image: aStream</body></methods><methods><class-id>Glorp.GlorpDatabaseTableTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testFKUniqueNames">testFKUniqueNames	| platform contactTable linkTable companyId personId |	platform := GlorpDatabaseLoginResource defaultPlatform.	contactTable := DatabaseTable new						name: 'CONTACT';						yourself.	contactTable createFieldNamed: 'ID' type: platform serial.	linkTable := DatabaseTable new						name: 'COMPANY_PERSON_LINK';						yourself.	companyId := linkTable createFieldNamed: 'COMPANY_ID' type: platform int4.	personId := linkTable createFieldNamed: 'PERSON_ID' type: platform int4.	linkTable		addForeignKeyFrom: companyId to: (contactTable fieldNamed: 'ID');		addForeignKeyFrom: personId to: (contactTable fieldNamed: 'ID').	self assert: (linkTable foreignKeyConstraints collect: [:ea | ea name asSymbol]) asSet size = linkTable foreignKeyConstraints size.</body><body package="GlorpDBTests" selector="testIndexes">testIndexes	| platform contactTable idField name1Field name2Field |	platform := GlorpDatabaseLoginResource defaultPlatform.	contactTable := DatabaseTable new						name: 'CONTACT';						yourself.	idField := (contactTable createFieldNamed: 'ID' type: platform serial) beIndexed.	self assert: contactTable indexes size = 1.	self assert: (contactTable hasIndexForField: idField).	name1Field := contactTable createFieldNamed: 'NAME1' type: platform varchar.	name2Field := contactTable createFieldNamed: 'NAME2' type: platform varchar.	self deny: (contactTable hasIndexForField: name1Field).	contactTable addIndexForFields: (Array with: name1Field with: name2Field).	self assert: contactTable indexes size = 2.	self assert: (contactTable hasIndexForField: idField).	self assert: (contactTable hasIndexForField: name1Field).	self assert: (contactTable hasIndexForField: name2Field).</body></methods><methods><class-id>Glorp.GlorpTravelAgent</class-id> <category>accessing</category><body package="GlorpTestModels" selector="agency">agency	^agency</body><body package="GlorpTestModels" selector="agency:">agency: anObject	agency := anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpFloat4Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform float4.</body></methods><methods><class-id>Glorp.GlorpFloat4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testFloat4">testFloat4	self helpTestFloat: nil.	self helpTestValue: 3.14 compareWith: [:read :original |		read - original &lt;= 0.00001].</body></methods><methods><class-id>Glorp.GlorpSlave</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id.</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject.</body></methods><methods><class-id>Glorp.GlorpConditionalMappingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testApplicableMappingForReadNewProtocol">testApplicableMappingForReadNewProtocol	| builder |	self setUpNew.	builder := ElementBuilder for: ([:x | x] asGlorpExpressionForDescriptor: descriptor) in: SimpleQuery new.	self assert: (newMapping applicableMappingForRow: #(1 foo nil nil) in: builder) == mapping1.	self assert: (newMapping applicableMappingForRow: #(6 foo nil nil) in: builder) == mapping2.	self assert: (newMapping applicableMappingForRow: #(5 foo nil nil) in: builder) == mapping3.</body><body package="GlorpTests" selector="testApplicableMappingForReadOldProtocol">testApplicableMappingForReadOldProtocol	| builder |	builder := ElementBuilder for: ([:x | x] asGlorpExpressionForDescriptor: descriptor) in: SimpleQuery new.	self assert: (mapping applicableMappingForRow: #(1 foo nil nil) in: builder) == mapping1.	self assert: (mapping applicableMappingForRow: #(6 foo nil nil) in: builder) == mapping2.	self assert: (mapping applicableMappingForRow: #(5 foo nil nil) in: builder) == mapping3.</body><body package="GlorpTests" selector="testApplicableMappingForWriteNewProtocol">testApplicableMappingForWriteNewProtocol	| passenger |	self setUpNew.	passenger := GlorpPassenger new.	passenger id: 1.	self assert: (newMapping applicableMappingForObject: passenger) == mapping1.	passenger id: 6.	self assert: (newMapping applicableMappingForObject: passenger) == mapping2.	passenger id: 5.	self assert: (newMapping applicableMappingForObject: passenger) == mapping3.</body><body package="GlorpTests" selector="testApplicableMappingForWriteOldProtocol">testApplicableMappingForWriteOldProtocol	| passenger |	passenger := GlorpPassenger new.	passenger id: 1.	self assert: (mapping applicableMappingForObject: passenger) == mapping1.	passenger id: 6.	self assert: (mapping applicableMappingForObject: passenger) == mapping2.	passenger id: 5.	self assert: (mapping applicableMappingForObject: passenger) == mapping3.</body><body package="GlorpTests" selector="testDescriptor">testDescriptor	self assert: mapping1 descriptor == descriptor.	self assert: mapping2 descriptor == descriptor.	self assert: mapping3 descriptor == descriptor.</body><body package="GlorpTests" selector="testMappedFieldsOldProtocol">testMappedFieldsOldProtocol	self assert: mapping mappedFields asSortedCollection = descriptor primaryTable fields asSortedCollection.	mapping := descriptor newMapping: ConditionalMapping.	self assert: mapping mappedFields isEmpty.	mapping conditionalField: (descriptor primaryTable fieldNamed: 'ID').	self assert: mapping mappedFields size = 1.		mapping if: #testIDLessThan5: then: (mapping1 := DirectMapping from: #blah to: (descriptor primaryTable fieldNamed: 'NAME')).	self assert: mapping mappedFields asSortedCollection = descriptor primaryTable fields asSortedCollection.</body></methods><methods><class-id>Glorp.GlorpConditionalMappingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	descriptor := system descriptorFor: GlorpPassenger.	mapping := descriptor newMapping: ConditionalMapping.	mapping conditionalField: (descriptor primaryTable fieldNamed: 'ID').	mapping if: #testIDLessThan5: then: (mapping1 := DirectMapping from: #blah to: (descriptor primaryTable fieldNamed: 'ID')).	mapping if: #testIDMoreThan5: then: (mapping2 := DirectMapping from: #bletch to: (descriptor primaryTable fieldNamed: 'NAME')).	mapping otherwise: (mapping3 := DirectMapping from: #bazoomer to: (descriptor primaryTable fieldNamed: 'ID')).	mapping conditionalMethod: #id.</body><body package="GlorpTests" selector="setUpNew">setUpNew	"Set up using the newer protocol"	newMapping := descriptor newMapping: ConditionalMapping.	newMapping		forField: (descriptor primaryTable fieldNamed: 'ID')		attribute: #id		if: [:value | value = 1]		useMapping: (mapping1 := DirectMapping from: #blah to: (descriptor primaryTable fieldNamed: 'ID')).	newMapping if: #testIDMoreThan5: then: (mapping2 := DirectMapping from: #bletch to: (descriptor primaryTable fieldNamed: 'NAME')).	newMapping otherwise: (mapping3 := DirectMapping from: #bazoomer to: (descriptor primaryTable fieldNamed: 'ID')).</body></methods><methods><class-id>Glorp.GlorpSurcharge class</class-id> <category>glorp</category><body package="GlorpTestModels" selector="glorpSetupDescriptor:forSystem:">glorpSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	self glorpCommonSetupDescriptor: aDescriptor forSystem: aSystem.	(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		keyedBy: 'S'		field: (table fieldNamed: 'TYPE').</body></methods><methods><class-id>Glorp.GlorpNullCommand</class-id> <category>accessing</category><body package="GlorpTests" selector="sqlString">sqlString	^stream contents.</body></methods><methods><class-id>Glorp.GlorpNullCommand</class-id> <category>testing</category><body package="GlorpTests" selector="succeeded">succeeded	^true.</body></methods><methods><class-id>Glorp.GlorpNullCommand class</class-id> <category>As yet unclassified</category><body package="GlorpTests" selector="useBinding:session:">useBinding: aBoolean session: aSession	^(self new)		useBinding: aBoolean;		session: aSession;		yourself.</body></methods><methods><class-id>Glorp.GlorpUser</class-id> <category>accessing</category><body package="GlorpTestModels" selector="folders">folders	^folders</body><body package="GlorpTestModels" selector="folders:">folders: aCollection	folders := aCollection</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpTestModels" selector="name">name	^name.</body><body package="GlorpTestModels" selector="name:">name: aString	name := aString.</body></methods><methods><class-id>Glorp.GlorpUser</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	id := nil.	folders := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpUser class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpItinerary</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="reservation">reservation	^reservation</body><body package="GlorpTestModels" selector="reservation:">reservation: anObject	reservation := anObject</body></methods><methods><class-id>Glorp.GlorpItinerary class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		reservation: GlorpReservation example1.</body><body package="GlorpTestModels" selector="example2">example2	^self new		reservation: GlorpReservation example2.</body></methods><methods><class-id>Glorp.GlorpThingOne</class-id> <category>accessing</category><body package="GlorpCollectionTypeModels" selector="id">id	^id</body><body package="GlorpCollectionTypeModels" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpCollectionTypeModels" selector="name">name	^name</body><body package="GlorpCollectionTypeModels" selector="name:">name: aString	name := aString</body></methods><methods><class-id>Glorp.GlorpThingOne</class-id> <category>comparing</category><body package="GlorpCollectionTypeModels" selector="&lt;=">&lt;= aThingOne	^self name &lt;= aThingOne name.</body></methods><methods><class-id>Glorp.GlorpThingOne class</class-id> <category>instance creation</category><body package="GlorpCollectionTypeModels" selector="named:">named: aString	^self new name: aString.</body></methods><methods><class-id>Glorp.GlorpWarehouse</class-id> <category>accessing</category><body package="GlorpTestModels" selector="address">address	^address</body><body package="GlorpTestModels" selector="address:">address: anObject	address := anObject</body><body package="GlorpTestModels" selector="currentItem">currentItem	^currentItem</body><body package="GlorpTestModels" selector="currentItem:">currentItem: anInventoryItem	currentItem := anInventoryItem</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="items">items	^items</body><body package="GlorpTestModels" selector="items:">items: aCollection	items := aCollection</body></methods><methods><class-id>Glorp.GlorpCacheTest</class-id> <category>tests</category><body package="GlorpTests" selector="testDuplicates">testDuplicates 	| c1 c2 |	c1 := GlorpCustomer example1.	c2 := GlorpCustomer example1.	cache at: 3 insert: c1.	cache at: 3 insert: c2.	self assert: (cache lookupClass: GlorpCustomer key: 3) = c1.</body><body package="GlorpTests" selector="testDuplicatesDifferentClasses">testDuplicatesDifferentClasses	| cust trans |	cust := GlorpCustomer example1.	trans := GlorpBankTransaction example1.	cache at: 3 insert: cust.	cache at: 3 insert: trans.	self assert: (cache lookupClass: GlorpCustomer key: 3) = cust.	self assert: (cache lookupClass: GlorpBankTransaction key: 3) = trans.</body><body package="GlorpTests" selector="testInsert">testInsert	| customer |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3) == customer</body><body package="GlorpTests" selector="testManualExpireAll">testManualExpireAll	| customer customer2 readBackCustomer |	system cachePolicy: TimedExpiryCachePolicy new.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	cache expireAll.	readBackCustomer := session readOneOf: GlorpCustomer where: [:each | each id = 3].	self assert: readBackCustomer isNil.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests" selector="testManualExpiry">testManualExpiry	| customer customer2 readBackCustomer |	system cachePolicy: TimedExpiryCachePolicy new.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	cache expireClass: GlorpCustomer key: 3 ifAbsent: [self error: 'wrong'].	readBackCustomer := session readOneOf: GlorpCustomer where: [:each | each id = 3].	self assert: readBackCustomer isNil.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests" selector="testRemove">testRemove	| customer |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3) == customer.	cache removeClass: GlorpCustomer key: 3 ifAbsent: [ self signalFailure: 'Item was not in cache.' ].	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: []) == nil.</body></methods><methods><class-id>Glorp.GlorpCacheTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	system cachePolicy: CachePolicy new.	session := GlorpSessionResource current newSession.	session system: system.	cache := session privateGetCache.</body><body package="GlorpTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpCacheTest class</class-id> <category>Accessing</category><body package="GlorpTests" selector="resources">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest</class-id> <category>support</category><body package="GlorpTests" selector="checkCacheExhaustivelyFor:">checkCacheExhaustivelyFor: aBlock	"Check to make sure the cache satisfies the criteria. Since this relies on unpredictable finalization, do a full 10 garbage collect then wait iterations. Don't return early, because we're checking to see that finalization *doesn't* happen"	self assert: (self doesCacheExhaustivelySatisfy: aBlock).</body><body package="GlorpTests" selector="checkCacheFor:">checkCacheFor: aBlock	"Check to make sure the cache satisfies the criteria. Since this relies on unpredictable finalization, do up to 10 garbage collect then wait iterations. If it's true before that, return early, but if it's not true at the end, fail"	self assert: (self doesCacheSatisfy: aBlock).</body><body package="GlorpTests" selector="doesCacheExhaustivelySatisfy:">doesCacheExhaustivelySatisfy: aBlock	| result |	result := false.	10		timesRepeat:			[Dialect garbageCollect.			(Delay forMilliseconds: 100) wait.			result := aBlock value].	^result.</body><body package="GlorpTests" selector="doesCacheSatisfy:">doesCacheSatisfy: aBlock	10		timesRepeat:			[Dialect garbageCollect.			(Delay forMilliseconds: 100) wait.			aBlock value ifTrue: [^true]].	^false.</body><body package="GlorpTests" selector="mournKeyOf:">mournKeyOf: anEphemeron	mourned := true.</body><body package="GlorpTests" selector="setUp">setUp	super setUp.	system cachePolicy: WeakVWCachePolicy new.	mourned := false.</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest</class-id> <category>initializing</category><body package="GlorpTests" selector="initialize">initialize</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest</class-id> <category>tests</category><body package="GlorpTests" selector="testEphemeralValue">testEphemeralValue	| value ephemeron |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	ephemeron := (Dialect smalltalkAt: #EphemeralValue) key: 'abc' value: value.	ephemeron manager: self.	Dialect garbageCollect.	value := nil.	self should: [10 timesRepeat: [		mourned ifFalse: [Dialect garbageCollect.		(Delay forMilliseconds: 100) wait]].		mourned].</body><body package="GlorpTests" selector="testEphemeralValueDictionary">testEphemeralValueDictionary	| value dict done |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	dict := WeakVWCachePolicy new dictionaryClass new.	dict at: 'abc' put: value.	Dialect garbageCollect.	value := nil.	done := false.	self should:		[10	timesRepeat:			[done ifFalse: [				Dialect garbageCollect.				(Delay forMilliseconds: 100) wait.				done := dict size = 0]].			 done].</body><body package="GlorpTests" selector="testEphemeron">testEphemeron	| value ephemeron |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	ephemeron := (Dialect smalltalkAt: #Ephemeron) key: value value: 'abc'.	ephemeron manager: self.	Dialect garbageCollect.	value := nil.	self should: [10 timesRepeat: [		mourned ifFalse: [Dialect garbageCollect.		(Delay forMilliseconds: 100) wait]].		mourned].</body><body package="GlorpTests" selector="testEphemeronDictionary">testEphemeronDictionary	| value dict done |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	dict := (Dialect smalltalkAt: #EphemeronDictionary) new.	dict at: value put: 'abc'.	Dialect garbageCollect.	value := nil.	done := false.	self should:		[10	timesRepeat:			[done ifFalse: [				Dialect garbageCollect.				(Delay forMilliseconds: 100) wait.				done := dict size = 0]].			 done].</body><body package="GlorpTests" selector="testLargeWeakDictionary">testLargeWeakDictionary	| elements size customers newElements |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 1.	size := 2 raisedTo: 14.	customers := OrderedCollection new: size.	1 to: size do: [:i | | cust |		cust := GlorpCustomer new.		customers add: cust.		cache at: i insert: cust].	elements := cache numberOfElements.	self assert: elements = (2 raisedTo: 14).	customers := nil.	Dialect garbageCollect.	(Delay forSeconds: 2) wait.	Dialect garbageCollect.	(Delay forSeconds: 1) wait.	newElements := cache numberOfElements.	self assert: newElements = 1.</body><body package="GlorpTests" selector="testUnreferencedExcessObjectsAreRemoved">testUnreferencedExcessObjectsAreRemoved	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 1.	cache at: 3 insert: GlorpCustomer new.	cache at: 4 insert: GlorpCustomer new.	self checkCacheFor: [(cache containsObjectForClass: GlorpCustomer key: 3) not].	self assert: (cache containsObjectForClass: GlorpCustomer key: 4).</body><body package="GlorpTests" selector="testUnreferencedObjectsAreRemoved">testUnreferencedObjectsAreRemoved	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 0.	cache at: 3 insert: GlorpCustomer new.	self		checkCacheFor: [(cache containsObjectForClass: GlorpCustomer key: 3) not].</body><body package="GlorpTests" selector="testUnreferencedObjectsAreRemovedInTheRightOrder">testUnreferencedObjectsAreRemovedInTheRightOrder	| customer |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 1.	cache at: 3 insert: GlorpCustomer new.	cache at: 4 insert: GlorpCustomer new.	customer := cache lookupClass: GlorpCustomer key: 3.	self deny: customer isNil.	cache at: 3 insert: customer.	self checkCacheFor: [(cache containsObjectForClass: GlorpCustomer key: 4) not].	self assert: (cache containsObjectForClass: GlorpCustomer key: 3).</body><body package="GlorpTests" selector="testUnreferencedObjectsNotRemovedDueToExtraReferences">testUnreferencedObjectsNotRemovedDueToExtraReferences	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	cache at: 3 insert: GlorpCustomer new.	self checkCacheExhaustivelyFor: [(cache containsObjectForClass: GlorpCustomer key: 3)].</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest class</class-id> <category>instance creation</category><body package="GlorpTests" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpGettingPrimaryKeyFromMappingTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	system := GlorpDocumentDescriptorSystem forPlatform: system platform.	session system: system.	session beginTransaction.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpGettingPrimaryKeyFromMappingTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="createData">createData	"Create seed data"	| doc attb att |	doc := GlorpDocument new initialize.	attb := GlorpAttachmentBytes new content: 'Hello, Alan'.	att := (GlorpAttachment new)				index: 1;				mimeType: 'text/plain';				attachmentBytes: attb.	session modify: doc in: [doc attachments add: att].</body><body package="GlorpDBTests" selector="testUnchangedInUnitOfWork">testUnchangedInUnitOfWork 	| doc |	self createData.	session reset.	doc := session readOneOf: GlorpDocument.	"Something changed? Should not."	session modify: doc in: [].	doc := nil.	session reset.	doc := session readOneOf: GlorpDocument.	self assert: doc attachments size = 1.	doc attachments do: 			[:each | 			self assert: each attachmentBytes content yourSelf notNil].	"The bug would cause this to write out the attachment over again, generating a primary key constraint error. Just in case that doesn't catch it, do a count"	session accessor permitNothingDuring: [		session modify: doc in: []].	self assert: (session count: GlorpDocument) = 1.	self assert: (session count: GlorpAttachment) = 1.	self assert: (session count: GlorpAttachmentBytes) = 1.	self assert: doc id notNil.	((session accessor executeSQLString: 'SELECT * FROM ATTACHMENT') first do: [:each | self assert: each notNil]).	((session accessor executeSQLString: 'SELECT * FROM ATTACHMENTBYTES') first do: [:each | self assert: each notNil])</body></methods><methods><class-id>Glorp.GlorpBookstoreCustomer</class-id> <category>accessing</category><body package="GlorpTestModels" selector="accountNumber">accountNumber	^accountNumber</body><body package="GlorpTestModels" selector="accountNumber:">accountNumber: anObject	accountNumber := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpBookstoreCustomer</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	booksOnOrder := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpBookstoreCustomer class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpUnassembledItem</class-id> <category>accessing</category><body package="GlorpTestModels" selector="assemblyCost">assemblyCost	^assemblyCost</body><body package="GlorpTestModels" selector="assemblyCost:">assemblyCost: anObject	assemblyCost := anObject</body></methods><methods><class-id>Glorp.GlorpBasicMappingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testGet">testGet		self assert: (mapping getValueFrom: person) = 1</body><body package="GlorpTests" selector="testSet">testSet		mapping setValueIn: person to: 2.	self assert: person id = 2.	self assert: (mapping getValueFrom: person) = 2.</body></methods><methods><class-id>Glorp.GlorpBasicMappingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	mapping := DirectMapping new.	mapping attributeName: #id.	mapping attribute classModel describedClass: GlorpPerson.	person := GlorpPerson example1.</body></methods><methods><class-id>Glorp.DefaultableThing</class-id> <category>accessing</category><body package="GlorpDBTests" selector="boolean">boolean	^boolean</body><body package="GlorpDBTests" selector="boolean:">boolean: anObject	boolean := anObject</body><body package="GlorpDBTests" selector="id">id	^id</body><body package="GlorpDBTests" selector="id:">id: anObject	id := anObject</body><body package="GlorpDBTests" selector="integer">integer	^integer</body><body package="GlorpDBTests" selector="integer:">integer: anObject	integer := anObject</body></methods><methods><class-id>Glorp.GlorpDescriptorSystemWithNamespaces</class-id> <category>accessing</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#()</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: GlorpTestClassInNamespace;		yourself</body><body package="GlorpTestModels" selector="descriptorForGlorpTestClassInNamespace:">descriptorForGlorpTestClassInNamespace: aDescriptor 	^aDescriptor</body></methods><methods><class-id>Glorp.GlorpExpressionJoiningTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	source := BaseExpression new.	target := source get: #relation.	base := BaseExpression new.</body><body package="GlorpTests" selector="tearDown">tearDown	source := nil.	target := nil.	base := nil.	system := nil.</body></methods><methods><class-id>Glorp.GlorpExpressionJoiningTest</class-id> <category>tests</category><body package="GlorpTests" selector="join:">join: exp 	^exp asExpressionJoiningSource: source toTarget: target</body><body package="GlorpTests" selector="resultOfJoiningFieldFor:toExpressionBuiltOn:">resultOfJoiningFieldFor: aTable toExpressionBuiltOn: anotherTable	| exp table |	base descriptor: (system descriptorFor: GlorpCustomer).	exp := FieldExpression forField: (aTable fieldNamed: 'ID')				basedOn: BaseExpression new.	table := base getTable: anotherTable.	^exp asExpressionJoiningSource: base toTarget: table.</body><body package="GlorpTests" selector="testBase">testBase	| result |	result := self join: base. 	self assert: result == source.</body><body package="GlorpTests" selector="testConstant">testConstant	| exp |	exp := ConstantExpression for: 42.	self assert: (self join: exp) == exp</body><body package="GlorpTests" selector="testField">testField	| exp  result |	exp := FieldExpression forField: (DatabaseField named: 'test' type: system platform int4)				basedOn: base.	result := self join: exp.	self assert: result base == source.	self assert: result field == exp field</body><body package="GlorpTests" selector="testFieldBuiltOnDifferentTable">testFieldBuiltOnDifferentTable	| result custTable |	custTable := system tableNamed: 'GR_CUSTOMER'.	result := self 		resultOfJoiningFieldFor: custTable		toExpressionBuiltOn: custTable.	self assert: result base == (base getTable: custTable).	self assert: result field == ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').</body><body package="GlorpTests" selector="testFieldBuiltOnSameTable">testFieldBuiltOnSameTable	| exp result base2 table custTable |	custTable := system tableNamed: 'GR_CUSTOMER'.	base2 := BaseExpression new.	base2 descriptor: (system descriptorFor: GlorpCustomer).	table := base2 getTable: custTable.	exp := FieldExpression forField: (custTable fieldNamed: 'ID')				basedOn: base.	result := exp asExpressionJoiningSource: base2 toTarget: table.	self assert: result base == table.	self assert: result field == exp field.</body><body package="GlorpTests" selector="testMapping">testMapping	| result exp |	exp := base get: #foo.	result := self join: exp. 	self assert: result base == source.	self assert: result name = #foo.</body><body package="GlorpTests" selector="testParameter">testParameter	| result exp table field |	table := DatabaseTable named: 'T'.		field := DatabaseField named: 'F' type: system platform int4.	table addField: field.	exp := base getParameter: field.	result := self join: exp.	self assert: result base == source.	self assert: result class == FieldExpression.	self assert: result field == field.</body><body package="GlorpTests" selector="testRelation">testRelation	| result exp |	exp := [:a | a foo = 3] asGlorpExpressionOn: base.	result := self join: exp. 	self assert: result class == RelationExpression.	self assert: result rightChild == exp rightChild.	self assert: result leftChild base == source.</body><body package="GlorpTests" selector="testRelation2">testRelation2	| result exp field | 	field := DatabaseField named: 'fred' type: system platform int4.	exp := [:a | a foo = field] asGlorpExpressionOn: base.	result := self join: exp. 	self assert: result class == RelationExpression.	self assert: result rightChild class == FieldExpression.	self assert: result rightChild field == field.	self assert: result leftChild base == source.</body><body package="GlorpTests" selector="testSelfJoinWithPrimaryKeyExpression">testSelfJoinWithPrimaryKeyExpression	"This tests a join of a class to itself, in this case customers who have other customers associated with them. Useful for hierarchies"	| pkExpression field result |	field := (system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID'.	pkExpression := Join 		from: field		to: field.	result := self join: pkExpression.	self assert: result leftChild basicField == field.	self assert: result rightChild basicField == field.	self assert: result rightChild base name = #relation.</body><body package="GlorpTests" selector="testTable">testTable	| result exp table |	table := DatabaseTable named: 'T'.	exp := base getTable: table.	result := self join: exp. 	self assert: result base == target.	self assert: result table == table.</body></methods><methods><class-id>Glorp.GlorpDBTypeTestsPackage class</class-id> <category>instance creation</category><body package="GlorpDBTypeTests" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.GlorpVariableTypeTest</class-id> <category>testing</category><body package="GlorpDBTests" selector="testRead">testRead	| gallery image |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example1).		session modify: gallery in: [].		session reset.		gallery := session readOneOf: GlorpGallery.		self assert: gallery images size = 1.		image := gallery images first.		self assert: image class = GlorpImageFile.		self assert: image bits = GlorpImageFile example1 bits.		].</body><body package="GlorpDBTests" selector="testReadBoth">testReadBoth	| gallery image link |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example2); add: (GlorpImageFile example1).		session modify: gallery in: [].		session reset.		gallery := session readOneOf: GlorpGallery.		self assert: gallery images size = 2.		self assert: (gallery images select: [:each | each class = GlorpImageFile]) size = 1.		image := gallery images detect: [:each | each class = GlorpImageFile].		link := gallery images detect: [:each | each class = GlorpImageLink].		self assert: (gallery images collect: [:each | each id]) asSet size = 2.		self assert: image bits = (GlorpImageFile example1 bits).		self assert: image thumbnailBits = (GlorpImageFile example1 bits).		self assert: image thumbnailBits = (GlorpImageFile example2 thumbnailBits).		].</body><body package="GlorpDBTests" selector="testReadLarge">testReadLarge	| gallery image |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example2).		session modify: gallery in: [].		session reset.		gallery := session readOneOf: GlorpGallery.		self assert: gallery images size = 1.		image := gallery images first.		self assert: image class = GlorpImageLink.		self assert: image thumbnailBits = (GlorpImageFile example2 thumbnailBits) .		].</body><body package="GlorpDBTests" selector="testWrite">testWrite	| gallery images links |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example1).		session modify: gallery in: [].		session reset.		images := session accessor executeSQLString: 'SELECT * FROM GLORP_IMAGE_FILE'.		self assert: images size = 1.		links := session accessor executeSQLString: 'SELECT GALLERY_ID, IMAGE_ID, LARGE FROM GALLERY_LINK'.		self assert: links size = 1.		self assert: links first last ='F'].</body><body package="GlorpDBTests" selector="testWriteLarge">testWriteLarge	| gallery images links |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example2).		session modify: gallery in: [].		session reset.		images := session accessor executeSQLString: 'SELECT * FROM GLORP_IMAGE_FILE'.		self assert: images size = 1.		links := session accessor executeSQLString: 'SELECT GALLERY_ID, IMAGE_ID, LARGE FROM GALLERY_LINK'.		self assert: links size = 1.		self assert: links first last = 'T'].</body></methods><methods><class-id>Glorp.GlorpVariableTypeTest</class-id> <category>Running</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	system := GlorpVariableTypeTestSystem forPlatform: session system platform.	session system: system.</body></methods><methods><class-id>Glorp.GlorpGallery</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="images">images	^images</body><body package="GlorpTestModels" selector="images:">images: anObject	images := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpGallery</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	images := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpGallery class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsTest</class-id> <category>setup</category><body package="GlorpDBTests" selector="setUp">setUp		| |	super setUp.	session := GlorpSessionResource current newSession.	system := session system.	session beginTransaction.	self writeAccountRows.	singleQuery := Query returningManyOf: GlorpBankAccount				where: [:passenger | passenger id = 6].	allQuery := Query returningManyOf: GlorpBankAccount.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.</body><body package="GlorpDBTests" selector="writeAccountRows">writeAccountRows	| accountRow1 accountRow2 |	accountRow1 := session system exampleAccountRow1. 	accountRow2 := session system exampleAccountRow2.	session writeRow: accountRow1.	session writeRow: accountRow2.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="check:">check: aClass	| collectionClass |	collectionClass := aClass isBehavior ifTrue: [aClass] ifFalse: [aClass class].	singleQuery collectionType: aClass.	allQuery collectionType: aClass.	singleResult := session execute: singleQuery.	allResult := session execute: allQuery.	self assert: singleResult class == collectionClass.	self assert: allResult class == collectionClass.	self assert: singleResult size = 1.	self assert: allResult size = 2.</body><body package="GlorpDBTests" selector="testArray">testArray	self check: Array.</body><body package="GlorpDBTests" selector="testBlank">testBlank	singleResult := session execute: singleQuery.	allResult := session execute: allQuery.	self assert: singleResult class == Array.	self assert: allResult class == Array.	self assert: singleResult size = 1.	self assert: allResult size = 2.</body><body package="GlorpDBTests" selector="testOrderedCollection">testOrderedCollection	self check: OrderedCollection.</body><body package="GlorpDBTests" selector="testSet">testSet	self check: Set.</body><body package="GlorpDBTests" selector="testSortedCollection">testSortedCollection	self check: SortedCollection.	self assert: allResult first &lt;= allResult last.</body><body package="GlorpDBTests" selector="testSortedCollectionReversed">testSortedCollectionReversed	self check: (SortedCollection sortBlock: [:a :b | b &lt;= a]).	self assert: allResult last &lt;= allResult first.</body></methods><methods><class-id>Glorp.GlorpOptimisticLockingTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session system: GlorpLockingDescriptorSystem new.	session beginTransaction.	session transact: [session register: session system example1].</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpOptimisticLockingTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="changeABookFrom:">changeABookFrom: books	^session		transact:			[session register: books.			books first copiesInStock: books first copiesInStock - 1].</body><body package="GlorpDBTests" selector="testSuccessfulUpdate">testSuccessfulUpdate	| books versions newVersions |	books := session readManyOf: GlorpBook orderBy: #id.	versions := (session accessor executeSQLString: 'SELECT VERSION FROM BOOK ORDER BY ID') collect: [:each | each first].	session modify: books in: [		books do: [:each | each copiesInStock: (each copiesInStock * 2)]].	newVersions := (session accessor executeSQLString: 'SELECT VERSION FROM BOOK ORDER BY ID') collect: [:each | each first].	self assert: newVersions = (versions collect: [:each | each + 1]).</body><body package="GlorpDBTests" selector="testSuccessfulUpdateOntoNullVersionField">testSuccessfulUpdateOntoNullVersionField	| books copies someBook |	someBook := session readOneOf: GlorpBook.	session accessor executeSQLString: 'UPDATE BOOK SET VERSION = NULL WHERE ID = ', someBook id printString. 	session reset.	books := session read: GlorpBook orderBy: #id.		copies := books collect: [:each | each copiesInStock].	session transact: [		session register: books.		books do: [:each | each copiesInStock: (each copiesInStock - 1)]].	session reset.	books := session readManyOf: GlorpBook orderBy: #id.	self assert: (books collect: [:each | each copiesInStock]) = (copies collect: [:each | each - 1]).</body><body package="GlorpDBTests" selector="testSuccessfulUpdateTwiceWithRefresh">testSuccessfulUpdateTwiceWithRefresh	| book |	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	session modify: book in: [		book copiesInStock: 4].	session refresh: book.	self assert: book copiesInStock = 4.	"Make sure we've properly updated the optimistic lock field"	session modify: book in: [		book copiesInStock: 7].	session reset.	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	self assert: book copiesInStock = 7.</body><body package="GlorpDBTests" selector="testSuccessfulUpdateTwiceWithRefreshAndSaveAndContinue">testSuccessfulUpdateTwiceWithRefreshAndSaveAndContinue	| book |	session beginUnitOfWork.	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	book copiesInStock: 4.	session saveAndContinue.	session refresh: book.	self assert: book copiesInStock = 4.	"Make sure we've properly updated the optimistic lock field"	book copiesInStock: 7.	session commitUnitOfWork.	session reset.	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	self assert: book copiesInStock = 7.</body><body package="GlorpDBTests" selector="testUnsuccessfulUpdateProceedingAndFailing">testUnsuccessfulUpdateProceedingAndFailing	| books |	books := session readManyOf: GlorpBook.	session accessor		executeSQLStringNoResult: 'UPDATE BOOK SET COPIES_IN_STOCK = 7, VERSION = 3'.	self should: [[self changeABookFrom: books] on: GlorpWriteFailure do: [:ex | ex resume: false]] raise: GlorpTransactionFailure.			session reset.	books := session readManyOf: GlorpBook.	self assert: (books collect: [:each | each copiesInStock]) = #( 7 7).</body><body package="GlorpDBTests" selector="testUnsuccessfulUpdateProceedingAnyway">testUnsuccessfulUpdateProceedingAnyway	| books |	books := session readManyOf: GlorpBook.	session accessor		executeSQLStringNoResult: 'UPDATE BOOK SET COPIES_IN_STOCK = 7, VERSION = 3'.	[self changeABookFrom: books] on: GlorpWriteFailure do: [:ex | ex resume: true].			session reset.	books := session readManyOf: GlorpBook.	self assert: (books collect: [:each | each copiesInStock]) = #( 7 7).</body><body package="GlorpDBTests" selector="testUnsuccessfulUpdateWithNoAction">testUnsuccessfulUpdateWithNoAction	"This is a little quirky. SUnit's action in should:raise: is to exit the exception with true. So the thing just short circuits, and we don't get a transaction failure because we killed the whole unit of work. This is, in general, what will happen if we handle and don't resume the write failures."	| books |	books := session readManyOf: GlorpBook.	session accessor		executeSQLStringNoResult: 'UPDATE BOOK SET COPIES_IN_STOCK = 7, VERSION = 3'.	self shouldnt: [		self should: [self changeABookFrom: books] raise: GlorpWriteFailure]		raise: GlorpTransactionFailure.	session reset.	books := session readManyOf: GlorpBook.	self assert: (books collect: [:each | each copiesInStock]) = #(7 7).</body></methods><methods><class-id>Glorp.GlorpPerishableItem</class-id> <category>accessing</category><body package="GlorpTestModels" selector="age">age	^age</body><body package="GlorpTestModels" selector="age:">age: anObject	age := anObject</body></methods><methods><class-id>Glorp.GlorpPoultry</class-id> <category>accessing</category><body package="GlorpTestModels" selector="featherColor">featherColor	^featherColor</body><body package="GlorpTestModels" selector="featherColor:">featherColor: anObject	featherColor := anObject</body></methods><methods><class-id>Glorp.GlorpChar2Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform char width: 2</body></methods><methods><class-id>Glorp.GlorpChar2Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testChar2">testChar2	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	self helpTestInvalidValue: 'abc'.	self helpTestInvalidValue: 'abcd'.	self helpTestInvalidValue: 'abcde'.		self assert: (type typeString asUppercase = (self platform char: 2) typeString asUppercase)</body></methods><methods><class-id>Glorp.GlorpPublisherEmployee</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="jobTitle">jobTitle	^jobTitle</body><body package="GlorpTestModels" selector="jobTitle:">jobTitle: aString	jobTitle := aString</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpPublisherEmployee</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	id := nil.	name := nil.	jobTitle := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.GlorpPublisherEmployee class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels" selector="bookExample1">bookExample1	^(GlorpBook new)		title: 'Mastering ENVY/Developer';		author: 'Knight/Pelrine/Cho';		description:				'Absolutely the best book written on ENVY/Developer by a set of authors all living on different continents';		copiesInStock: 2000;		version: 1.</body><body package="GlorpTestModels" selector="bookExample2">bookExample2	^(GlorpBook new)		title: 'The Bad Beginning';		author: 'Lemony Snicket';		description: 'Very fine description of the EJB standards process';		copiesInStock: 3;		version: 5.</body><body package="GlorpTestModels" selector="customerExample1">customerExample1	^(GlorpBookstoreCustomer new)		accountNumber: '123456789ABCDEF';		name: 'Aunt Colof'.</body><body package="GlorpTestModels" selector="customerExample2">customerExample2	^(GlorpBookstoreCustomer new)		accountNumber: '7';		name: 'Veronica Filbert Davidson'.</body><body package="GlorpTestModels" selector="example1">example1	"Return an example start set of books, customers and orders."	| cust1 cust2 book1 book2 |	cust1 := self customerExample1.	cust2 := self customerExample2.	book1 := self bookExample1.	book2 := self bookExample2.	^Array		with: book1		with: book2		with: cust1		with: cust2.</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels" selector="allTableNames">allTableNames	^#('BOOK' 'BOOK_CUSTOMER' 'CUSTOMER_BOOK_LINK').</body><body package="GlorpTestModels" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses) 		add: GlorpBook;		add: GlorpBookstoreCustomer;		yourself.</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels" selector="tableForBOOK:">tableForBOOK: aTable	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'TITLE' type: (platform varChar: 100).	aTable createFieldNamed: 'DESCRIPTION' type: (platform varChar: 255).	aTable createFieldNamed: 'COPIES_IN_STOCK' type: (platform int4).	(aTable createFieldNamed: 'VERSION' type: (platform versionFieldFor: platform int4)) beLockKey.</body><body package="GlorpTestModels" selector="tableForBOOK_CUSTOMER:">tableForBOOK_CUSTOMER: aTable	(aTable createFieldNamed: 'ACCOUNT_NUMBER' type: (platform varChar: 15)) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 100).</body><body package="GlorpTestModels" selector="tableForCUSTOMER_BOOK_LINK:">tableForCUSTOMER_BOOK_LINK: aTable	| custKey bookKey |	custKey := aTable createFieldNamed: 'CUSTOMER_ACCT_NUM' type: (platform varChar: 15).	aTable addForeignKeyFrom: custKey		to: ((self tableNamed: 'BOOK_CUSTOMER') fieldNamed: 'ACCOUNT_NUMBER').	bookKey := aTable createFieldNamed: 'BOOK_ID' type: (platform int4).		aTable addForeignKeyFrom: bookKey		to: ((self tableNamed: 'BOOK') fieldNamed: 'ID').</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels" selector="descriptorForGlorpBook:">descriptorForGlorpBook: aDescriptor	| table |	table := self tableNamed: 'BOOK'.	aDescriptor table: table.	aDescriptor addMapping: (			DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (			DirectMapping from: #title to: (table fieldNamed: 'TITLE')).	aDescriptor addMapping: (			DirectMapping from: #copiesInStock to: (table fieldNamed: 'COPIES_IN_STOCK')).	aDescriptor addMapping: (			DirectMapping from: #version to: (table fieldNamed: 'VERSION')).</body><body package="GlorpTestModels" selector="descriptorForGlorpBookstoreCustomer:">descriptorForGlorpBookstoreCustomer: aDescriptor	| table |	table := self tableNamed: 'BOOK_CUSTOMER'.	aDescriptor table: table.	aDescriptor addMapping: (			DirectMapping from: #accountNumber to: (table fieldNamed: 'ACCOUNT_NUMBER')).	aDescriptor addMapping: (			DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (			ManyToManyMapping new			attributeName: #booksOnOrder;			referenceClass: GlorpBook).</body></methods><methods><class-id>Glorp.GlorpBankAccountNumber</class-id> <category>accessing</category><body package="GlorpTestModels" selector="accountNumber">accountNumber	^accountNumber</body><body package="GlorpTestModels" selector="accountNumber:">accountNumber: anObject	accountNumber := anObject</body><body package="GlorpTestModels" selector="bankCode">bankCode	^bankCode</body><body package="GlorpTestModels" selector="bankCode:">bankCode: anObject	bankCode := anObject</body><body package="GlorpTestModels" selector="branchNumber">branchNumber	^branchNumber</body><body package="GlorpTestModels" selector="branchNumber:">branchNumber: anObject	branchNumber := anObject</body></methods><methods><class-id>Glorp.GlorpBankAccountNumber class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example12345">example12345	^self new		accountNumber: 12345;		bankCode: 4;		branchNumber: 777.</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>tests</category><body package="GlorpTests" selector="testDoubleRowUnificationDifferentRows">testDoubleRowUnificationDifferentRows	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f3		key: o3		withField: f2		key: o2.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.</body><body package="GlorpTests" selector="testDoubleRowUnificationDifferentRows2">testDoubleRowUnificationDifferentRows2	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.</body><body package="GlorpTests" selector="testDoubleRowUnificationDifferentRows3">testDoubleRowUnificationDifferentRows3	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap rowForTable: t3 withKey: o3) at: f3 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.</body><body package="GlorpTests" selector="testDoubleRowUnificationDifferentRows4">testDoubleRowUnificationDifferentRows4	| t4 f4 o4 |	t4 := DatabaseTable named: 'T4'.	f4 := t4 createFieldNamed: 'f4' type: (platform varChar: 10).	o4 := 'four'.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f3		key: o3		withField: f4		key: o4.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.	self assert: ((rowMap rowForTable: t4 withKey: o4) at: f4) = 42.</body><body package="GlorpTests" selector="testDoubleRowUnificationSameRow">testDoubleRowUnificationSameRow	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.</body><body package="GlorpTests" selector="testDoubleRowUnificationSameRow2">testDoubleRowUnificationSameRow2	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f2		key: o2		withField: f1		key: o1.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.</body><body package="GlorpTests" selector="testIteration">testIteration	| rows r1 r2 r3 count |	r1 := rowMap findOrAddRowForTable: t1 withKey: o1.	r2 := rowMap findOrAddRowForTable: t1 withKey: o2.	r3 := rowMap findOrAddRowForTable: t2 withKey: o2.	rows := IdentitySet new.	count := 0.	rowMap rowsDo: [:each | 		count := count + 1.		rows add: each].	self assert: count = 3.	self assert: (rows includes: r1).	self assert: (rows includes: r3).	self assert: (rows includes: r2).</body><body package="GlorpTests" selector="testStoreThenUnify">testStoreThenUnify	rowMap at: f1 key: o1 put: 12.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 12.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 12.</body><body package="GlorpTests" selector="testStoreWithRowMapKey">testStoreWithRowMapKey	| a b key1 key2 key3 table r1 r2 r3 |	a := Object new.	b := Object new.	key1 := RowMapKey new key1: a; key2: b.	key2 := RowMapKey new key1: a; key2: b.	key3 := RowMapKey new key1: b; key2: a.	table := DatabaseTable new.	r1 := rowMap findOrAddRowForTable: table withKey: key1.	r2 := rowMap findOrAddRowForTable: table withKey: key2.	r3 := rowMap findOrAddRowForTable: table withKey: key3.	self assert: r1 == r2.	self assert: r2 == r3.	self assert: r1 owner == key1.</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	platform := GlorpDatabaseLoginResource defaultPlatform.	t1 := DatabaseTable named: 'T1'.	t2 := DatabaseTable named: 'T2'.	t3 := DatabaseTable named: 'T3'.	f1 := t1 createFieldNamed: 'f1' type: (platform varChar: 10).	f2 := t2 createFieldNamed: 'f2' type: (platform varChar: 10).	f3 := t3 createFieldNamed: 'f3'  type: (platform varChar: 10).	rowMap := RowMap new.	o1 := 'one'.	o2 := 'two'.	o3 := 'three'.</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>tests-transformation</category><body package="GlorpTests" selector="testUnifyExtraOnSourceSideWithTransformationBeforeStoreForward">testUnifyExtraOnSourceSideWithTransformationBeforeStoreForward	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f1		key: o1		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 12.</body><body package="GlorpTests" selector="testUnifyExtraOnSourceSideWithTransformationBeforeStoreInverse">testUnifyExtraOnSourceSideWithTransformationBeforeStoreInverse	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f1		key: o1		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t2 withKey: o2) at: f2 put: 24.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 12.</body><body package="GlorpTests" selector="testUnifyExtraOnTargetSideWithTransformationBeforeStoreForward">testUnifyExtraOnTargetSideWithTransformationBeforeStoreForward	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 24.</body><body package="GlorpTests" selector="testUnifyExtraOnTargetSideWithTransformationBeforeStoreInverse">testUnifyExtraOnTargetSideWithTransformationBeforeStoreInverse	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t2 withKey: o2) at: f2 put: 24.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 24.</body><body package="GlorpTests" selector="testUnifyWithTransformationAfterStoreForward">testUnifyWithTransformationAfterStoreForward	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.</body><body package="GlorpTests" selector="testUnifyWithTransformationAfterStoreInverse">testUnifyWithTransformationAfterStoreInverse	"This is a little tricky. If we set the value first, then impose the constraint, then we're effectively doubling what was set. I think this is actually right, but also a very weird case on top of weird scenarios to begin with"	(rowMap findOrAddRowForTable: t2 withKey: o2) at: f2 put: 12.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	"Note: vs. the 6 and 12 you might otherwise expect"	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.</body><body package="GlorpTests" selector="testUnifyWithTransformationBeforeStoreForward">testUnifyWithTransformationBeforeStoreForward	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.</body><body package="GlorpTests" selector="testUnifyWithTransformationBeforeStoreInverse">testUnifyWithTransformationBeforeStoreInverse	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap at: f2 key: o2 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 6.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 12.</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>tests-relatedrows</category><body package="GlorpTests" selector="testRelatedRowInternal">testRelatedRowInternal	| cf1 r1 r2 r3 |	cf1 := t1 createFieldNamed: 'cf1' type: (platform varChar: 10).	t1 addForeignKeyFrom: cf1 to: f1.	rowMap		unifyField: f1		key: o1		withField: cf1		key: o2.	rowMap		unifyField: f1		key: o1		withField: cf1		key: o3.	r1 := rowMap rowForTable: t1 withKey: o1.	r1 at: f1 put: o1.	r2 := rowMap rowForTable: t1 withKey: o2.	r2 at: f1 put: o2.	r3 := rowMap rowForTable: t1 withKey: o3.	r3 at: f1 put: o3.	self assert: (r1 relatedRowsIn: rowMap) isEmpty.	self assert: (r2 relatedRowsIn: rowMap) asArray = (Array with: r1).	self assert: (r3 relatedRowsIn: rowMap) asArray = (Array with: r1).</body></methods><methods><class-id>Glorp.GlorpConstantValueInRelationshipTest</class-id> <category>support</category><body package="GlorpDBTests" selector="idsFor:">idsFor: aCollection	^(aCollection collect: [:each | each id]) asSortedCollection asArray.</body><body package="GlorpDBTests" selector="sampleWorker">sampleWorker	| worker job3 |	worker := GlorpWorker new.	worker id: 1234.	worker name: 'Some Worker'.	worker pendingJobs add: (GlorpJob new id: 1; description: 'job 1').	worker pendingJobs add: (GlorpJob new id: 2; description: 'job 2').	worker finishedJobs add: (job3 := GlorpJob new id: 3; description: 'job 3').	worker finishedJobs add: (GlorpJob new id: 4; description: 'job 4').	worker priorityJobs add: job3.	^worker.</body><body package="GlorpDBTests" selector="setUp">setUp	system := GlorpWorkerDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.	session := GlorpSessionResource current newSession.	session system: system.</body><body package="GlorpDBTests" selector="writeTestData">writeTestData	session writeRow: system exampleWorkerRow.	session writeRow: (system exampleJobRow: 1 finished: false).	session writeRow: (system exampleJobRow: 2 finished: false).	session writeRow: (system exampleJobRow: 3 finished: true).	session writeRow: (system exampleJobRow: 4 finished: true).	session writeRow: system exampleLinkRow1.	session writeRow: system exampleLinkRow2.</body></methods><methods><class-id>Glorp.GlorpConstantValueInRelationshipTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testRead">testRead	| worker |	[session beginTransaction.	self writeTestData.	worker := session execute: (Query returningOneOf: GlorpWorker where: [:each | each id = 1234]).	self assert: (self idsFor: worker pendingJobs) = #(1 2).	self assert: (self idsFor: worker finishedJobs) = #(3 4).	self assert: (self idsFor: worker priorityJobs) = #(3).	] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadWithJoin">testReadWithJoin	| worker |	[session beginTransaction.	self writeTestData.	worker := session		execute:			(Query returningOneOf: GlorpWorker where: [:each | each pendingJobs id = 1]).	self assert: worker id = 1234] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testWrite">testWrite	| worker sampleWorker |	[session beginTransaction.	session beginUnitOfWork.	sampleWorker := self sampleWorker.	session register: sampleWorker.	session commitUnitOfWork.	session reset.	worker := session execute: (Query returningOneOf: GlorpWorker where: [:each | each id = 1234]).	self assert: (self idsFor: worker pendingJobs) = #(1 2).	self assert: (self idsFor: worker finishedJobs) = #(3 4).	self assert: (self idsFor: worker priorityJobs) = #(3).	] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpConstantValueInRelationshipTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpCollectionTypesWithClassModelsDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpCollectionTypeModels" selector="descriptorForGlorpThingWithLotsOfDifferentCollections:">descriptorForGlorpThingWithLotsOfDifferentCollections: aDescriptor	| ocMapping |	aDescriptor table: self ownerTable.	(aDescriptor newMapping: DirectMapping)		from: #id to: (self ownerTable fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #name to: (self ownerTable fieldNamed: 'NAME').	(aDescriptor newMapping: OneToManyMapping)		attributeName: #array;		orderBy: [:each | (each getTable: self thingOneTable) getField: 'ARRAY_POSITION'];		writeTheOrderField;			join:				(Join					from: (self ownerTable fieldNamed: 'ID')					to: (self thingOneTable fieldNamed: 'ARRAY_OWNER')).	(aDescriptor newMapping: OneToManyMapping)		attributeName: #set;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self thingOneTable fieldNamed: 'SET_OWNER')).	ocMapping := (aDescriptor newMapping: ManyToManyMapping)		attributeName: #orderedCollection;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self linkTable fieldNamed: 'OWNER_ID')				from: 'O'				to: (self linkTable fieldNamed: 'TYPE')).	ocMapping orderBy: [:each | (each getTable: self linkTable) getField: 'POSITION'].	ocMapping writeTheOrderField.	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #bag;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self linkTable fieldNamed: 'OWNER_ID')				from: 'B'				to: (self linkTable fieldNamed: 'TYPE')).	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #sortedCollection;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self linkTable fieldNamed: 'OWNER_ID')				from: 'S'				to: (self linkTable fieldNamed: 'TYPE')).</body></methods><methods><class-id>Glorp.GlorpCollectionTypesWithClassModelsDescriptorSystem</class-id> <category>class models</category><body package="GlorpCollectionTypeModels" selector="classModelForGlorpThingWithLotsOfDifferentCollections:">classModelForGlorpThingWithLotsOfDifferentCollections: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #array collection: Array of: GlorpThingOne.	aClassModel newAttributeNamed: #set collection: Set of: GlorpThingOne.	aClassModel newAttributeNamed: #orderedCollection collection: OrderedCollection of: GlorpThingOne.	aClassModel newAttributeNamed: #bag collection: Bag of: GlorpThingOne.	aClassModel newAttributeNamed: #sortedCollection collection: SortedCollection of: GlorpThingOne.</body></methods><methods><class-id>Glorp.GlorpMediaType</class-id> <category>accessing</category><body package="GlorpTestModels" selector="mimeType">mimeType	^mimeType</body><body package="GlorpTestModels" selector="mimeType:">mimeType: anObject	mimeType := anObject</body><body package="GlorpTestModels" selector="name">name 	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpMediaType class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="text">text	^self new name: 'text'; mimeType: 'text/plain'</body></methods><methods><class-id>Glorp.GlorpVarchar1Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform varchar: 1.</body></methods><methods><class-id>Glorp.GlorpVarchar1Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testBooleanToTFString">testBooleanToTFString	stType := Boolean.	self helpTestValue: nil.	self helpTestValue: true.	self helpTestValue: false.</body></methods><methods><class-id>Glorp.GlorpTag</class-id> <category>as yet unclassified</category><body package="GlorpTestModels" selector="generateKeyFromLabel">generateKeyFromLabel	key := label asLowercase</body><body package="GlorpTestModels" selector="key">key	^ key</body><body package="GlorpTestModels" selector="key:">key: aKey	key := aKey</body><body package="GlorpTestModels" selector="label">label	^ label</body><body package="GlorpTestModels" selector="label:">label: aLabel	label := aLabel</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>private</category><body package="GlorpTestModels" selector="computeCollections">computeCollections	customers do: [:each | each store: self].	purchases := customers inject: #() into: [:sum :each | sum, each purchases].	purchases do: [:each | each store: self].</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>accessing</category><body package="GlorpTestModels" selector="customers">customers	^customers</body><body package="GlorpTestModels" selector="customers:">customers: anObject	customers := anObject</body><body package="GlorpTestModels" selector="purchases">purchases	^purchases</body><body package="GlorpTestModels" selector="purchases:">purchases: aCollection	purchases := aCollection</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="id">id	^id.</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger.</body><body package="GlorpTestModels" selector="name">name	^name.</body><body package="GlorpTestModels" selector="name:">name: aString	name := aString.</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>testing</category><body package="GlorpTestModels" selector="assertEqual:">assertEqual: aStore	self assert: id = aStore id.	self assert: name = aStore name.	customers assertEqual: aStore customers.	purchases assertEqual: aStore purchases.</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	customers := OrderedCollection new.	purchases := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpVideoStore class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpDirectMappingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	| descriptor |	super setUp.	mapping := DirectMapping from: #id to: ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	descriptor := Descriptor new.	descriptor classModel: (GlorpClassModel for: GlorpCustomer).	descriptor addMapping: mapping.</body></methods><methods><class-id>Glorp.GlorpDirectMappingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testExpressionFor">testExpressionFor	| cust exp |	cust := GlorpCustomer new.	cust id: 12.	exp := mapping		expressionFor: cust		basedOn: BaseExpression new		relation: #=.	self assert: exp rightChild class == ConstantExpression.	self assert: exp rightChild value = 12.	self assert: exp relation = #=.	self assert: exp leftChild class == MappingExpression.</body><body package="GlorpTests" selector="testProxying">testProxying	| customers |	session beginTransaction.	[((system descriptorFor: GlorpPerson) mappingForAttributeNamed: #name) shouldProxy: true.	session modify: GlorpPerson example1 in: [].	session reset.	customers := session read: GlorpPerson.	self assert: customers first name isGlorpProxy.	self deny: customers first name isInstantiated.	self assert: customers first name = 'Zaphod Beeblebrox']		ensure: [session rollbackTransaction].	self deny: ((system descriptorFor: GlorpPerson) mappedFields includes: ((system tableNamed: 'PERSON') fieldNamed: 'NAME')).</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortTest</class-id> <category>support</category><body package="GlorpTests" selector="assertSortOrder:">assertSortOrder: aCollection	| ids |	ids := (sorted collect: [:each | each id]) asArray.	self assert: ids = aCollection asArray.</body><body package="GlorpTests" selector="sort">sort	| sorter |	sorter := GlorpRowSorter new getChildrenVia: #relatedItems.	sorted := sorter sort: unsorted.</body><body package="GlorpTests" selector="sort:">sort: aCollection	unsorted := aCollection.	self sort.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortTest</class-id> <category>tests</category><body package="GlorpTests" selector="testBasicSort1">testBasicSort1	self sort: self data1.	self assertSortOrder: #(3 2 1).</body><body package="GlorpTests" selector="testBasicSort2">testBasicSort2	"Try it with a different initial order. The sort is a convoluted way of writing the questionably-portable reverse"	self sort: (self data1 asSortedCollection: [:a :b | a id &gt;= b id]).	self assertSortOrder: #(3 2 1).</body><body package="GlorpTests" selector="testBasicSortCompleteGraph">testBasicSortCompleteGraph	| one two three |	one := GlorpBreadthFirstTopologicalSortItem new id: 1.	two := GlorpBreadthFirstTopologicalSortItem new id: 2.	three := GlorpBreadthFirstTopologicalSortItem new id: 3.	one relateTo: two.	one relateTo: three.	three relateTo: two.	three relateTo: one.	two relateTo: three.	two relateTo: one.	self sort: (Array with: one with: two with: three).	self assert: sorted size = 3.</body><body package="GlorpTests" selector="testMedium1">testMedium1	self sort: self dataForMedium.	self assertSortOrder: #('c1' 'a2' 'b1' 'a1' 'c3' 'a4' 'b3' 'a3' 'b2' 'b4' 'c2' 'c4').</body><body package="GlorpTests" selector="testNoCyclesMedium">testNoCyclesMedium	self sort: self dataForNoCyclesMedium.	self assertSortOrder: #('c1' 'c2' 'c3' 'c4' 'b1' 'b2' 'b3' 'b4' 'a1' 'a2' 'a3' 'a4').</body><body package="GlorpTests" selector="testNoCyclesMediumPermuted">testNoCyclesMediumPermuted	self sort: self dataForNoCyclesMediumPermuted.	self assertSortOrder: #('c1' 'b1' 'c2' 'b2' 'c3' 'b3' 'c4' 'b4' 'a1' 'a2' 'a3' 'a4').</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortTest</class-id> <category>data</category><body package="GlorpTests" selector="data1">data1	| one two three |	one := GlorpBreadthFirstTopologicalSortItem new id: 1.	two := GlorpBreadthFirstTopologicalSortItem new id: 2.	three := GlorpBreadthFirstTopologicalSortItem new id: 3.	one relateTo: two.	two relateTo: three.	^Array with: one with: two with: three.</body><body package="GlorpTests" selector="dataForGroupNamed:">dataForGroupNamed: aString	| one two three four |	one := GlorpBreadthFirstTopologicalSortItem new id: aString, '1'.	two := GlorpBreadthFirstTopologicalSortItem new id: aString, '2'.	three := GlorpBreadthFirstTopologicalSortItem new id: aString, '3'.	four := GlorpBreadthFirstTopologicalSortItem new id: aString, '4'.	^Array with: one with: two with: three with: four.</body><body package="GlorpTests" selector="dataForMedium">dataForMedium	"Data to ensure that things tend to stay together.  This is a simple grouping a1-&gt;b, b-&gt;c, b-&gt;a2, repeated, with some extra floating b's and c's."	groupA := self dataForGroupNamed: 'a'.	groupB := self dataForGroupNamed: 'b'.	groupC := self dataForGroupNamed: 'c'.	groupA first relateTo: groupB first.	(groupA at: 3) relateTo: (groupB at: 3).	groupB first relateTo: groupC first.	(groupB at: 3) relateTo: (groupC at: 3).	groupB first relateTo: (groupA at: 2).	(groupB at: 3) relateTo: (groupA at: 4).	^groupA, groupB, groupC.</body><body package="GlorpTests" selector="dataForNoCyclesMedium">dataForNoCyclesMedium	"Data to ensure that things tend to stay together.  This is a simple grouping a-&gt;b, b-&gt;c repeated"	groupA := self dataForGroupNamed: 'a'.	groupB := self dataForGroupNamed: 'b'.	groupC := self dataForGroupNamed: 'c'.	1 to: 4 do: [:i |		(groupA at: i) relateTo: (groupB at: i).		(groupB at: i) relateTo: (groupC at: i)].	^groupC, groupB, groupA.</body><body package="GlorpTests" selector="dataForNoCyclesMediumPermuted">dataForNoCyclesMediumPermuted	"Data to ensure that things tend to stay together.  This is a simple grouping a-&gt;b, b-&gt;c repeated"	groupA := self dataForGroupNamed: 'a'.	groupB := self dataForGroupNamed: 'b'.	groupC := self dataForGroupNamed: 'c'.	1 to: 4 do: [:i |		(groupA at: i) relateTo: (groupB at: i).		(groupB at: i) relateTo: (groupC at: i)].	^groupB, groupA, groupC.</body></methods><methods><class-id>Glorp.GlorpDescriptorSystemWithNamespacePoolDictionaryDeclarer class</class-id> <category>VA compatibility</category><body package="GlorpTestModels" selector="_PRAGMA_GlorpTestNamespace">_PRAGMA_GlorpTestNamespace	"%%PRAGMA DECLARE	(name: GlorpTestNamespace isPool: true isConstant: true)	(pool: GlorpTestNamespace declarations: (		))"</body><body package="GlorpTestModels" selector="initialize">initialize	"If this is VA, force the pool dictionary/namespace pragma for the test namespace to be handled. That means that subsequent packages on file-in will be able to see it. A lot of jumping through hoops for something that doesn't even get exercised in VA"	Dialect isVisualAge ifFalse: [^self].	(Smalltalk at: #EtAbstractMethodsBrowser) new		rebuildNamespaceIfRequired: (Smalltalk at: #GlorpTestModels)		askUser: false.</body></methods><methods><class-id>Glorp.GlorpPublisher</class-id> <category>accessing</category><body package="GlorpTestModels" selector="differentBunchOfEmployeesById">differentBunchOfEmployeesById	^differentBunchOfEmployeesById</body><body package="GlorpTestModels" selector="differentBunchOfEmployeesById:">differentBunchOfEmployeesById: aDictionary	differentBunchOfEmployeesById := aDictionary</body><body package="GlorpTestModels" selector="employees">employees	^employees.</body><body package="GlorpTestModels" selector="employees:">employees: aDictionary	employees := aDictionary.</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body><body package="GlorpTestModels" selector="titles">titles	^titles</body><body package="GlorpTestModels" selector="titles:">titles: aCollectionOfStrings	titles := aCollectionOfStrings</body><body package="GlorpTestModels" selector="titlesWithNumberInStock">titlesWithNumberInStock	^titlesWithNumberInStock</body><body package="GlorpTestModels" selector="titlesWithNumberInStock:">titlesWithNumberInStock: aDictionary	titlesWithNumberInStock := aDictionary.	self titlesWithNumberInStockLink: (Dictionary new addAll: (aDictionary associations collect: [:each | each copy]); yourself).</body><body package="GlorpTestModels" selector="titlesWithNumberInStockLink">titlesWithNumberInStockLink	^titlesWithNumberInStockLink</body><body package="GlorpTestModels" selector="titlesWithNumberInStockLink:">titlesWithNumberInStockLink: aDictionary	titlesWithNumberInStockLink := aDictionary</body></methods><methods><class-id>Glorp.GlorpDialectTest</class-id> <category>tests</category><body package="GlorpTests" selector="testBlockArgumentCount">testBlockArgumentCount	self assert: (Dialect argumentCountFor: [3]) = 0.	self assert: (Dialect argumentCountFor: [:a | 3]) = 1.	self assert: (Dialect argumentCountFor: [:a :b | a &lt;= b]) = 2.</body><body package="GlorpTests" selector="testTimeSetMillisecond">testTimeSetMillisecond	| time oldMs oldSec oldMin newMs |	Dialect supportsMillisecondsInTimes ifFalse: [^self].	time := Time now.	oldMs := time milliseconds.	oldSec := time seconds truncated.	oldMin := time minutes.	newMs := oldMs &gt; 989 ifTrue: [3] ifFalse: [oldMs + 10].	time millisecond: newMs.	self assert: time milliseconds = newMs.	self assert: time seconds truncated = oldSec.	self assert: time minutes = oldMin.</body><body package="GlorpTests" selector="testTokensBasedOn">testTokensBasedOn	self assert: (Dialect tokensBasedOn: '.' in: 'abc.def.ghi') asArray = #('abc' 'def' 'ghi').</body></methods><methods><class-id>Glorp.GlorpTimedExpiryCacheTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	self setUpExpiryWithRealDelay.</body><body package="GlorpTests" selector="setUpExpiryWithRealDelay">setUpExpiryWithRealDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedExpiryCachePolicy new timeout: 1).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedExpiryCachePolicy new timeout: 1).</body><body package="GlorpTests" selector="setUpExpiryWithZeroDelay">setUpExpiryWithZeroDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedExpiryCachePolicy new timeout: 0).</body><body package="GlorpTests" selector="setUpForExpiryActionOf:">setUpForExpiryActionOf: aSymbol	(cache session descriptorFor: GlorpCustomer) cachePolicy expiryAction: aSymbol.	(cache session descriptorFor: GlorpBankTransaction) cachePolicy expiryAction: aSymbol.</body><body package="GlorpTests" selector="setUpForNotify">setUpForNotify	self setUpForExpiryActionOf: #notify.</body><body package="GlorpTests" selector="setUpForNotifyAndRemove">setUpForNotifyAndRemove	self setUpForExpiryActionOf: #notifyAndRemove.</body><body package="GlorpTests" selector="setUpForRefresh">setUpForRefresh	self setUpForExpiryActionOf: #refresh.</body></methods><methods><class-id>Glorp.GlorpTimedExpiryCacheTest</class-id> <category>tests</category><body package="GlorpTests" selector="testExpiryReturningNilWithRealDelay">testExpiryReturningNilWithRealDelay	"test that objects expire with a non-zero delay time."	| customer customer2 |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	(Delay forSeconds: 2) wait.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests" selector="testNotExpiredAfterRefresh">testNotExpiredAfterRefresh	| customer |	self setUpForRefresh.	session accessor beginTransaction.	[session accessor executeSQLStringNoResult: 'INSERT INTO GR_CUSTOMER VALUES (3,''Fred Flintstone'')'.	customer := session execute: (Query returningOneOf: GlorpCustomer where: [:each | each id = 3]).	(Delay forSeconds: 2) wait.	self assert: (cache hasExpired: customer).	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: (cache hasExpired: customer)]		ensure: [session accessor rollbackTransaction].</body><body package="GlorpTests" selector="testNotify">testNotify	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotify.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry.</body><body package="GlorpTests" selector="testNotifyAndRemove">testNotifyAndRemove	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry = true.</body><body package="GlorpTests" selector="testRegisteredObjectsDoNotExpire">testRegisteredObjectsDoNotExpire	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	customer id: 3.	cache at: 3 insert: customer.	session beginUnitOfWork.	session register: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: customer seenExpiry.</body></methods><methods><class-id>Glorp.GlorpInt8Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testInt8">testInt8	type := (self platform) int8.	self helpTestValue: nil.	self helpTestValue: 3212321555.</body></methods><methods><class-id>Glorp.GlorpInt8Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform int8</body></methods><methods><class-id>Glorp.GlorpObjectMappedToFunctionTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	| accountRow3 |	super setUp.	session beginTransaction.	system writeCustomer1Rows.	accountRow3 := system exampleAccountRow3.	session writeRow: accountRow3.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests" selector="testRelationships">testRelationships	| branch accounts |	branch := session readOneOf: GlorpBankBranch where: [:each | each branchNumber = 2].	accounts := branch accounts yourself.	self assert: accounts size = 1.	self assert: accounts first id = 9874.</body></methods><methods><class-id>Glorp.GlorpObjectMappedToFunctionTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testBasicRead">testBasicRead	| branches |	branches := session readManyOf: GlorpBankBranch.	self assert: branches size = 3.	self assert: (branches collect: [:each | each branchNumber]) asSortedCollection = #(2 3 712) asSortedCollection.</body><body package="GlorpDBTests" selector="testCache">testCache	| branches branch2 branch3 |	branches := session readManyOf: GlorpBankBranch.	branch2 := session readOneOf: GlorpBankBranch where: [:each | each branchNumber = 2].	branch3 := session readOneOf: GlorpBankBranch where: [:each | each branchNumber = 3].	self deny: branch2 == branch3.	self assert: (branches includes: branch2).	self assert: (branches includes: branch3).</body><body package="GlorpDBTests" selector="testNoWriteValidation">testNoWriteValidation	| |	(session system descriptorFor: GlorpBankBranch) mappings next readOnly: false.	self should: [session system validate] raise: Dialect error.</body><body package="GlorpDBTests" selector="testReadQueryingAttributes">testReadQueryingAttributes	| branches |	branches := session readManyOf: GlorpBankBranch where: [:each |		each accounts anySatisfy: [:eachAccount |			eachAccount accountNumber accountNumber in: #( '3' '4')]].	self assert: branches size = 2.	self assert: branches asSet size = 2.</body></methods><methods><class-id>Glorp.GlorpFilteringQueryDBTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testReadDictionary">testReadDictionary	| entryMapping encyclopedias query readBackEncyclopedias canadian plagiarists |	session system: (GlorpEncyclopediaDescriptorSystem forPlatform: session platform).	system := session system.	encyclopedias := system exampleEncyclopedias.	entryMapping := (system descriptorFor: GlorpEncyclopedia) mappingForAttributeNamed: #entries.	entryMapping useFilteredRead.	session transact: [session register: encyclopedias].	session reset.	query := Query readManyOf: GlorpEncyclopedia.	query orderBy: [:each | each name].	readBackEncyclopedias := session execute: query.	canadian := readBackEncyclopedias first.	self assert: canadian entries size = 3.	session accessor permitNothing.	self assert: (canadian entries at: 'abcde') id = 'two'.	self assert: (canadian entries at: '12345') id = 'one'.	self assert: (canadian entries at: 'unique') id = 'three'.	plagiarists := readBackEncyclopedias at: 2.	self assert: plagiarists entries size = 2.	self assert: (plagiarists entries at: '54321') = (canadian entries at: '12345').	self assert: (plagiarists entries at: 'edcba') = (canadian entries at: 'abcde').	self assert: readBackEncyclopedias last entries isEmpty.</body><body package="GlorpDBTests" selector="testReadOneToMany">testReadOneToMany	"This doesn't actually short-circuit interestingly, because of the shared holder"	| accounts txMapping tx1 tx2 otherHolder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accounts := session execute: ((Query returningManyOf: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 9874, 1 holder, 2 transactions"	tx1 := accounts last accountHolders first transactions.	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	otherHolder := accounts first accountHolders detect: [:each | each id = 28].	tx2 := otherHolder transactions.	self assert: (tx1 collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).	self assert: (tx2 collect: [:each | each amount currency]) asSortedCollection asArray = #(EUR).</body><body package="GlorpDBTests" selector="testReadOneToMany2">testReadOneToMany2	| accounts txMapping otherHolder holder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accounts := session execute: ((Query returningManyOf: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	holder := accounts first accountHolders detect: [:each | each id = 28].	otherHolder := accounts first accountHolders detect: [:each | each id = 27].	self assert:  (holder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#EUR).	session accessor permitNothing.	self assert: (otherHolder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).</body><body package="GlorpDBTests" selector="testReadOneToManyEmptyCriteria">testReadOneToManyEmptyCriteria	| accounts txMapping otherHolder holder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accounts := session execute: (Query returningManyOf: GlorpBankAccount).	accounts := accounts asSortedCollection: [:a :b | a id &lt;= b id].	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	holder := accounts first accountHolders detect: [:each | each id = 28].	otherHolder := accounts first accountHolders detect: [:each | each id = 27].	self assert:  (holder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#EUR).	session accessor permitNothing.	self assert: (otherHolder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).</body><body package="GlorpDBTests" selector="testReadOneToManyNoProxy">testReadOneToManyNoProxy	"This doesn't actually short-circuit interestingly, because of the shared holder"	| accounts txMapping tx1 tx2 otherHolder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping shouldProxy: false.	txMapping useFilteredRead.	accounts := session execute: ((Query returningManyOf: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 9874, 1 holder, 2 transactions"	tx1 := accounts last accountHolders first transactions.	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	otherHolder := accounts first accountHolders detect: [:each | each id = 28].	tx2 := otherHolder transactions.	self assert: (tx1 collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).	self assert: (tx2 collect: [:each | each amount currency]) asSortedCollection asArray = #(EUR).</body><body package="GlorpDBTests" selector="testReadOneToOne">testReadOneToOne	| people addressMapping |	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.	addressMapping := (system descriptorFor: GlorpPerson) mappingForAttributeNamed: #address.	addressMapping useFilteredRead.	people := session execute: (Query returningManyOf: GlorpPerson where: [:each | each id ~= 2]).	people first address yourSelf.	session accessor permitNothing.	people := people asSortedCollection: [:a :b | a id &lt;= b id].	self assert: people first address id = 2.	self assert: (people at: 2) address id = 3.	self assert: (people at: 3) address id = 1.	self assert: people size = 3.</body><body package="GlorpDBTests" selector="testTwoLevelRead">testTwoLevelRead	"A one-many and a many-many"	| accounts txMapping otherHolder holder accountMapping |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accountMapping := (system descriptorFor: GlorpBankAccount) mappingForAttributeNamed: #accountHolders.	accountMapping useFilteredRead.	accounts := session execute: ((Query returningManyOf: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	self assert: accounts first accountHolders size = 2.	holder := accounts first accountHolders detect: [:each | each id = 28].	holder transactions yourSelf.	session accessor permitNothing.	self assert: (accounts last accountHolders collect: [:each | each id]) asArray = #(27).	otherHolder := accounts first accountHolders detect: [:each | each id = 27].	self assert:  (holder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#EUR).	session accessor permitNothing.	self assert: (otherHolder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).</body></methods><methods><class-id>Glorp.GlorpFilteringQueryDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session beginTransaction.</body><body package="GlorpDBTests" selector="tearDown">tearDown	session rollbackTransaction.	session resetPermissions.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpCollectionTypeModelsPackage class</class-id> <category>instance creation</category><body package="GlorpCollectionTypeModels" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.GlorpTypeComparisonTest</class-id> <category>testing</category><body package="GlorpDBTypeTests" selector="testIntegerToInteger">testIntegerToInteger	self assert: (GlorpIntegerType new platform: platform) = (GlorpIntegerType new platform: platform).	self assert: (GlorpIntegerType new platform: platform) hash = (GlorpIntegerType new platform: platform) hash.</body><body package="GlorpDBTypeTests" selector="testIntegerToIntegerishNumber">testIntegerToIntegerishNumber	self assert: (GlorpIntegerType new platform: platform) = (GlorpNumericType new platform: platform).	self assert: (GlorpIntegerType new platform: platform) hash = (GlorpNumericType new platform: platform) hash.	self assert: (GlorpNumericType new platform: platform) = (GlorpIntegerType new platform: platform).	self assert: (GlorpNumericType new platform: platform) hash = (GlorpIntegerType new platform: platform) hash.</body><body package="GlorpDBTypeTests" selector="testIntegerToNumber">testIntegerToNumber	self deny: (GlorpIntegerType new platform: platform) = (GlorpNumericType new platform: platform; precision: 2).	self deny: (GlorpIntegerType new platform: platform) hash = (GlorpNumericType new platform: platform; precision: 2) hash.	self deny: (GlorpNumericType new platform: platform; precision: 2) = (GlorpIntegerType new platform: platform).	self deny: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpIntegerType new platform: platform) hash.</body><body package="GlorpDBTypeTests" selector="testIntegerishNumberToNumber">testIntegerishNumberToNumber	self deny: (GlorpNumericType new platform: platform) = (GlorpNumericType new platform: platform; precision: 2).	self deny: (GlorpNumericType new platform: platform) hash = (GlorpNumericType new platform: platform; precision: 2) hash.	self deny: (GlorpNumericType new platform: platform; precision: 2) = (GlorpNumericType new platform: platform).	self deny: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpNumericType new platform: platform) hash.</body><body package="GlorpDBTypeTests" selector="testNumberToNumber">testNumberToNumber	self assert: (GlorpNumericType new platform: platform; precision: 2) = (GlorpNumericType new platform: platform; precision: 2).	self assert: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpNumericType new platform: platform; precision: 2) hash.	self assert: (GlorpNumericType new platform: platform; precision: 2) = (GlorpNumericType new platform: platform; precision: 2).	self assert: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpNumericType new platform: platform; precision: 2) hash.</body></methods><methods><class-id>Glorp.GlorpTypeComparisonTest</class-id> <category>running</category><body package="GlorpDBTypeTests" selector="setUp">setUp	super setUp.	platform := DatabasePlatform new</body></methods><methods><class-id>Glorp.GlorpExpressionIterationTest</class-id> <category>tests</category><body package="GlorpTests" selector="helpTestSingleNodeDo:">helpTestSingleNodeDo: exp 	self assert: (exp collect: [:each | each]) = (OrderedCollection with: exp)</body><body package="GlorpTests" selector="testDoBase">testDoBase	self helpTestSingleNodeDo:BaseExpression new</body><body package="GlorpTests" selector="testDoCollection">testDoCollection	| exp l r |	exp := CollectionExpression new.	l := BaseExpression new.	r := BaseExpression new.	exp leftChild: l; rightChild: r.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: r with: exp)).</body><body package="GlorpTests" selector="testDoConstant">testDoConstant	self helpTestSingleNodeDo: ConstantExpression new</body><body package="GlorpTests" selector="testDoField">testDoField	| exp |	exp := FieldExpression new.	exp field: nil base: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests" selector="testDoMapping">testDoMapping	| exp |	exp := MappingExpression new.	exp named: 'foo' basedOn: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests" selector="testDoParameter">testDoParameter	| exp |	exp := ParameterExpression new.	exp field: nil base: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests" selector="testDoRelation">testDoRelation	| exp l r |	exp := RelationExpression new.	l := BaseExpression new.	r := BaseExpression new.	exp leftChild: l; rightChild: r.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: l with: r with: exp)).</body><body package="GlorpTests" selector="testDoTable">testDoTable	| exp |	exp := TableExpression new.	exp table: nil base: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests" selector="testDoWithCommonBase">testDoWithCommonBase	| exp l r base |	exp := RelationExpression new.	base := BaseExpression new.	l := MappingExpression new.	l named: nil basedOn: base.	r := MappingExpression new.	r named: nil basedOn: base.	exp leftChild: l; rightChild: r.		self assert: ((exp collect: [:each | each]) = (OrderedCollection with: base with: l with: r with: exp)).</body></methods><methods><class-id>Glorp.GlorpSessionTest</class-id> <category>support</category><body package="GlorpTests" selector="addCustomerToCache">addCustomerToCache	| customer |	customer := GlorpCustomer example1.	customer id: 3.	session cacheAt: 3 put: customer.	^customer</body><body package="GlorpTests" selector="setUp">setUp	super setUp.	session := GlorpSession new.	session system: system</body></methods><methods><class-id>Glorp.GlorpSessionTest</class-id> <category>tests</category><body package="GlorpTests" selector="helpTestUpdateWithExpiredExistingEntry:">helpTestUpdateWithExpiredExistingEntry: aCachePolicy	| customer customer2 row table unitOfWork |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: aCachePolicy.	customer := self addCustomerToCache.	customer2 := GlorpCustomer new.	customer2 id: customer id.	customer2 name: 'Barney Rubble'.	row := DatabaseRow newForTable: (table := system tableNamed: 'GR_CUSTOMER').	row at: (table fieldNamed: 'ID') put: customer id.	unitOfWork := UnitOfWork new.	unitOfWork session: session.	"Since there's already an object there, this shouldn't do anything"	unitOfWork updateSessionCacheFor: customer2 withRow: row.	self assert: (session expiredInstanceOf: GlorpCustomer key: 3) == customer.</body><body package="GlorpTests" selector="helpTestUpdateWithoutExpiredExistingEntry:">helpTestUpdateWithoutExpiredExistingEntry: aCachePolicy	| customer2 row table unitOfWork |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	customer2 := GlorpCustomer new.	customer2 id: 3.	customer2 name: 'Barney Rubble'.	row := DatabaseRow newForTable: (table := system tableNamed: 'GR_CUSTOMER').	row at: (table fieldNamed: 'ID') put: 3.	unitOfWork := UnitOfWork new.	unitOfWork session: session.	unitOfWork updateSessionCacheFor: customer2 withRow: row.	self assert: (session expiredInstanceOf: GlorpCustomer key: 3) == customer2.</body><body package="GlorpTests" selector="testAddingDescriptors">testAddingDescriptors	self assert: session system == system.	self assert: system session == session.	(session descriptorFor: GlorpAddress) session == session.</body><body package="GlorpTests" selector="testDuplicateDetection">testDuplicateDetection	| customer customer2 |	session beginUnitOfWork.	customer := self addCustomerToCache.	customer2 := customer copy.	self should: [session register: customer2] raise: Dialect error.	session rollbackUnitOfWork.</body><body package="GlorpTests" selector="testExecuteQuery">testExecuteQuery	| q result |	q := GlorpQueryStub new result: 3.	result := session execute: q.	self assert: result = 3</body><body package="GlorpTests" selector="testHasExpired1">testHasExpired1	| customer |	customer := self addCustomerToCache.	self deny: (session hasExpired: customer)</body><body package="GlorpTests" selector="testHasExpired2">testHasExpired2	| customer |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	customer := self addCustomerToCache.	self assert: (session hasExpired: customer)</body><body package="GlorpTests" selector="testHasExpired3">testHasExpired3	| customer |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	customer := self addCustomerToCache.	self assert: (session hasExpired: customer)</body><body package="GlorpTests" selector="testHasObjectOfClassExpired1">testHasObjectOfClassExpired1	self addCustomerToCache.	self deny: (session hasObjectExpiredOfClass: GlorpCustomer withKey: 3).</body><body package="GlorpTests" selector="testHasObjectOfClassExpired2">testHasObjectOfClassExpired2	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	self addCustomerToCache.	self assert: (session hasObjectExpiredOfClass: GlorpCustomer withKey: 3).</body><body package="GlorpTests" selector="testSQLDeleteStringFor">testSQLDeleteStringFor	| row table string |	table := session system tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 12.	row at: (table fieldNamed: 'STREET') put: 'some street'.	string := (DeleteCommand forRow: row useBinding: true session: session) sqlString.	self assert: string = 'DELETE FROM GR_ADDRESS WHERE ID = ?'.	string := (DeleteCommand forRow: row useBinding: false session: session) sqlString.	self assert: string = 'DELETE FROM GR_ADDRESS WHERE ID = 12'.</body><body package="GlorpTests" selector="testUpdateWithExpiredExistingEntry">testUpdateWithExpiredExistingEntry	self helpTestUpdateWithExpiredExistingEntry: (TimedExpiryCachePolicy new timeout: 0; expiryAction: #refresh).</body><body package="GlorpTests" selector="testUpdateWithExpiredExistingEntry2">testUpdateWithExpiredExistingEntry2	self helpTestUpdateWithExpiredExistingEntry: (TimedStrongCachePolicy new timeout: 0; expiryAction: #refresh).</body><body package="GlorpTests" selector="testUpdateWithoutExpiredExistingEntry">testUpdateWithoutExpiredExistingEntry	self helpTestUpdateWithoutExpiredExistingEntry: (TimedExpiryCachePolicy new timeout: 0).</body><body package="GlorpTests" selector="testUpdateWithoutExpiredExistingEntry2">testUpdateWithoutExpiredExistingEntry2	self helpTestUpdateWithoutExpiredExistingEntry: (TimedStrongCachePolicy new timeout: 0).</body></methods><methods><class-id>Glorp.GlorpFilteringQueryTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp</body></methods><methods><class-id>Glorp.GlorpFilteringQueryTest</class-id> <category>tests</category><body package="GlorpTests" selector="testSimple">testSimple	| query result |	query := FilteringQuery on: #( 1 2 3 4 5 6 7 8) filter: [:each :parameters | each odd].	result := GlorpSession new execute: query.	self assert: result = #(1 3 5 7).</body></methods><methods><class-id>Glorp.GlorpDatabaseIndexTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testNameGeneration">testNameGeneration	| platform table field index |	platform := GlorpDatabaseLoginResource defaultPlatform.	table := DatabaseTable new						name: 'A_VERY_VERY_VERY_LONG_TABLE_NAME';						yourself.	field := table createFieldNamed: 'A_VERY_LONG_FIELD_NAME' type: platform serial.	index := table addIndexForField: field.	self assert: index name size &lt;= platform maximumLengthOfTableName.</body><body package="GlorpDBTests" selector="testNameGenerationLong">testNameGenerationLong	| platform table field index |	"SQL Server has very long IDs"	platform := SQLServerPlatform new.	table := DatabaseTable new						name: 'A_VERY_VERY_VERY_LONG_TABLE_NAME';						yourself.	field := table createFieldNamed: 'A_VERY_LONG_FIELD_NAME' type: platform serial.	index := table addIndexForField: field.	self assert: index name size &lt;= platform maximumLengthOfTableName.	self assert: index name = (table name, '_', field name, '_IDX').</body></methods><methods><class-id>Glorp.GlorpTimedStrongCacheTest</class-id> <category>tests</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	self setUpExpiryWithRealDelay.</body><body package="GlorpTests" selector="setUpExpiryWithRealDelay">setUpExpiryWithRealDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedStrongCachePolicy new timeout: 1).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedStrongCachePolicy new timeout: 1).</body><body package="GlorpTests" selector="setUpExpiryWithZeroDelay">setUpExpiryWithZeroDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedStrongCachePolicy new timeout: 0).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedStrongCachePolicy new timeout: 0).</body><body package="GlorpTests" selector="setUpForExpiryActionOf:">setUpForExpiryActionOf: aSymbol	(cache session descriptorFor: GlorpCustomer) cachePolicy expiryAction: aSymbol.	(cache session descriptorFor: GlorpBankTransaction) cachePolicy expiryAction: aSymbol.</body><body package="GlorpTests" selector="setUpForNotifyAndRemove">setUpForNotifyAndRemove	self setUpForExpiryActionOf: #notifyAndRemove.</body><body package="GlorpTests" selector="setUpForRefresh">setUpForRefresh	self setUpForExpiryActionOf: #refresh.</body><body package="GlorpTests" selector="testExpiryReturningNilWithRealDelay">testExpiryReturningNilWithRealDelay	"test that objects expire with a non-zero delay time."	| customer customer2 |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	(Delay forSeconds: 2) wait.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests" selector="testNotExpiredAfterRefresh">testNotExpiredAfterRefresh	| customer |	self setUpForRefresh.	session accessor beginTransaction.	[session accessor executeSQLStringNoResult: 'INSERT INTO GR_CUSTOMER VALUES (3,''Fred Flintstone'')'.	customer := session execute: (Query returningOneOf: GlorpCustomer where: [:each | each id = 3]).	(Delay forSeconds: 2) wait.	self assert: (cache hasExpired: customer).	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: (cache hasExpired: customer)]		ensure: [session accessor rollbackTransaction].</body><body package="GlorpTests" selector="testNotify">testNotify	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotify.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry.</body><body package="GlorpTests" selector="testNotifyAndRemove">testNotifyAndRemove	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry = true.</body><body package="GlorpTests" selector="testRegisteredObjectsDoNotExpire">testRegisteredObjectsDoNotExpire	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	customer id: 3.	cache at: 3 insert: customer.	session beginUnitOfWork.	session register: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: customer seenExpiry.</body></methods><methods><class-id>Glorp.GlorpTimedStrongCacheTest</class-id> <category>support</category><body package="GlorpTests" selector="setUpForNotify">setUpForNotify	self setUpForExpiryActionOf: #notify.</body></methods><methods><class-id>Glorp.GlorpJob</class-id> <category>accessing</category><body package="GlorpTestModels" selector="description">description	^description</body><body package="GlorpTestModels" selector="description:">description: anObject	description := anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpReadingPersonWithEmailAddressesTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	session beginTransaction.	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	personRow := session system examplePersonRow1.	session writeRow: personRow.	emailAddress1Row := session system exampleEmailAddressRow1.	emailAddress2Row := session system exampleEmailAddressRow2.	id1 := emailAddress1Row at: (emailAddress1Row table fieldNamed: 'ID').	id2 := emailAddress2Row at: (emailAddress2Row table fieldNamed: 'ID').	session writeRow: emailAddress1Row.	session writeRow: emailAddress2Row.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session rollbackTransaction.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpReadingPersonWithEmailAddressesTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testObjectsNotAddedTwiceWhenReadingMultipleObjectsOneToMany">testObjectsNotAddedTwiceWhenReadingMultipleObjectsOneToMany	"Read in the objects first, so they're in cache. Make sure they don't get the collection built up twice."	| people |	people := session readManyOf: GlorpPerson.	self testReadMultipleObjectsOneToMany.	^people.</body><body package="GlorpDBTests" selector="testPreparedStatementsAreFaster">testPreparedStatementsAreFaster	"Not really a good test, since there are lots of other factors. And since we don't support this on all dialects/databases, they might easily be the same. Maybe should remove this test, but on the other hand it's the most useful feedback that the prepared statements are actually good for something"	| timePrepared timeUnPrepared| 	session reusePreparedStatements: true.	session reset.	timeUnPrepared := Time millisecondsToRun: [		session readManyOf: GlorpPerson where: [:eachPerson | eachPerson id = 3].		session readManyOf: GlorpPerson where: [:eachPerson | eachPerson id ~= 3].		session readManyOf: GlorpPerson where: [:eachPerson | eachPerson id &gt;= 3]].	session reset.	timePrepared := Time millisecondsToRun: [		3 timesRepeat: [ | query |			query := Query returningManyOf: GlorpPerson where: [:eachPerson | eachPerson id = (eachPerson parameter: 1)].			query executeWithParameters: #(3) in: session]].	(session accessor numberOfPreparedStatements &lt; 1) ifTrue: [^self "Unsupported, don't bother testing"].	Transcript cr; show: 'Time reusing prepared statements = ', timePrepared printString.	Transcript cr; show: 'Time not reusing prepared statements = ', timeUnPrepared printString.	"Give a little bit of room, so if they take roughly the same amount of time it'll still pass"	self assert: (timePrepared * 0.8 )&lt; timeUnPrepared.</body><body package="GlorpDBTests" selector="testPreparedStatementsAreReused">testPreparedStatementsAreReused	| | 	"This test only makes sense if binding is on" 	session useBinding ifFalse: [^self].	session reusePreparedStatements: true.	session reset.	session readManyOf: GlorpPerson where: [:eachPerson | eachPerson id = 3].	session readManyOf: GlorpPerson where: [:eachPerson | eachPerson id ~= 3].	session readManyOf: GlorpPerson where: [:eachPerson | eachPerson id &gt;= 3].	self assert: session accessor numberOfPreparedStatements = 3.	session reset.	1 to: 3 do: [:i | | query |			query := Query returningManyOf: GlorpPerson where: [:eachPerson | eachPerson id = (eachPerson parameter: 1)].			query executeWithParameters: (Array with: i) in: session].	self assert: session accessor numberOfPreparedStatements = 1.</body><body package="GlorpDBTests" selector="testReadMultipleObjectsOneToMany">testReadMultipleObjectsOneToMany	| query result person addresses |	query := Query returningManyOf: GlorpPerson where: [:eachPerson | eachPerson id = 3].	query alsoFetch: [:each | each emailAddresses].	result := query executeIn: session.	self assert: result size = 1.	person := result first.	addresses := person emailAddresses.	self deny: addresses isGlorpProxy.	self assert: addresses size = 2.	self 		assert: (addresses first id = id1 or: [addresses last id = id1]).	self 		assert: (addresses first id = id2 or: [addresses last id = id2]).	self assert: addresses first id ~= addresses last id.</body><body package="GlorpDBTests" selector="testReadPersonWithEmailAddresses">testReadPersonWithEmailAddresses	| query result emailAddresses |	query := Query		returningOneOf:GlorpPerson		where: [:person | person id = 3].	result := query executeIn: session.	emailAddresses := result emailAddresses getValue.	self assert: emailAddresses size = 2.	self		assert:			(emailAddresses first id = id1 or: [emailAddresses last id = id1]).	self		assert:			(emailAddresses first id = id2 or: [emailAddresses last id = id2]).	self assert: emailAddresses first id ~= emailAddresses last id.</body></methods><methods><class-id>Glorp.GlorpReadingPersonWithEmailAddressesTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpInt2Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testBooleanToInteger">testBooleanToInteger	stType := Boolean.	self helpTestValue: nil.	self helpTestValue: true.	self helpTestValue: false.</body><body package="GlorpDBTypeTests" selector="testInt2">testInt2	self helpTestValue: nil.	self helpTestValue: 32123.</body></methods><methods><class-id>Glorp.GlorpInt2Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform int2.</body></methods><methods><class-id>Glorp.GlorpQueryStub</class-id> <category>executing</category><body package="GlorpDBTests" selector="executeWithParameters:in:">executeWithParameters: parameterArray in: aSession 	aSession register: result.	^result.</body></methods><methods><class-id>Glorp.GlorpQueryStub</class-id> <category>initialize</category><body package="GlorpDBTests" selector="initialize">initialize	super initialize.	readsOneObject := true.</body></methods><methods><class-id>Glorp.GlorpQueryStub</class-id> <category>accessing</category><body package="GlorpDBTests" selector="result">result	^result</body><body package="GlorpDBTests" selector="result:">result: anObject	result := anObject</body></methods><methods><class-id>Glorp.GlorpQueryStub class</class-id> <category>instance creation</category><body package="GlorpDBTests" selector="newQuery">newQuery	^self new.</body></methods><methods><class-id>Glorp.GlorpEncyclopedia</class-id> <category>accessing</category><body package="GlorpTestModels" selector="articleAt:put:">articleAt: aString put: anEntry	entries at: aString put: anEntry.</body><body package="GlorpTestModels" selector="biographicalEntries">biographicalEntries	^biographicalEntries</body><body package="GlorpTestModels" selector="biographicalEntries:">biographicalEntries: aDictionary	biographicalEntries := aDictionary</body><body package="GlorpTestModels" selector="entries">entries	^entries.</body><body package="GlorpTestModels" selector="entries:">entries: aDictionary	entries := aDictionary</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: aString	name := aString</body><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	name isNil ifFalse: [aStream nextPutAll: name].	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpEncyclopedia</class-id> <category>initialize</category><body package="GlorpTestModels" selector="initialize">initialize	entries := Dictionary new.	biographicalEntries := Dictionary new.</body></methods><methods><class-id>Glorp.GlorpEncyclopedia class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpEncyclopedia class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	| result |	result := GlorpEncyclopedia new.	result entries at: 'one' put: GlorpEncyclopediaEntry example1.	result entries at: 'two' put: GlorpEncyclopediaEntry example2.	^result.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="inStore">inStore	^inStore</body><body package="GlorpTestModels" selector="inStore:">inStore: anObject	inStore := anObject</body><body package="GlorpTestModels" selector="price">price	^price</body><body package="GlorpTestModels" selector="price:">price: anObject	price := anObject</body><body package="GlorpTestModels" selector="title">title	^title</body><body package="GlorpTestModels" selector="title:">title: aString	title := aString</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>comparing</category><body package="GlorpTestModels" selector="&lt;=">&lt;= aVideoPurchase	^self title &lt;= aVideoPurchase title.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="customer">customer	^customer</body><body package="GlorpTestModels" selector="customer:">customer: aCustomer	customer := aCustomer.</body><body package="GlorpTestModels" selector="store:">store: aGlorpVideoStore	store := aGlorpVideoStore.</body><body package="GlorpTestModels" selector="videoStore">videoStore	^store.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self title.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>testing</category><body package="GlorpTestModels" selector="assertEqual:">assertEqual: aPurchase	self assert: customer name = aPurchase customer name.	self assert: customer dateOfBirth = aPurchase customer dateOfBirth.	self assert: store id = aPurchase videoStore id.	self assert: id = aPurchase id.	self assert: title = aPurchase title.	self assert: (price * 1000) rounded = (aPurchase price * 1000) rounded.	self assert: inStore = aPurchase inStore.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpPrimaryKeyExpressionWithConstantTest</class-id> <category>tests</category><body package="GlorpTests" selector="testAsExpressionCompound">testAsExpressionCompound		| e personTable |	personTable := system tableNamed: 'PERSON'.	e := compoundExpression asGeneralGlorpExpression.	self assert: (e rightChild isKindOf: RelationExpression).	self assert: (e rightChild relation == #=).	self assert: (e rightChild leftChild isKindOf: FieldExpression).	self assert: e rightChild leftChild field == (personTable fieldNamed: 'ADDRESS_ID').	self assert: (e rightChild rightChild isKindOf: ConstantExpression).	self assert: e rightChild rightChild value = 'B'.</body><body package="GlorpTests" selector="testAsExpressionSingle">testAsExpressionSingle		| e field param |	e := expression asGeneralGlorpExpression.	self assert: (e isKindOf: RelationExpression).	self assert: e relation == #=.	field := e leftChild.	self assert: (field isKindOf: FieldExpression).	self assert: field field == ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	param := e rightChild.	self assert: (param isKindOf: ConstantExpression).	self assert: param value = 7.</body><body package="GlorpTests" selector="testCompoundSQLPrinting">testCompoundSQLPrinting	| stream params|	stream := WriteStream on: (String new: 100).	params := Dictionary new.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID') put: 1.	compoundExpression printSQLOn: stream withParameters: params.	self assert: stream contents = 'PERSON.NAME = 1 AND PERSON.ADDRESS_ID = ''B'''.</body><body package="GlorpTests" selector="testParameterCount">testParameterCount	self assert: expression numberOfParameters = 1.	self assert: compoundExpression numberOfParameters = 2.</body><body package="GlorpTests" selector="testSQLPrinting">testSQLPrinting	| stream params |	stream := WriteStream on: (String new: 100).	params := Dictionary new.	expression printSQLOn: stream withParameters: params.	self assert: stream contents = 'CUSTOMER_ACCT_LINK.ACCT_ID = 7'</body></methods><methods><class-id>Glorp.GlorpPrimaryKeyExpressionWithConstantTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	expression := Join 		from: 7		to: ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	compoundExpression := Join		from: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID')		to: ((system tableNamed: 'PERSON') fieldNamed: 'NAME').	compoundExpression		addSource: 'B'		target: ((system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID').</body></methods><methods><class-id>Glorp.GlorpPassenger</class-id> <category>accessing</category><body package="GlorpTestModels" selector="airline">airline	^airline.</body><body package="GlorpTestModels" selector="airline:">airline: anAirline	airline := anAirline.</body><body package="GlorpTestModels" selector="frequentFlyerPoints">frequentFlyerPoints	^frequentFlyerMiles.</body><body package="GlorpTestModels" selector="frequentFlyerPoints:">frequentFlyerPoints: aSmallInteger 	frequentFlyerMiles := aSmallInteger.</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: aSmallInteger 	id := aSmallInteger.</body><body package="GlorpTestModels" selector="name">name	^name.</body><body package="GlorpTestModels" selector="name:">name: aString 	name := aString.</body></methods><methods><class-id>Glorp.GlorpPassenger class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		id: 3;		name: 'Some Passenger';		frequentFlyerPoints: 10000;		airline: GlorpAirline example1.</body><body package="GlorpTestModels" selector="example2">example2	^self new		id: 39;		name: 'Some Other Passenger';		frequentFlyerPoints: 7;		airline: GlorpAirline example2.</body></methods><methods><class-id>Glorp.GlorpConstantMappingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testConstantInClass">testConstantInClass	slot := nil.	mappingToClass mapObject: self inElementBuilder: nil.	self assert: slot = 34.</body><body package="GlorpTests" selector="testConstantInClassDoesNotWriteToRow">testConstantInClassDoesNotWriteToRow	"Would raise an exception if it tried to write into nil"	mappingToClass mapFromObject: self intoRowsIn: nil.</body><body package="GlorpTests" selector="testGetValue">testGetValue	slot := nil.	self assert: (mappingToClass getValueFrom: self) = 34.</body><body package="GlorpTests" selector="testSessionValue">testSessionValue	mappingToClass constantValueIsSession.	self assert: (mappingToClass constantValueIn: 38)== 38.</body></methods><methods><class-id>Glorp.GlorpConstantMappingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	| descriptor |	super setUp.	mappingToClass := ConstantMapping new		attributeName: #slot;		constantValue: 34.	descriptor := Descriptor new.	descriptor classModel: (GlorpClassModel for: self class).	descriptor addMapping: mappingToClass.	mappingToRow := ConstantMapping new.	mappingToSession := ConstantMapping new</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>glorp/events</category><body package="GlorpTestModels" selector="glorpNoticeOfExpiryIn:">glorpNoticeOfExpiryIn: aSession	seenExpiry := true.</body><body package="GlorpTestModels" selector="glorpPostFetch:">glorpPostFetch: aSession	seenPostFetch := true</body><body package="GlorpTestModels" selector="glorpPostWrite:">glorpPostWrite: aSession	seenPostWrite := true</body><body package="GlorpTestModels" selector="glorpPreWrite:">glorpPreWrite: aSession	seenPreWrite := true</body><body package="GlorpTestModels" selector="seenExpiry">seenExpiry	^seenExpiry</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>accessing</category><body package="GlorpTestModels" selector="accounts">accounts	^accounts.</body><body package="GlorpTestModels" selector="accounts:">accounts: aCollection	accounts := aCollection.</body><body package="GlorpTestModels" selector="addAccount:">addAccount: aBankAccount	accounts add: aBankAccount.	aBankAccount basicAddHolder: self.</body><body package="GlorpTestModels" selector="addTransaction:">addTransaction: aTransaction	transactions add: aTransaction.	aTransaction owner: self.</body><body package="GlorpTestModels" selector="id">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels" selector="name">name	"Private - Answer the value of the receiver's ''name'' instance variable."	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	"Private - Set the value of the receiver's ''name'' instance variable to the argument, anObject."	name := anObject</body><body package="GlorpTestModels" selector="removeAccount:">removeAccount: aBankAccount	accounts remove: aBankAccount.	aBankAccount basicRemoveHolder: self.</body><body package="GlorpTestModels" selector="seenPostFetch">seenPostFetch	^seenPostFetch</body><body package="GlorpTestModels" selector="seenPostWrite">seenPostWrite	^seenPostWrite</body><body package="GlorpTestModels" selector="seenPreWrite">seenPreWrite	^seenPreWrite</body><body package="GlorpTestModels" selector="transactions">transactions	"Private - Answer the value of the receiver's ''transactions'' instance variable."	^transactions</body><body package="GlorpTestModels" selector="transactions:">transactions: anObject	"Private - Set the value of the receiver's ''transactions'' instance variable to the argument, anObject."	transactions := anObject</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="accountsSortedById">accountsSortedById	^accountsSortedById.</body><body package="GlorpTestModels" selector="accountsSortedByIdDescending">accountsSortedByIdDescending	^accountsSortedByIdDescending.</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream 	super printOn: aStream.	aStream		nextPut: $(;		print: id;		nextPut: $,;		nextPutAll: (name ifNil: ['']);		nextPutAll: ')'</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>initialize/release</category><body package="GlorpTestModels" selector="initialize">initialize	transactions := OrderedCollection new.	accounts := OrderedCollection new.	seenExpiry := false.	seenPostFetch := false.	seenPreWrite:= false.	seenPostWrite := false.</body></methods><methods><class-id>Glorp.GlorpCustomer class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		name: 'Fred Flintstone';		addTransaction: GlorpBankTransaction example1;		addTransaction: GlorpBankTransaction example2.</body><body package="GlorpTestModels" selector="example2">example2	^self new          id: 123;		name: 'Fred Flintstone';		addTransaction: GlorpBankTransaction example1;		addTransaction: GlorpBankTransaction example2.</body><body package="GlorpTestModels" selector="exampleD1">exampleD1	^self new		name: 'Fred Flintstone'</body><body package="GlorpTestModels" selector="exampleD2">exampleD2	^self new		name: 'Wilma Flintstone'</body><body package="GlorpTestModels" selector="exampleD3">exampleD3	^self new		name: 'Pebbles Flintstone'</body></methods><methods><class-id>Glorp.GlorpCustomer class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testAutomaticRegistrationOnRead">testAutomaticRegistrationOnRead	| p c |	p := self exampleCustomerProxy.	c := p getValue.	session beginUnitOfWork.	session register: p.	self assert: (session isRegistered: p).	self assert: (session isRegistered: c).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: p).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: c).</body><body package="GlorpDBTests" selector="testCheckIfInstantiationRequiredForDirectMapping">testCheckIfInstantiationRequiredForDirectMapping	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	c1 name: proxy.	session beginUnitOfWork.	session register: c1.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #name.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests" selector="testCheckIfInstantiationRequiredForRelationshipInstantiatedProxy">testCheckIfInstantiationRequiredForRelationshipInstantiatedProxy	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	proxy query: (GlorpQueryStub new session: session; result: 'foo').	proxy session: session.	proxy yourSelf.	c1 accounts: proxy.	session beginUnitOfWork.	session register: c1.	c1 accounts: #().	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests" selector="testCheckIfInstantiationRequiredForRelationshipNoChange">testCheckIfInstantiationRequiredForRelationshipNoChange	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	c1 accounts: proxy.	session beginUnitOfWork.	session privateRegisterAsOld: c1.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests" selector="testCheckIfInstantiationRequiredForRelationshipNoProxy">testCheckIfInstantiationRequiredForRelationshipNoProxy	| c1 mapping |	c1 := GlorpCustomer new.	c1 accounts: #().	session beginUnitOfWork.	session register: c1.	c1 accounts: nil.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests" selector="testCheckIfInstantiationRequiredForRelationshipWithChange">testCheckIfInstantiationRequiredForRelationshipWithChange	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	proxy session: session.	proxy query: (GlorpQueryStub new result: 'foo').	c1 accounts: proxy.	session beginUnitOfWork.	session privateRegisterAsOld: c1.	c1 accounts: #().	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self assert: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests" selector="testCheckIfInstantiationRequiredForToManyRelationshipFromNew">testCheckIfInstantiationRequiredForToManyRelationshipFromNew	"Note that we force the object to be registered as new, just to make absolutely sure it's being treated as a new object."	| c1 proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	proxy session: session.	c1 accounts: proxy.	session beginUnitOfWork.	session privateRegisterAsNew: c1.	self assert: (proxy isInstantiated).</body><body package="GlorpDBTests" selector="testCommitOrderAtSessionLevel">testCommitOrderAtSessionLevel	| tables | 	tables := session tablesInCommitOrder.	tables first name = 'CUSTOMER'.	self unfinished.</body><body package="GlorpDBTests" selector="testOriginalValueFor">testOriginalValueFor	| c1 mapping |	c1 := GlorpCustomer new.	c1 name: 'fred'.	session beginUnitOfWork.	session register: c1.	c1 name: 'barney'.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #name.	self assert: (session privateGetCurrentUnitOfWork originalValueFor: c1 mapping: mapping) = 'fred'.</body><body package="GlorpDBTests" selector="testRollbackOneToManyAfterAdd">testRollbackOneToManyAfterAdd	| customer t1 t2 transList amount |	customer := GlorpCustomer example1.	t1 := customer transactions first.	t2 := customer transactions last.	transList := customer transactions.	amount := t1 amount.	session beginUnitOfWork.	session register: customer.	20 timesRepeat: [customer addTransaction: (GlorpBankTransaction new)].	customer transactions first amount: 65543.	session rollbackUnitOfWork.	self assert: customer transactions == transList.	self assert: customer transactions size = 2.	self assert: customer transactions first == t1.	self assert: customer transactions last == t2.	self assert: t1 amount == amount.</body><body package="GlorpDBTests" selector="testRollbackOneToManyAfterReplace">testRollbackOneToManyAfterReplace	| customer t1 t2 transList |	customer := GlorpCustomer example1.	t1 := customer transactions first.	t2 := customer transactions last.	transList := customer transactions.	session beginUnitOfWork.	session register: customer.	customer transactions: OrderedCollection new.	session rollbackUnitOfWork.	self assert: customer transactions == transList.	self assert: customer transactions size = 2.	self assert: customer transactions first == t1.	self assert: customer transactions last == t2.</body><body package="GlorpDBTests" selector="testRollbackOneToManyProxy">testRollbackOneToManyProxy	| customer t1 t2 transList |	customer := GlorpCustomer example1.	t1 := customer transactions first.	t2 := customer transactions last.	transList := customer transactions.	session beginUnitOfWork.	session register: customer.	customer transactions: OrderedCollection new.	session rollbackUnitOfWork.	self assert: customer transactions == transList.	self assert: customer transactions size = 2.	self assert: customer transactions first == t1.	self assert: customer transactions last == t2.</body><body package="GlorpDBTests" selector="testRollbackOneToManyWithList">testRollbackOneToManyWithList	"Check that dependents aren't being registered for the collection"	| customer marker |	"Lists only exist in VW"	Dialect isVisualWorks ifFalse: [^self].	marker := Object new.	customer := GlorpCustomer example1.	customer transactions: (customer transactions asList).	customer transactions addDependent: marker.	session beginUnitOfWork.	session register: customer.	20 timesRepeat: [customer addTransaction: (GlorpBankTransaction new)].	session rollbackUnitOfWork.	self assert: customer transactions class == (Dialect smalltalkAt: #List).	self assert: customer transactions size = 2.	self should: [customer transactions privateAt: 3] raise: Object subscriptOutOfBoundsSignal.	self assert: (customer transactions dependents includes: marker).	self deny: (session isRegistered: marker).</body><body package="GlorpDBTests" selector="testRollbackOneToOne">testRollbackOneToOne	| transaction customer |	transaction := GlorpBankTransaction new.	customer := GlorpCustomer new.	transaction owner: customer.	session beginUnitOfWork.	session register: transaction.	transaction owner: GlorpCustomer new.	session rollbackUnitOfWork.	self assert: transaction owner == customer.</body><body package="GlorpDBTests" selector="testRollbackOneToOneWithProxy">testRollbackOneToOneWithProxy	| transaction customerProxy |	transaction := self exampleTransactionWithCustomerProxy.	customerProxy := transaction owner.	session beginUnitOfWork.	session register: transaction.	transaction owner: GlorpCustomer new.	session rollbackUnitOfWork.	self assert: transaction owner == customerProxy</body><body package="GlorpDBTests" selector="testWriteObjectWithNilCollection">testWriteObjectWithNilCollection	| c1 query customer |	c1 := GlorpCustomer new.	c1 transactions: nil.	c1 id: 9999.	[session beginTransaction.	session beginUnitOfWork.	session register: c1.	session commitUnitOfWork.	query := Query returningOneOf: GlorpCustomer where: [:each | each id = 9999].	query shouldRefresh: true.	customer := session execute: query.	self assert: customer transactions notNil.	self assert: customer transactions isEmpty.	]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>support</category><body package="GlorpDBTests" selector="exampleCustomerProxy">exampleCustomerProxy	| p |	p := Proxy new.	p session: session.	p query: (GlorpQueryStub returningOneOf: GlorpCustomer where: [:a | a id = 3]).	p query result: (GlorpCustomer new id: 3).	^p</body><body package="GlorpDBTests" selector="exampleCustomerWithTransactionsProxy">exampleCustomerWithTransactionsProxy	| customer |	customer := GlorpCustomer new.	customer transactions: self exampleTransactionsProxy.	^customer</body><body package="GlorpDBTests" selector="exampleTransactionWithCustomerProxy">exampleTransactionWithCustomerProxy	| transaction |	transaction := GlorpBankTransaction example1.	transaction owner: self exampleCustomerProxy.	^transaction</body><body package="GlorpDBTests" selector="exampleTransactionsProxy">exampleTransactionsProxy	| p |	p := Proxy new.	p session: session.	p query: (GlorpQueryStub returningOneOf: GlorpBankTransaction where: [:a | a id ~= 0]).	p query result: (Array with: GlorpBankTransaction example1 with: GlorpBankTransaction example1).	^p</body><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session reset.	session resetPermissions.	session := nil.</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests-transaction wrappers</category><body package="GlorpDBTests" selector="testInTransactionDoSuccessful">testInTransactionDoSuccessful	"This has to test that a transaction completed successfully, so unlike most other tests, we have to clean up the evidence afterwards"	| result endResult |	[session inTransactionDo: [		session writeRow: session system exampleAddressRow].	result := session readManyOf: GlorpAddress.	self assert: result size = 1.	self assert: result first id = 123]		ensure: [session inTransactionDo: [session accessor executeSQLStringNoResult: 'DELETE FROM GR_ADDRESS']].	endResult := session readManyOf: GlorpAddress.	self assert: endResult size = 0.</body><body package="GlorpDBTests" selector="testInTransactionDoUnsuccessful">testInTransactionDoUnsuccessful	| result initial|	initial := session readManyOf: GlorpAddress.	self assert: initial isEmpty.	[session inTransactionDo: [		session writeRow: session system exampleAddressRow.		self error: 'no you don''t']] on: Dialect error do: [:ex | ex return: nil].	result := session readManyOf: GlorpAddress.	self assert: result size = 0.</body><body package="GlorpDBTests" selector="testTransactSuccessful">testTransactSuccessful	"This has to test that a transaction completed successfully, so unlike most other tests, we have to clean up the evidence afterwards"	| result |	[session transact: [		session register: (GlorpReservation new id: 345)].	result := session readManyOf: GlorpReservation.	self assert: result size = 1.	self assert: result first id = 345]		ensure: [session transact: [session accessor executeSQLStringNoResult: 'DELETE FROM RESERVATION']].</body><body package="GlorpDBTests" selector="testTransactUnsuccessful">testTransactUnsuccessful	| result |	[session transact: [		session register: (GlorpReservation new id: 345).		self error: 'didn''t work']] on: Dialect error do: [:ex | ex return: nil].	result := session readManyOf: GlorpReservation.	self assert: result size = 0.</body><body package="GlorpDBTests" selector="testinUnitOfWorkSuccessful">testinUnitOfWorkSuccessful	| result |	[session beginTransaction.	session inUnitOfWorkDo: [		session register: (GlorpReservation new id: 345)].	result := session readManyOf: GlorpReservation.	self assert: result size = 1.	self assert: result first id = 345]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testinUnitOfWorkUnsuccessful">testinUnitOfWorkUnsuccessful	| result |	[session beginTransaction.	[session inUnitOfWorkDo: [		session register: (GlorpReservation new id: 345).		self error: 'aaaagh']] on: Dialect error do: [:ex | ex return: nil].	result := session readManyOf: GlorpReservation.	self assert: result size = 0]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests-registration</category><body package="GlorpDBTests" selector="testPostRegister">testPostRegister	| c1 t1 t2 |	c1 := GlorpCustomer example2.	[session beginTransaction.	session beginUnitOfWork.	t1 := GlorpBankTransaction new.	t2 := GlorpBankTransaction new.	c1 addTransaction: t1.	c1 addTransaction: t2.	session register: c1.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: t1).	self assert: (session isRegistered: t2).	session commitUnitOfWork]		ensure: [session rollbackTransaction].	"Need some assertions on what was written"	self unfinished.</body><body package="GlorpDBTests" selector="testPreRegister">testPreRegister		| c1 t1 t2 trans |	c1 := GlorpCustomer example2.	[session beginTransaction.	session beginUnitOfWork.	session register: c1.	t1 := GlorpBankTransaction new.	t2 := GlorpBankTransaction new.	c1 addTransaction: t1.	c1 addTransaction: t2.	trans := session privateGetCurrentUnitOfWork privateGetTransaction.	session commitUnitOfWork.	self assert: (trans isRegistered: c1).	self assert: (trans isRegistered: t1).	self assert: (trans isRegistered: t2).]		ensure: [session rollbackTransaction].	"Need some assertions on what got written"	self unfinished.</body><body package="GlorpDBTests" selector="testRegisterAll">testRegisterAll	| c1 c2 collection |	c1 := GlorpCustomer new.	c2 := GlorpCustomer new.	session beginUnitOfWork.	collection := Array with: c1 with: c2.	session registerAll: collection.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: c2).	self deny: (session isRegistered: collection).</body><body package="GlorpDBTests" selector="testRegisterCollection">testRegisterCollection	| c1 c2 collection |	c1 := GlorpCustomer new.	c2 := GlorpCustomer new.	session beginUnitOfWork.	collection := Array with: c1 with: c2.	session register: collection.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: collection).</body><body package="GlorpDBTests" selector="testRegisterEmbeddedInTargetDontRefetch">testRegisterEmbeddedInTargetDontRefetch	" This tests for a problem with embedded objects suddenly becoming nil. This can happen when an object is part of a to-many relation. If the relation is followed during the registering phase the query will wrongly replace the embedded object even though requiresPopulating is false. When the object itself is already registered the replaced embedded object won't be registered."	| transactionId customer |		[session beginTransaction.	session inUnitOfWorkDo: 			[customer := GlorpCustomer example1.			customer id: 42.			session register: customer].	transactionId := customer transactions first id.	customer := nil.	session initializeCache.	session inUnitOfWorkDo: 			[| transaction amount |			transaction := session readOneOf: GlorpBankTransaction						where: [:each | each id = transactionId].			amount := transaction amount.			transaction owner transactions getValue.			self assert: amount == transaction amount]] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testRegisterExistingCollection">testRegisterExistingCollection	| c1 |	c1 := GlorpCustomer new.	session beginUnitOfWork.	session register: c1.	session register: c1 transactions.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: c1 transactions).	self deny: (session isNew: c1 transactions).</body><body package="GlorpDBTests" selector="testRegisterInstantiatedProxy">testRegisterInstantiatedProxy	| p c |	p := self exampleCustomerProxy.	c := p getValue.	session beginUnitOfWork.	session register: p.	self assert: (session isRegistered: p).	self assert: (session isRegistered: c).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: p).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: c).</body><body package="GlorpDBTests" selector="testRegisterObjectWithCollectionProxyThenInstantiate">testRegisterObjectWithCollectionProxyThenInstantiate	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| customer transactions |	customer := self exampleCustomerWithTransactionsProxy.	session beginUnitOfWork.	session privateRegisterAsOld: customer.	self deny: customer transactions isInstantiated.	transactions := customer transactions getValue.	self assert: customer transactions isInstantiated.	session register: transactions.	self assert: (session isRegistered: transactions first).	self assert: (session isRegistered: customer).	self assert: (session isRegistered: transactions).	self assert: (session isRegistered: customer transactions).</body><body package="GlorpDBTests" selector="testRegisterObjectWithInstantiatedProxy">testRegisterObjectWithInstantiatedProxy	| transaction customer |	transaction := self exampleTransactionWithCustomerProxy.	customer := transaction owner getValue.	session beginUnitOfWork.	session register: transaction.	self assert: (session isRegistered: transaction).	self assert: (session isRegistered: customer).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: customer).	self assert: transaction owner isInstantiated.</body><body package="GlorpDBTests" selector="testRegisterObjectWithNilCollection">testRegisterObjectWithNilCollection	| c1 |	c1 := GlorpCustomer new.	c1 transactions: nil.	session beginUnitOfWork.	session register: c1.	self assert: (session isRegistered: c1).</body><body package="GlorpDBTests" selector="testRegisterObjectWithProxy">testRegisterObjectWithProxy	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| transaction |	transaction := self exampleTransactionWithCustomerProxy.	session beginUnitOfWork.	session privateRegisterAsOld: transaction.	self assert: (session isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self deny: transaction owner isInstantiated.</body><body package="GlorpDBTests" selector="testRegisterObjectWithProxyThenInstantiate">testRegisterObjectWithProxyThenInstantiate	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| transaction customer |	transaction := self exampleTransactionWithCustomerProxy.	session beginUnitOfWork.	session privateRegisterAsOld: transaction.	self deny: transaction owner isInstantiated.	customer := transaction owner getValue.	session register: transaction.	self assert: (session isRegistered: transaction).	self assert: (session isRegistered: customer).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: customer).	self assert: transaction owner isInstantiated</body><body package="GlorpDBTests" selector="testRegisterObjectWithProxyThenInstantiateAndReregister">testRegisterObjectWithProxyThenInstantiateAndReregister	| transaction customer |	transaction := self exampleTransactionWithCustomerProxy.	session beginUnitOfWork.	session register: transaction.	customer := transaction owner getValue.	session register: transaction.	self assert: (session isRegistered: transaction).	self assert: (session isRegistered: customer).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: customer).	self assert: transaction owner isInstantiated</body><body package="GlorpDBTests" selector="testRegisterProxy">testRegisterProxy	| p |	p := self exampleCustomerProxy.	session beginUnitOfWork.	session register: p.	self deny: (session isRegistered: p).	self deny: (session isRegistered: p query result).	p getValue.	self assert: (session isRegistered: p).	self assert: (session isRegistered: p query result).</body><body package="GlorpDBTests" selector="testRegisterProxyThenInstantiateAndReregister">testRegisterProxyThenInstantiateAndReregister	| p c |	p := self exampleCustomerProxy.	session beginUnitOfWork.	session register: p.	c := p getValue.	session register: p.	self assert: (session isRegistered: p).	self assert: (session isRegistered: c).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: p).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: c)</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests-forcing update</category><body package="GlorpDBTests" selector="testRegisteringAndForcingUpdate">testRegisteringAndForcingUpdate	"Test that we can force the first customer to be rewritten, even if it hasn't been modified by using the forceSaveOf: call"	| customer triedToWrite row table map otherCustomer |	session beginTransaction.	customer := GlorpCustomer example1 id: 7.	otherCustomer := GlorpCustomer example2 id: 8.	session modify: (Array with: customer with: otherCustomer) in: [].	session accessor denyWrites.	session modify: customer in: [].	session beginUnitOfWork.	session register: otherCustomer.	session save: customer.	[session commitUnitOfWork] on: GlorpIllegalCommand do: [:ex |		triedToWrite := true.		table := session system tableNamed: 'GR_CUSTOMER'.		map := session privateGetCurrentUnitOfWork privateGetRowMap subMapForTable: table.		row := map at: map keys asArray first.		self assert: (row at: row fields first) = 7.		self assert: (row at: row fields last) = 'Fred Flintstone'.		self assert: map size = 1.	].	self assert: triedToWrite.	session rollbackTransaction.</body><body package="GlorpDBTests" selector="testRegisteringAndForcingUpdateToDatabase">testRegisteringAndForcingUpdateToDatabase	"Test going round trip to the database with forceSaveOf:. This odesn't assert much, but is mostly to make sure we aren't doing an insert instead of an update."	| customer otherCustomer |	session beginTransaction.	customer := GlorpCustomer example1 id: 7.	otherCustomer := GlorpCustomer example2 id: 8.	session modify: (Array with: customer with: otherCustomer) in: [].	session inUnitOfWorkDo: [		session register: otherCustomer.		session save: customer].	session rollbackTransaction.</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpLineWorker</class-id> <category>accessing</category><body package="GlorpTestModels" selector="productionLine">productionLine	^productionLine</body><body package="GlorpTestModels" selector="productionLine:">productionLine: anObject	productionLine := anObject</body></methods><methods><class-id>Glorp.GlorpLineWorker</class-id> <category>comparing</category><body package="GlorpTestModels" selector="=">= aLineWorker	^super = aLineWorker and: [productionLine = aLineWorker productionLine].</body></methods><methods><class-id>Glorp.GlorpTreeNode</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="children">children	^children.</body><body package="GlorpTestModels" selector="children:">children: aCollection	children := aCollection.</body><body package="GlorpTestModels" selector="id">id	^id.</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger.</body><body package="GlorpTestModels" selector="initialize">initialize	children := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpTreeNode</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	aStream nextPutAll: 'Node('.	id printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpTreeNode class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpProxyEqualityTest</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="setUp">setUp 	super setUp. 	session := GlorpSessionResource current newSession.	proxy := Proxy new.	proxy session: session.	stub := GlorpQueryStub returningOneOf: GlorpAddress where: [:address | address id = 1].	stub result: 'abc'.	proxy query: stub.	proxy parameters: #().	proxy2 := Proxy new.	proxy2 session: session.	stub2 := GlorpQueryStub returningOneOf: GlorpAddress where: [:address | address id = 1].	stub2 result: 'abc'.	proxy2 query: stub2.	proxy2 parameters: #().</body><body package="GlorpTestModels" selector="setUp2">setUp2	proxy query result: 'def'</body><body package="GlorpTestModels" selector="testEquality">testEquality	self assert: proxy = proxy2.</body><body package="GlorpTestModels" selector="testEquality2">testEquality2	self assert: proxy2 = proxy.</body><body package="GlorpTestModels" selector="testEqualityFailing">testEqualityFailing	self setUp2.	self deny: proxy = proxy2.</body><body package="GlorpTestModels" selector="testEqualityFailing2">testEqualityFailing2	self setUp2.	self deny: proxy2 = proxy.</body><body package="GlorpTestModels" selector="testInequality">testInequality	self setUp2.	self deny: proxy = proxy2.</body><body package="GlorpTestModels" selector="testInequality2">testInequality2	self setUp2.	self deny: proxy2 = proxy.</body><body package="GlorpTestModels" selector="testInequalityFailing">testInequalityFailing	self deny: proxy ~= proxy2.</body><body package="GlorpTestModels" selector="testInequalityFailing2">testInequalityFailing2	self deny: proxy2 ~= proxy.</body></methods><methods><class-id>Glorp.GlorpProxyEqualityTest class</class-id> <category>Accessing</category><body package="GlorpTestModels" selector="resources">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosCollectionTest</class-id> <category>tests</category><body package="GlorpTestModels" selector="createRowMap">createRowMap	rowMap := RowMapForMementos withCorrespondenceMap: transaction undoMap.	rowMap collectionMementos: transaction collectionMementos.	newCollection := rowMap collectionMementoFor: collection.</body><body package="GlorpTestModels" selector="testArray">testArray	collection := Array with: 1 with: 2 with: 3 with: 4.	copy := collection copy.	transaction register: collection.	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection = copy.	self deny: newCollection = collection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels" selector="testDictionary">testDictionary	collection := Dictionary new.	1 to: 50 do: [:i | collection at: i put: i printString].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection removeKey: i].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection size = copy size.	self assert: newCollection keys asSortedCollection = copy keys asSortedCollection.	self assert: newCollection values asSortedCollection = copy values asSortedCollection.	self deny: newCollection values asSortedCollection = collection values asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels" selector="testIdentityDictionary">testIdentityDictionary	collection := IdentityDictionary new.	1 to: 50 do: [:i | collection at: i put: i printString].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection removeKey: i].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection size = copy size.	self assert: newCollection keys asSortedCollection = copy keys asSortedCollection.	self assert: newCollection values asSortedCollection = copy values asSortedCollection.	self deny: newCollection values asSortedCollection = collection values asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels" selector="testOrderedCollection">testOrderedCollection	collection := (1 to: 50) asOrderedCollection.	copy := collection copy.	transaction register: collection.	12 timesRepeat: [collection removeLast].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection = copy.	self deny: newCollection = collection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels" selector="testOrderedSet">testOrderedSet	collection := (Dialect smalltalkAt: #OrderedSet ifAbsent: [^self]) new.	1 to: 50 do: [:i | collection add: i].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection remove: i].	collection add: 999.	self createRowMap.	self assert: newCollection asSortedCollection = copy asSortedCollection.	self deny: newCollection asSortedCollection = collection asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels" selector="testRBSmallDictionary">testRBSmallDictionary	collection := (Dialect smalltalkAt: #RBSmallDictionary ifAbsent: [^self]) new.	1 to: 50 do: [:i | collection at: i put: i printString].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection removeKey: i].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection size = copy size.	self assert: newCollection keys asSortedCollection = copy keys asSortedCollection.	self assert: newCollection values asSortedCollection = copy values asSortedCollection.	self deny: newCollection values asSortedCollection = collection values asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels" selector="testSet">testSet	collection := (1 to: 50) asSet.	copy := collection copy.	transaction register: collection.	1 to: 12 do: [:i | collection remove: i].	collection add: 'hello'.	self createRowMap.	self assert: newCollection asSortedCollection = copy asSortedCollection.	self deny: newCollection size = collection size		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosCollectionTest</class-id> <category>support</category><body package="GlorpTestModels" selector="setUp">setUp	transaction := ObjectTransaction new.	rowMap := nil.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionTest</class-id> <category>support</category><body package="GlorpTests" selector="customerStream">customerStream	| rows |	rows := #( ( 1 'Alan' ) (2 'Bob')).	^ReadStream on: rows.</body><body package="GlorpTests" selector="joinedStream">joinedStream	| rows |	rows := #( ( 1 'Alan' 101 101 '1st Avenue' 111) (2 'Bob' 102 102 '2nd Avenue' 222) ).	^ReadStream on: rows.</body><body package="GlorpTests" selector="joinedStream2">joinedStream2	| rows |	rows := #( (1 'Alan' 101 101 '1st Avenue' 111  ) (2 'Bob' 102 102 '2nd Avenue' 222  ) ).	^ReadStream on: rows.</body><body package="GlorpTests" selector="joinedStreamToMany">joinedStreamToMany	| rows |	rows := #( (1 'Alan' 101  7 'root' 'foo.com' )  (1 'Alan' 101  8 'root' 'bar.com' )  ).	^ReadStream on: rows.</body><body package="GlorpTests" selector="joinedStreamToMany3">joinedStreamToMany3	| rows |	rows := #( 			(1 'Alan' 1 '001' '001'  '123' 1 1 #CDN 1.5 'stuff' #CDN 1)  			(1 'Alan' 1 '001' '001'  '123' 2 1  #USD 1.5 'stuff' #USD 1) 			(1 'Alan' 2 '002' '002'  '234' 3 1  #CHF 1.5 'stuff' #CHF 1)			(1 'Alan' 2 '002' '002'  '234' 4 1  #EUR 1.5 'stuff' #EUR 1) ).	^ReadStream on: rows.</body><body package="GlorpTests" selector="mockStream">mockStream	| rows |	rows := #( ( 1 'Alan' 101) (2 'Bob' 102) (3 'Carol' 103)).	^ReadStream on: rows.</body><body package="GlorpTests" selector="mockStream2">mockStream2	| rows |	rows := #( ( 4 'David' 104) (5 'Evan' 105)).	^ReadStream on: rows.</body><body package="GlorpTests" selector="setUp">setUp	| query |	super setUp.	session := GlorpSessionResource current newSession.	((session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #name) shouldProxy: false.	query := Query readManyOf: GlorpPerson.	query session: session.	query prepare.	stream := GlorpCursoredStream on: self mockStream for: (query sqlWith: nil) accessor: nil.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionTest</class-id> <category>tests</category><body package="GlorpTests" selector="testBuilderIsolation">testBuilderIsolation	"Make sure that we can have multiple streams open simultaneously against the same query"	| stream2 person1 stream3 person4 person4a |	stream2 := GlorpCursoredStream on: self mockStream2 for: stream command.	stream3 := GlorpCursoredStream on: self mockStream2 for: stream command.	person1 := stream next.	person4 := stream2 next.	person4a := stream3 next.	self assert: person4 == person4a.	self assert: person4 id = 4.	self assert: person1 id = 1.	self assert: stream next id = 2.	self assert: person4a id = 4.</body><body package="GlorpTests" selector="testCollect">testCollect	self assert: (stream collect: [:each | each name]) = #('Alan' 'Bob' 'Carol').</body><body package="GlorpTests" selector="testKnittingWithAlsoFetch">testKnittingWithAlsoFetch	| query person1 person2 |	query := Query readManyOf: GlorpPerson.	query session: session.	query alsoFetch: [:each | each address].	query prepare.	stream := GlorpCursoredStream on: self joinedStream2 for: (query sqlWith: nil).	person1 := stream next.	self assert: session privateGetCache numberOfElements = 2.	self assert: person1 address street = '1st Avenue'.	person2 := stream next.	self assert: session privateGetCache numberOfElements = 4.	self assert: stream atEnd.	self assert: person2 id = 2.	self assert: person2 address street = '2nd Avenue'.	self assert: session privateGetCache numberOfElements = 4.</body><body package="GlorpTests" selector="testKnittingWithAlsoFetchDoubleToMany">testKnittingWithAlsoFetchDoubleToMany	| query customer1 |	query := Query readManyOf: GlorpCustomer.	query session: session.	query alsoFetch: [:each | each accounts].	query alsoFetch: [:each | each transactions].	query prepare.	stream := GlorpCursoredStream on: self joinedStreamToMany3 for: (query sqlWith: #()).	customer1 := stream next.	self assert: session privateGetCache numberOfElements = 7.	self assert: stream atEnd.	self assert: customer1 id = 1.	self assert: customer1 accounts size = 2.	self assert: customer1 accounts first accountNumber accountNumber = '123'.	self assert: customer1 accounts last accountNumber accountNumber = '234'.</body><body package="GlorpTests" selector="testKnittingWithAlsoFetchToManyInSingleGroup">testKnittingWithAlsoFetchToManyInSingleGroup	| query person1 |	query := Query readManyOf: GlorpPerson.	query session: session.	query alsoFetch: [:each | each emailAddresses].	query prepare.	stream := GlorpCursoredStream on: self joinedStreamToMany for: (query sqlWith: #()).	person1 := stream next.	self assert: session privateGetCache numberOfElements = 3.	self assert: (person1 emailAddresses allSatisfy: [:each | each user = 'root']).	self assert: person1 emailAddresses first ~= person1 emailAddresses last.	self assert: stream atEnd.</body><body package="GlorpTests" selector="testKnittingWithRetrieve">testKnittingWithRetrieve	| query tuple person1 address1 person2 address2 |	query := Query readManyOf: GlorpPerson.	query session: session.	query retrieve: [:each | each].	query retrieve: [:each | each address].	query prepare.	stream := GlorpCursoredStream on: self joinedStream for: (query sqlWith: nil).	tuple := stream next.	self assert: session privateGetCache numberOfElements = 2.	person1 := tuple first.	address1 := tuple last.	self assert: address1 street = '1st Avenue'.	self assert: person1 address == address1.	tuple := stream next.	self assert: stream atEnd.	person2 := tuple first.	address2 := tuple last.	self assert: person2 id = 2.	self assert: address2 street = '2nd Avenue'.	self assert: person2 address == address2.</body><body package="GlorpTests" selector="testNext">testNext	| person |	person := stream next.	self assert: person class == GlorpPerson.	self assert: person id = 1.	self assert: person name = 'Alan'.	self assert: session privateGetCache numberOfElements = 1.	person := stream next.	self assert: person id = 2.	self assert: person name = 'Bob'.	self assert: session privateGetCache numberOfElements = 2.	stream next.	self assert: stream atEnd.	self assert: stream next = nil.</body><body package="GlorpTests" selector="testNextColon">testNextColon	| people |	people := stream next: 2.	self assert: people size = 2.	self assert: people first id = 1.	self assert: people first name = 'Alan'.	self assert: session privateGetCache numberOfElements = 2.	self assert: people last id = 2.</body><body package="GlorpTests" selector="testPostFetchEvents">testPostFetchEvents	| query customer |	query := Query readManyOf: GlorpCustomer.	query session: session.	query prepare.	stream := GlorpCursoredStream on: self customerStream for: (query sqlWith: #()).	customer := stream next.	self assert: customer seenPostFetch.</body><body package="GlorpTests" selector="testReadEmpty">testReadEmpty	stream := GlorpCursoredStream on: (ReadStream on: #()) for: (stream query sqlWith: #()).	self assert: stream atEnd.	self assert: stream next isNil.</body><body package="GlorpTests" selector="testRegistration">testRegistration	| person |	session beginUnitOfWork.	person := stream next.	self assert: (session isRegistered: person).</body><body package="GlorpTests" selector="testRelease">testRelease	| person |	stream next.	stream release.	self assert: stream atEnd.	self assert: stream next isNil.</body><body package="GlorpTests" selector="testUpToEnd">testUpToEnd	| people |	people := stream upToEnd.	self assert: people size = 3.	self assert: people first name = 'Alan'.	self assert: people last name = 'Carol'.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionTest class</class-id> <category>resources</category><body package="GlorpTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpAirline</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: aString	name := aString</body></methods><methods><class-id>Glorp.GlorpAirline class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		id: 73;		name: 'Air Canada'.</body><body package="GlorpTestModels" selector="example2">example2	^self new		id: 74;		name: 'Lufthansa'.</body></methods><methods><class-id>Glorp.GlorpTestsPackage class</class-id> <category>instance creation</category><body package="GlorpTests" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.GlorpDeleteInUnitOfWorkTest</class-id> <category>As yet unclassified</category><body package="GlorpTests" selector="system">system	^unitOfWork session system.</body><body package="GlorpTests" selector="tableNamed:">tableNamed: aString 	^self system tableNamed: aString.</body></methods><methods><class-id>Glorp.GlorpDeleteInUnitOfWorkTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	| session |	session := GlorpMockSession new.	session beginUnitOfWork.	unitOfWork := session privateGetCurrentUnitOfWork.	session system: (GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database)</body><body package="GlorpTests" selector="tearDown">tearDown	unitOfWork := nil.</body></methods><methods><class-id>Glorp.GlorpDeleteInUnitOfWorkTest</class-id> <category>tests</category><body package="GlorpTests" selector="testCommit">testCommit	unitOfWork delete: GlorpAddress example1.	unitOfWork commit.	self assert: (unitOfWork numberOfRows) = 1.</body><body package="GlorpTests" selector="testDeleteRegistration">testDeleteRegistration	| obj |	obj := Object new.	unitOfWork delete: obj.	self assert: (unitOfWork willDelete: obj).	self deny: (unitOfWork willDelete: 3).</body><body package="GlorpTests" selector="testDeletesComeAfterUpdates">testDeletesComeAfterUpdates	unitOfWork delete: GlorpAddress example1.	unitOfWork register: GlorpCustomer example1.	unitOfWork commit.	self assert: unitOfWork session rows last table == (self tableNamed: 'GR_ADDRESS').</body><body package="GlorpTests" selector="testDeletesInReverseOrder">testDeletesInReverseOrder	"Not that good a test, because it could be luck with only two tables. Should test this at a lower level"	| cust trans |	cust := GlorpCustomer example2.	trans := cust transactions first.	"We need to give it a primary key or else the delete logic fails"	trans id: 42.	unitOfWork delete: cust.	unitOfWork delete: trans.	unitOfWork commit.	self assert: unitOfWork session rows last owner == cust.	self assert: (unitOfWork session rows reverse at: 2) owner == trans.</body><body package="GlorpTests" selector="testGeneratingDeleteRows">testGeneratingDeleteRows	unitOfWork delete: GlorpAddress example1.	unitOfWork createRows.	self assert: unitOfWork privateGetRowMap numberOfEntries = 1.	unitOfWork rowsForTable: (self tableNamed: 'GR_ADDRESS')		do: [:each | self assert: each forDeletion]</body></methods><methods><class-id>Glorp.IdentityHashPrintingObject</class-id> <category>printing</category><body package="GlorpTests" selector="printOn:">printOn: aStream	aStream nextPutAll: 'thing with hash '.	self identityHash printOn: aStream.</body></methods><methods><class-id>Glorp.TestCommandPermission</class-id> <category>tests</category><body package="GlorpDBTests" selector="testAlsoDeny">testAlsoDeny	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyCommand: InsertCommand.	session accessor alsoDenyCommand: DeleteCommand.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testDenyReads">testDenyReads	| person address |	[session beginTransaction.	self writeTestRows.	person := session readOneOf: GlorpPerson where: nil.	address := person address yourSelf.	session accessor denyReads.	self should: [session readOneOf: GlorpPerson where: nil] raise: GlorpIllegalCommand.	session inUnitOfWorkDo: [		session register: person.		session delete: address.		person address: (GlorpAddress new id: 7).		person name: 'Quigley Quagmire']]	ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testForbiddenDelete">testForbiddenDelete	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyCommand: DeleteCommand.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person address.					person address: nil]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testForbiddenDeleteAllowsUpdateAndInsert">testForbiddenDeleteAllowsUpdateAndInsert	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyCommand: DeleteCommand.	person := session readOneOf: GlorpPerson where: nil.	session inUnitOfWorkDo: [		session register: person.		person address: (GlorpAddress new id: 7).		person name: 'Quigley Quagmire']]	ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testInsertOnlyAllowsInsert">testInsertOnlyAllowsInsert	| person |	[session beginTransaction.	self writeTestRows.	session accessor insertOnly.	person := session readOneOf: GlorpPerson where: nil.	session		inUnitOfWorkDo:			[session register: person.			session register: (GlorpPerson new id: 4)]]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testInsertOnlyForbidsDelete">testInsertOnlyForbidsDelete	| person |	[session beginTransaction.	self writeTestRows.	session accessor insertOnly.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testInsertOnlyForbidsUpdate">testInsertOnlyForbidsUpdate	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					person name: 'Quigley Quagmire']]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testPermitEverything">testPermitEverything	session accessor permitEverything.	[session beginTransaction.	self writeTestRows.	session inUnitOfWorkDo: [ | person |		person := session readOneOf: GlorpPerson where: nil.		session delete: person address.		person address: (GlorpAddress new id: 7).		person name: 'Quigley Quagmire']]	ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testPermitNothing">testPermitNothing	session accessor permitNothing.	self should: [session readManyOf: GlorpPerson] raise: GlorpIllegalCommand.	self		should:			[session accessor executeCommand: InsertCommand new]		raise: GlorpIllegalCommand.	self		should:			[session accessor executeCommand: UpdateCommand new]		raise: GlorpIllegalCommand.	self		should:			[session accessor executeCommand: DeleteCommand new]		raise: GlorpIllegalCommand.	self		should:			[session accessor				executeCommand: SQLStringSelectCommand new]		raise: GlorpIllegalCommand.</body><body package="GlorpDBTests" selector="testReadOnlyForbidsDelete">testReadOnlyForbidsDelete	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadOnlyForbidsInsert">testReadOnlyForbidsInsert	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					person address: (GlorpAddress new id: 7)]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadOnlyForbidsUpdate">testReadOnlyForbidsUpdate	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					person name: 'Quigley Quagmire']]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.TestCommandPermission</class-id> <category>support</category><body package="GlorpDBTests" selector="writeTestRows">writeTestRows	| addressRow personRow |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	personRow := session system examplePersonRow1.	session writeRow: personRow.</body></methods><methods><class-id>Glorp.GlorpTravelAgency</class-id> <category>comparing</category><body package="GlorpTestModels" selector="=">= aGlorpTravelAgency	^self name = aGlorpTravelAgency name.</body></methods><methods><class-id>Glorp.GlorpTravelAgency</class-id> <category>accessing</category><body package="GlorpTestModels" selector="agents">agents	^agents</body><body package="GlorpTestModels" selector="agents:">agents: anObject	agents := anObject</body><body package="GlorpTestModels" selector="name">name	^name</body><body package="GlorpTestModels" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpSelectCommandTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testExecute">testExecute	| command dict result string |	dict := #('abc' 'Smalltalk').	string := session useBinding		ifTrue: ['SELECT ID FROM STUFF WHERE THING=? OR THING = ?']		ifFalse:			['SELECT ID FROM STUFF WHERE THING=''abc'' OR THING = ''Smalltalk'''].	command := SQLStringSelectCommand		sqlString: string		parameters: dict		useBinding: session useBinding		session: session.	result := session accessor executeCommand: command.	self assert: result size = 2.	self assert: result first first = 12.	self assert: result last first = 113141.</body></methods><methods><class-id>Glorp.GlorpTransformedFieldValueWrapperTest</class-id> <category>tests</category><body package="GlorpTests" selector="testPrivateSetOuter">testPrivateSetOuter	self deny: inner hasValue.	self deny: outer hasValue.	outer privateSetContents: 8.	self assert: outer contents = 8.	self assert: inner contents = 4.	self assert: inner hasValue.	self assert: outer hasValue.</body><body package="GlorpTests" selector="testSetInner">testSetInner	self deny: inner hasValue.	self deny: outer hasValue.	inner contents: 3.	self assert: outer contents = 6.	self assert: inner contents = 3.	self assert: inner hasValue.	self assert: outer hasValue.</body><body package="GlorpTests" selector="testSetOuter">testSetOuter	self deny: inner hasValue.	self deny: outer hasValue.	outer contents: 8.	self assert: outer contents = 8.	self assert: inner contents = 4.	self assert: inner hasValue.	self assert: outer hasValue.</body><body package="GlorpTests" selector="testSetOuterFails">testSetOuterFails	self deny: inner hasValue.	self deny: outer hasValue.	outer contents: 8.	self should: [outer contents: 9] raise: Dialect error.	self assert: outer contents = 8.	self assert: inner contents = 4.	self assert: inner hasValue.	self assert: outer hasValue.</body></methods><methods><class-id>Glorp.GlorpTransformedFieldValueWrapperTest</class-id> <category>accessing</category><body package="GlorpTests" selector="inner">inner	^inner</body><body package="GlorpTests" selector="inner:">inner: aFieldValueWrapper	inner := aFieldValueWrapper</body><body package="GlorpTests" selector="outer">outer	^outer</body><body package="GlorpTests" selector="outer:">outer: aTransformingFieldValueWrapper	outer := aTransformingFieldValueWrapper</body></methods><methods><class-id>Glorp.GlorpTransformedFieldValueWrapperTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	inner := FieldValueWrapper new.	outer := TransformingFieldValueWrapper new innerWrapper: inner; forwardTransformation: [:a | a * 2]; inverseTransformation: [:a | a / 2].</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections</class-id> <category>accessing</category><body package="GlorpCollectionTypeModels" selector="array">array	^array</body><body package="GlorpCollectionTypeModels" selector="array:">array: anObject	array := anObject</body><body package="GlorpCollectionTypeModels" selector="bag">bag	^bag</body><body package="GlorpCollectionTypeModels" selector="bag:">bag: anObject	bag := anObject</body><body package="GlorpCollectionTypeModels" selector="id">id	^id</body><body package="GlorpCollectionTypeModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpCollectionTypeModels" selector="name">name	^name</body><body package="GlorpCollectionTypeModels" selector="name:">name: anObject	name := anObject</body><body package="GlorpCollectionTypeModels" selector="orderedCollection">orderedCollection	^orderedCollection</body><body package="GlorpCollectionTypeModels" selector="orderedCollection:">orderedCollection: anObject	orderedCollection := anObject</body><body package="GlorpCollectionTypeModels" selector="set">set	^set</body><body package="GlorpCollectionTypeModels" selector="set:">set: anObject	set := anObject</body><body package="GlorpCollectionTypeModels" selector="sortedCollection">sortedCollection	^sortedCollection</body><body package="GlorpCollectionTypeModels" selector="sortedCollection:">sortedCollection: anObject	sortedCollection := anObject</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections</class-id> <category>initialize-release</category><body package="GlorpCollectionTypeModels" selector="initialize"> initialize	array := #().	orderedCollection := OrderedCollection new.	set := Set new.	bag := Bag new.	sortedCollection := #() asSortedCollection.</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections class</class-id> <category>instance creation</category><body package="GlorpCollectionTypeModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections class</class-id> <category>examples</category><body package="GlorpCollectionTypeModels" selector="example1">example1	| example array |	example := self new.	example name: 'fred'.	array := Array with: (GlorpThingOne named: 'array1') with: (GlorpThingOne named: 'array2') with: (GlorpThingOne named: 'array3').	example array: array.	example set add: (GlorpThingOne named: 'set1').	example set add: (GlorpThingOne named: 'set2').		example orderedCollection add: (GlorpThingOne named: 'orderedCollection1').	example orderedCollection add: (GlorpThingOne named: 'orderedCollection2').	example bag add: (GlorpThingOne named: 'bag1').	example bag add: (GlorpThingOne named: 'bag2').	example sortedCollection add: (GlorpThingOne named: 'sorted1').	example sortedCollection add: (GlorpThingOne named: 'sorted2').	example sortedCollection add: (GlorpThingOne named: 'sorted3').	example sortedCollection add: (GlorpThingOne named: 'sorted4').	^example.</body><body package="GlorpCollectionTypeModels" selector="exampleForOrdering">exampleForOrdering	| example |	example := self new.	example name: 'order'.	example orderedCollection add: (GlorpThingOne named: 'oc6').	example orderedCollection add: (GlorpThingOne named: 'oc5').	example orderedCollection add: (GlorpThingOne named: 'oc4').	example orderedCollection add: (GlorpThingOne named: 'oc3').	example orderedCollection add: (GlorpThingOne named: 'oc7').	example orderedCollection add: (GlorpThingOne named: 'oc8').	example array: (#('a1' 'a2' 'a3' 'a9' 'a8' 'a7') collect: [:each | GlorpThingOne named: each]).	^example</body></methods><methods><class-id>Glorp.GlorpEmailAddress</class-id> <category>accessing</category><body package="GlorpTestModels" selector="host">host	^host</body><body package="GlorpTestModels" selector="host:">host: anObject	host := anObject</body><body package="GlorpTestModels" selector="id">id	^ id</body><body package="GlorpTestModels" selector="id:">id: anInteger	 id := anInteger.</body><body package="GlorpTestModels" selector="user">user	^user</body><body package="GlorpTestModels" selector="user:">user: anObject	user := anObject</body></methods><methods><class-id>Glorp.GlorpEmailAddress</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: id printString.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpObjectTransactionTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	transaction := ObjectTransaction new</body></methods><methods><class-id>Glorp.GlorpObjectTransactionTest</class-id> <category>tests</category><body package="GlorpTests" selector="testArray">testArray	| object |	object := #(1 2 3 4 5) copy.	transaction begin.	transaction register: object.	object		at: 1 put: #one;		at: 2 put: object.	transaction abort.	self		assert: (object at: 1) == 1;		assert: (object at: 2) == 2</body><body package="GlorpTests" selector="testBecome">testBecome	| object |	object := 'hello' copy.	transaction begin.	transaction register: object.	object become: Set new.	transaction abort.	self 		assert: object class == '' class;		assert: object = 'hello'.</body><body package="GlorpTests" selector="testCommit">testCommit	| array |	array := #(1 2 3 4 5) copy.	transaction begin.	transaction register: array.	array		at: 1 put: #one;		at: 2 put: array.	transaction commit.	self		assert: (array at: 1) == #one;		assert: (array at: 2) == array</body><body package="GlorpTests" selector="testHashedCollection">testHashedCollection	| object originalMembers |	object := Set new.	originalMembers := #(#one #two #three 'four' 5 'vi' (1 2 3 4 5 6 7)) collect: [:each | each copy].	object addAll: originalMembers.	transaction begin.	transaction register: object.	object remove: #one; remove: (originalMembers at: 4).	object add: 1.	originalMembers last at: 7 put: 'seven'.	transaction abort.	self		assert: object size = originalMembers size;		assert: (object includes: originalMembers first);		assert: (object includes: (originalMembers at: 4));		assert: object size = (object rehash; size).	originalMembers do: [:each | self assert: (object includes: each)]</body><body package="GlorpTests" selector="testRegisteredObjectsDoRecursively">testRegisteredObjectsDoRecursively	| link |	link := 1 -&gt; (2 -&gt; (3 -&gt; (4 -&gt;5))).	transaction register: link.	self assert: transaction undoMap size = 1.	transaction registeredObjectsDo: [:each |		transaction register: each value].	self assert: transaction undoMap size = 4.</body><body package="GlorpTests" selector="testString">testString	| object |	object := 'Hello, World!' copy.	transaction begin.	transaction register: object.	object		at: 1 put: $h;		at: 2 put: $E.	transaction abort.	self		assert: object first  == $H;		assert: (object at: 2) == $e</body></methods><methods><class-id>Glorp.GlorpExpressionTest</class-id> <category>tests</category><body package="GlorpTests" selector="testAndOperation">testAndOperation	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) &amp; (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #AND.</body><body package="GlorpTests" selector="testAndOperation2">testAndOperation2	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) AND: (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #AND.</body><body package="GlorpTests" selector="testAnySatisfyExists">testAnySatisfyExists	| expression base |	system useJoinsForAnySatisfy: false.	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	expression := [:a | a items anySatisfy: [:each | each id = 7]] asGlorpExpressionOn: base.	self assert: expression class == SubSelectExpression.</body><body package="GlorpTests" selector="testAnySatisfyJoin">testAnySatisfyJoin	| expression base |	system useJoinsForAnySatisfy: true.	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	expression := [:a | a items anySatisfy: [:each | each id = 7]] asGlorpExpressionOn: base.	self assert: expression class == CollectionExpression.	self assert: expression leftChild == expression rightChild leftChild base.</body><body package="GlorpTests" selector="testAnySatisfyPrintExists">testAnySatisfyPrintExists	| expression |	system useJoinsForAnySatisfy: false.	expression := [:cust | cust transactions anySatisfy: [:each | each id = 7]] 				asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	self assert: (' EXISTS (SELECT s1t1.ID&lt;n&gt; FROM BANK_TRANS s1t1&lt;n&gt; WHERE *s1t1.ID = ?* AND *s1t2.ID = s1t1.OWNER_ID)*' expandMacros match: expression sqlString).</body><body package="GlorpTests" selector="testAnySatisfyPrintJoin">testAnySatisfyPrintJoin	| expression |	system useJoinsForAnySatisfy: true.	expression := [:cust | cust transactions anySatisfy: [:each | each id = 7]] 				asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	self assert: '(BANK_TRANS.ID = 7)' equalsIgnoringOuterBrackets: expression sqlString.</body><body package="GlorpTests" selector="testBetweenAnd">testBetweenAnd	| expression base |	base := BaseExpression new.	expression := [:a | a between: 3 and: 4] asGlorpExpressionOn: base.	self assert: expression class == InfixFunction.	self assert: expression name = 'BETWEEN AND'.	self assert: (expression arguments collect: [:each | each value]) = (Array with: 3 with: 4).</body><body package="GlorpTests" selector="testEqualityOperation">testEqualityOperation	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | a firstName = fred] asGlorpExpressionOn: base.	self assert: expression leftChild == (base get: #firstName).	self assert: expression rightChild class == ConstantExpression.	self assert: expression rightChild value == fred.	self assert: expression relation == #=</body><body package="GlorpTests" selector="testFindingMapping">testFindingMapping	| base baseDescriptor |	baseDescriptor := system descriptorFor: GlorpBankTransaction.	base := BaseExpression new descriptor: baseDescriptor.	self assert: (base get: #serviceCharge) mapping == (baseDescriptor mappingForAttributeNamed: #serviceCharge).	self assert: (base get: #serviceCharge) sourceDescriptor == (system descriptorFor: GlorpBankTransaction).	self assert: (base get: #serviceCharge) descriptor == (system descriptorFor: GlorpServiceCharge)</body><body package="GlorpTests" selector="testGetField">testGetField	| expression |	expression := [:cust | cust getField: 'ID'] asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	self assert: expression sqlString = 'GR_CUSTOMER.ID'.	self assert: expression class = FieldExpression.	self assert: expression field table = (system tableNamed: 'GR_CUSTOMER').</body><body package="GlorpTests" selector="testGetFieldAmbiguous">testGetFieldAmbiguous	| |	self 		should: [[:pass | pass getField: 'ID']			asGlorpExpressionForDescriptor: (system descriptorFor: GlorpPassenger)]		raise: Dialect error.</body><body package="GlorpTests" selector="testGetFieldFromSecondaryTable">testGetFieldFromSecondaryTable	| expression |	expression := [:pass | pass getField: 'POINTS']		asGlorpExpressionForDescriptor: (system descriptorFor: GlorpPassenger).	self assert: expression sqlString = 'FREQUENT_FLYER.POINTS'.	self assert: expression class = FieldExpression.	self assert: expression field table = (system tableNamed: 'FREQUENT_FLYER').</body><body package="GlorpTests" selector="testJoinOperation">testJoinOperation	| userExpression base expression addressTable personTable query field1 field2 join |	addressTable := system tableNamed: 'GR_ADDRESS'.	personTable := system tableNamed: 'PERSON'.	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpPerson).	userExpression := [:aPerson | aPerson address number = 12] 				asGlorpExpressionOn: base.	query := SimpleQuery returningOneOf: GlorpPerson where: userExpression.	query session: (GlorpSession new system: system).	self assert: (userExpression additionalExpressionsIn: query) size = 1.	query prepare.	expression := query whereClause.	self assert: query joins size = 1.	join := query joins first.	self		assert: expression == userExpression;		assert: expression relation == #=.	field1 := join leftChild field.	self assert: field1 table parent == personTable.	self assert: field1 name = 'ADDRESS_ID'.	field2 := join rightChild field.	self assert: field2 table parent == addressTable.	self assert: field2 name = 'ID'.</body><body package="GlorpTests" selector="testMappingBase">testMappingBase	| base |	base := BaseExpression new.	self assert: (base get: #someAttribute) base == base</body><body package="GlorpTests" selector="testMappingExpressionIdentity">testMappingExpressionIdentity 	self assertIdentityOf: [:a | a someAttribute] and: [:a | a someAttribute].</body><body package="GlorpTests" selector="testMappingExpressionIdentity2">testMappingExpressionIdentity2	self assertIdentityOf: [:a | a perform: #someAttribute] and: [:a | a someAttribute].</body><body package="GlorpTests" selector="testMappingExpressionIdentity3">testMappingExpressionIdentity3	self assertIdentityOf: [:a | a get: #someAttribute] and: [:a | a someAttribute].</body><body package="GlorpTests" selector="testMappingExpressionIdentity4">testMappingExpressionIdentity4	self denyIdentityOf: [:a | a get: #someAttribute] and: [:a | a someOtherAttribute].</body><body package="GlorpTests" selector="testOrOperation">testOrOperation	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) | (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #OR.</body><body package="GlorpTests" selector="testOrOperation2">testOrOperation2	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) OR: (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #OR.</body><body package="GlorpTests" selector="testTwoLevelMappingExpressionIdentity">testTwoLevelMappingExpressionIdentity	self assertIdentityOf: [:a | a someAttribute someAttribute] and: [:a | a someAttribute someAttribute].	self denyIdentityOf: [:a | a someAttribute someAttribute] and: [:a | a someAttribute].</body></methods><methods><class-id>Glorp.GlorpExpressionTest</class-id> <category>support</category><body package="GlorpTests" selector="assertIdentityOf:and:">assertIdentityOf: aBlock and: anotherBlock	 	| base |	base := BaseExpression new.	self assert: (aBlock asGlorpExpressionOn: base) == (anotherBlock asGlorpExpressionOn: base)</body><body package="GlorpTests" selector="denyIdentityOf:and:">denyIdentityOf: aBlock and: anotherBlock 	| base |	base := BaseExpression new.	self deny: (aBlock asGlorpExpressionOn: base) == (anotherBlock asGlorpExpressionOn: base)</body></methods><methods><class-id>Glorp.GlorpExpressionTest</class-id> <category>As yet unclassified</category><body package="GlorpTests" selector="testIsNullPrint">testIsNullPrint	| expression stream |	expression := [:cust | cust id = nil]		asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	stream := DatabaseCommand new session: system session.	expression printSQLOn: stream withParameters: Dictionary new.	self assert: '(GR_CUSTOMER.ID IS NULL)' equalsIgnoringOuterBrackets: expression sqlString.</body><body package="GlorpTests" selector="testNotNullPrint">testNotNullPrint	| expression stream |	expression := [:cust | cust id ~= nil]		asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	stream := DatabaseCommand new session: system session.	expression printSQLOn: stream withParameters: Dictionary new.	self assert: '(GR_CUSTOMER.ID IS NOT NULL)' equalsIgnoringOuterBrackets: stream contents.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>printing</category><body package="GlorpTests" selector="printOn:">printOn: aStream	aStream nextPut: $(.	id printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>relationships</category><body package="GlorpTests" selector="relateTo:">relateTo: anItem	relatedItems add: anItem.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>accessing</category><body package="GlorpTests" selector="id">id	^id</body><body package="GlorpTests" selector="id:">id: anObject	id := anObject</body><body package="GlorpTests" selector="parent">parent	^parent</body><body package="GlorpTests" selector="parent:">parent: anObject	parent := anObject</body><body package="GlorpTests" selector="relatedItems">relatedItems	^relatedItems</body><body package="GlorpTests" selector="relatedItems:">relatedItems: aCollection	relatedItems := aCollection</body><body package="GlorpTests" selector="status">status	^status</body><body package="GlorpTests" selector="status:">status: aSymbol	status := aSymbol</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>initialize-release</category><body package="GlorpTests" selector="initialize">initialize	relatedItems := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem class</class-id> <category>instance creation</category><body package="GlorpTests" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-read</category><body package="GlorpDBTests" selector="checkNumberOfAccounts:">checkNumberOfAccounts: anInteger	| accountRows |	accountRows := session accessor		executeSQLString: 'SELECT * FROM BANK_ACCT'.	self assert: accountRows size = anInteger.</body><body package="GlorpDBTests" selector="checkNumberOfLinkRows:">checkNumberOfLinkRows: anInteger	| linkRows |	linkRows := session accessor		executeSQLString: 'SELECT * FROM CUSTOMER_ACCT_LINK'.	self assert: linkRows size = anInteger.</body><body package="GlorpDBTests" selector="testReadCustomerAndAddAccount">testReadCustomerAndAddAccount	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [customer addAccount: (GlorpBankAccount new id: 77473)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId3 := 77473.			self checkAccounts.			self checkNumberOfLinkRows: 4].</body><body package="GlorpDBTests" selector="testReadCustomerAndDeleteAccount">testReadCustomerAndDeleteAccount	self		inTransactionDo:[			[self 				inUnitOfWorkDo: [ | account| 					account := customer accounts detect: [:each | each id = 9874].					session delete: account]				initializeWith: [self writeCustomerWithAccounts]]				on: Dialect error				do: [:ex | Transcript show: 'integrity violation'; cr.^self].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 2].</body><body package="GlorpDBTests" selector="testReadCustomerAndDeleteAccountProperly">testReadCustomerAndDeleteAccountProperly	"Do both the delete and the patching up of relationships"	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [ | account| 					account := customer accounts detect: [:each | each id = 9874].					session delete: account.					customer removeAccount: account]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 2].</body><body package="GlorpDBTests" selector="testReadCustomerAndRemoveAccount">testReadCustomerAndRemoveAccount	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := customer accounts detect: [:each | each id = 9874].					customer accounts remove: account]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2].</body><body package="GlorpDBTests" selector="testReadCustomerAndReplaceAccounts">testReadCustomerAndReplaceAccounts	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := GlorpBankAccount new id: 99999.					customer accounts do: [:each | each accountHolders remove: customer].					customer accounts: (Array with: account)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := 99999.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 4].</body><body package="GlorpDBTests" selector="testReadCustomerAndReplaceAccountsWithRemoval">testReadCustomerAndReplaceAccountsWithRemoval	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := customer accounts detect: [:each | each id = 6].					customer accounts: (Array with: account)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2].</body><body package="GlorpDBTests" selector="testReadCustomerAndReplaceAccountsWithoutInstantiatingHolders">testReadCustomerAndReplaceAccountsWithoutInstantiatingHolders	"This works, but only fortuitously. If the accounts haven't been read into memory, we don't have to remove their object-level references to the account holder, because changing one side of the relationship in memory is enough to cause the link rows to be deleted"	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := GlorpBankAccount new id: 99999.					customer accounts: (Array with: account)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := 99999.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 4].</body><body package="GlorpDBTests" selector="testReadCustomerAndReplaceInstantiatedAccountsWithEmpty">testReadCustomerAndReplaceInstantiatedAccountsWithEmpty	self		inTransactionDo:			[self				inUnitOfWorkDo:					[customer accounts yourSelf. 					customer accounts: #()]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := nil.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 1.			self checkNumberOfAccounts: 3].</body><body package="GlorpDBTests" selector="testReadCustomerAndReplaceUninstantiatedAccountsWithEmpty">testReadCustomerAndReplaceUninstantiatedAccountsWithEmpty	self		inTransactionDo:			[self				inUnitOfWorkDo:					[customer accounts: #()]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := nil.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 1.			self checkNumberOfAccounts: 3].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-write</category><body package="GlorpDBTests" selector="testWriteCustomerWithAccounts">testWriteCustomerWithAccounts	| newCustomer |	self		inTransactionDo:			[self writeCustomerWithAccounts.			session beginUnitOfWork.			newCustomer := GlorpCustomer example1.			newCustomer id: 12.			customerId := 12.			newCustomer accounts: (OrderedCollection with: (GlorpBankAccount new id: 223)).			session register: newCustomer.			session commitUnitOfWork.			session reset.			self readCustomer.			accountId1 := 223.			accountId2 := nil.			self checkAccounts.			self checkNumberOfAccounts: 4.			self checkNumberOfLinkRows: 4].</body><body package="GlorpDBTests" selector="testWriteCustomerWithNoAccounts">testWriteCustomerWithNoAccounts	| newCustomer |	self		inTransactionDo:			[session beginUnitOfWork.			newCustomer := GlorpCustomer example1.			newCustomer id: 12.			customerId := 12.			session register: newCustomer.			session commitUnitOfWork.			session reset.			self readCustomer.			accountId1 := nil.			accountId2 := nil.			self checkAccounts.			self checkNumberOfAccounts: 0.			self checkNumberOfLinkRows: 0].</body><body package="GlorpDBTests" selector="testWriteCustomerWithTwoAccounts">testWriteCustomerWithTwoAccounts	| newCustomer |	self		inTransactionDo:			[self writeCustomerWithAccounts.			session beginUnitOfWork.			newCustomer := GlorpCustomer example1.			newCustomer id: 12.			customerId := 12.			newCustomer accounts: (OrderedCollection with: (GlorpBankAccount new id: 223)).			newCustomer accounts add: (GlorpBankAccount new id: 224).			session register: newCustomer.			session commitUnitOfWork.			session reset.			self readCustomer.			accountId1 := 223.			accountId2 := 224.			self checkAccounts.			self checkNumberOfAccounts: 5.			self checkNumberOfLinkRows: 5].</body><body package="GlorpDBTests" selector="testWriteCustomersAndAccounts">testWriteCustomersAndAccounts	| newCustomer1 newCustomer2 newCustomer3 joint withBaby1 withBaby2 hisChecking herChecking |	self		inTransactionDo:			[			session beginUnitOfWork.			newCustomer1 := GlorpCustomer exampleD1.			newCustomer2 := GlorpCustomer exampleD2.			newCustomer3 := GlorpCustomer exampleD3.			hisChecking := GlorpBankAccount new id: 301.			herChecking := GlorpBankAccount new id: 302.			joint := GlorpBankAccount new id: 303.			withBaby1 := GlorpBankAccount new id: 304.			withBaby2 := GlorpBankAccount new id: 305.			newCustomer1 id: 201; accounts: (OrderedCollection with: hisChecking with: joint with: withBaby1).			newCustomer2 id: 202; accounts: (OrderedCollection with: herChecking with: joint with: withBaby2).			newCustomer3 id: 203; accounts: (OrderedCollection with: withBaby1 with: withBaby2).			session register: newCustomer1;				register: newCustomer2;				register: newCustomer3.			session commitUnitOfWork.			session reset.			newCustomer1 := self readCustomer: 201.			self assert: newCustomer1 accounts size = 3.			newCustomer2 := self readCustomer: 202.			self assert: newCustomer2 accounts size = 3.			newCustomer3 := self readCustomer: 203.			self assert: newCustomer3 accounts size = 2.			self checkNumberOfAccounts: 5.			self checkNumberOfLinkRows: 8].</body><body package="GlorpDBTests" selector="testWriteCustomersAndAccountsAndDelete">testWriteCustomersAndAccountsAndDelete	| newCustomer1 newCustomer2 newCustomer3 joint withBaby1 withBaby2 hisChecking herChecking |	self		inTransactionDo:			[			session beginUnitOfWork.			newCustomer1 := GlorpCustomer exampleD1.			newCustomer2 := GlorpCustomer exampleD2.			newCustomer3 := GlorpCustomer exampleD3.			hisChecking := GlorpBankAccount new id: 301.			herChecking := GlorpBankAccount new id: 302.			joint := GlorpBankAccount new id: 303.			withBaby1 := GlorpBankAccount new id: 304.			withBaby2 := GlorpBankAccount new id: 305.			newCustomer1 id: 201; accounts: (OrderedCollection with: hisChecking with: joint with: withBaby1).			newCustomer2 id: 202; accounts: (OrderedCollection with: herChecking with: joint with: withBaby2).			newCustomer3 id: 203; accounts: (OrderedCollection with: withBaby1 with: withBaby2).			session register: newCustomer1;				register: newCustomer2;				register: newCustomer3.			session commitUnitOfWork.			session reset.			newCustomer1 := self readCustomer: 201.			self assert: newCustomer1 accounts size = 3.			newCustomer2 := self readCustomer: 202.			self assert: newCustomer2 accounts size = 3.			newCustomer3 := self readCustomer: 203.			self assert: newCustomer3 accounts size = 2.			self checkNumberOfAccounts: 5.			self checkNumberOfLinkRows: 8.			session reset.				session transact: [ | cust acct |						cust := self readCustomer: 201.				acct := cust accounts detect: [:ea| ea id = 301] ifNone: [nil].				acct notNil ifTrue: [session delete: acct].				session delete: cust].			self checkNumberOfAccounts: 4.			self checkNumberOfLinkRows: 5].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-join</category><body package="GlorpDBTests" selector="testReadCustomerOrderByLinkTableField">testReadCustomerOrderByLinkTableField	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session readManyOf: GlorpCustomer.			customers do: [:each | | sortedAccounts |				sortedAccounts := each accounts asSortedCollection: [:a :b | a id &lt;= b id].				self assert: each accountsSortedById asArray = sortedAccounts asArray]].</body><body package="GlorpDBTests" selector="testReadCustomerOrderByLinkTableFieldDescending">testReadCustomerOrderByLinkTableFieldDescending	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session readManyOf: GlorpCustomer.			customers do: [:each | | sortedAccounts |				sortedAccounts := each accounts asSortedCollection: [:a :b | a id &lt;= b id].				self assert: each accountsSortedByIdDescending asArray = sortedAccounts asArray reverse]].</body><body package="GlorpDBTests" selector="testReadCustomerWithJoinToAccounts">testReadCustomerWithJoinToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyJoin: [:eachAccount | eachAccount accountNumber bankCode = '2']].			self assert: customers size = 2].</body><body package="GlorpDBTests" selector="testReadCustomerWithJoinToAccounts2">testReadCustomerWithJoinToAccounts2	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyJoin: [:eachAccount | eachAccount accountNumber branchNumber = 3]].			self assert: customers size = 1].</body><body package="GlorpDBTests" selector="testReadCustomerWithSimpleJoinToAccounts">testReadCustomerWithSimpleJoinToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyJoin: [:eachAccount | eachAccount id &lt;&gt; 12]].			self assert: customers size = 2].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="checkAccounts">checkAccounts	| sorted numberOfAccounts |	numberOfAccounts := (accountId1 isNil ifTrue: [0] ifFalse: [1]) + (accountId2 isNil ifTrue: [0] ifFalse: [1]) + (accountId3 isNil ifTrue: [0] ifFalse: [1]).	self assert: customer accounts size = numberOfAccounts.	sorted := customer accounts asSortedCollection: [:a :b | a id &lt;= b id].	accountId1 isNil ifFalse: [self assert: sorted first id = accountId1].	accountId2 isNil ifFalse: [self assert: (sorted at: 2) id = accountId2].	accountId3 isNil ifFalse: [self assert: sorted last id = accountId3].	self assert: (customer accounts collect: [:each | each id]) asSet size = customer accounts size.</body><body package="GlorpDBTests" selector="inUnitOfWorkDo:initializeWith:">inUnitOfWorkDo: aBlock initializeWith: initBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	initBlock value.	session beginUnitOfWork.	self readCustomer.	aBlock value.	session commitUnitOfWork.	session reset.</body><body package="GlorpDBTests" selector="readCustomer">readCustomer	| results query |	query := Query		returningManyOf: GlorpCustomer		where: [:cust | cust id = customerId].	results := query executeIn: session.	self assert: results size = 1.	customer := results first.</body><body package="GlorpDBTests" selector="readCustomer:">readCustomer: aCustomerId	| results query |	query := Query		returningManyOf: GlorpCustomer		where: [:cust | cust id = aCustomerId].	results := query executeIn: session.	self assert: results size = 1.	^results first.</body><body package="GlorpDBTests" selector="writeCustomerWithAccounts">writeCustomerWithAccounts	| customerRow accountRow1 accountRow2 linkRow1 linkRow2 customerRow2 accountRow3 linkRow3 |	customerRow := session system exampleCustomerRow1.	customerId := customerRow atFieldNamed: 'ID'.	customerRow2 := session system exampleCustomerRow2.	accountRow1 := session system exampleAccountRow1. 	accountId2 := accountRow1 atFieldNamed: 'ID'.	accountRow2 := session system exampleAccountRow2.	accountId1 := accountRow2 atFieldNamed: 'ID'.	accountRow3 := session system exampleAccountRow3.	linkRow1 := session system exampleCALinkRow1.	linkRow2 := session system exampleCALinkRow2.	linkRow3 := session system exampleCALinkRow3.	session writeRow: customerRow.	session writeRow: customerRow2.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: accountRow3.	session writeRow: linkRow1.	session writeRow: linkRow2.	session writeRow: linkRow3.</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-nodes</category><body package="GlorpDBTests" selector="testReadAndDeleteNodes">testReadAndDeleteNodes	"Make sure we don't delete out of order and that links disappear."	| nodes links |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		session transact: [			nodes := session read: GlorpTreeNode.			nodes do: [:each | session delete: each]].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 0].</body><body package="GlorpDBTests" selector="testReadNode">testReadNode	| allNodes |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		allNodes := session readManyOf: GlorpTreeNode orderBy: #id.		self assert: (allNodes collect: [:each | each id]) asArray = #( 1 2 3).		self assert: allNodes first children size = 2.		self assert: (allNodes first children collect: [:each | each id]) asSortedCollection asArray = #( 2 3)].</body><body package="GlorpDBTests" selector="testReadNodeAndDeleteChild">testReadNodeAndDeleteChild	| node1 node3 links nodes |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		node1 := session readOneOf: GlorpTreeNode where: [:each | each id = 1].		node3 := (node1 children asSortedCollection: [:a :b | a id &lt;= b id]) last.		session transact: [			session register: node1.			session delete: node3.			node1 children remove: node3].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 1.		self assert: links first first = 1. 		self assert: links first last = 2.		nodes := session accessor executeSQLString: 'SELECT * FROM TREE_NODE'.		self deny: (nodes anySatisfy: [:each | each first = node3 id]).		self assert: nodes size = 2		].</body><body package="GlorpDBTests" selector="testReadNodeAndDeleteChildWithSaveAndContinue">testReadNodeAndDeleteChildWithSaveAndContinue	"This exercises two things. First, there's a bug in save and continue with deleted objects resurrecting. Second, make sure that if we delete both parent and child, the link goes away"	| node1 node3 links nodes node2 |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		node1 := session readOneOf: GlorpTreeNode where: [:each | each id = 1].		node2 := (node1 children asSortedCollection: [:a :b | a id &lt;= b id]) first.		node3 := (node1 children asSortedCollection: [:a :b | a id &lt;= b id]) last.		session beginUnitOfWork.			[session register: node1.			session delete: node3.			node1 children remove: node3] ensure: [session saveAndContinue].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 1.		self assert: links first first = 1. 		self assert: links first last = 2.		nodes := session accessor executeSQLString: 'SELECT * FROM TREE_NODE'.		self deny: (nodes anySatisfy: [:each | each first = node3 id]).		self assert: nodes size = 2.			[session register: node1.			session delete: node2.			session delete: node1] ensure: [session saveAndContinue].		nodes := session accessor executeSQLString: 'SELECT * FROM TREE_NODE'.		self assert: nodes isEmpty.		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links isEmpty.		].</body><body package="GlorpDBTests" selector="testReadNodeAndDeleteParent">testReadNodeAndDeleteParent	| node1 links |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		session transact: [		node1 := session readOneOf: GlorpTreeNode where: [:each | each id = 1].		session delete: node1.		node1 children: #()].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 0].</body><body package="GlorpDBTests" selector="treeNodeClass">treeNodeClass	treeNodeClass isNil ifTrue: [treeNodeClass := GlorpTreeNode].	^treeNodeClass.</body><body package="GlorpDBTests" selector="treeNodeClass:">treeNodeClass: aClass	treeNodeClass := aClass.</body><body package="GlorpDBTests" selector="writeNodeWithChildren">writeNodeWithChildren	| node1 node2 node2a |	node1 := self treeNodeClass new id: 1.	node2 := self treeNodeClass new id: 2.	node2a := self treeNodeClass new id: 3.	node1 children add: node2.	node1 children add: node2a.	session inUnitOfWorkDo: [session register: node1].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-subselect</category><body package="GlorpDBTests" selector="testReadCustomerOrderingByCountSubselect">testReadCustomerOrderingByCountSubselect	"DB2 (as of 9.8) does not support an ORDER BY clause with correlated column references.	The ORDER BY sub-select here refers back to the selected column, so we skip this for DB2."	| customers |	session platform isDB2Platform ifTrue: [^self].	self		inTransactionDo:			[| sorted |			self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				orderBy: [:each | each accounts sqlCount].			sorted := (customers asSortedCollection: [:a :b | a accounts size &lt;= b accounts size]) asArray.			self assert: customers = sorted.			customers := session				read: GlorpCustomer				orderBy: [:each | each accounts sqlCount descending].			self assert: customers reverse = sorted].</body><body package="GlorpDBTests" selector="testReadCustomerWithAverageSubselect">testReadCustomerWithAverageSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each average: [:eachCust | eachCust accounts id]) = ((9874 + 6) / 2)].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts id sqlAverage) = 22].		self assert: customers size = 1.		self assert: customers first id = 28.].</body><body package="GlorpDBTests" selector="testReadCustomerWithCountSubselect">testReadCustomerWithCountSubselect	| customersWithOneAccount customersWithTwoAccounts customersWithLessThanFiveAccounts |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customersWithOneAccount := session				read: GlorpCustomer				where:					[:each | 					(each getConstant: 1) = (each count: [:eachCust | eachCust accounts])].			customersWithTwoAccounts := session				read: GlorpCustomer				where:					[:each | 					(each count: [:eachCust | eachCust accounts]) = 2].			"fully general syntax. doesn't require any helper methods, just the existence of the function"			customersWithLessThanFiveAccounts := session				read: GlorpCustomer				where: [:each | (each aggregate: each accounts as: #countStar) &lt; 5].		self assert: customersWithOneAccount size = 1.		self assert: customersWithOneAccount first id = 28.		self assert: customersWithTwoAccounts size = 1.		self assert: customersWithTwoAccounts first id = 27.		self assert: customersWithLessThanFiveAccounts size = 2].</body><body package="GlorpDBTests" selector="testReadCustomerWithCountSubselectAlternateSyntax">testReadCustomerWithCountSubselectAlternateSyntax	| customersWithOneAccount customersWithTwoAccounts |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customersWithOneAccount := session				read: GlorpCustomer				where:					[:each | 					(each getConstant: 1) = (each accounts sqlCount)].			customersWithTwoAccounts := session				read: GlorpCustomer				where:					[:each | 					each accounts sqlCount = 2].		self assert: customersWithOneAccount size = 1.		self assert: customersWithOneAccount first id = 28.		self assert: customersWithTwoAccounts size = 1.		self assert: customersWithTwoAccounts first id = 27].</body><body package="GlorpDBTests" selector="testReadCustomerWithEqualityComparisonToAccountsUsingInClause">testReadCustomerWithEqualityComparisonToAccountsUsingInClause	"Test doing a primary key rewrite of the where clause in a subselect, to the result of another subselect"	| customers accounts |	self		inTransactionDo:			[self writeCustomerWithAccounts.			accounts := session read: GlorpBankAccount where: [:each | each id = 22].			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount in: accounts]].			self assert: customers size = 1.			customers do: [:each | each accounts do: [:eachAcct | self assert: eachAcct id = 22]]].</body><body package="GlorpDBTests" selector="testReadCustomerWithEqualitySubSelectToAccountsUsingInClause">testReadCustomerWithEqualitySubSelectToAccountsUsingInClause	"Test doing a primary key rewrite of the where clause in a subselect, to the result of another subselect"	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount in: (Query read: GlorpBankAccount where: [:accts2 | accts2 id &lt;&gt; 12])]].			self assert: customers size = 2.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | 							eachAccount in: (Query read: GlorpBankAccount where: [:accts2 | accts2 id = 22])]].			self assert: customers size = 1.			customers do: [:each | each accounts do: [:eachAcct | self assert: eachAcct id = 22]]].</body><body package="GlorpDBTests" selector="testReadCustomerWithFilteredSubSelectToAccounts1">testReadCustomerWithFilteredSubSelectToAccounts1	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					(eachCustomer accounts select: [:eachAccount | eachAccount accountNumber bankCode = '2']) sqlCount &gt; 0].			self assert: customers size = 2].</body><body package="GlorpDBTests" selector="testReadCustomerWithFilteredSubSelectToAccounts2">testReadCustomerWithFilteredSubSelectToAccounts2	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					(eachCustomer accounts select: [:eachAccount | eachAccount accountNumber bankCode = '2']) sqlCount &gt; 1].			self assert: customers size = 0].</body><body package="GlorpDBTests" selector="testReadCustomerWithFilteredSubSelectToAccounts3">testReadCustomerWithFilteredSubSelectToAccounts3	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					(eachCustomer accounts select: [:eachAccount | eachAccount id &gt; 5 ]) sqlCount &lt;= 1].			self assert: customers size = 1].</body><body package="GlorpDBTests" selector="testReadCustomerWithFilteredSubSelectToAccountsAndAggregate">testReadCustomerWithFilteredSubSelectToAccountsAndAggregate	"Test with a filtered read to accounts, where we've used an aggregate function to find the customer with the maximum primary key for the given id"	| query |	((session system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts) useFilteredRead.	self		inTransactionDo:			[self writeCustomerWithAccounts.			query := Query readOneOf: GlorpCustomer where: [:each |				| q |				q := Query read: GlorpCustomer where: [:eachPundle |					eachPundle name = 'aCustomer'].				q retrieve: [:x | x id max].				each id = q].			customer := session execute: query.			self assert: customer name = 'aCustomer'.			self assert: (customer accounts collect: [:each | each id]) asSortedCollection asArray = #(6 9874)].</body><body package="GlorpDBTests" selector="testReadCustomerWithIsEmptyAndFilteredSubselectsToAccounts">testReadCustomerWithIsEmptyAndFilteredSubselectsToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | (eachCustomer accounts select: [:each | each id &gt; 30]) isEmpty].			self assert: customers size = 1.			self assert: customers first id = 28].</body><body package="GlorpDBTests" selector="testReadCustomerWithIsEmptySubselectToAccounts1">testReadCustomerWithIsEmptySubselectToAccounts1	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | eachCustomer accounts isEmpty].			self assert: customers size = 0].</body><body package="GlorpDBTests" selector="testReadCustomerWithMaxSubselect">testReadCustomerWithMaxSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each max: [:eachCust | eachCust accounts id]) = 9874].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts id sqlMax) = 22].		self assert: customers size = 1.		self assert: customers first id = 28.].</body><body package="GlorpDBTests" selector="testReadCustomerWithMinSubselect">testReadCustomerWithMinSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each min: [:eachCust | eachCust accounts id]) = 6].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts id sqlMin) = 22].		self assert: customers size = 1.		self assert: customers first id = 28.].</body><body package="GlorpDBTests" selector="testReadCustomerWithNotEmptyAndFilteredSubselectsToAccounts">testReadCustomerWithNotEmptyAndFilteredSubselectsToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | (eachCustomer accounts select: [:each | each id &gt; 30]) notEmpty].			self assert: customers size = 1.			self assert: customers first id = 27].</body><body package="GlorpDBTests" selector="testReadCustomerWithSimpleSubSelectToAccounts">testReadCustomerWithSimpleSubSelectToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount id &lt;&gt; 12]].			self assert: customers size = 2].</body><body package="GlorpDBTests" selector="testReadCustomerWithSubSelectToAccounts">testReadCustomerWithSubSelectToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount accountNumber bankCode = '2']].			self assert: customers size = 2].</body><body package="GlorpDBTests" selector="testReadCustomerWithSubSelectToAccounts2">testReadCustomerWithSubSelectToAccounts2	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount accountNumber branchNumber = 3]].			self assert: customers size = 1].</body><body package="GlorpDBTests" selector="testReadCustomerWithSubSelectToAccountsUsingInClause">testReadCustomerWithSubSelectToAccountsUsingInClause	"Test doing an IN clause with the result of another subselect"	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | 							| q |							q := Query read: GlorpBankAccount where: [:accts2 | accts2 id &lt;&gt; 12].							q retrieve: #id.							eachAccount id in: q]].			self assert: customers size = 2.			customers := session				readManyOf: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | 							| q |							q := Query read: GlorpBankAccount where: [:accts2 | accts2 id = 22].							q retrieve: #id.							eachAccount id in: q]].			self assert: customers size = 1.			customers do: [:each | each accounts do: [:eachAcct | self assert: eachAcct id = 22]].].</body><body package="GlorpDBTests" selector="testReadCustomerWithSumSubselect">testReadCustomerWithSumSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each sum: [:eachCust | eachCust accounts accountNumber branchNumber]) &lt; 6].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts accountNumber branchNumber sqlSum) &gt; 6].		self assert: customers size = 1.		self assert: customers first id = 28.].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>As yet unclassified</category><body package="GlorpDBTests" selector="session:">session: aDatabaseSession	session := aDatabaseSession.</body></methods><methods><class-id>Glorp.GlorpReservation</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anInteger	id := anInteger</body><body package="GlorpTestModels" selector="passenger">passenger	^passenger</body><body package="GlorpTestModels" selector="passenger:">passenger: aPassenger	passenger := aPassenger.	passengers add: aPassenger.</body><body package="GlorpTestModels" selector="passengers">passengers	^passengers</body><body package="GlorpTestModels" selector="passengers:">passengers: aCollection	passengers := aCollection.</body></methods><methods><class-id>Glorp.GlorpReservation</class-id> <category>initialize/release</category><body package="GlorpTestModels" selector="initialize">initialize	passengers := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpReservation class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new		id: 2;		passenger: GlorpPassenger example1.</body><body package="GlorpTestModels" selector="example2">example2	^self new		id: 7;		passenger: GlorpPassenger example2.</body></methods><methods><class-id>Glorp.GlorpReservation class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>tests-ordering</category><body package="GlorpDBTests" selector="helpTestSingleOrderingBy:setup:">helpTestSingleOrderingBy: aBlock setup: setupBlock	| query result realBlock |	query := Query returningManyOf: GlorpAddress.	query orderBy: aBlock.	realBlock := query expressionBlockFor: aBlock.	result := session execute: query.	self verifyOrderFor: result byAttribute: realBlock.</body><body package="GlorpDBTests" selector="testDescendingSingleOrdering">testDescendingSingleOrdering	| query result sortedResult |		query := Query returningManyOf: GlorpAddress where: [:each | each street ~= 'Beta'].	query orderBy: [:each | each street descending].	result := session execute: query.	sortedResult := result 				asSortedCollection: [:a :b | a street &gt; b street].	self assert: sortedResult asArray = result asArray.</body><body package="GlorpDBTests" selector="testDoubleOrderingAddress">testDoubleOrderingAddress	| query |	query := Query returningManyOf: GlorpAddress.	query orderBy: [:each | each street].	query orderBy: [:each | each number].	self validateDoubleOrderFor: query.</body><body package="GlorpDBTests" selector="testMixedDoubleOrderingAddress">testMixedDoubleOrderingAddress	| query |	query := Query returningManyOf: GlorpAddress.	query orderBy: [:each | each street descending].	query orderBy: [:each | each number].	self validateDoubleOrderMixedFor: query.</body><body package="GlorpDBTests" selector="testOrderingByRelatedObjectAttribute">testOrderingByRelatedObjectAttribute	| query result |	query := Query returningManyOf: GlorpPerson.	query orderBy: [:each | each address street].	result := session execute: query.	self verifyOrderFor: result byAttribute: [:each | each address street].</body><body package="GlorpDBTests" selector="testOrderingWithNonEmptyWhereClause">testOrderingWithNonEmptyWhereClause	| query result |	query := Query returningManyOf: GlorpPerson where: [:each | each id ~= 12].	query orderBy: #(#address #street).	result := session execute: query.	self verifyOrderFor: result byAttribute: [:each | each address street].</body><body package="GlorpDBTests" selector="testSingleOrderingAddress1">testSingleOrderingAddress1	self 		helpTestSingleOrderingBy: [:each | each street]		setup: [self writeAddressOrderingRows].</body><body package="GlorpDBTests" selector="testSingleOrderingAddress2">testSingleOrderingAddress2	self 		helpTestSingleOrderingBy: [:each | each number]		setup: [self writeAddressOrderingRows].</body><body package="GlorpDBTests" selector="testSingleOrderingBySymbol">testSingleOrderingBySymbol	self 		helpTestSingleOrderingBy: #street		setup: [self writeAddressOrderingRows].</body><body package="GlorpDBTests" selector="testSymbolsOrderingByRelatedObjectAttribute">testSymbolsOrderingByRelatedObjectAttribute	| query result |	query := Query returningManyOf: GlorpPerson.	query orderBy: #(#address #street).	result := session execute: query.	self verifyOrderFor: result byAttribute: [:each | each address street].</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	session system: (GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database).	session beginTransaction.	self writeAddressDoubleOrderingRows.	self writePersonOrderingRows.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session rollbackTransaction.	session reset.	session := nil.</body><body package="GlorpDBTests" selector="validateDoubleOrderFor:">validateDoubleOrderFor: query 	| result sortedResult |	result := session execute: query.	sortedResult := result asSortedCollection: 					[:a :b | 					a street = b street 						ifTrue: [a number &lt;= b number]						ifFalse: [a street &lt; b street]].	^self assert: sortedResult asArray = result asArray</body><body package="GlorpDBTests" selector="validateDoubleOrderMixedFor:">validateDoubleOrderMixedFor: query 	| result sortedResult |	result := session execute: query.	sortedResult := result asSortedCollection: 					[:a :b | 					a street = b street 						ifTrue: [a number &lt;= b number]						ifFalse: [a street &gt; b street]].	^self assert: sortedResult asArray = result asArray</body><body package="GlorpDBTests" selector="verifyOrderFor:byAttribute:">verifyOrderFor: result byAttribute: aBlock	1 to: result size - 1		do: 			[:i | 			| a b |			a := result at: i.			b := result at: i + 1.			self assert: (aBlock value: a) &lt;= (aBlock value: b)]</body><body package="GlorpDBTests" selector="writeAddressDoubleOrderingRows">writeAddressDoubleOrderingRows	self writeAddressOrderingRows.	session writeRow: session system exampleAddressRowForOrdering4.	session writeRow: session system exampleAddressRowForOrdering5.</body><body package="GlorpDBTests" selector="writeAddressOrderingRows">writeAddressOrderingRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.</body><body package="GlorpDBTests" selector="writePersonOrderingRows">writePersonOrderingRows	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>tests-data reading</category><body package="GlorpDBTests" selector="testReadDataItemsFromEmbeddedObject">testReadDataItemsFromEmbeddedObject	| query result transRow id |	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	id := transRow atFieldNamed: 'ID'.	query := Query returningManyOf: GlorpBankTransaction.	query retrieve: [:each | each id].	query retrieve: [:each | each serviceCharge description].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = (Array with: id with: 'additional overcharge').</body><body package="GlorpDBTests" selector="testReadDistinctIds">testReadDistinctIds	| query result |	query := Query returningManyOf: GlorpPerson.	query retrieve: [:each | each id distinct].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #(86 87 88)).</body><body package="GlorpDBTests" selector="testReadDistinctIdsWithWhereClause">testReadDistinctIdsWithWhereClause	| query result |	query := Query returningManyOf: GlorpPerson.	query retrieve: [:each | each id distinct].	query whereClause: [:each | each id ~= 423421].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #(86 87 88)).</body><body package="GlorpDBTests" selector="testReadDistinctRelatedAttribute">testReadDistinctRelatedAttribute	| query result allStreets |	query := Query returningManyOf: GlorpPerson.	query retrieve: [:each | each address street distinct].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #('Alpha' 'Beta' 'Gamma')).	allStreets := (session readManyOf: GlorpAddress) collect: [:each | each street].	self assert: allStreets size = 5.</body><body package="GlorpDBTests" selector="testReadObjectsAndData">testReadObjectsAndData	| query result tracing addressReadSeparately personReadSeparately |	query := Query returningManyOf: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each id].	tracing retrieve: [:each | each address].	query tracing: tracing.	query orderBy: #id.	result := query executeIn: session.	self assert: result size = 3.	self assert: (result first at: 1) = 86.	self assert: ((result first at: 2) class == GlorpAddress).	self assert: ((result first at: 2) id = 2).	addressReadSeparately := session readOneOf: GlorpAddress where: [:each | each id = 2].	self assert: result first last == addressReadSeparately.	personReadSeparately := session readOneOf: GlorpPerson where: [:each | each id = 86].	self assert: personReadSeparately address yourSelf == result first last.</body><body package="GlorpDBTests" selector="testReadOneWithObjects">testReadOneWithObjects	| query result |	query := Query returningOneOf: GlorpPerson where: [:each | each id = 86].	query retrieve: [:each | each].	query retrieve: [:each | each address].	query orderBy: [:each | each id].	result := query executeIn: session.	self assert: result first id = 86.	self assert: (result first address yourSelf == result last).</body><body package="GlorpDBTests" selector="testReadOnlyPrimaryKeys">testReadOnlyPrimaryKeys	| query result |	query := Query returningManyOf: GlorpPerson.	query retrieve: [:each | each id].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #(86 87 88)).</body><body package="GlorpDBTests" selector="testReadTwoDataItems">testReadTwoDataItems	| query result tracing|	query := Query returningManyOf: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each id].	tracing retrieve: [:each | each name].	query tracing: tracing.	result := query executeIn: session.	self assert: result size = 3.	self assert: (result includes: #(86 'person1')).	self assert: (result includes: #(87 'person2')).	self assert: (result includes: #(88 'person3')).</body><body package="GlorpDBTests" selector="testReadTwoDataItemsFromDifferentObjects">testReadTwoDataItemsFromDifferentObjects	| query result tracing|	query := Query returningManyOf: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each id].	tracing retrieve: [:each | each address street].	query tracing: tracing.	query orderBy: #id.	result := query executeIn: session.	self assert: result size = 3.	self assert: result first = #(86 'Beta').	self assert: (result at: 2) = #(87 'Gamma').	self assert: result last = #(88 'Alpha').</body><body package="GlorpDBTests" selector="testReadTwoObjects">testReadTwoObjects	| query result |	query := Query returningManyOf: GlorpPerson.	query retrieve: [:each | each].	query retrieve: [:each | each address].	query orderBy: [:each | each id].	result := query executeIn: session.	self assert: result size = 3.	self assert: (result first atIndex: 1) id = 86.	self assert: ((result first atIndex: 1) address yourSelf == result first last).</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testCriteriaSetup">testCriteriaSetup	| query |	query := Query returningOneOf: GlorpAddress where: [:each | each id = 12].	query session: session.	query setUpExpressions.	self assert: query whereClause class == RelationExpression.	self assert: query whereClause ultimateBaseExpression descriptor 				== (session descriptorFor: GlorpAddress)</body><body package="GlorpDBTests" selector="testIn">testIn	| query result |		query := Query returningManyOf: GlorpAddress where: [:each | each street in: #('Beta' 'Alpha')].	result := session execute: query.	self assert: (result allSatisfy: [:each | #('Beta' 'Alpha') includes: each street]).	self assert: result size = 4.</body><body package="GlorpDBTests" selector="testInEmpty">testInEmpty	"This test generates an error in DB2 because DB2 claims that IN (NULL) is invalid,	since not even NULL can be IN (NULL) (since NULL isn't equal to itself)."	| query result |	session platform isDB2Platform ifTrue: [^self].	query := Query returningManyOf: GlorpAddress where: [:each | each street in: #()].	result := session execute: query.	self assert: result isEmpty</body><body package="GlorpDBTests" selector="testInInteger">testInInteger	| query result |		query := Query returningManyOf: GlorpAddress where: [:each | each id in: #(1 2)].	result := session execute: query.	self assert: (result allSatisfy: [:each | #(1 2) includes: each id]).	self assert: result size = 2.</body><body package="GlorpDBTests" selector="testInSymbol">testInSymbol	| query result transRow transRow2 |	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.		transRow2 := session system exampleBankTransactionRow2.	session writeRow: transRow2.		query := Query returningManyOf: GlorpBankTransaction where: [:each | each amount currency in: #(#USD #CDN)].	result := session execute: query.	self assert: (result allSatisfy: [:each | each amount currency = #CDN]).	self assert: result size = 1.	query := Query returningManyOf: GlorpBankTransaction where: [:each | each amount currency in: #(#USD #DM)].	result := session execute: query.	self assert: result isEmpty.</body><body package="GlorpDBTests" selector="testLike">testLike	| query result |		query := Query returningManyOf: GlorpAddress where: [:each | each street like: 'Be%'].	result := session execute: query.	self assert: (result allSatisfy: [:each | each street = 'Beta']).	self assert: result size = 3.</body><body package="GlorpDBTests" selector="testReadMultipleObjects">testReadMultipleObjects	| query result tracing addressReadSeparately personReadSeparately allResults |	query := Query returningManyOf: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each ].	tracing retrieve: [:each | each address].	query tracing: tracing.	query orderBy: #id.	allResults := query executeIn: session.	self assert: allResults size = 3.	result := allResults first.	self assert: (result at: 1) id = 86.	self assert: ((result at: 1) class == GlorpPerson).	self assert: (result at: 1) address == (result at: 2).	self assert: ((result at: 2) class == GlorpAddress).	self assert: ((result at: 2) id = 2).	addressReadSeparately := session readOneOf: GlorpAddress where: [:each | each id = 2].	self assert: result last == addressReadSeparately.	personReadSeparately := session readOneOf: GlorpPerson where: [:each | each id = 86].	self assert: personReadSeparately == result first.	self assert: personReadSeparately address yourSelf == result last.</body></methods><methods><class-id>Glorp.GlorpReadQueryTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpVarchar4Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform varchar: 4.</body></methods><methods><class-id>Glorp.GlorpVarchar4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testVarChar4">testVarChar4	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	self helpTestValue: 'abc'.	self helpTestValue: 'abcd'.	stType := Symbol.	self helpTestValue: #abcd.	stType := nil.	self helpTestInvalidValue: 'abcde'.</body></methods><methods><class-id>Glorp.GlorpMockAccessor</class-id> <category>executing</category><body package="GlorpDBTests" selector="basicExecuteSQLString:">basicExecuteSQLString: aString	^ReadStream on: #(#(3)).</body><body package="GlorpDBTests" selector="executeCommand:returnCursor:">executeCommand: aCommand returnCursor: aBoolean	| result |	result := #(#(3)).	^aBoolean ifTrue: [result readStream] ifFalse: [result].</body><body package="GlorpDBTests" selector="executeSQLString:">executeSQLString: aString	^#((3)).</body></methods><methods><class-id>Glorp.GlorpVariableTypeTestSystem</class-id> <category>classes</category><body package="GlorpTestModels" selector="classModelForGlorpGallery:">classModelForGlorpGallery: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #images collectionOf: GlorpImageFile.	"Not a real attribute, but used in our conditional mapping."	aClassModel newAttributeNamed: #imagesLink collectionOf: GlorpImageLink.</body><body package="GlorpTestModels" selector="classModelForGlorpImageFile:">classModelForGlorpImageFile: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #bits type: ByteArray.	(aClassModel newAttributeNamed: #thumbnailBits type: ByteArray) useDirectAccess: false.</body><body package="GlorpTestModels" selector="classModelForGlorpImageLink:">classModelForGlorpImageLink: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #thumbnailBits type: ByteArray.	aClassModel newAttributeNamed: #fullImage type: GlorpImageFile.</body><body package="GlorpTestModels" selector="descriptorForGlorpGallery:">descriptorForGlorpGallery: aDescriptor		| table linkTable imagesConditional |	table := self tableNamed: 'GALLERY'.	linkTable := self tableNamed: 'GALLERY_LINK'.	aDescriptor table: table.	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #name.	imagesConditional := (aDescriptor newMapping: ConditionalToManyMapping)		attributeName: #images;		join: Join new.	imagesConditional		forField: (linkTable fieldNamed: 'LARGE')		attribute: [:object | object isLarge]		if: [:x | x = true]		useMapping:			((imagesConditional newMapping: ToManyMapping)				attributeName: #imagesLink;				useLinkTable;				join:						(Join								from: (table fieldNamed: 'ID')								to: (linkTable fieldNamed: 'GALLERY_ID')								from: 'T'								to: (linkTable fieldNamed: 'LARGE'))).	imagesConditional		otherwise:			((imagesConditional newMapping: ToManyMapping)				attributeName: #images;				useLinkTable;				join:						(Join								from: (table fieldNamed: 'ID')								to: (linkTable fieldNamed: 'GALLERY_ID')								from: 'F'								to: (linkTable fieldNamed: 'LARGE'))).</body><body package="GlorpTestModels" selector="descriptorForGlorpImageFile:">descriptorForGlorpImageFile: aDescriptor		aDescriptor table: 'GLORP_IMAGE_FILE'.	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #title.	aDescriptor directMappingFor: #bits.	aDescriptor directMapping from: #thumbnailBits to: 'THUMBNAIL_BITS'.</body><body package="GlorpTestModels" selector="descriptorForGlorpImageLink:">descriptorForGlorpImageLink: aDescriptor		aDescriptor table: 'GLORP_IMAGE_FILE'.	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #title.	aDescriptor directMapping from: #thumbnailBits to: 'THUMBNAIL_BITS'.	"This is really joining to our own table to get the full version of ourselves"	aDescriptor oneToOneMapping 		attributeName: #fullImage;		join: (Join from: (aDescriptor table fieldNamed: 'ID') to: (aDescriptor table fieldNamed: 'ID')).</body><body package="GlorpTestModels" selector="tableForGALLERY:">tableForGALLERY: aTable	aTable createFieldNamed: 'ID' type: platform serial.	aTable createFieldNamed: 'NAME' type: platform text.</body><body package="GlorpTestModels" selector="tableForGALLERY_LINK:">tableForGALLERY_LINK: aTable	| galleryId imageId |	galleryId := aTable createFieldNamed: 'GALLERY_ID' type: platform integer.	aTable addForeignKeyFrom: galleryId to: ((self tableNamed: 'GALLERY') fieldNamed: 'ID').	imageId := aTable createFieldNamed: 'IMAGE_ID' type: platform integer.	aTable addForeignKeyFrom: imageId to: ((self tableNamed: 'GLORP_IMAGE_FILE') fieldNamed: 'ID').	"Avoid booleans here because they aren't portable"	aTable createFieldNamed: 'LARGE' type: (platform char: 1).</body><body package="GlorpTestModels" selector="tableForGLORP_IMAGE_FILE:">tableForGLORP_IMAGE_FILE: aTable	aTable createFieldNamed: 'ID' type: platform serial.	aTable createFieldNamed: 'TITLE' type: platform text.	aTable createFieldNamed: 'BITS' type: platform blob.	aTable createFieldNamed: 'THUMBNAIL_BITS' type: platform blob.</body></methods><methods><class-id>Glorp.GlorpRowMapTest</class-id> <category>tests</category><body package="GlorpTests" selector="testCollapseMatchingInsertsAndDeletes">testCollapseMatchingInsertsAndDeletes	| c1 key1 key2 row1 remainingRow updates |	c1 := Object new.	key1 := RowMapKey new key1: a1; key2: b1.	key2 := RowMapKey new key1: a1; key2: c1.	row1 := rowMap findOrAddRowForTable: table1 withKey: key1.	row1 atFieldNamed: 'ONE_ID' put: 99.	row1 atFieldNamed: 'OTHER_ID' put: 98.	row1 atFieldNamed: 'KEY' put: 5.	row2 := rowMap findOrAddRowForTable: table1 withKey: key2.	row2 atFieldNamed: 'ONE_ID' put: 99.	row2 atFieldNamed: 'OTHER_ID' put: 14.	row2 atFieldNamed: 'KEY' put: 5.	row1 forDeletion: true.	updates := rowMap collapseMatchingInsertsAndDeletes.	self assert: rowMap numberOfEntries = 1.	self assert: updates size = 1.	self assert: updates asArray first = row2.	remainingRow := rowMap rowForTable: table1 withKey: key2 ifAbsent: [self assert: false].	rowMap rowForTable: table1 withKey: key1 ifPresent: [:shouldntBeThereAnyMore | self assert: false].	self assert: (remainingRow atFieldNamed: 'ONE_ID') = 99.	self assert: (remainingRow atFieldNamed: 'OTHER_ID') = 14.	self assert: (remainingRow atFieldNamed: 'KEY') = 5.	self assert: remainingRow owner = key2.</body><body package="GlorpTests" selector="testCollapseMatchingInsertsAndDeletesWithUnknownFields">testCollapseMatchingInsertsAndDeletesWithUnknownFields	"Check that we throw an error for unknown values in the update row"	| c1 key1 key2 row1 |	c1 := Object new.	key1 := RowMapKey new key1: a1; key2: b1.	key2 := RowMapKey new key1: a1; key2: c1.	row1 := rowMap findOrAddRowForTable: table1 withKey: key1.	row1 atFieldNamed: 'ONE_ID' put: 99.	row1 atFieldNamed: 'OTHER_ID' put: 98.	row1 atFieldNamed: 'KEY' put: 5.	row2 := rowMap findOrAddRowForTable: table1 withKey: key2.	row2 atFieldNamed: 'ONE_ID' put: 99.	row2 atFieldNamed: 'KEY' put: 5.	row1 forDeletion: true.	self should: [rowMap collapseMatchingInsertsAndDeletes] raise: Dialect error.</body><body package="GlorpTests" selector="testRowForTableSingle">testRowForTableSingle	| rowMapKey row |	rowMapKey := RowMapKey new.	rowMapKey key1: a1; key2: b1.	row := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row2 := rowMap rowForTable: table1 withKey: rowMapKey.	self assert: row == row2.</body></methods><methods><class-id>Glorp.GlorpRowMapTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	a1 := IdentityHashPrintingObject new.	b1 := IdentityHashPrintingObject new.	rowMap := RowMap new.	table1 := DatabaseTable new name: 'SomeTable'.	platform := OraclePlatform new.	table1 addField: (DatabaseField named: 'ONE_ID' type: platform integer) bePrimaryKey.	table1 addField: (DatabaseField named: 'OTHER_ID' type: platform integer).	table1 addField: (DatabaseField named: 'KEY' type: platform integer) bePrimaryKey.	row2 := 'row2'.</body></methods><methods><class-id>Glorp.GlorpBankTransaction</class-id> <category>accessing</category><body package="GlorpTestModels" selector="amount">amount	^amount</body><body package="GlorpTestModels" selector="amount:">amount: aGlorpMoney 	amount := aGlorpMoney</body><body package="GlorpTestModels" selector="id">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels" selector="owner">owner	"Private - Answer the value of the receiver's ''owner'' instance variable."	^owner</body><body package="GlorpTestModels" selector="owner:">owner: aCustomer 	owner := aCustomer</body><body package="GlorpTestModels" selector="serviceCharge">serviceCharge	^serviceCharge</body><body package="GlorpTestModels" selector="serviceCharge:">serviceCharge: aServiceCharge 	serviceCharge := aServiceCharge</body></methods><methods><class-id>Glorp.GlorpBankTransaction</class-id> <category>initialize</category><body package="GlorpTestModels" selector="initialize">initialize	amount := GlorpMoney forAmount: 0.	serviceCharge := GlorpServiceCharge default.</body></methods><methods><class-id>Glorp.GlorpBankTransaction class</class-id> <category>examples</category><body package="GlorpTestModels" selector="example1">example1	^self new</body><body package="GlorpTestModels" selector="example2">example2	^self new</body></methods><methods><class-id>Glorp.GlorpBankTransaction class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpExpressionRebuildingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testLoneBase">testLoneBase	original := BaseExpression new.	rebuilt := original rebuildOn: newBase.	self assert: rebuilt == newBase.</body><body package="GlorpTests" selector="testMapping">testMapping	original := [:each | each foo] asGlorpExpression.	rebuilt := original rebuildOn: newBase.	self assert: rebuilt base == newBase.</body><body package="GlorpTests" selector="testRelation">testRelation	original := [:each | each foo bar = each foo bletch] asGlorpExpression.	rebuilt := original rebuildOn: newBase.	self assert: rebuilt ultimateBaseExpression == newBase.	self assert: rebuilt leftChild ultimateBaseExpression == newBase.	self assert: rebuilt rightChild ultimateBaseExpression == newBase.	self assert: rebuilt leftChild base base == newBase.</body></methods><methods><class-id>Glorp.GlorpExpressionRebuildingTest</class-id> <category>tests-outer scope references</category><body package="GlorpTests" selector="testRebuildDoubleInnerScopeNormallyWithExists">testRebuildDoubleInnerScopeNormallyWithExists	original := [:each | 	each foo		anySatisfyExists:			[:eachFoo | eachFoo things anySatisfyExists: [:eachThing | eachThing stuff = each fooThing]]]		asGlorpExpression.	rebuilt := original rebuildOn: newBase.	rebuilt do: [:each | self assert: each ultimateBaseExpression == newBase].</body><body package="GlorpTests" selector="testRebuildDoubleInnerScopeNormallyWithJoins">testRebuildDoubleInnerScopeNormallyWithJoins	original := [:each | 	each foo		anySatisfyJoin:			[:eachFoo | eachFoo things anySatisfyJoin: [:eachThing | eachThing stuff = each fooThing]]]		asGlorpExpression.	rebuilt := original rebuildOn: newBase.	rebuilt do: [:each | self assert: each ultimateBaseExpression == newBase].</body><body package="GlorpTests" selector="testRebuildInnerScopeForSubquery">testRebuildInnerScopeForSubquery	| foo |	original := [:each | each foo anySatisfyJoin: [:eachFoo | eachFoo thing = each fooThing]] asGlorpExpression.	"Just so that it prints distinctively"	original ultimateBaseExpression descriptor: (Descriptor new classModel: (GlorpClassModel for: Object)).	foo := original leftChild.	newBase := SubSelectBaseExpression on: foo.	rebuilt := original rightChild rebuildOn: newBase startingFrom: foo.	self assert: rebuilt leftChild base == newBase.	self assert: rebuilt leftChild ultimateBaseExpression == original ultimateBaseExpression.	self assert: rebuilt rightChild base == original ultimateBaseExpression.</body><body package="GlorpTests" selector="testRebuildInnerScopeNormally">testRebuildInnerScopeNormally	original := [:each | each foo anySatisfy: [:eachFoo | eachFoo thing = each fooThing]]		asGlorpExpression.	rebuilt := original rebuildOn: newBase.	rebuilt do: [:each | self assert: each ultimateBaseExpression == newBase].</body><body package="GlorpTests" selector="testRebuildMappingWithStart">testRebuildMappingWithStart	original := [:each | each foo bar] asGlorpExpression.	rebuilt := original rebuildOn: newBase startingFrom: original base.	self assert: rebuilt base == newBase.</body></methods><methods><class-id>Glorp.GlorpExpressionRebuildingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	newBase := BaseExpression new.</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest</class-id> <category>tests</category><body package="GlorpTests" selector="testExpressionTableAliases">testExpressionTableAliases	query prepare.	newQuery := query copy.	self assert: (self tableAliasesPresentFor: query).	self deny: (self tableAliasesPresentFor: newQuery).</body><body package="GlorpTests" selector="testPreparedness">testPreparedness	self deny: query isPrepared.	query prepare.	newQuery := query copy.	self assert: query isPrepared.	self deny: newQuery isPrepared.</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest</class-id> <category>As yet unclassified</category><body package="GlorpTests" selector="tableAliasesPresentFor:">tableAliasesPresentFor: aQuery	aQuery whereClause detect: [:each | each hasTableAliases] ifNone: [^false].	^true.</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest</class-id> <category>support</category><body package="GlorpTests" selector="setUp">setUp	super setUp.	query := Query returningManyOf: GlorpCustomer.	query whereClause: [:each | each accounts anySatisfy: [:foo | foo id = 12]].	session := GlorpSessionResource current newSession.	query session: session.</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest class</class-id> <category>resources</category><body package="GlorpTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpCommandTest</class-id> <category>tests</category><body package="GlorpTests" selector="testSplittingInserts1">testSplittingInserts1	| rows command subCommands |	rows := Array with: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := command subCommands.	self assert: subCommands size = 1.	self assert: subCommands first allRows size = 1.	self assert: subCommands first allRows first == rows first.</body><body package="GlorpTests" selector="testSplittingInserts1000">testSplittingInserts1000	| rows command subCommands |	rows := (Array new: 1000) atAllPut: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := command subCommands.	self assert: subCommands size = 1.	self assert: subCommands first allRows size = 1000.	self assert: subCommands first allRows first == rows first.</body><body package="GlorpTests" selector="testSplittingInserts1001">testSplittingInserts1001	| rows command subCommands |	rows := (Array new: 1001) atAllPut: DatabaseRow new.	rows at: rows size put: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := command subCommands.	self assert: subCommands size = 2.	self assert: subCommands first allRows size = 1000.	self assert: subCommands first allRows first == rows first.	self assert: subCommands last allRows size = 1.	self assert:subCommands last allRows first == rows last.</body><body package="GlorpTests" selector="testSplittingInserts1003">testSplittingInserts1003	| rows command subCommands |	rows := (Array new: 1003) atAllPut: DatabaseRow new.	rows at: rows size put: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := command subCommands.	self assert: subCommands size = 2.	self assert: subCommands first allRows size = 1000.	self assert: subCommands first allRows first == rows first.	self assert: subCommands last allRows size = 3.	self assert:subCommands last allRows last == rows last.	self assert: subCommands last allRows first == rows first.</body><body package="GlorpTests" selector="testSplittingInserts2">testSplittingInserts2	| rows command subCommands |	rows := Array with: DatabaseRow new with: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := command subCommands.	self assert: subCommands size = 1.	self assert: subCommands first allRows size = 2.	self assert: subCommands first allRows first == rows first.	self assert: subCommands first allRows last == rows last.</body></methods><methods><class-id>Glorp.GlorpCommandTest</class-id> <category>As yet unclassified</category><body package="GlorpTests" selector="testFieldsToUpdate">testFieldsToUpdate	| command system row old bookTable session |	session := GlorpLockingDescriptorSystem sessionForLogin: (Login new database: OraclePlatform new).	system := session system.	bookTable := system tableNamed: 'BOOK'.	row := DatabaseRow newForTable: bookTable.	old := DatabaseRow newForTable: bookTable.	old at: (bookTable fieldNamed: 'ID') put: 6.	old at: (bookTable fieldNamed: 'TITLE') put: 'ABook'.	old at: (bookTable fieldNamed: 'DESCRIPTION') put: 'Stuff'.	old at: (bookTable fieldNamed: 'COPIES_IN_STOCK') put: 3.	old at: (bookTable fieldNamed: 'VERSION') put: 2.	row at: (bookTable fieldNamed: 'ID') put: 6.	row at: (bookTable fieldNamed: 'TITLE') put: 'ABook'.	row at: (bookTable fieldNamed: 'DESCRIPTION') put: 'Stuff'.	row at: (bookTable fieldNamed: 'COPIES_IN_STOCK') put: 4.	row at: (bookTable fieldNamed: 'VERSION') put: 2.	row withAllFieldsIn: old.	command := UpdateCommand forRows: (Array with: row) useBinding: false session: session.	self assert: command shouldUpdateOnlyChangedFields.	self assert: command singleRowBoundFields size = 2.	self assert: command singleRowBindings isEmpty. 	command useBinding: true.	self deny: command shouldUpdateOnlyChangedFields.	self assert: command singleRowBoundFields size = 5.	"The lock field is bound at the end"	self assert: command singleRowBindings size = 6.</body></methods><methods><class-id>Glorp.GlorpDirectMappingDBTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="readPerson">readPerson	| results query |	query := Query		returningManyOf: GlorpPerson		where: [:pers | pers id = personId].	results := query executeIn: session.	self assert: results size = 1.	person := results first.</body><body package="GlorpDBTests" selector="testMappingToSubselect">testMappingToSubselect	| personDescriptor people |	[session beginTransaction.	self writeAddress.	self writeHomelessPerson.	self writePersonWithEmailAddresses.	personDescriptor := system descriptorFor: GlorpPerson.	(personDescriptor newMapping: DirectMapping)		beReadOnly;		type: Boolean;		from: #hasEmail 		to: [:each | each emailAddresses notEmpty].	people := session read: GlorpPerson orderBy: #id.	self assert: people first hasEmail.	self deny: people last hasEmail.	self assert: people first emailAddresses notEmpty.	self assert: people last emailAddresses isEmpty.	 ]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadWithDirectFieldReference">testReadWithDirectFieldReference	| peopleWithAddresses peopleWithoutAddresses addressIdField |	[session beginTransaction.	self writeAddress.	self writeHomelessPerson.	self writeHomefulPerson.	addressIdField := (session system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID'.	peopleWithAddresses := session readManyOf: GlorpPerson where: [:each | (each getField: addressIdField) notNIL].	peopleWithoutAddresses := session readManyOf: GlorpPerson where: [:each | (each getField: addressIdField) isNIL].	self assert: peopleWithAddresses size = 1.	self assert: peopleWithoutAddresses size = 1.	self assert: peopleWithAddresses first id = 3.	self assert: peopleWithoutAddresses first id = 4.	 ]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testReadWithPseudoVariableMapping">testReadWithPseudoVariableMapping	| peopleWithAddresses peopleWithoutAddresses |	[session beginTransaction.	self writeAddress.	self writeHomelessPerson.	self writeHomefulPerson.	peopleWithAddresses := session readManyOf: GlorpPerson where: [:each | each addressId notNIL].	peopleWithoutAddresses := session readManyOf: GlorpPerson where: [:each | each addressId isNIL].	self assert: peopleWithAddresses size = 1.	self assert: peopleWithoutAddresses size = 1.	self assert: peopleWithAddresses first id = 3.	self assert: peopleWithoutAddresses first id = 4.]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testUpdate">testUpdate	|newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		personId := newPerson id.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		session inUnitOfWorkDo: [			session register: person.			person name: 'something else'].		session reset.		self readPerson.		self assert: person id = newPerson id.		self assert: person name = 'something else'].</body></methods><methods><class-id>Glorp.GlorpDirectMappingDBTest</class-id> <category>support</category><body package="GlorpDBTests" selector="testUpdateWithDefaultValue">testUpdateWithDefaultValue	"Check that default values don't revert if we update the object in some other way.  (This test does not in fact error in Glorp 7.7 - 69 and earlier, so needs revision.)"	self inTransactionDo:		[| thing |		session transact: [thing := DefaultableThing new id: 1].		session reset.		thing := session readOneOf: DefaultableThing.		self assert: thing integer = 4.		session modify: thing in: [thing integer: 7].		session reset.		thing := session readOneOf: DefaultableThing.		session modify: thing in: [thing boolean: true].		self assert: thing integer = 7].</body><body package="GlorpDBTests" selector="testWriteWithDefaultValue">testWriteWithDefaultValue	| rawDBResult field converter dbValue raw |	self inTransactionDo: [		| thing |		session transact: [thing := DefaultableThing new id: 1].		session reset.		thing := session readOneOf: DefaultableThing.		self assert: thing boolean = false.		field := (system tableNamed: 'DEFAULTABLE_THING') fieldNamed: 'MY_BOOL'.		converter := field converterForStType: Boolean.		dbValue := converter convert: false toDatabaseRepresentationAs: field type.		rawDBResult := session accessor executeSQLString: 'select MY_BOOL from DEFAULTABLE_THING'.		"The conversion back might get done by us, or might get done by the EXDI layer, Accomodate either possibility as long as it comes out to something equivalent to what we thought it ought to be."		raw := rawDBResult first first.		self assert: (raw = dbValue or: [raw = false]).		self assert: thing integer = 4].</body><body package="GlorpDBTests" selector="writeAddress">writeAddress	| addressRow |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.</body><body package="GlorpDBTests" selector="writeHomefulPerson">writeHomefulPerson	| personRow |	personRow := session system examplePersonRow1.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests" selector="writeHomelessPerson">writeHomelessPerson	| personRow |	personRow := session system examplePersonRow2.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests" selector="writePersonWithEmailAddresses">writePersonWithEmailAddresses	| personRow emailAddress1Row emailAddress2Row |	personRow := session system examplePersonRow1.	personId := personRow atFieldNamed: 'ID'.	session writeRow: personRow.	emailAddress1Row := session system exampleEmailAddressRow1.	emailAddress2Row := session system exampleEmailAddressRow2.	emailAddress1Row at: (emailAddress1Row table fieldNamed: 'ID').	emailAddress2Row at: (emailAddress2Row table fieldNamed: 'ID').	session writeRow: emailAddress1Row.	session writeRow: emailAddress2Row.</body></methods><methods><class-id>Glorp.GlorpBankBranch</class-id> <category>accessing</category><body package="GlorpTestModels" selector="accounts">accounts	^accounts</body><body package="GlorpTestModels" selector="accounts:">accounts: anObject	accounts := anObject</body><body package="GlorpTestModels" selector="branchNumber">branchNumber	^branchNumber.</body><body package="GlorpTestModels" selector="branchNumber:">branchNumber: aString	branchNumber := aString</body></methods><methods><class-id>Glorp.GlorpBankBranch</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', self branchNumber printString, ')'.</body></methods><methods><class-id>Glorp.GlorpTimedProxyReaperTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, ' for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, ' for ObjectStudio'. ^self].	reaper := TimedProxyReaper new.	reaper delay: 0.5.</body><body package="GlorpDBTests" selector="tearDown">tearDown	reaper release.	reaper := nil.</body></methods><methods><class-id>Glorp.GlorpTimedProxyReaperTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="README">README	"Unfortunately, these tests are timing sensitive. They may intermittently fail, when in fact they are working as advertised.	Rerun failed tests individually. If a test consistently fails, then it likely indicates a bug."</body><body package="GlorpDBTests" selector="testAddObjects">testAddObjects	| proxies |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testAddObjects for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testAddObjects for ObjectStudio'. ^self].	proxies := OrderedCollection new.	1 to: 10 do: [:index | 		proxies add: (TimedProxy returningOneOf: Object where: nil in: nil).		proxies last glorpSecondsToLive: 1000.		reaper add: proxies last].	(Delay forSeconds: 1) wait.	proxies do: [:proxy | self should: [reaper includes: proxy]].</body><body package="GlorpDBTests" selector="testExpireObjects">testExpireObjects	| proxies |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testExpireObjects for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding t', self class name, '&gt;&gt;estExpireObjects for ObjectStudio'. ^self].	proxies := OrderedCollection new.	1 to: 10 do: [:index | 		proxies add: (TimedProxy returningOneOf: Object where: nil in: nil).		proxies last glorpSecondsToLive: 1.		reaper add: proxies last].	(Delay forSeconds: 5) wait.	proxies do: [:proxy | self shouldnt: [reaper includes: proxy]].</body><body package="GlorpDBTests" selector="testTouchAndExpireObjectsWhileOtherObjectsAreBeingReaped">testTouchAndExpireObjectsWhileOtherObjectsAreBeingReaped	| expiringProxy proxy |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchAndExpireObjectsWhileOtherObjectsAreBeingReaped for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchAndExpireObjectsWhileOtherObjectsAreBeingReaped for ObjectStudio'. ^self].	reaper delay: 0.25.	expiringProxy := TimedProxy returningOneOf: Object where: nil in: nil.	expiringProxy glorpSecondsToLive: 1.	proxy := TimedProxy returningOneOf: Object where: nil in: nil.	proxy glorpSecondsToLive: 2.	reaper add: proxy; add: expiringProxy.	self assert: (reaper includes: proxy).	self assert: (reaper includes: expiringProxy).	(Delay forSeconds: 1) wait.	proxy glorpTouch.	(Delay forSeconds: 1.5) wait.	self assert: (reaper includes: proxy).	self deny: (reaper includes: expiringProxy).	(Delay forSeconds: 2) wait.	self deny: (reaper includes: proxy).</body><body package="GlorpDBTests" selector="testTouchObjects">testTouchObjects	| proxy |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchObjects for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchObjects for ObjectStudio'. ^self].	reaper delay: 0.25.	proxy := TimedProxy returningOneOf: Object where: nil in: nil.	proxy glorpSecondsToLive: 2.	reaper add: proxy.	(Delay forSeconds: 1) wait.	proxy glorpTouch.	(Delay forSeconds: 1.1) wait.	self should: [reaper includes: proxy].	(Delay forSeconds: 2) wait.	self shouldnt: [reaper includes: proxy]</body></methods><methods><class-id>Glorp.GlorpChar4Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform char width: 4.</body></methods><methods><class-id>Glorp.GlorpChar4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testChar4">testChar4	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	self helpTestValue: 'abc'.	self helpTestValue: 'abcd'.	self helpTestInvalidValue: 'abcde'.	stType := Symbol.	self helpTestValue: #abcd.		self assert: (type typeString asUppercase= (self platform char: 4) typeString asUppercase)</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>As yet unclassified</category><body package="GlorpTestModels" selector="customer">customer	^customer.</body><body package="GlorpTestModels" selector="customer:">customer: aCustomer	customer := aCustomer.</body><body package="GlorpTestModels" selector="store:">store: aGlorpVideoStore	store := aGlorpVideoStore.</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>accessing</category><body package="GlorpTestModels" selector="dueDate">dueDate	^dueDate</body><body package="GlorpTestModels" selector="dueDate:">dueDate: anObject	dueDate := anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="price">price	^price</body><body package="GlorpTestModels" selector="price:">price: anObject	price := anObject</body><body package="GlorpTestModels" selector="title">title	^title</body><body package="GlorpTestModels" selector="title:">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self title.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>testing</category><body package="GlorpTestModels" selector="assertEqual:">assertEqual: aRental	self assert: customer name = aRental customer name.	self assert: customer dateOfBirth = aRental customer dateOfBirth.	self assert: id = aRental id.	self assert: title = aRental title.	self assert: price = aRental price.	self assert: dueDate = aRental dueDate.</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>initialize-release</category><body package="GlorpTestModels" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	id := nil.	title := nil.	dueDate := nil.	price := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>comparing</category><body package="GlorpTestModels" selector="&lt;=">&lt;= aVideoRental	^self title &lt;= aVideoRental title.</body></methods><methods><class-id>Glorp.GlorpVideoRental class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource</class-id> <category>accessing</category><body package="GlorpDBTests" selector="accessor">accessor	^accessor</body><body package="GlorpDBTests" selector="accessor:">accessor: anObject	accessor := anObject</body><body package="GlorpDBTests" selector="login">login	^login</body><body package="GlorpDBTests" selector="login:">login: anObject	"We don't attempt to be secure on logins being used for tests. Make sure we don't surprise someone by modifying the original instance."	login := anObject copy.	login secure: false.</body><body package="GlorpDBTests" selector="platform">platform	^login database</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource</class-id> <category>initialize/release</category><body package="GlorpDBTests" selector="setUp">setUp	Transcript show: self class name asString, ' setUp'; cr.	super setUp.	self login: self class defaultLogin.	accessor := DatabaseAccessor forLogin: login.	accessor login.</body><body package="GlorpDBTests" selector="tearDown">tearDown	Transcript show: self class name asString, ' tearDown'; cr.	accessor notNil ifTrue: [[accessor logout] on: Dialect error do: [:ex | ]].</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource class</class-id> <category>accessing</category><body package="GlorpDBTests" selector="constructEventsTriggered">constructEventsTriggered	^(super constructEventsTriggered)		add: #changedDefaultLogin;		yourself</body><body package="GlorpDBTests" selector="defaultLogin">defaultLogin	"Return the default Login."	DefaultLogin isNil ifTrue: [^DefaultLogin := self defaultPostgreSQLLoginForVPN].	DefaultLogin database useBinding: DatabasePlatform useBindingIfSupported.	^DefaultLogin</body><body package="GlorpDBTests" selector="defaultLogin:">defaultLogin: aLogin 	DefaultLogin := aLogin.	self triggerEvent: #changedDefaultLogin</body><body package="GlorpDBTests" selector="defaultPlatform">defaultPlatform	^self defaultLogin database.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource class</class-id> <category>data</category><body package="GlorpDBTests" selector="defaultAccessLogin">defaultAccessLogin	"To set the default database login for Access, execute the following statement."	"self defaultAccessLogin."	^DefaultLogin := (Login new)		database: AccessPlatform new;		username: 'whatever';		password: '';		connectString: 'access'</body><body package="GlorpDBTests" selector="defaultDB2Login">defaultDB2Login	"To set the default database login to Oracle, execute the following statement."	"self defaultDB2Login."	^DefaultLogin := (Login new)		database: DB2Platform new;		username: 'sames';		password: 'sames';		connectString: 'store'</body><body package="GlorpDBTests" selector="defaultFirebirdLogin">defaultFirebirdLogin	"To set the default database login to Firebird, execute the following statement."	"self defaultFirebirdLogin."	^DefaultLogin := (Login new)		database: FirebirdPlatform new;		username: 'BaseSystem';		password: 'BaseSyst';		connectString: 'firebirdGlorpTestDB'</body><body package="GlorpDBTests" selector="defaultMysqlLogin">defaultMysqlLogin	"To set the default database login to MySQL, execute the following statement."	"self defaultMysqlLogin."	^DefaultLogin := (Login new)		database: MySQLPlatform new;		username: '';		password: '';		connectString: 'test'.</body><body package="GlorpDBTests" selector="defaultOracleLiteLogin">defaultOracleLiteLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleLiteLogin."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'System';		password: 'password';		connectString: 'odbc:polite'</body><body package="GlorpDBTests" selector="defaultOracleLogin">defaultOracleLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleLogin."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'System';		password: 'manager';		connectString: ''</body><body package="GlorpDBTests" selector="defaultOracleLogin2">defaultOracleLogin2	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleLogin2."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'system';		password: 'password';		connectString: ''</body><body package="GlorpDBTests" selector="defaultOracleODBCLogin">defaultOracleODBCLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleODBCLogin."	^DefaultLogin := (Login new)		database: OracleODBCPlatform new;		username: 'System';		password: 'manager';		connectString: 'oracle'</body><body package="GlorpDBTests" selector="defaultPersonalOracleLogin">defaultPersonalOracleLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultPersonalOracleLogin."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'system';		password: 'manager';		connectString: ''</body><body package="GlorpDBTests" selector="defaultPostgreSQLInternetLogin">defaultPostgreSQLInternetLogin	"To set the default database login to PostgreSQL, execute the following statement."	"self defaultPostgreSQLInternetLogin."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'guest';		password: 'guest';		connectString: 'store.cincomsmalltalk.com:5432_glorptest'.</body><body package="GlorpDBTests" selector="defaultPostgreSQLLocalLogin">defaultPostgreSQLLocalLogin	"To set the default database login to PostgreSQL, execute the following statement."	"self defaultPostgreSQLLocalLogin."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'glorp';		password: '';		connectString: '192.168.1.99:5432_test'.</body><body package="GlorpDBTests" selector="defaultPostgreSQLLogin">defaultPostgreSQLLogin	"To set the default database login to PostgreSQL, execute the following statement."	"self defaultPostgreSQLLogin."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'glorp-test';		password: 'simple';		connectString: '192.168.0.18_glorp-test'.</body><body package="GlorpDBTests" selector="defaultPostgreSQLLoginForGlorpStore">defaultPostgreSQLLoginForGlorpStore	"To set the default database login to PostgreSQL, execute the following statement."	"self defaultPostgreSQLLoginForGlorpStore."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'store-glorp-test';		password: 'simple';		connectString: '192.168.0.18_store-glorp-test'.</body><body package="GlorpDBTests" selector="defaultPostgreSQLLoginForVPN">defaultPostgreSQLLoginForVPN	"To set the default database login to PostgreSQL, execute the following statement."	"self defaultPostgreSQLLoginForVPN."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'dbadmin';		password: 'dbadmin';		connectString: 'curly.parcplace.com:5432_template1'.</body><body package="GlorpDBTests" selector="defaultSQLServerLogin">defaultSQLServerLogin	"To set the default database login for Dolphin, execute the following statement."	"self defaultSQLServerLogin."	^DefaultLogin := (Login new)		database: SQLServerPlatform new;		username: 'glorptest';		password: 'password';		connectString: 'glorptest'</body><body package="GlorpDBTests" selector="defaultSQLiteLocalLogin">defaultSQLiteLocalLogin	"To set the default database login to SQLite, change the connectString to an appropriate path and execute the following statement."	"self defaultSQLiteLocalLogin."	^DefaultLogin := (Login new)		database: SQLite3Platform new;		username: '';		password: '';		connectString: 'C:\MyPath\StoreData\glorpTestSQLite.db'.</body></methods><methods><class-id>Glorp.GlorpNumeric5Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform numeric scale: 5.</body></methods><methods><class-id>Glorp.GlorpNumeric5Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testNumeric5">testNumeric5	| fixed |	self platform supportsVariableSizedNumerics ifFalse: [^self].	self helpTestFloat: nil.	self helpTestFloat: 12.	self helpTestFloat: 10991.	self helpTestFloat: (Dialect readFixedPointFrom: '3.0').	fixed := Dialect readFixedPointFrom: '321.12'.	self platform supportsDecimalsOnAllNumerics		ifTrue: [			self helpTestFloat: fixed.			self helpTestFloat: 3.14]		ifFalse: [			self helpTestInvalidValue: fixed.			self helpTestInvalidValue: 3.14].</body></methods><methods><class-id>Glorp.GlorpObjectComparisonSubselectTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session system useJoinsForAnySatisfy: false.</body></methods><methods><class-id>Glorp.GlorpTestUpdatingTimestampInRecord</class-id> <category>tests</category><body package="GlorpDBTests" selector="testUpdating">testUpdating	| record firstTime secondTime |	session beginTransaction.	[	"First verify that when we insert, a timestamp is set"	record := GlorpRecordWithUpdateTime new id: 12; name: 'thing'.	session modify: record in: [ ].	session reset.	record := session readOneOf: GlorpRecordWithUpdateTime.	self assert: record id = 12.	firstTime := record updateTime asSeconds.	self assert: (firstTime - Timestamp now asSeconds) &lt; 2.	"Now wait long enough for the timestamp to definitely change, and verify that if modify the object it changes"	(Delay forSeconds: 2) wait.	session modify: record in: [record name: 'different'].	secondTime := record updateTime asSeconds.	self deny: secondTime = firstTime.	"Now verify that if we don't modify the object, we don't write the timestamp, or put it into the object"	(Delay forSeconds: 2) wait.	session modify: record in: [].	self assert: record updateTime asSeconds = secondTime.	session reset.	record := session readOneOf: GlorpRecordWithUpdateTime.	self assert: record updateTime asSeconds = secondTime.]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testUpdatingComment">testUpdatingComment	"Test that we update the unmapped comment field. We just put the printString of time now into the field, so most of the same sort of logic applies as in testUpdating."	| record time time2 rows |	session beginTransaction.	[	"First verify that when we insert, a comment is set"	record := GlorpRecordWithUpdateTime new id: 12; name: 'thing'.	time := Time now printString.	session modify: record in: [ ].	time2 := Time now printString.	session reset.	rows := session accessor executeSQLString: 'SELECT UPDATE_COMMENT from RECORD_WITH_UPDATE'.	"Just in case the seconds flipped in that interval between us noting the time and the value being generated, check against before and after. I really can't see there being more than a one second gap in there"	self assert: (rows first first = time or: [rows first first = time2]).	"Now wait long enough for the time to definitely change, and verify that if modify the object it changes"	(Delay forSeconds: 2) wait.	record := session readOneOf: GlorpRecordWithUpdateTime.	time := Time now printString.	session modify: record in: [record name: 'different'].	time2 := Time now printString.	rows := session accessor executeSQLString: 'SELECT UPDATE_COMMENT from RECORD_WITH_UPDATE'.	"Just in case the seconds flipped in that interval between us noting the time and the value being generated, check against before and after. I really can't see there being more than a one second gap in there"	self assert: (rows first first = time or: [rows first first = time2]).	"Now verify that if we don't modify the object, we don't write the comment, or put it into the object"	(Delay forSeconds: 2) wait.	session modify: record in: [].	rows := session accessor executeSQLString: 'SELECT UPDATE_COMMENT from RECORD_WITH_UPDATE'.	"Now verify that we still have the previous time value"	self assert: (rows first first = time or: [rows first first = time2]).]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests" selector="testUpdatingOtherThing">testUpdatingOtherThing	"Test that we update the mapped other thing field. We just put the printString of time now into the field, so most of the same sort of logic applies as in testUpdating."	| record time time2 newThing |	session beginTransaction.	[	"First verify that when we insert, a comment is set"	record := GlorpRecordWithUpdateTime new id: 12; name: 'thing'.	time := Time now printString.	session modify: record in: [ ].	time2 := Time now printString.	session reset.	newThing := session readOneOf: GlorpRecordWithUpdateTime.	"Just in case the seconds flipped in that interval between us noting the time and the value being generated, check against before and after. I really can't see there being more than a one second gap in there"	self assert: (newThing updateSomeOtherThing = time or: [newThing updateSomeOtherThing = time2]).	"Now wait long enough for the time to definitely change, and verify that if modify the object it changes"	(Delay forSeconds: 2) wait.	session reset.	record := session readOneOf: GlorpRecordWithUpdateTime.	time := Time now printString.	session modify: record in: [record name: 'different'].	time2 := Time now printString.	session reset.	newThing := session readOneOf: GlorpRecordWithUpdateTime.	self assert: (newThing updateSomeOtherThing = time or: [newThing updateSomeOtherThing = time2]).	record := session readOneOf: GlorpRecordWithUpdateTime.	"Now verify that if we don't modify the object, we don't write the comment, or put it into the object"	(Delay forSeconds: 2) wait.	session modify: record in: [].	session reset.	newThing := session readOneOf: GlorpRecordWithUpdateTime.	self assert: (newThing updateSomeOtherThing = time or: [newThing updateSomeOtherThing = time2]).]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpRegionalManager</class-id> <category>accessing</category><body package="GlorpTestModels" selector="region">region	^region</body><body package="GlorpTestModels" selector="region:">region: anObject	region := anObject</body></methods><methods><class-id>Glorp.GlorpRegionalManager</class-id> <category>comparing</category><body package="GlorpTestModels" selector="=">= aRegionalManager	^super = aRegionalManager and: [region = aRegionalManager region].</body></methods><methods><class-id>Glorp.GlorpFakeElementBuilder</class-id> <category>element builder protocol</category><body package="GlorpTests" selector="valueOf:">valueOf: aField	^value.</body><body package="GlorpTests" selector="valueOfField:in:">valueOfField: aField in: anArray	^value.</body></methods><methods><class-id>Glorp.GlorpFakeElementBuilder</class-id> <category>accessing</category><body package="GlorpTests" selector="value:">value: anObject	value := anObject.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testSerial">testSerial	"type := PGSerialType instance.	self assert: false.	self assert: (type typeString = 'SERIAL')"</body><body package="GlorpDBTypeTests" selector="testTimeWithTimeZone">testTimeWithTimeZone	| time |	"	type := PGTimeWithTimeZoneType instance.	time := Dialect timestampNow.	self assert: false. This needs some thought.	self assert: (self helpTestType: type withValue: time).		self assert: (type typeString = 'TIME WITH TIME ZONE')"</body><body package="GlorpDBTypeTests" selector="testTypeParametersNotAliased">testTypeParametersNotAliased	| type2 type3 |	type := (self platform) varchar.	self assert: type width isNil.	self assert: (type2 := self platform varChar: 5) width = 5.	self assert: type width isNil.	type3 := self platform varChar: 10.	self assert: type3 width = 10.	self assert: type2 width = 5.	self assert: type width isNil.</body><body package="GlorpDBTypeTests" selector="testVarBinary">testVarBinary	"Needs doing"	self needsWork: 'write the test'.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>infrastructure tests</category><body package="GlorpDBTypeTests" selector="testReadTime">testReadTime	self platform readTime: '18:06:22.12' for: self platform time.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>setup</category><body package="GlorpDBTypeTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.	connection := session accessor.</body><body package="GlorpDBTypeTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>accessing</category><body package="GlorpDBTypeTests" selector="platform">platform	^connection platform</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests class</class-id> <category>accessing</category><body package="GlorpDBTypeTests" selector="resources">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpDescriptorTest</class-id> <category>tests</category><body package="GlorpTests" selector="testAllClassesAndNames">testAllClassesAndNames	| identity1 identity2 identity3 |	system flushAllClasses.	identity1 := system allClasses.	identity2 := system allClasses.	system flushAllClasses.	identity3 := system allClasses.	self assert: identity1 == identity2.	self assert: identity1 ~~ identity3.	self should: [system allClassNames] raise: Dialect error.</body><body package="GlorpTests" selector="testAllMappingsForField">testAllMappingsForField	| descriptor mappings |	descriptor := system descriptorFor: GlorpCustomer.	mappings := descriptor 				allMappingsForField: ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	self assert: mappings first attributeName = #id</body><body package="GlorpTests" selector="testBuildBankTransactionAndDependentsFromRow">testBuildBankTransactionAndDependentsFromRow	| transactionDescriptor object row moneyDescriptor money1 table translations session builder |	session := GlorpMockSession new.	session system: system.	transactionDescriptor := system descriptorFor: GlorpBankTransaction.	object := GlorpBankTransaction new.	row := #(99 nil 'CDN' 98 'service charge' 'USD' 97).	builder := ObjectBuilder new.	builder row: row.	transactionDescriptor populateObject: object inBuilder: builder.	self assert: object id = 99.	moneyDescriptor := system descriptorFor: GlorpMoney.	money1 := GlorpMoney new.	table := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	translations := IdentityDictionary new.	translations at: (table fieldNamed: 'CURRENCY') put: 3.	translations at: (table fieldNamed: 'AMOUNT') put: 4.	builder := ElementBuilder new fieldTranslations: translations; row: row.	moneyDescriptor		populateObject: money1		inBuilder: builder.	self assert: money1 amount = 98.	self assert: money1 currency = #CDN.</body><body package="GlorpTests" selector="testBuildPersonFromRow">testBuildPersonFromRow	| descriptor object address session builder |	session := GlorpMockSession new.	session system: system.	address := GlorpAddress new.	session cacheAt: 127 put: address.	descriptor := system descriptorFor: GlorpPerson.	system tableNamed: 'PERSON'.	object := GlorpPerson new.	builder := ObjectBuilder new.	builder row: #(456 'Ralph' 127).	descriptor populateObject: object inBuilder: builder.	self assert: object class = GlorpPerson.	self assert: object id = 456.	self assert: object name = 'Ralph'.	self assert: object address getValue == address.</body><body package="GlorpTests" selector="testClassLookup">testClassLookup	self assert: (Dialect smalltalkAt: 'Object') == Object.	Dialect isVWWithNameSpaces ifTrue: [		"Sneaky meta-tricks to avoid things that won't compile in non-VW dialects"		self assert: (Dialect smalltalkAt: 'GlorpTestNamespace.GlorpTestClassInNamespace') == (Compiler evaluate: 'GlorpTestNamespace.GlorpTestClassInNamespace').		self assert: (Dialect smalltalkAt: 'GlorpTestNamespace.GlorpTestClassInNamespace') notNil].</body><body package="GlorpTests" selector="testDescriptorIdentity">testDescriptorIdentity	| descriptor |	descriptor := system descriptorFor: GlorpCustomer.	self assert: descriptor == (system descriptorFor: GlorpCustomer).</body><body package="GlorpTests" selector="testDescriptorWithNamespace">testDescriptorWithNamespace	| descriptor testCaseClass |	Dialect isVWWithNameSpaces ifFalse: [^self].	system := GlorpDescriptorSystemWithNamespaces new.	testCaseClass := 'GlorpTestNamespace.GlorpTestClassInNamespace' asQualifiedReference value.	descriptor := system descriptorFor: testCaseClass.	self assert: descriptor describedClass == testCaseClass.</body><body package="GlorpTests" selector="testMappedFields">testMappedFields	| descriptor |	descriptor := system descriptorFor: GlorpBankTransaction.	self assert: (descriptor mappedFields) = (descriptor table fields).</body><body package="GlorpTests" selector="testMappingForField">testMappingForField	| descriptor mapping |	descriptor := system descriptorFor: GlorpCustomer.	mapping := descriptor 				directMappingForField: ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	self assert: mapping attributeName = #id</body><body package="GlorpTests" selector="testPrimaryKeyExpressionFor">testPrimaryKeyExpressionFor	| descriptor trans exp |	descriptor := system descriptorFor: GlorpBankTransaction.	trans := GlorpBankTransaction new.	trans id: 42.	exp := descriptor		primaryKeyExpressionFor: trans		basedOn: BaseExpression new		relation: #=.	self assert: exp relation = #=.	self assert: exp rightChild value = 42.</body><body package="GlorpTests" selector="testPrimaryKeyExpressionForFailing">testPrimaryKeyExpressionForFailing	| descriptor trans |	descriptor := system descriptorFor: GlorpBankTransaction.	trans := GlorpCustomer new.	self		should:			[descriptor				primaryKeyExpressionFor: trans				basedOn: BaseExpression new				relation: #=]		raise: self errorSignal.</body><body package="GlorpTests" selector="testPrimaryKeyExpressionForWithCompositeKey">testPrimaryKeyExpressionForWithCompositeKey	self unfinished.</body></methods><methods><class-id>Glorp.GlorpDescriptorTest</class-id> <category>support</category><body package="GlorpTests" selector="errorSignal">errorSignal	^Dialect error.</body></methods><methods><class-id>Glorp.GlorpMappingFromClassModelTests</class-id> <category>Tests</category><body package="GlorpTests" selector="someCode">someCode	| model descriptor mapping table |	table := DatabaseTable named: 'TYPETESTS'.	table createFieldNamed: 'test' type: system platform boolean.	model := system addClassModelFor: GlorpTypeTestsModelClass.	model newAttributeNamed: #test type: Boolean.	system privateTableAt: table name put: table.	descriptor := Descriptor new.	descriptor system: system.	descriptor classModel: model.	descriptor table: table.	descriptor 		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'id')).	Boolean isNil 		ifTrue: [mapping := DirectMapping from: #test to: (table fieldNamed: 'test')]		ifFalse: 			[mapping := DirectMapping 						from: #test						type: Boolean						to: (table fieldNamed: 'test')].	descriptor addMapping: mapping.	system privateDescriptorAt: GlorpTypeTestsModelClass put: descriptor.	^system</body><body package="GlorpTests" selector="testAllAttributes">testAllAttributes	| bankTransTable customerTable ownerId btOwnerId customerModel customerDescriptor attributes |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	customerModel newAttributeNamed: #transactions		collectionOf: GlorpBankTransaction.	system addClassModelFor: GlorpBankTransaction.	system addEmptyDescriptorFor: GlorpBankTransaction.	(system descriptorFor: GlorpBankTransaction) table: (system tableNamed: 'BANK_TRANS').	customerDescriptor := system addEmptyDescriptorFor: GlorpCustomer.	customerDescriptor table: customerTable.	system createMappingsFromClassModelIn: customerDescriptor.	self assert: (customerDescriptor mappingForAttributeNamed: #id) notNil.	self 		assert: (customerDescriptor mappingForAttributeNamed: #transactions) notNil.	system validate.	attributes := OrderedCollection new.	customerDescriptor classModel attributesDo: [:each | attributes add: each].	self assert: attributes size = 2.</body><body package="GlorpTests" selector="testAllAttributesSkipDefined">testAllAttributesSkipDefined	| bankTransTable customerTable ownerId btOwnerId customerModel customerDescriptor ownerId2 |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	ownerId2 := customerTable createFieldNamed: 'ID2' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	customerModel newAttributeNamed: #transactions		collectionOf: GlorpBankTransaction.	system addClassModelFor: GlorpBankTransaction.	system addEmptyDescriptorFor: GlorpBankTransaction.	customerDescriptor := system addEmptyDescriptorFor: GlorpCustomer.	customerDescriptor table: customerTable.	(customerDescriptor newMapping: DirectMapping) from: #id to: ownerId2.	system createMappingsFromClassModelIn: customerDescriptor.	self assert: customerDescriptor mappings size = 2.	self 		assert: (customerDescriptor mappingForAttributeNamed: #id) field = ownerId2</body><body package="GlorpTests" selector="testDirectMapping">testDirectMapping	| customerTable ownerId descriptor mapping customerModel |	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	descriptor table: customerTable.	system createMappingIn: descriptor fromClassModelForAttributeNamed: #id.	mapping := descriptor mappingForAttributeNamed: #id.	self assert: mapping class = DirectMapping.	self assert: mapping field = ownerId</body><body package="GlorpTests" selector="testDirectMappingNameFieldNameComputation">testDirectMappingNameFieldNameComputation	| customerTable ownerId descriptor mapping customerModel |	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'OWNER_ID' type: platform int4.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	descriptor table: customerTable.	system attributeNameToFieldNameBlock: [:symbol | 'OWNER_ID'].	system createMappingIn: descriptor fromClassModelForAttributeNamed: #id.	mapping := descriptor mappingForAttributeNamed: #id.	self assert: mapping class = DirectMapping.	self assert: mapping field = ownerId</body><body package="GlorpTests" selector="testOneToOneRelation">testOneToOneRelation	| bankTransTable customerTable ownerId btOwnerId bankTransModel descriptor mapping |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	system		addClassModelFor: GlorpCustomer;		addEmptyDescriptorFor: GlorpCustomer.	bankTransModel := system addClassModelFor: GlorpBankTransaction.	bankTransModel newAttributeNamed: #owner type: GlorpCustomer.	descriptor := system addEmptyDescriptorFor: GlorpBankTransaction.	descriptor table: bankTransTable.	system createMappingIn: descriptor fromClassModelForAttributeNamed: #owner.	mapping := descriptor mappingForAttributeNamed: #owner.	self assert: mapping class = OneToOneMapping</body><body package="GlorpTests" selector="testToManyRelation">testToManyRelation	| bankTransTable customerTable ownerId btOwnerId mapping customerModel customerDescriptor |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #transactions		collectionOf: GlorpBankTransaction.	system addClassModelFor: GlorpBankTransaction.	system addEmptyDescriptorFor: GlorpBankTransaction.	customerDescriptor := system addEmptyDescriptorFor: GlorpCustomer.	customerDescriptor table: customerTable.	system createMappingIn: customerDescriptor		fromClassModelForAttributeNamed: #transactions.	mapping := customerDescriptor mappingForAttributeNamed: #transactions.	self assert: mapping class = ToManyMapping.	self assert: mapping referenceClass = GlorpBankTransaction</body></methods><methods><class-id>Glorp.GlorpMappingFromClassModelTests</class-id> <category>running</category><body package="GlorpTests" selector="setUp">setUp	platform := PostgreSQLPlatform new.	system := DynamicDescriptorSystem forPlatform: platform</body></methods><methods><class-id>Glorp.GlorpObjectWithNoAccessors</class-id> <category>accessing</category><body package="GlorpTestModels" selector="extremelyPrivateValue:">extremelyPrivateValue: aString	alue := aString</body></methods><methods><class-id>Glorp.GlorpTypeTestsModelClass</class-id> <category>As yet unclassified</category><body package="GlorpDBTests" selector="test">test	^test.</body><body package="GlorpDBTests" selector="test:">test: anObject	test:= anObject.</body></methods><methods><class-id>Glorp.GlorpServiceCharge</class-id> <category>accessing</category><body package="GlorpTestModels" selector="amount">amount	^amount</body><body package="GlorpTestModels" selector="amount:">amount: anObject	amount := anObject</body><body package="GlorpTestModels" selector="description">description	^description</body><body package="GlorpTestModels" selector="description:">description: anObject	description := anObject</body></methods><methods><class-id>Glorp.GlorpServiceCharge</class-id> <category>initialize</category><body package="GlorpTestModels" selector="initialize">initialize</body></methods><methods><class-id>Glorp.GlorpServiceCharge class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="default">default	^self new		amount: (GlorpMoney forAmount: 3);		description: 'additional overcharge'.</body><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpCompressedMoney</class-id> <category>accessing</category><body package="GlorpTestModels" selector="amount">amount	^array at: 2</body><body package="GlorpTestModels" selector="amount:">amount: anObject	array at: 2 put: anObject</body><body package="GlorpTestModels" selector="currency">currency	^array at: 1</body><body package="GlorpTestModels" selector="currency:">currency: anObject	array at: 1 put: anObject</body><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpCompressedMoney</class-id> <category>printing</category><body package="GlorpTestModels" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self amount;		space;		nextPutAll: self currency;		nextPut: $).</body></methods><methods><class-id>Glorp.GlorpCompressedMoney</class-id> <category>initialize</category><body package="GlorpTestModels" selector="initialize">initialize	array := Array new: 2.</body></methods><methods><class-id>Glorp.GlorpCompressedMoney class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="currency:amount:">currency: aSymbol amount: aNumber	^super new initialize		currency: aSymbol;		amount: aNumber.</body><body package="GlorpTestModels" selector="defaultCurrency">defaultCurrency	^#CDN.</body><body package="GlorpTestModels" selector="forAmount:">forAmount: aNumber	^self currency: self defaultCurrency amount: aNumber.</body><body package="GlorpTestModels" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDatabaseSessionTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="testWriteRow">testWriteRow	| rowToWrite fields rowReadFromDatabase |	rowToWrite := session system examplePersonRow2.		[session beginTransaction.	session writeRow: rowToWrite.	rowReadFromDatabase := (session accessor				executeSQLString: 'SELECT * FROM ' , rowToWrite table name) first.	fields := rowToWrite table fields.	(1 to: fields size) with: fields		do: [:index :field | self assert: (rowReadFromDatabase atIndex: index) = (rowToWrite at: field)]] 			ensure: [session rollbackTransaction]</body></methods><methods><class-id>Glorp.GlorpDatabaseSessionTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpDatabaseSessionTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpDescriptorValidationTest</class-id> <category>testing</category><body package="GlorpTests" selector="testJoinDirection">testJoinDirection	| descriptor table1 table2 mapping system descriptor2 |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	descriptor2 := system addEmptyDescriptorFor: GlorpVideoStore.	table1 := DatabaseTable named: 'Table1'.	table1 createFieldNamed: 'one' type: nil.	table2 := DatabaseTable named: 'Table2'.	table2 createFieldNamed: 'two' type: nil.	descriptor addTable: table1.	descriptor2  addTable: table2.	mapping := descriptor newMapping: OneToOneMapping.	mapping attributeName: #accounts.	mapping referenceClass: GlorpVideoStore.	mapping join: (Join from: (table1 fieldNamed: 'one') to: (table2 fieldNamed: 'two')).	mapping validate.	mapping := descriptor newMapping: OneToOneMapping.	mapping attributeName: #bar.	mapping referenceClass: GlorpVideoStore.	mapping join: (Join from: (table2 fieldNamed: 'two') to: (table1 fieldNamed: 'one')).	self should: [mapping validate] raise: Dialect error.</body><body package="GlorpTests" selector="testValidateDirectInstvarAccessExisting">testValidateDirectInstvarAccessExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #id to: field.	mapping validate</body><body package="GlorpTests" selector="testValidateDirectInstvarAccessNonExisting">testValidateDirectInstvarAccessNonExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #bar to: field.	self should: [mapping validate] raise: Dialect error</body><body package="GlorpTests" selector="testValidateSelectorAccessExisting">testValidateSelectorAccessExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #id to: field.	mapping attribute useDirectAccess: false.	mapping validate</body><body package="GlorpTests" selector="testValidateSelectorAccessNonExisting">testValidateSelectorAccessNonExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #foo to: field.	mapping attribute useDirectAccess: false.	self should: [mapping validate] raise: Dialect error</body><body package="GlorpTests" selector="testValidatingExistingDescriptors">testValidatingExistingDescriptors	| session |	session := GlorpSessionResource current newSession.	GlorpTestDescriptorSystem glorpAllSubclasses do: [:each |		session system: (each forPlatform: (OraclePlatform new)).		session system validate].</body></methods><methods><class-id>Glorp.GlorpOwnerSlaveTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="test1">test1	| owner slaves table field |	self		inTransactionDo:			[owner := GlorpOwner new.			owner id: 1.			slaves := OrderedCollection new.			1 to: 5 do: [:id | slaves add: (GlorpSlave new id: id)].			owner slaves: slaves.			owner slave: slaves last.			session beginUnitOfWork.			session register: owner.			session commitUnitOfWork.			session reset.			owner := session readOneOf: GlorpOwner where: [:each | each id = 1].			self assert: owner slaves isEmpty not.			table := session system tableNamed: 'GLORP_SLAVE'.			field := table fieldNamed: 'OWNER_ID'.			slaves := session				readManyOf: GlorpSlave				where: [:each | ((each getTable: table) getField: field) ~= nil].			self assert: slaves size = 5].</body><body package="GlorpDBTests" selector="testSortOrder">testSortOrder	"Validate that it doesn't matter what order we put in the input, the tables come out in the correct sort order."	| justTheseTables sorted sorted2 |	justTheseTables := Array with: (system tableNamed: 'GLORP_OWNER') with: (system tableNamed: 'GLORP_SLAVE').	sorted := (TableSorter for: justTheseTables) sort.	sorted2 := (TableSorter for: justTheseTables reverse) sort.	self assert: sorted = sorted2.	self assert: sorted first name = 'GLORP_SLAVE'.</body></methods><methods><class-id>Glorp.GlorpDBTestsPackage class</class-id> <category>instance creation</category><body package="GlorpDBTests" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.GlorpImageLink</class-id> <category>accessing</category><body package="GlorpTestModels" selector="id">id	^id</body><body package="GlorpTestModels" selector="id:">id: anObject	id := anObject</body><body package="GlorpTestModels" selector="image">image	^fullImage</body><body package="GlorpTestModels" selector="image:">image: anObject	fullImage := anObject</body><body package="GlorpTestModels" selector="thumbnailBits">thumbnailBits	^thumbnailBits</body><body package="GlorpTestModels" selector="thumbnailBits:">thumbnailBits: anObject	thumbnailBits := anObject</body><body package="GlorpTestModels" selector="title">title	^title</body><body package="GlorpTestModels" selector="title:">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest</class-id> <category>tests</category><body package="GlorpDBTests" selector="setUpQueryBasic:">setUpQueryBasic: query 	| |	query session: session.	query setUpExpressions.	query setupTracing.</body><body package="GlorpDBTests" selector="setUpQueryFields:">setUpQueryFields: query 	self setUpQueryBasic: query.	query computeFields.</body><body package="GlorpDBTests" selector="setUpQueryFully:">setUpQueryFully: query 	self setUpQueryBasic: query.	query prepare</body><body package="GlorpDBTests" selector="skipToString">skipToString	^session platform supportsANSIJoins ifTrue: ['join '] ifFalse: ['where '].</body><body package="GlorpDBTests" selector="testCaseInsensitiveQuery">testCaseInsensitiveQuery	| result |	session platform supportsCaseInsensitiveLike ifFalse: [^self].	[session beginUnitOfWork.	session beginTransaction.	session register: GlorpAddress example1.	session commitUnitOfWork.	result := session				readOneOf: GlorpAddress				where: [:address | address street ilike: 'WeSt%'].	self assert: result street = 'West 47th Ave'] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests" selector="testComputingFieldsForDirectMappings">testComputingFieldsForDirectMappings	| query table |	query := SimpleQuery returningOneOf: GlorpAddress where: [:each | each id = 1].	self setUpQueryFields: query.		table := session system tableNamed: 'GR_ADDRESS'.	self assert: (query fields = table fields).</body><body package="GlorpDBTests" selector="testComputingFieldsForDirectMappingsWithFullPrepare">testComputingFieldsForDirectMappingsWithFullPrepare	| query table |	query := Query readOneOf: GlorpAddress where: [:each | each id = 1].	query session: session.	query prepare.		table := session system tableNamed: 'GR_ADDRESS'.	self assert: ((query fields collect: [:each | each table parent fieldNamed: each name])= table fields).</body><body package="GlorpDBTests" selector="testComputingFieldsForReferenceMappings">testComputingFieldsForReferenceMappings	| query table |	query := SimpleQuery returningOneOf: GlorpPerson where: [:each | each id = 1].	self setUpQueryFields: query.		table := session system tableNamed: 'PERSON'.	self assert: (query fields = table fields).</body><body package="GlorpDBTests" selector="testComputingFieldsForReferenceMappingsWithFullPrepare">testComputingFieldsForReferenceMappingsWithFullPrepare	| query table |	query := SimpleQuery returningOneOf: GlorpPerson where: [:each | each id = 1].	query session: session.	query prepare.		table := session system tableNamed: 'PERSON'.	self assert: ((query fields collect: [:each | each table parent fieldNamed: each name])= table fields).</body><body package="GlorpDBTests" selector="testDescriptorAssignmentToCriteria">testDescriptorAssignmentToCriteria	| query |	query := SimpleQuery returningOneOf: GlorpAddress where: [:each | each id = 1].	query session: session.	query setUpExpressions.	self assert: query whereClause ultimateBaseExpression descriptor == (session descriptorFor: GlorpAddress).</body><body package="GlorpDBTests" selector="testFieldAliasingForEmbeddedMappings">testFieldAliasingForEmbeddedMappings	| query table |	query := SimpleQuery returningOneOf: GlorpBankTransaction where: [:each | each id = 1].	self setUpQueryFields: query.	table := session system tableNamed: 'BANK_TRANS'.	self assert: (query fields = table fields).	self assert: (query builders first translateFieldPosition: (table fieldNamed: 'ID')) = 1.	self assert: (query builders first translateFieldPosition: (table fieldNamed: 'OWNER_ID')) = 2.</body><body package="GlorpDBTests" selector="testJoinExpressionWithMultipleTables">testJoinExpressionWithMultipleTables	| query sql sqlStream result command |	query := SimpleQuery returningOneOf: GlorpPassenger where: [:each | each id = 1].	query session: session.	query prepare.	command := query sqlWith: Dictionary new.	command useBinding: false.	sql := command sqlString.	sqlStream := ReadStream on: sql asLowercase.	sqlStream skipToAll: self skipToString.	Dialect isVisualWorks ifTrue: [sqlStream skip: self skipToString size].	"&lt;Grumble grumble&gt; stupid incompatibilities"	result := sqlStream upToEnd.	session platform supportsANSIJoins ifTrue: [		self assert: ('frequent_flyer t2 on *t1.id = t2.id*&lt;n&gt; where *t1.id = 1*' expandMacros match: result)]		ifFalse: [self assert:  ('*(t1.id = 1) and ((t1.id = t2.id*' match: result)].</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest</class-id> <category>tests-ordering</category><body package="GlorpDBTests" selector="testDoubleOrderSQL">testDoubleOrderSQL	| query sql |	query := SimpleQuery returningManyOf: GlorpAddress.	query orderBy: [:each | each id].	query orderBy: [:each | each number].	self setUpQueryFully: query.	sql := (query sqlWith: Dictionary new) sqlString.	self assert: ('* from gr_address t1 order by t1.id, t1.house_num' match: sql asLowercase).</body><body package="GlorpDBTests" selector="testOrderSQL">testOrderSQL	| query sql |	query := SimpleQuery returningManyOf: GlorpAddress.	query orderBy: [:each | each id].	self setUpQueryFully: query.	sql := (query sqlWith: Dictionary new) sqlString.	self assert: ('* from gr_address t1 order by t1.id' match: sql asLowercase).</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest</class-id> <category>support</category><body package="GlorpDBTests" selector="setUp">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests" selector="tearDown">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest class</class-id> <category>resources</category><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpInt4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testInt4">testInt4	self helpTestValue: nil.	self helpTestValue: 3212321.</body></methods><methods><class-id>Glorp.GlorpInt4Test</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform int4</body></methods><methods><class-id>Glorp.GlorpInt4Test class</class-id> <category>instance creation</category><body package="GlorpDBTypeTests" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpDemoTablePopulatorResource</class-id> <category>setup</category><body package="GlorpDBTests" selector="populateStuffTable">populateStuffTable 	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (12,''abc'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (13, ''hey nonny nonny'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (42, ''yabba dabba doo'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (9625, ''the band played on'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (113141, ''Smalltalk'')'.</body><body package="GlorpDBTests" selector="setUp">setUp		super setUp.	login := GlorpDatabaseLoginResource current.	self class needsSetup ifFalse: [^self].	login accessor doDDLOperation:			[GlorpTestDescriptorSystem glorpAllSubclasses				do: [:eachSystemClass | 					self setUpSystem: (eachSystemClass forPlatform: login platform) setUpDefaults].			self populateStuffTable].</body><body package="GlorpDBTests" selector="setUpSystem:">setUpSystem: system 	| errorBlock |	login accessor dropTables: ((TableSorter for: system allTables) sort reverse).	errorBlock := [:ex | Transcript show: ex description; cr. ex pass].	system platform areSequencesExplicitlyCreated ifTrue: [		login accessor dropSequences: system allSequences.		system allSequences do: [:each |			login accessor createSequence: each ifError: errorBlock]].	system allTables do: [:each | 			login accessor createTable: each				ifError: errorBlock].	system allTables do: [:each |			login accessor createTableIndexes: each ifError: errorBlock]. 	"SQLite3 doesn't support adding/dropping constraints."	system platform supportsConstraints ifTrue: [		system allTables do: [:each | 				login accessor createTableFKConstraints: each ifError: errorBlock]].	self class needsSetup: false</body></methods><methods><class-id>Glorp.GlorpDemoTablePopulatorResource class</class-id> <category>setup</category><body package="GlorpDBTests" selector="invalidateSetup">invalidateSetup	"GlorpDemoTablePopulatorResource invalidateSetup"	NeedsSetup := true.	self reset.</body><body package="GlorpDBTests" selector="needsSetup">needsSetup	NeedsSetup isNil ifTrue: [NeedsSetup := true].	^NeedsSetup</body><body package="GlorpDBTests" selector="needsSetup:">needsSetup: aBoolean	NeedsSetup := aBoolean.</body><body package="GlorpDBTests" selector="resources">resources	^Array with: GlorpDatabaseLoginResource.</body></methods><methods><class-id>Glorp.GlorpIntegerTest</class-id> <category>tests</category><body package="GlorpDBTypeTests" selector="testInteger">testInteger	type := (self platform) integer.	self helpTestValue: nil.	self helpTestValue: 3212321.</body></methods><methods><class-id>Glorp.GlorpIntegerTest</class-id> <category>types</category><body package="GlorpDBTypeTests" selector="defaultDatabaseType">defaultDatabaseType	^self platform integer.</body></methods><methods><class-id>Glorp.GlorpMoney</class-id> <category>accessing</category><body package="GlorpTestModels" selector="amount">amount	^amount</body><body package="GlorpTestModels" selector="amount:">amount: anInteger	amount := anInteger</body><body package="GlorpTestModels" selector="currency">currency	^currency</body><body package="GlorpTestModels" selector="currency:">currency: aSymbol	currency := aSymbol</body></methods><methods><class-id>Glorp.GlorpMoney class</class-id> <category>instance creation</category><body package="GlorpTestModels" selector="currency:amount:">currency: aSymbol amount: aNumber	^self new		currency: aSymbol;		amount: aNumber.</body><body package="GlorpTestModels" selector="defaultCurrency">defaultCurrency	^#CDN.</body><body package="GlorpTestModels" selector="forAmount:">forAmount: anAmount	^self currency: self defaultCurrency amount: anAmount.</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>utility</category><body package="GlorpDBTests" selector="createTables">createTables	"Create the tables for this descriptor system. This will fail if the tables already exist. Use recreateTables for that."	^self createTablesFor: GlorpDatabaseLoginResource current login.</body><body package="GlorpDBTests" selector="dropTables">dropTables	"Drop and re-create the tables for this descriptor system."	^self dropTablesFor: GlorpDatabaseLoginResource current login.</body><body package="GlorpDBTests" selector="recreateTables">recreateTables	"Drop and re-create the tables for this descriptor system."	^self recreateTablesFor: GlorpDatabaseLoginResource current login.</body></methods><methods><class-id>Core.Collection</class-id> <category>glorp</category><body package="GlorpTestModels" selector="assertEqual:">assertEqual: aCollection	"A convenience method for testing"	self asSortedCollection with: aCollection asSortedCollection do: [:a :b |		a assertEqual: b].</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>glorp</category><body package="GlorpTestModels" selector="assertEqual:">assertEqual: anObject	GlorpTestModelClass new assert: anObject = nil.</body></methods><initialize><class-id>Glorp.GlorpDescriptorSystemWithNamespacePoolDictionaryDeclarer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TestAsserter</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>DatabaseCommand</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useBinding stream sqlString session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>AbstractReadQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultClass whereClause base limit offset proxyType shouldRefresh tracing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><class><name>DatabaseAccessor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection currentLogin logging logger logOnly reusePreparedStatements deniedCommands mutex dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>TestResource</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>