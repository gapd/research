<?xml version="1.0"?><st-source><!-- Name: GlorpVWPortNotice: LGPL(S)The code is Copyright (C) 2000-2003  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USAComment: This is part of the GLORP system, an open-source library (LGPL(S)) for persisting Smalltalk objects in relational databases. For more information see the accompanying files and/or the web sites http://www.glorp.org or http://www.sourceforge.net/projects/glorpDbIdentifier: bear73DbTrace: 297795Namespace: GlorpPackageName: GlorpVWPortParcel: #('GlorpVWPort')ParcelName: GlorpVWPortPrintStringCache: (7.8 - 1001,sames)Version: 7.8 - 1001Date: 9:48:16 AM August 20, 2010 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (aug10.2) of August 13, 2010 on August 20, 2010 at 9:48:16 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Glorp</name><environment>Smalltalk</environment><private>false</private><imports>			Smalltalk.*			</imports><category>GlorpMisc</category><attributes><package>GlorpVWPort</package></attributes></name-space><comment><name-space-id>Glorp</name-space-id><body></body></comment><class><name>ProtoObject</name><environment>Smalltalk</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>ProtoObject</class-id><body>This is an abstract superclass for Proxies and other objects that subclass nil and implement a doesNotUnderstand: handler. Some dialects (e.g. Dolphin) provide this directly. For others it needs to be provided in the Glorp&lt;Dialect&gt;Port package/Application and provided with the appropriate set of methods.</body></comment><class><name>EphemeralValueDictionary</name><environment>Core</environment><super>Core.EphemeronDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>keepAround </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>Core.EphemeralValueDictionary</class-id><body>This is a weak equality dictionary where the values are the weak things, not the keys. So if no one references the value any longer, it will be deleted. </body></comment><class><name>EphemeralValue</name><environment>Kernel</environment><super>Kernel.Ephemeron</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Support</category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>Kernel.EphemeralValue</class-id><body>This is like an ephemeron, but the value rather than the key is the ephemeral thing. Implement key/key: and value/value: to swap the inst var usage. This can be confusing in inspectors.</body></comment><class><name>EqualOnContentReadStream</name><environment>Core</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>Core.EqualOnContentReadStream</class-id><body>Two EqualAdapterReadStreams are equal if their collections are equal.  This is the sole point of the class:  to avoid obstructing equality checks when using streams to adapt objects.</body></comment><methods><class-id>ProtoObject</class-id> <category>As yet unclassified</category><body package="GlorpVWPort" selector="==">== anObject	"Answer true if the receiver and the argument are the same object (have the same	object pointer) and false otherwise.  Do not redefine the message == in any	other class!  No Lookup."	&lt;primitive: 110&gt;	self primitiveFailed</body><body package="GlorpVWPort" selector="basicAt:">basicAt: index	"Answer the value of an indexable field in the receiver. Fail if the	argument index is not an Integer or is out of bounds. Do not override this	message in any subclass."	&lt;primitive: 60&gt;	index isInteger ifTrue: [^self subscriptBoundsErrorFor: #basicAt: index: index].	index respondsToArithmetic		ifTrue: [^self basicAt: index asSmallInteger]		ifFalse: [^self nonIntegerIndexError: index]</body><body package="GlorpVWPort" selector="basicSize">basicSize	"Answer the number of indexable fields in the receiver. This value is the	same as the largest legal subscript. Do not override in any subclass."	&lt;primitive: 62&gt;	"The number of indexable fields of fixed-length objects is 0"	^0</body><body package="GlorpVWPort" selector="become:">become: otherObject 	"Copy the regular VisualWorks primBecome:"	"Swap the instance data and appropriate header information of the receiver and the	 argument, otherObject. In other words, transform the receiver into the argument and	 vice-versa.  Fail if either object is an immediate or a MethodContext or a	 BlockContext or if there is insufficient memory to perform the become, or if either	 object is immutable. Answer with the argument which is now the semantic equivalent	 of the object that formerly denoted the receiver."	&lt;primitive: 72 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #primBecome: index: nil value: otherObject]		ifFalse: [self handleFailedBecome: otherObject]</body><body package="GlorpVWPort" selector="class">class	^ProtoObject</body><body package="GlorpVWPort" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	3 error: 'dNU on ProtoObject. This should never happen'.</body><body package="GlorpVWPort" selector="identityHash">identityHash	&lt;primitive: 75&gt;	self primitiveFailed</body><body package="GlorpVWPort" selector="inspect">inspect	"Create and schedule an Inspector in which the user can examine the	receiver's variables."	Tools.Trippy.Inspector useSimpleInspector		ifTrue: [Inspector openOn: self]		ifFalse: [Tools.Trippy.Inspector openOn: self]</body><body package="GlorpVWPort" selector="instVarAt:">instVarAt: index	"Answer with a fixed variable in an object.  The numbering of the variables	corresponds to the named instance variables.  Fail if the index is not an	Integer or is not the index of a fixed variable."	&lt;primitive: 73&gt;	"Access beyond fixed variables."	^self basicAt: index - self class instSize</body><body package="GlorpVWPort" selector="instVarAt:put:">instVarAt: anInteger put: anObject	"Store a value into a fixed variable in the receiver.  The numbering of	the variables corresponds to the named instance variables.  Fail if	the index is not an Integer or is not the index of a fixed variable.	Answer with the value stored as the result.  (Using this message	violates the principle that each object has sovereign control over the	storing of values into its instance variables.)."	&lt;primitive: 74&gt;	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject</body><body package="GlorpVWPort" selector="isImmediate">isImmediate	^false.</body><body package="GlorpVWPort" selector="isImmutable">isImmutable	"Answer if the receiver is immutable.  This is always true of immediates.	 Cannot fail."	&lt;primitive: 1063&gt;	^false</body><body package="GlorpVWPort" selector="nextObject">nextObject	"Answer with the next object following the receiver in	the enumeration of all non-immediate objects. Fail if there is no such	object or if the receiver is an immediate object. See ObjectMemory class	someObject."	&lt;primitive: 531&gt;	^0</body><body package="GlorpVWPort" selector="nilFields">nilFields</body><body package="GlorpVWPort" selector="noModificationErrorFor:index:value:">noModificationErrorFor: selector index: index value: value	^(NoModificationError receiver: self selector: selector index: index value: value) raiseRequest</body><body package="GlorpVWPort" selector="nonIntegerIndexError:">nonIntegerIndexError: index	"Raise a signal indicating that an improper object was used as an index."	^Object nonIntegerIndexSignal raiseWith: index</body><body package="GlorpVWPort" selector="performMethod:">performMethod: method	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver."	^self performMethod: method arguments: #()</body><body package="GlorpVWPort" selector="performMethod:arguments:">performMethod: method arguments: args	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the list of arguments of the method.	The number of arguments expected by the method must match the size of the	Array."	^method valueWithReceiver: self arguments: args</body><body package="GlorpVWPort" selector="performMethod:with:">performMethod: method with: arg1	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the argument of the method. The method	must be expecting one argument."	^self performMethod: method arguments: (Array with: arg1)</body><body package="GlorpVWPort" selector="primitiveFailed">primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	3 error: (#errPrimitiveFailed &lt;&lt; #dialogs &gt;&gt; 'a primitive has failed')</body><body package="GlorpVWPort" selector="subscriptBoundsErrorFor:index:">subscriptBoundsErrorFor: selector index: index	"Raise a signal indicating that an improper index was used as an index in a send of selector with index."	^(SubscriptOutOfBoundsError receiver: self selector: selector index: index value: nil) raiseRequest</body><body package="GlorpVWPort" selector="whileMutableDo:">whileMutableDo: aBlock	aBlock value.</body></methods><methods><class-id>ProtoObject</class-id> <category>printing</category><body package="GlorpVWPort" selector="forStackDumpPrintUsing:">forStackDumpPrintUsing: aPolicy	^aPolicy printObject: self</body></methods><methods><class-id>ProtoObject</class-id> <category>overrides</category><body package="GlorpVWPort" selector="inspectorActions">inspectorActions	"Answer a collection of Action instances listing the common actions	a user might want to perform on an object. They are added to the 	inspector's Object menu."	^#()</body><body package="GlorpVWPort" selector="inspectorClasses">inspectorClasses	^self getValue inspectorClasses.</body><body package="GlorpVWPort" selector="inspectorCollaborators">inspectorCollaborators	"Answer a collection of Collaborator instances listing the important other	objects a person looking at this one might want to see. For example,	collaborators of a view would be its model and the controller.	Collaborators are added to the inspector's Go menu."	^#()</body><body package="GlorpVWPort" selector="inspectorExtraAttributes">inspectorExtraAttributes	^#()</body><body package="GlorpVWPort" selector="inspectorHierarchies">inspectorHierarchies	^#()</body><body package="GlorpVWPort" selector="inspectorSize">inspectorSize	^0</body><body package="GlorpVWPort" selector="inspectorString">inspectorString	"For Object Studio compatibility"	^self printString.</body></methods><methods><class-id>ProtoObject</class-id> <category>doesNotUnderstand</category><body package="GlorpVWPort" selector="_isProxy">_isProxy	^true.</body></methods><methods><class-id>ProtoObject class</class-id> <category>LICENSE</category><body package="GlorpVWPort" selector="LICENSE">LICENSE	^'Copyright 2000-2004 Alan Knight.This class is part of the GLORP system (see http://www.glorp.org), licensed under the GNU Lesser General Public License, with clarifications with respect to Smalltalk library usage (LGPL(S)). This code is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the package comment, or the COPYING.TXT file that should accompany this distribution, or the GNU Lesser General Public License.'</body></methods><methods><class-id>ProtoObject class</class-id> <category>accessing</category><body package="GlorpVWPort" selector="toolListIcon">toolListIcon	^BehaviorIcons Proxy</body></methods><methods><class-id>Core.EphemeralValueDictionary</class-id> <category>accessing</category><body package="GlorpVWPort" selector="createKey:value:">createKey: key value: value	^(EphemeralValue key: key value: value) manager: manager</body></methods><methods><class-id>Core.EphemeralValueDictionary</class-id> <category>finalization</category><body package="GlorpVWPort" selector="mournKeyOf:">mournKeyOf: anEphemeron	"We always remove from the dictionary, whether or not we have an explicit manager"	manager == nil ifTrue:		[self error: (#noManagerToMourn &lt;&lt; #dialogs &gt;&gt; 'no manager to mourn')].	self removeKey: anEphemeron key ifAbsent: [].	manager == self ifFalse: [manager mournKeyOf: anEphemeron].</body></methods><methods><class-id>Core.EphemeralValueDictionary</class-id> <category>private</category><body package="GlorpVWPort" selector="findKeyOrNil:">findKeyOrNil: key  	"We want an equality dictionary, but ephemeron dictionaries are by identity. Override findKeyOrNil: back again to the super super implementation."	| location length probe pass |	length := self basicSize.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.	[(probe := self basicAt: location) == nil or: [probe key = key]]		whileFalse: 			[(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>Core.EphemeralValueDictionary class</class-id> <category>LICENSE</category><body package="GlorpVWPort" selector="LICENSE">LICENSE	^'Copyright 2000-2004 Alan Knight.This class is part of the GLORP system (see http://www.glorp.org), licensed under the GNU Lesser General Public License, with clarifications with respect to Smalltalk library usage (LGPL(S)). This code is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the package comment, or the COPYING.TXT file that should accompany this distribution, or the GNU Lesser General Public License.'</body></methods><methods><class-id>Kernel.EphemeralValue</class-id> <category>accessing</category><body package="GlorpVWPort" selector="key">key	^value.</body><body package="GlorpVWPort" selector="key:">key: anObject	value := anObject</body><body package="GlorpVWPort" selector="key:value:">key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	self key: aKey.	self value: anObject</body><body package="GlorpVWPort" selector="value">value	^key.</body><body package="GlorpVWPort" selector="value:">value: anObject	key := anObject.</body></methods><methods><class-id>Kernel.EphemeralValue</class-id> <category>comparing</category><body package="GlorpVWPort" selector="=">= anAssociation 	"Answer whether the receiver is equal to the argument."	^self class = anAssociation class and: [self key == anAssociation key]</body><body package="GlorpVWPort" selector="hash">hash	"I implement identity based comparison, rather than equality variant implemented in the superclass chain. We return a hash value here that is consistent with our local = method. See Object&gt;&gt;hash for more info on the hash/comparison invariant. Note that we are sneakily switching our key and value, which is why the reference to key needs to be a message send."	^self key identityHash</body></methods><methods><class-id>Kernel.EphemeralValue class</class-id> <category>LICENSE</category><body package="GlorpVWPort" selector="LICENSE">LICENSE	^'Copyright 2000-2004 Alan Knight.This class is part of the GLORP system (see http://www.glorp.org), licensed under the GNU Lesser General Public License, with clarifications with respect to Smalltalk library usage (LGPL(S)). This code is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the package comment, or the COPYING.TXT file that should accompany this distribution, or the GNU Lesser General Public License.'</body></methods><methods><class-id>Core.EqualOnContentReadStream</class-id> <category>comparing</category><body package="GlorpVWPort" selector="=">= anObject	^self class = anObject class and:		[self collection = anObject collection]</body><body package="GlorpVWPort" selector="hash">hash	^collection hash</body></methods><methods><class-id>Core.EqualOnContentReadStream</class-id> <category>private</category><body package="GlorpVWPort" selector="collection">collection	"Our hierarchy has this (with heavy warning against use) in some dialects, not in others.  We don't need the warning, given the limited use of this class, and must have it, so provide it in case it's not there in a superclass."	^collection</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GlorpVWPort" selector="atIndex:">atIndex: anIndex	"This method offers a way of providing polymorphism between me and classes that want to imitate me but cannot override #at: safely.  It is useful in cross-dialect applications such as Glorp.  Use at:, not this method, unless this polymorphism is wanted."	^self at: anIndex</body></methods><methods><class-id>Core.Number</class-id> <category>printing</category><body package="GlorpVWPort" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	"VisualWorks has this unpleasant habit of appending characters to anything float-like that's not actually an instance of Float, 	which happens way down in the guts of the printing, so it's hard to avoid. 	This seems to be the only reasonable way to work around it without resorting to inefficient and non-portable print policies.	In addition, the exponent character, d, is more universally understood as e."	| basic real |	basic := self printString.	real := basic last isDigit				ifTrue: [basic]				ifFalse: [basic copyFrom: 1 to: basic size - 1].	real := real asLowercase copyReplaceAll: 'd' with: 'e'.	aCommand nextPutAll: real</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>glorp</category><body package="GlorpVWPort" selector="asGlorpExpression">asGlorpExpression	^self asGlorpExpressionOn: BaseExpression new.</body><body package="GlorpVWPort" selector="asGlorpExpressionForDescriptor:">asGlorpExpressionForDescriptor: aDescriptor	| base |	base := BaseExpression new.	base descriptor: aDescriptor.	^self asGlorpExpressionOn: base.</body><body package="GlorpVWPort" selector="asGlorpExpressionOn:">asGlorpExpressionOn: anExpression 	^(self value: MessageArchiver new) asGlorpExpressionOn: anExpression</body><body package="GlorpVWPort" selector="asGlorpExpressionOn:in:">asGlorpExpressionOn: anExpression in: aQuery 	^(self value: (MessageArchiver new privateGlorpQuery: aQuery)) asGlorpExpressionOn: anExpression.</body><body package="GlorpVWPort" selector="asGlorpExpressionOn:withUltimateBase:">asGlorpExpressionOn: anExpression withUltimateBase: aBaseExpression	"Build the expression, knowing that some parts of it may refer to an outer context based on aBaseExpression. This is primarily useful for subselect blocks"	| archiver tree |	archiver := MessageArchiver new.	tree := self value: archiver.	^tree asGlorpExpressionOn: anExpression basedOn: archiver withUltimateBase: aBaseExpression.</body><body package="GlorpVWPort" selector="glorpIsBlock">glorpIsBlock	^true.</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="GlorpVWPort" selector="months">months	^self monthIndex.</body></methods><methods><class-id>Core.Timestamp</class-id> <category>accessing</category><body package="GlorpVWPort" selector="days">days	^self day.</body><body package="GlorpVWPort" selector="hours">hours	^self hour.</body><body package="GlorpVWPort" selector="milliseconds">milliseconds	^self millisecond.</body><body package="GlorpVWPort" selector="minutes">minutes	^self minute.</body><body package="GlorpVWPort" selector="monthIndex">monthIndex	^month</body><body package="GlorpVWPort" selector="months">months	^self month.</body><body package="GlorpVWPort" selector="seconds">seconds	^self second.</body><body package="GlorpVWPort" selector="years">years	^self year.</body></methods><methods><class-id>Core.Object class</class-id> <category>class initialization</category><body package="GlorpVWPort" selector="glorpAllSubclasses">glorpAllSubclasses	"We need an isolation layer here because ObjectStudio's allSubclasses returns symbols"	^self allSubclasses.</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="GlorpVWPort" selector="glorpEndOfIndexedInstVars">glorpEndOfIndexedInstVars	"Return the index at which indexed instance variables start. The same as basicSize for most dialects, but funny for ObjectStudio"	^self basicSize.</body><body package="GlorpVWPort" selector="glorpIsBlock">glorpIsBlock	^false.</body><body package="GlorpVWPort" selector="glorpStartOfIndexedInstVars">glorpStartOfIndexedInstVars	"Return the index at which indexed instance variables start. 1 for most dialects, but funny for ObjectStudio"	^1.</body></methods><methods><class-id>Core.Text</class-id> <category>printing</category><body package="GlorpVWPort" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand    self asString printOn: aCommand.</body></methods><methods><class-id>Core.Time</class-id> <category>accessing</category><body package="GlorpVWPort" selector="milliseconds">milliseconds	^0.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Ephemeron</name><environment>Kernel</environment><super>Kernel.WeakKeyAssociation</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Support</category><attributes><package>System-Support</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>EphemeronDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>accessLock manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>