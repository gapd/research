<?xml version="1.0"?><st-source><!-- Name: GlorpAnalysisNotice: LGPL(S)The code is Copyright (C) 2000-2003  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USAComment: This holds analysis tools (but portable, so not GUI tools) for use with Glorp. Basically written to hold a query performance analyzer that can keep track of queries executed and their time.DbIdentifier: bear73DbTrace: 296898DevelopmentPrerequisites: #(#(#bundle 'Glorp' '') #(#any 'GlorpVWPortNonBase' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #('PostgreSQLDriver')Namespace: GlorpPackageName: GlorpAnalysisParcel: #('GlorpAnalysis')ParcelName: GlorpAnalysisPrerequisiteParcels: #(#('Glorp' '') #('GlorpVWPortNonBase' ''))PrintStringCache: (7.7.1 - 2,dcaster)Version: 7.7.1 - 2Date: 2:38:05 PM August 13, 2010 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (aug10.2) of August 13, 2010 on August 13, 2010 at 2:38:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SQLite3ForeignKeyData</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id seq sourceTableName targetTableName sourceColumnName targetColumnName onUpdate onDelete match </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3ForeignKeyData</class-id><body>This class holds the data returned by a SQLite PRAGMA foreign_key_info( tablename ) query.</body></comment><class><name>MetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.MetadataDescriptorSystem</class-id><body>This is an abstract superclass for descriptor systems describing database metadata.</body></comment><class><name>OracleMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.MetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.OracleMetadataDescriptorSystem</class-id><body>This describes Oracle's non-standard metadata.</body></comment><class><name>InformationSchemaMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.MetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id><body>This is an abstract superclass for descriptor systems describing database metadata, for databases which conform at least reasonably closely to the information_schema standard.</body></comment><class><name>ReferentialConstraintTableMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.InformationSchemaMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</class-id><body>This is a base descriptor system for reading database information from a Postgresql and MS SQL Server databases, which have in common the REFERENTIAL_CONSTRAINTS table.</body></comment><class><name>SQLServerMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLServerMetadataDescriptorSystem</class-id><body>This is a descriptor system for reading database information from a SQLServer database.</body></comment><class><name>SQLite3DatabaseTable</name><environment>Glorp</environment><super>Glorp.DatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>foreignKeysData indexesData tableSql </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3DatabaseTable</class-id><body>This class temporarily substitutes for the DatabaseTable parent class during the meta-information gathering stage.It knows about SQLite3's special PRAGMA procs, and holds the SQLite3 specific intermediate pieces of information.In the end, members of this class know how to generate the usual DatabaseTable object from their own info, usingthe method &gt;&gt;asDatabaseTable.</body></comment><class><name>SQLite3MetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.MetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id><body>SQLiteMetadataDescriptorSystem describes SQLite's non-standard metadata.</body></comment><class><name>PostgresqlMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.PostgresqlMetadataDescriptorSystem</class-id><body>This is a base descriptor system for reading database information from a Postgresql database.</body></comment><class><name>SQLite3IndexColumnData</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seqno cid name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3IndexColumnData</class-id><body>This class holds the data returned by a SQLite PRAGMA index_info( indexname ) query.First, use the index_list() pragma for a given table name, to get the list of indexes.Then, use the index_info() pragma to get the relevent column information for eachreturned index name.Instance Variables	cid		&lt;Integer&gt;	Column id of the returned data. Can probably be ignored--use name instead.	name	&lt;String&gt;	Column name.	seqno	&lt;Integer&gt;	This column's position within the index, zero-based.</body></comment><class><name>ReferentialConstraint</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.ReferentialConstraint</class-id><body>Similar to PrimaryKeyConstraint, this is a class mostly used to increase our ability to easily refer to a table. We don't expect to ever actually read instances of it.</body></comment><class><name>GlorpSQLite3MetaSession</name><environment>Glorp</environment><super>Glorp.GlorpSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.GlorpSQLite3MetaSession</class-id><body>GlorpSqlite3MetaSession is a special subclass of GlorpSession which serves to impose restrictions on DatabaseTable and other metadescriptor-related classes. This is something of a hack, but seems to be the simplest way to acquire the information schema from SQLite. SQLite has no standard information schema tables, so the info-schema contents must be extracted from special Sqlite PRAGMA statements, which work much like stored procedures that return row sets.</body></comment><class><name>SQLite3IndexData</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seq name unique indexColumnsData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3IndexData</class-id><body>This class holds the data returned by a SQLite PRAGMA index_list( tablename ) query.See the comment for SQLiteIndexColumnData for more information about capturing theSQLite indexes data.Instance Variables	name	&lt;String&gt;	The index name.	seq		&lt;Integer&gt;	Can probably be ignored. For each table, the indexes are numbered from 0.	unique	&lt;Integer&gt;	1 means the index is unique, 0 else.</body></comment><class><name>GlorpQueryPerformanceAnalyzer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session commands </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id><body>This can keep track of the commands executed and the time taken, to provide information about how to optimize the query performance.</body></comment><class><name>MySQLMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.InformationSchemaMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.MySQLMetadataDescriptorSystem</class-id><body>This is a descriptor system for reading database information from a MySQL database.</body></comment><methods><class-id>Glorp.SQLite3ForeignKeyData</class-id> <category>accessing</category><body package="GlorpAnalysis" selector="id">id	^id</body><body package="GlorpAnalysis" selector="id:">id: anObject	id := anObject</body><body package="GlorpAnalysis" selector="match">match	^match</body><body package="GlorpAnalysis" selector="match:">match: anObject	match := anObject</body><body package="GlorpAnalysis" selector="onDelete">onDelete	^onDelete</body><body package="GlorpAnalysis" selector="onDelete:">onDelete: anObject	onDelete := anObject</body><body package="GlorpAnalysis" selector="onUpdate">onUpdate	^onUpdate</body><body package="GlorpAnalysis" selector="onUpdate:">onUpdate: anObject	onUpdate := anObject</body><body package="GlorpAnalysis" selector="seq">seq	^seq</body><body package="GlorpAnalysis" selector="seq:">seq: anObject	seq := anObject</body><body package="GlorpAnalysis" selector="sourceColumnName">sourceColumnName	^sourceColumnName</body><body package="GlorpAnalysis" selector="sourceColumnName:">sourceColumnName: anObject	sourceColumnName := anObject</body><body package="GlorpAnalysis" selector="sourceTableName">sourceTableName	^sourceTableName</body><body package="GlorpAnalysis" selector="sourceTableName:">sourceTableName: anObject	sourceTableName := anObject</body><body package="GlorpAnalysis" selector="targetColumnName">targetColumnName	^targetColumnName</body><body package="GlorpAnalysis" selector="targetColumnName:">targetColumnName: anObject	targetColumnName := anObject</body><body package="GlorpAnalysis" selector="targetTableName">targetTableName	^targetTableName</body><body package="GlorpAnalysis" selector="targetTableName:">targetTableName: anObject	targetTableName := anObject</body></methods><methods><class-id>Glorp.MetadataDescriptorSystem</class-id> <category>classes</category><body package="GlorpAnalysis" selector="classModelForDatabaseField:">classModelForDatabaseField: aClassModel	aClassModel newAttributeNamed: #table type: DatabaseTable.	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #isPrimaryKey type: Boolean.	aClassModel newAttributeNamed: #isNullable type: Boolean.	aClassModel newAttributeNamed: #isUnique type: Boolean.	aClassModel newAttributeNamed: #type type: GlorpDatabaseType.</body><body package="GlorpAnalysis" selector="classModelForDatabaseIndex:">classModelForDatabaseIndex: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #fields collectionOf: DatabaseField.</body><body package="GlorpAnalysis" selector="classModelForDatabaseTable:">classModelForDatabaseTable: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #schema type: String.	aClassModel newAttributeNamed: #fields collectionOf: DatabaseField.	aClassModel newAttributeNamed: #foreignKeyConstraints collectionOf: ForeignKeyConstraint.	aClassModel newAttributeNamed: #indexes collectionOf: DatabaseIndex.	aClassModel newAttributeNamed: #primaryKeyFields collectionOf: DatabaseField.</body><body package="GlorpAnalysis" selector="classModelForForeignKeyConstraint:">classModelForForeignKeyConstraint: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #sourceFields collectionOf: DatabaseField.	aClassModel newAttributeNamed: #targetFields collectionOf: DatabaseField.</body><body package="GlorpAnalysis" selector="classModelForNamedSequence:">classModelForNamedSequence: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #schema type: String.</body><body package="GlorpAnalysis" selector="classModelForPrimaryKeyConstraint:">classModelForPrimaryKeyConstraint: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #table type: DatabaseTable.</body></methods><methods><class-id>Glorp.MetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="descriptorForDatabaseField:">descriptorForDatabaseField: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis" selector="descriptorForDatabaseIndex:">descriptorForDatabaseIndex: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis" selector="descriptorForDatabaseTable:">descriptorForDatabaseTable: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis" selector="descriptorForForeignKeyConstraint:">descriptorForForeignKeyConstraint: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis" selector="descriptorForGlorpKeyColumnUsage:">descriptorForGlorpKeyColumnUsage: aDescriptor	self subclassResponsibility</body><body package="GlorpAnalysis" selector="descriptorForPrimaryKeyConstraint:">descriptorForPrimaryKeyConstraint: aDescriptor	self subclassResponsibility.</body></methods><methods><class-id>Glorp.MetadataDescriptorSystem class</class-id> <category>instance creation</category><body package="GlorpAnalysis" selector="concreteClassForPlatform:">concreteClassForPlatform: aPlatform	aPlatform isOraclePlatform ifTrue: [^OracleMetadataDescriptorSystem].	aPlatform isPostgreSQLPlatform ifTrue: [^PostgresqlMetadataDescriptorSystem].	aPlatform isMySQLPlatform ifTrue: [^MySQLMetadataDescriptorSystem].	aPlatform isSQLServerPlatform ifTrue: [^SQLServerMetadataDescriptorSystem].	aPlatform isSQLite3Platform ifTrue: [^SQLite3MetadataDescriptorSystem].	GlorpError signal: aPlatform class name, ' is not a supported platform for Glorp analysis.'</body><body package="GlorpAnalysis" selector="forPlatform:">forPlatform: aPlatform	^self == MetadataDescriptorSystem		ifTrue: [(self concreteClassForPlatform: aPlatform) forPlatform: aPlatform]		ifFalse: [super forPlatform: aPlatform].</body><body package="GlorpAnalysis" selector="sessionForLogin:">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system."	^aGlorpLogin database class = SQLite3Platform		ifTrue: [SQLite3MetadataDescriptorSystem sessionForLogin: aGlorpLogin]		ifFalse: [super sessionForLogin: aGlorpLogin]</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="descriptorForDatabaseField:">descriptorForDatabaseField: aDescriptor	| table usageTable constraintTable isPkMapping refTable typeField widthField |	table := self tableNamed: 'all_tab_columns'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'column_name').	(aDescriptor newMapping: OneToOneMapping) 		attributeName: #table.	(aDescriptor newMapping: DirectMapping) 		from: #isNullable to: (table fieldNamed: 'nullable');		converter: (self platform converterNamed: #booleanToStringYN).	typeField := table fieldNamed: 'data_type'.	widthField := table fieldNamed: self characterLengthFieldName.	(aDescriptor newMapping: AdHocMapping) 		forAttribute: #type		fromDb:	[:row :elementBuilder :context| 					self platform typeWithDatabaseName: (elementBuilder valueOfField: (context translateField: typeField)) characterWidth: (elementBuilder valueOfField: (context translateField: widthField))]		toDb: [:rows :attribute :attributeRows | 			(rows at: table) at: typeField put: (attribute typeName)]		mappingFields: (Array with: typeField with: widthField).	usageTable := self tableNamed: 'all_cons_columns'.	constraintTable := self tableNamed: 'all_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #primaryKeyConstraints;		referenceClass: PrimaryKeyConstraint;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'owner') to: (usageTable fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'owner') to: (constraintTable fieldNamed: 'owner')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  'P' to: (constraintTable fieldNamed: 'constraint_type')).	isPkMapping := (aDescriptor newMapping: DirectMapping) 		from: #isPrimaryKey 		to: [:each | each primaryKeyConstraints notEmpty].	isPkMapping shouldProxy: true.	refTable := self tableNamed: 'all_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #constraintsTargetingMe;		referenceClass: ReferentialConstraint;		beForPseudoVariable;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'position'];		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name')			from: (table fieldNamed: 'owner') to: (usageTable fieldNamed: 'owner'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (refTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'owner') to: (refTable fieldNamed: 'owner')).</body><body package="GlorpAnalysis" selector="descriptorForDatabaseIndex:">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis" selector="descriptorForDatabaseTable:">descriptorForDatabaseTable: aDescriptor	| table constraintTable |	table := self tableNamed: 'all_tables'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'table_name').	(aDescriptor newMapping: DirectMapping) from: 'schema' to: (table fieldNamed: 'owner').	(aDescriptor newMapping: ToManyMapping)		attributeName: #fields.	constraintTable := self tableNamed: 'all_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #foreignKeyConstraints;			referenceClass: ForeignKeyConstraint;		join: (Join			from: (table fieldNamed: 'owner') to: (constraintTable fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from: 'R' to: (constraintTable fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis" selector="descriptorForForeignKeyConstraint:">descriptorForForeignKeyConstraint: aDescriptor	| table usageTable columns targetFieldMapping |	table := self tableNamed: 'all_constraints'.	aDescriptor table: table.	aDescriptor directMapping from: 'name' to: (table fieldNamed: 'constraint_name').	"We have to make sure we map our primary keys directly. Otherwise we'll get into trying to use the relationship mappings to find foreign key values and it gets ugly. Make them pseudo-variables so we don't have to actually create inst vars for them."	(aDescriptor directMapping from: #schema to: (table fieldNamed: 'owner')) beForPseudoVariable.	(aDescriptor directMapping from: #tableName to: (table fieldNamed: 'table_name')) beForPseudoVariable.	(aDescriptor directMapping from: #tableSchema to: (table fieldNamed: 'owner')) beForPseudoVariable.	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	usageTable := self tableNamed: 'all_cons_columns'.	columns := self tableNamed: 'all_tab_columns'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #sourceFields;		referenceClass: DatabaseField;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'position'];		join: (Join			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'owner') to: (usageTable fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'owner') to: (columns fieldNamed: 'owner')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).	aDescriptor oneToOneMapping		attributeName: #table;		referenceClass: DatabaseTable;		beForPseudoVariable;		join: (Join 			from: (table fieldNamed: 'owner') to: ((self tableNamed: 'all_tables') fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: ((self tableNamed: 'all_tables') fieldNamed: 'table_name')).	targetFieldMapping := aDescriptor toManyMapping		attributeName: #targetFields;		join: [:eachField | eachField primaryKeyConstraints foreignKeyConstraintsUsingMeAsPrimaryKeyConstraint ] .	"Note that to get the link table to order by, we need to refer to it in terms of the relationship that controls it, not just ask the base for that table."	targetFieldMapping orderBy: [:eachField | (eachField primaryKeyConstraints getTable: usageTable) getField: 'position'].</body><body package="GlorpAnalysis" selector="descriptorForNamedSequence:">descriptorForNamedSequence: aDescriptor	| table |	table := self tableNamed: 'all_sequences'.	aDescriptor table: table.		aDescriptor directMapping from: 'name' to: (table fieldNamed: 'sequence_name').	aDescriptor directMapping from: 'schema' to: (table fieldNamed: 'sequence_owner').</body><body package="GlorpAnalysis" selector="descriptorForPrimaryKeyConstraint:">descriptorForPrimaryKeyConstraint: aDescriptor	| table constraintTable tableTable |	table := self tableNamed: 'all_constraints'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'constraint_name').	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	tableTable := self tableNamed: 'all_tables'.	aDescriptor oneToOneMapping		attributeName: #table;		join: (Join 			from: (table fieldNamed: 'table_name') to: (tableTable fieldNamed: 'table_name')			from: (table fieldNamed: 'owner') to: (tableTable fieldNamed: 'owner')).	constraintTable := self tableNamed: 'all_constraints'.	aDescriptor oneToOneMapping		attributeName: #foreignKeyConstraintsUsingMeAsPrimaryKeyConstraint;		referenceClass: ForeignKeyConstraint;		beForPseudoVariable;		join: (Join			from: (table fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'r_constraint_name')			from: (table fieldNamed: 'owner') to: (constraintTable fieldNamed: 'r_owner')			from: 'R' to: (constraintTable fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis" selector="descriptorForReferentialConstraint:">descriptorForReferentialConstraint: aDescriptor	| table |	table := self tableNamed: 'all_constraints'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'constraint_name').</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>accessing</category><body package="GlorpAnalysis" selector="allTableNames">allTableNames	^#()</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis" selector="tableForALL_CONSTRAINTS:">tableForALL_CONSTRAINTS: aTable	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'owner' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_type' type: (platform varchar: 255)) bePrimaryKey. 	(aTable createFieldNamed: 'r_constraint_name' type: (platform varchar: 255)).	(aTable createFieldNamed: 'r_owner' type: (platform varchar: 255)).</body><body package="GlorpAnalysis" selector="tableForALL_CONS_COLUMNS:">tableForALL_CONS_COLUMNS: aTable	(aTable createFieldNamed: 'owner' type: (platform varchar: 30)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 30)) bePrimaryKey.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 30)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 4000)) bePrimaryKey.	(aTable createFieldNamed: 'position' type: (platform int4)).</body><body package="GlorpAnalysis" selector="tableForALL_SEQUENCES:">tableForALL_SEQUENCES: aTable	| |	(aTable createFieldNamed: 'sequence_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'sequence_owner' type: (platform varchar: 255)) bePrimaryKey.</body><body package="GlorpAnalysis" selector="tableForALL_TABLES:">tableForALL_TABLES: aTable	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'owner' type: (platform varchar: 255)) bePrimaryKey.</body><body package="GlorpAnalysis" selector="tableForALL_TAB_COLUMNS:">tableForALL_TAB_COLUMNS: aTable	| tableName schema |	tableName := (aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	schema := (aTable createFieldNamed: 'owner' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'all_tables') fieldNamed: 'table_name')		from: schema to: ((self tableNamed: 'all_tables') fieldNamed: 'owner').	aTable createFieldNamed: 'column_id' type: platform int4.	aTable createFieldNamed: 'nullable' type: (platform char: 1).	aTable createFieldNamed: 'data_type' type: (platform varchar: 255).	aTable createFieldNamed: 'char_length' type: platform int4.	aTable createFieldNamed: 'data_precision' type: platform int4.</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>helpers</category><body package="GlorpAnalysis" selector="characterLengthFieldName">characterLengthFieldName	^'char_length'.</body><body package="GlorpAnalysis" selector="foreignKeyConstraintTypeString">foreignKeyConstraintTypeString	"Return the string we expect in the database table for constraints to distinguish foreign key constraints from others."	^'R'.</body><body package="GlorpAnalysis" selector="primaryKeyConstraintTypeString">primaryKeyConstraintTypeString	"Return the string we expect in the database table for constraints to distinguish primary key constraints from others."	^'P'.</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>classes</category><body package="GlorpAnalysis" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: DatabaseField;		add: DatabaseTable;		add: DatabaseIndex;		add: ForeignKeyConstraint;		add: PrimaryKeyConstraint;		add: ReferentialConstraint;		add: NamedSequence;		yourself.</body></methods><methods><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="descriptorForDatabaseField:">descriptorForDatabaseField: aDescriptor	"Map the Field object to the associated columns in the COLUMNS table.	The inst vars #type and #defaultValue use AdHocMappings, and their mappings	are described in their own respective methods, &gt;&gt;fieldTypeMappingFor:, and	&gt;&gt;fieldDefaultValueMappingFor:, as shown."	| table usageTable constraintTable isPkMapping |	table := self tableNamed: 'columns'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'column_name').	(aDescriptor newMapping: OneToOneMapping) 		attributeName: #table.	(aDescriptor newMapping: DirectMapping) 		from: #isNullable to: (table fieldNamed: 'is_nullable');		converter: (self platform converterNamed: #booleanToStringYesNo).	self fieldTypeMappingFor: aDescriptor.	self fieldDefaultValueMappingFor: aDescriptor.	usageTable := self tableNamed: 'key_column_usage'.	constraintTable := self tableNamed: 'table_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #primaryKeyConstraints;		referenceClass: PrimaryKeyConstraint;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'table_schema') to: (constraintTable fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  'PRIMARY KEY' to: (constraintTable fieldNamed: 'constraint_type')).	isPkMapping := (aDescriptor newMapping: DirectMapping) 		from: #isPrimaryKey 		to: [:each | each primaryKeyConstraints notEmpty].	isPkMapping shouldProxy: false.</body><body package="GlorpAnalysis" selector="descriptorForDatabaseIndex:">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis" selector="descriptorForDatabaseTable:">descriptorForDatabaseTable: aDescriptor	| table usageTable constraintTable |	table := self tableNamed: 'tables'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'table_name').	(aDescriptor newMapping: DirectMapping) from: 'schema' to: (table fieldNamed: 'table_schema').	(aDescriptor newMapping: ToManyMapping)		attributeName: #fields.	usageTable := self tableNamed: 'key_column_usage'.	constraintTable := self tableNamed: 'table_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #foreignKeyConstraints;		referenceClass: ForeignKeyConstraint;		useLinkTable;		join: (Join			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'table_schema') to: (constraintTable fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  'FOREIGN KEY' to: (constraintTable fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis" selector="descriptorForForeignKeyConstraint:">descriptorForForeignKeyConstraint: aDescriptor	| table usageTable columns targetFieldMapping |	table := self tableNamed: 'table_constraints'.	aDescriptor table: table.	aDescriptor directMapping from: #name to: (table fieldNamed: 'constraint_name').	"We have to make sure we map our primary keys directly. Otherwise we'll get into trying to use the relationship mappings to find foreign key values and it gets ugly. Make them pseudo-variables so we don't have to actually create inst vars for them."	(aDescriptor directMapping from: #schema to: (table fieldNamed: 'constraint_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #tableName to: (table fieldNamed: 'table_name')) beForPseudoVariable.	(aDescriptor directMapping from: #tableSchema to: (table fieldNamed: 'table_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	usageTable := self tableNamed: 'key_column_usage'.	columns := self tableNamed: 'columns'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #sourceFields;		referenceClass: DatabaseField;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'ordinal_position'];		join: (Join			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).	targetFieldMapping := aDescriptor toManyMapping		attributeName: #targetFields;		useLinkTable;		join: (Join 			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'referenced_table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'referenced_table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'referenced_column_name') to: (columns fieldNamed: 'column_name')).	targetFieldMapping orderBy: [:eachField | (eachField primaryKeyConstraints getTable: usageTable) getField: 'ordinal_position'].</body><body package="GlorpAnalysis" selector="descriptorForPrimaryKeyConstraint:">descriptorForPrimaryKeyConstraint: aDescriptor	"Note that this maps to the same table as a ForeignKeyConstraint, and I haven't bothered to do any inheritance, just relying on the joins in the relationships to distinguish the two. Also, we don't really have to map anything at all here, but the name is useful for telling instances apart, if we ever got instances."	| table tableTable |	table := self tableNamed: 'table_constraints'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'constraint_name').	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	tableTable := self tableNamed: 'tables'.	aDescriptor oneToOneMapping		attributeName: #table;		join: (Join 			from: (table fieldNamed: 'table_name') to: (tableTable fieldNamed: 'table_name')			from: (table fieldNamed: 'table_schema') to: (tableTable fieldNamed: 'table_schema')).</body><body package="GlorpAnalysis" selector="extraFieldsForTypeIn:">extraFieldsForTypeIn: table	"Return an additional fields we're going to need in order to determine the data type of a column."	^#().</body><body package="GlorpAnalysis" selector="fieldDefaultValueMappingFor:">fieldDefaultValueMappingFor: aDescriptor	"The DB keeps column_default as a string. Use this mapping to de-convert the string to our field's type.	For the mapping block to actually work, we need the builder's Field (called &gt;&gt;instance) to have	its type already built, since the block uses that GlorpType to understand the 'column_default' string."		| table defaultValueField |	table := aDescriptor table.	defaultValueField := table fieldNamed: 'column_default'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #defaultValue		fromDb:			[:row :elementBuilder :context | 			self platform				toGlorpType: (elementBuilder instance type)				fromString:					(elementBuilder valueOfField: (context translateField: defaultValueField))]		toDb: [:rows :attribute :attributeRows | ]		mappingFields: (Array with: defaultValueField)</body><body package="GlorpAnalysis" selector="fieldTypeMappingFor:">fieldTypeMappingFor: aDescriptor	| table typeField widthField |	table := aDescriptor table.	typeField := table fieldNamed: 'data_type'.	widthField := table fieldNamed: self characterLengthFieldName.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #type		fromDb:			[:row :elementBuilder :context | 			self platform				typeWithDatabaseName:					(elementBuilder valueOfField: (context translateField: typeField))				characterWidth:					(elementBuilder valueOfField: (context translateField: widthField))				extraInformation:					(self getExtraInformationFor: context inBuilder: elementBuilder)]		toDb:			[:rows :attribute :attributeRows | (rows at: table) at: typeField put: attribute typeName]		mappingFields: (Array with: typeField with: widthField), (self extraFieldsForTypeIn: table).</body><body package="GlorpAnalysis" selector="getExtraInformationFor:inBuilder:">getExtraInformationFor: aContext inBuilder: anElementBuilder	"If there's extra information we need to pass in to compute the data type, set it up here."</body></methods><methods><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis" selector="constraintsTable">constraintsTable	^self tableNamed: 'TABLE_CONSTRAINTS'.</body><body package="GlorpAnalysis" selector="informationSchemaName">informationSchemaName	"Return the name of the schema we'll use for the information_schema tables. Typically we'd expect that to be information_schema, but it isn't necessarily so."	^'INFORMATION_SCHEMA'.</body><body package="GlorpAnalysis" selector="tableForCOLUMNS:">tableForCOLUMNS: aTable	| tableName schema |	aTable schema: self informationSchemaName.	tableName := (aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	schema := (aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'tables') fieldNamed: 'table_name')		from: schema to: ((self tableNamed: 'tables') fieldNamed: 'table_schema').	aTable createFieldNamed: 'ordinal_position' type: platform int4.	aTable createFieldNamed: 'is_nullable' type: (platform boolean).	aTable createFieldNamed: 'data_type' type: (platform varchar: 255).	aTable createFieldNamed: 'column_default' type: (platform varchar: 255).	aTable createFieldNamed: 'character_maximum_length' type: platform int4.	aTable createFieldNamed: 'numeric_precision' type: platform int4.</body><body package="GlorpAnalysis" selector="tableForKEY_COLUMN_USAGE:">tableForKEY_COLUMN_USAGE: aTable	| columns constraints |	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'constraint_schema' type: (platform varchar: 255).	aTable createFieldNamed: 'ordinal_position' type: platform int4.	columns := self tableNamed: 'columns'.	aTable addForeignKeyFrom: (aTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')		from: (aTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')		from: (aTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name').	constraints := self constraintsTable.	aTable addForeignKeyFrom: (aTable fieldNamed: 'constraint_name') to: (constraints fieldNamed: 'constraint_name')		from: (aTable fieldNamed: 'constraint_schema') to: (constraints fieldNamed: 'constraint_schema').</body><body package="GlorpAnalysis" selector="tableForTABLES:">tableForTABLES: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'table_type' type: (platform varchar: 255).</body><body package="GlorpAnalysis" selector="tableForTABLE_CONSTRAINTS:">tableForTABLE_CONSTRAINTS: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_type' type: (platform varchar: 255)) bePrimaryKey.  "FOREIGN KEY"</body></methods><methods><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id> <category>helpers</category><body package="GlorpAnalysis" selector="characterLengthFieldName">characterLengthFieldName	^'character_maximum_length'.</body><body package="GlorpAnalysis" selector="foreignKeyConstraintTypeString">foreignKeyConstraintTypeString	"Return the string we expect in the database table for constraints to distinguish foreign key constraints from others."	^'FOREIGN KEY'.</body><body package="GlorpAnalysis" selector="primaryKeyConstraintTypeString">primaryKeyConstraintTypeString	"Return the string we expect in the database table for constraints to distinguish primary key constraints from others."	^'PRIMARY KEY'.</body></methods><methods><class-id>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="descriptorForDatabaseField:">descriptorForDatabaseField: aDescriptor	| table refTable usageTable |	super descriptorForDatabaseField: aDescriptor.	table := aDescriptor table.	usageTable := self tableNamed: 'key_column_usage'.	refTable := self tableNamed: 'referential_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #constraintsTargetingMe;		referenceClass: ReferentialConstraint;		beForPseudoVariable;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'ordinal_position'];		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_schema') to: (refTable fieldNamed: 'constraint_schema')			from: (usageTable fieldNamed: 'constraint_name') to: (refTable fieldNamed: 'constraint_name')).</body><body package="GlorpAnalysis" selector="descriptorForDatabaseIndex:">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis" selector="descriptorForDatabaseTable:">descriptorForDatabaseTable: aDescriptor	| table usageTable constraintTable |	table := self tableNamed: 'tables'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'table_name').	(aDescriptor newMapping: DirectMapping) from: 'schema' to: (table fieldNamed: 'table_schema').	(aDescriptor newMapping: ToManyMapping)		attributeName: #fields.	usageTable := self tableNamed: 'key_column_usage'.	constraintTable := self tableNamed: 'table_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #foreignKeyConstraints;		referenceClass: ForeignKeyConstraint;		useLinkTable;		join: (Join			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'table_schema') to: (constraintTable fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  'FOREIGN KEY' to: (constraintTable fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis" selector="descriptorForForeignKeyConstraint:">descriptorForForeignKeyConstraint: aDescriptor	| table usageTable columns targetFieldMapping |	table := self tableNamed: 'table_constraints'.	aDescriptor table: table.	aDescriptor directMapping from: #name to: (table fieldNamed: 'constraint_name').	"We have to make sure we map our primary keys directly. Otherwise we'll get into trying to use the relationship mappings to find foreign key values and it gets ugly. Make them pseudo-variables so we don't have to actually create inst vars for them."	(aDescriptor directMapping from: #schema to: (table fieldNamed: 'constraint_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #tableName to: (table fieldNamed: 'table_name')) beForPseudoVariable.	(aDescriptor directMapping from: #tableSchema to: (table fieldNamed: 'table_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	usageTable := self tableNamed: 'key_column_usage'.	columns := self tableNamed: 'columns'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #sourceFields;		referenceClass: DatabaseField;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'ordinal_position'];		join: (Join			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).	targetFieldMapping := aDescriptor toManyMapping		attributeName: #targetFields;		join: [:eachField | eachField primaryKeyConstraints foreignKeyConstraintsUsingMeAsPrimaryKeyConstraint ] .	"Note that to get the link table to order by, we need to refer to it in terms of the relationship that controls it, not just ask the base for that table."	targetFieldMapping orderBy: [:eachField | (eachField primaryKeyConstraints getTable: usageTable) getField: 'ordinal_position'].</body><body package="GlorpAnalysis" selector="descriptorForPrimaryKeyConstraint:">descriptorForPrimaryKeyConstraint: aDescriptor	"Note that this maps to the same table as a ForeignKeyConstraint, and I haven't bothered to do any inheritance, just relying on the joins in the relationships to distinguish the two. Also, we don't really have to map anything at all here, but the name is useful for telling instances apart, if we ever got instances."	| table constraintTable |	super descriptorForPrimaryKeyConstraint: aDescriptor.	table := aDescriptor primaryTable.	constraintTable := self tableNamed: 'referential_constraints'.	aDescriptor oneToOneMapping		attributeName: #foreignKeyConstraintsUsingMeAsPrimaryKeyConstraint;		referenceClass: ForeignKeyConstraint;		useLinkTable;		beForPseudoVariable;		join: (Join			from: (table fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'unique_constraint_name')			from: (table fieldNamed: 'constraint_schema') to: (constraintTable fieldNamed: 'unique_constraint_schema'));		reverseJoin: (Join 			from: (constraintTable fieldNamed: 'constraint_schema') to: (table fieldNamed: 'constraint_schema')			from: (constraintTable fieldNamed: 'constraint_name') to: (table fieldNamed: 'constraint_name')			from: 'FOREIGN KEY' to: (table fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis" selector="descriptorForReferentialConstraint:">descriptorForReferentialConstraint: aDescriptor	"We don't really have to map anything at all here to real variables, but the name is useful for telling instances apart, if we ever got instances. Other than that everything is pseudovariables"	| table usageTable columns |	table := self tableNamed: 'referential_constraints'.	aDescriptor table: table.		aDescriptor directMapping from: 'name' to: (table fieldNamed: 'constraint_name').	usageTable := self tableNamed: 'key_column_usage'.	columns := self tableNamed: 'columns'.	aDescriptor oneToOneMapping		attributeName: #targetField;		referenceClass: DatabaseField;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'unique_constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'unique_constraint_schema') to: (usageTable fieldNamed: 'constraint_schema'));		reverseJoin: (Join 			from: (usageTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).</body></methods><methods><class-id>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis" selector="allTableNames">allTableNames	^#(columns key_column_usage referential_constraints tables table_constraints)</body><body package="GlorpAnalysis" selector="constraintsTable">constraintsTable	^self tableNamed: 'referential_constraints'.</body><body package="GlorpAnalysis" selector="tableForREFERENTIAL_CONSTRAINTS:">tableForREFERENTIAL_CONSTRAINTS: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_schema' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'unique_constraint_schema' type: (platform varchar: 255).	aTable createFieldNamed: 'unique_constraint_name' type: (platform varchar: 255).	aTable createFieldNamed: 'table_name' type: (platform varchar: 255).</body></methods><methods><class-id>Glorp.SQLServerMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="fieldTypeMappingFor:">fieldTypeMappingFor: aDescriptor	"For SQL Server, we can find out if this is an IDENTITY column only by calling a special function called COLUMNPROPERTY."		| table isIDMapping columnField schemaField tableField |	table := aDescriptor table.	schemaField := table fieldNamed: 'table_schema'.	tableField := table fieldNamed: 'table_name'.	columnField := table fieldNamed: 'column_name'.	isIDMapping := (aDescriptor newMapping: DirectMapping)		fromPseudoVariable: #isIdentityColumn		type: Integer		to:			([:each | 				| tableExp objectId | 				tableExp := each getTable: table.				objectId := ((tableExp getField: schemaField) , '.', (tableExp getField: tableField)) objectId.				objectId columnPropertySchema: (tableExp getField: columnField) property: 'IsIdentity']			asGlorpExpressionForDescriptor: aDescriptor).	isIDMapping readOnly: true.	isIDMapping shouldProxy: false.	^super fieldTypeMappingFor: aDescriptor</body><body package="GlorpAnalysis" selector="getExtraInformationFor:inBuilder:">getExtraInformationFor: aContext inBuilder: anElementBuilder	"SQL Server identity column information."		| field mapping |	mapping := anElementBuilder descriptor mappingForAttributeNamed:			#isIdentityColumn.	field := anElementBuilder fieldTranslations keys		detect: [:each | each name asSymbol = #COLUMNPROPERTY].	^( (mapping valueInBuilder: anElementBuilder as: field) = 1) ifTrue: ['IDENTITY'] ifFalse: [nil].</body></methods><methods><class-id>Glorp.SQLite3DatabaseTable</class-id> <category>accessing</category><body package="GlorpAnalysis" selector="foreignKeysData">foreignKeysData	^foreignKeysData</body><body package="GlorpAnalysis" selector="foreignKeysData:">foreignKeysData: anObject	foreignKeysData := anObject</body><body package="GlorpAnalysis" selector="hasAutoIncrement">hasAutoIncrement	"Return true if my original create table statement sql has an auto increment primary key:	INTEGER PRIMARY KEY AUTOINCREMENT. This means my pkey column is Serial.	With SQLite3, a field declared this way automatically gets ROWID value from a	private sequence table. (This method can be tricked if the sql contains CRs or Tabs.)"	| sql |	^(sql := self tableSql)		ifNil: [false]		ifNotNil: 			[((sql asUppercase copyWithout: Character space)				indexOfSubCollection: 'INTEGERPRIMARYKEYAUTOINCREMENT'				startingAt: 1) &gt; 0]</body><body package="GlorpAnalysis" selector="indexesData">indexesData	^indexesData</body><body package="GlorpAnalysis" selector="indexesData:">indexesData: anObject	indexesData := anObject</body><body package="GlorpAnalysis" selector="tableSql">tableSql	^tableSql</body><body package="GlorpAnalysis" selector="tableSql:">tableSql: anObject	tableSql := anObject</body></methods><methods><class-id>Glorp.SQLite3DatabaseTable</class-id> <category>fields</category><body package="GlorpAnalysis" selector="addForeignKeyFromAll:toAll:suffixExpression:">addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: suffixExpression	"Generate the foreign key using these source and target fields, which are likely proxy objects.	This method assigns a temporary name to avoid endless recursion. Later, after the proxies	have been instantiated, a	proper name is regenerated."	| newFK |	newFK := ForeignKeyConstraint				sourceFields: sourceFields				targetFields: targetFields				suffixExpression: suffixExpression.	newFK name: 'ForeignKeyNumber_' , (foreignKeyConstraints size + 1) printString.	^foreignKeyConstraints add: newFK</body></methods><methods><class-id>Glorp.SQLite3DatabaseTable</class-id> <category>converting</category><body package="GlorpAnalysis" selector="asDatabaseTable">asDatabaseTable	"This is where we switch from this subclass, which exists purely to gather info from	SQLite's PRAGMAs, to become its super class, DatabaseTable. Before throwing away	the special index and foreign key information, figure out which columns are unique,	generate the primaryKeyFields list, and switch the #fields &gt;&gt;table references to their	replacement table object."	| table ivarName |	self findUniqueColumns.	self findPrimaryKeyFields.	table := DatabaseTable new.	#(#name #schema #fields #foreignKeyConstraints #indexes #parent #lockKeyFields #primaryKeyFields #isImaginary #replacementSubSelect)		do: 			[:ivar |			ivarName := ivar asString.			table instVarNamed: ivarName put: (self instVarNamed: ivarName)].	table fields do: [:fld| fld table: table].	^table</body><body package="GlorpAnalysis" selector="findPrimaryKeyFields">findPrimaryKeyFields	"This method isn't strictly necessary, since the pkey info is already available and the	lazy accessor will gather them if necessary. But, this method calculates them in	the official pkey sequence order, which can be useful for comparisson purposes, and	if nothing else, it serves as a check comparing index contents with the pkey field flag.	Check each index to see if it is both unique and has all the expected pkey columns.	Save primaryKeyFields according to the index 'seqno' information.	Possible wrong sort order if there is a separate unique index on the pkey columns,	and we compare that index before we get to the true pkey index."	| pknames match pkFields pkSet |	pkFields := self fields select: [:fld | fld isPrimaryKey].	pknames := pkFields collect: [:fld | fld name].	pkSet := pknames asSet.	match := self indexesData detect: 					[:indexDat |					indexDat unique = 1						ifTrue: [pkSet = indexDat columnNames asSet]						ifFalse: [false]]				ifNone: [].	match ifNotNil: [primaryKeyFields := match asOrderedFieldsForTable: self]</body><body package="GlorpAnalysis" selector="findUniqueColumns">findUniqueColumns	"Check each index to see if it is both unique and has just one column.	If true, then assign the corresponding DatabaseField isUnique: true."	| uniqueField cols |	self indexesData do: 			[:indexDat |			uniqueField := indexDat unique = 1						ifTrue: 							[cols := indexDat columnNames.							cols size = 1								ifTrue: 									[self fields detect: [:fld | fld name = cols first]										ifNone: [self error: (#CannotFindUniqueIndex &lt;&lt; #store &gt;&gt;'Cannot find unique-indexed column.')]]].			uniqueField ifNotNil: [uniqueField isUnique: true]]</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="descriptorForDatabaseField:">descriptorForDatabaseField: aDescriptor	"Map the Field object to the associated columns in the COLUMNS table.	Note that we cannot get the table name in the retrieved rows because that	info is not returned from the SQLite pragma. We can only map to what is	returned by the pseudo query. So, the table reference is back-filled later."	| table |	table := self tableNamed: 'columns'.	aDescriptor table: table.		"(aDescriptor newMapping: OneToOneMapping)		attributeName: #table."	(aDescriptor newMapping: DirectMapping)		from: 'position' to: (table fieldNamed: 'cid').	(aDescriptor newMapping: DirectMapping)		from: 'name' to: (table fieldNamed: 'name').	(aDescriptor newMapping: DirectMapping) 		from: 'isNullable' to: (table fieldNamed: 'notnull').	"(aDescriptor newMapping: DirectMapping) 		from: 'type' to: (table fieldNamed: 'type')."	self fieldTypeMappingFor: aDescriptor.	(aDescriptor newMapping: DirectMapping) 		from: 'defaultValue' to: (table fieldNamed: 'dflt_value').	(aDescriptor newMapping: DirectMapping) 		from: 'isPrimaryKey' to: (table fieldNamed: 'pk').</body><body package="GlorpAnalysis" selector="descriptorForDatabaseIndex:">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis" selector="descriptorForDatabaseTable:">descriptorForDatabaseTable: aDescriptor</body><body package="GlorpAnalysis" selector="descriptorForForeignKeyConstraint:">descriptorForForeignKeyConstraint: aDescriptor	" *** This method was defined by Glorp.MetadataDescriptorSystem as a subclass responsibility.	Replace its body with a proper implementation. *** "</body><body package="GlorpAnalysis" selector="descriptorForPrimaryKeyConstraint:">descriptorForPrimaryKeyConstraint: aDescriptor	" *** This method was defined by Glorp.MetadataDescriptorSystem as a subclass responsibility.	Replace its body with a proper implementation. *** "</body><body package="GlorpAnalysis" selector="descriptorForSQLite3DatabaseTable:">descriptorForSQLite3DatabaseTable: aDescriptor	"SELECT * FROM sqlite_master WHERE type = 'table' AND 'name' = ?"	"type name tbl_name rootpage sql"	"Note, fwiw, that for type='table' entries, name and tbl_name fields will have the same value."	| table |	table := self tableNamed: 'sqlite_master'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #type to: (table fieldNamed: 'type').	(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'name').	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #tbl_name to: (table fieldNamed: 'tbl_name').	(aDescriptor newMapping: DirectMapping) from: #tableSql to: (table fieldNamed: 'sql').	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #fields;		shouldProxy: false.	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #foreignKeysData;		shouldProxy: false.	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #indexesData;		shouldProxy: false.</body><body package="GlorpAnalysis" selector="descriptorForSQLite3ForeignKeyData:">descriptorForSQLite3ForeignKeyData: aDescriptor      "PRAGMA foreign_key_list(table-name);"	"id seq table from to on_update on_delete match"	"As if from a query like this:	SELECT id, seq, sourceTable, from, table, to ORDER BY id, seq WHERE sourceTable = ?"	| fkeysTable |	fkeysTable := self tableNamed: 'foreign_keys'.	aDescriptor table: fkeysTable.		((aDescriptor newMapping: DirectMapping)		from: 'id' to: (fkeysTable fieldNamed: 'id')).  "which column id (not column name)."	((aDescriptor newMapping: DirectMapping)		from: 'seq' to: (fkeysTable fieldNamed: 'seq')).  "which position in the fkey."	((aDescriptor newMapping: DirectMapping) 		from: 'targetTableName' to: (fkeysTable fieldNamed: 'table')).  "the pkey table."	((aDescriptor newMapping: DirectMapping) 		from: 'sourceColumnName' to: (fkeysTable fieldNamed: 'from')). "my fkey column."	((aDescriptor newMapping: DirectMapping) 		from: 'targetColumnName' to: (fkeysTable fieldNamed: 'to')).   "the pkey column."	"The following fields are absent in earlier SQLite 3 dlls, so we ignore them.	((aDescriptor newMapping: DirectMapping) 		from: 'onUpdate' to: (fkeysTable fieldNamed: 'on_update')). 	((aDescriptor newMapping: DirectMapping) 		from: 'onDelete' to: (fkeysTable fieldNamed: 'on_delete')).	((aDescriptor newMapping: DirectMapping) 		from: 'match' to: (fkeysTable fieldNamed: 'match'))."</body><body package="GlorpAnalysis" selector="descriptorForSQLite3IndexColumnData:">descriptorForSQLite3IndexColumnData: aDescriptor      "PRAGMA index_list(table-name);"	"seq name unique"	| indexColumnsTable |	indexColumnsTable := self tableNamed: 'index_info'.	aDescriptor table: indexColumnsTable.		((aDescriptor newMapping: DirectMapping)		from: 'seqno' to: (indexColumnsTable fieldNamed: 'seqno')).  	"The index column sequence number."	((aDescriptor newMapping: DirectMapping) 		from: 'cid' to: (indexColumnsTable fieldNamed: 'cid')).			"The column id, which we don't use."	((aDescriptor newMapping: DirectMapping) 		from: 'name' to: (indexColumnsTable fieldNamed: 'name')).  	"The name of the column, which we use."</body><body package="GlorpAnalysis" selector="descriptorForSQLite3IndexData:">descriptorForSQLite3IndexData: aDescriptor      "PRAGMA index_list(table-name);"	"seq name unique"	| indexesTable |	indexesTable := self tableNamed: 'index_list'.	aDescriptor table: indexesTable.		((aDescriptor newMapping: DirectMapping) 		from: 'name' to: (indexesTable fieldNamed: 'name')).  "The name of the index."	((aDescriptor newMapping: DirectMapping)		from: 'seq' to: (indexesTable fieldNamed: 'seq')).  "The index number, which we don't use."	((aDescriptor newMapping: DirectMapping) 		from: 'unique' to: (indexesTable fieldNamed: 'unique')). "If the index is unique, 1, otherwise, 0."	"collection of SQLiteIndexColumnData."	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #indexColumnsData;		shouldProxy: false.</body><body package="GlorpAnalysis" selector="fieldTypeMappingFor:">fieldTypeMappingFor: aDescriptor	| table typeField |	table := aDescriptor table.	typeField := table fieldNamed: 'type'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #type		fromDb:			[:row :elementBuilder :context | 			self platform				typeWithDatabaseName:					(elementBuilder valueOfField: (context translateField: typeField))				characterWidth: 0				extraInformation: #()]		toDb:			[:rows :attribute :attributeRows | ]		mappingFields: (Array with: typeField).</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>classes</category><body package="GlorpAnalysis" selector="classModelForSQLite3DatabaseTable:">classModelForSQLite3DatabaseTable: aClassModel	super classModelForDatabaseTable: aClassModel.	aClassModel newAttributeNamed: #foreignKeysData collectionOf: SQLite3ForeignKeyData.	aClassModel newAttributeNamed: #indexesData collectionOf: SQLite3IndexData.	aClassModel newAttributeNamed: #tableSql type: String.</body><body package="GlorpAnalysis" selector="classModelForSQLite3ForeignKeyData:">classModelForSQLite3ForeignKeyData: aClassModel	"id seq table from to on_update on_delete match"	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #seq type: Integer.	aClassModel newAttributeNamed: #sourceTableName type: String.	aClassModel newAttributeNamed: #targetTableName type: String.	aClassModel newAttributeNamed: #sourceColumnName type: String.	aClassModel newAttributeNamed: #targetColumnName type: String."	The following fields are absent in older SQLite 3 dlls.	aClassModel newAttributeNamed: #onUpdate type: String.	aClassModel newAttributeNamed: #onDelete type: String.	aClassModel newAttributeNamed: #match type: String."</body><body package="GlorpAnalysis" selector="classModelForSQLite3IndexColumnData:">classModelForSQLite3IndexColumnData: aClassModel	aClassModel newAttributeNamed: #seqno type: Integer.	aClassModel newAttributeNamed: #cid type: Integer.	aClassModel newAttributeNamed: #name type: String.</body><body package="GlorpAnalysis" selector="classModelForSQLite3IndexData:">classModelForSQLite3IndexData: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #seq type: Integer.	aClassModel newAttributeNamed: #unique type: Integer.	aClassModel newAttributeNamed: #indexColumnsData collectionOf: SQLite3IndexColumnData.</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis" selector="tableForCOLUMNS:">tableForCOLUMNS: aTable	"PRAGMA table_info(table-name)"	"cid name type notnull dflt_value pk"	| tableName |	tableName := (aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'sqlite_master') fieldNamed: 'tbl_name').	(aTable createFieldNamed: 'cid' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'type' type: platform int4.	aTable createFieldNamed: 'notnull' type: platform boolean.	aTable createFieldNamed: 'dflt_value' type: (platform varchar: 255).	aTable createFieldNamed: 'pk' type: platform boolean</body><body package="GlorpAnalysis" selector="tableForFOREIGN_KEYS:">tableForFOREIGN_KEYS: aTable      "PRAGMA foreign_key_list(table-name);"	"id seq table from to on_update on_delete match"	"This function returns a collection of fkey columns for aTable, mapped to pkey columns of 'table'."	| tableName |	tableName := (aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'sqlite_master') fieldNamed: 'tbl_name').	(aTable createFieldNamed: 'id' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'seq' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'from' type: (platform varchar: 255).	aTable createFieldNamed: 'to' type: (platform varchar: 255).	aTable createFieldNamed: 'on_update' type: (platform varchar: 255).	aTable createFieldNamed: 'on_delete' type: (platform varchar: 255).	aTable createFieldNamed: 'match' type: (platform varchar: 255).</body><body package="GlorpAnalysis" selector="tableForINDEX_INFO:">tableForINDEX_INFO: aTable	"seqno cid name"	| tableName |	tableName := (aTable createFieldNamed: 'index_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'index_list') fieldNamed: 'name').	(aTable createFieldNamed: 'seqno' type: (platform int4)) bePrimaryKey.	(aTable createFieldNamed: 'cid' type: (platform int4)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255))</body><body package="GlorpAnalysis" selector="tableForINDEX_LIST:">tableForINDEX_LIST: aTable	"seq name unique"	| tableName |	tableName := (aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'sqlite_master') fieldNamed: 'tbl_name').	(aTable createFieldNamed: 'seq' type: (platform int4)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'unique' type: (platform int4))</body><body package="GlorpAnalysis" selector="tableForSQLITE_MASTER:">tableForSQLITE_MASTER: aTable	"SELECT * FROM sqlite_master WHERE type = 'table'."	"type can be TABLE, VIEW or INDEX"	"type name tbl_name rootpage sql"	(aTable createFieldNamed: 'type' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)).	(aTable createFieldNamed: 'rootpage' type: (platform varchar: 255)).	(aTable createFieldNamed: 'sql' type: (platform varchar: 255))</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>accessing</category><body package="GlorpAnalysis" selector="allClasses">allClasses	allClasses isEmpty ifTrue: [allClasses := self constructAllClasses asSet asOrderedCollection].	^allClasses</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>session creation</category><body package="GlorpAnalysis" selector="sessionForLogin:">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| newSession |	platform isNil ifTrue: [self platform: aGlorpLogin database].	aGlorpLogin database class = self platform class ifFalse: [self error: 'Login is incompatible with the database specified in the descriptor system'].	newSession := GlorpSQLite3MetaSession new.	newSession accessor: (DatabaseAccessor forLogin: aGlorpLogin).	newSession system: self.	^newSession.</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>initialize-release</category><body package="GlorpAnalysis" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"self useDirectAccessForMapping: false."	^self</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem class</class-id> <category>instance creation</category><body package="GlorpAnalysis" selector="sessionForLogin:">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| system session |	system := self forPlatform: aGlorpLogin database.	session :=  GlorpSQLite3MetaSession new.	session accessor: (DatabaseAccessor forLogin: aGlorpLogin).	session system: system.	^session.</body></methods><methods><class-id>Glorp.PostgresqlMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="descriptorForNamedSequence:">descriptorForNamedSequence: aDescriptor	"Really, we need to filter named sequences according to relkind='S', which is probably most easily done using filtered inheritance, but since we're going to be retrieving them specifically by name one at a time anyway, this should be adequate."	| table |	table := self tableNamed: 'pg_class'.	aDescriptor table: table.		aDescriptor directMapping from: 'name' to: (table fieldNamed: 'relname').</body></methods><methods><class-id>Glorp.PostgresqlMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis" selector="tableForPG_CLASS:">tableForPG_CLASS: aTable	| |	aTable schema: 'PG_CATALOG'.	(aTable createFieldNamed: 'relname' type: (platform varchar: 255)) bePrimaryKey.</body></methods><methods><class-id>Glorp.SQLite3IndexColumnData</class-id> <category>accessing</category><body package="GlorpAnalysis" selector="cid">cid	^cid</body><body package="GlorpAnalysis" selector="cid:">cid: anObject	cid := anObject</body><body package="GlorpAnalysis" selector="name">name	^name</body><body package="GlorpAnalysis" selector="name:">name: anObject	name := anObject</body><body package="GlorpAnalysis" selector="seqno">seqno	^seqno</body><body package="GlorpAnalysis" selector="seqno:">seqno: anObject	seqno := anObject</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>api/queries</category><body package="GlorpAnalysis" selector="readManyOf:">readManyOf: aClass	^aClass = DatabaseTable		ifTrue: [self readManyOfDatabaseTableWhere: nil limit: nil orderBy: nil]		ifFalse: [super readManyOf: aClass]</body><body package="GlorpAnalysis" selector="readManyOf:limit:">readManyOf: aClass limit: anInteger	^aClass = DatabaseTable		ifTrue: [self readManyOfDatabaseTableWhere: nil limit: anInteger orderBy: nil]		ifFalse: [super readManyOf: aClass limit: anInteger]</body><body package="GlorpAnalysis" selector="readManyOf:orderBy:">readManyOf: aClass orderBy: aCriteria	^aClass = DatabaseTable		ifTrue: [self readManyOfDatabaseTableWhere: nil limit: nil orderBy: aCriteria]		ifFalse: [super readManyOf: aClass orderBy: aCriteria]</body><body package="GlorpAnalysis" selector="readManyOf:where:">readManyOf: aClass where: aBlock	^aClass = DatabaseTable		ifTrue: [self readManyOfDatabaseTableWhere: aBlock limit: nil orderBy: nil]		ifFalse: [super readManyOf: aClass where: aBlock]</body><body package="GlorpAnalysis" selector="readManyOf:where:limit:">readManyOf: aClass where: aBlock limit: anInteger	^aClass = DatabaseTable		ifTrue: [self readManyOfDatabaseTableWhere: aBlock limit: anInteger orderBy: nil]		ifFalse: [super readManyOf: aClass where: aBlock  limit: anInteger]</body><body package="GlorpAnalysis" selector="readOneOf:">readOneOf: aClass	^aClass = DatabaseTable		ifTrue: [self readOneOfDatabaseTableWhere: nil ]		ifFalse: [super readOneOf: aClass]</body><body package="GlorpAnalysis" selector="readOneOf:where:">readOneOf: aClass where: aBlock	^aClass = DatabaseTable		ifTrue: [self readOneOfDatabaseTableWhere: aBlock]		ifFalse: [super readOneOf: aClass where: aBlock]</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>private-sqlite</category><body package="GlorpAnalysis" selector="databaseTablesFromSqliteDatabaseTables:">databaseTablesFromSqliteDatabaseTables: queryResults	"Return the cached DatabaseTable versions of these raw SqliteDatabaseTable query results.	Those raw tables which are not already in the cache must be converted and added to the cache.	In addition, their target tables will also be read and added to the cache."	| newTables |	newTables := self updateSQLiteTableData: queryResults.	newTables do: [:aTable | self cacheAt: aTable name asUppercase put: aTable].	newTables do: 			[:aTable |			aTable foreignKeyConstraints do: 					[:constraint |					| fields |					fields := self fromProxies: constraint sourceFields.					constraint sourceFields: fields.					fields := self fromProxies: constraint targetFields.					constraint targetFields: fields]].	newTables do: 			[:aTable |			aTable foreignKeyConstraints do: 					[:constraint |					constraint name: nil.					constraint name]].	"Now that we've read and cached the full extent of connected tables, return the original query results."	^queryResults		collect: [:anSqliteTable | self cachedTableNamed: anSqliteTable name asUppercase]</body><body package="GlorpAnalysis" selector="findForeignKeysForTable:">findForeignKeysForTable: aRawTable	"SQLite pragmas provide only the fkey source and target field and table names. This method	generates the corresponding foreignKeyConstraint objects. The parameter is a SqliteDatabaseTable	representing the DatabaseTable that we are in the process of instantiating from the meta info.	Constraint source and target fields which are not in the cache (DatabaseTable) are represented as proxy	objects to be resolved later."	| sqliteFKeys keyIds |	sqliteFKeys := aRawTable foreignKeysData.	keyIds := (sqliteFKeys collect: [:fkey | fkey id]) asSet.	keyIds do: 			[:keyId |			| keyColsUnsorted sourceFields targetFields keyCols |			keyColsUnsorted := sqliteFKeys select: [:fkey | fkey id = keyId].			keyCols := (keyColsUnsorted asSortedCollection: [:a :b | a seq &lt;= b seq]) asArray.			sourceFields := keyCols collect: 							[:fkey |							| tableName fieldName sourceTable |							tableName := fkey sourceTableName asUppercase.							fieldName := fkey sourceColumnName asUppercase.							(sourceTable := self cachedTableNamed: tableName)								ifNil: [self proxyForField: fieldName ofTable: tableName]								ifNotNil: 									[sourceTable fields detect: [:fld | fld name asUppercase = fieldName]										ifNone: [self error: 'fkey sourceField is from self, yet not found.']]].			targetFields := keyCols collect: 							[:fkey |							| tableName fieldName targetTable |							tableName := fkey targetTableName asUppercase.							fieldName := fkey targetColumnName asUppercase.							(targetTable := self cachedTableNamed: tableName)								ifNil: [self proxyForField: fieldName ofTable: tableName]								ifNotNil: 									[targetTable fields detect: [:fld | fld name asUppercase = fieldName]										ifNone: [self error: 'fkey target field not found.']]].			aRawTable addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: nil]</body><body package="GlorpAnalysis" selector="rawReadManyOfSqliteDatabaseTableWhere:limit:orderBy:">rawReadManyOfSqliteDatabaseTableWhere: aBlock limit: anInteger orderBy: aCriteria	"Add a where clause to return only table rows. Return an OrderedCollection.	The returned objects are raw. They do not have their foreign key fields completed."	| query |	query := SimpleQuery returningManyOf: SQLite3DatabaseTable.	anInteger ifNotNil: [query limit: anInteger].	aCriteria ifNotNil: [query orderBy: aCriteria].	aBlock		ifNil: [query where: [:each | each type = 'table']]		ifNotNil: [query where: [:each | each type = 'table' AND: aBlock asGlorpExpression]].	"Read the initially sought tables. (These are SqliteDatabaseTables--not proper DatabaseTables yet)."	^(self execute: query) asOrderedCollection</body><body package="GlorpAnalysis" selector="rawReadOneOfSqliteDatabaseTableWhere:">rawReadOneOfSqliteDatabaseTableWhere: aBlock	"Add a where clause to return only table rows. Return an OrderedCollection.	The returned object is raw. It does not have their foreign key fields completed."	| query |	query := SimpleQuery returningOneOf: SQLite3DatabaseTable.	aBlock		ifNil: [query where: [:each | each type = 'table']]		ifNotNil: 			[query where: [:each | each type = 'table' AND: aBlock asGlorpExpression]].	"Read the initially sought tables. (These are SqliteDatabaseTables--not proper DatabaseTables yet)."	^self execute: query.</body><body package="GlorpAnalysis" selector="readManyOfDatabaseTableWhere:limit:orderBy:">readManyOfDatabaseTableWhere: aBlock limit: anInteger orderBy: aCriteria	"Read the initially sought SqliteDatabaseTables--not proper DatabaseTables yet.	Then process them, adding the final DatabaseTables to the cache."	| rawResults |	rawResults := self				rawReadManyOfSqliteDatabaseTableWhere: aBlock				limit: anInteger				orderBy: aCriteria.	^(rawResults isEmpty or: [rawResults first isNil])		ifTrue: [OrderedCollection new]		ifFalse: [self databaseTablesFromSqliteDatabaseTables: rawResults]</body><body package="GlorpAnalysis" selector="readOneOfDatabaseTableWhere:">readOneOfDatabaseTableWhere: aBlock	"Read the initially sought SqliteDatabaseTables--not proper DatabaseTables yet.	Then process them, adding the final DatabaseTables to the cache."	| rawResult |	rawResult := self rawReadOneOfSqliteDatabaseTableWhere: aBlock.	^rawResult		ifNotNil: 			[(self databaseTablesFromSqliteDatabaseTables: (OrderedCollection with: rawResult)) first]</body><body package="GlorpAnalysis" selector="updateSQLiteTableData:">updateSQLiteTableData: sqliteDatabaseTables	"Convert each SQLiteDatabaseTable object to the usual DatabaseTable object.	Instances of the former contain raw column, index, and foreign key information that	needs to be converted into ForeignKeyConstraints and unique column attributes.	The conversion method, #asDatabaseTable also relinks all DatabaseField references	to the new DatabaseTable object, so that the original SQLiteDatabaseTable can	finally be discarded after this call completes."	| uncached |	uncached := sqliteDatabaseTables				reject: [:aTable | (self cachedTableNamed: aTable name asUppercase) notNil].	^uncached collect: 			[:aSQLiteTable |			self findForeignKeysForTable: aSQLiteTable.			aSQLiteTable asDatabaseTable]</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>private-sqlite-proxy</category><body package="GlorpAnalysis" selector="fromProxies:">fromProxies: proxies	^proxies collect: 			[:each |			each class = SQLite3Proxy ifTrue: [each getValue] ifFalse: [each]]</body><body package="GlorpAnalysis" selector="proxyForField:ofTable:">proxyForField: aFieldName ofTable: aTableName	| proxy aBlock |	aBlock := [:each | each name asUppercase = aTableName asUppercase].	proxy := SQLite3Proxy				returningOneOf: SQLite3DatabaseTable				where: [:each | each type = 'table' AND: aBlock asGlorpExpression]				in: self.	proxy glorpProxyAction: 			[:session :rawResult |			rawResult				ifNotNil: 					[| collection table |					collection := session								databaseTablesFromSqliteDatabaseTables: (OrderedCollection with: rawResult).					table := collection first.					table fieldNamed: aFieldName]].	proxy glorpOwner: self.	^proxy</body><body package="GlorpAnalysis" selector="proxyForTableNamed:">proxyForTableNamed: aTableName	| proxy aBlock |	aBlock := [:each | each name asUppercase = aTableName asUppercase].	proxy := SQLite3Proxy				returningOneOf: SQLite3DatabaseTable				where: [:each | each type = 'table' AND: aBlock asGlorpExpression]				in: self.	proxy glorpProxyAction: 			[:session :rawResult |			rawResult				ifNotNil: 					[| collection |					collection := session								databaseTablesFromSqliteDatabaseTables: (OrderedCollection with: rawResult).					collection first]].	proxy glorpOwner: self.	^proxy</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>private-sqlite-cache</category><body package="GlorpAnalysis" selector="cachedTableNamed:">cachedTableNamed: aTableName	"This method checks the cache, and returns the requested DatabaseTable object if found, or nil."	^aTableName ifNil: [nil] ifNotNil: [self cacheLookupForClass: DatabaseTable key: aTableName]</body></methods><methods><class-id>Glorp.SQLite3IndexData</class-id> <category>accessing</category><body package="GlorpAnalysis" selector="indexColumnsData">indexColumnsData	^indexColumnsData</body><body package="GlorpAnalysis" selector="indexColumnsData:">indexColumnsData: anObject	indexColumnsData := anObject</body><body package="GlorpAnalysis" selector="name">name	^name</body><body package="GlorpAnalysis" selector="name:">name: anObject	name := anObject</body><body package="GlorpAnalysis" selector="seq">seq	^seq</body><body package="GlorpAnalysis" selector="seq:">seq: anObject	seq := anObject</body><body package="GlorpAnalysis" selector="unique">unique	^unique</body><body package="GlorpAnalysis" selector="unique:">unique: anObject	unique := anObject</body></methods><methods><class-id>Glorp.SQLite3IndexData</class-id> <category>converting</category><body package="GlorpAnalysis" selector="asOrderedFieldsForTable:">asOrderedFieldsForTable: aTable	"Return a list of aTable's fields referenced by me, sorted	according to the seqno inst var."	^self columnDataSortedBySeq collect: 			[:columnDatum |			aTable fields detect: [:fld | fld name = columnDatum name]				ifNone: [self error: 'Cannot find indexed column.']]</body><body package="GlorpAnalysis" selector="columnDataSortedBySeq">columnDataSortedBySeq	"Return my list of columns, sorted according to the seq inst var."	^self indexColumnsData asSortedCollection: [:a :b | a seqno &lt;= b seqno]</body><body package="GlorpAnalysis" selector="columnNames">columnNames	"Return my list of column names, unsorted."	^self indexColumnsData collect: [:each| each name]</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>initialize-release</category><body package="GlorpAnalysis" selector="initialize">initialize	commands := OrderedCollection new: 500.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>notification</category><body package="GlorpAnalysis" selector="command:">command: aDatabaseCommand	commands add: aDatabaseCommand-&gt;nil.</body><body package="GlorpAnalysis" selector="time:">time: aTime	"Make sure we log at least 1ms for each command"	commands last value: (aTime max: 1).</body><body package="GlorpAnalysis" selector="update:with:">update: eventName with: aParameter	self perform: eventName with: aParameter.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>hookup</category><body package="GlorpAnalysis" selector="connectTo:">connectTo: aSession	session := aSession.	session accessor addDependent: self.</body><body package="GlorpAnalysis" selector="disconnectFrom:">disconnectFrom: aSession	session := aSession.	session accessor removeDependent: self.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>reporting</category><body package="GlorpAnalysis" selector="commandsByTime">commandsByTime	^commands asSortedCollection: [:a :b | (a value ifNil: [0]) &gt;= (b value ifNil: [0])].</body><body package="GlorpAnalysis" selector="commandsForTableNamed:">commandsForTableNamed: aTableName	"Return a list of all the commands, with their time, associated with aTable"	| table |	table := session system tableNamed: aTableName.	^commands select: [:each |  		each key tables includes: table].</body><body package="GlorpAnalysis" selector="privateCommands">privateCommands	^commands.</body><body package="GlorpAnalysis" selector="subsume:">subsume: aGlorpQueryPerformanceAnalyzer	"Add in the data from this other session."	commands addAll: aGlorpQueryPerformanceAnalyzer privateCommands.</body><body package="GlorpAnalysis" selector="summaryByTypeOfTimesByTable">summaryByTypeOfTimesByTable	| readSummary writeSummary |	readSummary := Dictionary new.	readSummary at: #READS put: 0.	writeSummary := Dictionary new.	writeSummary at: #WRITES put: 0.	commands do: [:each |  | summary |		summary := (each key isKindOf: RowBasedCommand) 			ifTrue: [				writeSummary at: #WRITES put: (writeSummary at: #WRITES) + each value.				writeSummary] 			ifFalse: [				readSummary at: #READS put: (readSummary at: #READS) + each value.				readSummary].		summary at: #totalNumberOfQueries put: (summary at: #totalNumberOfQueries ifAbsentPut: [0]) + 1.		each key tables do: [:eachTable |			summary at: (self translateTable: eachTable) put: (summary at: (self translateTable: eachTable) ifAbsentPut: [0]) + each value]].	^Array with: readSummary with: writeSummary.</body><body package="GlorpAnalysis" selector="summaryOfCountsByTable">summaryOfCountsByTable	| summary |	summary := Dictionary new.	commands do: [:each | 		each key tables do: [:eachTable |			summary at: (self translateTable: eachTable) put: (summary at: (self translateTable: eachTable) ifAbsentPut: [0]) + 1]].	^summary.</body><body package="GlorpAnalysis" selector="summaryOfTimesByTable">summaryOfTimesByTable	| summary |	summary := Dictionary new.	commands do: [:each | 		each key tables do: [:eachTable |			summary at: (self translateTable: eachTable) put: (summary at: (self translateTable: eachTable) ifAbsentPut: [0]) + each value]].	^summary.</body><body package="GlorpAnalysis" selector="totalTime">totalTime	^commands inject: 0 into: [:sum :each | sum + each value].</body><body package="GlorpAnalysis" selector="translateTable:">translateTable: aTable	"In case we've subsumed multiple sessions, normalize them all to the main one."	^session system tableNamed: aTable name.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer class</class-id> <category>instance creation</category><body package="GlorpAnalysis" selector="for:">for: aSession	"Hook us up to aSession"	^self new connectTo: aSession.</body><body package="GlorpAnalysis" selector="for:during:">for: aSession during: aBlock	| monitor |	monitor := self for: aSession.	aBlock ensure: [monitor disconnectFrom: aSession].	^monitor.</body><body package="GlorpAnalysis" selector="monitor:forSeconds:">monitor: aSession forSeconds: seconds	^self for: aSession during: [(Delay forSeconds: seconds) wait].</body><body package="GlorpAnalysis" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.MySQLMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis" selector="tableForCOLUMNS:">tableForCOLUMNS: aTable	super tableForCOLUMNS: aTable.	aTable createFieldNamed: 'extra' type: (platform varchar: 255).</body><body package="GlorpAnalysis" selector="tableForKEY_COLUMN_USAGE:">tableForKEY_COLUMN_USAGE: aTable	| columns |	super tableForKEY_COLUMN_USAGE: aTable.	aTable createFieldNamed: 'referenced_table_schema' type: (platform varchar: 255).	aTable createFieldNamed: 'referenced_table_name' type: (platform varchar: 255).	aTable createFieldNamed: 'referenced_column_name' type: (platform varchar: 255).	columns := self tableNamed: 'COLUMNS'.	aTable addForeignKeyFrom: (aTable fieldNamed: 'referenced_table_name') to: (columns fieldNamed: 'table_name')		from: (aTable fieldNamed: 'referenced_table_schema') to: (columns fieldNamed: 'table_schema')		from: (aTable fieldNamed: 'referenced_column_name') to: (columns fieldNamed: 'column_name').</body></methods><methods><class-id>Glorp.MySQLMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis" selector="extraFieldsForTypeIn:">extraFieldsForTypeIn: table	"Return an additional fields we're going to need in order to determine the data type of a column."	^Array with: (table fieldNamed: 'extra').</body><body package="GlorpAnalysis" selector="getExtraInformationFor:inBuilder:">getExtraInformationFor: aContext inBuilder: anElementBuilder	"MySQL has extra type information in the field called EXTRA."	| field |	field := anElementBuilder descriptor table fieldNamed: 'extra'.	^anElementBuilder valueOfField: (aContext translateField: field).</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class></st-source>