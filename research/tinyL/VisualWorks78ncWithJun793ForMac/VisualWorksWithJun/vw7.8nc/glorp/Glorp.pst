<?xml version="1.0"?><st-source><!-- Name: GlorpNotice: LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USABundleName: GlorpBundleStructure: a Store.BundleForParcelComment: This is the GLORP system, an open-source library (LGPL(S)) for persisting Smalltalk objects in relational databases. For more information see the #notice property, accompanying files, and/or the web sites http://www.glorp.org or http://www.sourceforge.net/projects/glorpDevelopmentPrerequisites: #(#(#any 'GlorpVWPort' ''))IsDeployedBundle: trueParcel: nilParcelName: GlorpPrerequisiteParcels: #(#('GlorpVWPort' ''))Version: 7.8 - 1023Date: 12:55:51 PM February 18, 2011 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (feb11.2) of February 11, 2011 on February 18, 2011 at 12:55:51 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GlorpDatabaseValueGenerator</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseValueGenerator</class-id><body>This is an abstract superclass for thing that generate values when objects are written to the database. The most common usage is the various types of sequences, identity columns and other primary key generating mechanism. But it can also be used for optimistic locking via version numbers or timestamps. It doesn't actually have any code at the moment, so it might just be deletable, or maybe there's some refactoring to be done.</body></comment><class><name>VersionGenerator</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseValueGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VersionGenerator</class-id><body>An abstract superclass for generators that generate version numbers (rather than sequence numbers).Subclasses must implement the following messages:	sequencing		nextValueFor:in:</body></comment><class><name>AdHocVersionGenerator</name><environment>Glorp</environment><super>Glorp.VersionGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block numberOfArguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AdHocVersionGenerator</class-id><body>This is a version generator that takes an arbitrary block and runs it.Instance Variables:	block	&lt;BlockClosure&gt;	The block we evaluate to get the next version.	numberOfArguments	&lt;Integer&gt;	Generated automatically. How many arguments does block take. If zero, we invoke it without our arguments. If not, we give it the arguments to use.</body></comment><class><name>GlorpExpression</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.GlorpExpression</class-id><body>This is the superclass of Glorp expression tree nodes. These are used to represent the where clause of a query, or things that describe relationships between objects and/or represent boolean expressions evaluated against them. They are typically created by converting a block into an expression using asGlorpExpression. Then they are used in generating the SQL string to be sent to the database.Subclasses must implement the following messages:	accessing		canHaveBase	api		base		get:withArguments:	converting		asJoin	navigating		ultimateBaseExpression	preparing		asExpressionJoiningSource:toTarget:		rebuildOn:startingFrom:withOuterScopeBase:	printing		printOnlySelfOn:		printTreeOn:</body></comment><class><name>FunctionExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>function base alias symbol type </inst-vars><class-inst-vars>functions </class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.FunctionExpression</class-id><body>This represents a database function or other modifier. For example, conversion to upper or lower case, or the ascending/descending modifier in order by clauses. At the moment it is hard-coded to to handle only the descending modifier and does not handle e.g. function arguments, functions that differ between databases, functional syntax ( as opposed to postfix). One would probably define subclasses to handle these cases, but this is the simplest thing that could possibly work for the current functionality.Instance Variables:	function	&lt;String&gt;	The string we print to the database	base &lt;GlorpExpression&gt; The thing we're a function of.	alias &lt;String&gt; If we're to be selected as a field, what should we be selcted as. Think SELECT t1.A + t1.B AS FRED.	symbol &lt;Symbol&gt; The original symbol used to create us. Helpful if recreating onto a different platform where the DB string can be different.	type &lt;GlorpDatabaseType&gt; Optional. If we have a type defined, then we can record it here. Otherwise, we will return the type of the field we are operating on.	</body></comment><class><name>PostfixFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.PostfixFunction</class-id><body>This represents a function that prints postfix, meaning its name comes after its argument. For example, DESC for a descending sort. That's maybe stretching the definition of a function, but that's how it's implemented for purposes of Glorp SQL definition.</body></comment><class><name>DatabaseRow</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table contents shouldBeWritten owner forDeletion status oldVersion generated parent operation </inst-vars><class-inst-vars>missingFieldIndicator emptySlot </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseRow</class-id><body>This represents the data to be written out to a row. Database rows are normally stored in a rowmap, keyed according to their table and the object that did the primary writes to them. We expect that that's only one object, although embedded values are an exception to that.Instance Variables:	table	&lt;DatabaseTable&gt;	The table holding the data	contents	&lt;IdentityDictionary&gt;	Holds the fields with their values, indirectly through FieldValueWrapper instances.	shouldBeWritten	&lt;Boolean&gt;	Normally true, but can be set false to suppress writing of a particular row. Used with embedded value mappings, where we create their row, unify it with the parent row, and suppress writing of the original row.	owner	&lt;Object&gt;	The primary object that wrote into this row, would also be the key into the rowmap.	forDeletion &lt;Boolean&gt; Is this row to be deleted or written.	status &lt;Symbol&gt; Used for topological sort to determine write order. We keep a symbol indicating the "visited" status of the row while doing the sort. This doesn't separate the sort from the row, using each row directly as a node in the graph. This is less general, but uses less memory than other alternatives.	parent &lt;DatabaseRow&gt; Also used during sorting. Keep track of our parent node.	oldVersion &lt;DatabaseRow&gt; The old version of us. Used if we increment a version field to keep track of what its value was before.	generated &lt;Boolean&gt; True if we have already had field with generated types generated in the preWrite phase. This is needed because we generate all sequences before doing any writes. But if we use an explicit writeRow: operation, then we want to make sure that generated values are generated. And some generated types write over what was there before (e.g. optimistic lock fields). So we need a way of knowing if generation has already been done. Note that this doesn't apply if using post-write sequence generation (i.e. identity columns) because then it's all after the write. This makes certain things not work as well, but that's what you get for using identity columns.	</body></comment><class><name>Mapping</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor attribute debugRead debugWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.Mapping</class-id><body>This is the abstract superclass for all Glorp mappings. A mapping defines how one particular instance variable will be mapped into and out of the database. There is considerable variation among the subclasses.Subclasses must implement the following messages:	accessing		allTables	mapping		mapFromObject:intoRowsIn:		mapObject:inElementBuilder:		referencedIndependentObjectsFrom:		trace:context:	testing		controlsTables		isRelationship		isStoredInSameTable		mappedFieldsInstance Variables:	attribute	&lt;GlorpAttributeModel&gt;	The description of the instance variable we map.	canRead	&lt;Boolean&gt;	Is this mapping allowed to read.	canWrite	&lt;Boolean&gt;	Is this mapping allowed to write.	debugRead	&lt;Boolean&gt;	For debugging purposes. If true, we will halt when this mapping is about to read..	debugWrite	&lt;Boolean&gt;	For debugging purposes. If true, we will halt when this mapping is about to write.	descriptor	&lt;Descriptor&gt;	The descriptor that contains this mapping.</body></comment><class><name>ConstantMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constantValue valueIsSession </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ConstantMapping</class-id><body>Sometimes you just want a constant value to be set, either in the row, the object or both. And sometimes you just want a non-mapping (e.g. with a ConditionalMapping where oneof the conditions means "this isn't mapped"). This mapping represents these situations.It also handles the special case where it's useful to have access to the session inside adomain object, by allowing you to map it to an instance variable.So far only the case of mapping to an inst var is implemented.Instance Variables:</body></comment><class><name>Descriptor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tables mappings system mappedFields cachePolicy typeResolver mapsPrimaryKeys keyFields classModel multipleTableJoin imaginaryTableReplacements mappingsForFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.Descriptor</class-id><body>For each persistent class, there is a descriptor. This is what tells GLORP how to read and write objects of this class. The descriptor is not actually a very complicated object, because most of the information is in the mappings described below. But the descriptor does keep hold of a few per-class pieces of information, notablyInstance Variables:	cachePolicy	&lt;CachePolicy&gt;	The cache policy to use. If left blank, default to what the system specifies.	describedClass	&lt;Class&gt;	The persistent class that we map.	mappedFields	&lt;Collection of: DatabaseField&gt;	The database fields we have mappings for (cached computed value)	mappings	&lt;(Collection of: Mapping)&gt;	Our mappings.	mapsPrimaryKeys	&lt;Object&gt;	Do we map the primary keys (cached computed value)	multipleTableCriteria	&lt;(Collection of: Join)&gt;	description of multipleTableCriteria	system	&lt;DescriptorSystem&gt;	The descriptor system that we belong to.	tables	&lt;(SequenceableCollection of: (DatabaseTable))&gt;	The tables that we map	typeResolver	&lt;TypeResolver&gt;	description of typeResolver</body></comment><class><name>TypeResolver</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>members system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.TypeResolver</class-id><body>TypeResolvers are used to implement inheritance. Each descriptor has a type resolver, which can be asked for the types associated with that descriptor. By default we get an IdentityTypeResolver, which just gives us a single class. With inheritance we can get different types.Subclasses must implement the following messages:	accessing		classesRequiringIndependentQueriesFor:		describedConcreteClassFor:withBuilder:descriptor:	type resolution		typeMappingRootDescriptorInstance Variables:	members	&lt;(SequenceableCollection of: (Descriptor))&gt;	The descriptors of the classes that this resolver applies to.	system	&lt;DescriptorSystem&gt;	The system in which the members live.</body></comment><class><name>BasicTypeResolver</name><environment>Glorp</environment><super>Glorp.TypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>concreteMembers subclassDescriptorsBuilt rootDescriptor rootClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.BasicTypeResolver</class-id><body>This is an abstract superclass for TypeResolvers that do inheritance in some form.Instance Variables:	concreteMembers	&lt;(Collection of: (Descriptor))&gt;	Which of our members can actually be instantiated, as opposed to abstract superclasses.	rootClass	&lt;Behavior&gt;	Which is the root class of the inheritance hierarchy we represent.	rootDescriptor	&lt;Descriptor&gt;	The descriptor for the root class	subclassDescriptorsBuilt	&lt;Boolean&gt;	Have we asked the system for the descriptors for all of the root's subclasses yet?</body></comment><class><name>FilteredTypeResolver</name><environment>Glorp</environment><super>Glorp.BasicTypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.FilteredTypeResolver</class-id><body>This is a type resolver for inheritance where all of the classes are represented in a single table, with some sort of identifying field for which subclass they are. The table would have the union of all possible fields for all classes. It's called filtering, because for any particular class, we filter out those instances from all those represented in the table.</body></comment><class><name>GlorpDatabaseType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform selector typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseType</class-id><body>This is an abstract superclass for objects representing types in the database. Each one will correspond to a particular simple type that we can store and retrieve from the database. e.g. int, varchar, and so on. For types that are variable sizes, different instances may represent, e.g. varchar(5) vs. varchar(20). While the classes may be reused across different databases, a database platform is expected to be able to return the types that it knows about as instances of these clasess. So you can send #varchar to OraclePlatform and get back one of these.Subclasses must implement the following messages:	exdi specific		exdiTypeInstance Variables	platform	&lt;DatabasePlatform&gt;	The platform that owns us.	typeString	&lt;String&gt;	Our name in the database.	selector &lt;Symbol&gt; The name of the message we can send to the platform to get ourselves or an equivalent type back again.</body></comment><class><name>GlorpTimeType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>DatabasePlatform</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types converters useBinding reservedWords functions characterEncoding </inst-vars><class-inst-vars>converterRepository </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabasePlatform</class-id><body>This is an abstract superclass for classes that provide a compatibility layer for different databases. They encapsulate different SQL syntaxes, binding mechanism, types that are available, and general limits.Subclasses must implement the following messages:	accessing		vwEXDIConnectionClass	binding		bindingsForGroupWritingFor:	constants		areSequencesExplicitlyCreated		supportsMillisecondsInTimes	sequences		databaseSequenceClass	testing		usesArrayBindingRatherThanGrouping	types		int4		sequence		serial		timestamp		varbinary		varcharInstance Variables:	characterEncoding	&lt;ByteSymbol&gt;	What character encoding should we use for the database connection.	converters	&lt;Dictionary from: Symbol to: DatabaseConverter&gt;	The available type converters. So, for example, if there is a boolean to integer conversion, we expect it in this dictionary associated with the symbol #booleanToInteger. If that symbol isn't there, we will look up the converter by performing #booleanToIntegerConverter and caching the result.	functions	&lt;FunctionExpression&gt;	Which functions are available for this database. There is a set of common functions created by FunctionExpression, plus we can define our own additions or overrides that are specific to this database.	reservedWords	&lt;Collection of: String&gt;	Which names are reserved words in this database. Any that we use as table or column names will need to be quoted.	types	&lt;Dictionary from: Symbol to: GlorpDatabaseType&gt;	A cache of available types, mapped by name to the type instance.	useBinding	&lt;Boolean&gt;	By default, should we use binding for this database.</body></comment><class><name>OraclePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OraclePlatform</class-id><body>This is a platform for Oracle databases. Currently there's only one, but it might be better for some purposes to separate out by versions, as some older versions don't support all features.</body></comment><class><name>OracleODBCPlatform</name><environment>Glorp</environment><super>Glorp.OraclePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OracleODBCPlatform</class-id><body>This is a platform for Oracle, as accessed through ODBC. The database doesn't change, but at least in VW we determine which connection type to use based on the platform object, so we need to use an ODBC connection rather than an OCI connection.</body></comment><class><name>RelationshipMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query join usesLinkTable shouldProxy linkTableJoin targetTableJoin reverseJoin shouldUseFilteredRead rowMapKeyConstructorBlock controlsTables isExclusive linkFields proxyAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.RelationshipMapping</class-id><body>This is an abstract superclass for relationships between one mapped object and another (or a collection of others).Instance Variables:	join	&lt;Join&gt;	The join between our table and the target. Note that if we use a link table, this will be a join between our table and the link table.	targetTableJoin	&lt;Join&gt;	If we're using a link table, it may be desirable to also join to attributes of the main table. This optional extra join allows that.	query	&lt;SimpleQuery&gt;	The query that will return the other side of the relationship, given parameters describing our side.	linkFields	&lt;Collection of: DatabaseField&gt;	When there's a link table, we need to know the other side of the relationship, from link table to target. Usually we can figure it out based on the target table and the foreign key constraints, but sometimes (e.g. if there are multiple relationships to the same table) we need to be told which fields are the ones that connect to this table. Again that's FROM the LINK table TO the TARGET table, not the entry in the link table that we'd connect  to.	reverseJoin	&lt;Join&gt;	caches the other end of the relationship, as above.	rowMapKeyConstructorBlock	&lt;BlockClosure&gt;	Usually row map keys are constructed automatically, but it's possible that in weird cases we  might need to construct complicated ones (e.g. if there are 3 things that need to participate instead of just two, as in Store's use of the same link table and the same row to indicate the relationship from package to class and package to metaclass).	shouldProxy	&lt;Boolean&gt;	Should we proxy or directly construct the referenced object	shouldUseFilteredRead	&lt;Boolean&gt;	should we use a filtered read.	usesLinkTable	&lt;Boolean&gt;	Do we use a link table, or is it a direct join to the target.	isExclusive &lt;Boolean&gt; Is this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted.</body></comment><class><name>OneToOneMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.OneToOneMapping</class-id><body>This represents a simple one to one relationship, e.g. from Person to Address. Assuming each person has only one address. Note that this has no methods, and only really exists for backward compatibility purposes, since a to-one relationship is the default for RelationshipMapping.</body></comment><class><name>EmbeddedValueOneToOneMapping</name><environment>Glorp</environment><super>Glorp.OneToOneMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldTranslation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id><body>This represents a one-to-one mapping in which the referenced object is stored as part of the same table as the containing object.</body></comment><class><name>AbstractProxy</name><environment>Glorp</environment><super>ProtoObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value isInstantiated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.AbstractProxy</class-id><body>This is an abstract superclass for proxy objects. It inherits from ProtoObject, which is part of the platform specific layer, but implements most of the proxy functionality.Instance Variables:	isInstantiated	&lt;Boolean&gt;	Has this proxy been instantiated or not.	value	&lt;Object&gt;	What we are proxying for.</body></comment><class><name>Proxy</name><environment>Glorp</environment><super>Glorp.AbstractProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session query parameters action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.Proxy</class-id><body>This implements the Glorp database proxy behaviour, for proxies that get their result by evaluating a query using a particular set of parameters, in the context of a particular Glorp query.Instance Variables:	parameters	&lt;Dictionary | SequenceableCollection&gt;	Our parameters, keyed either by name or by index.	query	&lt;Query&gt;	The query we will evaluate. Note that for a mapping, all proxies will share the same query instance.	session	&lt;GlorpSession&gt;	The session in which this proxy exists, and against which the query will be executed to find our value.</body></comment><class><name>InfixFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argument arguments functionParts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.InfixFunction</class-id><body>This is a function that is infix. That is, it prints its name in between its arguments. For example, + for string concatenation, || for logical OR. Instance Variables:	arguments	&lt;Collection of GlorpExpression&gt;	Our post-arguments (the first one being the base).	functionParts &lt;Array of: String&gt; The parts of our name. For a two-argument function, this is just the same as an array containing the name, but for one with more (e.g. BETWEEN AND) it contains the different portions of the name.</body></comment><class><name>GlorpQueries</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpQueries</class-id><body>This class represents package information for the GlorpQueries package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>ObjectTransaction</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>undoMap collectionMementos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.ObjectTransaction</class-id><body>An ObjectTransaction knows how to remember the state of objects and revert them back to that state later on. It does this by making a *shallow* copy of the registered objects and everything connected to them, and then putting that into an identity dictionary keyed by the originals.If you have to undo, you push the state from the shallow copies back into the originals.Yes, that works, and it's all you have to do. It even handles collections become:ing different sizes.This is fairly independent of GLORP. You could use this mechanism in general, if you provided your own mechanism for figuring out what to register, or even just uncommented the one in here.Instance Variables:	undoMap	&lt;IdentityDictionary&gt;	 The dictionary of originals-&gt;copies.</body></comment><class><name>DatabaseCommand</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useBinding stream sqlString session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseCommand</class-id><body>A DatabaseCommand is what a query uses to actually generate its SQL and to execute it. A command wraps a stream, into which the SQL is written, but with knowledge of the platform for which it's being written, and potentially details about how it should execute.Subclasses must implement the following messages:	accessing		arrayBoundFields		bindings		bindingTypes		parameterTypeSignature	executing		printSQL	testing		succeededInstance Variables:	platform	&lt;DatabasePlatform&gt;	The database for which we're to generate/execute SQL.	sqlString	&lt;String&gt;	The resulting SQL.	stream	&lt;Stream&gt;	The stream into which we generate the SQL. Once we've finished and got sqlString this isn't necessary any more.	useBinding	&lt;Boolean&gt;	Should we use binding, or print parameters directly into the string.</body></comment><class><name>SelectCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameters blockFactor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SelectCommand</class-id><body>This represents a SELECT query to the database. This can either be based on a GLORP query, or on a hard-coded SQL string.Subclasses must implement the following messages:	accessing		printSQLInstance Variables:	blockFactor	&lt;SmallInteger&gt;	The blocking factor to use for this query. This is most likely to make a difference for these kind of operations, and so is directly settable here.	parameters	&lt;Dictionary from: DatabaseField to: Object&gt;	The parameters to the query.</body></comment><class><name>QuerySelectCommand</name><environment>Glorp</environment><super>Glorp.SelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query boundExpressions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.QuerySelectCommand</class-id><body>This is the normal class to use for select queries. It generates SQL for a select operation returning a set of rows.Instance Variables:	boundExpressions	&lt;(Collection of: GlorpExpression)&gt;	The expressions for which we need bind parameters. We expect that these are things that resolve to fields, or more generally, to something the database will accept as a valid thing to bind ofr.	query	&lt;Query&gt;	The query in which we're executing.</body></comment><class><name>CompoundSelectCommand</name><environment>Glorp</environment><super>Glorp.QuerySelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>commands </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.CompoundSelectCommand</class-id><body>This is a select command that uses a number of sub-commands to print multiple queries, and combine them into one for execution. Used in conjunction with compound queries, e.g. using UNION ALL. The query knows what the combination operation is.Instance Variables:	commands	&lt;(Collection of: DatabaseCommand)&gt;	The commands we are to print.</body></comment><class><name>GlorpBlobType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queryType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpError</name><environment>Glorp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpError</class-id><body>This is an abstract superclass for GLORP exceptions.</body></comment><class><name>ValidationError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.ValidationError</class-id><body>ValidationError is a superclass for all errors that are raise while validating a descriptor. The exception may resume.</body></comment><class><name>NoTableFound</name><environment>Glorp</environment><super>Glorp.ValidationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expectedTables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.NoTableFound</class-id><body>NoTableFound is raise if there is possible mismatch between an active record and database table namesInstance Variables:	expectedTables	&lt;OrderedCollection&gt;	 expected table names to map the model</body></comment><class><name>ToManyMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderBy shouldWriteTheOrderField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ToManyMapping</class-id><body>This is a superclass for mappings which represent a relationship between one object and a collection of others. It isn't an abstract superclass, you can use this class directly, and you will get the same behaviour as if you were using OneToManyMapping. Or if you set useLinkTable to true, you'll get the same behaviour as a ManyToManyMapping.Instance Variables:	orderBy	&lt;(SequenceableCollection of: (GlorpExpression | BlockClosure))&gt;	By what criteria should we order the collection of items when we are reading.	shouldWriteTheOrderField	&lt;Boolean&gt;	On write, when we write an item in the collection, should we also write the index at which it occurs in the collection into the database. This lets us preserve ordering if we just used a SequenceableCollection in memory. If this is true, we assume that the first item in orderBy will give us the field to write the index into.</body></comment><class><name>ManyToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ManyToManyMapping</class-id><body>This is a to-many relationship in which we use a link table to the collection, rather than a foreign key in the items of the collection pointing back to the "owner". Using this class is exactly equivalent to just using a ToManyMapping and setting the useLinkTable field to true.</body></comment><class><name>CannotFindSession</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.CannotFindSession</class-id><body>This is an error that we raise when trying to determine what session to use for an operation, and we don't have enough information to figure it out.</body></comment><class><name>GlorpInvalidTypeError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object expectedType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpInvalidTypeError</class-id><body>When mapping, if we encounter an object in a relationship that doesn't match the type we're expecting from the ClassModel/AttributeModel then we raise this exception. Instance Variables:	expectedType	&lt;GlorpClassModel&gt;		The classModel for the type we were expecting.	object	&lt;Object&gt;	The object that contained the invalid reference.</body></comment><class><name>GlorpTransactionFailure</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpTransactionFailure</class-id><body>This is the exception we raise if we encounter a database error trying to commit a transaction.</body></comment><class><name>PrefixFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments separator argumentModifierBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.PrefixFunction</class-id><body>This represents a function which prints prefix, printing its name, followed by the arguments in parentheses. This is the most common sort of function, e.g. MIN(), MAX(), DISTINCT, TO_CHAR Instance Variables:	arguments	&lt;(SequenceableCollection of: GlorpExpression)&gt;	Our arguments (in addition to our base).	separator	&lt;String&gt;	What we will use to separate the arguments. By default, a comma.</body></comment><class><name>Case</name><environment>Glorp</environment><super>Glorp.PrefixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argumentTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.Case</class-id><body>This represents a function which prints prefix, printing CASE, followed by the argument in parentheses, and then the rest of the MS SQL Server CASE statement, with a single test condition (WHEN) and a default value (ELSE):CASE (arg1)	WHEN arg2 THEN arg3 	ELSE arg4END AS arg5For example:CASE ('SELECT count(*) FROM aTable')	WHEN '0' THEN 0 	ELSE 1 END AS arg3</body></comment><class><name>GeneralSubSelectExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.GeneralSubSelectExpression</class-id><body>This represents an arbitrary sub-select. This would normally get created by embedding a query instance inside a query block. For example   where: [:each | each id &gt; 2 &amp; (each something = aWholeOtherQuery)].Warning: This can be get very complicated, especially if aWholeOtherQuery refers to variables inside the main query block, creating a correlated subselect.Instance Variables:	query	&lt;Query&gt;	The query that we subselect.</body></comment><class><name>Tracing</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base allTracings retrievalExpressions alsoFetchExpressions query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.Tracing</class-id><body>A tracing is a collection of expressions representing the graph of other objects whichare to be read at the same time as the root object.Instance Variables:	base	&lt;Expression&gt;	The base expression representing the root object. Same as the parameter to the query block	allTracings	&lt;Collection of: Expression&gt;	The expressions representing each of the associated objects. e.g. base accounts, base amount serviceCharge .	alsoFetchExpressions	&lt;(Collection of: GlorpExpression)&gt;	Objects to also retrieve, but not included in the result set, just knitted together with the other related objects.	retrievalExpressions	&lt;(Collection of: GlorpExpression)&gt;	Objects to also retrieve, and to include in teh result set</body></comment><class><name>DatabaseSequence</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseValueGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reservedNumbers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseSequence</class-id><body>This is an abstract superclass for identifier generation mechanisms in the database. For example, Oracle sequences, SQL Server identity columns, and so on.Subclasses must implement the following messages:	sequencing		getSequenceValueFromDatabaseFor:in:using:		postWriteAssignSequenceValueFor:in:using:Instance Variables:	reservedNumbers	&lt;OrderedCollection&gt;	Numbers that we have already reserved and have available. This is only useful if the sequence can generate more than one identifier in a single request, and we have configured it (and ourselves) to do so and use those numbers. This is useful for efficiency when inserting lots of data.</body></comment><class><name>NamedSequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name tableSelectCommand schema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.NamedSequence</class-id><body>This is a database sequence that is identified by name.Subclasses must implement the following messages:	SQL		tableSelectCommandFor:in:reserving:Instance Variables:	name	&lt;String&gt;	The name of the sequence	schema	&lt;String&gt;	The schema that contains the sequence. Subclasses should set this up appropriately.	tableSelectCommand	&lt;SQLStringSelectCommand&gt;	The command to execute to get the next value. </body></comment><class><name>FirebirdSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.FirebirdSequence</class-id><body>Implements firebird sequence generation by calling out to gen_id()</body></comment><class><name>ObjectExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappingExpressions requiresDistinct tableAliases fieldAliases </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ObjectExpression</class-id><body>This is a not-especially well-named superclass for expressions that end up mapping to rows in the database, more or less. That is, it's more or less a superclass for things that have the capacity to alias tables, and to have mapping expressions derived from them. Since, depending on your point of view, everything is an object, the name isn't very descriptive. Or if some things aren't considered objects, TableExpression is a good candidate. But we have the common functionality for managing tables, and for keeping a dictionary of our sub-mapping expressions.Subclasses must implement the following messages:	accessing		system		table	fields		controlsTablesInstance Variables:	fieldAliases	&lt;Dictionary from: DatabaseField to: DatabaseField&gt;	For each field, the corresponding aliased field for our query. So, e.g. PERSON.NAME will map to t1.NAME. These aren't strings, though, these are fields derived from the aliased table.	mappingExpressions	&lt;Dictionary from: Symbol to: ( MappingExpression | TableExpression) &gt;	Each attribute that's derived from us will be maintained in this dictionary. This is very important, because Glorp relies critically on these expressions being identical. So "object field == object field".	requiresDistinct	&lt;Boolean&gt;	Do the fields that we will cause to be added to the SELECT portion of the query need a DISTINCT wrapped around them?	tableAliases	&lt;Dictionary from: DatabaseTable to: DatabaseTable&gt;	While the query is being prepared, tables will be assigned aliases. This keeps track of the aliases for the tables that we control. As with fieldAliases, note that this stores table copies with their names altered, not strings.</body></comment><class><name>TableExpression</name><environment>Glorp</environment><super>Glorp.ObjectExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.TableExpression</class-id><body>This is an expression representing a table. Typically we refer to things in terms of objects which control tables, but sometimes you want to refer directly to a table that's not mapped, either in the process of building up a more OO representing (e.g. referring to a link table) or because we just want to do something more complicated that's not mapped, or incompletely mapped.Instance Variables:	base	&lt;BaseExpression | MappingExpression&gt;	The expression on which we are built.	table	&lt;DatabaseTable&gt;	The table that we represent.</body></comment><class><name>DatabaseConverter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseConverter</class-id><body>This is a superclass for objects that convert back and forth between database representations and object representations.Subclasses must implement the following messages:	converting		convert:fromDatabaseRepresentationAs:		convert:toDatabaseRepresentationAs:Instance Variables:	name	&lt;ByteSymbol&gt;	The name for this converter. The name is used, concatenated with #Converter, to create a symbol that can be performed against the DatabasePlatform to give this converter. So, e.g. booleanToIntegerConverter.</body></comment><class><name>DelegatingDatabaseConverter</name><environment>Glorp</environment><super>Glorp.DatabaseConverter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host stToDbSelector dbToStSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DelegatingDatabaseConverter</class-id><body>This is a converter which delegates the conversion to methods on some other object, typically the database platform.Instance Variables:	dbToStSelector	&lt;Symbol&gt;	The symbol we perform when converter from database to object representation. Takes two arguments, the value, and the database type.	host	&lt;Object&gt;	The object that holds the methods specified by the selectors.	stToDbSelector	&lt;Symbol&gt;	The symbol we perform when converter from object to database representation. Takes two arguments, the value, and the database type.</body></comment><class><name>ElementBuilder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instance requiresPopulating key expression cursor fieldTranslations isExpired row query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.ElementBuilder</class-id><body>This is the abstract superclass of builders. These assemble information, either primitive data or objects, from a database result set.Subclasses must implement the following messages:	building objects		buildObjectFrom:		findInstanceForRow:useProxy:	selecting fields		fieldsFromMyPerspectiveInstance Variables:	expression	&lt;MappingExpression&gt;	The expression we're mapping. e.g. if the query is reading people, this might be the expression corresponding to "each address", meaning that we build the address object related to the main Person instance by the given relationship. 	fieldTranslations	&lt;Array of: Integer&gt;	 The translation of the field positions from where they are in the descriptor to where they are in the row we're reading. This is done so we can read the rows efficiently, by index, rather than doing lots of dictionary lookups by name. If we're doing a simple read, the translations will probably be a no-op, but if we read multiple objects, some of the fields will be in different positions than they are in our table definition.	instance	&lt;Object&gt;	The thing we're constructing.	isExpired	&lt;Boolean&gt;	If our instance is in cache, we use that instead. However, if the instance has expired, then we do something different (most likely force a refresh) than if it's still alive.	key	&lt;Object&gt;	The key for this row. This is lazily computed, and "self" is used a special marker to indicate that it hasn't been computed yet.	query	&lt;AbstractReadQuery&gt;	the query that we're building results for.	requiresPopulating	&lt;Boolean&gt;	Do we need to populate the object. Will be false if the object was found in cache and hasn't expired.	row	&lt;Array&gt;	The database results. May actually be a result set row of some sort rather than an array, depending on the dialect, but should always respond to indexing protocol.</body></comment><class><name>DictionaryBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyBuilder valueBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.DictionaryBuilder</class-id><body>This is a subclass of builders that builds dictionaries. Basically it needs to build both the key and the value and then assemble them into a dictionary.Instance Variables:	keyBuilder	&lt;ElementBuilderr&gt;	The builder for the key	valueBuilder	&lt;ElementBuilder&gt;	The builder for the value.</body></comment><class><name>Query</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session prepared expectedRows collectionType ordering maximumLobSizeToRetrieveDirectly readsOneObject groupBy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.Query</class-id><body>This is an abstract superclass for Glorp queries.Subclasses must implement the following messages:	accessing		readsOneObject	executing		executeWithParameters:in:Instance Variables:	collectionType	&lt;Class&gt;	What sort of collection should this query return its results in.	expectedRows	&lt;Integer&gt;	Roughly how many rows should we expect to get back. Doesn't have to be right, but can be used to set buffer sizes appropriately in the database.	ordering	&lt;(SequenceableCollection of: (GlorpExpression | Block | Symbol))&gt;	If we order the results, what are the ordering criteria. Either an expression, but one whose root ends up evaluating to a field, or a block or symbol that can be converted to same.	prepared	&lt;Boolean&gt;	Has this query already been prepared (at the Glorp level), this says nothing about prepared statements for the database, which will be separate objects.	session	&lt;GlorpSession&gt;	What session should this query execute in. Can be nil until we start to prepare the query.</body></comment><class><name>AbstractReadQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultClass whereClause base limit offset proxyType shouldRefresh tracing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.AbstractReadQuery</class-id><body>An abstract superclass for Glorp queries. Most query types will descend from this, but a couple are specialized.Subclasses must implement the following messages:	executing		rowsFromDatabaseWithParameters:Instance Variables:	base	&lt;BaseExpression&gt;	In Glorp expressions it's very important that expressions we're trying to compose together are built on the same base, which represents the object that we're talking about in the query. This holds the base expression that we're expecting to use in this query.	limit	&lt;Integer&gt;	Some databases support limiting the number of rows retrieved. If we can, we'll use this variable to set that.	offset	&lt;Integer&gt;	Some databases support starting from a given point in the collection of retrievable rows, often used in combination with limit. So, e.g. get me the rows, sorted by name, starting at the 1012th and giving me 40 of them.	proxyType	&lt;Class | nil&gt;	If this is nil, do not use proxies. Otherwise, use this class to create proxies for relationships. At the moment, likely to be either Proxy or TimedProxy.	readsOneObject	&lt;Boolean&gt;	Do we return only one object, or a collection. That is, is this a readManyOf: or a readOneOf:	resultClass	&lt;Behavior&gt;	What kind of objects are we looking for.	shouldRefresh	&lt;Boolean&gt;	If the result is already in cache, should we refresh it according to what the database says, or just return it as is.	tracing	&lt;Tracing&gt;	The tracing. This describes the graph of objects we will actually retrieve.	whereClause	&lt;GlorpExpression&gt;	What is the criteria on which we will filter the results.</body></comment><class><name>AdabasLikePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AdabasLikePlatform</class-id><body>This is a platform for Adabas and related databases.</body></comment><class><name>AdabasDPlatform</name><environment>Glorp</environment><super>Glorp.AdabasLikePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AdabasDPlatform</class-id><body>This is a platform for the Adabas database.</body></comment><class><name>PersistentObject</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.PersistentObject</class-id><body>This is an abstract superclass for Glorp persistent objects. Things don't have to subclass from this in order to be persistent, but if they do, they will inherit some methods which may be useful.</body></comment><class><name>DatabaseAccessor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection currentLogin logging logger logOnly reusePreparedStatements deniedCommands mutex dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseAccessor</class-id><body>This translates between the the general, portable Glorp protocol and whatever needs to be done to access a database in a particular smalltalk dialect. Most of the real work is done in its subclasses.Subclasses must implement the following messages:	accessing		connectionClassForLogin:	executing		basicExecuteSQLString:		externalDatabaseErrorSignal		rowCount	login		loginIfError:		logout		showDialog:Instance Variables	connection	&lt;varies&gt;	The underlying database connection	currentLogin	&lt;Login&gt; The glorp-level login we are using	logging	&lt;Boolean&gt;	(default is false) Is logging on or off	logOnly &lt;Boolean&gt; (default is false) If logging is true, and logOnly is true, then the commands are ONLY logged and not executed.	logger &lt;TextCollector&gt; (default is Transcript) The user can put any TextCollector API supporting class in here to collect information. It must support #show: and #cr.	permittedCommands	&lt;Collection of: DatabaseCommand class&gt;	The list of commands we are permitted to use. This allows us to filter commands, indicating that a particular session should only be doing inserts right now, not updates, deletes, or queries. Or that it should only be doing writes, not reads.	reusePreparedStatements	&lt;Boolean&gt;	Should we try to reuse prepared statements,that have the same SQL, or just re-prepare each time.</body></comment><class><name>SqueakDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInTransaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-VW3</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SqueakDatabaseAccessor</class-id><body>A database accessor for Squeak.Instance Variables:	isInTransaction	&lt;Boolean&gt;	Are we in a transaction. We don't have an indicator for that from the database layer, so keep track of it here.</body></comment><class><name>GlorpAbstractNumericType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpMSSQLFloatType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpAbstractIntegerType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpSerialType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generated sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>DB2IdentityType</name><environment>Glorp</environment><super>Glorp.GlorpSerialType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.DB2IdentityType</class-id><body>DB2IdentityType represents identity column types in DB2. Glorp prefers sequences over identity columns, and uses sequences when generating schemas. But since pre-exisitng DB2 tables may contain identity columns, this class is necessary. See also, DB2Sequence and DB2IdentitySequence.</body></comment><class><name>GlorpCursoredStream</name><environment>Glorp</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command cursor mightHaveDuplicateRows builders buildersThatReturnResults databaseAccessor peekBuffer rawPeekBuffer statement </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpCursoredStream</class-id><body>This is a Glorp wrapper for a database cursor. It has stream-like behaviour, which is implemented by getting rows from the underlying cursor and constructing the objects as required. All queries go through one of these streams, although in the default case they will get all the results out of it (at which point the cursor will be closed) and then return them in another kind of collection. But it's possible to use one of these as the return type, in which case you can make use of the open cursor to incrementally get results.Instance Variables:	builders	&lt;(Collection of: ObjectBuilder)&gt;	The ObjectBuilders used to construct the objects we return out of the rows.	buildersThatReturnResults	&lt;(SequenceableCollection of: ElementBuilder)&gt;		command	&lt;DatabaseCommand&gt;	The command that was executed to give us this cursor.	cursor	&lt;&gt;	The underlying database cursor. Class varies by dialect. We deal with the lack of polymorphism by indirecting all cursor operations through the accessor.	databaseAccessor	&lt;DatabaseAccessor&gt;	The accessor that the command was executed against.	mightHaveDuplicateRows	&lt;Boolean&gt;	May this stream have duplicate rows? This can happen, for example, if we do a join that causes some sub-section of the row to be duplicated. If so, we need to check for this and remove duplicates from the object stream as we go. This forces us to peek ahead.	peekBuffer	&lt;Object&gt;	The peek buffer (holding an object) that we use when peeking ahead.	rawPeekBuffer	&lt;&gt;	The peek buffer (holding a row) that we use when peeking ahead. We need to buffer at both levels.	statement	&lt;GlorpPreparedStatement&gt;	The actual prepared statement that the command ran in order to get our results.</body></comment><class><name>GlorpSmallIntType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>IdentityTypeResolver</name><environment>Glorp</environment><super>Glorp.TypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.IdentityTypeResolver</class-id><body>This is a trivial type resolver (and the default one) that just uses a single class, with no inheritance.</body></comment><class><name>Cache</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items policy mainCache extraReferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.Cache</class-id><body>This is the per-class cache of instances read from the database.Instance Variables:	items	&lt;Dictionary from: Object to: Object&gt;	The cached items, keyed by their primary key values	policy	&lt;CachePolicy&gt;	The settings for this cache.</body></comment><class><name>BaseExpression</name><environment>Glorp</environment><super>Glorp.ObjectExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor availableSubSelectNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.BaseExpression</class-id><body>This represents the base object that we're looking for in a query. So if we ask to read: Person, then we will have a base expression corresponding to Person. Even if what we end up retrieving is not part of the Person object, it remains the base, because it's what defines our point of view.Instance Variables:	availableSubSelectNumber	&lt;Integer&gt;	As the base of the query, we keep track of how many subselects there are. New subselects will need to have a unique number so they can prefix their tables as e.g. s1t1 when aliasing them, and the number comes from this counter.	descriptor	&lt;Descriptor&gt;	The descriptor for the class we're looking for.</body></comment><class><name>SubSelectBaseExpression</name><environment>Glorp</environment><super>Glorp.BaseExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trueBase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.SubSelectBaseExpression</class-id><body>This is a special variation of a base expression which is used when we know we are a subselect. In some circumstances we'll need to operate with respect to the subselect base, as if we were a standalone query. But sometimes we'll need to know the broader context in which we're living. Having a separate subclass helps us distinguish.Instance Variables:	trueBase	&lt;MappingExpression&gt;	The base on which we are built. Note that this doesn't mean this is the overall base expression, in fact it's probably a mapping expression, it's just the thing from which this subselect was built. Presumably the ultimate base expression can be found by following that outer context down, but there could be multiple levels of subselects involved.</body></comment><class><name>FieldValueWrapper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents hasValue containedBy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.FieldValueWrapper</class-id><body>When we are creating our rowmap, we need to be able to unify values. That is, we express the constraint that field A in table T1 must be equal to field B in table T2. And we have to be able to do this whether or not we have yet assigned a value to either of these fields, and whether or not other equality constraints have already been imposed on one or the other of these fields. We do this by holding the values in a wrapper. When we unify them, we replace one wrapper with the other, so that both rows now refer to the same value. In order to efficiently find where things are contained, we hold a collection of the containing rows.Instance Variables:	containedBy	&lt;(Association key: DatabaseField value: (IdentitySet of: DatabaseRow)) | (IdentityDictionary of: Same)&gt;	The rows that contain this wrapper. Using a trick similar to #dependents, we optimize the containedByCollection to be an association if we are only contained in one row (the most common case). Otherwise we have a dictionary. The containing rows are indexed by field, because when we're updating the row to replace the wrapper, we need to know which field to replace. Also, a single row could conceivably contain the same wrapper in two different fields, and both need to be updated.	contents	&lt;Object&gt;	The value we contain	hasValue	&lt;Boolean&gt;	Has our value been set or not. We can't just test for nil in contents, because nil is a valid value.</body></comment><class><name>RelationExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relation leftChild rightChild outerJoin </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.RelationExpression</class-id><body>This represents a relationship between two sub-expressions, that is something like = or AND. So in object attribute = field, we're the equals node. We have exactly two children, and mostly just print ourselves in between them. However there is some other interesting logic in there about splitting up comparisons between objects into comparisons between keys, and even just printing can get fairly complicated.Instance Variables:	leftChild	&lt;GlorpExpression&gt;	The left child.	rightChild	&lt;GlorpExpression&gt;	The right child.	outerJoin	&lt;Boolean&gt;	Is this an outer join (only makes sense if we are an equality comparison.	relation	&lt;String&gt;	The string or symbol that we print for our relationship.</body></comment><class><name>CollectionExpression</name><environment>Glorp</environment><super>Glorp.RelationExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.CollectionExpression</class-id><body>This represents expressions on collection objects taking a block, which at the moment means just anySatisfy:We treat this as a relation, but with the special properties that when we convert the right hand side into an expression we assume it's a block and give it a base which is the left-hand side. Also, we don't print this relation when printing SQL, we just print the right hand side.</body></comment><class><name>CompoundQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queries operation primaryQuery specialBuilders requiresDistinct </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.CompoundQuery</class-id><body>This is a query that has more than one subquery, combined by expressions like UNION ALL or INTERSECTION. It doesn't do all that much except print its subqueries and combine them according to the operation.Instance Variables:	operation	&lt;String&gt;	The name of the operation we are using to combine the queries.	primaryQuery	&lt;Query&gt;	The first query that we contain. This determines what objects we actually return. All of the queries should match up in terms of what they return, or the database is unlikely to accept this as a valid query.	queries	&lt;(SequenceableCollection of: SimpleQuery)&gt;	The queries we contain.	specialBuilders &lt;Array of: ElementBuilder&gt; If we want to do something to modify our result, we can add our own set of builders here, which will be added to those of the internal queries. Motivating example is doing a horizontal inheritance query, where we can end up with one of N different objects in the row, and we just want to return that one directly.</body></comment><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLServerPlatform</class-id><body>This is a platform for the Microsoft SQL Server database.</body></comment><class><name>OracleSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count sequenceIncrement accessProtect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OracleSequence</class-id><body>This supports Oracle sequence using select nextval from sys.allObjects. It also supports getting multiple sequence numbers at once. Going against AllObjects seemed to work much better than going against any real table.Instance Variables:	accessProtect	&lt;RecursionLock | Semaphore&gt;	Mutual exclusion on our sequence allocation, since we may need to protect our cache of already-allocated numbers, and prevent two different processes from going to the database simultaneously. This might want to be pushed up to a superclass so it can be shared.	count	&lt;Number&gt;	How many identifiers have we gotten in a row without going to the database.	sequenceIncrement	&lt;SmallInteger&gt;	By how much does the sequence in the database increment on each nextVal call.</body></comment><class><name>DatabaseIndex</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MjlGlorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseIndex</class-id><body>This describes an index in the database. Glorp doesn't use it internally, other than when creating tables in the database.Instance Variables:	fields	&lt;(SequenceableCollection of: DatabaseField)&gt;	The set of fields that are to be indexed.	name	&lt;String&gt;	The name of the index. We will try and generate one based on the table if one is not supplied.</body></comment><class><name>ObjectBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queryCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.ObjectBuilder</class-id><body>This builds full-blown persistent objects with descriptors. This is the most common type of builder.</body></comment><class><name>GlorpVirtualCollection</name><environment>Glorp</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query session realObjects parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpVirtualCollection</class-id><body>This represents a virtual collection, i.e. one that we haven't really read into memory yet. It responds to a reasonable subset of collection protocol, and will read the elements into memory only when necessary. So, e.g. a select: operation takes a query block, and is equivalent to AND:ing that query block to the main query.To create a virtual collection, ask the session for one. e.g. session virtualCollectionOf: AClass.This is an initial version which will read in the objects fairly eagerly. An optimization might be to defer certain types of operations depending on whether the block can be evaluated into SQL or not. e.g.  collect: [:each | each name]can be turned into a retrieve: operation. But   collect: [:each | each printString]cannot. We could try to check the block for operations like collect: and detect:, deferring the point at which the objects will be read in.Handling of ordering is also a little bit funny. The blocks we like for ordering aren't compatible with sortedCollection type blocks. It'd be nice to be more compatible.</body></comment><class><name>DatabaseTableConstraint</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name table shouldCreateInDatabase fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseTableConstraint</class-id><body>Abstract superclass reifying a constraint on a value in a column or between values in columns.</body></comment><class><name>PrimaryKeyConstraint</name><environment>Glorp</environment><super>Glorp.DatabaseTableConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName schema type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PrimaryKeyConstraint</class-id><body>This is a class representing non-foreign key database constraints. It's not actually used for very much, but is mostly so we can model the metadata in the database's information_schema to get information we need about primary keys and other information that may be represented as constraints rather than field attributes.</body></comment><class><name>SQLite3Proxy</name><environment>Glorp</environment><super>Glorp.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SQLite3Proxy</class-id><body>SQLiteProxy is different from a normal proxy in that its &gt;&gt;glorpTriggerProxyAction: method passes back the result of the block, which the &gt;&gt;getValue method reassigns to the originally retrieved #value inst var. The idea is to have a proxy that represents a DatabaseField, when there is no such entity in any SQLite schema table, so it must be constructed from a variety of special SQLite3 function calls (called pragmas).</body></comment><class><name>ConstantExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ConstantExpression</class-id><body>This represents a literal constant. So, if object field = 2, this would be the (2) part.Instance Variables:	alias	&lt;String&gt;	Sometimes in queries we want to retrieve something specific in a column value. So, e.g. "select name as one, 2 as two from ...." Where we get back columns named 'one' and 'two', where the value of 'two' is always 2. The alias tells us what to alias the column for this as, if we're using this as something to be selected.	value	&lt;Object&gt;	The literal constant value.</body></comment><class><name>OneToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.OneToManyMapping</class-id><body>This represents a mapping from one object to a collection of others. This class is really only here for backward compatibility. Using ToManyMapping directly will give exactly the same behaviour.</body></comment><class><name>GlorpInMemorySequenceDatabaseType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>representationType </inst-vars><class-inst-vars>count </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>FixedSizeQueue</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maximumSize items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.FixedSizeQueue</class-id><body>This is a fixed size queue of objects. It's intended for keeping around a fixed number of references to objects in a weak dictionary. As such its API is rather limited (one method), and it's write-only.Instance Variables:	items	&lt;OrderedCollection&gt;	The items in the queue	maximumSize	&lt;Integer&gt;	How many items we're allowed</body></comment><class><name>PGSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PGSequence</class-id><body>This implements postgresql sequences using nextVal. The mechanism is similar to Oracle sequences, but we don't have to give it a table to select against when all we want is a bunch of numbers, so the implementation is simpler.</body></comment><class><name>SQLStringCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameters maximumBlobSizeToRetrieveDirectly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLStringCommand</class-id><body>This represents a command that executes arbitrary SQL and is not a select. For selects use SQLStringSelectCommand.</body></comment><class><name>GlorpCorePackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.GlorpCorePackage</class-id><body>This class represents package information for the GlorpCore package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>VersionType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingType generator generatesOverExistingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VersionType</class-id><body>This represents the type of something used for a version field.Instance Variables:	underlyingType	&lt;DatabaseType&gt;	The underlying type of our field.	sequence &lt;&gt; The generator used to generate the next value.</body></comment><class><name>GlorpWriteFailure</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpWriteFailure</class-id><body>This is the error we raise if we encounter an error trying to write some rows. This typically indicates an optimistic lock failure, although it might also happen if we violated a constraint.Instance Variables:	command	&lt;DatabaseCommand&gt;	The command we were trying to execute.	object	&lt;Object&gt;	The object or objects we were trying to write.</body></comment><class><name>InvalidSessionSetup</name><environment>Glorp</environment><super>Glorp.ValidationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.InvalidSessionSetup</class-id><body>InvalidSessionSetup will be raised the descriptor system we are validating is different from the current session descriptor.</body></comment><class><name>RowBasedCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>row allRows rowCount failed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.RowBasedCommand</class-id><body>This is a command based on one or more in-memory rows. The purposes is to write, or delete that row or rows. This knows enough to be able to use features like array binding to do the row operations more efficiently.Subclasses must implement the following messages:	bound values		arrayBoundFields		singleRowBoundFieldsInstance Variables:	allRows	&lt;(Collection of: (DatabaseRow))&gt; A collection of rows. May be nil. If we have multiples, then we will be array bound or otherwise bulk-written under certain circumstances.	row	&lt;DatabaseRow&gt;	The primary row, either the single row we're writing, or the one we're writing right now out of the allRows collection.	rowCount	&lt;Integer&gt;	The row count from the last statement we executed.	succeeded	&lt;Boolean&gt;	Has the statement overall succeded or failed.</body></comment><class><name>DeleteCommand</name><environment>Glorp</environment><super>Glorp.RowBasedCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DeleteCommand</class-id><body>A command to delete our set of rows.</body></comment><class><name>GlorpTimeStampType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>SubstringFunction</name><environment>Glorp</environment><super>Glorp.PrefixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.SubstringFunction</class-id><body>This is a function subclass specifically for substring functions. It needs its own separate subclass because it has to be written out differently for different databases, particularly if applied to LOB types.</body></comment><class><name>CachePolicy</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expiryAction numberOfElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.CachePolicy</class-id><body>A CachePolicy implements the different possible policies we might use for caching. The superclass implements the trivial policy of keeping all objects forever.The policy also controls what we store in the cache. In general, it's assumed to be a cache entry of some sort, and the policy is responsible for wrapping and unwrapping objects going to and from the cache. The default policy is that the objects themselves are the cache entry (saving one object per cached object in overhead).Instance Variables	size	&lt;Number&gt;	The minimum cache size we want to use.	expiryAction &lt;Symbol&gt; What to do when an object has expired. Currently hard-coded as one of #remove, #notify, #refresh, #notifyAndRemove.</body></comment><class><name>MultipleMappingsForInstanceVariable</name><environment>Glorp</environment><super>Glorp.ValidationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributeNames readableMappings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.MultipleMappingsForInstanceVariable</class-id><body>This error raises when validating a descriptor if there is more than one mapping to the same instance variable.Instance Variables:	attributeNames	&lt;Collection of String&gt;	the list of attributes referencing the same instance variable	readableMappings	&lt;Collection of Mapping&gt;	the list of mappings referencing the same instance variable</body></comment><class><name>VWDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driverSession preparedStatements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-VW3</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VWDatabaseAccessor</class-id><body>An accessor for VisualWorks EXDI connections.Instance Variables:	driverSession	&lt;ExternalDatabaseSession&gt;	If we aren't re-using prepared statements, then we work directly with a single EXDI session that we keep hold of and reuse for each command.	preparedStatements	&lt;CacheManager&gt;	A cache of prepared statements that we can re-use, if the session is set appropriately.</body></comment><class><name>TimedProxy</name><environment>Glorp</environment><super>Glorp.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id reaper secondsToLive timeToDie association </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.TimedProxy</class-id><body>This is a proxy which only holds onto its value for a fixed amount of time, and then uninstantiates. This is useful in highly-connected object graphs, where we might like to get rid of parts of a large tree that we are no longer using, but where simple weak references won't give enough information. For one to one relationships, we can cut the proxy relation, the object will remain in cache if it is registered or being otherwised referenced, and if we ask for it again, we won't have to go to the database because it will be found in cache. It's probably not such a good idea to use these kind of proxies for collections, where we will have to go to the database again if we need the value. See also TimedProxyReaper.Instance Variables:	association	&lt;Association&gt; The association in the TimedProxyReaper which holds onto our identifier plus a time after which we should expire.	id	&lt;Integer&gt;	An ID, assigned to us by the reaper, so that it doesn't hold strong references to us.	reaper	&lt;TimedProxyReaper&gt;	The reaper which controls this proxy.	secondsToLive	&lt;ArithmeticValue&gt;	How much time, in seconds, we should wait after we were last touched before expiring.	timeToDie	&lt;Integer&gt;	The millisecond clock value at which we expire. Is this a problem if there are dialects/versions for which the millisecond clock wraps around?</body></comment><class><name>JoinBaseExpression</name><environment>Glorp</environment><super>Glorp.BaseExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.JoinBaseExpression</class-id><body>When we use an expression as a join, we tend to write it backwards. We use expressions when the relationship is more complicated than we can express as a single join. And we describe it by giving the target and describing how to use relationships to get from the target object to the source object. We can't do it forwards, because the forward relationship is exactly what we're trying to describe with this join. For example, for a (rather contrived) Address to Job relationship, we might write it as  [:eachJob | eachJob worker address]However, this means that when we're trying to rebuild this expression and fit it into a query, it's backwards from most expressions. We know that, so we give it a special kind of base that makes it rebuild itself slightly different, by preferring the target rather than the source.  </body></comment><class><name>VADatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInTransaction </inst-vars><class-inst-vars>databaseErrorSignal </class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VADatabaseAccessor</class-id><body>An accessor for VisualAge 8.0 and higher. Instance Variables	isInTransaction	&lt;Boolean&gt;	Are we in a transaction. We don't have an indicator for this from the database layer, so keep track of it here.</body></comment><class><name>MessageArchiver</name><environment>Glorp</environment><super>ProtoObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mySelector myArguments myReceiver query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.MessageArchiver</class-id><body>This is what we use to construct GlorpExpression trees out of blocks. An instance of MessageArchiver is passed into the block. It has a doesNotUnderstand: handler, and in response to almost any message, will just return a new MessageArchiver which knows it is descended from this one. The result (assuming no inlined messages or other tricky stuff happened) is a tree of MessageArchivers recording all the sent messages. We can then traverse that and construct the appropriate expression tree.Instance Variables:	myArguments	&lt;(Collection of: (Object | ProtoObject))&gt;	The arguments to the message that caused me to be constructed.	myReceiver	&lt;MessageArchiver | nil&gt;	The object that received the message that caused me to be constructed. For the initial MessageArchiver that's passed in, this will be nil. Otherwise it is a MessageArchiver.	mySelector	&lt;Symbol&gt;	The selector of the message that caused me to be constructed.	query	&lt;AbstractReadQuery&gt;	The query for which I am constructing the expression. This is here so that we can construct the final expression tree directly onto its BaseExpression.</body></comment><class><name>MappingExpression</name><environment>Glorp</environment><super>Glorp.ObjectExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name base outerJoin mapping phantom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.MappingExpression</class-id><body>This represents an attribute of some other object. It's called a mapping expression because each attribute has a mapping, and when we come to prepare the query, we'll be using that mapping's information to deduce joins, and to print properly.Instance Variables:	base	&lt;BaseExpression | MappingExpression&gt;	The expression we are built on, which is to say the expression describing the object of which we are an attribute.	mapping	&lt;Mapping&gt;	The mapping we correspond to in the base. So if the base was [:each | each owner city] and we are #name, then we the mapping is for the attribute #name in the descriptor for City.	name	&lt;Symbol&gt;	The name of our attribute. We will use this to determine the mapping.	outerJoin	&lt;Boolean&gt;	Are we to interpret the join to our parent object's table as being an outer join or not?	phantom &lt;Boolean&gt; Is this a phantom mapping - one which is not defined in the descriptor explicitly, but is temporarily created to define a reverse relationship, an alsoFetch of subclasses, or some other transient usage.</body></comment><class><name>OcelotPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OcelotPlatform</class-id><body>This is a platform for the open-source Ocelot database.</body></comment><class><name>FirebirdPlatform</name><environment>Glorp</environment><super>Glorp.OcelotPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.FirebirdPlatform</class-id><body>This is a Glorp platform for the InterBase and Firebird databases.  It is currently subclassed from Ocelot because both claim to be highly standard-compliant.  It would probably be better if both inherited from some sort of abstract SQL92Platform.Firebird/InterBase supports binding in all statements (indeed its EXDI appears to require it for blobs) and can also reuse SELECT statements, but reuse of RowBasedCommands (INSERT, DELETE, UPDATE) for blobs is unreliable although binding of such statements is essential.  Set	reusePreparedStatements: falseon Logins that have an instance of this class as their platform.</body></comment><class><name>ParameterExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base lookupKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ParameterExpression</class-id><body>This is an expression representing a placeholder for a parameter value. So, e.g. object attribute = &lt;parameter for field OWNER_ID&gt;. This is most frequently used for the queries in proxies, although it can be used anywhere. The parameter can be identified by either a field, a name, or an index, which can get fairly ugly.Instance Variables:	base	&lt;GlorpExpression&gt;	Our base expression.	lookupKey	&lt;DatabaseField | SomethingElse&gt;	The thing based on which we look up our parameter value in the array or dictionary of parameters that's passed to the query. So it can be number (for positional usage), a field, or something else.. </body></comment><class><name>GlorpDateType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpBooleanType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpExtensionsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpExtensions</package></attributes></class><comment><class-id>Glorp.GlorpExtensionsPackage</class-id><body>This class represents package information for the GlorpExtensions package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>EmptyExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.EmptyExpression</class-id><body>This represents the null expression, but more polymorphically than just sticking nil in the where clause. We also use this as a short-circuiting mechanism if we're given a where clause that is either just literal true or literal false. So if you end up creating a query with a literal false, we will never go to the database, we'll just return an empty collection as the result. This is more useful than you might think.Instance Variables:	base	&lt;GlorpExpression&gt;	Our base expression, which we'll use in case someone ANDs or ORs something onto us.	value	&lt;Boolean| nil &gt; If we are true or false, then this result may end up being short-circuited. If it's nil, then we're just an empty where clause.</body></comment><class><name>RowMapKey</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key1 key2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.RowMapKey</class-id><body>This class serves as a key for a dictionary containing two sub-keys, where we want to be able to look up based on the identity of both sub-keys paired together. This is used primarily for many-to-many mappings indexing into rowmaps, where we want to key the row by the identity of the object that determines it, but there are two of them.Instance Variables:key1	&lt;Object&gt;	One sub-key.key2	&lt;Object&gt;	The other sub-key.'</body></comment><class><name>DuplicatePrimaryKeyException</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>existingObject newObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.DuplicatePrimaryKeyException</class-id><body>This is an exception we raise when we detect two different objects with the same primary key in our cache.</body></comment><class><name>GlorpIllegalCommand</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpIllegalCommand</class-id><body>This is the exception we raise if we try to execute a command for which permission has been denied at the Glorp level. e.g. we try to insert while denyWrites is active.Instance Variables:	command	&lt;DatabaseCommand&gt;	The command we tried to execute.</body></comment><class><name>Join</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources targets base outerJoin owningMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.Join</class-id><body>This is a specialized variety of expression that is more constrained and is used for defining relationships. It has two main purposes - ease of construction: Relationships are normally defined by field to field equality expressions (my foreign key field = his primary key field). These are more tedious to create via block expressions, so this provides a simpler syntax. - constrained semantics. These define both read and write for the relationship, so fully general expressions won't work (most notably, relations other than equality are hard to write). Using a primaryKeyExpression ensures that we satisfy these constraints.I'm not completely sure this class is a good idea. It makes for an annoying assymetry between different kinds of expressions. This is especially notable now that we allow sources to be constants. It's possible that all we need is an expression constructor that generates real expressions, but with more convenient syntax and ensuring that the constraints are met.Note that although these are typically fk=pk, it's allowed to be the other way around -- i.e. our object-level relationships can be the opposite of the way the fk's "point" in the database.Instance Variables:	base	&lt;BaseExpression&gt;	The base on which we are built. Mostly used if we want to convert this into a real expression.	sources	&lt;SequenceableCollection of: (DatabaseField | ConstantExpression)&gt; The source fields (typically the foreign keys)	targets	&lt;SequenceableCollection of: DatabaseField&gt; The target fields (typically the targets of the foreign keys)</body></comment><class><name>DatabaseField</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table name isPrimaryKey position type isNullable isUnique isLockKey defaultValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseField</class-id><body>This represents a field in a database table. See also DatabaseTable. Glorp relies heavily on identity of fields for comparison purposes, so be careful when copying these.Instance Variables:	defaultValue	&lt;Object&gt;	What is the default value of this field, if unspecified in the creation statement.	isLockKey	&lt;Boolean&gt;	Is this field part of an optimistic lock key. If so, then on update we will generate an update statement that checks that this value hasn't changed since the object wasn't read.	isNullable	&lt;Boolean&gt;	Is this field allowed to be null?	isPrimaryKey	&lt;Boolean&gt;	Is this field part of the primary key?	isUnique	&lt;Boolean&gt;	Does this field have a unique constraint in the database?	name	&lt;String&gt;	The name of the field.	position	&lt;Object | ProtoObject&gt;	description of position	table	&lt;DatabaseTable&gt;	The table that contains this field.	type	&lt;GlorpDatabaseType&gt;	The type of  data that this field contains.</body></comment><class><name>GlorpAbstractStringType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width queryType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpClobType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpMySQLClobType</name><environment>Glorp</environment><super>Glorp.GlorpClobType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpMySQLClobType</class-id><body>MySQL clobs come back from the driver as binary data, so we need to make a subclass that knows it needs a converter for its incoming data.</body></comment><class><name>GlorpDictionaryDescription</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyExpression valueExpression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpDictionaryDescription</class-id><body>When querying for a dictionary, it's not enough to tell the query to return its collection in a dictionary. We need to be able to describe both the key and the value. So we would pass an instance of this as the collectionType: to a query or mapping.Instance Variables:	keyExpression	&lt;GlorpExpression | Block&gt;	The description of the key	valueExpression	&lt;GlorpExpression | Block&gt;	The description of the value</body></comment><class><name>TypeMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.TypeMapping</class-id><body>TypeMappings are used to implement inheritance. They do not map to particular instance variables, but instead define things about the way the class is read. The default type mapping is IdentityTypeMapping, which does nothing. To use inheritance, substitute either a FilteredTypeMapping or a HorizontalTypeMapping. TypeMappings become part of a TypeResolver, which keeps the information for a class and its subclasses, each of which will have a typeMapping specific to that class.Subclasses must implement the following messages:	testing		isAbstract</body></comment><class><name>TimedProxyReaper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>weakValueDictionary keysSortedByExpiryTime indexOffset mutex reaperThread delay maximumWork nextId timeout done startTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.TimedProxyReaper</class-id><body>Overview:A TimedProxyReaper collects TimedProxies and, using a background process, uninstantiates when they are due to expire. You can control the number of seconds between each invocation of the background process, with the message #delay:, and you can control the amount of work the background process will do each time it runs with the message #maximumWork:.API Methods:</body></comment><class><name>TransformingFieldValueWrapper</name><environment>Glorp</environment><super>Glorp.FieldValueWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>forwardTransformation inverseTransformation innerWrapper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpUnitOfWork</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.TransformingFieldValueWrapper</class-id><body>This wraps another wrapper and transforms its value.Instance Variables:	forwardTransformation	&lt;Block&gt;	What to do to convert our value going out.	innerWrapper	&lt;FieldValueWrapper&gt;	The wrapper that really has the value.	inverseTransformation	&lt;Block&gt;	What to do to convert our value going in.</body></comment><class><name>FilteredTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field key keyDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.FilteredTypeMapping</class-id><body>FilteredTypeMapping assumes that all objects are stored in a single table, and there's a field in that table that identifies which subclass it is.Instance Variables:	field	&lt;DatabaseField&gt;	The field which identifies the subclass.	key	&lt;Object&gt;	The value we expect to find in that field for this particular subclass	keyDictionary	&lt;Dictionary&gt;	A dictionary for us and all of our subclasses from key values to subclass.</body></comment><class><name>JoinPrinter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>joinsToProcess availableTables query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.JoinPrinter</class-id><body>This is a helper class used for printing collections of joins in the &lt;expletive deleted&gt; ANSI join syntax. This syntax wants us to embed all of the joins into the initial list of tables, so we have to come up with an order for printing that makes sure we get all the joins in properly. This is more complicated than you might think.Instance Variables:	availableTables	&lt;(Collection of: DatabaseTable)&gt;	Which are the tables that we plan to print.	joinsToProcess	&lt;(Collection of: Join)&gt;	Which joins do we have to put in between those tables somehow or other.	query	&lt;Query&gt;	What is the query in which we are printing all of this.</body></comment><class><name>WeakVWCachePolicy</name><environment>Glorp</environment><super>Glorp.CachePolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.WeakVWCachePolicy</class-id><body>This is a cache policy that uses VisualWorks 7.x weak references (ephemerons) to store references to objects, letting them vanish if not referenced. It uses the numberOfElements inst var as an indicator of how many objects to keep hard references to, preventing objects from disappearing too quickly.Instance Variables:</body></comment><class><name>TableSorter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderedTables tables visitedTables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.TableSorter</class-id><body>This implements a topological sort for tables, based on the foreign key constraints between them.Instance Variables:	orderedTables	&lt;Collection of: DatabaseTable&gt;	The resulting tables in sorted order.	tables	&lt;(Collection of: (DatabaseTable))&gt;	The input tables.	visitedTables	&lt;IdentitySet of: DatabaseTable&gt;	The tables we have already visited during the sort.</body></comment><class><name>GlorpDoubleType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>MySQLPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.MySQLPlatform</class-id><body>This is a definition for MySQL databases. It's not done yet, just here as a placeholder.</body></comment><class><name>DictionaryMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyMapping valueMapping associationDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DictionaryMapping</class-id><body>This allows us to map a dictionary into tables. It should, I hope, support arbitrarily either mapping to single fields, or to objects, for either the key or the value. At the moment, it at least passes the tests for the value-&gt;object and value-&gt;value cases.Instance Variables:	keyMapping	&lt;DatabaseMapping&gt;	The mapping to use to read/write the key. It should be for an attribute named #key.	valueMapping	&lt;DatabaseMapping&gt;	The mapping to use to read/write the value. It should be for an attribute named #value. Note that this is optional, and isn't a full blown mapping, because if we have a relationship, we will normally just use this mapping to describe it directly. If we have a direct mapping for the value, then we have this odd situation where we use the Join from this mapping, but the direct mapping to control the read/write of the variable.	associationDescriptor	&lt;Descriptor&gt;	We manipulate the key/value pairs as associations in some places, and have a mock descriptor for association, specific to this mapping, which is used to get the key/value.</body></comment><class><name>BasicDictionaryMapping</name><environment>Glorp</environment><super>Glorp.DictionaryMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.BasicDictionaryMapping</class-id><body>This class is obsolete, but exists only so that people using the old name will not have to change their code.</body></comment><class><name>GlorpClassModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system describedClass subclasses attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.GlorpClassModel</class-id><body>This holds the metadata describing a class. Since Smalltalk classes are fairly self-describing, this mostly consists of the names and types of the instance variables that we want to be persistent. If those variables are collections, we also want to know the types of the items in the collections.Instance Variables:	attributes	&lt;(Collection of: GlorpAttributeModel)&gt;	Our attributes, one for each instance variable.	describedClass	&lt;Class&gt;	The class we hold metadata for.	subclasses	&lt;Array of: Class&gt;	The collection of subclasses of our describedClass. Computed automatically, and used as a performance optimization for inheritance testing.	system	&lt;DescriptorSystem&gt;	The system that contains us.</body></comment><class><name>ExpressionGroup</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ExpressionGroup</class-id><body>This isn't really an expression, in that it can never occur due to parsing. It's a way of grouping several expressions together so that we can process them together, essentially making sure that the iteration methods will loop over all the expressions, but only do each node once, even if it occurs in multiple expressions.  This is used in processing order expressions to figure out what tables and join expressions we need.Because it is only used in transient ways, it probably doesn't implement all the required operations for normal expression usage.</body></comment><class><name>SQLite3Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLite3Platform</class-id><body>I support Glorp's use of the SQLite database;  see http://www.sqlite.org.  Some notes on the implementation:SQLite provides no specific support for time-related data other than column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSI therefore map Date, Time and Timestamp to and from strings via #to... and (inherited) #read... methods whose formats agree with these functions.  (I also return false to #supportsMillisecondsInTimes, again in agreement with the above functions which do not include millliseconds.)My #maximumLengthOfTableName value is limited purely for convenience;  it can probably be much larger.In VW, this version uses the non-threaded SQLite3Connection EXDI class.  Make my #vwEXDIConnectionClass return SQLite3ThreadedConnection to make Glorp use the threaded interface and, if using this with Store, also change its string reference in #asGlorpDatabase, #databaseFor:.  Alternatively, create an SQLlite3ThreadedPlatform subclass of me and add an extra line, instead of changing a line, to the Store methods.  (Note that in order to be thread-safe, your SQLite installation must be compiled with the SQLITE_THREADSAFE preprocessor macro set to 1.  In SQLite3, both the Windows and Linux precompiled binaries in the distribution are compiled this way.  If you are unsure if the SQLite library you are linking against is compiled to be threadsafe you can call the sqlite3_threadsafe()  interface to find out.)SQLite parses FOREIGN KEY constraints but does not enforce them.SQLite's approach to data typing is unusual for SQL.  Its data values are:	NULL	INTEGER. The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value.	REAL. The value is a floating point value, stored as an 8-byte IEEE floating point number.	TEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16-LE).	BLOB. The value is a blob of data, stored exactly as it was inputbut its typing is dynamic, so any column can in principle store any value, and its column affinities are	TEXT - can store NULL, TEXT or BLOB	NUMERIC - can store all five; text values that converts to reals or integers without loss of information are so stored	INTEGER - as NUMERIC plus reals that convert to integer without loss of information are so stored	REAL - as NUMERIC but integer values are coerced to reals	NONE - no coercion is performed.My int* and float*/double type methods that define Glorp types for SQLite conform to the expressibility of the above data values.</body></comment><class><name>CannotAutomaticallyDetermineJoin</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraints tables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.CannotAutomaticallyDetermineJoin</class-id><body>When we create descriptors, Glorp will try to determine the join to use between two tables based on foreign key constraints, if it hasn't been specified explicitly. If we can't find any foreign key constraints, or if we find too many, and can't decide automatically which one to use, we raise this exception.This is an exception raised when creating Instance Variables:	constraints	&lt;Array of: ForeignKeyConstraint&gt;	The list of constraints we found.	tables	&lt;Collection of: DatabaseTable&gt;	The two tables we were trying to find a join between.</body></comment><class><name>VersionNumberVersionGenerator</name><environment>Glorp</environment><super>Glorp.VersionGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VersionNumberVersionGenerator</class-id><body>This generates version numbers by adding one to the previous value of the designated field.</body></comment><class><name>GlorpMSSQLSysnameType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>MultipleRowMapKey</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpUnitOfWork</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.MultipleRowMapKey</class-id><body>This is a special (and rarely needed) form of row map key that allows an arbitrary number of objects to participate in it.</body></comment><class><name>RowMap</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowDictionary hasDeletions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.RowMap</class-id><body>This is the central class used for writing. We build up a collection of rows that are to be written, indexed by the objects that "own" them. While any object can contribute values to a row (for example, in a relationship, the value of a field that is a foreign key may come from the primary key of another object) it is a central assumption that each row is owned by a single object. Once we know all the rows, we can compute which ones have changed from their previous database values (see RowMapForMementos) and which fields within them have changed, and then we can write them out.Instance Variables:	hasDeletions	&lt;Boolean&gt;	Do we have any deletions. Deletions are marked by a flag in the row, but it's useful to know quickly if we have any or not.	rowDictionary	&lt;(Dictionary from: DatabaseTable to: (Dictionary from: Object to: DatabaseRow)&gt;	The rows, indexed by their table, then by the owning object.</body></comment><class><name>RowMapForMementos</name><environment>Glorp</environment><super>Glorp.RowMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars>correspondenceMap reversedCorrespondenceMap collectionMementos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.RowMapForMementos</class-id><body>This is a specialized version of RowMap for creating rowmaps out of the mementos in the undo/correspondence map. When doing partial writes we create a rowmap for the current state of the objects, then a rowmap for the original state, and difference the two.The tricky part is that the mementos refer back to the original objects, so when we establish unification constraints between rows, they would establish them to original objects. This is wrong, and not trivial to debug.So this rowmap keeps the correspondence map and knows that it has to compensate and get the memento for any related objects.</body></comment><class><name>UniqueConstraint</name><environment>Glorp</environment><super>Glorp.DatabaseTableConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.UniqueConstraint</class-id><body>UniqueConstraint implementation has not been finishedInstance Variables:	isForPrimaryKey	&lt;Boolean&gt;	description of isForPrimaryKey</body></comment><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.GlorpSession</class-id><body>This is the main class for communicating between the user and Glorp. It acts as a broker for reading queries, and as the main point for registering objects for modification.Instance Variables:	system	&lt;DescriptorSystem&gt;	The definition of our tables, classes, and the relationships between them.	currentUnitOfWork	&lt;UnitOfWork | nil&gt;	If we have an active unit of work, this will hold it. All modifications are tracked through the unit of work.	cache	&lt;CacheManager&gt;	Our cache of objects that we've already read.	accessor	&lt;DatabaseAccessor&gt;	Our connection to the database.	application	&lt;?&gt;	application-specific data	reaper &lt;TimedProxyReaper&gt; If we are using TimedProxy for some of our relationships, this holds the reaper which will expire them on timeout.	errorAction &lt;Block&gt; What block should we evaluate when there's an error.	modificationTracker &lt;GlorpVWWriteBarrierTracker&gt; VisualWorks-specific. This holds the GlorpVWWriteBarrierTracker in use for this session. This uses immutability to keep track of objects which are changed.</body></comment><class><name>Dialect</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>dialectName timestampClass lookedUpNames isNamespaceAware lastSystemTime lastServerTime </class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.Dialect</class-id><body>This is an encapsulation layer for dialect differences between Smalltalk. It has a variety of class messages that do different things depending which dialect we are running on.</body></comment><class><name>DirectMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field converter shouldProxy query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DirectMapping</class-id><body>This is the simplest type of mapping, it maps directly between an instance variable that holds some "primitive" type, and a field in a database table.Instance Variables:	converter	&lt;DatabaseConverter&gt;	The converter used to transform the data into database form and back again. This will be automatically computed based on the types defined, if possible, but for more complex conversions (e.g. booleans into strings in the database) a converter can be explicitly specified.	field	&lt;DatabaseField | FunctionExpression&gt;	The field to write to. One complication is that (for reading purposes) the field may be a function. So we might have a mapping that reads from the TO_UPPER of some field, or even an aggregate function like MAX.</body></comment><class><name>ForeignKeyConstraint</name><environment>Glorp</environment><super>Glorp.DatabaseTableConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suffixExpression sourceFields targetFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.ForeignKeyConstraint</class-id><body>This represents a foreign key constraint in the database. It's used during table creation, but more important it's used when calculating the order in which we need to write rows. Also, if joins aren't specified on a relationship, we will try to infer them from the foreign key constraints.Instance Variables:	name	&lt;Object&gt;	The name of the constraint.	shouldCreateInDatabase	&lt;Boolean&gt;	We may have table definitions that we don't want to create in the database, either because we know they're already there, or because they are for "imaginary" tables.	sourceFields	&lt;(SequenceableCollection of: DatabaseField)&gt;	The fields we constrain from. The order is fairly arbitrary, but at least we use it consistently.	suffixExpression	&lt;String&gt;	A bit of a hack to allow us to append some extra text to the constraint. In particular, added to suppor the ability to append "ON DELETE CASCADE".	targetFields	&lt;(SequenceableCollection of: DatabaseField)&gt;	The fields we constraint to.</body></comment><class><name>GlorpDatabaseWriteError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command databaseError accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseWriteError</class-id><body>This is the error we raise when we encounter an exception inside Glorp's database write code. This is uniform across dialects, so it can be reliably caught. We wrap the underlying exception.Instance Variables:	accessor	&lt;DatabaseAccessor&gt;	The accessor we were executing against.	command	&lt;DatabaseCommand&gt;	The command we were executing	databaseError	&lt;Exception&gt;	The exception that the system raised.</body></comment><class><name>UnitOfWork</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session transaction deletedObjects newObjects rowMap commitPlan deletePlan rowsByTable succeeded linkRowsForUpdate commitPhase deleting </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.UnitOfWork</class-id><body>A UnitOfWork keeps track of objects which might potentially be modified and lets you roll them back or commit the changes into the database.Instance Variables:	newObjects	&lt;IdentitySet of: Object&gt;	The objects registered with us as being new (i.e. not existing already in the database)	session	&lt;Session&gt;	The session in which this is all taking place.	transaction	&lt;ObjectTransaction&gt;	Keeps track of the original object state so that we can revert it.	rowMap	&lt;RowMap&gt;	A holder for the rows when we are writing out changes.	commitPlan	&lt;(OrderedCollection of: DatabaseRow)&gt;	The list of rows to be written, in order. Constructed by topological sorting the contents of the row map.	calculatingRows &lt;Boolean&gt; Are we in the process of computing the rows to be written. If so, we should not be doing reads and registrations - it's probably an error in the mapping code by accidentally forcing a read.</body></comment><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DescriptorSystem</class-id><body>This holds onto the Glorp metadata. Each session will have a DescriptorSystem associated with it, which describes the tables, descriptors, and class models that are to be made persistent.Subclasses must implement the following messages:	accessing		allTableNames		constructAllClassesInstance Variables:	allClasses	&lt;Collection of: Behavior&gt;	The classes we have metadata for.	cachePolicy	&lt;CachePolicy&gt;	The default cache policy to use. Descriptors can override this.	classModels	&lt;Dictionary from: Behavior to: GlorpClassModel&gt;	Our class models, indexed by class.	descriptors	&lt;Dictionary from: Behavior to: Descriptor&gt;	Our descriptors, indexed by class.	platform	&lt;DatabasePlatform&gt;	The platform for which we will be used. This is required because the table definitions will refer to the platform in order to get the appropriate types for fields.	sequences	&lt;Dictionary from: String to: DatabaseSequence&gt;	The sequences that we have available, indexed by name asUppercase.	session	&lt;GlorpSession&gt;	The session we provide metadata to.	tables	&lt;Dictionary from: String to: DatabaseTable&gt;	Our database tables, indexed by name asUppercase.	typeResolvers	&lt;Dictionary from: Behavior to: TypeResolver&gt;	The type resolvers that we will use for inheritance, indexed by class.	useDirectAccessForMapping	&lt;Boolean&gt;	By default, should we use direct instance variable access (instVarAt:) or send get/set messages. Individual attributes can override this.	useJoinsForAnySatisfy	&lt;Boolean&gt;	By default, should we use joins for anySatisfy and similar queries, or should we use EXISTS subselects.</body></comment><class><name>MySQLSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.MySQLSequence</class-id><body>This is a sequence type for MySQL AutoIncrement fields.</body></comment><class><name>GlorpNumericType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>precision scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>TableBasedSequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequenceTableName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.TableBasedSequence</class-id><body>This is a sequence that gets its values from a sequence table. It doesn't look like it's fully implemented, or used.Instance Variables:	sequenceTableName	&lt;String&gt;	The name of the sequence table to use.</body></comment><class><name>VariableJoin</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>joins </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.VariableJoin</class-id><body>This represents a join that could be to multiple different tables, e.g. when using horizontal inheritance.Instance Variables:	joins	&lt;Dictionary from: Class to: Join&gt;	description of joins</body></comment><class><name>JustSelectTheMaximumSequenceValueAndAddOne</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field table </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.JustSelectTheMaximumSequenceValueAndAddOne</class-id><body>This is a sequence that just does a select max(primaryKeyFieldName) for the table in question and adds one to it. This is, um, less-than-perfectly efficient, and I'm not at all clear that it'll work for a multi-user system. But it's what Store used to do on SQL Server, so we'd like to be able to mimic it. And it's actually easier to preallocate for than identity columns, which is nice. This isn't really named in the same sense as the others, but it's useful to inherit the named preallocation behaviour, and we store the field to select against in the name.Instance Variables:	tableName	&lt;DatabaseTable&gt;	the table we sequence.	field &lt;DatabaseField&gt; the field we sequence.</body></comment><class><name>TimedExpiryCachePolicy</name><environment>Glorp</environment><super>Glorp.CachePolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.TimedExpiryCachePolicy</class-id><body>This implements a cache that notes that an object is stale after some amount of time since it has been read.Instance Variables:	timeout	&lt;Integer&gt;	The time in seconds until we note an object as needing refreshing.</body></comment><class><name>AccessPlatform</name><environment>Glorp</environment><super>Glorp.SQLServerPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AccessPlatform</class-id><body>This is a platform for the Microsoft Access database. It subclasses from SQL Server, because the two have a number of characteristics in common.</body></comment><class><name>GlorpCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>UpdateCommand</name><environment>Glorp</environment><super>Glorp.RowBasedCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.UpdateCommand</class-id><body>A command to update our set of rows.</body></comment><class><name>SimpleQuery</name><environment>Glorp</environment><super>Glorp.AbstractReadQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builders fields joins tablePrefix customCommand tablesToPrint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SimpleQuery</class-id><body>This is a query that is directly executable. A single query might be more than we can do in a single database read, so we might have to break it down into simple queries. But at the moment we just break anything down into an equivalent single query.Instance Variables:	builders	&lt;OrderedCollection of: ElementBuilder)&gt;	The builders that will assemble the object from the row that this query returns.	fields	&lt;OrderedCollection of: DatabaseField&gt;	The fields being selected.	joins	&lt;OrderedCollection of: Join&gt; While preparing the query, we will need to build up a list of joins implied by the relationships in the where clause, ordering, and so forth. This acts as storage for those.	tablePrefix	&lt;String&gt;	If we are part of a subselect, we want to prefix all of our table aliases with some known, common prefix, so that we won't have our own t1 which would get confused with the parent query's t1. The normal convention is something like 's1' for subselect 1, so we get s1t1, and so forth.	command &lt;DatabaseCommand&gt; We can tell the query to use a specific command instead of generating one appropriately. Note that if this is set, it overrides most of the other sql generation.</body></comment><class><name>SQLite3PragmaQuery</name><environment>Glorp</environment><super>Glorp.SimpleQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SQLite3PragmaQuery</class-id><body>This is a query intended to execute a SQLite3 PRAGMA command. The command behaves like a stored function that takes a parameter and returns a result set. The meta information schema for SQLite is not available in the standard views, but it can be eventually deduced by executing particular pragma commands.</body></comment><class><name>SAPDBPlatform</name><environment>Glorp</environment><super>Glorp.AdabasLikePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SAPDBPlatform</class-id><body>Ths is a platform for SAPDB.</body></comment><class><name>GlorpVarBinaryType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>AddingWriteStream</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>GlorpExtensions</package></attributes></class><comment><class-id>Glorp.AddingWriteStream</class-id><body>Why *can't* you stream onto a set? Or a bag, or a SortedCollection? No good reason that I can see. This implements only a subset of stream behaviour, that which is necessary to let us build up collections where we have to "append" elements using #add: rather than #at:put: and explicit grows.Instance Variables:	target	&lt;Collection&gt;	The thing we're streaming onto.</body></comment><class><name>CacheManager</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subCaches session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.CacheManager</class-id><body>This is the entire cache for a session, consisting of multiple sub-caches, one per class.Instance Variables:	session	&lt;Session&gt;	The containing session.	subCaches	&lt;Dictionary from: Class to: Cache&gt;	The per-class caches.</body></comment><class><name>GlorpAttributeModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type collectionType keyType classModel attributeIndex useDirectAccess setSelector canRead canWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.GlorpAttributeModel</class-id><body>This is the metadata for an individual instance variable. It will be held in a GlorpClassModel, and used for accessing the variable when building or writing out objects.Instance Variables:	attributeIndex	&lt;Integer&gt;	What is the index in the class of the instance variable. Used if we are using instVarAt: to get values.	classModel	&lt;GlorpClassModel&gt;	The class model that contains us.	collectionType	&lt;Class&gt;	If we are an attribute that holds a collection, what is the class of the collection.	keyType	&lt;Class&gt;	If we represent a dictionary attribute, what is the type of our key (type will be used for the type of the value).	name	&lt;Symbol&gt;	The name of the attribute/instance variable.	setSelector	&lt;Symbol&gt;	If we are using message access to get/set values, what is the selector to use for setting. Defaults to name, ':'.	type	&lt;Class&gt;	The class containing this instance variable	useDirectAccess	&lt;Boolean&gt;	If true (the default) we use instVarAt:/instVarAt:put: to access the attribute values.</body></comment><class><name>GlorpExpressionsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.GlorpExpressionsPackage</class-id><body>This class represents package information for the GlorpExpressions package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>GlorpMiscPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpMiscPackage</class-id><body>This class represents package information for the GlorpMisc package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>SQLServerSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLServerSequence</class-id><body>This implements SQL Server sequences, which aren't really sequences at all, but identity columns. That means we can't do more than one at a time, and we have to do an extra select to get the value back.</body></comment><class><name>AdHocMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fromDbMappingBlock toDbMappingBlock mappedFields shouldProxy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.AdHocMapping</class-id><body>AdHocMapping is a configurable sort of mapping, done via two blocks. It's not easy to use, but gives you very direct access to the underlying mechanisms, so it should be possible to write mappings that are otherwise very complicated or impossible.Instance Variables:	fromDbMappingBlock	&lt;BlockClosure&gt;	The block we invoke when reading from the database. It's given arguments of the "row" we got from the database (note that this doesn't necessarily correspond to a single row, but is all the fields we selected in the query) , the elementBuilder associated with our containing object, and the "context", the expression from the query for what we're reading from the database. Typical usage is to use the context to translate a field into the appropriate aliased field from the query, and use the element builder to get the value of that field. e.g. elementBuilder valueOfField: (context translateField: someField) in: row	mappedFields	&lt;SequenceableCollection of: DatabaseField&gt;	The list of fields we work with. We need to specify this so that Glorp knows that it needs to e.g. includes these fields in the list of those selected.	shouldProxy	&lt;Boolean&gt;	Should we create a proxy for our target objects when we read an object containing this mapping.	toDbMappingBlock	&lt;BlockClosure&gt;	The block we invoke when writing to the database. It takes as arguments the rowmap being created, the target object we are writing, and a dictionary of the rows we already have associated with this object. The block is expected to update the rowmap with the new information.</body></comment><class><name>NullConverter</name><environment>Glorp</environment><super>Glorp.DatabaseConverter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.NullConverter</class-id><body>This is a no-op converter. When converting in either direction, it just returns the value.</body></comment><class><name>GlorpFloatType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>TimestampVersionGenerator</name><environment>Glorp</environment><super>Glorp.VersionGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.TimestampVersionGenerator</class-id><body>A generator that puts Timestamp now into fields when it is invoked.</body></comment><class><name>DualRoleFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments whereClauseVersion selectListVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.DualRoleFunction</class-id><body>This is a function that prints in different ways in a field list than it does in a where clause, typically because use of the where clause version isn't supported in field lists.</body></comment><class><name>InsertCommand</name><environment>Glorp</environment><super>Glorp.RowBasedCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InsertCommand</class-id><body>A command to insert our set of rows.</body></comment><class><name>FilteringQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection filter collectBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.FilteringQuery</class-id><body>This is a query that expects all the objects it might return to already be in memory, and in a collection from which it can pick them out by evaluating a block. This is used to implement filtered reads on a mapping. When one of the mappings fires, it reads all the relevant results, and so each instance  using that mapping can get the results out of memory without going to the database again.Instance Variables:	collectBlock	&lt;Block&gt;	A one-argument block we evaluate to actually collect up the results. That is, internally we are likely to have a more complex representation in the collection, e.g. an array containing various extra information plus the objects. This gets the objects out of the collection.	collection	&lt;(GlorpVirtualCollection of: Object)&gt;	The collection on which we filter. Typically a virtual collection, at least for filtered reads, but can also handle a normal collection.	filter	&lt;Block&gt;	The two-argument block we use to filter. The first argument is the entry from the collection, the second is the parameters to the query that were used.	readsOneObject	&lt;Boolean&gt;	A duplicate of readsOneObject in AbstractReadyQuery. Do we return a collection, or a single result.</body></comment><class><name>GlorpPGTimeWithTimeZoneType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpRowSorter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>childSelector queue sorted current items childCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.GlorpRowSorter</class-id><body>This sorts a set of rows to determine the order in which they should be inserted into the database. It does this using a breadth first topological sort. What that means is that instead of traversing the graph depth first, as is normal for topological, we traverse it breadth first. This gives us the desirable property of keeping the child rows together as much as possible. Since the initial input will already have been sorted by the static table ordering that is implied by the foreign key constraints, this will also keep rows from the same table together, unless the sort algorithm finds a reason the order needs to be changed. This maximizes the opportunities for using optimizations like Oracle array binding, which want to write groups of similar rows all at once. Note that we can't just use the table order directly, because there may be row-level issues. That is, rows may need to be written before other rows in the same table, or even if there is a table constraint, it may only be relevant for a small number of rows.Instance Variables:	childCache	&lt;IdentityDictionary from: Object to: Collection&gt;	The calculation of children may be expensive, and may have to be done more than once for an item, so we cache the information here.	childSelector	&lt;Symbol | BlockClosure&gt;	The zero-argument selector which we perform on an item, or the one-argument block which we evaluate in order to get the children.	current	&lt;DatabaseRow | GlorpBreadthFirstTopologicalSortItem&gt;	The item we are currently examining.	items	&lt;ReadStream&gt;	A stream on the items we are intended to sort.	queue	&lt;OrderedCollection&gt;	This maintains the breadth first order. So, when we encounter an item, we add its children to the end of the queue. The Sorter processes the items in order off the queue, resulting in a breadth first traversal.	sorted	&lt;OrderedCollection&gt;	The resulting collection, in sorted order.</body></comment><class><name>Cast</name><environment>Glorp</environment><super>Glorp.PrefixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.Cast</class-id><body>This is an attempt to allow a cast to be used on constants, as e.g.   CAST value: '1-2-3' as: platform dateIt doesn't work yet, since printing of constants doesn't like having functions in the way - it conflicts with type conversion, and looks like it'll take a bit of work to fix.</body></comment><class><name>GlorpDatabaseReadError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command databaseError accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseReadError</class-id><body>This is the error we raise when we encounter an exception inside Glorp's database read code. This is uniform across dialects, so it can be reliably caught. We wrap the underlying exception.Instance Variables:	accessor	&lt;DatabaseAccessor&gt;	The accessor we were executing against.	command	&lt;DatabaseCommand&gt;	The command we were executing	databaseError	&lt;Exception&gt;	The exception that the system raised.</body></comment><class><name>GlorpUnitOfWorkPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.GlorpUnitOfWorkPackage</class-id><body>This class represents package information for the GlorpUnitOfWork package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>GlorpMappingsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.GlorpMappingsPackage</class-id><body>This class represents package information for the GlorpMappings package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>SQLite3PragmaMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpDatabasePackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.GlorpDatabasePackage</class-id><body>LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>SQLStringSelectCommand</name><environment>Glorp</environment><super>Glorp.QuerySelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLStringSelectCommand</class-id><body>This is a select command whose SQL is given, rather than being generated from a query.</body></comment><class><name>SQLite3PragmaCommand</name><environment>Glorp</environment><super>Glorp.SQLStringSelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GlorpIntegerType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>HorizontalTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappedClass isAbstract </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.HorizontalTypeMapping</class-id><body>HorizontalTypeMapping assumes that all objects are stored in different tables. Only leaf classes in the inheritance hierarchy can be mapped. The descriptors for the classes themselves have the necessary information, our only job is to be involved in building up the query. Queries can be done either by splitting up into a series of separate queries, or as one horribly complex query with union all clauses.Instance Variables:	isAbstract	&lt;Boolean&gt;	Is this an abstract superclass.	mappedClass	&lt;Class&gt;	The class that we are mapping.</body></comment><class><name>NullSequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.NullSequence</class-id><body>This is a sequence that doesn't do anything. It's really just a placeholder.</body></comment><class><name>InMemorySequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InMemorySequence</class-id><body>This is a sequence generator that just generates numbers in memory. Mostly useful for testing, because the numbers aren't guaranteed unique in the database unless we are the only user, and our initial value was appropriately set.Instance Variables:	count	&lt;Integer&gt;	The last used identifier.</body></comment><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseTable</class-id><body>This is our internal representation of a table in the database. It holds onto enough information for us to both map to the table, and to create it in the database if required.Instance Variables	fields	&lt;(Collection of: DatabaseField)&gt;	The columns in the table.	foreignKeyConstraints	&lt;(Collection of: ForeignKeyConstraint)&gt;	The foreign key constraints between this table and others.	indexes	&lt;(Collection of: DatabaseIndex)&gt;	The indexes on this table.	isImaginary	&lt;Boolean&gt;	We allow "imaginary" tables, which don't really exist in the database. This is most useful in connection with embedded mappings. For example, we can have a Currency object which maps to a CURRENCY table, but there is no currency table in the database, and instead we have a number of embedded mappings that put those fields inside another table.	lockKeyFields	&lt;Collection of: DatabaseField&gt;	Which fields (which should also be in our field list) are checked when doing optimistic locking	name	&lt;String&gt;	The name of the table.	parent	&lt;DatabaseTable | nil&gt;	For a normal table, this is nil. When we create an aliased table we remember who the original table was using this field.	primaryKeyFields	&lt;(SequenceableCollection of: (DatabaseField))&gt;	Which fields (which should also be in our field list) are primary keys.	replacementSubSelect	&lt;CompoundQuery | SimpleQuery&gt;	I honestly don't remember at the moment what this does, but it seems to be used when we're traversing relationships that are in imaginary tables in order to figure out what the actual join has to be. And maybe the join needs to be done in a subselect rather than as a simple join in certain cases.	schema	&lt;String&gt;	What is the name of the schema in which this table exists. This is used when printing the qualified name of the table. 	uniqueConstraints	&lt;(Collection of: UniqueConstraint)&gt;	The unique constraints for this table</body></comment><class><name>ObjectStudioDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inTransaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id><body>An accessor for ObjectStudio.Instance Variables:	inTransaction	&lt;Boolean&gt;	Are we in a transaction. We don't have an indicator for this from the database layer, so keep track of it here.</body></comment><class><name>MySQLODBCPlatform</name><environment>Glorp</environment><super>Glorp.MySQLPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>StandaloneFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.StandaloneFunction</class-id><body>This represents a function that takes no arguments and is complete in itself. The obvious example is COUNT(*). Making a special '*' pseudo-field seems even more of a hack than just hard-coding it into a function like this. It's possible that things like nextval(sequence) might be able to fall in this category too.</body></comment><class><name>DolphinDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DolphinDatabaseAccessor</class-id><body>The database accessor subclass for Dolphin Smalltalk.</body></comment><class><name>CompositeQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.CompositeQuery</class-id><body>This is a query that contains several sub-queries, and executes them all in sequence, returning the concatenation of all the results. This is different from a CompoundQuery, which groups multiple queries together according to operations like UNION ALL, or INTERSECT. This just puts together several different queries and executes them separately, combining the results in Smalltalk. CompoundQuery is more powerful, and can take advantage of database features, but this is more flexible.</body></comment><class><name>PostgreSQLPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PostgreSQLPlatform</class-id><body>This is a platform for the open-source PostgreSQL database.</body></comment><class><name>MessageArchiverForGetMapping</name><environment>Glorp</environment><super>Glorp.MessageArchiver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.MessageArchiverForGetMapping</class-id><body>This is a special subclass of MessageArchiver which constructs its expression using getMapping:named: rather than just get:. It's possible it ought to be generalized to one that's parameterized by what message it sends, but right now I only need the one...</body></comment><class><name>HorizontalTypeResolver</name><environment>Glorp</environment><super>Glorp.BasicTypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shouldUseSingleQuery </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.HorizontalTypeResolver</class-id><body>This implements inheritance where each concrete class is represented in its own table. Each table will duplicate the fields that are in common between the concrete classes.</body></comment><class><name>GlorpHelper</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>GlorpHelper</class-id><body>This is a helper class for methods that I'd like to be able to add as extensions, but don't want to for fear of conflicting with dialects that have them, or people who implement them for their own projects, and any other miscellaneous extensions. One extension is that this class is in the Smalltalk namespace, so is universally accessible, and it provides a way for class extensions that don't have visibility of the Glorp namespace to access the Dialect class.</body></comment><class><name>DB2Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DB2Platform</class-id><body>This is a Glorp platform for DB2 databases.</body></comment><class><name>SubSelectExpression</name><environment>Glorp</environment><super>Glorp.RelationExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query localBase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.SubSelectExpression</class-id><body>This is a special sort of relation expression used when printing subselects that are generated out of anySatisfy: or noneSatisfy: using an EXISTS/NOT EXISTS clause.Instance Variables:	localBase	&lt;SubSelectBaseExpression&gt;	The base expression that our sub-query is built on, as opposed to the overall base expression of query.	query	&lt;SimpleQuery&gt;	The sub-query we are responsible for.</body></comment><class><name>ReadQuery</name><environment>Glorp</environment><super>Glorp.AbstractReadQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.ReadQuery</class-id><body>This represents a general read query. By general we mean that it might require more than one trip to the database. It computes a "tracing" indicating which groups of objects can be read simultaneously, then constructs a group of corresponding SimpleQuery instances and executes them.</body></comment><class><name>GlorpTextType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>ConditionalToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conditional </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ConditionalToManyMapping</class-id><body>This is a conditional mapping, but one where the condition is applied to a relationship with a collection, and applies to individual elements of the collection. So, rather than making a single choice overall of which mapping to apply, we loop over the collection and make the choice separately for each element.This is experimental, and probably suffers from lots of limitations.</body></comment><class><name>FieldExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field base alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.FieldExpression</class-id><body>This is an expression representing a field in a table. It could be used, for example, if we were writing a data level expression.   getTable: 'foo') getField: 'bar'Instance Variables:	alias	&lt;Object&gt;	Sometimes in queries we want to retrieve values in columns other than what they are normally named. So we can give the field an alias, and generate something like "select id, name as somethingElse"	base	&lt;GlorpExpression&gt;	The expression this is based on, which ought to be something which is associated with the table that contains our field.	field	&lt;DatabaseField&gt;	The field we represent in the expression.</body></comment><class><name>GlorpDatabaseTypesPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseTypesPackage</class-id><body>This class represents package information for the GlorpDatabaseTypes package, for systems that don't have things like package properties to store things like copyright and license information.LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</body></comment><class><name>DB2Sequence</name><environment>Glorp</environment><super>Glorp.OracleSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DB2Sequence</class-id><body>DB2Sequence implements DB2 sequences using nextVal. The mechanism is similar to that of Postgres.Get a sequence number using a query like this. 	SELECT NEXT VALUE FOR my_sequence.Note that DB2 sequences are only supported in single partition databases.Instance Variables	accessProtect	&lt;RecursionLock | Semaphore&gt;	Mutual exclusion on our sequence allocation, since we may need to protect our cache of already-allocated numbers, and prevent two different processes from going to the database simultaneously. This might want to be pushed up to a superclass so it can be shared.	count	&lt;Number&gt;	How many identifiers have we gotten in a row without going to the database.	sequenceIncrement	&lt;SmallInteger&gt;	By how much does the sequence in the database increment on each nextVal call.</body></comment><class><name>Login</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>database username password connectString name schema secure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.Login</class-id><body>Enough information to log in to a particular database.Instance Variables:	connectString	&lt;String&gt;	The string that will be passed to the driver level to tell us what to connect to. This might be e.g. an ODBC data source name, or it might be a host name plus socket/database name for Postgresql.	database	&lt;DatabasePlatform&gt;	The platform describing what type of database this is. Used here mostly to indicate how we need to talk to the underlying connection layer, which may be different by database.	name	&lt;String&gt;	A name we can use to describe this. No significance to the database.	password	&lt;String&gt;	The connect password.	schema	&lt;String&gt;	What should our default schema be. Used mostly internally, to set the schema of the tables we are using.	username	&lt;String&gt;	The connect username.</body></comment><class><name>TimedStrongCachePolicy</name><environment>Glorp</environment><super>Glorp.CachePolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.TimedStrongCachePolicy</class-id><body>This implements a cache that notes that an object is stale after some amount of time since it has been read.Instance Variables:	timeout	&lt;Integer&gt;	The time in seconds until we note an object as needing refreshing.</body></comment><class><name>SelectingElementBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SelectingElementBuilder</class-id><body>This is a special subclass of ElementBuilder used when we execute a query that reads multiple different things, but in any row, we expect only one of them to have a value. This is useful if we're doing inheritance queries where each concrete subclass is in a separate table. We can join the queries together, but we expect each row to contain only one particular subclass instance.</body></comment><class><name>IdentityTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.IdentityTypeMapping</class-id><body>This is the default type mapping for classes that aren't using inheritance. It implements all of the protocol as no-ops.</body></comment><class><name>SQLite3Sequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLite3Sequence</class-id><body>Sequences for SQLite.</body></comment><class><name>DirectToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DirectToManyMapping</class-id><body>This is a to-many mapping where the class in the collection is a simple type, not a compound object. This requires fiddling with the descriptors, to allow each such mapping to define a different descriptor for the target class. This should be regarded as something of a prototype. It seems to work, at least for basic operations, but it may well have problems.Instance Variables:	resultField	&lt;DatabaseField&gt;	The field in the target table in which we have our results.</body></comment><class><name>DynamicDescriptorSystem</name><environment>Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributeNameToFieldNameBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DynamicDescriptorSystem</class-id><body>This is a descriptor system whose descriptors and tables are created dynamically rather than out of generated code. Note that identity is extremely important, so care is required to set these up properly.</body></comment><class><name>ConditionalMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conditionalField conditionalMethod cases otherwiseCase conditionalFieldMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ConditionalMapping</class-id><body>This is a mapping that does different things depending on some testable condition. Depending on whether we're reading or writing, we are likely to test different things. This is useful if a field can be interpreted in more than one way. The API is rather messy.Instance Variables:	cases	&lt;SequenceableCollection of: (Association)&gt;	Used on read - a list of associations representing the cases we test. The key is either a one-argument block to be evaluated or a one-argument selector to be performed by the descriptorSystem, returning a boolean, and the value is the mapping to use if it returns true. 	conditionalField	&lt;DatabaseField&gt;	The field whose value will be used as the argument to the blocks/selectors in cases.	otherwiseCase	&lt;Mapping&gt;	If none of the other cases evaluate to true on read, use this mapping.	conditionalMethod	&lt;Block | Symbol&gt;	Used on write - a zero-argument selector or one-argument block. The selector will be sent to the object being written, the block will be evaluated with that object as the argument. This is expected to return the object that will be written via the appropriate mapping.	conditionalFieldMapping	&lt;Mapping&gt;	Used on write - the mapping used to write out the value in the conditional field.</body></comment><class><name>DataElementBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.DataElementBuilder</class-id><body>This builds raw data items rather than persistent objects with descriptors. Used if we do something like   aQuery retrieve: [:each | each address streetName].giving us back simple data objects.This makes building them quite simple.</body></comment><class><name>GlorpPreparedStatement</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signature statement busy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.GlorpPreparedStatement</class-id><body>This represents a prepared statement in the database. Instance Variables:	busy	&lt;Boolean&gt;	Are we currently in use - that is to say, are we executing and/or holding an active cursor.	signature	&lt;String&gt;	A string that we can use to match up to commands and see if we are appropriate for the command to use. The signature of a command is its SQL String plus a string representing the types of its parameters.	statement	&lt;Object&gt;	The actual statement object. Because we don't really know what type this is, and it varies by dialect, we allow the accessor to extract it from us and do the real work.</body></comment><class><name>GlorpInvalidExpressionError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpInvalidExpressionError</class-id><body>This represents an invalid expression condition in a query.</body></comment><class><name>PluggableDatabaseConverter</name><environment>Glorp</environment><super>Glorp.DatabaseConverter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stToDb dbToSt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PluggableDatabaseConverter</class-id><body>This is a converter where the conversion is specified by two blocks.Instance Variables:	dbToSt	&lt;BlockClosur&gt;	The block to run to convert from the database representation to Smalltalk representation. Takes one argument, the value to be converted.	stToDb	&lt;BlockClosure&gt;	The block to run to convert from Smalltalk representation to the database representation. Takes one argument, the value to be converted.</body></comment><class><name>GlorpVarCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>DB2IdentitySequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DB2IdentitySequence</class-id><body>DB2IdentitySequence is the sequence class for DB2 identity columns. Glorp prefers sequence objects over identity columns, and although DB2 has both, Glorp defaults to using sequences. Therefore there is no code here to create an identity column. Primary keys will use sequences instead. DB2IdentitySequence primarily helps in the analysis of tables that were created outside Glorp.One can obtain the most recently installed number using a query like this.	VALUES IDENTITY_VAL_LOCAL().</body></comment><class><name>AdHocProxy</name><environment>Glorp</environment><super>Glorp.AbstractProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.AdHocProxy</class-id><body>This represents a proxy that gets its value in a user-defined way, by evaluating a block.Instance Variables:	readBlock	&lt;BlockClosure&gt;	The zero-argument block we evaluate to get the proxied object.</body></comment><shared-variable><name>Singleton</name><environment>Glorp.NullSequence</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpDatabase</package></attributes></shared-variable><shared-variable><name>LoggingEnabled</name><environment>Glorp.DatabaseAccessor</environment><private>false</private><constant>false</constant><category>accessing</category><initializer></initializer><attributes><package>GlorpDatabase</package></attributes></shared-variable><shared-variable><name>UseBindingIfSupported</name><environment>Glorp.DatabasePlatform</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>GlorpDatabase</package></attributes></shared-variable><methods><class-id>Glorp.VersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="nextValueFor:in:">nextValueFor: aField in: aRow	self subclassResponsibility.</body><body package="GlorpDatabase" selector="preWriteAssignSequenceValueFor:in:using:">preWriteAssignSequenceValueFor: aField in: aRow using: anAccessor	"Overwrite a pre-existing value in the field if necessary"	aRow at: aField forcePut: (self nextValueFor: aField in: aRow).</body></methods><methods><class-id>Glorp.AdHocVersionGenerator</class-id> <category>accessing</category><body package="GlorpDatabase" selector="block">block	^block</body><body package="GlorpDatabase" selector="block:">block: aBlock	block := aBlock.	numberOfArguments := Dialect argumentCountFor: block.</body></methods><methods><class-id>Glorp.AdHocVersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="nextValueFor:in:">nextValueFor: aField in: aRow	"Get the next value by evaluating the block. If it doesn't care about the field or row, don't pass them as arguments. If it does, then give it both."	numberOfArguments = 0 ifTrue: [^block value] ifFalse: [^block value: aField value: aRow].</body></methods><methods><class-id>Glorp.AdHocVersionGenerator class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="block:">block: aBlock	^self new block: aBlock.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="className">className	^self class name.</body><body package="GlorpExpressions" selector="displayString">displayString	| stream |	stream := String new writeStream.	self printOnlySelfOn: stream.	^stream contents.</body><body package="GlorpExpressions" selector="printOn:">printOn: aStream 	self printTreeOn: aStream</body><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	self subclassResponsibility.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream	self subclassResponsibility.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="addBoundExpressionsIn:to:">addBoundExpressionsIn: aQuery to: boundExpressions</body><body package="GlorpExpressions" selector="additionalExpressions">additionalExpressions	^#().</body><body package="GlorpExpressions" selector="additionalExpressionsIn:">additionalExpressionsIn: aQuery 	"Return the collection of additional expressions (representing joins) that this expression tree requires. Because some additional expressions may in turn have their own additional expressions (mapping joins represented by general expressions), repeat until we don't get any more."	| allExpressions newExpressions allNewExpressions expressionsConsidered |	allExpressions := ExpressionGroup with: self.	allExpressions addAll: aQuery ordering.	allExpressions add: aQuery groupBy.	allExpressions addAll: aQuery tracing additionalExpressions.	expressionsConsidered := IdentitySet new.	allNewExpressions := OrderedCollection new.	newExpressions := nil.	[newExpressions := (newExpressions isNil ifTrue: [allExpressions] ifFalse: [newExpressions])		inject: ExpressionGroup new 		into: [:sum :each | 			((expressionsConsidered includes: each) not and: [				each queryLevelBaseExpression == aQuery baseExpression]) ifTrue: [					sum addAll: each additionalExpressions.					expressionsConsidered add: each].			sum].	allNewExpressions addAll: newExpressions children.	newExpressions isEmpty] whileFalse.	^allNewExpressions.</body><body package="GlorpExpressions" selector="addToTargetFields:">addToTargetFields: aCollection	"If we can provide target fields, add them to the collection"	^self.</body><body package="GlorpExpressions" selector="allControlledTables">allControlledTables	"Return all the tables that we control, directly or indirectly. Basically, if we are a mapping expression with a link table, return the link table as well as any tables of ours."	^self tables.</body><body package="GlorpExpressions" selector="allRelationsFor:do:andBetweenDo:">allRelationsFor: rootExpression do: aBlock andBetweenDo: anotherBlock	"In any normal relationship, there's only one thing. Just do it"	aBlock value: rootExpression leftChild value: rootExpression rightChild.</body><body package="GlorpExpressions" selector="allTables">allTables	^self inject: Set new into: [:sum :each | 		sum addAll: each tables. sum].</body><body package="GlorpExpressions" selector="allTablesToPrint">allTablesToPrint	^self inject: Set new into: [:sum :each | 		sum addAll: each tablesToPrint. sum].</body><body package="GlorpExpressions" selector="allTablesToPrintStoppingAt:">allTablesToPrintStoppingAt: aSubSelectBaseExpression	^self inject: Set new into: [:sum :each | 		each queryLevelBaseExpression == aSubSelectBaseExpression ifTrue: [			sum addAll: each tablesToPrint]. sum].</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	self subclassResponsibility.</body><body package="GlorpExpressions" selector="assignTableAliasesStartingAt:prefix:">assignTableAliasesStartingAt: anInteger prefix: aString	^anInteger.</body><body package="GlorpExpressions" selector="bindingType">bindingType	^self type.</body><body package="GlorpExpressions" selector="condenseBooleanEquality">condenseBooleanEquality	^self.</body><body package="GlorpExpressions" selector="condenseBooleanEqualityExpressions">condenseBooleanEqualityExpressions	^self.</body><body package="GlorpDatabase" selector="condensePrimaryKeyComparison">condensePrimaryKeyComparison	^self.</body><body package="GlorpExpressions" selector="condensePrimaryKeyComparisons">condensePrimaryKeyComparisons	^self.</body><body package="GlorpExpressions" selector="hasBindableExpressionsIn:">hasBindableExpressionsIn: aCommand	^false.</body><body package="GlorpExpressions" selector="prepareIn:">prepareIn: aQuery	"A little weird, because what we end up asking for additional expressions from, might not be us"	aQuery adjustWhereClause.	(aQuery whereClause additionalExpressionsIn: aQuery)		do:			[:each | 			(aQuery shouldExpressionBeJoin: each)				ifTrue: [aQuery addJoin: each]				ifFalse: [aQuery privateAnd: each]].</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:">rebuildOn: aBaseExpression startingFrom: anExpression	"Rebuild the expression on the new base. If we encounter anExpression, treat that as the base, and build only from that point up. e.g. if we have a.b.c.d and we rebuildOn: z startingFrom: b, then the result will be z.c.d"	^self rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: nil.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	"Rebuild the expression on the new base. If we encounter anExpression, treat that as the base, and build only from that point up. e.g. if we have a.b.c.d and we rebuildOn: z startingFrom: b, then the result will be z.c.d. Pieces that aren't based on anExpression should be built onto ultimateBaseExpression instead of aBaseExpression. They represents parts of outer scope trees that are referenced within us.  Note that anExpression can be nil, but if it is, then ultimateBaseExpression is effectively ignored."	self subclassResponsibility.</body><body package="GlorpExpressions" selector="removeNonJoinParts">removeNonJoinParts	"Remove anything that's not an actual join. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to use the general ones, because they're not field level."	^self.</body><body package="GlorpExpressions" selector="replaceJoinsWithInverse">replaceJoinsWithInverse	"If we don't know specifically what to do with a kind of expression, assume it doesn't apply and we should be replacing it with nothing."	^self.</body><body package="GlorpExpressions" selector="rewriteBooleanEquality:">rewriteBooleanEquality: relation	"Does not apply to general expressions"</body><body package="GlorpExpressions" selector="rewriteEquality">rewriteEquality	^self.</body><body package="GlorpExpressions" selector="rewriteEqualityExpressions">rewriteEqualityExpressions	^self.</body><body package="GlorpExpressions" selector="rewriteFunctionArguments">rewriteFunctionArguments	"If a function needs to adjust its arguments, do that here. The motivating example is one where a string argument is rewritten into a form that's of a different length, e.g. the Postgresql driver does that to strings in Blobs"	^self.</body><body package="GlorpExpressions" selector="rewriteFunctionArgumentsWith:">rewriteFunctionArgumentsWith: ourArgument	"If a function needs to adjust its arguments, do that here. The motivating example is one where a string argument is rewritten into a form that's of a different length, e.g. the Postgresql driver does that to strings in Blobs"	^self.</body><body package="GlorpExpressions" selector="tableForANSIJoin">tableForANSIJoin	"Which table will we join to."	^nil.</body><body package="GlorpExpressions" selector="tables">tables	^#().</body><body package="GlorpExpressions" selector="tablesContainingMe">tablesContainingMe	"Return a list of tables that contain this object, whether or not we control them. This is mostly the same as tables, but will differ for embedded mappings."	^self tables.</body><body package="GlorpExpressions" selector="tablesToPrint">tablesToPrint	^#().</body><body package="GlorpExpressions" selector="validate">validate</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="allSatisfy:">allSatisfy: aBlock	"Answer true if aBlock answers true for any element of the receiver.	 An empty collection answers false."	self do: [:each| (aBlock value: each) ifFalse: [^false]].	^true</body><body package="GlorpExpressions" selector="anySatisfy:">anySatisfy: aBlock	"Answer true if aBlock answers true for any element of the receiver.	 An empty collection answers false."	self do: [:each| (aBlock value: each) ifTrue: [^true]].	^false</body><body package="GlorpExpressions" selector="collect:">collect: aBlock	| newCollection |	newCollection := OrderedCollection new.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection.</body><body package="GlorpExpressions" selector="detect:">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [self notFoundError]</body><body package="GlorpExpressions" selector="detect:ifNone:">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="GlorpExpressions" selector="do:">do: aBlock	"Iterate over the expression tree"	self do: aBlock skipping: IdentitySet new.</body><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	aBlock value: self.</body><body package="GlorpExpressions" selector="inject:into:">inject: anObject into: aBlock	| sum |	sum := anObject.	self do: [:each | sum := aBlock value: sum value: each].	^sum</body><body package="GlorpExpressions" selector="select:">select: aBlock	| newCollection |	newCollection := OrderedCollection new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>inspecting</category><body package="GlorpExpressions" selector="inspectorHierarchies">inspectorHierarchies	| hierarchy |	hierarchy := ((Smalltalk at: #Tools ifAbsent: [^#()])		at: #Trippy ifAbsent: [^#()])		at: #Hierarchy ifAbsent: [^#()].	^Array with: (hierarchy			id: #expression			label: 'Expression Tree'			parentBlock: [:each | nil]			childrenBlock: [:each | each inspectorChildren])</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canBeUsedForRetrieve">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^false.</body><body package="GlorpExpressions" selector="canBind">canBind	"Return true if this represents a value that can be bound into a prepared statement"	^false.</body><body package="GlorpExpressions" selector="canKnit">canKnit	"Return true if, when building objects, we can knit the object corresponding to this expression to a related object. Roughly speaking, is this a mapping expression"	^false.</body><body package="GlorpExpressions" selector="canPrint">canPrint	"Return true if we can print into a where clause"	^true.</body><body package="GlorpExpressions" selector="canTranslateFields">canTranslateFields	"Return true if we are a mapping expression and can thus translate from fields into their aliased version for a particular query."	^false.</body><body package="GlorpExpressions" selector="hasImpliedClauses">hasImpliedClauses	"Return true if this implies additional SQL clauses beyond just a single field expression"	^false.</body><body package="GlorpExpressions" selector="hasProvidedAdditionalExpressions">hasProvidedAdditionalExpressions	"Return true if we have already provided additional expressions to some query. Only important when we're preparing a subselect and don't want to bring in joins that are part of the main query"	^true.</body><body package="GlorpExpressions" selector="hasTableAliases">hasTableAliases	^false.</body><body package="GlorpExpressions" selector="isConstantExpression">isConstantExpression	^false.</body><body package="GlorpExpressions" selector="isDistinct">isDistinct	^false.</body><body package="GlorpExpressions" selector="isEmptyExpression">isEmptyExpression	^false.</body><body package="GlorpExpressions" selector="isGlorpExpression">isGlorpExpression	^true.</body><body package="GlorpExpressions" selector="isJoin">isJoin	^false.</body><body package="GlorpExpressions" selector="isMappable">isMappable	"Return true if we're something that can be returned in a select statement."	^true.</body><body package="GlorpExpressions" selector="representsDerivedObject">representsDerivedObject	^false.</body><body package="GlorpExpressions" selector="returnsDictionary">returnsDictionary	"Return true if we representa  ampping to a dictionary"	^false.</body><body package="GlorpExpressions" selector="shortCircuitOnNullComparison:">shortCircuitOnNullComparison: anObject	"Return true if we represent an expression that compares null to a non-nullable value, so we don't ever need to really evaluate it"	^false.</body><body package="GlorpExpressions" selector="willPrintAsWhereClause">willPrintAsWhereClause	^true.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="beOuterJoin">beOuterJoin	^self.</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^self subclassResponsibility.</body><body package="GlorpExpressions" selector="field">field	^nil.</body><body package="GlorpExpressions" selector="fieldFromMeOrSubclasses">fieldFromMeOrSubclasses	"For mapping expression, return the field for this mapping, but if the field is not mapped, and the class uses inheritance, check for subclasses, and use a random one of the subclass mappings. For all others, just return the field."	^self field.</body><body package="GlorpExpressions" selector="hasDescriptor">hasDescriptor	^false.</body><body package="GlorpExpressions" selector="printsTable">printsTable	^false.</body><body package="GlorpExpressions" selector="type">type	^self field type.</body><body package="GlorpExpressions" selector="valueIn:">valueIn: aDictionary	"Return the value associated with this expression given the parameters in aDictionary. Only meaningful for ParameterExpressions"	^self.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>api</category><body package="GlorpExpressions" selector=",">, anExpression	^self get: #, withArguments: (Array with: anExpression asGlorpExpression).</body><body package="GlorpExpressions" selector="AND:">AND: anExpression	"This method doesn't really have to exist, because it would be inferred using operationFor:, but it's included here for efficiency and to make it a little less confusing how relation expression get created. Note that the two expression must already be  built on the same base!"	anExpression isNil ifTrue: [^self].	anExpression == true ifTrue: [^self].	anExpression == false ifTrue: [^false].	(anExpression isGlorpExpression and: [anExpression isEmptyExpression]) ifTrue: [^self].	^RelationExpression named: #AND basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions" selector="AND:AND:">AND: anExpression AND: otherExpression	"A convenience method to allow easy conjunction of multiple ANDs at the same level"	^(self AND: anExpression) AND: otherExpression.</body><body package="GlorpExpressions" selector="AND:AND:AND:">AND: anExpression AND: otherExpression AND: thirdExpression	"A convenience method to allow easy conjunction of multiple ANDs at the same level"	^((self AND: anExpression) AND: otherExpression) AND: thirdExpression.</body><body package="GlorpExpressions" selector="AND:AND:AND:AND:">AND: anExpression AND: otherExpression AND: thirdExpression AND: fourthExpression	"A convenience method to allow easy conjunction of multiple ANDs at the same level"	^(((self AND: anExpression) AND: otherExpression) AND: thirdExpression) AND: fourthExpression.</body><body package="GlorpExpressions" selector="asGlorpExpression">asGlorpExpression	^self.</body><body package="GlorpExpressions" selector="base">base	self subclassResponsibility.</body><body package="GlorpExpressions" selector="equals:">equals: anExpression	^RelationExpression named: #= basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions" selector="get:withArguments:">get: aSymbol withArguments: anArray	self subclassResponsibility.</body><body package="GlorpExpressions" selector="getFunction:withArguments:">getFunction: aSymbol withArguments: anArray	| expression |	expression := FunctionExpression for: aSymbol withArguments: anArray basedOn: self.	expression isNil ifTrue: [^nil].	^expression.</body><body package="GlorpExpressions" selector="getFunction:withArguments:in:">getFunction: aSymbol withArguments: anArray in: system	| expression |	expression := FunctionExpression for: aSymbol withArguments: anArray basedOn: self system: system.	expression isNil ifTrue: [^nil].	^expression.</body><body package="GlorpExpressions" selector="OR:">OR: anExpression	"This method doesn't really have to exist, because it would be inferred using operationFor:, but it's included here for efficiency and to make it a little less confusing how relation expression get created.  Note that the two expression must already be  built on the same base!"	anExpression isNil ifTrue: [^self].		anExpression == true ifTrue: [^true].	anExpression == false ifTrue: [^self].	(anExpression isGlorpExpression and: [anExpression isEmptyExpression]) ifTrue: [^self].	^RelationExpression named: #OR basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions" selector="parameter:">parameter: aConstantExpression	"Create a parameter expression with the given name. But note that the name doesn't have to be a string. Database fields, symbols, and integers are all plausible"	| value |	value := aConstantExpression class == ParameterExpression ifTrue: [aConstantExpression field] ifFalse: [aConstantExpression value].	^ParameterExpression forField: value basedOn: self.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asDistinctFieldOn:">asDistinctFieldOn: anExpression	^(self asGlorpExpressionOn: anExpression) get: #distinct withArguments: #().</body><body package="GlorpExpressions" selector="asField">asField	"If we correspond to a single field, return it"	^self field.</body><body package="GlorpExpressions" selector="asGeneralGlorpExpression">asGeneralGlorpExpression	"Convert the result to a general (tree-format) expression, if it's the more limited join expression"	^self.</body><body package="GlorpExpressions" selector="asGeneralGlorpExpressionWithFields">asGeneralGlorpExpressionWithFields	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	^self.</body><body package="GlorpExpressions" selector="asGlorpExpressionForDescriptor:">asGlorpExpressionForDescriptor: aDescriptor	self ultimateBaseExpression descriptor: aDescriptor.</body><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	aBaseExpression ultimateBaseExpression == self ultimateBaseExpression		ifTrue: [^self].	^self rebuildOn: aBaseExpression.</body><body package="GlorpExpressions" selector="asGlorpExpressionOn:basedOn:withUltimateBase:">asGlorpExpressionOn: aBaseExpression basedOn: oldBaseExpression withUltimateBase: ultimateBaseExpression	^self		rebuildOn: aBaseExpression		startingFrom: oldBaseExpression		withOuterScopeBase: ultimateBaseExpression.</body><body package="GlorpExpressions" selector="asGlorpExpressionOn:in:">asGlorpExpressionOn: aBaseExpression in: aQuery	^self asGlorpExpressionOn: aBaseExpression.</body><body package="GlorpExpressions" selector="asGlorpExpressionOn:withUltimateBase:">asGlorpExpressionOn: anExpression withUltimateBase: aBaseExpression	"Build the expression, knowing that some parts of it may refer to an outer context based on aBaseExpression. This is primarily useful for subselect blocks"	^self rebuildOn: anExpression startingFrom: self queryLevelBaseExpression withOuterScopeBase: aBaseExpression.</body><body package="GlorpExpressions" selector="asIndependentJoins">asIndependentJoins	"If this is an ANDed clause, split it into independent joins"	^Array with: self.</body><body package="GlorpExpressions" selector="asJoin">asJoin	self subclassResponsibility.</body><body package="GlorpExpressions" selector="asNonDistinctField">asNonDistinctField	^self</body><body package="GlorpExpressions" selector="generalExpressionPart">generalExpressionPart	"If we have a mixture of joins and general expressions, return only the general part"	^self.</body><body package="GlorpExpressions" selector="inverseJoin">inverseJoin	"We assume that only the parts that are actually joins ought to invert"	| new |	new := self asGlorpExpressionOn: BaseExpression new.	new do: [:each |		each replaceJoinsWithInverse].	^new.</body><body package="GlorpExpressions" selector="onlyJoinParts">onlyJoinParts	"Strip out any generic parts, leaving only the things that are actually joins"	| new |	new := self asGlorpExpressionOn: BaseExpression new.	new do: [:each |		each removeNonJoinParts].	new := new condenseBooleanEquality.	new isJoin ifFalse: [new do: [:each | each condenseBooleanEqualityExpressions]].	^new.</body><body package="GlorpExpressions" selector="rebuildOn:">rebuildOn: aBaseExpression	^self rebuildOn: aBaseExpression startingFrom: nil.</body><body package="GlorpExpressions" selector="sourceForTarget:">sourceForTarget: aField	^nil.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>initialize</category><body package="GlorpExpressions" selector="in:">in: anExpression	^RelationExpression named: #IN basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions" selector="initialize">initialize</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>primary keys</category><body package="GlorpExpressions" selector="primaryKeyFromDictionary:">primaryKeyFromDictionary: aDictionary	"Given a set of parameters, return a primary key suitable for retrieving our target. We can't do this for general expressions, so indicate failure by returning nil"	^nil.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^self ultimateBaseExpression</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	self subclassResponsibility.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>private/accessing</category><body package="GlorpExpressions" selector="requiresDistinct">requiresDistinct	^false.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>debugging</category><body package="GlorpExpressions" selector="sharedPiecesWith:">sharedPiecesWith: anExpression	"Return a set of the pieces we share in common with anExpression. Mostly useful for debugging unwanted sharing, or the lack of wanted sharing. Note that this won't dive down into subselects."	| myPieces shared |	myPieces := IdentitySet new.	shared := IdentitySet new.	self do: [:each | myPieces add: each].	anExpression do: [:each | (myPieces includes: each) ifTrue: [shared add: each]].	^shared.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>As yet unclassified</category><body package="GlorpCore" selector="sqlString">sqlString	| command |	command := QuerySelectCommand new		useBinding: false;		session: self ultimateBaseExpression descriptor session.	self printSQLOn: command withParameters: #().	^command contents.</body></methods><methods><class-id>Glorp.GlorpExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="alias">alias	^alias</body><body package="GlorpExpressions" selector="alias:">alias: aString	alias := aString</body><body package="GlorpExpressions" selector="arguments">arguments	^#().</body><body package="GlorpExpressions" selector="arguments:">arguments: anArray	^self.</body><body package="GlorpExpressions" selector="base">base	^base.</body><body package="GlorpExpressions" selector="base:">base: anExpression	base := anExpression.</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	^true.</body><body package="GlorpExpressions" selector="convertedDbValueOf:">convertedDbValueOf: anObject	"Not clear what should happen here, but let's just pass it through for the moment"	^(self converterForStType: anObject class) convert: anObject toDatabaseRepresentationAs: self type.</body><body package="GlorpExpressions" selector="converterForStType:">converterForStType: aClass	^self type notNil 		ifTrue: [self type converterForStType: aClass]		ifFalse: [self field converterForStType: aClass].</body><body package="GlorpExpressions" selector="defaultType">defaultType	"We don't know our type. Return a basic numeric type as being as good a guess as any."	^base system platform numeric</body><body package="GlorpExpressions" selector="field">field	^base field.</body><body package="GlorpExpressions" selector="fieldExpression">fieldExpression	^base fieldExpression.</body><body package="GlorpExpressions" selector="function:">function: aString	function := aString.</body><body package="GlorpExpressions" selector="function:arguments:">function: aString arguments: anArray	self function: aString.</body><body package="GlorpExpressions" selector="impliedSmalltalkType">impliedSmalltalkType	type isNil ifFalse: [^type impliedSmalltalkType].	^self field impliedSmalltalkType.</body><body package="GlorpExpressions" selector="mappedFields">mappedFields	^Array with: self.</body><body package="GlorpExpressions" selector="name">name	^function.</body><body package="GlorpExpressions" selector="symbol">symbol	^symbol</body><body package="GlorpExpressions" selector="symbol:">symbol: aSymbol	symbol := aSymbol</body><body package="GlorpExpressions" selector="table">table	(self hasField and: [self field notNil]) ifTrue: [^self field table].	"If we don't have a field, then maybe we have a relationship mapping or a base, so get the descriptor's primary table. Relevant if we have a function like EXISTS"	^self base table.</body><body package="GlorpExpressions" selector="tablesToPrint">tablesToPrint	^#().</body><body package="GlorpExpressions" selector="type">type	| field |	type isNil ifFalse: [^type].	field := self field.	^field isNil ifTrue: [self defaultType] ifFalse: [field type].</body><body package="GlorpExpressions" selector="type:">type: aGlorpDatabaseType	type := aGlorpDatabaseType</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	aStream nextPutAll: function.</body><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters: aDictionary.	alias notNil ifTrue: [aStream nextPutAll: ' AS '; nextPutAll: alias].</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary		self subclassResponsibility.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream 		nextPutAll: function</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canBeUsedForRetrieve">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^true.</body><body package="GlorpExpressions" selector="isDistinct">isDistinct	^function = 'DISTINCT'.</body><body package="GlorpExpressions" selector="isGenerated">isGenerated	^false.</body><body package="GlorpExpressions" selector="isSameAliasedFieldAs:">isSameAliasedFieldAs: aFieldOrFunction	^self == aFieldOrFunction.</body><body package="GlorpExpressions" selector="printsIntoJoins">printsIntoJoins	"Certain functions should be printed into joins as well as into select lists (e.g. UPPER). However, there are others that don't (at least I don't think so) make any sense in joins, e.g. DISTINCT. Differentiate the two. Right now the only one I can think of that doesn't make sense is distinct. It's not clear to me that I'm not just hacking my way through this"	^self isDistinct not.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="convertValueOf:in:">convertValueOf: anObject in: aDictionary	| translated |	translated := anObject isGlorpExpression 		ifTrue: [anObject valueIn: aDictionary]		ifFalse: [anObject].	translated isGlorpExpression ifTrue: [^translated].	^self base convertedDbValueOf: translated.</body><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newBase |	newBase := base asExpressionJoiningSource: source toTarget: target.	^self copy function: function; base: newBase.</body><body package="GlorpExpressions" selector="get:withArguments:">get: aSymbol withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asDistinctFieldOn:">asDistinctFieldOn: anExpression	self isDistinct ifTrue: [^self asGlorpExpressionOn: anExpression].	^super asDistinctFieldOn: anExpression.</body><body package="GlorpExpressions" selector="asNonDistinctField">asNonDistinctField	^self isDistinct ifTrue: [base] ifFalse: [self].</body><body package="GlorpExpressions" selector="hasField">hasField	"If we correspond to a single field, return it. This is a bit of a hack having this only here, because for some functions it doesn't work."	^base hasField.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>compatibility</category><body package="GlorpExpressions" selector="translateField:">translateField: aField	^base translateField: aField.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="valueInBuilder:as:">valueInBuilder: anElementBuilder as: anExpression	^self base valueInBuilder: anElementBuilder as: anExpression.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>mapping</category><body package="GlorpExpressions" selector="valueInBuilder:">valueInBuilder: anElementBuilder	^self base valueInBuilder: anElementBuilder as: self.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuilt := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) getFunction: self symbol withArguments: (self arguments collect: [:each | each rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression]) in: aBaseExpression system.	rebuilt alias: self alias.	^rebuilt.</body><body package="GlorpExpressions" selector="rewriteBooleanEquality:">rewriteBooleanEquality: relation	base := base rewriteBooleanEquality: relation.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:">createFor: arguments	| new |	new := self copy.	new arguments: arguments.	new type: type.	^new.</body><body package="GlorpExpressions" selector="createFor:withBase:symbol:">createFor: arguments withBase: anExpression symbol: aSymbol	| new |	new := self copy.	new base: anExpression.	new symbol: aSymbol.	new type: type.	new arguments: arguments.	^new.</body><body package="GlorpExpressions" selector="withTable:">withTable: aTable	"For a function expression, we shouldn't need to do anything here. It will have already been rebuilt on a base that has aliases"	^self."	| copy newBase |	newBase := BaseExpression new.	newBase descriptor: base descriptor.	copy := self rebuildOn: newBase.	copy fieldExpression setTable: aTable.	^copy."</body></methods><methods><class-id>Glorp.FunctionExpression class</class-id> <category>private</category><body package="GlorpExpressions" selector="basicFunctions">basicFunctions	functions isNil ifTrue: [functions := self createBasicFunctionsFor: nil].	^functions.</body><body package="GlorpExpressions" selector="createBasicFunctionsFor:">createBasicFunctionsFor: anObject	| exists notExists |	functions := IdentityDictionary new.	functions		at: #descending put: (PostfixFunction named: 'DESC');		at: #distinct put: (PrefixFunction named: 'DISTINCT');		at: #max put: (PrefixFunction named: 'MAX');		at: #min put: (PrefixFunction named: 'MIN');		at: #sum put: (PrefixFunction named: 'SUM');		at: #avg put: (PrefixFunction named: 'AVG');		at: #average put: (PrefixFunction named: 'AVG');		at: #toChar: put: (PrefixFunction named: 'TO_CHAR');		at: #not put: (PrefixFunction named: 'NOT');		at: #, put: (InfixFunction named: '||');		at: #countStar put: (StandaloneFunction named: 'COUNT(*)');		at: #count put: (PrefixFunction named: 'COUNT');		at: #between:and: put: (InfixFunction named: #('BETWEEN' 'AND'));		at: #isNil			put:				((RelationExpression new)						relation: #=;						rightChild: nil asGlorpExpression);		at: #notNil			put:				((RelationExpression new)						relation: #&lt;&gt;;						rightChild: nil asGlorpExpression);		at: #isNIL			put:				((RelationExpression new)						relation: #=;						rightChild: nil asGlorpExpression);		at: #notNIL			put:				((RelationExpression new)						relation: #&lt;&gt;;						rightChild: nil asGlorpExpression).	exists := InfixFunction named: 'EXISTS'.	anObject isNil ifFalse: [exists type: anObject boolean].	functions at: #exists: put: exists.	notExists := InfixFunction named: 'NOT EXISTS'.	anObject isNil ifFalse: [notExists type: anObject boolean].	functions at: #notExists: put: notExists.	functions		at: #asUppercase put: (PrefixFunction named: 'UPPER');		at: #asLowercase put: (PrefixFunction named: 'LOWER');		at: #replace:with: put: (PrefixFunction named: 'REPLACE');		at: #cast: put: ((Cast named: 'CAST') separator: ' AS ');		at: #copyFrom:to: put: (SubstringFunction named: 'SUBSTR').	^functions.</body><body package="GlorpExpressions" selector="initialize">initialize	self resetFunctions.</body><body package="GlorpExpressions" selector="named:">named: aString	"Used for creating template instances only"	^self new function: aString.</body><body package="GlorpExpressions" selector="resetFunctions">resetFunctions	"self resetFunctions"	functions := nil.</body></methods><methods><class-id>Glorp.FunctionExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="for:withArguments:basedOn:">for: aSymbol withArguments: anArray basedOn: anExpression	| base system |	base := anExpression ultimateBaseExpression.	system := base isNil ifTrue: [nil] ifFalse: [base system].		^self for: aSymbol withArguments: anArray basedOn: anExpression system: system.</body><body package="GlorpExpressions" selector="for:withArguments:basedOn:system:">for: aSymbol withArguments: anArray basedOn: anExpression system: system	| functionTemplate newFunction |	functionTemplate := (system isNil		ifTrue: [self basicFunctions]		ifFalse: [system platform functions]) at: aSymbol ifAbsent: [^nil].	newFunction := functionTemplate		createFor: anArray		withBase: anExpression		symbol: aSymbol.	^newFunction.</body></methods><methods><class-id>Glorp.PostfixFunction</class-id> <category>printing</category><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary		base printSQLOn: aStream withParameters: aDictionary.	self printsIntoJoins ifFalse: [^self].	aStream nextPutAll: ' '; nextPutAll: function.</body><body package="GlorpExpressions" selector="printUnqualifiedSQLOn:withParameters:">printUnqualifiedSQLOn: aStream withParameters: aDictionary		base printUnqualifiedSQLOn: aStream withParameters: aDictionary.	aStream nextPutAll: ' '; nextPutAll: function.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>accessing</category><body package="GlorpDatabase" selector="at:">at: aField	^self at: aField ifAbsent: [self error: 'missing field'].</body><body package="GlorpDatabase" selector="at:ifAbsent:">at: aField ifAbsent: absentBlock	^(self wrapperAt: aField ifAbsent: [^absentBlock value]) contents.</body><body package="GlorpDatabase" selector="at:ifAbsentPut:">at: aField ifAbsentPut: absentBlock	| old |	old := contents at: aField position.	old == self class emptySlot 		ifTrue: absentBlock		ifFalse: [^old contents].</body><body package="GlorpUnitOfWork" selector="at:put:">at: aField put: aValue 		"For generated fields, we expect the real value to be provided later by the database, so don't write a nil value"		| wrapper |"	aValue isGlorpExpression ifTrue: [self error: 'cannot store expressions in rows']."	aField table == self table ifFalse: [self error: 'Invalid table'].	wrapper := self contentsAt: aField ifAbsentPut: [FieldValueWrapper new].	(aValue isNil and: [aField isGenerated]) ifFalse: [wrapper contents: aValue].	wrapper isNowContainedBy: self and: aField.	^wrapper.</body><body package="GlorpDatabase" selector="atFieldNamed:">atFieldNamed: aString	| field |	field := table fieldNamed: aString.	^self at: field</body><body package="GlorpDatabase" selector="atFieldNamed:ifAbsent:">atFieldNamed: aString ifAbsent: aBlock	| field |	field := table fieldNamed: aString ifAbsent: aBlock.	^self at: field ifAbsent: aBlock.</body><body package="GlorpDatabase" selector="atFieldNamed:put:">atFieldNamed: aString put: anObject	| field |	field := table fieldNamed: aString.	^self at: field put: anObject</body><body package="GlorpDatabase" selector="contentsAt:ifAbsentPut:">contentsAt: aField ifAbsentPut: absentBlock	| old newValue |	old := contents at: aField position.	^old == self class emptySlot 		ifTrue: [			newValue := absentBlock value.			contents at: aField position put: newValue.			newValue]		ifFalse: [old].</body><body package="GlorpDatabase" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	^self atFieldNamed: aMessage selector asString ifAbsent: [super doesNotUnderstand: aMessage].</body><body package="GlorpDatabase" selector="fields">fields	^self table fields select: [:each | (self includesField: each)].</body><body package="GlorpDatabase" selector="forDeletion">forDeletion	^forDeletion.</body><body package="GlorpDatabase" selector="forDeletion:">forDeletion: aBoolean	forDeletion := aBoolean.</body><body package="GlorpDatabase" selector="includesField:">includesField: aField	^(contents at: aField position) ~~ self class emptySlot.</body><body package="GlorpDatabase" selector="lockKeyFields">lockKeyFields	^table lockKeyFields</body><body package="GlorpDatabase" selector="nonGeneratedFields">nonGeneratedFields	"Return a list of our fields that are not generated"	| result |	result := OrderedCollection new: contents size.	self table fields do: [:field | 		field isGenerated not ifTrue: [result add: field]].	^result.</body><body package="GlorpDatabase" selector="nonGeneratedFieldsWithValues">nonGeneratedFieldsWithValues	"Return a list of our fields that a) are not generated or b) have values. That is, exclude values we expect the database to generate"	| result |	result := OrderedCollection new: contents size.	self fieldsAndValidValuesDo: [:field :value | 		(value notNil or: [field isGenerated not]) ifTrue: [result add: field]].	^result.</body><body package="GlorpDatabase" selector="nonPrimaryKeyFields">nonPrimaryKeyFields	| result |	result := OrderedCollection new: contents size.	self fieldsDo: [:field | 		field isPrimaryKey ifFalse: [result add: field]].	^result.</body><body package="GlorpUnitOfWork" selector="numberOfFields">numberOfFields	^contents		inject: 0		into:			[:sum :each | sum + (each == self class emptySlot ifTrue: [0] ifFalse: [1])].</body><body package="GlorpDatabase" selector="oldVersionAt:ifAbsent:">oldVersionAt: aField ifAbsent: aBlock	oldVersion isNil ifTrue: [^aBlock value].	^oldVersion at: aField ifAbsent: aBlock.</body><body package="GlorpDatabase" selector="owner">owner	^owner.</body><body package="GlorpDatabase" selector="owner:">owner: anObject	owner := anObject.</body><body package="GlorpDatabase" selector="parent">parent	^parent</body><body package="GlorpDatabase" selector="parent:">parent: aDatabaseRow	parent := aDatabaseRow.</body><body package="GlorpDatabase" selector="primaryKey">primaryKey	| |	self table primaryKeyFields isEmpty ifTrue: [^nil].	^self table hasCompositePrimaryKey 		ifTrue: [			self table primaryKeyFields 				collect: [:each | 	self at: each]]		ifFalse: [self at: self table primaryKeyFields first ifAbsent: [nil]].</body><body package="GlorpDatabase" selector="status">status	^status</body><body package="GlorpDatabase" selector="status:">status: aSymbol	status := aSymbol</body><body package="GlorpDatabase" selector="table">table	"Private - Answer the value of the receiver's ''table'' instance variable."	^table</body><body package="GlorpDatabase" selector="values">values	| result |	result := OrderedCollection new.	self keysAndValuesDo: [:key :value |		result add: value].	^result</body><body package="GlorpDatabase" selector="wrapperAt:">wrapperAt: aField	^self wrapperAt: aField ifAbsent: [self error: 'Field not found'].</body><body package="GlorpDatabase" selector="wrapperAt:ifAbsent:">wrapperAt: aField ifAbsent: aBlock	| thing |	contents isNil ifTrue: [^aBlock value].	thing := contents at: aField position.	^thing == self class emptySlot ifTrue: aBlock ifFalse: [thing].</body><body package="GlorpDatabase" selector="wrapperAt:put:">wrapperAt: aField put: aWrapper	| old |	old := contents at: aField position.	old == aWrapper ifTrue: [^self].	contents at: aField position put: aWrapper.	aWrapper isNowContainedBy: self and: aField.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>printing</category><body package="GlorpDatabase" selector="equalityStringForField:">equalityStringForField: aDatabaseField	| stream |	stream := WriteStream on: (String new: 50).	self printEqualityStringForField: aDatabaseField on: stream.	^stream contents.</body><body package="GlorpDatabase" selector="fieldsNeedingUpdate">fieldsNeedingUpdate	"Return a list of the fields that are different from the previous version (if we know what that was)"	| result |	oldVersion isNil ifTrue: [^self nonPrimaryKeyFields].	result := OrderedCollection new: contents size.	self fieldsDo: 			[:each | 			each isPrimaryKey 				ifFalse: 					[(oldVersion at: each ifAbsent: [self class missingFieldIndicator]) 						= (self at: each) ifFalse: [result add: each]]].	^result</body><body package="GlorpDatabase" selector="printEqualityStringForField:on:">printEqualityStringForField: aDatabaseField on: aCommand 	"Get around PostgreSQL bug.  Qualified names cannot appear in SET expression."	aCommand nextPutAll: (aDatabaseField platform nameForColumn: aDatabaseField name).	aCommand nextPutAll: ' = '.	self printValueOfField: aDatabaseField on: aCommand</body><body package="GlorpDatabase" selector="printEqualityTemplateForField:on:">printEqualityTemplateForField: aDatabaseField on: aCommand	"Get around PostgreSQL bug.  Qualified names cannot appear in SET expression."	| bind |	aCommand nextPutAll: (aDatabaseField platform nameForColumn: aDatabaseField name).	aCommand nextPutAll: ' = '.	bind := aCommand canBind: (self at: aDatabaseField ifAbsent: [nil]) to: aDatabaseField type.	bind		ifTrue: [aCommand nextPutAll: '?']		ifFalse: [self printValueOfField: aDatabaseField on: aCommand].</body><body package="GlorpDatabase" selector="printEqualityTemplateForField:on:withBinding:">printEqualityTemplateForField: aDatabaseField on: aCommand withBinding: aBoolean	"Get around PostgreSQL bug.  Qualified names cannot appear in SET expression."	aCommand nextPutAll: (aDatabaseField platform nameForColumn: aDatabaseField name).	aCommand nextPutAll: ' = '.	aBoolean 		ifTrue: [aCommand nextPutAll: '?']		ifFalse: [self printValueOfField: aDatabaseField on: aCommand].</body><body package="GlorpDatabase" selector="printFieldNamesOn:">printFieldNamesOn: aWriteStream 	GlorpHelper 		do: [:each | aWriteStream nextPutAll: each name]		for: self table fields		separatedBy: [aWriteStream nextPutAll: ','].</body><body package="GlorpDatabase" selector="printLockEqualityForField:on:">printLockEqualityForField: aDatabaseField on: aStream	| expression |	expression := ((BaseExpression new getTable: aDatabaseField table) getField: aDatabaseField) get: #= withArguments: (Array with: (oldVersion at: aDatabaseField)).	expression printSQLOn: aStream withParameters: #().</body><body package="GlorpDatabase" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , ((table isNil or: [table name isNil]) ifTrue: [''] ifFalse: [table name]),  ')'.	aStream cr.	self fieldsAndValuesDo: [:eachField :eachWrapper |		aStream nextPutAll: '    '.		eachField printOn: aStream.		aStream nextPutAll: '-&gt;'.		eachWrapper printOn: aStream.		aStream cr.].</body><body package="GlorpDatabase" selector="printPrimaryKeyStringOn:">printPrimaryKeyStringOn: aStream 	"If there is no primary key (i.e. this is a link table) use all the values that we have"	| fields |	fields := table primaryKeyFields isEmpty 		ifTrue: [self fields]		ifFalse: [table primaryKeyFields].	GlorpHelper		do:  [:eachField |			self printEqualityStringForField: eachField on: aStream]		for: fields		separatedBy: [aStream nextPutAll: ' AND '].</body><body package="GlorpDatabase" selector="printPrimaryKeyTemplateOn:">printPrimaryKeyTemplateOn: aStream	"If there is no primary key (i.e. this is a link table) use all the values that we have"	| fields |	fields := table primaryKeyFields isEmpty 		ifTrue: [self fields]		ifFalse: [table primaryKeyFields].	GlorpHelper		do:  [:eachField |			self printEqualityTemplateForField: eachField on: aStream]		for: fields		separatedBy: [aStream nextPutAll: ' AND '].</body><body package="GlorpDatabase" selector="printValueOfField:on:">printValueOfField: aDatabaseField on: aWriteStream 	aDatabaseField type print: (self at: aDatabaseField ifAbsent: [nil]) on: aWriteStream.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>initializing</category><body package="GlorpDatabase" selector="fieldsAndValidValuesDo:">fieldsAndValidValuesDo: aBlock 	"If iterating over fields and values, we include wrappers with no value assigned yet. This might or might not be what we want. This one just iterates over ones with actual values"	self isEmpty ifTrue: [^self].	table fields do: [:each |  | value |		value := self at: each ifAbsent: [self class missingFieldIndicator].		value == self class missingFieldIndicator ifFalse: [			aBlock value: each value: value]].</body><body package="GlorpDatabase" selector="fieldsAndValuesDo:">fieldsAndValuesDo: aBlock 	table isNil ifTrue: [^self].	table fields do: [:each | aBlock value: each value: (self at: each ifAbsent: [self class missingFieldIndicator])]</body><body package="GlorpDatabase" selector="initialize">initialize	shouldBeWritten := true.	forDeletion := false.	generated := false.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>configuring</category><body package="GlorpDatabase" selector="shouldBeWritten:">shouldBeWritten: aBoolean 	shouldBeWritten := aBoolean</body><body package="GlorpDatabase" selector="table:">table: aDatabaseTable	table := aDatabaseTable.	contents := Array new: (aDatabaseTable fields size).	contents atAllPut: self class emptySlot.</body><body package="GlorpDatabase" selector="withAllFieldsIn:">withAllFieldsIn: aRow 	"aRow represents our original state. Make sure that we have all the fields in aRow, using nil values for any that are missing. This is needed if, e.g. we have been removed from a 1-many relationship, so we don't get a value generated for our foreign key, but we should still write it as a nil. We have to distinguish this from the case of a value that simply hasn't changed."	aRow isEmpty ifTrue: [^self].	oldVersion := aRow.	self numberOfFields = table fields size ifTrue: [^self].	aRow fieldsAndValidValuesDo: 			[:eachField :eachValue | 			(self includesField: eachField) ifFalse: [self at: eachField put: nil]].	^self</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>querying</category><body package="GlorpDatabase" selector="expectsToGetValueFor:">expectsToGetValueFor: aField	"Are we constrained to a field which is presumably going to get a value, which for the moment must mean it's a serial type. This is primarily required for identity column databases, because in other cases we will pre-allocate sequence numbers, and this should never come up"	| wrapper innerWrappers testBlock containing |	wrapper := self wrapperAt: aField ifAbsent: [^false].	innerWrappers := wrapper allInnerWrappers.	testBlock := [:eachField | (eachField ~~ aField and: [eachField type isSerial]) ifTrue: [^true]].	(Array with: wrapper), innerWrappers do: [:eachWrapper |		containing := eachWrapper containedBy.		containing glorpIsCollection 			ifTrue: [containing keysDo: testBlock]			ifFalse: [testBlock value: containing key]].	^false.</body><body package="GlorpDatabase" selector="hasValueFor:">hasValueFor: aField	^(self wrapperAt: aField ifAbsent: [^false]) hasValue.</body><body package="GlorpDatabase" selector="shouldBeWritten">shouldBeWritten	table isNil ifTrue: [^shouldBeWritten].	^shouldBeWritten and: [table shouldBeWritten].</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="needsValueFromSequence:">needsValueFromSequence: aSequence 	self table fields do: 			[:each | 			((self shouldGenerateValueFor: each) and: [each type sequence == aSequence]) 				ifTrue: [^true]].	^false</body><body package="GlorpDatabase" selector="postWriteAssignSequencesUsing:">postWriteAssignSequencesUsing: anAccessor	self table fields do: [:each |		(self hasValueFor: each) ifFalse: [			each type postWriteAssignSequenceValueFor: each in: self using: anAccessor]].</body><body package="GlorpDatabase" selector="preWriteAssignSequencesUsing:">preWriteAssignSequencesUsing: aSession	"Skip if we've already been generated"	generated ifTrue: [^self].	self table fields do: 			[:each | 			(self shouldGenerateValueFor: each in: aSession) 				ifTrue: 					[each type 						preWriteAssignSequenceValueFor: each						in: self						using: (aSession isNil ifTrue: [nil] ifFalse: [aSession accessor])]].	generated := true.</body><body package="GlorpDatabase" selector="shouldGenerateValueFor:">shouldGenerateValueFor: aField	^self shouldGenerateValueFor: aField in: nil.</body><body package="GlorpDatabase" selector="shouldGenerateValueFor:in:">shouldGenerateValueFor: aField in: aSession	| isInsert |	aField isGenerated ifFalse: [^false].	aField type generatesOverExistingValues ifTrue: [^true].	"For those that don't write over existing values, only update them if this is an insert. Otherwise we can't tell the difference between an empty column and one which we're just not updating in this unit of work. This requires the session, but the session may be nil - if so, default to true, because that usage is just for reserving sequence numbers, and it's better to err on the side of too many."	isInsert := aSession isNil ifTrue: [true] ifFalse: [aSession shouldInsert: self].	^isInsert and: [(self hasValueFor: aField) not].</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>relationships</category><body package="GlorpDatabase" selector="relatedRowsIn:">relatedRowsIn: aRowMap	| relatedRows |	relatedRows := OrderedCollection new.	self table foreignKeyConstraints		do:			[:eachConstraint | relatedRows addAll: (eachConstraint rowsRelatedTo: self)].	^relatedRows.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>testing</category><body package="GlorpDatabase" selector="equals:">equals: aRow 	self forDeletion = aRow forDeletion ifFalse: [^false].	self fieldsAndValuesDo: 			[:eachField :eachWrapper | 			| otherValue |			otherValue := aRow at: eachField ifAbsent: [self class missingFieldIndicator].			eachWrapper = otherValue ifFalse: [^false]].	^true</body><body package="GlorpDatabase" selector="hash">hash	| basic |	basic := self table hash.	self fieldsAndValuesDo: 			[:eachField :eachValue | 			basic := basic bitXor: eachField hash.			basic := basic bitXor: eachValue hash].	^basic.</body><body package="GlorpDatabase" selector="isEmpty">isEmpty	| empty |	contents isNil ifTrue: [^true].	empty := self class emptySlot.	contents do: [:each | each == empty ifFalse: [^false]].	^true.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>enumerating</category><body package="GlorpDatabase" selector="fieldsDo:">fieldsDo: aBlock 	1 to: contents size do: [:i |		| value |		value := contents at: i.		(value == self class emptySlot) ifFalse: [aBlock value: (self table fields at: i)]].</body><body package="GlorpDatabase" selector="fieldValuesDo:">fieldValuesDo: aBlock 	contents do: [:each | each == self class emptySlot ifFalse: [aBlock value: each]].</body><body package="GlorpDatabase" selector="keysAndValuesDo:">keysAndValuesDo: aBlock	1 to: contents size do: [:i |		| value | 		value := contents at: i.		value == self class emptySlot ifFalse: [			aBlock value: (self table fields at: i) value: value contents]].</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>comparing</category><body package="GlorpDatabase" selector="=">= aRow	self class == aRow class ifFalse: [^false].	^self equals: aRow.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>private</category><body package="GlorpUnitOfWork" selector="at:forcePut:">at: aField forcePut: aValue 	"Write the value. If there's a previous value, overwrite it. Use with extreme caution."	| wrapper |	aValue isGlorpExpression ifTrue: [self error: 'cannot store expressions in rows'].	aField table == self table ifFalse: [self error: 'Invalid table'].	wrapper := self contentsAt: aField ifAbsentPut: [FieldValueWrapper new].	wrapper privateSetContents: aValue.	^wrapper.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>api</category><body package="GlorpUnitOfWork" selector="unifyField:withField:inRow:">unifyField: eachSourceField withField: eachTargetField inRow: targetRow	| sourceWrapper targetWrapper |	sourceWrapper := self wrapperAt: eachSourceField ifAbsent: [nil].	targetWrapper := targetRow wrapperAt: eachTargetField ifAbsent: [nil].	sourceWrapper isNil		ifTrue:			[targetWrapper isNil				ifTrue:					[targetWrapper := FieldValueWrapper new.					targetRow wrapperAt: eachTargetField put: targetWrapper].			^self wrapperAt: eachSourceField put: targetWrapper].	targetWrapper isNil ifTrue: [^targetRow wrapperAt: eachTargetField put: sourceWrapper].	sourceWrapper unifyWith: targetWrapper.</body></methods><methods><class-id>Glorp.DatabaseRow class</class-id> <category>private</category><body package="GlorpDatabase" selector="emptySlot">emptySlot	emptySlot == nil ifTrue: [emptySlot := Object new].	^emptySlot.</body><body package="GlorpDatabase" selector="missingFieldIndicator">missingFieldIndicator	missingFieldIndicator == nil ifTrue: [missingFieldIndicator := Object new].	^missingFieldIndicator.</body></methods><methods><class-id>Glorp.DatabaseRow class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="new">new	^super new initialize.</body><body package="GlorpDatabase" selector="newForTable:">newForTable: aTable	^self new table: aTable.</body><body package="GlorpDatabase" selector="newForTable:withOwner:">newForTable: aTable withOwner: anObject	^self new table: aTable; owner: anObject.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>preparing</category><body package="GlorpMappings" selector="joinExpressionFor:">joinExpressionFor: anExpression	^nil.</body><body package="GlorpMappings" selector="multipleTableExpressionsFor:">multipleTableExpressionsFor: anExpression	^#().</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="applicableMappingForObject:">applicableMappingForObject: anObject 	"For polymorphism with conditional mappings"	^self</body><body package="GlorpMappings" selector="createDeleteRowFor:in:">createDeleteRowFor: anObject in: aRowMap	"Only applies to mappings that write into link tables"</body><body package="GlorpMappings" selector="expressionFor:">expressionFor: anObject	"Return an expression representing the value of the object. This can be nil, an object value or values, an expression, or a collection of expressions (for a composite key, if we're passed an expression)"	anObject isNil ifTrue: [^#(nil)].	anObject isGlorpExpression ifFalse: [		^self mappedFields collect: [:each | 				self valueOfField: each fromObject: anObject]].	^self mappedFields		collect: [:each | (anObject getField: each)].</body><body package="GlorpMappings" selector="expressionFor:basedOn:relation:">expressionFor: anObject basedOn: anExpression relation: aSymbol	"Return our expression using the object's values. e.g. if this was a direct mapping from id-&gt;ID and the object had id: 3, then return TABLE.ID=3. Used when rewriting object=object into field=field"	| myValue result |	myValue := self expressionFor: anObject.	result := nil.	myValue with: self join allTargetFields do: [:eachValue :eachField |		| source |		source := anExpression get: self attribute name.		source hasDescriptor ifTrue: [source := source getField: eachField].		result := (source get: aSymbol withArguments: (Array with: eachValue)) AND: result].	^result.</body><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap	self subclassResponsibility.</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anObject1	self subclassResponsibility.</body><body package="GlorpMappings" selector="mappedTables">mappedTables	^(self mappedFields collect: [:each | each table]) asSet.</body><body package="GlorpMappings" selector="readBackNewRowInformationFor:fromRowsIn:">readBackNewRowInformationFor: anObject fromRowsIn: aRowMap 	"	self subclassResponsibility. ?"</body><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:">referencedIndependentObjectsFrom: anObject	self subclassResponsibility.</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	self subclassResponsibility.</body><body package="GlorpMappings" selector="translateFields:">translateFields: anOrderedCollection 	"Normal mappings don't translate"	^anOrderedCollection.</body><body package="GlorpMappings" selector="translateTable:">translateTable: aTable	"If we have a field translation, return the translated (i.e. real) table to use. This ideally allows us to use either the real table in which something is embedded, or the imaginary table"	^aTable.</body><body package="GlorpMappings" selector="valueOfField:fromObject:">valueOfField: aField fromObject: anObject	self error: 'Can''t get value of field'.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>testing</category><body package="GlorpMappings" selector="canBeUsedForRetrieve">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	self isRelationship ifFalse: [^true].	^self isToManyRelationship not.</body><body package="GlorpMappings" selector="controlsTables">controlsTables	"Return true if this type of mapping 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	self subclassResponsibility</body><body package="GlorpMappings" selector="hasAttribute">hasAttribute	"Return true if this maps an attribute, which is normally true"	^true</body><body package="GlorpMappings" selector="hasImpliedClauses">hasImpliedClauses	"Return true if this implies multiple sql clauses"	^false.</body><body package="GlorpMappings" selector="hasValueThatCanProvideField:from:">hasValueThatCanProvideField: aField from: anObject	"Return true if we have enough information in ourselves to populate our fields. The only time this won't be true is if we're either holding an uninstantiated proxy or have a to-many relationship mapping with an empty collection."	^true.</body><body package="GlorpMappings" selector="includesSubFieldsInSelectStatement">includesSubFieldsInSelectStatement	^false</body><body package="GlorpMappings" selector="isRelationship">isRelationship	"True when the mapping associates different persistent classes."	^self subclassResponsibility</body><body package="GlorpMappings" selector="isStoredInSameTable">isStoredInSameTable	"True when the mapping is between two objects that occupy the same table, e.g. an embedded mapping."	^self subclassResponsibility</body><body package="GlorpMappings" selector="isToManyRelationship">isToManyRelationship	^false.</body><body package="GlorpMappings" selector="isTypeMapping">isTypeMapping	^false</body><body package="GlorpMappings" selector="mappedFields">mappedFields	self subclassResponsibility</body><body package="GlorpMappings" selector="mapsPrimaryKeys">mapsPrimaryKeys	^(self mappedFields detect: [:each | each isPrimaryKey] ifNone: [nil]) notNil.</body><body package="GlorpMappings" selector="mapsSimpleObject">mapsSimpleObject	"Return true if we know that we map something without a descriptor. For some mappings, like ad hoc or conditional, we don't really know, so we default to false"	^false.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="allTables">allTables	self subclassResponsibility.</body><body package="GlorpMappings" selector="attribute">attribute	attribute isNil ifTrue: [attribute := GlorpAttributeModel new].	^attribute.</body><body package="GlorpMappings" selector="attributeAccessor">attributeAccessor	^self attribute.</body><body package="GlorpMappings" selector="attributeName">attributeName	^self attribute name.</body><body package="GlorpMappings" selector="attributeName:">attributeName: aSymbol	| oldAttribute symbolName |	symbolName := aSymbol asSymbol.	oldAttribute := attribute.	attribute := self classModel attributeNamed: symbolName.	oldAttribute isNil		ifTrue: [self initializeAttribute]		ifFalse: [attribute copyFrom: oldAttribute].</body><body package="GlorpMappings" selector="beForPseudoVariable">beForPseudoVariable	self attribute beForPseudoVariable.</body><body package="GlorpMappings" selector="beReadOnly">beReadOnly	self canWrite: false.</body><body package="GlorpMappings" selector="canRead">canRead	^self attribute canRead.</body><body package="GlorpMappings" selector="canWrite">canWrite	^self attribute canWrite.</body><body package="GlorpMappings" selector="canWrite:">canWrite: aBoolean	self attribute canWrite: aBoolean.</body><body package="GlorpMappings" selector="classModel">classModel	"If we don't have one, just make a temporary one. We'll fix it later"	descriptor isNil ifTrue: [^GlorpClassModel new].	^self descriptor classModel.</body><body package="GlorpMappings" selector="descriptor">descriptor	^descriptor</body><body package="GlorpMappings" selector="descriptor:">descriptor: aDescriptor	descriptor := aDescriptor.	attribute isNil ifFalse: [self copyAttributeAttributes].</body><body package="GlorpMappings" selector="fieldsForDescriptorSelectStatement">fieldsForDescriptorSelectStatement	"Return a collection of fields that this mapping will read from a row when the containing object is read, as opposed to when we're specifically told to use this field. Normally it amounts to the same thing."	^self mappedFields.</body><body package="GlorpMappings" selector="fieldsForSelectStatement">fieldsForSelectStatement	"Return a collection of fields that this mapping will read from a row"	self canRead ifFalse: [^#()].	^self mappedFields</body><body package="GlorpMappings" selector="isForPseudoVariable">isForPseudoVariable	^self attribute isForPseudoVariable or: [self attributeAccessor isValid not].</body><body package="GlorpMappings" selector="readOnly">readOnly	^self canWrite not.</body><body package="GlorpMappings" selector="readOnly:">readOnly: aBoolean	self canWrite: aBoolean not.</body><body package="GlorpMappings" selector="referenceClass">referenceClass	^self attribute type.</body><body package="GlorpMappings" selector="session">session		^self descriptor session.</body><body package="GlorpMappings" selector="system">system		^self descriptor system.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>printing SQL</category><body package="GlorpMappings" selector="allRelationsFor:do:andBetweenDo:">allRelationsFor: rootExpression do: aBlock andBetweenDo: anotherBlock	"Normal mappings just operate on a single expression"	aBlock value: rootExpression leftChild value: rootExpression rightChild.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>public</category><body package="GlorpMappings" selector="getValueFrom:">getValueFrom: anObject	^self attribute getValueFrom: anObject.</body><body package="GlorpMappings" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: '(';		nextPutAll: (attribute isNil ifTrue: [''] ifFalse: [self attributeName]) ;		nextPutAll: ')'.</body><body package="GlorpMappings" selector="setValueIn:to:">setValueIn: anObject to: aValue	self canRead ifFalse: [^self].	self attribute setValueIn: anObject to: aValue.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>debugging</category><body package="GlorpMappings" selector="debugRead">debugRead	^debugRead</body><body package="GlorpMappings" selector="debugRead:">debugRead: aBoolean	debugRead := aBoolean</body><body package="GlorpMappings" selector="debugWrite">debugWrite	^debugWrite</body><body package="GlorpMappings" selector="debugWrite:">debugWrite: aBoolean	debugWrite := aBoolean</body><body package="GlorpMappings" selector="stopIfDebuggingRead">stopIfDebuggingRead	debugRead ifTrue: [self halt].</body><body package="GlorpMappings" selector="stopIfDebuggingWrite">stopIfDebuggingWrite	debugWrite ifTrue: [self halt].</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>api</category><body package="GlorpMappings" selector="beExclusive">beExclusive	self error: 'Only relationship mappings can be exclusive'.</body><body package="GlorpMappings" selector="isExclusive">isExclusive	^false.</body><body package="GlorpMappings" selector="isExclusive:">isExclusive: aBoolean	aBoolean ifTrue: [self error: 'Only relationship mappings can be exclusive'].</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>iterating</category><body package="GlorpMappings" selector="loopOverAttributeOf:doing:">loopOverAttributeOf: anObject doing: aTwoArgumentBlock	"Loop over the target, which we extract from anObject, and iterate over it evaluating the block. For things that aren't collections, iterating means just run once. Note that the argument is expected to be an instance of our descriptor, as opposed to the attribute method, which expects the target object"	| target |	target := self getValueFrom: anObject.	self attribute loopOver: target doing: aTwoArgumentBlock.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>initialize/release</category><body package="GlorpMappings" selector="copyAttributeAttributes">copyAttributeAttributes	"We have an attributemodel that was created before we actually had a descriptor. It's possible that it had properties set. Make sure we copy them. If necessary, initialize things that require it."	| oldAttribute |	oldAttribute := attribute.	attribute := self classModel attributeNamed: oldAttribute name type: oldAttribute type collectionType: oldAttribute collectionType.	attribute copyFrom: oldAttribute.	self initializeAttribute.</body><body package="GlorpMappings" selector="initialize">initialize	debugRead := false.	debugWrite := false.</body><body package="GlorpMappings" selector="initializeAttribute">initializeAttribute	"This is where we can initialize aspects of the attribute, if required. The motivating example is initializing the collection type of the attribute if it wasn't set. We need it to have some type, but we don't want to initialize it while we're doing basic initialization and aren't yet properly attached to a descriptor or class model"</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	self validateAttribute</body><body package="GlorpMappings" selector="validateAttribute">validateAttribute	self canWrite ifTrue: [self attribute validateCanWrite].	self canRead ifTrue: [self attribute validateCanRead]</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>proxies</category><body package="GlorpMappings" selector="newProxyIn:">newProxyIn: anObjectBuilder 	| proxy |	proxy := Proxy new.	proxy query: (self queryFor: anObjectBuilder).	proxy glorpProxyAction: self proxyAction.	^proxy</body><body package="GlorpMappings" selector="proxyAction">proxyAction	^nil.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>private</category><body package="GlorpMappings" selector="convertedDbValueOf:">convertedDbValueOf: stValue 	"Mappings in general don't know how to do type conversion. Subclasses that deal with database primitive types should override."	^stValue</body></methods><methods><class-id>Glorp.Mapping class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anElementBuilder	| value |	value := anElementBuilder isNil		ifTrue: [constantValue]		ifFalse: [self constantValueIn: anElementBuilder session].	self setValueIn: anObject to: value.</body><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:">referencedIndependentObjectsFrom: anObject	^#().</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	^self.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="constantValue">constantValue	^constantValue.</body><body package="GlorpMappings" selector="constantValue:">constantValue: anObject	constantValue := anObject.</body><body package="GlorpMappings" selector="constantValueIn:">constantValueIn: aSession	^valueIsSession		ifTrue: [aSession]		ifFalse: [constantValue].</body><body package="GlorpMappings" selector="constantValueIsSession">constantValueIsSession	valueIsSession := true.</body><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^#().</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="controlsTables">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^false</body><body package="GlorpMappings" selector="isRelationship">isRelationship	^false</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>api</category><body package="GlorpMappings" selector="getValueFrom:">getValueFrom: anObject	^constantValue.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>initialize/release</category><body package="GlorpMappings" selector="initialize">initialize	super initialize.	valueIsSession := false.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validateAttribute">validateAttribute	^self.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>accessing</category><body package="GlorpMappings" selector="addMapping:">addMapping: aMapping 	self basicAddMapping: aMapping.	aMapping hasAttribute ifTrue: [		(aMapping classModel attributeNamed: aMapping attribute name) == aMapping attribute ifFalse: [self error: 'If you have a classModel you must use newMapping: rather than addMapping:']].</body><body package="GlorpMappings" selector="addMultipleTableJoin:">addMultipleTableJoin: anExpression 	self multipleTableJoin add: anExpression</body><body package="GlorpMappings" selector="addTable:">addTable: aDatabaseTable 	tables add: aDatabaseTable.</body><body package="GlorpMappings" selector="allMappingsForField:">allMappingsForField: aField 	"Return all of the mappings that use this field"	^mappings select: [:each | each mappedFields includes: aField]</body><body package="GlorpMappings" selector="allTables">allTables	"Return all tables used by this descriptor or its subclasses. For a non-inheritance descriptor, this is the same as tables."	^self typeResolver allTablesFor: self.</body><body package="GlorpMappings" selector="basicAddMapping:">basicAddMapping: aMapping 	mappings := mappings, (Array with: aMapping).	aMapping descriptor: self.	self resetMappedFields.</body><body package="GlorpMappings" selector="cachePolicy">cachePolicy	cachePolicy isNil ifTrue: [^system cachePolicy].	^cachePolicy</body><body package="GlorpMappings" selector="cachePolicy:">cachePolicy: aCachePolicy	cachePolicy:= aCachePolicy</body><body package="GlorpMappings" selector="classModel">classModel	^classModel</body><body package="GlorpMappings" selector="classModel:">classModel: aGlorpClassModel	classModel := aGlorpClassModel</body><body package="GlorpMappings" selector="describedClass">describedClass	^classModel describedClass.</body><body package="GlorpMappings" selector="describedClass:">describedClass: aClass	classModel := self system classModelFor: aClass.</body><body package="GlorpMappings" selector="directMappingForField:">directMappingForField: aField 	"Return a single, direct mapping for this field. There may conceivably be more than one, but they all have to agree, so it shouldn't matter as far as the value. There may also be none."	^(self mappingsForFields at: aField ifAbsent: [^nil]) 		detect: [:each | each isRelationship not]		ifNone: [nil]</body><body package="GlorpMappings" selector="directMappingsForField:">directMappingsForField: aField 	"Return all the relationship mappings that use this field"	^(self mappingsForFields at: aField ifAbsent: [^#()]) 		reject: [:each | each isRelationship].</body><body package="GlorpMappings" selector="fieldsForSelectStatement">fieldsForSelectStatement	| myFields inheritedFields |	myFields := self mappedFields.	inheritedFields := self typeResolver fieldsForSelectStatement.	^inheritedFields isEmpty ifTrue: [myFields] ifFalse: [myFields, inheritedFields].</body><body package="GlorpMappings" selector="imaginaryTableIsDefinedByRelationFrom:to:">imaginaryTableIsDefinedByRelationFrom: sourceAttributeName to: targetAttributeName	self imaginaryTableReplacements add: (Array with: sourceAttributeName with: targetAttributeName).</body><body package="GlorpMappings" selector="initialize">initialize	mappings := Array new.	tables := OrderedCollection new: 1.</body><body package="GlorpMappings" selector="keyFields">keyFields	"Return the fields we use as primary keys for caching purposes. Typically, these are just going to be the primary keys of our primary table. Objects intended to be embedded won't map the primary keys at all. Weird objects may supply their own keys (e.g. functions rather than fields directly)"	^keyFields == nil		ifTrue:			[self mapsPrimaryKeys				ifTrue: [self primaryTable primaryKeyFields]				ifFalse: [nil]]		ifFalse: [keyFields].</body><body package="GlorpMappings" selector="keyFields:">keyFields: aFieldCollection	"Set the fields we use as primary keys for caching purposes. Typically, these are just going to be the primary keys of our primary table"	keyFields := aFieldCollection.</body><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return all the fields that are mapped, in the order that they occur in the table. This specifically omits fields that are not in the selected set of tables (so e.g. even if a mapping uses a link table field, if it's not in the list of tables to select from, we don't want it). We also include mapped, non-constant expressions, which we would normally expect to be functions"	mappedFields isNil ifTrue: [		| fieldSet |		fieldSet := IdentitySet new: mappings size.		mappings do: [:each | fieldSet addAll: each fieldsForDescriptorSelectStatement].		mappedFields := OrderedCollection new.		tables do: [:each |			each fields do: [:eachField | (fieldSet includes: eachField) ifTrue: [mappedFields add: eachField]]].		fieldSet do: [:each |  			(each isGlorpExpression and: [each isConstantExpression not]) ifTrue: [mappedFields add: each]]].	^mappedFields.</body><body package="GlorpMappings" selector="mappingForAttributeNamed:">mappingForAttributeNamed: aSymbol	^mappings detect: [:each | each attributeName == aSymbol] ifNone: [		self isForAssociation ifTrue: [self valueDescriptor mappingForAttributeNamed: aSymbol]]</body><body package="GlorpMappings" selector="mappingForField:">mappingForField: aField	^(self mappingsForFields at: aField ifAbsent: [^nil]) first.</body><body package="GlorpMappings" selector="mappingsForFields">mappingsForFields	"Return a dictionary from fields to the mappings that contain them. This specifically omits fields that are not in the selected set of tables (so e.g. even if a mapping uses a link table field, if it's not in the list of tables to select from, we don't want it). We also include mapped, non-constant expressions, which we would normally expect to be functions"	mappingsForFields isNil ifTrue: [		mappingsForFields := IdentityDictionary new: mappings size.		mappings do: [:eachMapping | 			eachMapping mappedFields do: [:eachField | 				(mappingsForFields at: eachField ifAbsentPut: [OrderedCollection new]) add: eachMapping]]].	^mappingsForFields.</body><body package="GlorpMappings" selector="multipleTableJoin">multipleTableJoin	multipleTableJoin isNil		ifTrue: [multipleTableJoin := OrderedCollection new: 1].	^multipleTableJoin.</body><body package="GlorpMappings" selector="primaryTable">primaryTable	tables isEmpty ifTrue: [^nil].	^tables first.</body><body package="GlorpMappings" selector="relationshipMappingForField:">relationshipMappingForField: aField 	"Return a single, direct mapping for this field. There may conceivably be more than one, but they all have to agree, so it shouldn't matter as far as the value. There may also be none."	^(self mappingsForFields at: aField ifAbsent: [^nil]) 		detect: [:each | each isRelationship]		ifNone: [nil]</body><body package="GlorpMappings" selector="relationshipMappingsForField:">relationshipMappingsForField: aField 	"Return all the relationship mappings that use this field"	^(self mappingsForFields at: aField ifAbsent: [^#()]) 		select: [:each | each isRelationship].</body><body package="GlorpMappings" selector="removeMapping:">removeMapping:  aMapping	mappings := mappings copyWithout: aMapping</body><body package="GlorpMappings" selector="resetMappedFields">resetMappedFields	mappedFields := nil.</body><body package="GlorpMappings" selector="session">session	^system session.</body><body package="GlorpMappings" selector="system">system	^system</body><body package="GlorpMappings" selector="system:">system: anObject	system := anObject</body><body package="GlorpMappings" selector="table">table	tables isEmpty ifTrue: [^nil].	^tables first.</body><body package="GlorpMappings" selector="table:">table: aDatabaseTable		| table |	table := aDatabaseTable isString		ifTrue: [table := self system tableNamed: aDatabaseTable]		ifFalse: [aDatabaseTable].	tables add: table.</body><body package="GlorpMappings" selector="tables">tables	^tables</body><body package="GlorpMappings" selector="typeMapping">typeMapping	^mappings detect: [ :each | each isTypeMapping ] ifNone: [		| mapping |		mapping := IdentityTypeMapping new.		self addMapping: mapping.		mapping]</body><body package="GlorpMappings" selector="typeMapping:">typeMapping: aMapping	self addMapping: aMapping</body><body package="GlorpMappings" selector="typeResolver">typeResolver	typeResolver isNil		ifTrue: [  IdentityTypeResolver new register: self  ].	^typeResolver</body><body package="GlorpMappings" selector="typeResolver:">typeResolver: anObject	typeResolver := anObject</body><body package="GlorpMappings" selector="valueDescriptor">valueDescriptor	| valueMapping |	valueMapping := self mappingForAttributeNamed: #value.	valueMapping isNil ifTrue: [^nil].	^valueMapping referenceDescriptor.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>tracing</category><body package="GlorpMappings" selector="defaultTracing">defaultTracing	^Tracing new.</body><body package="GlorpMappings" selector="setupTracing:">setupTracing: aTracing	"Find all the other objects that need to be read when this one is read"	self trace: aTracing context: aTracing base.</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	"For each mapping, check if the relationship is involved in the set of thingsto be read"	mappings do: [:each |		each trace: aTracing context: anExpression].</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>type mapping</category><body package="GlorpMappings" selector="allDescribedConcreteClasses">allDescribedConcreteClasses	^ self typeMapping allDescribedConcreteClasses</body><body package="GlorpMappings" selector="registerTypeResolver:">registerTypeResolver: aResolver	self registerTypeResolver: aResolver abstract: false</body><body package="GlorpMappings" selector="registerTypeResolver:abstract:">registerTypeResolver: aResolver abstract: shouldBeAbstract	shouldBeAbstract ifFalse: [ self beAbstract ].	aResolver register: self.</body><body package="GlorpMappings" selector="typeMappingCriteriaIn:">typeMappingCriteriaIn: base	| r l |	r := ConstantExpression for: self typeMapping keys.	l := FieldExpression forField: self typeMapping field basedOn: base.	^l in: r</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>internal</category><body package="GlorpMappings" selector="buildReplacementTableSelect">buildReplacementTableSelect	"We have an imaginary table which is defined by selecting from our attributes instead of from the table. Build the query for that."	| sourceMappings targetMappings mainQuery subQuery |	mainQuery := nil.	sourceMappings := imaginaryTableReplacements		collect: [:each | self mappingForAttributeNamed: each first].	targetMappings := imaginaryTableReplacements		collect: [:each | self mappingForAttributeNamed: each last].	sourceMappings		with: targetMappings		do:			[:eachSourceMapping :eachTargetMapping | 			subQuery := self				buildReplacementTableSelectFrom: eachSourceMapping				to: eachTargetMapping.			mainQuery := mainQuery isNil				ifTrue: [subQuery]				ifFalse: [mainQuery unionAll: subQuery]].	mainQuery session: self session.	self primaryTable replacementSubSelect: mainQuery.</body><body package="GlorpMappings" selector="buildReplacementTableSelectFrom:to:">buildReplacementTableSelectFrom: sourceMapping to: targetMapping	"Build a select statement that combines the two mappings. We expect that both are relationships from a single object whose table is imaginary, so we need to knit together the information from the mappings to join the real tables directly together."	| fullJoin targetJoin sourceJoin subQuery join |	subQuery := Query returningManyOf: sourceMapping referenceClass.	subQuery session: self session.		subQuery setUpExpressions.	"Invert because these will both start with the imaginary one on the left and we want to merge them together"	sourceJoin := (sourceMapping join		replacing: self primaryTable		withEquivalenceFrom: targetMapping join) inverseJoin.	targetJoin := targetMapping join		replacing: self primaryTable		withEquivalenceFrom: sourceMapping join.	fullJoin := sourceJoin = targetJoin		ifTrue: [sourceJoin]		ifFalse: [sourceJoin , targetJoin].	join := fullJoin asGeneralGlorpExpression asExpressionJoiningSource: subQuery baseExpression toTarget: subQuery baseExpression.	subQuery addJoin: join.	sourceMapping usesLinkTable ifTrue: [subQuery addJoin: (sourceMapping  expressionFromLinkToReferenceTableWithBase: subQuery baseExpression)].	targetMapping usesLinkTable ifTrue: [subQuery addJoin: (targetMapping  expressionFromLinkToReferenceTableWithBase: subQuery baseExpression)].	self		setRetrievalExpressionsInReplacementTableForQuery: subQuery		fromMapping: sourceMapping		toMapping: targetMapping.	^subQuery.</body><body package="GlorpMappings" selector="describedConcreteClassFor:withBuilder:">describedConcreteClassFor: row withBuilder: builder	"Lookup the class that is represented by the row when there is a possibility		of this row representing any class within a hierarchy. "	^self typeResolver describedConcreteClassFor: row withBuilder: builder descriptor: self</body><body package="GlorpMappings" selector="readBackNewRowInformationFor:">readBackNewRowInformationFor: anObject</body><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:do:">referencedIndependentObjectsFrom: anObject do: aBlock	mappings do: [:each |		(each referencedIndependentObjectsFrom: anObject) do: [:eachReferencedObject |			aBlock value: eachReferencedObject]].</body><body package="GlorpMappings" selector="referencedIndependentObjectsWithMappingsFrom:do:">referencedIndependentObjectsWithMappingsFrom: anObject do: aBlock	mappings do: [:each |		(each referencedIndependentObjectsFrom: anObject) do: [:eachReferencedObject |			aBlock value: eachReferencedObject value: each]].</body><body package="GlorpMappings" selector="setRetrievalExpressionsInReplacementTableForQuery:fromMapping:toMapping:">setRetrievalExpressionsInReplacementTableForQuery: subQuery fromMapping: sourceMapping toMapping: targetMapping	self primaryTable fields		do:			[:each | 			| sourceReplacement replacement expression |			sourceReplacement := sourceMapping join targetForSource: each.			replacement := sourceReplacement isNil				ifTrue: [targetMapping join targetForSource: each]				ifFalse: [sourceReplacement].			expression := replacement isGlorpExpression				ifTrue: [replacement] 				ifFalse: [(BaseExpression new getTable: replacement table) getField: replacement].			expression alias: each name.			subQuery retrieve: expression].</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>testing</category><body package="GlorpMappings" selector="computeMapsPrimaryKeys">computeMapsPrimaryKeys	| primaryKeyFields |	self tables isEmpty ifTrue: [^false].	primaryKeyFields := self primaryTable primaryKeyFields.	primaryKeyFields isEmpty ifTrue: [^false].	primaryKeyFields		do: [:each | (self mappedFields anySatisfy: [ :eachMappedField |			eachMappedField = each]) ifFalse: [^false]].	^true.</body><body package="GlorpMappings" selector="isForAssociation">isForAssociation	^self describedClass == Association.</body><body package="GlorpMappings" selector="isTypeMappingRoot">isTypeMappingRoot	^self typeResolver isTypeMappingRoot: self</body><body package="GlorpMappings" selector="mapsPrimaryKeys">mapsPrimaryKeys	mapsPrimaryKeys isNil ifTrue: [mapsPrimaryKeys := self computeMapsPrimaryKeys].	^mapsPrimaryKeys</body><body package="GlorpMappings" selector="supportsOrdering">supportsOrdering	typeResolver isNil ifTrue: [^true].	^typeResolver supportsOrderingFor: self.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>mapping</category><body package="GlorpMappings" selector="createRowsFor:in:">createRowsFor: anObject in: aRowMap	| row |	anObject class == self describedClass		ifFalse: [self error: 'wrong descriptor for this object'].	mappings do: [:each | 			each stopIfDebuggingWrite.			each mapFromObject: anObject intoRowsIn: aRowMap].	"If we haven't written out our primary keys, then make sure we do so, but if absolutely none of our mappings have written anything, then just ignore it."	row := aRowMap rowForTable: self primaryTable withKey: anObject ifAbsent: [^self].	self primaryTable primaryKeyFields do: [:each | 		self setFieldValue: each 	in: row from: anObject].	"This is a bit of a hack/heuristic. If the multiple table join is an outer join, and the row doesn't exist yet, then assume we won't need it and don't do the join. It means none of our mappings wrote to it. Hope that in that case no one else's will. It seems reasonable that we wouldn't map an object to multiple tables unless we planned to map some field within it, but it's still a bit of a risk."	self multipleTableJoin do: [:each | 		(each isOuterJoin not or: [each allTables anySatisfy: [:eachTable | 			aRowMap includesRowForTable: eachTable withKey: anObject]]) 				ifTrue: [					each						mapFromSource: anObject						andTarget: anObject						intoRowsIn: aRowMap]].</body><body package="GlorpMappings" selector="mappings">mappings	^ReadStream on: mappings</body><body package="GlorpMappings" selector="populateObject:inBuilder:">populateObject: anObject inBuilder: anElementBuilder	"Answer an object using the values for the specified fields."	mappings		do: [:each | 			each stopIfDebuggingRead.			each mapObject: anObject inElementBuilder: anElementBuilder].</body><body package="GlorpMappings" selector="primaryKeyCollectionFor:">primaryKeyCollectionFor: anObject	"Find the primary key for anObject. Always return it as a collection."	| fields |	anObject yourSelf class == self describedClass		ifFalse: [self error: 'Wrong descriptor for this object'].	fields := self primaryTable primaryKeyFields.	^fields collect: [:each | self valueOfField: each fromObject: anObject].</body><body package="GlorpMappings" selector="primaryKeyExpressionFor:basedOn:relation:">primaryKeyExpressionFor: anObject basedOn: anExpression relation: aSymbol	"anObject can be either a real domain object, or a constant expression containing it, or an expression representing the object"	| expression value pkMappings |	value := anObject isGlorpExpression		ifTrue:			[anObject isConstantExpression ifTrue: [anObject value] ifFalse: [anObject]]		ifFalse:			[anObject class == self describedClass				ifFalse: [self error: 'Wrong descriptor for this object'].			anObject].	self isForAssociation ifTrue: [		"We just rewrite as self value = x"		^((anExpression get: #value) get: aSymbol withArguments: (Array with:  value)) rewriteEquality].	expression := nil.	pkMappings := self primaryKeyMappings.	(pkMappings isEmpty ifTrue: [self mappings] ifFalse: [pkMappings])		do:			[:each | 			| clause |			clause := each				expressionFor: value				basedOn: anExpression				relation: aSymbol.			expression := aSymbol = #&lt;&gt; ifTrue: [clause OR: expression] ifFalse: [clause AND: expression]].	^expression.</body><body package="GlorpMappings" selector="primaryKeyFor:">primaryKeyFor: anObject	"Find the primary key for anObject. If it's a single field, just return a single value. Otherwise, return a collection. Caller is expected to know what to expect."	| fields |	anObject class == self describedClass		ifFalse: [self error: 'Wrong descriptor for this object'].	fields := self primaryTable primaryKeyFields.	^fields size = 1		ifTrue: [self valueOfField: (fields at: 1) fromObject: anObject]		ifFalse:			[fields collect: [:each | self valueOfField: each fromObject: anObject]].</body><body package="GlorpMappings" selector="primaryKeyMappings">primaryKeyMappings	"Return things that map to our primary key fields. Prefer direct mappings"	| fields pkMappings |	fields := self primaryTable primaryKeyFields.	pkMappings := OrderedCollection new: fields size.	fields do: [:each |  | mapping |		mapping := self directMappingForField: each.		mapping isNil ifTrue: [mapping := self mappingForField: each].		mapping isNil ifFalse: [pkMappings add: mapping]].	^pkMappings.</body><body package="GlorpMappings" selector="readBackNewRowInformationFor:in:">readBackNewRowInformationFor: anObject in: aRowMap 	anObject yourSelf class == self describedClass ifFalse: [self error: 'wrong descriptor for this object'].	mappings do: [:each | each readBackNewRowInformationFor: anObject fromRowsIn: aRowMap]</body><body package="GlorpMappings" selector="setFieldValue:in:from:">setFieldValue: each in: row from: anObject	"Try to set the value of the field, which is normally a primary key field, in the row, based on data in the object. Useful for the case where we have only a relationship mapping to the object that holds our primary key, and it is uninstantiated"	| value |	(row wrapperAt: each ifAbsent: [FieldValueWrapper new]) hasValue		ifFalse:			[value := self valueOfField: each fromObject: anObject ifNone: [^self].			"We're using this to get primary key fields. Nil is not a useful answer."			value isNil ifTrue: [^self].			row at: each put: value].</body><body package="GlorpMappings" selector="valueOfField:fromObject:">valueOfField: aField fromObject: anObject	^self valueOfField: aField fromObject: anObject ifNone: [nil].</body><body package="GlorpMappings" selector="valueOfField:fromObject:ifNone:">valueOfField: aField fromObject: anObject ifNone: aBlock	| directMapping notFound |	directMapping := self directMappingForField: aField.	directMapping isNil		ifFalse: [^directMapping valueOfField: aField fromObject: anObject].	notFound := Object new.	(self relationshipMappingsForField: aField)		do:			[:each | 			| candidate |			(each hasValueThatCanProvideField: aField from: anObject)				ifTrue: [					candidate := each valueOfField: aField fromObject: anObject ifNone: [notFound].					candidate == notFound ifFalse: [^candidate]]].	^aBlock value.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>type resolution</category><body package="GlorpMappings" selector="classesRequiringIndependentQueries">classesRequiringIndependentQueries	^ self typeResolver classesRequiringIndependentQueriesFor: self describedClass</body><body package="GlorpMappings" selector="typeMappingRoot">typeMappingRoot	^self typeResolver typeMappingRoot</body><body package="GlorpMappings" selector="typeMappingRootDescriptor">typeMappingRootDescriptor	^self typeResolver typeMappingRootDescriptor</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>printing</category><body package="GlorpMappings" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	self describedClass printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>As yet unclassified</category><body package="GlorpMappings" selector="imaginaryTableReplacements">imaginaryTableReplacements	imaginaryTableReplacements isNil ifTrue: [imaginaryTableReplacements := OrderedCollection new: 4].	^imaginaryTableReplacements.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>creating mappings</category><body package="GlorpMappings" selector="directMapping">directMapping	^self newMapping: DirectMapping.</body><body package="GlorpMappings" selector="directMappingFor:">directMappingFor: attributeName	"Create a direct mapping from the attribute of this name to the field in the table with a matching name. For convenience when there's a good correspondence between the field and instance variable names."	| field |	self tables do: [:each |		field := each fieldNamed: attributeName ifAbsent: [nil] caseSensitive: false].	field isNil ifTrue: [self error: 'Cannot find field named ', attributeName printString].	^self directMapping from: attributeName to: field.</body><body package="GlorpMappings" selector="fieldFor:">fieldFor: aFieldOrString	"We allow either a field or a string naming the field, and return the appropriate field object."	aFieldOrString isString ifFalse: [^aFieldOrString].	self tables do: [:each |		| field | 		field := each fieldNamed: aFieldOrString.		field isNil ifFalse: [^field]].	self error: 'Cannot find field ', aFieldOrString, '. Please pass in the field object'.</body><body package="GlorpMappings" selector="newMapping:">newMapping: aClass	| mapping |	mapping := aClass new.	self basicAddMapping: mapping.	^mapping.</body><body package="GlorpMappings" selector="oneToOneMapping">oneToOneMapping	^self newMapping: OneToOneMapping.</body><body package="GlorpMappings" selector="toManyMapping">toManyMapping	^self newMapping: ToManyMapping.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>deleting</category><body package="GlorpMappings" selector="createDeleteRowFor:table:in:">createDeleteRowFor: anObject table: aTable in: aRowMap	"Create records for rows that require deletion"	(self primaryKeyMappingsFor: aTable)		do: [:each | 			each first mapFromObject: anObject intoRowsIn: aRowMap].</body><body package="GlorpMappings" selector="createDeleteRowsFor:in:">createDeleteRowsFor: anObject in: aRowMap	"Create records for rows that require deletion"	|  |	anObject class == self describedClass ifFalse: [self error: 'wrong descriptor for this object'].	"If we don't map primary keys, then we're something that gets embedded, and a delete isn't necessary"	self mapsPrimaryKeys ifFalse: [^self]. 	self tables do: [:eachTable |		self createDeleteRowFor: anObject table: eachTable in: aRowMap.		aRowMap rowForTable: eachTable withKey: anObject ifPresent: [:eachRow | eachRow forDeletion: true]].	"It's possible that we might not have any direct mapping for a secondary table's primary keys, so allow the multiple table criteria to specify them if that's the only one. If they're not, then they don't do any harm"	self multipleTableJoin do: [:each |		each mapFromSource: anObject andTarget: anObject intoRowsIn: aRowMap.		each allTables do: [:eachTable |			aRowMap rowForTable: eachTable withKey: anObject ifPresent: [:eachRow | eachRow forDeletion: true]]].	self mappings do: [:each | each  createDeleteRowFor: anObject in: aRowMap].</body><body package="GlorpMappings" selector="primaryKeyMappingsFor:">primaryKeyMappingsFor: aTable	"Return our primary key mappings as a collection of mappings, one collection per primary key"	| allMappings |	allMappings := Dictionary new: aTable primaryKeyFields size.	aTable primaryKeyFields		do: [:each | 			| mappingsForField |			mappingsForField := self mappingsForFields at: each ifAbsent: [nil].			mappingsForField isNil ifFalse: [allMappings at: each put: mappingsForField]].	^allMappings.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	"Do any tests we can to make sure that this definition makes sense in this context"	| readableMappings attributeNames |	self system validateDescriptor: self.	self mappings do: [:eachMapping |		eachMapping validate].	"Validate that we have at most one readable mapping for an instance variable"	readableMappings := self mappings select: [:each | each canRead and: [each isTypeMapping not and: [each attributeName isEmpty not]]].	attributeNames := readableMappings collect: [:each | each attributeName].	(attributeNames asSet size = readableMappings size) 		ifFalse: [MultipleMappingsForInstanceVariable new					model: self describedClass;					readableMappings: readableMappings;					raiseRequest].	self typeResolver validate.</body></methods><methods><class-id>Glorp.Descriptor class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>registering</category><body package="GlorpMappings" selector="register:">register: aDescriptor	^self register: aDescriptor abstract: false</body><body package="GlorpMappings" selector="register:abstract:">register: aDescriptor abstract: abstract	self system: aDescriptor system.	self addMember: aDescriptor.	aDescriptor typeResolver: self</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>accessing</category><body package="GlorpMappings" selector="addMember:">addMember: aDescriptor	members isNil ifTrue: [ members := OrderedCollection new].	members add: aDescriptor</body><body package="GlorpMappings" selector="allTablesFor:">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses. For a non-inheritance descriptor, this is the same as tables."	self subclassResponsibility.</body><body package="GlorpMappings" selector="classesRequiringIndependentQueriesFor:">classesRequiringIndependentQueriesFor: aClass	self subclassResponsibility</body><body package="GlorpMappings" selector="describedConcreteClassFor:withBuilder:descriptor:">describedConcreteClassFor: row withBuilder: builder descriptor: aDescriptor	self subclassResponsibility</body><body package="GlorpMappings" selector="shouldUseSingleQuery">shouldUseSingleQuery	"Return true if we should attempt to combine queries for multiple subclasses in disjoint tables into one."	^false.</body><body package="GlorpMappings" selector="system">system	^system</body><body package="GlorpMappings" selector="system:">system: anObject	system := anObject</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>type resolution</category><body package="GlorpMappings" selector="fieldsForSelectStatement">fieldsForSelectStatement	"Return fields that are needed in a select statement - i.e. return all inherited fields that are part of the tables we are already selecting for this object"	^#().</body><body package="GlorpMappings" selector="typeMappingRootDescriptor">typeMappingRootDescriptor	self subclassResponsibility</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>other</category><body package="GlorpMappings" selector="describedClasses">describedClasses	^members collect: [:each | each describedClass ].</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>query setup</category><body package="GlorpMappings" selector="setUpExpressionsForQuery:">setUpExpressionsForQuery: aQuery	"A hook to let us do any modifications to the query that we need."	^self.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>testing</category><body package="GlorpMappings" selector="supportsOrderingFor:">supportsOrderingFor: aDescriptor	^true.</body><body package="GlorpMappings" selector="usesInheritance">usesInheritance	^false.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	^self.</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings" selector="concreteMembers">concreteMembers	^concreteMembers isNil 		ifTrue: [ concreteMembers := OrderedCollection new ]		ifFalse: [ concreteMembers]</body><body package="GlorpMappings" selector="rootClass">rootClass	^rootClass</body><body package="GlorpMappings" selector="rootClass:">rootClass: anObject	rootClass := anObject</body><body package="GlorpMappings" selector="rootDescriptor">rootDescriptor	^rootDescriptor isNil		ifTrue: [ rootDescriptor := self system descriptorFor: self rootClass ]		ifFalse: [ rootDescriptor ]</body><body package="GlorpMappings" selector="subclassDescriptorsBuilt">subclassDescriptorsBuilt	^subclassDescriptorsBuilt isNil		ifTrue: [ subclassDescriptorsBuilt := false ]		ifFalse: [ subclassDescriptorsBuilt ]</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>registering</category><body package="GlorpMappings" selector="register:abstract:">register: aDescriptor abstract: abstract	super register: aDescriptor abstract: abstract.	abstract ifFalse: [ self concreteMembers add: aDescriptor ]</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>other</category><body package="GlorpMappings" selector="rootDescriptor:">rootDescriptor: anObject	rootDescriptor := anObject</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>private</category><body package="GlorpMappings" selector="allDescribedConcreteClasses">allDescribedConcreteClasses	self subclassDescriptorsBuilt ifFalse: [self forceSubclassDescriptorLoads].	^self concreteMembers collect: [ :each | each describedClass ]</body><body package="GlorpMappings" selector="forceSubclassDescriptorLoads">forceSubclassDescriptorLoads	self rootClass allSubclassesDo: [ :each | self system descriptorFor: each ].	subclassDescriptorsBuilt := true</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>type resolution</category><body package="GlorpMappings" selector="typeMappingRootDescriptor">typeMappingRootDescriptor	^self rootDescriptor</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>testing</category><body package="GlorpMappings" selector="usesInheritance">usesInheritance	^true.</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	| tables sequences |	super validate.	tables := self concreteMembers collect: [:each | each primaryTable].	sequences := tables inject: #() into: [:sum :each | sum, ((each primaryKeyFields) collect: [:eachField | eachField type sequence])].	sequences asSet size &gt; 1 ifTrue: [self error: 'When using inheritance, all tables must use the same sequence. Otherwise, the primary key references will be ambiguous.'].</body></methods><methods><class-id>Glorp.FilteredTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings" selector="allTablesFor:">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses. Since all our subclasses use a single table, this is the same as for a normal descriptor."	^aDescriptor tables.</body><body package="GlorpMappings" selector="classesRequiringIndependentQueriesFor:">classesRequiringIndependentQueriesFor: aClass	^Array with: aClass</body></methods><methods><class-id>Glorp.FilteredTypeResolver</class-id> <category>type resolving</category><body package="GlorpMappings" selector="askConcreteMembersForConcreteClassFor:withBuilder:">askConcreteMembersForConcreteClassFor: row withBuilder: builder	concreteMembers do: [:each |		each describedConcreteClassFor: row withBuilder: builder].</body><body package="GlorpMappings" selector="describedConcreteClassFor:withBuilder:descriptor:">describedConcreteClassFor: row withBuilder: builder descriptor: aDescriptor	^aDescriptor typeMapping describedConcreteClassFor: row withBuilder: builder</body><body package="GlorpMappings" selector="fieldsForSelectStatement">fieldsForSelectStatement	"Return fields that are needed in a select statement - i.e. return all inherited fields that are part of the tables we are already selecting for this object, but not in the main descriptor"	| fields rootFields |	fields := OrderedCollection new.	rootFields := self rootDescriptor mappedFields asSet.	self concreteMembers do: [:each |		each == self rootDescriptor ifFalse: [			each mappedFields do: [:eachSubField |				(rootFields includes: eachSubField) ifFalse: [					fields add: eachSubField]]]].	^fields.</body><body package="GlorpMappings" selector="isAbstract:">isAbstract: aDescriptor	^aDescriptor == self rootDescriptor</body></methods><methods><class-id>Glorp.FilteredTypeResolver</class-id> <category>registering</category><body package="GlorpMappings" selector="register:abstract:">register: aDescriptor abstract: aBoolean	super register: aDescriptor abstract: aBoolean.	aBoolean		ifTrue:			[| fakeTypeMapping |			fakeTypeMapping := FilteredTypeMapping to: nil keyedBy: nil.			fakeTypeMapping attribute name: #filteredTypeResolverFilterMapping.			fakeTypeMapping readOnly: true.			aDescriptor typeMapping: fakeTypeMapping].</body><body package="GlorpMappings" selector="register:keyedBy:field:">register: aDescriptor keyedBy: aKey field: aField	self register: aDescriptor abstract: false.	aDescriptor typeMapping: (FilteredTypeMapping to: aField keyedBy: aKey).</body></methods><methods><class-id>Glorp.FilteredTypeResolver class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="forRootClass:">forRootClass: aClass	^self new		rootClass: aClass;		yourself.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="generatesOverExistingValues">generatesOverExistingValues	"Do we generate our value even if there's alread one present in the field"	^false.</body><body package="GlorpDatabaseTypes" selector="hasParameters">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^false.</body><body package="GlorpDatabaseTypes" selector="hasSequence">hasSequence	^false.</body><body package="GlorpDatabaseTypes" selector="hasWidth">hasWidth	"Return true if this type has a width attribute - basically meaning it's a string or LOB type. Note that this is different from the isVariableWidth test, which tells us if a field has fixed vs. varying width. So a CHAR field hasWidth=&gt;true, but isVariableWidth=&gt;false, while a VARCHAR field hasWidth=&gt;true isVariableWidth=&gt;false, and a NUMBER has both false."	^false.</body><body package="GlorpDatabaseTypes" selector="isGenerated">isGenerated	^false</body><body package="GlorpDatabaseTypes" selector="isIdentityColumn">isIdentityColumn	^false.</body><body package="GlorpDatabaseTypes" selector="isSerial">isSerial	"answer if this is a database-generated primary key column"	^false</body><body package="GlorpDatabaseTypes" selector="isStringType">isStringType	"Return true if the type of values this stores are strings"	^false.</body><body package="GlorpDatabaseTypes" selector="isVariable">isVariable	^false.</body><body package="GlorpDatabaseTypes" selector="isVariableWidth">isVariableWidth	"Return true if this type allows varying length data within a particular instance. e.g., this is true for a varchar, but false for a fixed size character field"	^false.</body><body package="GlorpDatabaseTypes" selector="requiresCast">requiresCast	^false.</body><body package="GlorpDatabaseTypes" selector="requiresConvertToVarbinary">requiresConvertToVarbinary	"This is a hack for testing against SQL Server"	^false.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="glorpPrintSelectSQLOn:">glorpPrintSelectSQLOn: aCommand	self printSelectSQLOn: aCommand withParameters: #().</body><body package="GlorpDatabaseTypes" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	aCommand nextPutAll: self typeString.</body><body package="GlorpDatabaseTypes" selector="platform">platform	^platform</body><body package="GlorpDatabaseTypes" selector="platform:">platform: aDatabasePlatform	platform := aDatabasePlatform.</body><body package="GlorpDatabaseTypes" selector="postWriteAssignSequenceValueFor:in:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow</body><body package="GlorpDatabaseTypes" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: aSession</body><body package="GlorpDatabaseTypes" selector="preWriteAssignSequenceValueFor:in:using:">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	aDatabaseField defaultValue isNil ifTrue: [^self].	(aDatabaseRow hasValueFor: aDatabaseField) ifTrue: [^self].	"Default values will not write if this field is constrained to a primary key generator"	(aDatabaseRow expectsToGetValueFor: aDatabaseField) ifTrue: [^self].	aDatabaseRow at: aDatabaseField put: (aDatabaseField defaultValue).</body><body package="GlorpDatabaseTypes" selector="print:on:">print: aValue on: aStream	aValue glorpPrintSQLOn: aStream.</body><body package="GlorpDatabaseTypes" selector="printCollection:on:">printCollection: aCollection on: aStream	aCollection glorpPrintSQLOn: aStream for: self.</body><body package="GlorpDatabaseTypes" selector="printNullCastOn:">printNullCastOn: aStream	"Some platforms, eg., DB2, need to cast NULL for collections, as in	SELECT ... WHERE ... IN (CAST(NULL AS type))."		| expr |	expr := FunctionExpression		for: #cast:		withArguments: (Array with: (ConstantExpression for: self))		basedOn: (ConstantExpression for: nil).	expr printSelectSQLOn: aStream withParameters: #()</body><body package="GlorpDatabaseTypes" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aCommand withParameters: aDictionary	aCommand nextPutAll: self typeString.</body><body package="GlorpDatabaseTypes" selector="typeName">typeName	"An alias that can be used to print the non-parameterized name"	^typeString.</body><body package="GlorpDatabaseTypes" selector="typeString">typeString	^typeString.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	self subclassResponsibility.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="precision:">precision: anInteger	^self error: ((self class name asString), ' is not a variable precision type.')</body><body package="GlorpDatabaseTypes" selector="queryType">queryType	"If we can't pass this type in as an argument to a query (e.g. a blob) then return a type we can use instead"	^self.</body><body package="GlorpDatabaseTypes" selector="scale:">scale: anInteger	^self error: ((self class name asString), ' is not a variable scale type.')</body><body package="GlorpDatabaseTypes" selector="selector">selector	^selector</body><body package="GlorpDatabaseTypes" selector="selector:">selector: aSymbol	selector := aSymbol</body><body package="GlorpDatabaseTypes" selector="sequence">sequence	^nil</body><body package="GlorpDatabaseTypes" selector="size:">size: anInteger	^self error: ((self class name asString), ' is not a variable sized type.')</body><body package="GlorpDatabaseTypes" selector="typeString:">typeString: aString	typeString := aString</body><body package="GlorpDatabaseTypes" selector="underlyingType">underlyingType	^self.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize</body><body package="GlorpDatabaseTypes" selector="initializeForField:in:">initializeForField: aDatabaseField in: aDescriptorSystem</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	^self platform nullConverter.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	"Return the Smalltalk type which most commonly corresponds to our database type. By default, Object if we don't have any more specific information."	^Object.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes" selector="=">= aType	^self basicEquals: aType.</body><body package="GlorpDatabaseTypes" selector="basicEquals:">basicEquals: aType	self class == aType class ifFalse: [^false].	self platform == aType platform ifFalse: [^false].	self typeString = aType typeString ifFalse: [^false].	^true.</body><body package="GlorpDatabaseTypes" selector="hash">hash	^self platform hash bitXor: self typeString hash</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>instance creation</category><body package="GlorpDatabaseTypes" selector="instance">instance	^super new</body><body package="GlorpDatabaseTypes" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>printing</category><body package="GlorpDatabaseTypes" selector="padToThreeDigits:">padToThreeDigits: anInteger	| string |	string := anInteger truncated printString.	string size = 3 ifTrue: [^string].	string size = 2 ifTrue: [^'0', string].	string size = 1 ifTrue: [^'00', string].</body><body package="GlorpDatabaseTypes" selector="padToTwoDigits:">padToTwoDigits: anInteger	| string |	string := anInteger truncated printString.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>conversion-times</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	^self platform converterNamed: #time.</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="print:on:">print: aValue on: aStream	aStream nextPutAll: (self platform printTime: aValue for: self).</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Time.</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Time.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="canBind:to:">canBind: aValue to: aType	(Dialect unbindableClassNames includes: aValue class name) ifTrue: [^false].	^true.</body><body package="GlorpDatabase" selector="canUseInWhereClause:type:">canUseInWhereClause: aValue type: aType	(Dialect isFloatingPoint: aValue) ifTrue: [^false].	^true.</body><body package="GlorpDatabase" selector="isAccessPlatform">isAccessPlatform	^false</body><body package="GlorpDatabase" selector="isDB2Platform">isDB2Platform	^false</body><body package="GlorpDatabase" selector="isMySQLPlatform">isMySQLPlatform	^false.</body><body package="GlorpDatabase" selector="isODBCPlatform">isODBCPlatform	^false</body><body package="GlorpDatabase" selector="isOcelotPlatform">isOcelotPlatform	^false</body><body package="GlorpDatabase" selector="isOraclePlatform">isOraclePlatform	^false</body><body package="GlorpDatabase" selector="isPostgreSQLPlatform">isPostgreSQLPlatform	^false</body><body package="GlorpDatabase" selector="isSQLServerPlatform">isSQLServerPlatform	^false</body><body package="GlorpDatabase" selector="isSQLite3Platform">isSQLite3Platform	^false</body><body package="GlorpDatabase" selector="maximumQueryValueSize">maximumQueryValueSize	"If there's a limit on how big a bound input parameter can be for a query, return it here. By default, no maximum. "	^536870911 "VisualWorks SmallInteger maxVal. Lacking infinity, this will do as a default."</body><body package="GlorpDatabase" selector="measuresStringFieldWidthsInBytes">measuresStringFieldWidthsInBytes	"Return true if we measure the width of a string in bytes rather than characters. So, a 255-character field can hold 255 bytes worth of string, not 255 characters. This is important with encodings"	^false.</body><body package="GlorpDatabase" selector="requiresCastsForNullsInUnions">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^false.</body><body package="GlorpDatabase" selector="reusePreparedStatements">reusePreparedStatements	"The ordinary choice is to initialize the accessor to reuse statements whenever binding is being used."	^true</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^false.</body><body package="GlorpDatabase" selector="supportsAliasInCompoundQuery">supportsAliasInCompoundQuery	"Return true if, when we have a subselect, we can (and/or must) alias the result with a table name. Access doesn't like the table name"	^true.</body><body package="GlorpDatabase" selector="supportsAlterTableForConstraints">supportsAlterTableForConstraints	^true</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"Return true if this platform supports binding parameters rather than printing them as strings into the SQL statement"	^false.</body><body package="GlorpDatabase" selector="supportsCaseInsensitiveLike">supportsCaseInsensitiveLike	^false.</body><body package="GlorpDatabase" selector="supportsDecimalsOnAllNumerics">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^true.</body><body package="GlorpDatabase" selector="supportsGroupWritingFor:">supportsGroupWritingFor: aCommand	"Return true if this platform can do array binding or an equivalent for this command"	^false.</body><body package="GlorpDatabase" selector="supportsInformationSchema">supportsInformationSchema	^true.</body><body package="GlorpDatabase" selector="supportsIntersect">supportsIntersect	"Do we support the INTERSECT or MINUS operations."	^true.</body><body package="GlorpDatabase" selector="supportsLimit">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^false.</body><body package="GlorpDatabase" selector="supportsMultipleOpenCursors">supportsMultipleOpenCursors	"Can this database support multiple open cursors at once"	^true.</body><body package="GlorpDatabase" selector="supportsOffset">supportsOffset	"Do we support anything analogous to the postgresql OFFSET, skipping the first N rows"	^false.</body><body package="GlorpDatabase" selector="supportsRowCount">supportsRowCount	^true.</body><body package="GlorpDatabase" selector="supportsSchemaForLogin">supportsSchemaForLogin	^true</body><body package="GlorpDatabase" selector="supportsSchemas">supportsSchemas	"Return true if this platform supports schemas. Access and SQLite 3 do not."	^true</body><body package="GlorpDatabase" selector="supportsStringQueryOnBlobs">supportsStringQueryOnBlobs	^true.</body><body package="GlorpDatabase" selector="supportsTableOwners">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^false</body><body package="GlorpDatabase" selector="useBinding">useBinding	"Return true if we should use binding"	self supportsBinding ifFalse: [^false].	useBinding isNil ifTrue: [useBinding := self class useBindingIfSupported].	^useBinding</body><body package="GlorpDatabase" selector="useBinding:">useBinding: aBoolean	useBinding := aBoolean.</body><body package="GlorpDatabase" selector="useMicrosoftOuterJoins">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins"	^false.</body><body package="GlorpDatabase" selector="useOracleOuterJoins">useOracleOuterJoins	"Return true if we use the old Oracle x = y (+) syntax for outer joins"	^false.</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	"Return true if we use array binding for grouped writes rather than printing the sql multiple times. Only applies if we support grouped writes"	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="usesIdentityColumns">usesIdentityColumns	^false.</body><body package="GlorpDatabase" selector="usesInformationSchema">usesInformationSchema	^false</body><body package="GlorpDatabase" selector="usesPrimaryKeyUniqueConstraintNames">usesPrimaryKeyUniqueConstraintNames	"When dropping/creating primary key constraints, do they have distinguished names."	^true.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="blob">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new].</body><body package="GlorpDatabase" selector="boolean">boolean	"By default, we represent booleans as small integers."	^self smallint.</body><body package="GlorpDatabase" selector="char">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new].</body><body package="GlorpDatabase" selector="char:">char: anInteger	^self char width: anInteger.</body><body package="GlorpDatabase" selector="character">character	^self char</body><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new].</body><body package="GlorpDatabase" selector="date">date	"Return the type we use to represent dates. By default, we use the same type as for timestamps."	^self timestamp.</body><body package="GlorpDatabase" selector="datetime">datetime	^self timestamp</body><body package="GlorpDatabase" selector="double">double	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="generatorFor:withBlock:">generatorFor: aType withBlock: aBlock	"Don't cache this, because we want to return different instances depending on aType"	^VersionType underlyingType: aType generator: (AdHocVersionGenerator block: aBlock).</body><body package="GlorpDatabase" selector="inMemorySequence">inMemorySequence	^self typeNamed: #inMemorySequence ifAbsentPut: [		GlorpInMemorySequenceDatabaseType representedBy: self int4].</body><body package="GlorpDatabase" selector="int">int	^self integer.</body><body package="GlorpDatabase" selector="int2">int2	^self subclassResponsibility</body><body package="GlorpDatabase" selector="int4">int4	^self subclassResponsibility</body><body package="GlorpDatabase" selector="int8">int8	^self subclassResponsibility</body><body package="GlorpDatabase" selector="integer">integer	^self typeNamed: #integer ifAbsentPut: [GlorpIntegerType new].</body><body package="GlorpDatabase" selector="number">number	^self typeNamed: #number ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase" selector="numeric">numeric	^self number.</body><body package="GlorpDatabase" selector="nvarchar">nvarchar	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="raw">raw	^self blob.</body><body package="GlorpDatabase" selector="sequence">sequence	^self subclassResponsibility</body><body package="GlorpDatabase" selector="serial">serial	self subclassResponsibility.</body><body package="GlorpDatabase" selector="smallint">smallint	^self typeNamed: #smallint ifAbsentPut: [GlorpSmallIntType new].</body><body package="GlorpDatabase" selector="text">text	^self clob.</body><body package="GlorpDatabase" selector="time">time	self subclassResponsibility.</body><body package="GlorpDatabase" selector="timestamp">timestamp	self subclassResponsibility.</body><body package="GlorpDatabase" selector="typeNamed:ifAbsentPut:">typeNamed: aSymbol ifAbsentPut: aBlock	| type |	type := self types at: aSymbol ifAbsentPut: [		| newType |		newType := aBlock value.		newType platform: self.		newType selector: aSymbol].	type hasParameters ifTrue: [type := type copy].	^type.</body><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:">typeWithDatabaseName: aString characterWidth: aNumber	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	| baseType matchingTypes simpleTypes |	matchingTypes := self typesWithValues values asArray select: [:each | each typeName asLowercase = aString asLowercase].	matchingTypes isEmpty ifTrue: [		Transcript cr; show: 'Cannot find type ', aString, ' using integer instead.'. matchingTypes := Array with: self integer].	"We may get generated and non-generated both matching, e.g. inMemorySequence and int. Prefer the non-generated."	simpleTypes := matchingTypes reject: [:each | each isGenerated].	baseType := simpleTypes isEmpty ifTrue: [matchingTypes first] ifFalse: [simpleTypes first].	^baseType hasWidth ifTrue: [baseType copy width: aNumber] ifFalse: [baseType].</body><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:extraInformation:">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: anythingElse	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	^self typeWithDatabaseName: aString characterWidth: aNumber.</body><body package="GlorpDatabase" selector="types">types	types == nil ifTrue: [types := IdentityDictionary new].	^types.</body><body package="GlorpDatabase" selector="varChar">varChar	^self varchar.</body><body package="GlorpDatabase" selector="varChar:">varChar: anInt	^self varchar width: anInt.</body><body package="GlorpDatabase" selector="varbinary">varbinary	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="varbinary:">varbinary: anInteger	^self varbinary width: anInteger.</body><body package="GlorpDatabase" selector="varchar">varchar	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="varchar:">varchar: anInt	^self varchar width: anInt.</body><body package="GlorpDatabase" selector="versionFieldFor:">versionFieldFor: aType	"Don't cache this, because we want to return different instances depending on aType"	^(VersionType underlyingType: aType) generatesOverExistingValues: true; platform: self.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	self subclassResponsibility.</body><body package="GlorpDatabase" selector="batchWriteStatementTerminatorString">batchWriteStatementTerminatorString	"^&lt;String&gt; This statement return the string to be used to devide several statement during batch write ..."	^';'</body><body package="GlorpDatabase" selector="capitalWritingOfColumnName">capitalWritingOfColumnName	"^&lt;Boolean&gt; This method returns true, if the dbms wants to have column 	names written in capital letters"	^false</body><body package="GlorpDatabase" selector="capitalWritingOfCreatorName">capitalWritingOfCreatorName	"^&lt;Boolean&gt; This method returns true, if the dbms wants to have column 	names written in capital letters"	^true</body><body package="GlorpDatabase" selector="capitalWritingOfSQLCommands">capitalWritingOfSQLCommands	"^&lt;Boolean&gt;"	^true</body><body package="GlorpDatabase" selector="capitalWritingOfTableName">capitalWritingOfTableName	"^&lt;Boolean&gt;"	^true</body><body package="GlorpDatabase" selector="charactersThatNeedEscaping">charactersThatNeedEscaping	^#($' )</body><body package="GlorpDatabase" selector="columnNameSeparatorString">columnNameSeparatorString	"^&lt;String&gt; This statement return the string to be used to devide several columns ..."	^','</body><body package="GlorpDatabase" selector="deleteViewWithTableSyntax">deleteViewWithTableSyntax	^false</body><body package="GlorpDatabase" selector="endColumnAddString">endColumnAddString	"The string we use as a suffix when adding a colum"	^''.</body><body package="GlorpDatabase" selector="hasSubtransaction">hasSubtransaction	"^&lt;Boolean&gt; This method returns true, if the used dbms is able to execute multiple sql-statements	transferred via a command line transmitted from client to server - otherwise I return false"	^true</body><body package="GlorpDatabase" selector="initializeReservedWords">initializeReservedWords	reservedWords := Set new.</body><body package="GlorpDatabase" selector="maxLengthOfDatabaseName">maxLengthOfDatabaseName	"^&lt;Integer&gt;I return the max. length of a database name"	^8</body><body package="GlorpDatabase" selector="maxSQLBufferLength">maxSQLBufferLength	"^&lt;Integer&gt; I return the maximum length of a sql command stream"	^8192</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^18</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^18</body><body package="GlorpDatabase" selector="nameForPrimaryKeyConstraintsWhenDropping">nameForPrimaryKeyConstraintsWhenDropping	"Return the name we use to describe a constraint when dropping them. This is required because MySQL wants you to use 'DROP PRIMARY KEY' rather than the ANSI 'DROP CONSTRAINT'."	^'CONSTRAINT'.</body><body package="GlorpDatabase" selector="parenthesizeCommandsInCompoundQuery">parenthesizeCommandsInCompoundQuery	^true</body><body package="GlorpDatabase" selector="postfixTableNameBeforeDeleting">postfixTableNameBeforeDeleting	^false</body><body package="GlorpDatabase" selector="prefixQualifierBeforeCreatingAndDeleting">prefixQualifierBeforeCreatingAndDeleting	^true</body><body package="GlorpDatabase" selector="prefixQualifierSeparatorString">prefixQualifierSeparatorString	"^&lt;String&gt; This statement return the string to be used to separate the qualifier and the table/column name"	^'.'</body><body package="GlorpDatabase" selector="prefixTableNameBeforeDeleting">prefixTableNameBeforeDeleting	^false</body><body package="GlorpDatabase" selector="primaryKeysAreAutomaticallyUnique">primaryKeysAreAutomaticallyUnique	"Return false if, in addition to specifying something as a primary key, we must separately specify it as unique"	^false.</body><body package="GlorpDatabase" selector="requiresEscapeFor:">requiresEscapeFor: aCharacter	^self charactersThatNeedEscaping includes: aCharacter.</body><body package="GlorpDatabase" selector="requiresTransactionForTableOperations">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^true.</body><body package="GlorpDatabase" selector="reservedWords">reservedWords	reservedWords isNil ifTrue: [self initializeReservedWords].	^reservedWords.</body><body package="GlorpDatabase" selector="sqlTextCurrentServerUTCTimestamp">sqlTextCurrentServerUTCTimestamp	self subclassResponsibility</body><body package="GlorpDatabase" selector="sqlTextForBeginTransaction">sqlTextForBeginTransaction	"comment"	^'BEGIN'</body><body package="GlorpDatabase" selector="sqlTextForDEFAULT:">sqlTextForDEFAULT: defaultValue	"^&lt;String&gt;. Answer the column DEFAULT clause as a string with the given value.	This is used in CREATE TABLE statements as part of each column specification."		| strm |	^defaultValue		ifNotNil:			[strm := String new writeStream.			strm nextPutAll: 'DEFAULT '.			defaultValue glorpPrintSQLOn: strm.			strm contents]		ifNil: ['']</body><body package="GlorpDatabase" selector="sqlTextForNOTNULLAttributeConstraint">sqlTextForNOTNULLAttributeConstraint	"^&lt;String&gt;"	^'NOT NULL'</body><body package="GlorpDatabase" selector="sqlTextForNOTNULLWithDefaultAttributeConstraint">sqlTextForNOTNULLWithDefaultAttributeConstraint	"^&lt;String&gt;"	^'NOT NULL WITH DEFAULT'</body><body package="GlorpDatabase" selector="sqlTextForNOTUNIQUEAttributeConstraint">sqlTextForNOTUNIQUEAttributeConstraint	^''.</body><body package="GlorpDatabase" selector="sqlTextForNULLAttributeConstraint">sqlTextForNULLAttributeConstraint	"^&lt;String&gt;"	^'NULL'</body><body package="GlorpDatabase" selector="sqlTextForUNIQUEAttributeConstraint">sqlTextForUNIQUEAttributeConstraint	^'UNIQUE'.</body><body package="GlorpDatabase" selector="sqlWildcardForMultipleCharacters">sqlWildcardForMultipleCharacters	"^&lt;String&gt; This method returns the used wildcard string for multiple characters"		^'%'</body><body package="GlorpDatabase" selector="sqlWildcardForSingleCharacter">sqlWildcardForSingleCharacter	"^&lt;String&gt; This method returns the used wildcard string for single characters"		^'_'</body><body package="GlorpDatabase" selector="startColumnAddString">startColumnAddString	"The string we use as a prefix when adding a colum"	^' COLUMN '.</body><body package="GlorpDatabase" selector="supportsAuthentication">supportsAuthentication	^true</body><body package="GlorpDatabase" selector="supportsConstraints">supportsConstraints	"Return true if we support integrity constraints. That is, foreign key, primary key or unique constraints."	^true.</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	self subclassResponsibility.</body><body package="GlorpDatabase" selector="supportsVariableSizedNumerics">supportsVariableSizedNumerics	"Return true if this platform can support numbers with a varying size and number of decimal places. Access, notably, doesn't seem to be able to"	^true.</body><body package="GlorpDatabase" selector="usesNullForEmptyStrings">usesNullForEmptyStrings	"Return true if this database is likely to use nil as an empty string value"	^false.</body><body package="GlorpDatabase" selector="usesNullForFalse">usesNullForFalse	"Return true if this database is likely to use nil as an empty string value"	^false.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase" selector="booleanToBooleanConverter">booleanToBooleanConverter	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToDBBoolean:for:		fromDbToSt: #convertDBBooleanToBoolean:for:.</body><body package="GlorpDatabase" selector="booleanToIntegerConverter">booleanToIntegerConverter	^DelegatingDatabaseConverter		named: #booleanToInteger		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertIntegerToBoolean:for:.</body><body package="GlorpDatabase" selector="booleanToStringTFConverter">booleanToStringTFConverter	^DelegatingDatabaseConverter		named: #booleanToString		hostedBy: self		fromStToDb: #convertBooleanToTF:for:		fromDbToSt: #convertTFToBoolean:for:.</body><body package="GlorpDatabase" selector="booleanToStringYNConverter">booleanToStringYNConverter	^DelegatingDatabaseConverter		named: #booleanToString		hostedBy: self		fromStToDb: #convertBooleanToYN:for:		fromDbToSt: #convertYNToBoolean:for:.</body><body package="GlorpDatabase" selector="booleanToStringYesNoConverter">booleanToStringYesNoConverter	^DelegatingDatabaseConverter		named: #booleanToString		hostedBy: self		fromStToDb: #convertBooleanToYesNo:for:		fromDbToSt: #convertYesNoToBoolean:for:.</body><body package="GlorpDatabase" selector="convertBooleanToDBBoolean:for:">convertBooleanToDBBoolean: aBoolean for: aType	(self usesNullForFalse and: [aBoolean isNil]) ifTrue: [^false].	^aBoolean.</body><body package="GlorpDatabase" selector="convertBooleanToInteger:for:">convertBooleanToInteger: aBoolean for: aType	aBoolean isNil ifTrue: [^nil].	^aBoolean ifTrue: [1] ifFalse: [0].</body><body package="GlorpDatabase" selector="convertBooleanToTF:for:">convertBooleanToTF: aBoolean for: aType	aBoolean isNil ifTrue: [^aBoolean].	^aBoolean ifTrue: ['T'] ifFalse: ['F'].</body><body package="GlorpDatabase" selector="convertBooleanToYN:for:">convertBooleanToYN: aBoolean for: aType	aBoolean isNil ifTrue: [^aBoolean].	^aBoolean ifTrue: ['Y'] ifFalse: ['N'].</body><body package="GlorpDatabase" selector="convertBooleanToYesNo:for:">convertBooleanToYesNo: aBoolean for: aType	aBoolean isNil ifTrue: [^aBoolean].	^aBoolean ifTrue: ['YES'] ifFalse: ['NO'].</body><body package="GlorpDatabase" selector="convertDBBooleanToBoolean:for:">convertDBBooleanToBoolean: aBoolean for: aType	^aBoolean.</body><body package="GlorpDatabase" selector="convertIntegerToBoolean:for:">convertIntegerToBoolean: anInteger for: aType	anInteger isNil ifTrue: [^anInteger].	anInteger = 1 ifTrue: [^true].	anInteger = 0 ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase" selector="convertTFToBoolean:for:">convertTFToBoolean: aString for: aType	aString isNil ifTrue: [^aString].	aString = 'T' ifTrue: [^true].	aString = 'F' ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase" selector="convertYNToBoolean:for:">convertYNToBoolean: aString for: aType	aString isNil ifTrue: [^aString].	aString = 'Y' ifTrue: [^true].	aString = 'N' ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase" selector="convertYesNoToBoolean:for:">convertYesNoToBoolean: aString for: aType	aString isNil ifTrue: [^aString].	aString asUppercase = 'YES' ifTrue: [^true].	aString asUppercase = 'NO' ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase" selector="printBoolean:for:">printBoolean: aBoolean for: aType	"If the platform is MS SQL Server, a boolean object in a SELECT needs to be converted to  BIT type, since T, Y, or true make SQLServer complain. "	| stream |	stream := WriteStream on: String new.	aBoolean glorpPrintSQLOn: stream.	^stream contents.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="asTimestamp:for:">asTimestamp: anObject for: aType	anObject isNil ifTrue: [^nil].	^anObject class = Time		ifTrue: [Dialect newTimestampFromDate: Date today time: anObject]		ifFalse: [anObject asTimestamp].</body><body package="GlorpDatabase" selector="dateConverter">dateConverter	^DelegatingDatabaseConverter		named: #date		hostedBy: self		fromStToDb: #toDate:for:		fromDbToSt: #readDate:for:.	"#printDate:for:"</body><body package="GlorpDatabase" selector="printDate:isoFormatOn:">printDate: aTimestamp isoFormatOn: stream	"Print the date as yyyy-mm-dd"	| monthNumber dayOfMonth |	aTimestamp isNil ifTrue: [^'NULL'].	aTimestamp year printOn: stream.	stream nextPut: $-.	monthNumber := aTimestamp monthIndex.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: monthNumber).	stream nextPut: $-.	dayOfMonth := aTimestamp dayOfMonth.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: dayOfMonth).</body><body package="GlorpDatabase" selector="printTime:isoFormatOn:">printTime: aTime isoFormatOn: aStream 	self		printTime: aTime		isoFormatOn: aStream		milliseconds: self supportsMillisecondsInTimes.	^self</body><body package="GlorpDatabase" selector="printTime:isoFormatOn:milliseconds:">printTime: aTimestamp isoFormatOn: stream milliseconds: aBoolean	"Print the time as hh:mm:ss.mmm"	| ms |	aTimestamp isNil ifTrue: [^nil].	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: aTimestamp hours).	stream nextPut: $:.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: aTimestamp minutes).	stream nextPut: $:.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: aTimestamp seconds).	aBoolean ifFalse: [^self].	ms := aTimestamp milliseconds.	ms = 0 ifTrue: [^self].	stream nextPut: $..	stream nextPutAll: (GlorpDatabaseType padToThreeDigits: ms).</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: aStream for: aType	aTimestamp isNil ifTrue: [aTimestamp glorpPrintSQLOn: aStream. ^self].	aStream nextPut: $'; nextPutAll: aTimestamp printString; nextPut: $'.</body><body package="GlorpDatabase" selector="readDate:for:">readDate: anObject for: aType	"format '2003-03-13"	anObject isNil ifTrue: [^nil].	anObject class == Date ifTrue: [^anObject].	anObject isString ifTrue: [		^self readDateFromStream: (ReadStream on: anObject) for: aType].	^anObject asDate.</body><body package="GlorpDatabase" selector="readDateFromStream:for:">readDateFromStream: aStream for: aType	"Seems like we get to do this ourselves, in a lowest common denominator kind of way. Translate into GMT if we've got a timezone."	"assumes ISO format.	self readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self readTimestamp: '2003-03-03 19:29:28.337-05' for: nil"	|  years months days |	years := (aStream upTo: $-) asNumber.	months := (aStream upTo: $-) asNumber.	days := (aStream upTo: $ ) asNumber.	^Dialect newDateWithYears: years months: months days: days.</body><body package="GlorpDatabase" selector="readTime:for:">readTime: anObject for: aType	"format 15:29:28.337-05  (timezone optional)"	anObject isNil ifTrue: [^nil].	anObject class == Time ifTrue: [^anObject].	anObject isString ifTrue: [		^self readTimeFromStream: (ReadStream on: anObject) for: aType].	^anObject asTime.</body><body package="GlorpDatabase" selector="readTimeFromStream:for:">readTimeFromStream: aStream for: aType	"Seems like we get to do this ourselves, in a lowest common denominator kind of way. Ignore timezones right now"	"assumes ISO format.	self readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self readTimestamp: '2003-03-03 19:29:28.337-05' for: nil"	| hours minutes seconds milliseconds timeZoneOffset millisecondAccumulator |	hours := (aStream upTo: $:) asNumber.	minutes := (aStream upTo: $:) asNumber.	seconds := (aStream next: 2) asNumber.	(aStream peek = $.) 		ifTrue: [			aStream next.			millisecondAccumulator := WriteStream on: String new.			[aStream atEnd not and: [aStream peek isDigit]] whileTrue: [				millisecondAccumulator nextPut: aStream next].			milliseconds := millisecondAccumulator contents asNumber]		ifFalse: [milliseconds := 0].	timeZoneOffset := aStream upToEnd asNumber.	^Dialect newTimeWithHours: hours minutes: minutes seconds: seconds milliseconds: milliseconds.	"^Dialect addSeconds: (timeZoneOffset * -1* 60 * 60) to: aTime."</body><body package="GlorpDatabase" selector="readTimestamp:for:">readTimestamp: anObject for: aType	"Seems like we get to do this ourselves, in a lowest common denominator kind of way. Translate into GMT if we've got a timezone."	"assumes ISO format.	self readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self readTimestamp: '2003-03-03 19:29:28.337-05' for: nil"	anObject isNil ifTrue: [^nil].	anObject class == Dialect timestampClass ifTrue: [^anObject].	anObject isString		ifTrue:			[| stream |			stream := ReadStream on: anObject.			^self readTimestampFromStream: stream for: aType].	^anObject asTimestamp.</body><body package="GlorpDatabase" selector="readTimestampFromStream:for:">readTimestampFromStream: aStream for: aType	| years months days hours minutes seconds millisecondAccumulator milliseconds timeZoneOffset |	years := (aStream upTo: $-) asNumber.	months := (aStream upTo: $-) asNumber.	days := (aStream upTo: $ ) asNumber.	hours := (aStream upTo: $:) asNumber.	minutes := (aStream upTo: $:) asNumber.	seconds := (aStream next: 2) asNumber.	(aStream peek = $.) 		ifTrue: [			aStream next.			millisecondAccumulator := WriteStream on: String new.			[aStream atEnd not and: [aStream peek isDigit]] whileTrue: [				millisecondAccumulator nextPut: aStream next].			milliseconds := millisecondAccumulator contents asNumber]		ifFalse: [milliseconds := 0].	timeZoneOffset := aStream upToEnd asNumber.	timeZoneOffset isNil ifTrue: [timeZoneOffset := 0].	timeZoneOffset := timeZoneOffset * 60 * 60.	^Dialect 		newTimestampWithYears: years		months: months		days: days		hours: hours		minutes: minutes		seconds: seconds		milliseconds: milliseconds		offset:timeZoneOffset.</body><body package="GlorpDatabase" selector="timeConverter">timeConverter	^DelegatingDatabaseConverter		named: #time		hostedBy: self		fromStToDb: #toTime:for:		fromDbToSt: #readTime:for:.	"#printTime:for:"</body><body package="GlorpDatabase" selector="timestampConverter">timestampConverter	^DelegatingDatabaseConverter		named: #timestamp		hostedBy: self		fromStToDb: #toTimestamp:for:		fromDbToSt: #readTimestamp:for:.	"#printTimestamp:for:"</body><body package="GlorpDatabase" selector="timestampToDateConverter">timestampToDateConverter	^DelegatingDatabaseConverter		named: #timestampToDate		hostedBy: self		fromStToDb: #toTimestamp:for:		fromDbToSt: #readDate:for:.</body><body package="GlorpDatabase" selector="toDate:for:">toDate: anObject for: aType	anObject isNil ifTrue: [^nil].	anObject class = Date ifTrue: [^anObject].	^anObject asDate.</body><body package="GlorpDatabase" selector="toTime:for:">toTime: anObject for: aType	anObject isNil ifTrue: [^nil].	anObject class = Time ifTrue: [^anObject].	^anObject asTime.</body><body package="GlorpDatabase" selector="toTimestamp:for:">toTimestamp: anObject for: aType		anObject isNil ifTrue: [^nil].	anObject class = Dialect timestampClass ifTrue: [^anObject].	^anObject asTimestamp.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseIdentitySequenceClass">databaseIdentitySequenceClass	"This method applies only to classes that have both types--database sequences and identity columns.	Currently, only DB2 has both types. The sequence is prefered, and the identity type has minimal support."	self databaseSequenceClass</body><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	self subclassResponsibility.</body><body package="GlorpDatabase" selector="newDatabaseIdentitySequenceNamed:">newDatabaseIdentitySequenceNamed: aString	"Return an identity sequence, with the given name. This method is useful for platforms	which provide regular sequence objects as well as identity column objects. Glorp uses	sequences when they are available, but pre-existing DB2 tables may contain identity	columns, so we need to be able to recognize them."	^self databaseIdentitySequenceClass named: aString</body><body package="GlorpDatabase" selector="newDatabaseSequenceNamed:">newDatabaseSequenceNamed: aString	"Return a sequence of the type we use, with the given name"	^self databaseSequenceClass named: aString.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>type converters</category><body package="GlorpDatabase" selector="converterNamed:">converterNamed: aSymbol	^self converters at: aSymbol ifAbsentPut: [		| converter |		converter := self perform: (aSymbol, 'Converter') asSymbol.		converter name: aSymbol]</body><body package="GlorpDatabase" selector="converters">converters	converters isNil ifTrue: [converters := IdentityDictionary new].	^converters.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-numbers</category><body package="GlorpDatabase" selector="convertToDouble:for:">convertToDouble: aNumber for: type 	aNumber isNil ifTrue: [^nil].	^Dialect coerceToDoublePrecisionFloat: aNumber</body><body package="GlorpDatabase" selector="convertToFloat:for:">convertToFloat: aNumber for: aType 	aNumber isNil ifTrue: [^nil].	^aNumber asFloat.</body><body package="GlorpDatabase" selector="convertToInteger:for:">convertToInteger: aNumber for: aType 	^aNumber isNil ifTrue: [aNumber] ifFalse: [aNumber asNumber asInteger].</body><body package="GlorpDatabase" selector="convertToNumber:for:">convertToNumber: aNumber for: aType	"Convert to an arbitrary numeric type. Make sure our precision matches. *Hate* floating point"	| exponent result |	aNumber isNil ifTrue: [^nil].	aType precision isNil ifTrue: [^aNumber].	(Dialect doesPrecisionOf: aNumber equal: aType precision) ifTrue: [^aNumber].	exponent := Dialect		coerceToDoublePrecisionFloat: (10 raisedToInteger: aType precision).	result := (aNumber * exponent) rounded / exponent.	^aNumber isInteger ifTrue: [result rounded] ifFalse: [result].</body><body package="GlorpDatabase" selector="numberToDoubleConverter">numberToDoubleConverter	^DelegatingDatabaseConverter		named: #numberToDouble		hostedBy: self		fromStToDb: #convertToDouble:for:		fromDbToSt: #convertToDouble:for:.</body><body package="GlorpDatabase" selector="numberToFloatConverter">numberToFloatConverter	^DelegatingDatabaseConverter		named: #numberToFloat		hostedBy: self		fromStToDb: #convertToFloat:for:		fromDbToSt: #convertToFloat:for:.</body><body package="GlorpDatabase" selector="numberToIntegerConverter">numberToIntegerConverter	^DelegatingDatabaseConverter		named: #numberToInteger		hostedBy: self		fromStToDb: #convertToInteger:for:		fromDbToSt: #convertToInteger:for:.</body><body package="GlorpDatabase" selector="numberToNumberConverter">numberToNumberConverter	^DelegatingDatabaseConverter		named: #numberToNumber		hostedBy: self		fromStToDb: #convertToNumber:for:		fromDbToSt: #convertToNumber:for:.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-null</category><body package="GlorpDatabase" selector="nullConversion:for:">nullConversion: anObject for: aType	^anObject.</body><body package="GlorpDatabase" selector="nullConverter">nullConverter	^NullConverter new		name: #null.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>general services</category><body package="GlorpDatabase" selector="predefinedKeywords">predefinedKeywords	"		^&lt;OrderdCollection of: String&gt; This method returns a list of preserved keyword, which should		not be used in database-, table or column names or any othe names in the platform system	"	^OrderedCollection new</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="byteArrayToString:for:">byteArrayToString: aByteArray for: aType	^aByteArray isNil ifTrue: [nil] ifFalse: [Dialect convert: aByteArray toStringWithEncoding: self characterEncoding].</body><body package="GlorpDatabase" selector="byteArrayToStringConverter">byteArrayToStringConverter	^DelegatingDatabaseConverter		named: #byteArrayToString		hostedBy: self		fromStToDb: #convertStringToByteArray:for:		fromDbToSt: #convertByteArrayToString:for:.</body><body package="GlorpDatabase" selector="convertByteArrayToSQLString:for:">convertByteArrayToSQLString: aByteArray for: aType	"This is a slightly misleading name. Really what we want is conversion to a Blob-type of field. So if it's a bytearray, we can just let the driver take care of that conversion, but if we're given a string, we should convert it."	^aByteArray isString		ifTrue:			[Dialect				convert: aByteArray				toByteArrayWithEncoding: self characterEncoding]		ifFalse: [aByteArray].</body><body package="GlorpDatabase" selector="convertByteArrayToString:for:">convertByteArrayToString: aByteArray for: aType	^aByteArray asString.</body><body package="GlorpDatabase" selector="convertStringToByteArray:for:">convertStringToByteArray: aString for: aType	^aString asByteArray.</body><body package="GlorpDatabase" selector="escapeFor:">escapeFor: aCharacter	aCharacter = $' ifTrue: [^''''''].	^String with: $\ with: aCharacter.</body><body package="GlorpDatabase" selector="integerToString:for:">integerToString: anInteger for: aType	anInteger isNil ifTrue: [^nil].	^self padString: anInteger printString for: aType.</body><body package="GlorpDatabase" selector="integerToStringConverter">integerToStringConverter	^DelegatingDatabaseConverter		named: #integerToString		hostedBy: self		fromStToDb: #integerToString:for:		fromDbToSt: #stringToInteger:for:.</body><body package="GlorpDatabase" selector="padString:for:">padString: aString for: aType 	| padding trimmed |	aString isNil ifTrue: [^nil].	aString isString ifFalse: [self error: 'Invalid data type'].	(self usesNullForEmptyStrings and: [aString isEmpty]) ifTrue: [^nil].	trimmed := self trimString: aString for: aType.					(aType isVariableWidth or: [trimmed size = aType width]) ifTrue: [^trimmed].	padding := String new: aType width - aString size.	padding atAllPut: self paddingCharacter.	^aString , padding</body><body package="GlorpDatabase" selector="paddingCharacter">paddingCharacter	^1 asCharacter.</body><body package="GlorpDatabase" selector="printBlob:on:for:">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: 'X'''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPut: $'.</body><body package="GlorpDatabase" selector="stringToByteArray:for:">stringToByteArray: aString for: aType	| string |	string := self unpadString: aString for: aType.	^string isNil ifTrue: [nil] ifFalse: [Dialect convert: string toByteArrayWithEncoding: self characterEncoding].</body><body package="GlorpDatabase" selector="stringToInteger:for:">stringToInteger: aString for: aType	| string |	string := self unpadString: aString for: aType.	^string isNil ifTrue: [nil] ifFalse: [string asNumber truncated].</body><body package="GlorpDatabase" selector="stringToStringConverter">stringToStringConverter	^DelegatingDatabaseConverter		named: #stringToString		hostedBy: self		fromStToDb: #padString:for:		fromDbToSt: #unpadString:for:.</body><body package="GlorpDatabase" selector="stringToSymbol:for:">stringToSymbol: aString for: aType	| string |	string := self unpadString: aString for: aType.	^string isNil ifTrue: [nil] ifFalse: [string asSymbol].</body><body package="GlorpDatabase" selector="symbolToString:for:">symbolToString: aSymbol for: aType	aSymbol isNil ifTrue: [^nil].	^self padString: aSymbol asString for: aType.</body><body package="GlorpDatabase" selector="symbolToStringConverter">symbolToStringConverter	^DelegatingDatabaseConverter		named: #symbolToString		hostedBy: self		fromStToDb: #symbolToString:for:		fromDbToSt: #stringToSymbol:for:.</body><body package="GlorpDatabase" selector="toGlorpType:fromString:">toGlorpType: aGlorpType fromString: aString	"Return a Smalltalk instance of the type indicated by aGlorpType."		| aClass |	^aString		ifNotNil:			[aClass := aGlorpType impliedSmalltalkType.			aClass readFrom: aString readStream]</body><body package="GlorpDatabase" selector="trimString:for:">trimString: aString for: aType 	| trimmedString length excess |	aType width isNil ifTrue: [^aString].	self measuresStringFieldWidthsInBytes ifFalse: [		^aString size &gt; aType width ifTrue: [aString copyFrom: 1 to: aType width] ifFalse: [aString]].	"If our characters are less than half the number of bytes it can hold, assume it will fit and don't try to do this"	(aString size &lt; (aType width // 2)) ifTrue: [^aString].	"If we're doing defaults that don't map characters to multi-bytes, don't do this"	(#(ascii default) includes: self characterEncoding) ifTrue: [		^aString size &gt; aType width ifTrue: [aString copyFrom: 1 to: aType width] ifFalse: [aString]].	trimmedString := aString.	[length := (Dialect convert: trimmedString toByteArrayWithEncoding: self characterEncoding) size.	excess := length - aType width.	excess &gt; 0 		"Try to be careful and trim as little as possible, while still keeping the number of steps reasonable for large excesses"		ifTrue: [trimmedString := trimmedString copyFrom: 1 to: trimmedString size - ((excess // 2) max: 1)]		ifFalse: [^trimmedString].	true] whileTrue.</body><body package="GlorpDatabase" selector="unpadString:for:">unpadString: aString for: aType	aString isNil ifTrue: [^nil].	^aType isVariableWidth 		ifTrue: [aString]		ifFalse: [(ReadStream on: aString) upTo: 1 asCharacter].</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>exdi specific</category><body package="GlorpDatabase" selector="exdiTypeForDates">exdiTypeForDates	^#Date.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>database-specific</category><body package="GlorpDatabase" selector="compoundOperationFor:">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol"	^aSymbol.</body><body package="GlorpDatabase" selector="printOffset:on:">printOffset: anInteger on: aCommand	"By default, do nothing"</body><body package="GlorpDatabase" selector="printPostLimit:on:">printPostLimit: anInteger on: aCommand	"By default, do nothing"</body><body package="GlorpDatabase" selector="printPreLimit:on:">printPreLimit: anInteger on: aCommand	"By default, do nothing"</body><body package="GlorpDatabase" selector="queryWithUnsupportedOperationsEliminatedFrom:do:">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	^self.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	self subclassResponsibility.</body><body package="GlorpDatabase" selector="maximumSizeToGroupWriteFor:">maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows	"If we are going to group write, how many rows of this collection should we do it for at once"	^aCollectionOfDatabaseRows size.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>functions</category><body package="GlorpDatabase" selector="functions">functions	functions isNil ifTrue: [self initializeFunctions].	^functions.</body><body package="GlorpDatabase" selector="initializeFunctions">initializeFunctions	"Subclasses should override to add database-specific functions"	functions := FunctionExpression createBasicFunctionsFor: self.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="createDropTableStatementFor:">createDropTableStatementFor: aTableNameString	"^&lt;String&gt; This method returns a string which can be used to drop a database table ..."	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: 'DROP TABLE';		space;		nextPutAll: aTableNameString.	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createTableIndexStatementStringsFor:">createTableIndexStatementStringsFor: aGLORPDatabaseTable	^aGLORPDatabaseTable indexes		collect:			[:idx | 			| sqlStatementStream |			sqlStatementStream := WriteStream on: String new.			sqlStatementStream nextPutAll: 'CREATE INDEX '.			sqlStatementStream nextPutAll: idx name.			sqlStatementStream nextPutAll: ' ON '.			self printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream.			idx printStatementOn: sqlStatementStream.			sqlStatementStream contents].</body><body package="GlorpDatabase" selector="createTableStatementStringFor:">createTableStatementStringFor: aGLORPDatabaseTable 	"^&lt;String&gt; This method returns a string which can be used to create a database table ..."	| sqlStatementStream tmpString |	tmpString := 'create table'.	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: (self capitalWritingOfSQLCommands 			ifTrue: [tmpString asUppercase]			ifFalse: [tmpString]);		space.	self printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream.	"Now print the columns specification for each field in the table ..."	self 		printColumnsSpecificationFor: aGLORPDatabaseTable		on: sqlStatementStream.	self supportsConstraints ifTrue:		[aGLORPDatabaseTable hasPrimaryKeyConstraints ifTrue: 			[sqlStatementStream nextPutAll: ', '.			(aGLORPDatabaseTable primaryKeyConstraints creationStringFor: self)				do: [ :each | sqlStatementStream nextPutAll: each.]				separatedBy: [sqlStatementStream nextPut: $,]].		aGLORPDatabaseTable hasUniqueConstraints ifTrue:			[sqlStatementStream nextPutAll: ', '.			aGLORPDatabaseTable uniqueConstraints do:				[:each | sqlStatementStream nextPutAll: (each creationString)]				separatedBy: [sqlStatementStream nextPut: $,]]].	sqlStatementStream		nextPut: $).	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="ddlTableNameFor:">ddlTableNameFor: aTableOrString	"	Either a databaseTable or a string can be passed in the argument.	"	^ aTableOrString isString		ifTrue: [ self capitalWritingOfTableName 			ifTrue: [ aTableOrString asUppercase ] 			ifFalse:[ aTableOrString ] ]		ifFalse: [ self ddlTableNameFor: aTableOrString qualifiedName ]</body><body package="GlorpDatabase" selector="printDDLTableNameFor:on:">printDDLTableNameFor: aGLORBDatabaseTable on: sqlStatementStream	"This method just writes the name of a table to a stream, in a way appropriate for DDL statements"		sqlStatementStream		nextPutAll: (self capitalWritingOfTableName 				ifTrue:[ aGLORBDatabaseTable qualifiedName asUppercase ] 				ifFalse:[ aGLORBDatabaseTable qualifiedName ]).</body><body package="GlorpDatabase" selector="printSqlStatementToListTablesInSchema:on:">printSqlStatementToListTablesInSchema: schemaString on: aStream	" Not standardized, although SQL Server, MySQL and PostgreSQL use the INFORMATION_SCHEMA "	| lowerSchema |	self usesInformationSchema		ifFalse: [^self subclassResponsibility].	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT table_name FROM information_schema.tables ';		nextPutAll: 'WHERE table_type = ';		nextPut: $';		nextPutAll: 'BASE TABLE';		nextPut: $'.	(lowerSchema notNil and: [lowerSchema notEmpty])		ifTrue: [			aStream				nextPutAll: ' AND lower(table_schema) = ';				nextPut: $';				nextPutAll: lowerSchema;				nextPut: $'.].	aStream nextPut: $;</body><body package="GlorpDatabase" selector="printSqlStatementToRenameTable:to:on:">printSqlStatementToRenameTable: aDatabaseTable to: newTableName on: aStream	" Tje default SQL statement is	ALTER TABLE &lt;oldTableName&gt; RENAME TO &lt;newTableName&gt;.	Different platforms may use another form. Override in subclasses if necessary.	"	aStream		nextPutAll: 'ALTER TABLE ';		nextPutAll: (self ddlTableNameFor: aDatabaseTable);		nextPutAll: ' RENAME TO ';		nextPutAll: newTableName</body><body package="GlorpDatabase" selector="printSqlStatementToTestExistenceOfTable:inSchema:on:">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	" Not standardized, although SQL Server, MySQL and PostgreSQL use the INFORMATION_SCHEMA "	| lowerTableName lowerSchema |	self usesInformationSchema		ifFalse: [^self subclassResponsibility].	lowerTableName := tableName asLowercase.	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT count(*) FROM information_schema.tables ';		nextPutAll: 'WHERE lower(table_name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $'.	(lowerSchema notNil and: [lowerSchema notEmpty])		ifTrue: [			aStream				nextPutAll: ' AND lower(table_schema) = ';				nextPut: $';				nextPutAll: lowerSchema;				nextPut: $'.].	aStream		nextPutAll: ' AND table_type = ';		nextPut: $';		nextPutAll: 'BASE TABLE';		nextPut: $';		nextPut: $;</body><body package="GlorpDatabase" selector="sqlStatementToListTablesInSchema:">sqlStatementToListTablesInSchema: schemaString	| stream |	stream := WriteStream on: String new.	self printSqlStatementToListTablesInSchema: schemaString on: stream.	^stream contents</body><body package="GlorpDatabase" selector="sqlStatementToRenameTable:to:">sqlStatementToRenameTable: aDatabaseTable to: newTableName	| stream |	stream := WriteStream on: String new.	self printSqlStatementToRenameTable: aDatabaseTable to: newTableName on: stream.	^ stream contents</body><body package="GlorpDatabase" selector="sqlStatementToTestExistenceOfTable:inSchema:">sqlStatementToTestExistenceOfTable: tableName inSchema: schemaString	| stream |	stream := WriteStream on: String new.	self printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: stream.	^stream contents</body><body package="GlorpDatabase" selector="tableNameFor:">tableNameFor: aStringRepresentingATableName	"Return the table name, as modified to be used in a database statement."	^aStringRepresentingATableName.</body><body package="GlorpDatabase" selector="validateTableName:">validateTableName: tableNameString	" &lt;Boolean&gt; I return true, if the choosen tableNameString is valid for the platform" 	^( tableNameString size &lt;= self maximumLengthOfTableName ) 			and: [ (self predefinedKeywords includes: tableNameString asLowercase) not ]</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>accessing</category><body package="GlorpDatabase" selector="characterEncoding">characterEncoding	"We hope that this will be set appropriately for the connection, but make sure the default is fairly harmless, and will in most cases complain rather than write characters incorrectly"	characterEncoding isNil ifTrue: [characterEncoding := #ascii].	^characterEncoding</body><body package="GlorpDatabase" selector="characterEncoding:">characterEncoding: anEncodingName	characterEncoding := anEncodingName.</body><body package="GlorpDatabase" selector="vwConnectionClass">vwConnectionClass	^self isODBCPlatform 			ifTrue: [self vwODBCConnectionClass]			ifFalse: [self vwEXDIConnectionClass]</body><body package="GlorpDatabase" selector="vwEXDIConnectionClass">vwEXDIConnectionClass	^self subclassResponsibility</body><body package="GlorpDatabase" selector="vwODBCConnectionClass">vwODBCConnectionClass	"Prefer Threaded over not if nothing is loaded, but use whatever is loaded if there is anything"	'ODBCThreadedConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].	'ODBCConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].			^'ODBCThreadedConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'ODBCThapiEXDI'</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services columns</category><body package="GlorpDatabase" selector="createAddColumnStatementFor:">createAddColumnStatementFor: aField	| stream |	stream := WriteStream on: String new.	stream 		nextPutAll: 'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: stream.	stream		space;		nextPutAll: ' ADD ';		nextPutAll: self startColumnAddString.	self  printColumn: aField on: stream.	stream nextPutAll: self  endColumnAddString.			^stream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatement:newType:">createAlterColumnStatement: aField newType: aType	^self createAlterColumnStatement: aField newType: aType usingExpression: nil</body><body package="GlorpDatabase" selector="createAlterColumnStatement:newType:usingExpression:">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  ' TYPE ';		nextPutAll: aType typeString.	expression ifNotNil: [ sqlStatementStream nextPutAll: ' USING ', expression ].	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatement:setDefault:">createAlterColumnStatement: aField setDefault: anObject	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'SET DEFAULT';		space.	anObject printOn: sqlStatementStream.		^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementDropDefault:">createAlterColumnStatementDropDefault: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DROP DEFAULT '.	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementDropNotNull:">createAlterColumnStatementDropNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DROP';		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint.		^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementSetNotNull:">createAlterColumnStatementSetNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'SET';		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint.		^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createDropColumnStatementFor:">createDropColumnStatementFor: aField	| stream |	stream := WriteStream on: String new.	stream 		nextPutAll: 'ALTER TABLE';		space.	self printDDLTableNameFor: aField table  on: stream.	stream		space;		nextPutAll: 'DROP COLUMN';		space;		nextPutAll: (self nameForColumn: aField name).			^stream contents</body><body package="GlorpDatabase" selector="endColumnQuote">endColumnQuote	"Return the character used to stop quoting the name of a column so that we can avoid conflicts with reserved names. ANSI says to use double quotes, so that's the default."	^'"'.</body><body package="GlorpDatabase" selector="nameForColumn:">nameForColumn: aColumnString	| upper |	upper := self capitalWritingOfColumnName ifTrue: [aColumnString asUppercase] ifFalse: [aColumnString].	(self reservedWords includes: aColumnString asLowercase) ifFalse: [^upper].	^self startColumnQuote, upper, self endColumnQuote.</body><body package="GlorpDatabase" selector="printColumn:on:">printColumn: eachGlorpDatabaseField on: sqlStatementStream	"Print the column specification for the CREATE TABLE statement.	Don't show a default value for serial columns, since their semanitics are different."	sqlStatementStream		nextPutAll: (self nameForColumn: eachGlorpDatabaseField name);		space;		nextPutAll: eachGlorpDatabaseField typeString;		space;		nextPutAll: 				(eachGlorpDatabaseField type isSerial					ifTrue: ['']					ifFalse: [self sqlTextForDEFAULT: eachGlorpDatabaseField defaultValue]);		space;		nextPutAll:				(eachGlorpDatabaseField isNullable						ifTrue: [self sqlTextForNULLAttributeConstraint]						ifFalse: [self sqlTextForNOTNULLAttributeConstraint]);		space;		nextPutAll:				(eachGlorpDatabaseField isUnique						ifTrue: [self sqlTextForUNIQUEAttributeConstraint]						ifFalse: [self sqlTextForNOTUNIQUEAttributeConstraint]).</body><body package="GlorpDatabase" selector="printColumnsSpecificationFor:on:">printColumnsSpecificationFor: aGlorpDatabaseTable on: sqlStatementStream	aGlorpDatabaseTable fields isEmpty not		ifTrue:			[| sepFlag |			sqlStatementStream				space;				nextPut: $(.			sepFlag := false.			aGlorpDatabaseTable fields				do:					[:eachGlorpDatabaseField | 					sepFlag						ifTrue:							[sqlStatementStream nextPutAll: self columnNameSeparatorString].					self printColumn: eachGlorpDatabaseField on: sqlStatementStream.					sepFlag := true]].</body><body package="GlorpDatabase" selector="printSqlStatementToCopyDataFromColumn:to:on:">printSqlStatementToCopyDataFromColumn: fromColumn to: toColumn on: aStream	"	Example:	UPDATE test_bank_acct	SET close_balance = balance	WHERE close_balance IS NULL OR close_balance &lt;&gt; balance	"	| toColumnName fromColumnName |	toColumnName := self nameForColumn: toColumn name.	fromColumnName := self nameForColumn: fromColumn name.	aStream		nextPutAll: 'UPDATE ';		nextPutAll: (self ddlTableNameFor: fromColumn table);		nextPutAll: ' SET ';		nextPutAll: toColumnName;		nextPutAll: ' = ';		nextPutAll: fromColumnName;		nextPutAll: ' WHERE ';		nextPutAll: toColumnName;		nextPutAll: ' IS NULL OR ';		nextPutAll: toColumnName;		nextPutAll: ' &lt;&gt; ';		nextPutAll: fromColumnName</body><body package="GlorpDatabase" selector="printSqlStatementToCopyDataFromTable:to:on:">printSqlStatementToCopyDataFromTable: fromTable to: toTable on: aStream	aStream		nextPutAll: 'INSERT INTO ';		nextPutAll: (self ddlTableNameFor: toTable);		nextPutAll: ' ( '.	GlorpHelper 		print: [:each | self nameForColumn: each name]		on: aStream		for: fromTable fields		separatedBy: ','.	aStream		nextPutAll: ' ) ';		nextPutAll: ' SELECT '.	GlorpHelper 		print: [:each | self nameForColumn: each name]		on: aStream		for: fromTable fields		separatedBy: ','.	aStream		nextPutAll: ' FROM ';		nextPutAll: (self ddlTableNameFor: fromTable)</body><body package="GlorpDatabase" selector="printSqlStatementToPopulateColumn:with:on:">printSqlStatementToPopulateColumn: aDatabaseField with: aValue on: aStream	| converter dbValue |	converter := aDatabaseField converterForStType: aValue class.	dbValue := converter		convert: aValue		toDatabaseRepresentationAs: aDatabaseField type.	aStream		nextPutAll: 'UPDATE ';		nextPutAll: (self ddlTableNameFor: aDatabaseField table);		nextPutAll: ' SET ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' = ';		nextPutAll: dbValue printString;		nextPutAll: ' WHERE (';		nextPutAll: ( self nameForColumn: aDatabaseField name);		nextPutAll: ' IS NULL OR ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' &lt;&gt; ';		nextPutAll: dbValue printString;		nextPutAll: ')'</body><body package="GlorpDatabase" selector="printSqlStatementToRenameColumn:to:on:">printSqlStatementToRenameColumn: oldColumn to: newColumnName on: aStream	aStream		nextPutAll: 'ALTER TABLE ';		nextPutAll: (self ddlTableNameFor: oldColumn table);		nextPutAll: ' RENAME ';		nextPutAll:  (self nameForColumn:  oldColumn name);		nextPutAll: ' TO ';		nextPutAll:  (self nameForColumn: newColumnName).</body><body package="GlorpDatabase" selector="sqlStatementToCopyDataFromColumn:to:">sqlStatementToCopyDataFromColumn: fromDatabaseField to: toDatabaseField	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToCopyDataFromColumn: fromDatabaseField		to: toDatabaseField		on: stream.	^ stream contents</body><body package="GlorpDatabase" selector="sqlStatementToCopyDataFromTable:to:">sqlStatementToCopyDataFromTable: fromDatabaseTable to: toDatabaseTable	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToCopyDataFromTable: fromDatabaseTable		to: toDatabaseTable		on: stream.	^ stream contents</body><body package="GlorpDatabase" selector="sqlStatementToPopulateColumn:with:">sqlStatementToPopulateColumn: aDatabaseField with: aValue	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToPopulateColumn: aDatabaseField		with: aValue		on: stream.	^ stream contents</body><body package="GlorpDatabase" selector="sqlStatementToRenameColumn:to:">sqlStatementToRenameColumn: oldColumn to: newColumnName	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToRenameColumn: oldColumn		to: newColumnName		on: stream.	^ stream contents</body><body package="GlorpDatabase" selector="startColumnQuote">startColumnQuote	"Return the character used to start quoting the name of a column so that we can avoid conflicts with reserved names. ANSI says to use double quotes, so that's the default."	^'"'.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>type helpers</category><body package="GlorpDatabase" selector="typesWithValues">typesWithValues	"Return our types list, but makes sure it has at least basic types in it"	self varchar.	self int4.	self integer.	self int.	self number.	self timestamp.	self char.	self blob.	self clob.	self raw.	self serial.	self text.	^self types.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services constraints</category><body package="GlorpDatabase" selector="createConstraintAddStatement:">createConstraintAddStatement:  aConstraint	| sqlStatementStream |	self supportsAlterTableForConstraints ifFalse: [^''].	aConstraint shouldCreateInDatabase ifFalse: [^''].	self supportsConstraints			ifTrue: [sqlStatementStream := WriteStream on: String new.					sqlStatementStream						nextPutAll:  'ALTER TABLE';						space.					self printDDLTableNameFor: aConstraint table on: sqlStatementStream.					(aConstraint creationStringFor: self)						do: [ :each | sqlStatementStream nextPutAll: ' ADD ', each.]						separatedBy: [sqlStatementStream nextPut: $,].					^sqlStatementStream contents].	^String new</body><body package="GlorpDatabase" selector="createConstraintDropStatement:">createConstraintDropStatement: aConstraint	| aStream |	self supportsAlterTableForConstraints ifFalse: [^''].	aConstraint shouldCreateInDatabase ifFalse: [^''].	aStream := WriteStream on: (String new: 50).	aStream nextPutAll: 'ALTER TABLE '.	self printDDLTableNameFor: aConstraint table on: aStream.	aStream nextPutAll: ' DROP '.	self writeConstraintToDrop: aConstraint onStream: aStream.	^aStream contents.</body><body package="GlorpDatabase" selector="createForeignKeyConstraintAddStatement:">createForeignKeyConstraintAddStatement: aForeignKeyConstraint	"Callback from the ForeignKeyConstraint. Returns collection of statements "	| ws |	aForeignKeyConstraint shouldCreateInDatabase ifFalse: [^#('')].	ws := WriteStream on: (String new: 50).	ws		nextPutAll: 'CONSTRAINT ';		nextPutAll: aForeignKeyConstraint name;		nextPutAll: ' FOREIGN KEY ('.	GlorpHelper print: [:each | each name] on: ws for: aForeignKeyConstraint sourceFields separatedBy: ','.	ws 	nextPutAll: ') REFERENCES ';		nextPutAll: aForeignKeyConstraint targetTable qualifiedName;		nextPutAll: ' ('.	GlorpHelper print: [:each | each name] on: ws for: aForeignKeyConstraint targetFields separatedBy: ','.	ws nextPutAll: ')'.	aForeignKeyConstraint suffixExpression isNil		ifFalse:			[ws				space;				nextPutAll: aForeignKeyConstraint suffixExpression].	^OrderedCollection with: ws contents.</body><body package="GlorpDatabase" selector="createPrimaryKeyConstraintAddStatement:">createPrimaryKeyConstraintAddStatement: aPrimaryKeyConstraint	"Callback from the PrimaryKeyConstraint. Returns collection of statements "	| aStream statements |	aPrimaryKeyConstraint shouldCreateInDatabase ifFalse: [^''].	statements := OrderedCollection new.	aStream := WriteStream on: String new.	aStream nextPutAll: 'CONSTRAINT '.	aStream nextPutAll: aPrimaryKeyConstraint name.	aStream nextPutAll: ' PRIMARY KEY  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: aPrimaryKeyConstraint primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	statements add: aStream contents.	self primaryKeysAreAutomaticallyUnique ifTrue: [^statements].	aStream reset.	aStream nextPutAll: ' CONSTRAINT '.	aStream nextPutAll: (self usesPrimaryKeyUniqueConstraintNames 							ifTrue: [aPrimaryKeyConstraint table name, '_UNIQ'] 							ifFalse: ['']).	aStream nextPutAll: ' UNIQUE  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: aPrimaryKeyConstraint  primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	statements add: aStream contents.	^statements</body><body package="GlorpDatabase" selector="createUniqueConstraintAddStatement:">createUniqueConstraintAddStatement: aUniqueConstraint	"Callback from the UniqueConstraint. Returns collection of statements "		| stream |	aUniqueConstraint shouldCreateInDatabase ifFalse: [^#('')].	stream := WriteStream on: (String new: 50).	stream		nextPutAll: 'CONSTRAINT ';		nextPutAll: aUniqueConstraint name;		nextPutAll: ' UNIQUE ('.	GlorpHelper 		print: [:each | each name] 		on: stream 		for: aUniqueConstraint fields 		separatedBy: ','.	stream nextPutAll: ')'.	^OrderedCollection with: stream contents</body><body package="GlorpDatabase" selector="writeConstraintToDrop:onStream:">writeConstraintToDrop: aConstraint onStream: aStream	aStream		nextPutAll: 'CONSTRAINT ';		nextPutAll: aConstraint name.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>obsolete</category><body package="GlorpDatabase" selector="createTableFKContraintsStatementStringsFor:">createTableFKContraintsStatementStringsFor: aGLORPDatabaseTable	^aGLORPDatabaseTable foreignKeyConstraintsForCreation		collect: [:each |	self createConstraintAddStatement: each ]</body><body package="GlorpDatabase" selector="printPrimaryKeyConstraintsOn:for:">printPrimaryKeyConstraintsOn: sqlStatementStream for: aTable 	"This method print the constraint specification on sqlStatementStream"	aTable primaryKeyFields isEmpty ifTrue: [^self].	(self createPrimaryKeyConstraintAddStatement: aTable primaryKeyConstraints)		do: [ :each | sqlStatementStream nextPutAll: each].</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>*eoglorp</category><body package="GlorpDatabase" selector="createLoginFromConnectionDictionary:">createLoginFromConnectionDictionary: aDict 	self subclassResponsibility</body><body package="GlorpDatabase" selector="loginWithConnectionDictionary:">loginWithConnectionDictionary: aDict 	| platformClass |	platformClass := self glorpAllSubclasses				detect: [:cls | cls understandsConnectionDictionary: aDict].	^ platformClass isNil		ifFalse: [platformClass createLoginFromConnectionDictionary: aDict] ifTrue: [nil]</body><body package="GlorpDatabase" selector="understandsConnectionDictionary:">understandsConnectionDictionary: aDict	^false</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>testing</category><body package="GlorpDatabase" selector="useBindingByDefault">useBindingByDefault	^true</body><body package="GlorpDatabase" selector="useBindingIfSupported">useBindingIfSupported	"If I am nil (the default), each platform that supportsBinding lazily initializes to its defaultUseBinding value.  If I have a value, I force lazy initialization of each platform that supportsBinding to my value.  Normally, a value is set only for specific testing purposes."	UseBindingIfSupported isNil ifTrue: [^self useBindingByDefault].	^UseBindingIfSupported</body><body package="GlorpDatabase" selector="useBindingIfSupported:">useBindingIfSupported: aBooleanOrNil	"If I am nil (the default), each platform that supportsBinding lazily initializes to its defaultUseBinding value.  If I have a value, I force lazy initialization of each platform that supportsBinding to my value.  Normally, a value is set only for specific testing purposes."	UseBindingIfSupported := aBooleanOrNil.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	^OracleSequence.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>SQL</category><body package="GlorpDatabase" selector="isOraclePlatform">isOraclePlatform	^true</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="boolean">boolean	^self int2.</body><body package="GlorpDatabase" selector="char">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new].</body><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'clob'].</body><body package="GlorpDatabase" selector="date">date	^self typeNamed: #date ifAbsentPut: [GlorpTimeStampType new typeString: 'date'].</body><body package="GlorpDatabase" selector="double">double	^self float8</body><body package="GlorpDatabase" selector="float">float	^self float4.</body><body package="GlorpDatabase" selector="float4">float4	^self typeNamed: #float4 ifAbsentPut: [GlorpFloatType new typeString: 'float'].</body><body package="GlorpDatabase" selector="float8">float8	^self typeNamed: #float8 ifAbsentPut: [GlorpDoubleType new typeString: 'double precision'].</body><body package="GlorpDatabase" selector="int">int	^self integer</body><body package="GlorpDatabase" selector="int2">int2	^self integer</body><body package="GlorpDatabase" selector="int4">int4	^self integer</body><body package="GlorpDatabase" selector="int8">int8	^self integer</body><body package="GlorpDatabase" selector="number">number	^self typeNamed: #number ifAbsentPut: [GlorpNumericType new typeString: 'number'].</body><body package="GlorpDatabase" selector="raw">raw	^self typeNamed: #raw ifAbsentPut: [GlorpBlobType new typeString: 'raw'].</body><body package="GlorpDatabase" selector="sequence">sequence	^self serial.</body><body package="GlorpDatabase" selector="serial">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: (self integer typeString)].</body><body package="GlorpDatabase" selector="text">text	^self clob.</body><body package="GlorpDatabase" selector="time">time	^self timestamp.</body><body package="GlorpDatabase" selector="timestamp">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'date'].</body><body package="GlorpDatabase" selector="varchar">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new typeName: 'varchar2'].</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>table creation</category><body package="GlorpDatabase" selector="printNumericFieldOfSize:on:">printNumericFieldOfSize: anInteger on: aStream	aStream 		nextPutAll: 'number('.	anInteger printOn: aStream.	aStream nextPutAll: ')'.</body><body package="GlorpDatabase" selector="printStringFieldOfSize:on:">printStringFieldOfSize: anInteger on: aStream	aStream 		nextPutAll: 'varchar2('.	anInteger printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	^true.</body><body package="GlorpDatabase" selector="endColumnAddString">endColumnAddString	"The string we use as a suffix when adding a colum"	^' ) '.</body><body package="GlorpDatabase" selector="initializeReservedWords">initializeReservedWords	super initializeReservedWords.	reservedWords add: 'number'.</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^30</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^30</body><body package="GlorpDatabase" selector="primaryKeysAreAutomaticallyUnique">primaryKeysAreAutomaticallyUnique	"Return false if, in addition to specifying something as a primary key, we must separately specify it as unique"	^true.</body><body package="GlorpDatabase" selector="requiresTransactionForTableOperations">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^false.</body><body package="GlorpDatabase" selector="sqlTextCurrentServerUTCTimestamp">sqlTextCurrentServerUTCTimestamp	^'SELECT SYS_EXTRACT_UTC(CURRENT_TIMESTAMP) FROM DUAL'</body><body package="GlorpDatabase" selector="startColumnAddString">startColumnAddString	"The string we use as a prefix when adding a colum"	^' ( '.</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	^false.</body><body package="GlorpDatabase" selector="usesNullForEmptyStrings">usesNullForEmptyStrings	"Return true if this database is likely to use nil as an empty string value"	^true.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDate for: aType	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: 'to_date('''.	self		printDate: aDate		isoFormatOn: stream.	stream nextPutAll: ''','''.	stream nextPutAll: 'YYYY-MM-DD'.	stream nextPutAll: ''')'.	^stream contents.</body><body package="GlorpDatabase" selector="printTime:for:">printTime: aTime for: aType	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: 'to_date('''.	self		printTime: aTime		isoFormatOn: stream.	stream nextPutAll: ''','''.	stream nextPutAll: 'HH24:MI:SS'.	stream nextPutAll: ''')'.	^stream contents.</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPutAll: 'to_date('''.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPut: $ .	self		printTime: aTimestamp		isoFormatOn: stream		milliseconds: false.	stream nextPutAll: ''','''.	stream nextPutAll: 'YYYY-MM-DD HH24:MI:SS'.	stream nextPutAll: ''')'.</body><body package="GlorpDatabase" selector="timestampConverter">timestampConverter	^DelegatingDatabaseConverter		named: #timestamp		hostedBy: self		fromStToDb: #asTimestamp:for:		fromDbToSt: #readTimestamp:for:.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="canUseInWhereClause:type:">canUseInWhereClause: aValue type: aType	"This is mostly for test support purposes. If we know we can't use a particular kind of value in the where clause on some database, don't try."	(super canUseInWhereClause: aValue type: aType) ifFalse: [^false].	"On Oracle we effectively can't compare constants against blobs."	aType = self blob ifFalse: [^true].	aValue isNil ifTrue: [^true].	^false.</body><body package="GlorpDatabase" selector="maximumQueryValueSize">maximumQueryValueSize	"If there's a limit on how big a bound input parameter can be for a query, return it here. By default, no maximum. "	^4001</body><body package="GlorpDatabase" selector="measuresStringFieldWidthsInBytes">measuresStringFieldWidthsInBytes	"Return true if we measure the width of a string in bytes rather than characters. So, a 255-character field can hold 255 bytes worth of string, not 255 characters. This is important with encodings."	^true</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^false.</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"Binding works only with VW EXDI so far"	^Dialect isVisualWorks.</body><body package="GlorpDatabase" selector="supportsGroupWritingFor:">supportsGroupWritingFor: aCommand	^self supportsBinding and: [self useBinding and: [aCommand supportsGroupWriting]].</body><body package="GlorpDatabase" selector="supportsTableOwners">supportsTableOwners	^true</body><body package="GlorpDatabase" selector="useOracleOuterJoins">useOracleOuterJoins	"Return true if we use the old Oracle x = y (+) syntax for outer joins"	^true.</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	"Return true if we use array binding for grouped writes rather than printing the sql multiple times. Only applies if we support grouped writes"	^true.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="printBlob:on:for:">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: 'HEXTORAW('''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPutAll: ''')'.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand arrayBindings.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="GlorpDatabase" selector="compoundOperationFor:">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol"	aSymbol == #EXCEPT ifTrue: [^'MINUS'].	^aSymbol.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>accessing</category><body package="GlorpDatabase" selector="vwEXDIConnectionClass">vwEXDIConnectionClass	"Prefer Threaded over not if nothing is loaded, but use whatever is loaded if there is anything"	'OracleThreadedConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].	'OracleConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].			^'OracleThreadedConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'OracleThapiEXDI'</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>functions</category><body package="GlorpDatabase" selector="initializeFunctions">initializeFunctions	| baseExists dbSpecificExists selectList baseNotExists dbSpecificNotExists |	super initializeFunctions.	"Oracle doesn't allow functions like EXISTS in a field list, but will allow a select there as an argument to a function, such as DECODE. So print it that way if we're in the select list."	baseExists := functions at: #exists:.	dbSpecificExists := DualRoleFunction new.	dbSpecificExists function: '#exists:'.	dbSpecificExists whereClauseVersion: baseExists.	selectList := PrefixFunction named: 'DECODE'.	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 1 asGlorpExpression with: 0 asGlorpExpression].	selectList type: baseExists type.	dbSpecificExists selectListVersion: selectList.	dbSpecificExists type: baseExists type.	functions at: #exists: put: dbSpecificExists.	"And similarly NOT EXISTS"	baseNotExists := functions at: #notExists:.	dbSpecificNotExists := DualRoleFunction new.	dbSpecificNotExists function: '#notExists:'.	dbSpecificNotExists whereClauseVersion: baseNotExists.	selectList := PrefixFunction named: 'DECODE'.	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 0 asGlorpExpression with: 1 asGlorpExpression].	selectList type: baseNotExists type.	dbSpecificNotExists selectListVersion: selectList.	dbSpecificNotExists type: baseExists type.	functions at: #notExists: put: dbSpecificNotExists.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>services columns</category><body package="GlorpDatabase" selector="createAlterColumnStatement:newType:usingExpression:">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aType typeString, ')'.	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatement:setDefault:">createAlterColumnStatement: aField setDefault: anObject	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT';		space.	anObject printOn: sqlStatementStream.	sqlStatementStream		nextPutAll:  ')'.		^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementDropDefault:">createAlterColumnStatementDropDefault: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT NULL)'.	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementDropNotNull:">createAlterColumnStatementDropNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'NULL)'.		^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementSetNotNull:">createAlterColumnStatementSetNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint;		nextPutAll: ')'.		^sqlStatementStream contents</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="printSqlStatementToListTablesInSchema:on:">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Not standardized"	| lowerSchema |	lowerSchema := (schemaString isNil or: [schemaString isEmpty])		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT table_name FROM all_tables '.	(lowerSchema notNil and: [lowerSchema notEmpty]) ifTrue:		[aStream 			nextPutAll: 'WHERE lower(owner) = ';			nextPut: $';			nextPutAll: lowerSchema;			nextPut: $']</body><body package="GlorpDatabase" selector="printSqlStatementToTestExistenceOfTable:inSchema:on:">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	" This query will test only for tables that the logged on user has access to... "	| lowerTableName lowerSchema |	lowerTableName := tableName asLowercase.	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT count(*) FROM all_tables ';		nextPutAll: 'WHERE lower(table_name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $';		nextPutAll: ' AND lower(owner) = ';		nextPut: $';		nextPutAll: lowerSchema;		nextPut: $'</body></methods><methods><class-id>Glorp.OracleODBCPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="isODBCPlatform">isODBCPlatform	^true.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="addPhantomMappingExpressionOn:">addPhantomMappingExpressionOn: base 	| phantomMapping phantomMappingName phantomExpression |	phantomMapping := self reverseMapping.	phantomMappingName := 'glorp_internal_' , self attributeName , '_to_' 				, self descriptor describedClass name.	phantomExpression := base getMapping: phantomMapping				named: phantomMappingName.	phantomExpression bePhantom.	^phantomExpression</body><body package="GlorpMappings" selector="buildGeneralQueryIn:">buildGeneralQueryIn: anObjectBuilder	"For filtered queries. We need to build this in terms of the parent query"	| base parentCriteria fullCriteria phantomExpression newQuery |	base := BaseExpression new.	base descriptor: self referenceDescriptor.	phantomExpression := self addPhantomMappingExpressionOn: base.	parentCriteria := anObjectBuilder query whereClause.	fullCriteria := parentCriteria		rebuildOn: phantomExpression.	newQuery := Query returningManyOf: self referenceClass.	"newQuery collectionType: self collectionType."	fullCriteria isEmptyExpression ifFalse: [newQuery where: fullCriteria].	self		setGeneralQueryRetrievalIn: newQuery		basedOn: base		phantom: phantomExpression.	^newQuery.</body><body package="GlorpMappings" selector="buildQuery">buildQuery	| toMany |	toMany := self attribute isCollectionAttribute.	query := toMany		ifTrue: [Query read: self referenceClass where: self join]		ifFalse: [Query readOneOf: self referenceClass where: self join].	query session: self session.	query baseExpression descriptor: (self session descriptorFor: self referenceClass).	query collectionType: self collectionType.	self usesLinkTable ifTrue: [		query AND: (self expressionFromLinkToReferenceTableWithBase: query baseExpression)].	^query.</body><body package="GlorpMappings" selector="buildRowMapKeyForSource:target:index:">buildRowMapKeyForSource: source target: target index: index	^(RowMapKey new)		key1: target yourSelf;		key2: source yourSelf.</body><body package="GlorpMappings" selector="createDeleteRowFor:in:">createDeleteRowFor: anObject in: aRowMap	"This is like firing the mapping, but instead of creating the data, we just need to check if there are link table entries, and if so, make sure they are deleted"	| target mementoizedTarget|	self canWrite ifFalse: [^self].	self usesLinkTable ifFalse: [^self].	target := self getValueFrom: anObject.	target := self session realObjectFor: target ifNone: [^self].	(self isValidTarget: target) ifTrue: [		mementoizedTarget := aRowMap collectionMementoFor: target.		self createDeleteRowForLinkFrom: anObject toTarget: mementoizedTarget in: aRowMap].</body><body package="GlorpMappings" selector="createDeleteRowForLinkFrom:toTarget:in:">createDeleteRowForLinkFrom: anObject toTarget: target in: aRowMap	| linkTable |	self usesLinkTable ifFalse: [^false].	linkTable := self linkTableJoin allTables asArray first.	self attribute		loopOver: target		doing:			[:index :eachTarget | 			| intermediate |			intermediate := self				rowMapKeyForSource: anObject				target: eachTarget				index: index.			aRowMap				rowForTable: linkTable				withKey: intermediate				ifPresent:					[:linkRow | linkRow isEmpty ifFalse: [linkRow forDeletion: true]]].</body><body package="GlorpMappings" selector="extendedJoin">extendedJoin	"In order to do a many-to-many read we need more information than just the write, we need to know 	the relationship to the other table. Construct that based on the table information"	| generalMappingCriteria base |	self usesLinkTable ifFalse: [^self join].	generalMappingCriteria := self join asGeneralGlorpExpressionWithFields.	base := generalMappingCriteria ultimateBaseExpression.	^(self expressionFromLinkToReferenceTableWithBase: base) AND: generalMappingCriteria.</body><body package="GlorpMappings" selector="extendedJoinFromSource:toTarget:">extendedJoinFromSource: sourceExpression toTarget: targetExpression	"In order to do a many-to-many read we need more information than just the write, we need to know 	the relationship to the other table. Construct that based on the table information"	| generalMappingCriteria |	self usesLinkTable 		ifFalse: [^self join asExpressionJoiningSource: sourceExpression toTarget: targetExpression].	generalMappingCriteria := self join asExpressionJoiningSource: sourceExpression toTarget: targetExpression.	^(self expressionFromLinkToReferenceTableWithBase: targetExpression) AND: generalMappingCriteria.</body><body package="GlorpMappings" selector="isValidTarget:">isValidTarget: anObject	^anObject isGlorpProxy		ifTrue: [anObject isInstantiated]		ifFalse: [true].</body><body package="GlorpMappings" selector="knitFromBuilder:toBuilder:">knitFromBuilder: sourceBuilder toBuilder: targetBuilder 	self canRead ifFalse: [^self].	self attribute knit: sourceBuilder instance to: targetBuilder instance</body><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap 	"Our target is a collection. The tricky bit is that if we're building rows into a RowMapForMementos, then the collection we contain isn't the one we want to use. We want the old version. Ask the row map to give it to us. If it's a normal row map, we'll just get the same thing back" 	| target mementoizedTarget|	self canWrite ifFalse: [^self].	target := self getValueFrom: anObject.	target := self session realObjectFor: target ifNone: [^self].	(self isValidTarget: target) ifTrue: [		mementoizedTarget := aRowMap collectionMementoFor: target.		self mapFromObject: anObject toTarget: mementoizedTarget puttingRowsIn: aRowMap].</body><body package="GlorpMappings" selector="mapFromObject:toTarget:puttingRowsIn:">mapFromObject: anObject toTarget: target puttingRowsIn: aRowMap	self attribute		loopOver: target		doing:			[:index :eachTarget | 			| intermediate |			intermediate := self				rowMapKeyForSource: anObject				target: eachTarget				index: index.			self				mapOneFromObject: anObject				toTarget: eachTarget				intermediate: intermediate				atPosition: index				puttingRowsIn: aRowMap].</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anElementBuilder	| value session parameters |	session := descriptor session.	parameters := self parametersIn: anElementBuilder.	value := self shouldProxy		ifTrue:			[| proxy |			proxy := (self newProxyIn: anElementBuilder)				session: session;				parameters: parameters;				glorpOwner: anObject.			"If we know in advance the proxy would return nil, or an empty collection, just put that in rather than the proxy"			(proxy query shortCircuitEmptyReturn: parameters)				ifTrue: [proxy getValue]				ifFalse: [proxy]]		ifFalse:			[(self queryFor: anElementBuilder)				executeWithParameters: parameters				in: session].	self setValueIn: anObject to: value.</body><body package="GlorpMappings" selector="mapOneFromObject:toTarget:intermediate:atPosition:puttingRowsIn:">mapOneFromObject: sourceObject toTarget: targetObject intermediate: aRowMapKey atPosition: index puttingRowsIn: aRowMap	self linkTableJoin		mapFromSource: sourceObject		andTarget: aRowMapKey		intoRowsIn: aRowMap.	self targetTableJoin isNil		ifFalse:			[self targetTableJoin				mapFromSource: sourceObject				andTarget: (self mapsSimpleObject ifTrue: [aRowMapKey] ifFalse: [targetObject])				intoRowsIn: aRowMap].	self usesLinkTable		ifTrue:			[self reverseJoin				mapFromSource: aRowMapKey				andTarget: (self mapsSimpleObject ifTrue: [aRowMapKey] ifFalse: [targetObject])				intoRowsIn: aRowMap].	self		writeExtraInformationInto: aRowMap		atKey: aRowMapKey		forSourceObject: sourceObject		targetObject: targetObject		atIndex: index.</body><body package="GlorpMappings" selector="parametersIn:">parametersIn: anElementBuilder	| parameters |	self shouldUseFilteredRead ifTrue: [^anElementBuilder command parameters].	parameters := IdentityDictionary new.	self join		mappableSourceFieldsDo:			[:eachSource | parameters at: eachSource put: (anElementBuilder valueOfField: eachSource)].	^parameters.</body><body package="GlorpMappings" selector="query">query	query isNil ifTrue: [self buildQuery].	^query.</body><body package="GlorpMappings" selector="referenceTableFieldFor:">referenceTableFieldFor: aField	^self usesLinkTable		ifTrue: [nil]		ifFalse: [self join targetForSource: aField].</body><body package="GlorpMappings" selector="reverseJoin">reverseJoin	reverseJoin isNil ifTrue: [reverseJoin := self joinFromLinkToReferenceTable].	^reverseJoin.</body><body package="GlorpMappings" selector="reverseMapping">reverseMapping	"Construct the backwards mapping that corresponds to us. If it's using a link table, then we are at least potentially a toMany mapping. Otherwise, we can point backwards only to a single object."	| mapping |	^self usesLinkTable		ifTrue: 			[mapping := (ManyToManyMapping new)				attributeName: #temporaryAttributeFromSubselect;				referenceClass: self descriptor describedClass;				join: self reverseJoin inverseJoin;				descriptor: self descriptor.			mapping reverseJoin: self join inverseJoin onlyJoinParts]		ifFalse: 			[(OneToOneMapping new)				attributeName: #temporaryAttributeFromSubselect;				referenceClass: self descriptor describedClass;				join: self join inverseJoin;				descriptor: self descriptor]</body><body package="GlorpMappings" selector="rowMapKeyForSource:target:index:">rowMapKeyForSource: source target: target index: index	"Create the row map key. Make sure we're holding onto the real objects, so proxies don't time out on us"	self needsSpecialRowMapKey ifFalse: [^target].	(target yourSelf isNil or: [source yourSelf isNil]) ifTrue: [^nil].	^rowMapKeyConstructorBlock isNil		ifTrue:			[self				buildRowMapKeyForSource: source				target: target				index: index]		ifFalse:			[rowMapKeyConstructorBlock value: source yourSelf value: target yourSelf].</body><body package="GlorpMappings" selector="setGeneralQueryRetrievalIn:basedOn:phantom:">setGeneralQueryRetrievalIn: newQuery basedOn: base phantom: phantomExpression	self descriptor keyFields		do: [:eachField | newQuery retrieve: (phantomExpression getField: eachField)].	newQuery retrieve: base.</body><body package="GlorpMappings" selector="valueOfField:fromObject:">valueOfField: aField fromObject: anObject	^self valueOfField: aField fromObject: anObject ifNone: [self error: 'Cannot find value'].</body><body package="GlorpMappings" selector="valueOfField:fromObject:ifNone:">valueOfField: aField fromObject: anObject ifNone: aBlock	"Return the value of a given field in our target object. Used in extracting primary keys when they are mapped via relationships"	| targetField target |	targetField := self referenceTableFieldFor: aField.	targetField isNil ifTrue: [^aBlock value].	target := self getValueFrom: anObject.	"If it's a proxy and uninstantiated, we have to get the value from the proxy"	(target isGlorpProxy and: [target isInstantiated not])		ifTrue: [^target parameters at: aField].	"If the object is instantiated, then we prefer to get the value from the object, because if it's non-primary key then the proxy may not know it, or it may vary from what the proxy has. Well, that seems unlikely, but try this anyway"	self attribute 			loopOver: target 		doing: [:index :eachTarget | | value |			value := self referenceDescriptor valueOfField: targetField fromObject: eachTarget ifNone: [self].			value == self ifFalse: [^value]].	"We couldn't get it from the object, probably because it's unmapped. See if the proxy has it after all"	target isGlorpProxy ifTrue: [^target parameters at: aField].	"We couldn't get the value at all. This may mean that the object is new, so it has no proxies holding the value. Return nil and hope it's new and that it will all get figured out"	^aBlock value.</body><body package="GlorpMappings" selector="writeExtraInformationInto:atKey:forSourceObject:targetObject:atIndex:">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject  atIndex: index</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="controlsTables">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^controlsTables</body><body package="GlorpMappings" selector="hasValueThatCanProvideField:from:">hasValueThatCanProvideField: aField from: anObject	"Return true if we have enough information in ourselves to populate our fields. The only time this won't be true is if we're either holding an uninstantiated proxy or have a to-many relationship mapping with an empty collection. Assumes that aField is one that we map."	| value |	value := self getValueFrom: anObject.	value isGlorpProxy ifFalse: [^value notNil].	value isInstantiated ifTrue: [^true].	^value parameters includesKey: aField.</body><body package="GlorpMappings" selector="isRelationship">isRelationship	"True when the mapping associates different persistent classes."	^true</body><body package="GlorpMappings" selector="isStoredInSameTable">isStoredInSameTable	"Normally, a relationship mapping isn't stored in the same table, but if we're part of a dictionary mapping and the table is mapped to an association, then we want to be treated that way. The test is a horrible hack"	^self classModel describedClass == Association.</body><body package="GlorpMappings" selector="isToManyRelationship">isToManyRelationship	^self attribute isCollectionAttribute.</body><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^self join allSourceFields select: [:each | each isMappable and: [(each isGlorpExpression not or: [each isConstantExpression not])]].</body><body package="GlorpMappings" selector="needsSpecialRowMapKey">needsSpecialRowMapKey	"Return true if we have to use a special key object for the row map, rather than just our target"	^self usesLinkTable.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="allTables">allTables	(self join) isNil ifTrue: [^#()].	^(self join) allTables.</body><body package="GlorpMappings" selector="basicReferenceClass">basicReferenceClass	^self attribute type.</body><body package="GlorpMappings" selector="basicReferenceDescriptor">basicReferenceDescriptor	^self system descriptorFor: self basicReferenceClass.</body><body package="GlorpMappings" selector="collectionType">collectionType	^nil.</body><body package="GlorpMappings" selector="controlsTables:">controlsTables: aBoolean	"We can indicate that this relationship does not actually control its tables. This is going to be true if the parent controls the same tables and coexists with us. Think StoreVersionlessPundle and Pundle"	controlsTables := aBoolean.</body><body package="GlorpMappings" selector="join">join	join isNil ifTrue: [self initializeJoin].	^join.</body><body package="GlorpMappings" selector="join:">join: aJoin	"We allow the join to be specified either as a Join (the normal case) or as an expression. We expect an expression specifying the relationship in terms of other relationships. So, e.g. to specify the join from InsurancePlan to PolicyHolder we might specify[:eachPolicyHolder | eachPolicyHolder employer availablePlans].  Note that the relationship is described from the point of view of the target, and is just a list of mappings. Then we take this internally and transform it into an equality expression we can use to define the relationship."	| base basicExpression |	(Dialect isBlock: aJoin) 		ifTrue: [			self beReadOnly.			base := JoinBaseExpression new.			base descriptor: (self system descriptorFor: self referenceClass).			basicExpression := aJoin asGlorpExpressionOn: base.			"It doesn't matter what name we give the parameter, because it will be rewritten into a primary key comparison anyway, that will use the fields as 'names'. Also, it's important that we assign into join here, because otherwise the rewriteEquality operation will try and figure out a join for us, since it's still nil."			join := basicExpression get: #= withArguments: (				Array with: (ParameterExpression forField: 'sourceObject' basedOn: basicExpression join)).			join := join rewriteEquality]		ifFalse: [join := aJoin].	[join owningMapping: self] on: MessageNotUnderstood do: [:ex | ex | ex return].</body><body package="GlorpMappings" selector="linkTableJoin">linkTableJoin	linkTableJoin isNil ifTrue: [^self join].	^linkTableJoin</body><body package="GlorpMappings" selector="linkTableJoin:">linkTableJoin: aJoin	"Set the join from the link table to the target table. Normally this is calculated automatically (see reverseJoin), but it can be set manually if that's not possible (for example, because you want to include a constant value in the join, that won't be included in the foreign key constraints). See also relevantLinkTableFields if you need to give a hint."	linkTableJoin := aJoin.	[aJoin owningMapping: self] on: MessageNotUnderstood do: [:ex | ex | ex return].</body><body package="GlorpMappings" selector="mappingCriteria">mappingCriteria	^self join.</body><body package="GlorpMappings" selector="mappingCriteria:">mappingCriteria: aJoin	self join: aJoin.</body><body package="GlorpMappings" selector="proxyAction">proxyAction	"Return an action each proxy should take when it's instantiated. This is a two-argument block		[:owner :target | "	^proxyAction.</body><body package="GlorpMappings" selector="proxyAction:">proxyAction: aBlock	"Set an action each proxy should take when it's instantiated. This is a two-argument block		[:owner :target | "	proxyAction := aBlock.</body><body package="GlorpMappings" selector="referenceClass:">referenceClass: aClass	self attribute type: aClass.</body><body package="GlorpMappings" selector="referenceDescriptor">referenceDescriptor	^self system descriptorFor: self referenceClass.</body><body package="GlorpMappings" selector="reverseJoin:">reverseJoin: aJoin	"Set the reverse join - the join from the link table to the target table. Normally this will be calculated based on the foreign key constraints, but in rare cases (e.g. a foreign key that may be to more than one table) you may want to set it explicitly"	reverseJoin := aJoin.</body><body package="GlorpMappings" selector="shouldProxy">shouldProxy	^shouldProxy.</body><body package="GlorpMappings" selector="shouldProxy:">shouldProxy: aBoolean	shouldProxy := aBoolean.</body><body package="GlorpMappings" selector="targetTableJoin">targetTableJoin	^targetTableJoin</body><body package="GlorpMappings" selector="targetTableJoin:">targetTableJoin: aJoin	"Set the join from the source table to the target table. Note that is is only required if you are using a link table, and in addition to the link table join need to connect from the source table directly to the target table as well.  This is *NOT* supposed to be a join from the link table to the target table. That's reverseJoin, and is calculated automatically. See relevantLinkTableFields if you need to give a hint, or linkTableJoin: if you want to set it explicitly."	targetTableJoin := aJoin.	aJoin owningMapping: self.</body><body package="GlorpMappings" selector="useLinkTable">useLinkTable	usesLinkTable := true.</body><body package="GlorpMappings" selector="usesLinkTable">usesLinkTable	^usesLinkTable</body><body package="GlorpMappings" selector="usesLinkTable:">usesLinkTable: anObject	usesLinkTable := anObject</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>initializing</category><body package="GlorpMappings" selector="constraintsFrom:to:">constraintsFrom: oneTableSet to: anotherTableSet	^(self oneWayConstraintsFrom: oneTableSet to: anotherTableSet), 		(self oneWayConstraintsFrom: anotherTableSet to: oneTableSet)</body><body package="GlorpMappings" selector="initialize">initialize	super initialize.	shouldProxy := true.	shouldUseFilteredRead := false.	usesLinkTable := false.	controlsTables := true.	isExclusive := false.</body><body package="GlorpMappings" selector="initializeJoin">initializeJoin	"We haven't been given a join. There might be a compound one, or else see if we can make an educated guess at one"	linkTableJoin notNil ifTrue: [join := linkTableJoin, targetTableJoin. ^self].	self initializeJoinTo: self relatedTables.</body><body package="GlorpMappings" selector="initializeJoinTo:">initializeJoinTo: otherTables	"We haven't been giving a join. See if we can make an educated guess at one by looking for tables with constraints to us. If linkFields is set, it tells us the source field for the relationship between the link table and the target, so in looking for our own relationship to the link table, we exclude that."	| toConstraints fromConstraints |	self descriptor tables isEmpty ifTrue: [^self join: Join new].	(self referenceDescriptor tables isEmpty and: [self referenceDescriptor typeResolver usesInheritance]) ifTrue: [^self join: Join new].	toConstraints := self oneWayConstraintsFrom: self descriptor tables to: otherTables.	linkFields isNil ifFalse: [toConstraints := toConstraints reject: [:eachConstraint | eachConstraint targetFields anySatisfy: [:eachField | linkFields includes: eachField]]].	fromConstraints :=  self oneWayConstraintsFrom: otherTables to: self descriptor tables.	linkFields isNil ifFalse: [fromConstraints := fromConstraints reject: [:eachConstraint | eachConstraint sourceFields anySatisfy: [:eachField | linkFields includes: eachField]]].	self join: (self system joinFor: self toTables: otherTables fromConstraints: fromConstraints toConstraints: toConstraints).</body><body package="GlorpMappings" selector="oneWayConstraintsFrom:to:">oneWayConstraintsFrom: oneTableSet to: anotherTableSet	| matches |	matches := OrderedCollection new: 3.	oneTableSet do: [:eachFromTable |		 anotherTableSet do: [:eachToTable |			matches addAll:  (eachFromTable foreignKeyConstraints					select: [:eachConstraint | eachConstraint refersToTable: eachToTable])]].	^matches.</body><body package="GlorpMappings" selector="relatedTables">relatedTables	| otherTables possibleLinkTables |	otherTables := self basicReferenceDescriptor tables.	usesLinkTable ifFalse: [^otherTables].	linkFields isNil ifFalse: [^(linkFields collect: [:each | each table]) asSet asArray].	possibleLinkTables := self system allTables		select:			[:each | 			(each hasConstraintsToAnyOf: self descriptor tables)				and: [each hasConstraintsToAnyOf: otherTables]].	possibleLinkTables size ~= 1		ifTrue: [CannotAutomaticallyDetermineJoin new			tables: possibleLinkTables;			signal: 'Cannot automatically determine link table..'].	^possibleLinkTables.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>api</category><body package="GlorpMappings" selector="beExclusive">beExclusive	"Make this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted"	isExclusive := true.</body><body package="GlorpMappings" selector="constructRowMapKeyAs:">constructRowMapKeyAs: aBlock	"Give us the opportunity to construct a custom row map key. This is useful if you need to force two relationships to share a link table entry"	rowMapKeyConstructorBlock := aBlock.</body><body package="GlorpMappings" selector="isExclusive">isExclusive	"Return whether this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted"	^isExclusive.</body><body package="GlorpMappings" selector="isExclusive:">isExclusive: aBoolean	"Set whether this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted"	isExclusive := aBoolean.</body><body package="GlorpMappings" selector="linkField:">linkField: aDatabaseField	linkFields := Array with: aDatabaseField.</body><body package="GlorpMappings" selector="linkFields">linkFields	^linkFields.</body><body package="GlorpMappings" selector="linkFields:">linkFields: aCollection	"Set the fields that are foreign keys *from* the link table (this is only used if we have one) to the *target* table. This is used as a hint in the case where the link table is ambiguous, and is easier than specifying the full join."	linkFields := aCollection.</body><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:">referencedIndependentObjectsFrom: anObject	| value |	self canWrite ifFalse: [^#()].	value := self getValueFrom: anObject.	value == nil ifTrue: [^#()].	^Array with: value.</body><body package="GlorpMappings" selector="relevantLinkTableFields">relevantLinkTableFields	^linkFields.</body><body package="GlorpMappings" selector="relevantLinkTableFields:">relevantLinkTableFields: aCollection	linkFields := aCollection.</body><body package="GlorpMappings" selector="shouldUseFilteredRead">shouldUseFilteredRead	^shouldUseFilteredRead.</body><body package="GlorpMappings" selector="shouldUseFilteredRead:">shouldUseFilteredRead: aBoolean	shouldUseFilteredRead := aBoolean.</body><body package="GlorpMappings" selector="useFilteredRead">useFilteredRead	shouldUseFilteredRead := true.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>processing</category><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	"Currently we don't trace relationships across tables, so all we do hereis accumulate the list of embedded mappings"	| newContext |	(aTracing tracesThrough: self) ifFalse: [^self].	newContext := anExpression get: self attributeName.	aTracing addExpression: newContext.	self referenceDescriptor trace: aTracing context: newContext.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>preparing</category><body package="GlorpMappings" selector="joinExpressionFor:">joinExpressionFor: targetExpression	"We're looking for the object represented by this mapping, and we know the object represented by its source. Use our mapping criteria to construct a join that traverses that instance of this relationship"	| sourceExpression |	(self controlsTables not and: [self classModel describedClass == Association]) ifTrue: [^nil].	sourceExpression := targetExpression base.	^self extendedJoinFromSource: sourceExpression toTarget: targetExpression.</body><body package="GlorpMappings" selector="multipleTableExpressionsFor:">multipleTableExpressionsFor: anExpression	^self referenceDescriptor multipleTableJoin		collect: [:each | each asExpressionJoiningSource: anExpression toTarget: anExpression]</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="targetTables">targetTables	^((self usesLinkTable ifTrue: [self reverseJoin] ifFalse: [self join]) allTargetFields collect: [:each | each table]) asSet.</body><body package="GlorpMappings" selector="validate">validate	| targetJoinSourceFields targetJoinTargetTables |	super validate.	self join isNil ifTrue: [^self].	targetJoinSourceFields := targetTableJoin isNil ifTrue: [#()] ifFalse: [targetTableJoin allSourceFields].	targetJoinTargetTables :=  targetTableJoin isNil ifTrue: [#()] ifFalse: [targetTableJoin allTargetFields collect: [:each | each table]].	(self join allSourceFields asArray, targetJoinSourceFields)		do:			[:each | 			(each class == DatabaseField or: [each isKindOf: FunctionExpression]) 				ifTrue: [(self descriptor tables includes: each table)					ifFalse: [self error: 'Joins should go from the table(s) associated with this descriptor to the other table(s)']]].	(self targetTables asArray, targetJoinTargetTables)		do:			[:each | 			(self referenceDescriptor allTables includes: each)				ifFalse:					[self						error:							'Joins should go to the table(s) associated with the reference class of the mapping']].	join allSourceFields asSet size = join allSourceFields size ifFalse: [self error: 'The same field occurs twice in the join. This might be legal, but is probably a cut and paste error.'].	join allTargetFields asSet size = join allTargetFields size ifFalse: [self error: 'The same field occurs twice in the join. This might be legal, but is probably a cut and paste error.'].	(self isExclusive and: [self canWrite not]) ifTrue: [self error: 'It is not meaningful to have an exclusive relationship that is read-only.'].</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>proxies</category><body package="GlorpMappings" selector="queryFor:">queryFor: anObjectBuilder 	"If we have a specific query we should use in this case, rather than our general one, construct it. Right now that only applies if we're using filtered reads"	| basicQuery collection primaryKey newQuery cachedQuery filterBlock |	self shouldUseFilteredRead 		ifFalse: [^self query].	cachedQuery := anObjectBuilder cachedQueryFor: self.	cachedQuery isNil 		ifTrue: 			[basicQuery := self buildGeneralQueryIn: anObjectBuilder.			self query tracing alsoFetchExpressions 				do: [:each | basicQuery alsoFetch: each].			collection := GlorpVirtualCollection new setQuery: basicQuery]		ifFalse: [collection := cachedQuery collection].	primaryKey := anObjectBuilder primaryKey.	filterBlock := self descriptor keyFields size = 1 				ifTrue: [[:objects :parameters | (objects at: 1) = primaryKey]]				ifFalse: 					[					[:objects :parameters | 					(1 to: primaryKey size) inject: true						into: [:sum :i | sum and: [(primaryKey at: i) = (objects at: i)]]]].	newQuery := FilteringQuery on: collection filter: filterBlock.	newQuery collectBlock: [:each | each last].	newQuery readsOneObject: self attribute isCollectionAttribute not.	newQuery collectionType: self collectionType.	anObjectBuilder cachedQueryFor: self is: newQuery.	^newQuery</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>private/expressions</category><body package="GlorpMappings" selector="constraints">constraints	"Return a list of the constraints from our link table. If the linkField is set, filter the constraints to those that include that field. "	| referenceKeys linkTable referenceTables allConstraints relevantConstraints |	referenceKeys := (self join) targetKeys asOrderedCollection.	linkTable := referenceKeys first table.	"If we haven't been told the relevant link table fields, assume we can find them by looking at all the ones that aren't the ones from our source to the link, and all the rest will be from the link to the target"	allConstraints := linkTable foreignKeyConstraints.	relevantConstraints := linkFields isNil 		ifTrue: [allConstraints reject: [:each |  each sourceFields allSatisfy: [:eachSourceField |			(referenceKeys includes: eachSourceField)]]]		ifFalse: [allConstraints select: [:each | each sourceFields anySatisfy: [:eachSourceField |			linkFields includes: eachSourceField]]].	"Validate that we can handle this case"	referenceTables := (relevantConstraints collect: [:each | each targetTable]) asSet.	referenceTables size &gt; 1 ifTrue: [self error: 'Cannot handle this general a case. Try hinting using relevantLinkTableFields:'].	referenceTables size = 0 ifTrue: [self error: 'No tables found. Did you set up foreign key references in the table definitions?'].	^relevantConstraints.</body><body package="GlorpMappings" selector="expressionFromLinkToReferenceTableWithBase:">expressionFromLinkToReferenceTableWithBase: base	| reverse |	reverse := self reverseJoin asGlorpExpressionOn: base.	^reverse asGeneralGlorpExpressionWithFields.</body><body package="GlorpMappings" selector="joinFromLinkToReferenceTable">joinFromLinkToReferenceTable	"Generate the inverse mapping expression, i.e. the one connecting the link table to the reference table, using the foreign key constraints. We assume that if there's a general part, it applies only to the original join, and not to the reverse join that we're generating."	| expression generalPart |	expression := Join new.	self constraints do: [:eachConstraint | 		eachConstraint sourceFields with: eachConstraint targetFields do: 			[:eachSource :eachTarget |				expression addSource: eachSource target: eachTarget]].	generalPart := self join generalExpressionPart.	^generalPart isNil ifTrue: [expression] ifFalse: [generalPart AND: expression].</body><body package="GlorpMappings" selector="singleJoinFromLinkToReferenceTableForConstraints:">singleJoinFromLinkToReferenceTableForConstraints: constraints	"Generate the inverse mapping expression, i.e. the one connecting the link table to the reference table, using the foreign key constraints. We assume that if there's a general part, it applies only to the original join, and not to the reverse join that we're generating."	| expression generalPart |	expression := Join new.	constraints do: [:eachConstraint | 		eachConstraint sourceFields with: eachConstraint targetFields do: 			[:eachSource :eachTarget |				expression addSource: eachSource target: eachTarget]].	generalPart := self join generalExpressionPart.	^generalPart isNil ifTrue: [expression] ifFalse: [generalPart AND: expression].</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="controlsTables">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^false</body><body package="GlorpMappings" selector="isStoredInSameTable">isStoredInSameTable	^true</body><body package="GlorpMappings" selector="shouldProxy">shouldProxy	^false.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>transformations</category><body package="GlorpMappings" selector="defaultTransformationExpressionFor:">defaultTransformationExpressionFor: aDescriptor 	"If there's no transformation, get all the mapped fields from the other descriptor and construct a transformation of each onto itself. This lets us unify the fields in my row with the fields in its row"	| fields transform |	fields := IdentitySet new.	aDescriptor mappings do: [:each | fields addAll: each mappedFields].	transform := Join new.	fields do: [:each | transform addSource: each target: each].	^transform</body><body package="GlorpMappings" selector="hasTransformation">hasTransformation	^false.</body><body package="GlorpMappings" selector="transformationExpression">transformationExpression	^self hasFieldTranslation		ifTrue: [fieldTranslation]		ifFalse: [fieldTranslation := self defaultTransformationExpressionFor: (self referenceDescriptor)].</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="fieldTranslation">fieldTranslation	^fieldTranslation</body><body package="GlorpMappings" selector="fieldTranslation:">fieldTranslation: aPrimaryKeyExpression 	fieldTranslation := aPrimaryKeyExpression</body><body package="GlorpMappings" selector="hasFieldTranslation">hasFieldTranslation	^fieldTranslation notNil.</body><body package="GlorpMappings" selector="join">join	^nil.</body><body package="GlorpMappings" selector="join:">join: anExpression	self error: 'Embedded mappings do not use joins'.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="knitFromBuilder:toBuilder:">knitFromBuilder: sourceBuilder toBuilder: targetBuilder 	sourceBuilder requiresPopulating ifFalse: [^self].	super knitFromBuilder: sourceBuilder toBuilder: targetBuilder</body><body package="GlorpMappings" selector="mapFromObject:toTarget:puttingRowsIn:">mapFromObject: anObject toTarget: target puttingRowsIn: aRowMap 	self transformationExpression 		mapFromSource: anObject		andTarget: target		intoRowsIn: aRowMap.	self transformationExpression allTables do: [:eachTable |			aRowMap rowForTable: eachTable withKey: target ifPresent: [  :each |			each shouldBeWritten: false]].</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anElementBuilder	| myTraceNode myBuilder |	"If the object already has a value in my slot, then this it got a cache hit, the embedded value was carried along for the ride, and we don't need to assign anything"	(self getValueFrom: anObject) isNil ifFalse: [^self].	"Otherwise, we need to look up the trace node that corresponds to this mapping, and get its instance"	myTraceNode := anElementBuilder expression get: self attributeName.	myBuilder := anElementBuilder query elementBuilderFor: myTraceNode.	self setValueIn: anObject to: myBuilder instance.</body><body package="GlorpMappings" selector="reverseMapping"> reverseMapping	^self class new		attributeName: #temporaryReverseMappingForEmbeddedMapping;		referenceClass: self descriptor describedClass;		descriptor: self descriptor.</body><body package="GlorpMappings" selector="translateFields:">translateFields: anOrderedCollection 	fieldTranslation isNil ifTrue: [^anOrderedCollection].	^anOrderedCollection collect: [:each |		fieldTranslation sourceForTarget: each].</body><body package="GlorpMappings" selector="translateTable:">translateTable: aTable	"If we have a field translation, return the translated (i.e. real) table to use. This ideally allows us to use either the real table in which something is embedded, or the imaginary table"	fieldTranslation isNil ifTrue: [^aTable].	1 to: fieldTranslation allTargetFields size		do:			[:i | 			(fieldTranslation allTargetFields at: i) table == aTable				ifTrue: [^(fieldTranslation allSourceFields at: i) table]].	^aTable.</body><body package="GlorpMappings" selector="valueOfField:fromObject:ifNone:">valueOfField: aField fromObject: anObject ifNone: aBlock	| targetField target |	targetField := self transformationExpression targetForSource: aField.	targetField isNil ifTrue: [^aBlock value].	target := self getValueFrom: anObject.	^self referenceDescriptor valueOfField: targetField fromObject: target.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>internal</category><body package="GlorpMappings" selector="fieldsForSelectStatement">fieldsForSelectStatement	"Return a collection of fields that this mapping will read from a row"	"Return nothing, because our sub-objects will take care of adding their own fields, translated correctly through us."	^#().</body><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	fieldTranslation isNil ifFalse: [^fieldTranslation allSourceFields].	^self referenceDescriptor mappedFields.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>preparing</category><body package="GlorpMappings" selector="joinExpressionFor:">joinExpressionFor: targetExpression	"We're looking for the object represented by this mapping, and we know the object represented by its source. Use our mapping criteria to construct a join that traverses that instance of this relationship.	Embedded values never induce a join."	^nil.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>accessing</category><body package="GlorpQueries" selector="=">= anObject	"In VA we inherit this as identity. Need to override"	^anObject = self getValue.</body><body package="GlorpQueries" selector="isKindOf:">isKindOf: aClass	self isInstantiated ifTrue: [^value isKindOf: aClass].	^false</body><body package="GlorpQueries" selector="uninstantiate">uninstantiate	value := nil.	isInstantiated := false.</body><body package="GlorpQueries" selector="~=">~= anObject 	^(self = anObject) not</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>overrides</category><body package="GlorpQueries" selector="basicSize">basicSize	^self getValue basicSize.</body><body package="GlorpQueries" selector="hash">hash	^self getValue hash.</body><body package="GlorpQueries" selector="inspect">inspect	^self getValue inspect.</body><body package="GlorpQueries" selector="isImmutable">isImmutable	^self getValue isImmutable.</body><body package="GlorpQueries" selector="store">store	"For Object Studio compatibility"	^self inspectorString.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>printing</category><body package="GlorpQueries" selector="basicPrintOn:">basicPrintOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue basicPrintOn: aStream]		ifFalse: [aStream nextPutAll: 'uninstantiated proxy'].	aStream nextPut: $}</body><body package="GlorpQueries" selector="basicPrintString">basicPrintString	| aStream |	aStream := WriteStream on: String new.	self basicPrintOn: aStream.	^aStream contents</body><body package="GlorpQueries" selector="printOn:">printOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue printOn: aStream]		ifFalse: [aStream nextPutAll: 'uninstantiated proxy'].	aStream nextPut: $}</body><body package="GlorpQueries" selector="printString">printString	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>api</category><body package="GlorpQueries" selector="getValue">getValue	self subclassesMustImplement</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>notification</category><body package="GlorpQueries" selector="glorpPostFetch:">glorpPostFetch: aSession</body><body package="GlorpQueries" selector="glorpPostFetchValidate:">glorpPostFetchValidate: aSession</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>dnu handling</category><body package="GlorpQueries" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	^self getValue perform: aMessage selector withArguments: aMessage arguments.</body><body package="GlorpQueries" selector="doesNotUnderstand:args:">doesNotUnderstand: sel args: args 	"This is the variant for ObjectStudio"	^self getValue perform: sel withArguments: args.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>initialize</category><body package="GlorpQueries" selector="proxyInitialize">proxyInitialize	isInstantiated := false.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>testing</category><body package="GlorpQueries" selector="isGlorpProxy">isGlorpProxy	^true.</body><body package="GlorpQueries" selector="isInstantiated">isInstantiated	isInstantiated isNil ifTrue: [isInstantiated := false].	^isInstantiated</body></methods><methods><class-id>Glorp.AbstractProxy class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="new">new	^super new proxyInitialize.</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>accessing</category><body package="GlorpQueries" selector="class">class	^Proxy	"self isInstantiated ifTrue: [^value class].	query isNil ifTrue: [^Proxy].	query resultClass isNil ifTrue: [^Proxy].	^query resultClass."</body><body package="GlorpQueries" selector="isKindOf:">isKindOf: aClass	self isInstantiated ifTrue: [^value isKindOf: aClass].	query isNil ifTrue: [^false].	query resultClass isNil ifTrue: [^false].	query resultClass isBehavior ifFalse: [^false].	^query resultClass includesBehavior: aClass.</body><body package="GlorpQueries" selector="parameters">parameters	^parameters</body><body package="GlorpQueries" selector="parameters:">parameters: aDictionary	parameters := aDictionary.</body><body package="GlorpQueries" selector="query">query	^query</body><body package="GlorpQueries" selector="query:">query: aQuery 	query := aQuery</body><body package="GlorpQueries" selector="session">session	^session</body><body package="GlorpQueries" selector="session:">session: aSession 	session := aSession</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>printing</category><body package="GlorpQueries" selector="printOn:">printOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue printOn: aStream]		ifFalse: 			[aStream nextPutAll: 'uninstantiated '.			query isNil				ifTrue: [aStream nextPutAll: '???']				ifFalse: [					query readsOneObject ifFalse: [aStream nextPutAll: 'collection of '].					aStream nextPutAll: query resultClass name]].	aStream nextPut: $}</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>proxy actions</category><body package="GlorpQueries" selector="glorpOwner">glorpOwner	"Return the object for which this proxy was created. Note that this is not kept track of unless we have a proxy action."	action isNil ifTrue: [^nil].	^action key.</body><body package="GlorpQueries" selector="glorpOwner:">glorpOwner: anObject	"If we don't have an action, the owner is unnecessary. Ignore it. If we do have one, put it in as the key of an association with the action block following it."	action isNil ifTrue: [^self].	action key: anObject.</body><body package="GlorpQueries" selector="glorpProxyAction">glorpProxyAction	"Return the block we expect to evaluate when the proxy is fired."	action isNil ifTrue: [^nil].	^action value.</body><body package="GlorpQueries" selector="glorpProxyAction:">glorpProxyAction: aTwoArgumentBlock	"Set the action we'll take when the proxy fires. This is a two argument block that takes the owning object and the value of the proxy as arguments."	aTwoArgumentBlock isNil ifTrue: [^action := nil].	action := nil -&gt; aTwoArgumentBlock.</body><body package="GlorpQueries" selector="glorpTriggerProxyAction:">glorpTriggerProxyAction: target	"Evaluate our action with the owner and the newly retrieved target."	| owner block |	action isNil ifTrue: [^self].	owner := action key.	block := action value.	block value: owner value: target.</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>api</category><body package="GlorpQueries" selector="getValue">getValue	self isInstantiated ifTrue: [^value].	parameters isNil ifTrue: [parameters := Dictionary new: 0].	[value := query isNil		ifTrue: [nil]		ifFalse: [query executeWithParameters: parameters in: session]]		ensure: [isInstantiated := true].	self glorpTriggerProxyAction: value.	^value.</body></methods><methods><class-id>Glorp.Proxy class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="returningManyOf:where:">returningManyOf: aClass where: aBlock 	^self new query: (Query returningManyOf: aClass where: aBlock)</body><body package="GlorpQueries" selector="returningManyOf:where:in:">returningManyOf: aClass where: aBlock in: aSession		^self new 		query: (Query returningManyOf: aClass where: aBlock);		session: aSession</body><body package="GlorpQueries" selector="returningOneOf:where:">returningOneOf: aClass where: aBlock 	^self new query: (Query returningOneOf: aClass where: aBlock)</body><body package="GlorpQueries" selector="returningOneOf:where:in:">returningOneOf: aClass where: aBlock in: aSession		^self new 		query: (Query returningOneOf: aClass where: aBlock);		session: aSession.</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>converting</category><body package="GlorpExpressions" selector="asField">asField	"If we correspond to a single field, return it. This is a bit of a hack having this only here, because for some functions it doesn't work."	^self.</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>preparing</category><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."		| newArguments |	newArguments := arguments collect: [:each | each asExpressionJoiningSource: source toTarget: target].	^(super asExpressionJoiningSource: source toTarget: target) arguments: newArguments.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuilt newArgs |	self == anExpression ifTrue: [^aBaseExpression].	base == aBaseExpression ifTrue: [^self].	newArgs := arguments collect: [:each | each rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression].	rebuilt := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) get: self symbol withArguments: newArgs.	rebuilt alias: self alias.	^rebuilt.</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>printing</category><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	| translated |	base printSQLOn: aStream withParameters: aDictionary.	self printsIntoJoins ifFalse: [^self].	1 to: self functionParts size do: [:i |		aStream 			nextPut: $ ;			nextPutAll: (self functionParts at: i);			nextPut: $ .		i &gt; arguments size ifFalse: [ 			translated := self convertValueOf: (arguments at: i) in: aDictionary.			translated isGlorpExpression				ifTrue: [translated printSQLOn: aStream withParameters: aDictionary]				ifFalse: [self type print: translated on: aStream]]].</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	base printOn: aStream.	aStream		nextPutAll: ' ', function, ' '.	arguments printOn: aStream.</body><body package="GlorpExpressions" selector="printUnqualifiedSQLOn:withParameters:">printUnqualifiedSQLOn: aStream withParameters: aDictionary	base printUnqualifiedSQLOn: aStream withParameters: aDictionary.	self functionParts with: arguments do: [:functionPart :arg |		aStream 			nextPut: $ ;			nextPutAll: functionPart;			nextPut: $ .		arg printUnqualifiedSQLOn: aStream withParameters: aDictionary].</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>accessing</category><body package="GlorpExpressions" selector="argument">argument	^arguments first.</body><body package="GlorpExpressions" selector="argument:">argument: anObject	arguments := Array with: anObject.</body><body package="GlorpExpressions" selector="arguments">arguments	^arguments.</body><body package="GlorpExpressions" selector="arguments:">arguments: anArray	arguments := anArray.</body><body package="GlorpExpressions" selector="functionParts">functionParts	functionParts isNil ifTrue: [functionParts := Array with: function].	^functionParts.</body><body package="GlorpExpressions" selector="functionParts:">functionParts: anArray	functionParts := anArray.</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	super do: aBlock skipping: aSet.	arguments do: [:each | each do: aBlock skipping: aSet].</body></methods><methods><class-id>Glorp.InfixFunction class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="named:">named: aStringOrArray	| instance trimmedName |	instance := self new.	aStringOrArray isString		ifTrue: [instance function: aStringOrArray]		ifFalse: [			instance functionParts: aStringOrArray.			trimmedName := aStringOrArray copyFrom: 2 to: aStringOrArray size.			instance function: (trimmedName inject: aStringOrArray first into: [:sum :each | sum, ' ', each])].	^instance.</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>initializing</category><body package="GlorpUnitOfWork" selector="initialize">initialize	self initializeUndoMap.</body><body package="GlorpUnitOfWork" selector="initializeUndoMap">initializeUndoMap	undoMap := IdentityDictionary new: 1000.	collectionMementos := IdentityDictionary new: 200.</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>begin/commit/abort</category><body package="GlorpUnitOfWork" selector="abort">abort	undoMap keysAndValuesDo: [:original :copy | self restoreStateOf: original toThatOf: copy]</body><body package="GlorpUnitOfWork" selector="abort:">abort: original	| copy |	copy := undoMap at: original ifAbsent: [^self].	self restoreStateOf: original toThatOf: copy</body><body package="GlorpUnitOfWork" selector="begin">begin	self initializeUndoMap</body><body package="GlorpUnitOfWork" selector="commit">commit	self initializeUndoMap</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="collectionMementoFor:">collectionMementoFor: anObject	anObject isNil ifTrue: [^#()].	^collectionMementos at: anObject ifAbsent: [self mementoFor: anObject].</body><body package="GlorpUnitOfWork" selector="collectionMementos">collectionMementos	^collectionMementos.</body><body package="GlorpUnitOfWork" selector="mementoFor:">mementoFor: anObject	^undoMap at: anObject.</body><body package="GlorpUnitOfWork" selector="undoMap">undoMap	^undoMap</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>private/registering</category><body package="GlorpUnitOfWork" selector="shallowCopyOf:ifNotNeeded:">shallowCopyOf: anObject ifNotNeeded: aBlock	| copy |	copy := anObject shallowCopy.	^copy == anObject 		ifTrue: [aBlock value]		ifFalse: [copy]</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>private/restoring</category><body package="GlorpUnitOfWork" selector="isShapeOf:differentThanThatOf:">isShapeOf: original differentThanThatOf: copy	^original class ~~ copy class or: [original glorpBasicSize ~= copy glorpBasicSize]</body><body package="GlorpUnitOfWork" selector="restoreIndexedInstanceVariablesOf:toThoseOf:">restoreIndexedInstanceVariablesOf: original toThoseOf: copy	copy glorpStartOfIndexedInstVars to: copy glorpEndOfIndexedInstVars do: [:index |		original isString 			ifTrue: [original at: index put: (copy at: index)]			ifFalse: [original basicAt: index put: (copy basicAt: index)]].</body><body package="GlorpUnitOfWork" selector="restoreNamedInstanceVariablesOf:toThoseOf:">restoreNamedInstanceVariablesOf: original toThoseOf: copy	1 to: copy class instSize do: [:index |		original instVarAt: index put: (copy instVarAt: index)]</body><body package="GlorpUnitOfWork" selector="restoreShapeOf:toThatOf:">restoreShapeOf: original toThatOf: copy	| newOriginal |	(copy class isBits or: [copy class isVariable])		ifTrue: [newOriginal := copy class basicNew: copy glorpBasicSize]		ifFalse: [newOriginal := copy class basicNew].	original become: newOriginal.</body><body package="GlorpUnitOfWork" selector="restoreStateOf:toThatOf:">restoreStateOf: original toThatOf: copy 	(self isShapeOf: original differentThanThatOf: copy) 		ifTrue: [self restoreShapeOf: original toThatOf: copy].	self restoreNamedInstanceVariablesOf: original toThoseOf: copy.	self restoreIndexedInstanceVariablesOf: original toThoseOf: copy</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>registering</category><body package="GlorpUnitOfWork" selector="isRegistered:">isRegistered: anObject 	"Note: We can never have a situation where a proxy is registered but its contents aren't, so we don't have to worry about that ambiguous case."	| realObject |	realObject := self realObjectFor: anObject ifNone: [^false].	^undoMap includesKey: realObject.</body><body package="GlorpUnitOfWork" selector="needsCollectionMementoFor:">needsCollectionMementoFor: aCollection	"We can avoid the need for a collection copy if the collection has no internal structure - that is, if we'll be able to loop over a simple shallow copy. This is dialect and collection class dependent"	^Dialect needsCollectionMementoFor: aCollection.</body><body package="GlorpUnitOfWork" selector="realObjectFor:">realObjectFor: anObject 	"If this is a proxy, return the contents (if available). Otherwise, return nil"	^self realObjectFor: anObject ifNone: [nil].</body><body package="GlorpUnitOfWork" selector="realObjectFor:ifNone:">realObjectFor: anObject ifNone: aBlock	"If this is a proxy, return the contents (if available). Otherwise, evaluate the block"	^anObject isGlorpProxy 		ifTrue: [anObject isInstantiated ifTrue: [anObject getValue] ifFalse: [aBlock value]]		ifFalse: [anObject]</body><body package="GlorpUnitOfWork" selector="register:">register: anObject 	"Make anObject be a member of the current transaction. Return the object if registered, or nil otherwise"	| copy realObject |	(self requiresRegistrationFor: anObject) ifFalse: [^nil].	realObject := self realObjectFor: anObject ifNone: [^nil].	copy := self shallowCopyOf: realObject ifNotNeeded: [^nil].	undoMap at: realObject put: copy.	self registerTransientInternalsOfCollection: realObject.	^realObject</body><body package="GlorpUnitOfWork" selector="registeredObjectsDo:">registeredObjectsDo: aBlock	"Iterate over all our objects. Note that this will include objects without descriptors. Be sure we're iterating over a copy of the keys, because this will add objects to the undoMap. Allow the block to return a collection which we will then add to the list of things to process, until there's nothing further"	| newAdditions previousVersion |	newAdditions := undoMap keys.	previousVersion := newAdditions.	[newAdditions isEmpty]		whileFalse:			[newAdditions do: aBlock.			newAdditions := OrderedCollection new.			undoMap				keysDo:					[:eachKey | (previousVersion includes: eachKey) ifFalse: [newAdditions add: eachKey]].			newAdditions isEmpty ifFalse: [previousVersion := undoMap keys]].</body><body package="GlorpUnitOfWork" selector="registerTransientInternalsOfCollection:">registerTransientInternalsOfCollection: aCollection	"If this is a collection, then we may need to register any internal structures it has, e.g. an internal array. This is implementation dependent for the collection. We will also explicitly exclude strings"	aCollection glorpIsCollection ifFalse: [^self].	aCollection class isBits ifTrue: [^self].	(self needsCollectionMementoFor: aCollection)		ifTrue: [collectionMementos at: aCollection put: aCollection copy].	aCollection glorpRegisterCollectionInternalsIn: self."For this to work, the dialect must not copy collections so shallowly that internals are reused identically.In VW, Dictionary copy calls postCopy, which copies the associations or value collection (but not thekeys).  Without this, mementos added to the original would also be added to the copy.  In VA, sendingcopy to a Dictionary does a shallow copy.  In VA, inline the call of copy to shallowCopy and send thepostCopy call to it explicitly to get the behaviour we need without changing Dictionary copy behaviourin VA, which might have side-effects.  This feature's tests have been altered to check this copy safety."</body><body package="GlorpUnitOfWork" selector="requiresRegistrationFor:">requiresRegistrationFor: anObject	| realObject |	realObject := self realObjectFor: anObject ifNone: [^false].	^(self isRegistered: realObject) not.</body></methods><methods><class-id>Glorp.ObjectTransaction class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="new">new	^super new initialize</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>executing</category><body package="GlorpDatabase" selector="executeBoundIn:">executeBoundIn: anAccessor	^anAccessor executeCommandBound: self.</body><body package="GlorpDatabase" selector="executeUnboundIn:">executeUnboundIn: anAccessor	^anAccessor executeCommandUnbound: self.</body><body package="GlorpDatabase" selector="printSQL">printSQL	self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>stream behaviour</category><body package="GlorpDatabase" selector="contents">contents	^stream contents.</body><body package="GlorpDatabase" selector="cr">cr	stream cr.</body><body package="GlorpDatabase" selector="nextPut:">nextPut: aCharacter	^stream nextPut: aCharacter.</body><body package="GlorpDatabase" selector="nextPutAll:">nextPutAll: aString	^stream nextPutAll: aString.</body><body package="GlorpDatabase" selector="nextPutString:">nextPutString: aString	^self nextPutAll: aString.</body><body package="GlorpDatabase" selector="policy">policy	^stream policy.</body><body package="GlorpDatabase" selector="print:">print: anObject	anObject printOn: self</body><body package="GlorpDatabase" selector="space">space	stream space.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="arrayBoundFields">arrayBoundFields	self subclassResponsibility</body><body package="GlorpDatabase" selector="bindings">bindings	self subclassResponsibility.</body><body package="GlorpDatabase" selector="bindingTypes">bindingTypes	self subclassResponsibility.</body><body package="GlorpDatabase" selector="bindingTypesForEXDI">bindingTypesForEXDI	^self bindingTypes collect: [:each | each exdiType].</body><body package="GlorpDatabase" selector="blockFactor">blockFactor	^5  "A reasonable default if we don't know"</body><body package="GlorpDatabase" selector="maximumLobSizeToRetrieveDirectly">maximumLobSizeToRetrieveDirectly	^32768.</body><body package="GlorpDatabase" selector="parameterTypeSignature">parameterTypeSignature	self subclassResponsibility.</body><body package="GlorpDatabase" selector="platform:">platform: aDatabasePlatform	self error: 'This API is obsolete. Pass the session instead'.</body><body package="GlorpDatabase" selector="query">query	^nil.</body><body package="GlorpDatabase" selector="session">session	^session.</body><body package="GlorpDatabase" selector="signature">signature	^self sqlString, self parameterTypeSignature.</body><body package="GlorpDatabase" selector="sqlString">sqlString	sqlString isNil ifTrue: [		stream isNil ifTrue: [stream := WriteStream on: (String new: 100)].		self printSQL.		sqlString := stream contents.		stream := nil].	^sqlString.</body><body package="GlorpDatabase" selector="system">system	self session isNil ifTrue: [^nil].	^self session system.</body><body package="GlorpDatabase" selector="useBinding">useBinding	^useBinding</body><body package="GlorpDatabase" selector="useBinding:">useBinding: aBoolean	useBinding := aBoolean</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>testing</category><body package="GlorpDatabase" selector="canBind:to:">canBind: aValue to: aType	useBinding ifFalse: [^false].	^self platform canBind: aValue to: aType underlyingType.</body><body package="GlorpDatabase" selector="hasMultipleRows">hasMultipleRows	^false.</body><body package="GlorpDatabase" selector="isReadCommand">isReadCommand	^false.</body><body package="GlorpDatabase" selector="needsRowCount">needsRowCount 	^false.</body><body package="GlorpDatabase" selector="shouldUseGroupWriting">shouldUseGroupWriting	^(self hasMultipleRows and: [self platform supportsGroupWritingFor: self])</body><body package="GlorpDatabase" selector="succeeded">succeeded	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>initializing</category><body package="GlorpDatabase" selector="initialize">initialize	useBinding := true.	stream := WriteStream on: (String new: 100).</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>reporting</category><body package="GlorpDatabase" selector="tables">tables	"Return a list of the tables we will affect"	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>As yet unclassified</category><body package="GlorpDatabase" selector="platform">platform	self session isNil ifTrue: [^nil].	^self session platform.</body><body package="GlorpDatabase" selector="session:">session: aGlorpSession	session := aGlorpSession.</body></methods><methods><class-id>Glorp.DatabaseCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.SelectCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="blockFactor:">blockFactor: anInteger	blockFactor := anInteger.</body><body package="GlorpDatabase" selector="parameters">parameters	^parameters</body><body package="GlorpDatabase" selector="parameters:">parameters: aDictionary	parameters := aDictionary</body><body package="GlorpDatabase" selector="parameterTypeSignature">parameterTypeSignature	| result |	result := WriteStream on: String new.	self bindings do: [:each | result nextPutAll: each class name].	^result contents.</body><body package="GlorpDatabase" selector="printSQL">printSQL	self subclassResponsibility.</body></methods><methods><class-id>Glorp.SelectCommand</class-id> <category>testing</category><body package="GlorpDatabase" selector="canBind:to:">canBind: aValue to: aType	aValue isNil ifTrue: [^false].	^super canBind: aValue to: aType.</body><body package="GlorpDatabase" selector="isReadCommand">isReadCommand	^true.</body><body package="GlorpDatabase" selector="succeeded">succeeded	^true.</body></methods><methods><class-id>Glorp.SelectCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="forQuery:parameters:">forQuery: aQuery parameters: aDictionary	^(self new)		query: aQuery;		parameters: aDictionary;		yourself.</body><body package="GlorpDatabase" selector="forQuery:parameters:useBinding:session:">forQuery: aQuery parameters: aDictionary useBinding: aBoolean session: aSession	^(self new)		query: aQuery;		parameters: aDictionary;		useBinding: aBoolean;		session: aSession;		yourself.</body></methods><methods><class-id>Glorp.QuerySelectCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="bindings">bindings	self useBinding ifFalse: [^#()].	boundExpressions isNil ifTrue: [self findBoundExpressions].	^boundExpressions collect: [:each | each bindingIn: self].</body><body package="GlorpDatabase" selector="bindingTypes">bindingTypes	self useBinding ifFalse: [^#()].	boundExpressions isNil ifTrue: [self findBoundExpressions].	^boundExpressions collect: [:each | each bindingType].</body><body package="GlorpDatabase" selector="blockFactor">blockFactor	blockFactor isNil ifTrue: [blockFactor := query expectedRows].	^blockFactor.</body><body package="GlorpDatabase" selector="boundExpressions">boundExpressions	^boundExpressions</body><body package="GlorpDatabase" selector="boundExpressions:">boundExpressions: anObject	boundExpressions := anObject</body><body package="GlorpDatabase" selector="findBoundExpressions">findBoundExpressions	self useBinding ifFalse: [^nil].	boundExpressions := OrderedCollection new.	query addBoundExpressionsIn: self to: boundExpressions.</body><body package="GlorpDatabase" selector="maximumLobSizeToRetrieveDirectly">maximumLobSizeToRetrieveDirectly	^query isNil		ifTrue: [super maximumLobSizeToRetrieveDirectly]		ifFalse: [query maximumLobSizeToRetrieveDirectly].</body><body package="GlorpDatabase" selector="printSQL">printSQL	stream nextPutAll: 'SELECT '.	query printSelectFieldsOn: self.	self findBoundExpressions.	query printTablesOn: self.	query printWhereClauseOn: self.	query printJoinsOn: self.	query printGroupByOn: self.	query printOrderingOn: self.	query printPostLimitOn: self.	query printOffsetOn: self.</body><body package="GlorpDatabase" selector="query">query	^query.</body><body package="GlorpDatabase" selector="query:">query: aQuery	query := aQuery.</body></methods><methods><class-id>Glorp.QuerySelectCommand</class-id> <category>printing</category><body package="GlorpDatabase" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	query printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.QuerySelectCommand</class-id> <category>reporting</category><body package="GlorpDatabase" selector="tables">tables	^(self query tablesToPrint collect: [:each | each parent]) asSet.</body></methods><methods><class-id>Glorp.CompoundSelectCommand</class-id> <category>accessing</category><body package="GlorpCore" selector="arrayBoundFields">arrayBoundFields	" *** This method was defined by Glorp.DatabaseCommand as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpCore" selector="bindings">bindings	^commands inject: #() into: [:sum :each | sum, each bindings].</body><body package="GlorpCore" selector="bindingTypes">bindingTypes	^self commands inject: #() into: [:sum :each | sum, each bindingTypes].</body><body package="GlorpCore" selector="commands">commands	commands isNil ifTrue: [commands := query queries collect: [:each | each sqlWith: parameters]].	^commands.</body><body package="GlorpCore" selector="parameters:">parameters: aDictionary	parameters := aDictionary.	commands := nil.</body><body package="GlorpCore" selector="printSQL">printSQL	self nextPutAll: 'SELECT '.	self requiresDistinct ifTrue: [self nextPutAll: 'DISTINCT '].	self nextPutAll: '* FROM '.	self platform supportsAliasInCompoundQuery ifTrue: [self nextPut: $(].	GlorpHelper 		do: [:each | 			self platform parenthesizeCommandsInCompoundQuery ifTrue: [self nextPut: $(].			self nextPutAll: each sqlString.			self platform parenthesizeCommandsInCompoundQuery ifTrue: [self nextPut: $)]]		for: self commands		separatedBy: [query printOperationOn: self].	self platform supportsAliasInCompoundQuery ifTrue: [self nextPut: $)].	query printCompoundSelectAliasesOn: self.	query printOrderingOn: self.	query printGroupByOn: self.</body><body package="GlorpCore" selector="requiresDistinct">requiresDistinct	^self query requiresDistinct.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'blob'</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>types</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	(aClass includesBehavior: String) ifTrue: [^self platform converterNamed: #byteArrayToString].	self platform isPostgreSQLPlatform ifTrue: [^self platform converterNamed: #byteArrayToSQLString].	self platform isOcelotPlatform ifTrue: [^self platform converterNamed: #blobDataToStream].	^self platform nullConverter</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^ByteArray.</body><body package="GlorpDatabaseTypes" selector="queryType">queryType	"Return the type that we can cast an argument to in order to match against this"	queryType isNil ifTrue: [^self].	^queryType.</body><body package="GlorpDatabaseTypes" selector="queryType:">queryType: aType	"Set the type that we can cast an argument to in order to match against this"	queryType := aType.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#ByteArray.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="print:on:">print: aValue on: aStream	self platform printBlob: (aValue isNil ifTrue: [nil] ifFalse: [aValue asByteArray]) on: aStream for: self.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes" selector="=">= aType	super = aType ifFalse: [^false].	self queryType == self ifTrue: [^true].	self queryType = aType queryType		 ifFalse: [^false].	^true.</body><body package="GlorpDatabaseTypes" selector="hash">hash	^self queryType == self		ifTrue: [super hash]		ifFalse: [super hash bitXor: self queryType hash]</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="requiresConvertToVarbinary">requiresConvertToVarbinary	"This is a hack for testing against SQL Server"	^true.</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>testing</category><body package="GlorpMisc" selector="ancestorOf:">ancestorOf: anExceptionThingy	"VA Compatibility"	^self handles: anExceptionThingy</body><body package="GlorpMisc" selector="isResumable">isResumable	^self class mayResume.</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>accessing</category><body package="GlorpMisc" selector="databaseError">databaseError"rh 8/1/2004 21:26 for #getMessageText"	^self class name</body><body package="GlorpMisc" selector="getMessageText">getMessageText	"This is horribly ugly. Not only are dialects inconsistent, but behaviour between types of exceptions is inconsistent within dialects"		Dialect isVisualWorks ifTrue: [^self getVisualWorksMessageText].	Dialect isVisualAge ifTrue: [^self getVisualAgeMessageText].	Dialect isSqueak ifTrue: [^self databaseError].	^self printString.</body><body package="GlorpMisc" selector="getVisualAgeMessageText">getVisualAgeMessageText		| tempTag |	tempTag := self basicTag.	^tempTag isNil ifTrue: [self printString] ifFalse: [tempTag errorText].</body><body package="GlorpMisc" selector="getVisualWorksMessageText">getVisualWorksMessageText	"In VisualWorks, we often get arrays of ExternalDatabaseExceptions, whose parameter is an array of ExternalDatabaseError objects. Or we might just get an exception, or we might get nil or something else entirely, in which case we fall back to a default error message."	| dbError |	self databaseError isNil ifTrue: [^messageText := self defaultMessageText].	dbError := self databaseError.	dbError glorpIsCollection ifTrue: [dbError := dbError first].	messageText := [dbError dbmsErrorString] on: Error do: [:ex | 		ex return: ([dbError messageText] on: Error do: [:anotherEx |			anotherEx return: self defaultMessageText])].	^messageText.</body><body package="GlorpMisc" selector="messageText">messageText	(messageText isNil or: [messageText isEmpty]) ifTrue: [		messageText := self getMessageText].	^messageText.</body><body package="GlorpMisc" selector="session">session	"We don't know what our session is, return nil by default."	^nil.</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>ANSI</category><body package="GlorpMisc" selector="signal">signal	"VisualWorks has non-ANSI semantics for this method. Re-implement to do the standard thing"	^Dialect isVisualWorks ifTrue: [self raise] ifFalse: [super signal].</body><body package="GlorpMisc" selector="signal:">signal: aString	"VisualWorks has non-ANSI semantics for this method. Re-implement to do the standard thing"	^Dialect isVisualWorks		ifTrue:			[self messageText: aString.			self raise]		ifFalse: [super signal: aString].</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>printing</category><body package="GlorpMisc" selector="description">description	"Make sure that we've populated our messageText before calling the superclass implementation."	self getMessageText.	^super description.</body></methods><methods><class-id>Glorp.GlorpError class</class-id> <category>exception compatibility</category><body package="GlorpMisc" selector="ancestorOf:">ancestorOf: anExceptionThingy	"VA Compatibility"	^self exceptionalEvent handles: anExceptionThingy</body><body package="GlorpMisc" selector="description">description	"For ObjectStudio"	^super description.</body></methods><methods><class-id>Glorp.GlorpError class</class-id> <category>ANSI</category><body package="GlorpMisc" selector="signal">signal	^self new signal.</body><body package="GlorpMisc" selector="signal:">signal: aString	^self new signal: aString.</body></methods><methods><class-id>Glorp.GlorpError class</class-id> <category>testing</category><body package="GlorpMisc" selector="mayResume">mayResume	"This is a VisualWorks convention. Reimplement this here so that it will also be found in other dialects that don't have it in the superclass."	^false</body></methods><methods><class-id>Glorp.ValidationError</class-id> <category>accessing</category><body package="GlorpMisc" selector="model">model	^self parameter</body><body package="GlorpMisc" selector="model:">model: aClass	self parameter: aClass</body></methods><methods><class-id>Glorp.ValidationError</class-id> <category>printing</category><body package="GlorpMisc" selector="description">description	^self messageText</body></methods><methods><class-id>Glorp.ValidationError class</class-id> <category>testing</category><body package="GlorpMisc" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Glorp.NoTableFound</class-id> <category>printing</category><body package="GlorpMisc" selector="printOn:">printOn: aStream	aStream nextPutAll: self messageText</body></methods><methods><class-id>Glorp.NoTableFound</class-id> <category>accessing</category><body package="GlorpMisc" selector="expectedTables">expectedTables	^expectedTables</body><body package="GlorpMisc" selector="expectedTables:">expectedTables: aCollection	expectedTables := aCollection</body><body package="GlorpMisc" selector="messageText">messageText	self model isString ifTrue: [^'No table &lt;1s&gt; found' expandMacrosWith: self model].	^'No table found for &lt;1s&gt;, expected to see one of  &lt;2s&gt;' expandMacrosWith: self model name with: self expectedTables printString</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>api</category><body package="GlorpMappings" selector="collectionType">collectionType	^self attribute collectionType.</body><body package="GlorpMappings" selector="collectionType:">collectionType: aClass	self attribute collectionType: aClass.</body><body package="GlorpMappings" selector="orderBy">orderBy	^orderBy.</body><body package="GlorpMappings" selector="orderBy:">orderBy: aBlockOrSelector	orderBy isNil ifTrue: [orderBy := OrderedCollection new].	orderBy add: aBlockOrSelector.</body><body package="GlorpMappings" selector="shouldWriteTheOrderField">shouldWriteTheOrderField	^shouldWriteTheOrderField</body><body package="GlorpMappings" selector="shouldWriteTheOrderField:">shouldWriteTheOrderField: aBoolean	shouldWriteTheOrderField := aBoolean.</body><body package="GlorpMappings" selector="writeTheOrderField">writeTheOrderField	shouldWriteTheOrderField := true.</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="buildGeneralQueryIn:">buildGeneralQueryIn: anObjectBuilder	| newQuery |	newQuery := super buildGeneralQueryIn: anObjectBuilder.	orderBy isNil ifFalse: [orderBy do: [:each | newQuery orderBy: each]].	^newQuery.</body><body package="GlorpMappings" selector="buildQuery">buildQuery	query := super buildQuery.	orderBy isNil ifFalse: [orderBy do: [:each | query orderBy: each]].	^query.</body><body package="GlorpMappings" selector="keyForOrderingFrom:to:">keyForOrderingFrom: anObject to: target	self usesLinkTable ifFalse: [^target].	^self orderField table == self linkTable ifTrue: [target] ifFalse: [anObject].</body><body package="GlorpMappings" selector="writeExtraInformationInto:atKey:forSourceObject:targetObject:atIndex:">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject atIndex: index	shouldWriteTheOrderField		ifTrue:			[| keyForOrdering |			keyForOrdering := self keyForOrderingFrom: sourceObject to: rowMapKey.			aRowMap				at: self orderField				key: keyForOrdering				put: index].</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>private/expressions</category><body package="GlorpMappings" selector="linkTable">linkTable	| referenceKeys |	self usesLinkTable ifFalse: [^nil].	referenceKeys := (self join) targetKeys asOrderedCollection.	^referenceKeys first table.</body><body package="GlorpMappings" selector="orderField">orderField	| exp |	exp := Query new expressionBlockFor: orderBy first.	^(exp asGlorpExpressionOn: (BaseExpression new descriptor: self referenceDescriptor)) field.</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="hasValueThatCanProvideField:from:">hasValueThatCanProvideField: aField from: anObject	"Return true if we have enough information in ourselves to populate our fields. The only time this won't be true is if we're either holding an uninstantiated proxy or have a to-many relationship mapping with an empty collection. Inline the superclass implementation to avoid fetching the value twice."	| value |	(super hasValueThatCanProvideField: aField from: anObject) ifFalse: [^false].	value := self getValueFrom: anObject.	^value isEmpty not.</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>initialize/release</category><body package="GlorpMappings" selector="defaultCollectionType">defaultCollectionType	^OrderedCollection.</body><body package="GlorpMappings" selector="initialize">initialize	super initialize.	shouldWriteTheOrderField := false.</body><body package="GlorpMappings" selector="initializeAttribute">initializeAttribute	"This is where we can initialize aspects of the attribute, if required. The motivating example is initializing the collection type of the attribute if it wasn't set. We need it to have some type, but we don't want to initialize it while we're doing basic initialization and aren't yet properly attached to a descriptor or class model"	super initializeAttribute.	self attribute collectionType isNil		ifTrue: [self attribute collectionType: self defaultCollectionType].</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	| targetClassModel |	super validate.	(self collectionType = GlorpCursoredStream and: [self shouldUseFilteredRead]) ifTrue: [self error: 'Filtered mappings can cause duplicates and so cannot return cursors'].	(shouldWriteTheOrderField and: [orderBy isNil]) ifTrue: [self error: 'Mapping tries to write the collection order to a field, but has no order by field specified'].		orderBy isNil ifTrue: [^self].	targetClassModel := self system classModelFor: attribute type.	"Note that this will only validate when the orderBy is a symbol - not a block, expression, or field"	orderBy do: [:attributeName |		attributeName isSymbol ifTrue: [			(targetClassModel hasAttributeNamed: attributeName) ifFalse: [				self error: attribute printString, ' is attempting to order by #', attributeName, ' which is not a mapped attribute of ', targetClassModel describedClass name]]].</body></methods><methods><class-id>Glorp.ManyToManyMapping</class-id> <category>initializing</category><body package="GlorpMappings" selector="initialize">initialize	super initialize.	usesLinkTable := true.</body></methods><methods><class-id>Glorp.CannotFindSession</class-id> <category>printing</category><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Cannot find the right session to use - send the #session: message first.'.</body></methods><methods><class-id>Glorp.CannotFindSession class</class-id> <category>testing</category><body package="GlorpMisc" selector="mayResume">mayResume	^true.</body></methods><methods><class-id>Glorp.GlorpInvalidTypeError</class-id> <category>accessing</category><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Object being written does not match the type of the attribute: ''', self object printString,  ''' ~= ''' , self expectedType printString, ''''.</body><body package="GlorpMisc" selector="expectedType">expectedType	^expectedType</body><body package="GlorpMisc" selector="expectedType:">expectedType: aGlorpClassModel	expectedType := aGlorpClassModel</body><body package="GlorpMisc" selector="object">object	^object</body><body package="GlorpMisc" selector="object:">object: anObject	object := anObject</body></methods><methods><class-id>Glorp.GlorpTransactionFailure</class-id> <category>accessing</category><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Optimistic Lock Conflict'.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>printing</category><body package="GlorpExpressions" selector="printBasicSQLOn:withParameters:forSelect:">printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean	aStream		nextPutAll: function;		nextPut: $(.	aBoolean		ifTrue: [base printSelectSQLOn: aStream withParameters: aDictionary]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].	arguments		do:			[:each | 			"It's possible there needs to be type conversion here similar to InfixFunction&gt;&gt;printSQLOn:withParameters:, but it's not clear how common that case is, or how best to do it, so leaving it until it becomes a problem."			aStream nextPutAll: separator.			aBoolean 				ifTrue: [each printSelectSQLOn: aStream withParameters: aDictionary]				ifFalse: [each printSQLOn: aStream withParameters: aDictionary]].	aStream nextPut: $).	alias notNil		ifTrue:			[aStream				nextPutAll: ' AS ';				nextPutAll: alias].</body><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary	self printBasicSQLOn: aStream withParameters: aDictionary forSelect: true.</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	self printsIntoJoins		ifTrue: [self printBasicSQLOn: aStream withParameters: aDictionary forSelect: false]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream		nextPutAll: function, '('.	base printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>initializing</category><body package="GlorpExpressions" selector="initialize">initialize	super initialize.	arguments := #().	separator := ','.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>converting</category><body package="GlorpExpressions" selector="convertedStValueOf:">convertedStValueOf: anObject	"This assumes that functions that do conversions have already had their effect in the database, and all we're concerned with is the fundamental data type conversion"	^base convertedStValueOf: anObject.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	arguments do: [:each | each do: aBlock skipping: aSet].	aBlock value: self.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>accessing</category><body package="GlorpExpressions" selector="argumentModifierBlock">argumentModifierBlock	^argumentModifierBlock</body><body package="GlorpExpressions" selector="argumentModifierBlock:">argumentModifierBlock: aBlock	argumentModifierBlock := aBlock</body><body package="GlorpExpressions" selector="arguments">arguments	^arguments.</body><body package="GlorpExpressions" selector="arguments:">arguments: aCollection	"Our arguments may have already been set to a block, in which case we evaluate it with the incoming collection."	argumentModifierBlock notNil ifTrue: [^arguments := argumentModifierBlock value: self value: aCollection].	arguments := aCollection.</body><body package="GlorpExpressions" selector="separator">separator	^separator</body><body package="GlorpExpressions" selector="separator:">separator: aString	separator := aString</body></methods><methods><class-id>Glorp.Case</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="argumentTypes:">argumentTypes: anArray 	argumentTypes := anArray.</body></methods><methods><class-id>Glorp.Case</class-id> <category>printing</category><body package="GlorpExpressions" selector="printBasicSQLOn:withParameters:forSelect:">printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean	"Example: CASE (base?)		WHEN arg1 THEN arg2 		 ELSE arg3	END AS alias"		aStream		nextPutAll: function;		nextPut: $(.	aBoolean		ifTrue: [base printSelectSQLOn: aStream withParameters: aDictionary]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].	aStream nextPutAll: ')'.	1 to: arguments size do: [:i |		| keyword argument argumentType |		keyword := #(' WHEN ' ' THEN ' ' ELSE ') at: i.		argument := arguments at: i.		argumentType := argumentTypes at: i.		aStream nextPutAll: keyword.		"Our printing of constants with types is unfortunately tied up with relation expressions, so we shortcircuit some of the logic and just have the types print directly. This will not let us e.g. bind parameters to this function, but we don't expect to be doing that right now."		argumentType print: argument on: aStream].	aStream nextPutAll: ' END '.	alias notNil		ifTrue: [aStream				nextPutAll: ' AS ';				nextPutAll: alias]</body></methods><methods><class-id>Glorp.Case</class-id> <category>initializing</category><body package="GlorpExpressions" selector="initialize">initialize	super initialize.	function := 'CASE'.	separator := ' '.	argumentTypes := OrderedCollection new: 3.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="base:">base: anExpression	base := anExpression.</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions" selector="descriptor">descriptor	^base system descriptorFor: query resultClass.</body><body package="GlorpExpressions" selector="field">field	^nil.</body><body package="GlorpExpressions" selector="mappedFields">mappedFields	"Let's try this and see if it works returning empty"	^#().</body><body package="GlorpExpressions" selector="query">query	^query</body><body package="GlorpExpressions" selector="query:">query: aQuery	query := aQuery</body><body package="GlorpExpressions" selector="type">type	^query resultType.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	" *** This method was defined by Glorp.GlorpExpression as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary 	| command |	aStream nextPutAll: '('.	self query session: aStream query session.	command := self query sqlWith: aDictionary.	aStream nextPutAll: command sqlString.	aStream nextPutAll: ')'.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream	aStream nextPutAll: 'subselect('.	query printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asJoin">asJoin	" *** This method was defined by Glorp.GlorpExpression as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpExpressions" selector="convertedDbValueOf:">convertedDbValueOf: anObject	^anObject.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="addBoundExpressionsIn:to:">addBoundExpressionsIn: aCommand to: boundExpressions	self query session: aCommand query session.	self query prepare.	self query addBoundExpressionsIn: aCommand to: boundExpressions.</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	" *** This method was defined by Glorp.GlorpExpression as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuiltBase rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuiltBase := base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	rebuilt := self copy.	rebuilt base: rebuiltBase.	rebuilt query: (query rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	^rebuilt."	^query asGlorpExpressionOn: aBaseExpression."</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="base">base	^base</body><body package="GlorpExpressions" selector="get:withArguments:">get: aSymbol withArguments: anArray 	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body><body package="GlorpExpressions" selector="getField:">getField: aField	"This is rather a hack on the use of get:, but I think it should be all right because we should never run into one of these in normal expression generation. The issue is that if we do an expression of the form (x = aQuery) where the query returns an object of the same class as X. We want to rewrite that into a primary key comparison for the database, so we want to do a get: against aQuery. But the only thing that seems to sensibly translate into is a retrieve: clause and return the query. That will only work for a single level get:, but I think that a multi-level one, from converting a block, shouldn't ever get to a general sub-select."	query retrieve: [:each | each getField: aField].</body><body package="GlorpExpressions" selector="getMapping:named:">getMapping: aMapping named: aSymbol	"Suppose we do an expression of the form (x = aQuery) where the query returns an object of the same class as X. We want to rewrite that into a primary key comparison for the database, so we want to do a getMapping:named: against aQuery. But the only thing that seems to sensibly translate into is a retrieve: clause and return the query. That will only work for a single level get:, but I think that a multi-level one, from converting a block, shouldn't ever get to a general sub-select."	query retrieve: aSymbol.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="isMappable">isMappable	"Return true if we're something that can be returned in a select statement."	^false.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="basedOn:">basedOn: anExpression	"The defining characteristic of a general subselect is that it doesn't care what it's based on. The base is just a convenient place to hang an independent expression. So make sure we're built on a true base, which won't print confusing stuff for us"	^self new base: anExpression ultimateBaseExpression.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>accessing</category><body package="GlorpQueries" selector="addExpression:">addExpression: anExpression	self addExpression: anExpression andDo: [:ignore |].</body><body package="GlorpQueries" selector="addExpression:andDo:">addExpression: anExpression andDo: aBlock	| exp |	exp := anExpression asGlorpExpressionOn: self base in: query.	(allTracings includes: exp) ifFalse: [		allTracings add: exp.		aBlock value: exp].</body><body package="GlorpQueries" selector="additionalExpressions">additionalExpressions	| all |	alsoFetchExpressions isEmpty ifTrue: [^retrievalExpressions].	all := OrderedCollection new.	all addAll: self retrievalExpressions.	all addAll: self alsoFetchExpressions.	^all.</body><body package="GlorpQueries" selector="allTracings">allTracings	^allTracings.</body><body package="GlorpQueries" selector="alsoFetchExpressions">alsoFetchExpressions	^alsoFetchExpressions</body><body package="GlorpQueries" selector="base">base	^query isNil ifTrue: [base] ifFalse: [query baseExpression].</body><body package="GlorpQueries" selector="base:">base: anExpression 	base := anExpression</body><body package="GlorpQueries" selector="retrievalExpressions">retrievalExpressions	^retrievalExpressions.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>setup</category><body package="GlorpQueries" selector="setup">setup	"We have been put into a query. If we aren't to trace anything else, trace the base"	retrievalExpressions isEmpty ifTrue: [		allTracings addFirst: base.		retrievalExpressions add: base].</body><body package="GlorpQueries" selector="updateBase:">updateBase: aBaseExpression	"Make sure we have the same base as the query"	| transformed |	transformed := IdentityDictionary new.	base == aBaseExpression ifTrue: [^self].	base := aBaseExpression.	allTracings := allTracings collect: [:each | | new | new := each asGlorpExpressionOn: base.		transformed at: each put: new.		new].	retrievalExpressions := retrievalExpressions collect: [:each | 		transformed at: each].	alsoFetchExpressions := alsoFetchExpressions collect: [:each | 		transformed at: each].</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>initialize</category><body package="GlorpQueries" selector="initialize">initialize	base := BaseExpression new.	allTracings := OrderedCollection new: 2.	retrievalExpressions := Set new: 3.	alsoFetchExpressions := Set new: 3.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>api</category><body package="GlorpQueries" selector="alsoFetch:">alsoFetch: anExpression 	"Add the expression as something which will be explicitly retrieved and knit together with other results, but NOT included in the result list"	self addExpression: anExpression andDo: [:exp |		alsoFetchExpressions add: exp].</body><body package="GlorpQueries" selector="retrieve:">retrieve: anExpression 	"Add the expression as something which will be explicitly retrieved and knit together with other results, and included in the result list"	self addExpression: anExpression andDo: [:exp |		retrievalExpressions add: exp].</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>querying</category><body package="GlorpQueries" selector="tracesThrough:">tracesThrough: aMapping	^aMapping isStoredInSameTable.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries" selector="postCopy">postCopy	allTracings := allTracings copy.	retrievalExpressions := retrievalExpressions copy.	alsoFetchExpressions := alsoFetchExpressions copy.</body></methods><methods><class-id>Glorp.Tracing class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="for:">for: aQuery	^self new base: aQuery whereClause ultimateBaseExpression.</body><body package="GlorpQueries" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="creationString">creationString	^'Create sequence ', self qualifiedName.</body><body package="GlorpDatabase" selector="dropString">dropString	^'Drop string unspecified for this type of sequence'.</body><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession 	self subclassResponsibility.</body><body package="GlorpDatabase" selector="hasReservedNumbers">hasReservedNumbers	^reservedNumbers notNil and: [reservedNumbers isEmpty not].</body><body package="GlorpDatabase" selector="nextReservedNumber">nextReservedNumber	^reservedNumbers removeFirst.</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor	self subclassResponsibility.</body><body package="GlorpDatabase" selector="preWriteAssignSequenceValueFor:in:using:">preWriteAssignSequenceValueFor: aField in: aRow using: anAccessor	self hasReservedNumbers		ifTrue: [aRow at: aField put: self nextReservedNumber]		ifFalse:			[self				getSequenceValueFromDatabaseFor: aField				in: aRow				using: anAccessor].</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>initialize/release</category><body package="GlorpDatabase" selector="initialize">initialize</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>accessing</category><body package="GlorpDatabase" selector="reservedNumbers">reservedNumbers	reservedNumbers isNil ifTrue: [reservedNumbers := OrderedCollection new: 50].	^reservedNumbers.</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>testing</category><body package="GlorpDatabase" selector="isIdentityColumn">isIdentityColumn	^false.</body></methods><methods><class-id>Glorp.DatabaseSequence class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="named:">named: aString	^self new name: aString.</body><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>accessing</category><body package="GlorpDatabase" selector="name">name	^name.</body><body package="GlorpDatabase" selector="name:">name: aString	name := aString.</body><body package="GlorpDatabase" selector="qualifiedName">qualifiedName	^(schema isNil or: [schema isEmpty]) ifTrue: [name] ifFalse: [schema, '.', name].</body><body package="GlorpDatabase" selector="schema">schema	^schema</body><body package="GlorpDatabase" selector="schema:">schema: aString	schema := aString</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>SQL</category><body package="GlorpDatabase" selector="availableReservedNumbers">availableReservedNumbers	^self reservedNumbers size.</body><body package="GlorpDatabase" selector="maximumToReserveAtOnce">maximumToReserveAtOnce		^1000.</body><body package="GlorpDatabase" selector="reserveSequenceNumbers:in:for:">reserveSequenceNumbers: anInteger in: aSession for: aTable	| numberNeeded numberToReserve |	numberNeeded := anInteger - self availableReservedNumbers.	numberNeeded &lt;= 0 ifTrue: [^self].	self		reserveViaTableSelect: numberNeeded		in: aSession		for: aTable.	[anInteger - self availableReservedNumbers &gt;0 ] whileTrue: [		numberToReserve := (anInteger - self availableReservedNumbers) min: (self maximumToReserveAtOnce).		self reserveViaBackupMechanism: numberToReserve in: aSession].</body><body package="GlorpDatabase" selector="reserveViaTableSelect:in:for:">reserveViaTableSelect: anInteger in: aSession for: aTable	| rows command |	command := self		tableSelectCommandFor: (self tableToSelectFromIn: aSession for: aTable)		in: aSession		reserving: anInteger.	command parameters: (Array with: anInteger).	rows := aSession accessor executeCommand: command.	rows do: [:each | self reservedNumbers add: each first].</body><body package="GlorpDatabase" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anObject	self subclassResponsibility.</body><body package="GlorpDatabase" selector="tableToSelectFromFor:">tableToSelectFromFor: aTable	"Sometimes it's inefficient to select sequence values against our own table and we can use a database-specific system table instead to be much faster. Subclasses can override where this is the case"	^aTable.</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="dropString">dropString	^'Drop sequence ', self qualifiedName.</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>printing</category><body package="GlorpDatabase" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: (name isNil ifTrue: ['unnamed'] ifFalse: [name]);		nextPut: $).</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>As yet unclassified</category><body package="GlorpDatabase" selector="reserveViaBackupMechanism:in:">reserveViaBackupMechanism: anInteger in: aSession	"For interbase, the generator mechanism should always work"	self error: 'This should never happen'.</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="dropString">dropString	^'DELETE FROM RDB$GENERATORS        WHERE RDB$GENERATOR_NAME=''', self qualifiedName, ''''.</body><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aDatabaseField in: aDatabaseRow using: anAccessor 	| statement rows pk |	statement := 'select gen_id(' , self qualifiedName 				, ',1) from rdb$database'.	rows := anAccessor executeSQLString: statement.	pk := rows first first.	aDatabaseRow at: aDatabaseField put: pk</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body><body package="GlorpDatabase" selector="reserveViaTableSelect:in:for:">reserveViaTableSelect: anInteger in: aSession for: aTable	"Interbase returns the top of the generated range in a single row. Do the iteration ourselves"	| rows command max |	command := self		tableSelectCommandFor: aTable		in: aSession		reserving: anInteger.	command parameters: (Array with: anInteger).	command useBinding: false.	rows := aSession accessor executeCommand: command.	max := rows first first.	max - anInteger + 1 to: max do: [:i | self reservedNumbers add: i].</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>public</category><body package="GlorpDatabase" selector="creationString">creationString	^'create generator ' , self qualifiedName.</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Since tableSelectCommand was never nilled, a second pundle version reusing this sequence used to get an SQL string embedding the first's integer value.  If it was a version of a different pundle, its integer probably differed;  when a call to reserve e.g. 1233 returns a maximum got by reusing the prior version's call to reserve e.g. 85, the result is 1148 duplicate keys.  If #insertOnly was set,  replication failed on an illegal command.  If we reached one of the fix-up states where it was not, then our cache assured us we were updating and we happily overwrote e.g. the blob for a class definition with that for a method definition (as I experienced :-/).  As sequences are set in the descriptor system and reused, this persisted until the session was discarded or its system was revised.  We now check the integer."	| stream useBinding |	"Binding into this doesn't seem to work"	useBinding := false.	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:		[stream := WriteStream on: (String new: 200).		stream nextPutAll: 'select gen_id('.		stream nextPutAll: self qualifiedName.		stream nextPut: $,.		stream nextPutAll: (useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).		stream nextPutAll: ') from rdb$database'.		tableSelectCommand := SQLStringSelectCommand new.		tableSelectCommand parameters: (Array with: anInteger).		tableSelectCommand setSQLString: stream contents.		tableSelectCommand session: aSession].	^tableSelectCommand</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>fields</category><body package="GlorpExpressions" selector="aliasedTableFor:">aliasedTableFor: aDatabaseTable 	tableAliases isNil ifTrue: [^aDatabaseTable].	aDatabaseTable isAliased ifTrue: [^aDatabaseTable].	^tableAliases 		at: aDatabaseTable 		ifAbsent: [			(self tables includes: aDatabaseTable) 					ifTrue: [self error: 'Bug. Expression has only partially aliased tables']				ifFalse: [					| tableExpression |					tableExpression := self mappingExpressions at: aDatabaseTable ifAbsent: [nil].					tableExpression isNil 						ifTrue: [aDatabaseTable]						ifFalse: [tableExpression aliasedTableFor: aDatabaseTable]]].</body><body package="GlorpExpressions" selector="aliasedTableFor:ifAbsent:">aliasedTableFor: aDatabaseTable  ifAbsent: aBlock	tableAliases isNil ifTrue: [^aBlock value].	aDatabaseTable isAliased ifTrue: [^aDatabaseTable].	^tableAliases at: aDatabaseTable ifAbsent: [aBlock value].</body><body package="GlorpExpressions" selector="aliasTable:to:">aliasTable: aDatabaseTable to: aString 	| newTable |	newTable := aDatabaseTable copy.	newTable name: aString.	newTable parent: aDatabaseTable.	newTable schema: ''.	self tableAliases at: aDatabaseTable put: newTable</body><body package="GlorpExpressions" selector="controlsTables">controlsTables	self subclassResponsibility.</body><body package="GlorpExpressions" selector="findFieldNamed:">findFieldNamed: aString	| fields |	fields := OrderedCollection new: 1.	self tables do: [:each |		| field |		field := each fieldNamed: aString ifAbsent: [nil].		field isNil ifFalse: [fields add: field]].	fields isEmpty ifTrue: [self error: 'No field named ', aString, ' in ', self printString].	fields size &gt; 1 ifTrue: [self error: 'Ambiguous field ', aString, ' in ', self printString].	^fields at: 1.</body><body package="GlorpExpressions" selector="newFieldExpressionFor:">newFieldExpressionFor: aField	^FieldExpression forField: aField basedOn: self</body><body package="GlorpExpressions" selector="translateField:">translateField: aDatabaseField	| newTable rebuilt |	rebuilt := aDatabaseField isGlorpExpression		ifTrue: [aDatabaseField asGlorpExpressionOn: self withUltimateBase: self ultimateBaseExpression]		ifFalse: [aDatabaseField].	newTable := self aliasedTableFor: rebuilt table.	newTable == rebuilt table ifTrue: [^rebuilt].	^self fieldAliases at: aDatabaseField ifAbsentPut: [rebuilt withTable: newTable].</body><body package="GlorpExpressions" selector="translateFields:">translateFields: anOrderedCollection 	^anOrderedCollection collect: [:each | self translateField: each]</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="fieldAliases">fieldAliases	fieldAliases isNil ifTrue: [fieldAliases := IdentityDictionary new].	^fieldAliases.</body><body package="GlorpExpressions" selector="mappingExpressions">mappingExpressions	mappingExpressions isNil ifTrue: [mappingExpressions := IdentityDictionary new].	^mappingExpressions.</body><body package="GlorpExpressions" selector="mappingExpressions:">mappingExpressions: anObject	mappingExpressions := anObject</body><body package="GlorpExpressions" selector="system">system	self subclassResponsibility.</body><body package="GlorpExpressions" selector="table">table	self subclassResponsibility.</body><body package="GlorpExpressions" selector="tableAliases">tableAliases	tableAliases isNil ifTrue: [		tableAliases := IdentityDictionary new: 3].	^tableAliases</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printTableAliasesOn:">printTableAliasesOn: aStream 	self hasTableAliases 		ifTrue: 			[aStream nextPutAll: ' '.			tableAliases keysAndValuesDo: [:eachKey :eachValue | 				aStream nextPutAll: eachKey name, '-&gt;', eachValue name , ' ']]</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canTranslateFields">canTranslateFields	"Return true if we are a mapping expression and can thus translate from fields into their aliased version for a particular query. More generally, do we respond to translateField:"	^true.</body><body package="GlorpExpressions" selector="hasField">hasField	^false.</body><body package="GlorpExpressions" selector="hasProvidedAdditionalExpressions">hasProvidedAdditionalExpressions	"Return true if we have already provided additional expressions to some query. Only important when we're preparing a subselect and don't want to bring in joins that are part of the main query"	^self hasTableAliases.</body><body package="GlorpExpressions" selector="hasTableAliases">hasTableAliases	^tableAliases notNil</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="get:">get: aSymbol 	"Return the mapping expression corresponding to the named attribute"	| reallyASymbol functionExpression |	reallyASymbol := aSymbol asSymbol.	functionExpression := self getFunction: aSymbol withArguments: #().	functionExpression isNil ifFalse: [^functionExpression].	^self mappingExpressions at: reallyASymbol		ifAbsentPut: [MappingExpression named: reallyASymbol basedOn: self]</body><body package="GlorpExpressions" selector="get:withArguments:">get: aSymbol withArguments: anArray 	| specialExpression functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	specialExpression := self performSpecialExpression: aSymbol withArguments: anArray.	specialExpression isNil ifFalse: [^specialExpression].	anArray isEmpty ifTrue: [^self get: aSymbol].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body><body package="GlorpExpressions" selector="getConstant:">getConstant: anObject	"Allows us to refer to a constant object easily. This is most useful for subselects, where I can already write something like   [:each | (each count: subQuery) = 5]but since the subselect part might be very verbose, I might prefer to put the constant value first. I can't write   [:each | 5 = (each count: subQuery)]because then the left-hand side expression doesn't refer back to the block argument, and we can't build the expression correctly. So I can write   [:each | (each getConstant: 5) = (each count: subQuery)]"	^anObject asGlorpExpressionOn: self.</body><body package="GlorpExpressions" selector="getField:">getField: aField	| realField |	realField := aField isString		ifTrue: [self findFieldNamed: aField]		ifFalse: [aField].	"This might be an expression, most notably a constant expression, in which case it either contains a string or a field. This is awfully ugly"	realField isGlorpExpression		ifTrue:			[realField class == ConstantExpression				ifTrue:					[realField := realField value isString						ifTrue: [realField := self findFieldNamed: realField value]						ifFalse: [realField]]].	^self getFieldKnownNotToBeAName: realField.</body><body package="GlorpExpressions" selector="getFieldKnownNotToBeAName:">getFieldKnownNotToBeAName: aField	"The public getField method may, for convenience, be passed a string or a constant expression with a string that is a field name. This is a mess, and can be confused with a constant value. This method does not allow that."	| realField |	realField := aField.	realField isGlorpExpression		ifTrue:			[realField class == ConstantExpression ifTrue: [^realField].			realField class == ParameterExpression				ifTrue: [realField := realField field]].	^self getFieldThatsAnActualFieldObject: realField.</body><body package="GlorpExpressions" selector="getFieldThatsAnActualFieldObject:">getFieldThatsAnActualFieldObject: aField	"If the field isn't from our table, do a getTable first. If we don't know, assume we can get it directly."	self controlsTables ifFalse: [^self base getFieldThatsAnActualFieldObject: (self translateField: aField)].	^((self hasDescriptor not) or: [self tables includes: aField table])		ifTrue:			[self mappingExpressions				at: aField				ifAbsentPut: [self newFieldExpressionFor: aField]]		ifFalse: [(self getTable: aField table) getField: aField].</body><body package="GlorpExpressions" selector="getMapping:named:">getMapping: aMapping named: aString	"Get a mapping expression given the actual mapping (this is most useful for an anonymous mapping that isn't named or in our descriptor). Only if you really know what you're doing!. Short circuit looking up the mapping, checking for functions, and so on."	^self mappingExpressions at: aString		ifAbsentPut: [ | expression |			expression := MappingExpression named: aString basedOn: self.			expression mapping: aMapping.			expression].</body><body package="GlorpExpressions" selector="getParameter:">getParameter: aDatabaseField 	^ParameterExpression forField: aDatabaseField basedOn: self.</body><body package="GlorpExpressions" selector="getTable:">getTable: aTable	"This can take a string, a constantExpression containing a string, or a table object"	| realTable |	realTable := aTable isString		ifTrue: [self system tableNamed: aTable]		ifFalse: [aTable].	"This might be an expression, most notably a constant expression, in which case it either contains a string or a field"	realTable isGlorpExpression		ifTrue:			[realTable value isString				ifTrue: [realTable := self system tableNamed: realTable value]				ifFalse: [realTable := realTable value]].	^self mappingExpressions		at: realTable		ifAbsentPut: [TableExpression forTable: realTable basedOn: self].</body><body package="GlorpExpressions" selector="referenceClass">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="assignTableAliasesStartingAt:prefix:">assignTableAliasesStartingAt: anInteger prefix: aString	| tableNumber prefix |	self controlsTables ifFalse: [^anInteger].	self hasTableAliases ifTrue: [^anInteger].	tableNumber := anInteger.	prefix := aString isNil ifTrue: ['t'] ifFalse: [aString].	self tables		do:			[:each | 			self aliasTable: each to: prefix , tableNumber printString.			tableNumber := tableNumber + 1].	^tableNumber.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>internal</category><body package="GlorpExpressions" selector="anySatisfyDefault:">anySatisfyDefault: anExpression 	^(self system isNil or: [self system useJoinsForAnySatisfy])		ifTrue: [self anySatisfyJoin: anExpression]		ifFalse: [self anySatisfyExists: anExpression].</body><body package="GlorpExpressions" selector="anySatisfyExists:">anySatisfyExists: anExpression 	| newExpression |	anExpression isConstantExpression ifTrue: [self error: 'The argument to anySatisfy: must be a block evaluating to a boolean condition.'].	newExpression := SubSelectExpression 		named: #anySatisfy:		basedOn: self		withArguments: (Array with: anExpression).	^newExpression.</body><body package="GlorpExpressions" selector="anySatisfyJoin:">anySatisfyJoin: anExpression 	| newExpression |	anExpression isConstantExpression ifTrue: [self error: 'The argument to anySatisfy: must be a block evaluating to a boolean condition.'].	self base requiresDistinct: true.	newExpression := CollectionExpression 		named: #anySatisfy:		basedOn: self		withArguments: (Array with: anExpression).	self base removeMappingExpression: self.	^newExpression.</body><body package="GlorpExpressions" selector="includes:">includes: anObject	"Allow us to specify includes: as a shortcut for (anySatisfy: [:each | each = anObject]). Rather than just call anySatisfy:, we need to go through the get: mechanism, both to avoid the anySatisfy: method on expressions that treats them like a collection, and to make sure we get the default mechanism for anySatisfy: (either joins or exists)"	^self get: #anySatisfy: withArguments: (Array with: ([:each | each = anObject] asGlorpExpressionOn: self)).</body><body package="GlorpExpressions" selector="noneSatisfy:">noneSatisfy: anExpression 	| newExpression |	newExpression := SubSelectExpression 		named: #noneSatisfy:		basedOn: self		withArguments: (Array with: anExpression).	^newExpression.</body><body package="GlorpExpressions" selector="noneSatisfyExists:">noneSatisfyExists: anExpression 	| newExpression |	newExpression := SubSelectExpression 		named: #noneSatisfy:		basedOn: self		withArguments: (Array with: anExpression).	^newExpression.</body><body package="GlorpExpressions" selector="oneArgumentSpecialSelectors">oneArgumentSpecialSelectors	^#(#anySatisfyDefault: #anySatisfyJoin: #anySatisfyExists: #getTable: #getField: #fieldNamed: #parameter: #noneSatisfy: #noneSatisfyExists: #getConstant: #count: #sum: #min: #max: #average: #sqlSelect: #includes:)</body><body package="GlorpExpressions" selector="performSpecialExpression:withArguments:">performSpecialExpression: aSymbol withArguments: anArray	| symbolToPerform |	symbolToPerform := self specialSymbolToPerformFor: aSymbol.	(self zeroArgumentSpecialSelectors includes: symbolToPerform) ifTrue: [^self perform: symbolToPerform].	(self oneArgumentSpecialSelectors includes: symbolToPerform) ifTrue: [^self perform: symbolToPerform with: anArray first ].	(self twoArgumentSpecialSelectors includes: symbolToPerform) ifTrue: [^self perform: symbolToPerform with: (anArray at: 1) with: (anArray at: 2)].	^nil.</body><body package="GlorpExpressions" selector="specialSymbolToPerformFor:">specialSymbolToPerformFor: aSymbol	"Avoid polymorphism between things you can send to an expression inside a query block and things you can do to an expression to iterate over an expression true"	aSymbol == #anySatisfy: ifTrue: [^#anySatisfyDefault:].	aSymbol == #select: ifTrue: [^#sqlSelect:].	^aSymbol.</body><body package="GlorpExpressions" selector="twoArgumentSpecialSelectors">twoArgumentSpecialSelectors	^#(#aggregate:as:)</body><body package="GlorpExpressions" selector="zeroArgumentSpecialSelectors">zeroArgumentSpecialSelectors	^#(#asOuterJoin #sqlCount #sqlSum #sqlMin #sqlMax #sqlAverage #sqlAvg #isEmpty #notEmpty #asDate #asTimestamp #bePhantom).</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>private/accessing</category><body package="GlorpExpressions" selector="removeMappingExpression:">removeMappingExpression: anExpression	"Private. Normally you would never do this, but in the case of an anySatisfy: or allSatisfy: we want to have each of them as distinct joins, so we will remove the entry from the mappingExpression of the base, making sure that relationship will not be used for anything else. Since any/allSatisfy: is the only valid use of a collection relationship, we don't have to worry about whether it was used for something else earlier."	self mappingExpressions removeKey: anExpression name.</body><body package="GlorpExpressions" selector="requiresDistinct">requiresDistinct	^requiresDistinct</body><body package="GlorpExpressions" selector="requiresDistinct:">requiresDistinct: aBoolean 	requiresDistinct := aBoolean</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>initialize</category><body package="GlorpExpressions" selector="initialize">initialize	super initialize.	requiresDistinct := false.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>api-aggregates</category><body package="GlorpExpressions" selector="aggregate:as:">aggregate: anExpression as: aggregateFunctionName	^self aggregate: anExpression as: aggregateFunctionName where: nil.</body><body package="GlorpQueries" selector="aggregate:as:where:">aggregate: anExpression as: aggregateFunctionName where: whereExpression	"Make a subselect of the expression that is our argument, returning an aggregated value. e.g.session read: GlorpCustomer where: 	[:each |  	(each aggregate: eachCust accounts as: #countStar where: [:acct | acct price &gt; 1000]]) = 1].	This is the most general form of aggregation convenience method, and everything else is implemented in terms of it"	| q expression next objectExpression retrievalExpression basicExpression |	"We may be passed an expression corresponding to either a field, or to a full object, depending on the aggregate function. In either case, build backwards from the first full object"	objectExpression := anExpression mapping isRelationship 		ifTrue: [anExpression] ifFalse: [anExpression base].	q := Query readManyOf: objectExpression referenceClass.	expression := q baseExpression.	next := objectExpression.	[next base isNil] whileFalse: [		expression := next mapping addPhantomMappingExpressionOn: expression.		next := next base].	"We have to force construct the equality expression, because we don't want 'self' rebuilt onto the other base"	expression := RelationExpression new outerJoin: false; relation: #=; leftChild: expression; rightChild: self.	q whereClause: expression.	"We need to rebuild the thing we're using to retrieve in the right context. Also, if we're called directly, the symbol may be wrapped as a constantExpression. Unwrap it"	basicExpression := anExpression rebuildOn: q baseExpression startingFrom: objectExpression.	retrievalExpression := (basicExpression get: aggregateFunctionName asGlorpExpression value).	q retrieve: retrievalExpression.	whereExpression == nil ifFalse: [		q AND: (whereExpression asGlorpExpressionOn: basicExpression)].	^q asGlorpExpressionOn: self ultimateBaseExpression.</body><body package="GlorpExpressions" selector="asDate">asDate	"Cast the receiver to be a date"	^self getFunction: #cast: withArguments: (Array with: self system platform date asGlorpExpression).</body><body package="GlorpExpressions" selector="asTimestamp">asTimestamp	"Cast the receiver to be a timestamp"	^self getFunction: #cast: withArguments: (Array with: self system platform timestamp asGlorpExpression).</body><body package="GlorpExpressions" selector="average:">average: anExpression	^self aggregate: anExpression as: #average.</body><body package="GlorpExpressions" selector="count:">count: anExpression	"Make a subselect of the expression that is our argument, returning a count(*). e.g.session read: GlorpCustomer where: 	[:each |  (each count: [:eachCust | eachCust accounts]) = 1]."	^self aggregate: anExpression as: #countStar.</body><body package="GlorpExpressions" selector="count:where:">count: anExpression where: filterExpression	"Make a subselect of the expression that is our argument, returning a count(*). e.g.session read: GlorpCustomer where: 	[:each |  (each count: [:eachCust | eachCust accounts]) = 1]."	^self aggregate: anExpression as: #countStar where: filterExpression.</body><body package="GlorpQueries" selector="existenceCheck:as:">existenceCheck: anExpression as: functionName	"Make a subselect of the expression that is our argument, returning it wrapped in either an exists or a not exists, e.g. 	session read: GlorpCustomer where: 	[:each |  		each existenceCheck: eachCust accounts as: #exists:].	This is the most general form of existence checking convenience method, others are implemented in terms of it. It's very similar to aggregate:as:where:, but simpler."	| q expression next objectExpression |	"We may be passed an expression corresponding to either a field, or to a full object, depending on the aggregate function. In either case, build backwards from the first full object"	objectExpression := anExpression mapping isRelationship 		ifTrue: [anExpression] ifFalse: [anExpression base].	q := Query readManyOf: objectExpression mapping referenceClass.	expression := q baseExpression.	next := objectExpression.	[next base isNil] whileFalse: [		expression := next mapping addPhantomMappingExpressionOn: expression.		next := next base].	"We have to force construct the equality expression, because we don't want 'self' rebuilt onto the other base"	expression := RelationExpression new outerJoin: false; relation: #=; leftChild: expression; rightChild: self.	q whereClause: expression.	"Just read back a literal constant, we don't actually care about the data"	q retrieve: ([:each | 'x' ] asGlorpExpression getFunction: #distinct withArguments: #()).	^self get: functionName withArguments: (Array with: (q asGlorpExpressionOn: self ultimateBaseExpression)).</body><body package="GlorpExpressions" selector="max:">max: anExpression	^self aggregate: anExpression as: #max.</body><body package="GlorpExpressions" selector="min:">min: anExpression	^self aggregate: anExpression as: #min.</body><body package="GlorpExpressions" selector="sqlAverage">sqlAverage	"Make a subselect of the expression that is our argument, returning an avg(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlAverage &gt; 100]."	^self queryLevelBaseExpression average: self.</body><body package="GlorpExpressions" selector="sqlAvg">sqlAvg	"Make a subselect of the expression that is our argument, returning an avg(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlAvg &gt; 100]."	^self queryLevelBaseExpression average: self.</body><body package="GlorpExpressions" selector="sqlCount">sqlCount	"Make a subselect of the expression that is our argument, returning a count(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts sqlCount = 1]."	^self queryLevelBaseExpression count: self.</body><body package="GlorpExpressions" selector="sqlCountWhere:">sqlCountWhere: filterExpression	"Make a subselect of the expression that is our argument, returning a count(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts sqlCount = 1]."	^self queryLevelBaseExpression count: self where: filterExpression.</body><body package="GlorpExpressions" selector="sqlMax">sqlMax	"Make a subselect of the expression that is our argument, returning a max(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlMax = 1]."	^self queryLevelBaseExpression max: self.</body><body package="GlorpExpressions" selector="sqlMin">sqlMin	"Make a subselect of the expression that is our argument, returning a minimum. e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlMin = 1]."	^self queryLevelBaseExpression min: self.</body><body package="GlorpExpressions" selector="sqlSum">sqlSum	"Make a subselect of the expression that is our argument, returning a count(*). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlSum = 1]."	^self queryLevelBaseExpression sum: self.</body><body package="GlorpExpressions" selector="sum:">sum: anExpression	"Make a subselect of the expression that is our argument, returning a sum. e.g.session read: GlorpCustomer where: 	[:each |  (each sum: [:eachCust | eachCust accounts id]) &gt; 5]."	^self aggregate: anExpression as: #sum.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="base">base	^base.</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions" selector="printsTable">printsTable	^true.</body><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions" selector="table">table	^table.</body><body package="GlorpExpressions" selector="tables">tables	^Array with: table.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="aliasedTableFor:">aliasedTableFor: aDatabaseTable 	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable]		ifFalse: [base aliasedTableFor: aDatabaseTable]</body><body package="GlorpExpressions" selector="aliasedTableFor:ifAbsent:">aliasedTableFor: aDatabaseTable ifAbsent: aBlock	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable ifAbsent: aBlock]		ifFalse: [base aliasedTableFor: aDatabaseTable ifAbsent: aBlock]</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^(source tablesContainingMe includes: table) ifTrue: [source] ifFalse: [target getTable: table].</body><body package="GlorpExpressions" selector="controlsTables">controlsTables	"We can end up with a table expression built on top of a base that has the same table. If so, we don't count as controlling that table"	base isNil ifTrue: [^true].	base hasDescriptor ifFalse: [^true].	^(base descriptor tables includes: table) not.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	self == anExpression ifTrue: [^aBaseExpression].	^(base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) getTable: table.</body><body package="GlorpExpressions" selector="tablesToPrint">tablesToPrint	self controlsTables ifFalse: [^#()].	^Array with: (self aliasedTableFor: table).</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	table printSQLOn: aStream withParameters: #().	self printTableAliasesOn: aStream.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	base printOn: aStream.	aStream nextPut: $..	table printSQLOn: aStream withParameters: #()</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>initialize/release</category><body package="GlorpExpressions" selector="table:base:">table: aDatabaseTable base: aBaseExpression	table := aDatabaseTable.	base := aBaseExpression.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree"	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="getFieldThatsAnActualFieldObject:">getFieldThatsAnActualFieldObject: aField	^self mappingExpressions at: aField ifAbsentPut: [self newFieldExpressionFor: aField].</body><body package="GlorpExpressions" selector="getTable:">getTable: aTable	self error: 'getting a table from a table expression doesn''t make sense'.</body><body package="GlorpExpressions" selector="referenceClass">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^nil.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canPrint">canPrint	"Return true if we can print into a where clause"	^false.</body></methods><methods><class-id>Glorp.TableExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="forTable:basedOn:">forTable: aDatabaseTable basedOn: aBaseExpression	^self new table: aDatabaseTable base: aBaseExpression; yourself</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>converting</category><body package="GlorpDatabase" selector="convert:fromDatabaseRepresentationAs:">convert: anObject fromDatabaseRepresentationAs: aDatabaseType 	self subclassResponsibility</body><body package="GlorpDatabase" selector="convert:toDatabaseRepresentationAs:">convert: anObject toDatabaseRepresentationAs: aDatabaseType 	self subclassResponsibility</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>printing</category><body package="GlorpDatabase" selector="printOn:">printOn: aString	aString nextPutAll: 'DatabaseConverter(', name, ')'.</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>initialize</category><body package="GlorpDatabase" selector="initialize">initialize	name := #unnamed.</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>accessing</category><body package="GlorpDatabase" selector="name">name	^name.</body><body package="GlorpDatabase" selector="name:">name: aString	name := aString.</body></methods><methods><class-id>Glorp.DatabaseConverter class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.DelegatingDatabaseConverter</class-id> <category>initialize-release</category><body package="GlorpDatabase" selector="hostedBy:fromStToDb:fromDbToSt:">hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	host := anObject.	stToDbSelector := stDbSelector.	dbToStSelector := dbStSelector</body><body package="GlorpDatabase" selector="named:hostedBy:fromStToDb:fromDbToSt:">named: aSymbol hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	name := aSymbol.	host := anObject.	stToDbSelector := stDbSelector.	dbToStSelector := dbStSelector</body></methods><methods><class-id>Glorp.DelegatingDatabaseConverter</class-id> <category>converting</category><body package="GlorpDatabase" selector="convert:fromDatabaseRepresentationAs:">convert: anObject fromDatabaseRepresentationAs: aDatabaseType 	^host perform: dbToStSelector with: anObject with: aDatabaseType</body><body package="GlorpDatabase" selector="convert:toDatabaseRepresentationAs:">convert: anObject toDatabaseRepresentationAs: aDatabaseType 	^host perform: stToDbSelector with: anObject with: aDatabaseType.</body></methods><methods><class-id>Glorp.DelegatingDatabaseConverter class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="hostedBy:fromStToDb:fromDbToSt:">hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	^super new		hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector</body><body package="GlorpDatabase" selector="named:hostedBy:fromStToDb:fromDbToSt:">named: aSymbol hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	^super new		named: aSymbol		hostedBy: anObject		fromStToDb: stDbSelector		fromDbToSt: dbStSelector.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>executing</category><body package="GlorpQueries" selector="hasFieldTranslations">hasFieldTranslations	^self fieldTranslations notNil</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>accessing</category><body package="GlorpQueries" selector="canCauseDuplicateRows">canCauseDuplicateRows	^false.</body><body package="GlorpQueries" selector="cursor">cursor	^cursor</body><body package="GlorpQueries" selector="cursor:">cursor: aGlorpCursoredStream	cursor := aGlorpCursoredStream</body><body package="GlorpQueries" selector="expression">expression	^expression</body><body package="GlorpQueries" selector="expression:">expression: anExpression	expression := anExpression.</body><body package="GlorpQueries" selector="fieldTranslations">fieldTranslations	^fieldTranslations</body><body package="GlorpQueries" selector="fieldTranslations:">fieldTranslations: aDictionary 	fieldTranslations := aDictionary.</body><body package="GlorpQueries" selector="instance">instance	^instance</body><body package="GlorpQueries" selector="instanceValue">instanceValue	^instance</body><body package="GlorpQueries" selector="query">query	^query</body><body package="GlorpQueries" selector="query:">query: aQuery 	query := aQuery</body><body package="GlorpQueries" selector="requiresDistinct">requiresDistinct	^expression requiresDistinct.</body><body package="GlorpQueries" selector="requiresPopulating">requiresPopulating	^true</body><body package="GlorpQueries" selector="returnValueIn:">returnValueIn: aCursoredStream	^self instance</body><body package="GlorpQueries" selector="row">row	^row</body><body package="GlorpQueries" selector="row:">row: anArray	"Since nil is a possible key value, use self as a special marker to indicate we haven't found the key yet"	row == anArray ifFalse: [		key := self].	row := anArray.</body><body package="GlorpQueries" selector="session">session	^expression descriptor session.</body><body package="GlorpQueries" selector="subBuilders">subBuilders	^#().</body><body package="GlorpQueries" selector="system">system	^self session system.</body><body package="GlorpQueries" selector="withAllSubBuilders">withAllSubBuilders	^Array with: self.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>building objects</category><body package="GlorpQueries" selector="buildObjectFrom:">buildObjectFrom: anArray 	self subclassResponsibility.</body><body package="GlorpQueries" selector="didValidationFail:">didValidationFail: validateResult	^validateResult == false.</body><body package="GlorpQueries" selector="findInstanceForRow:proxyType:">findInstanceForRow: aRow proxyType: proxyType	self subclassResponsibility.</body><body package="GlorpQueries" selector="knitResultIn:">knitResultIn: aSimpleQuery	"Connect up our built object with any other builders that use the same thing"	^self.</body><body package="GlorpQueries" selector="registerObjectInUnitOfWork">registerObjectInUnitOfWork	"If there is a current unit of work, then we must register in it, after population because that way the state is already in place. The nil checks are mostly for safety during unit tests, as those conditions should never occur in real use"	query isNil ifTrue: [^self].	query session isNil ifTrue: [^self].	query session register: instance.</body><body package="GlorpQueries" selector="sendPostFetchValidateIn:OnFailureDo:">sendPostFetchValidateIn: aSession OnFailureDo: aBlock	| validateResult |	validateResult := aSession sendPostFetchValidateEventTo: self instance.	(self didValidationFail: validateResult) ifTrue: aBlock.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries" selector="fieldsForSelectStatement">fieldsForSelectStatement	^self subclassResponsibility.</body><body package="GlorpQueries" selector="fieldsFromMyPerspective">fieldsFromMyPerspective	self subclassResponsibility.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>translating fields</category><body package="GlorpQueries" selector="translateFieldPosition:">translateFieldPosition: aDatabaseField 	fieldTranslations isNil ifTrue: [^aDatabaseField position].	^fieldTranslations at: aDatabaseField.</body><body package="GlorpDatabase" selector="valueOf:">valueOf: anExpression	^expression valueInBuilder: self.</body><body package="GlorpDatabase" selector="valueOfField:">valueOfField: aField	"aField is either a database field, or a constant expression containing a non-varying value that isn't derived from the row"	(aField class == ConstantExpression) ifTrue: [^aField value].	^self row atIndex: (self translateFieldPosition: aField).</body><body package="GlorpDatabase" selector="valueOfField:in:">valueOfField: aField in: aRow	"Since the elementBuilder now holds the row, #valueOfField: is preferred protocol, but some things (e.g. ad hoc mapping blocks) might still be using this, so left for compatibility"	(aField class == ConstantExpression) ifTrue: [^aField value].	^aRow atIndex: (self translateFieldPosition: aField).</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>initializing</category><body package="GlorpQueries" selector="initialize">initialize</body><body package="GlorpQueries" selector="setup">setup	"Do any initialization required once we've got our parameters"	^self.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries" selector="postCopy">postCopy	instance := nil.	row := nil.	requiresPopulating := false.	isExpired := false.</body><body package="GlorpQueries" selector="reconcileWithBuilders:andCopy:">reconcileWithBuilders: oldCollection andCopy: newCollection</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>testing</category><body package="GlorpQueries" selector="buildsObjects">buildsObjects	^false.</body></methods><methods><class-id>Glorp.ElementBuilder class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="basicFor:in:">basicFor: anExpression in: aQuery	^(self basicClassFor: anExpression in: aQuery) new		expression: anExpression;		query: aQuery;		setup.</body><body package="GlorpQueries" selector="for:in:">for: anExpression in: aQuery	^(self classFor: anExpression in: aQuery) new		expression: anExpression;		query: aQuery;		setup.</body><body package="GlorpQueries" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.ElementBuilder class</class-id> <category>private</category><body package="GlorpQueries" selector="basicClassFor:in:">basicClassFor: anExpression in: aQuery	^(anExpression hasDescriptor and: [anExpression mapsSimpleObject not])		ifTrue: [ObjectBuilder] 		ifFalse: [DataElementBuilder].</body><body package="GlorpQueries" selector="classFor:in:">classFor: anExpression in: aQuery		((aQuery returnsDictionary and: [anExpression == aQuery baseExpression])		or: [anExpression returnsDictionary])			ifTrue: [^DictionaryBuilder].	^self basicClassFor: anExpression in: aQuery.</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries" selector="fieldsForSelectStatement">fieldsForSelectStatement	^#()</body><body package="GlorpQueries" selector="fieldsFromMyPerspective">fieldsFromMyPerspective	^#()</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>accessing</category><body package="GlorpQueries" selector="canCauseDuplicateRows">canCauseDuplicateRows	^expression class == MappingExpression and: [expression mapping isToManyRelationship].</body><body package="GlorpQueries" selector="instanceValue">instanceValue	^self instance value</body><body package="GlorpQueries" selector="subBuilders">subBuilders	^Array with: keyBuilder with: valueBuilder.</body><body package="GlorpQueries" selector="withAllSubBuilders">withAllSubBuilders	^Array with: self with: keyBuilder with: valueBuilder.</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>building objects</category><body package="GlorpQueries" selector="buildObjectFrom:">buildObjectFrom: anArray	"We just build an association out of the sub-builders "	| |	self row: anArray.</body><body package="GlorpQueries" selector="findInstanceForRow:proxyType:">findInstanceForRow: aRow proxyType: proxyType	instance := Association new.</body><body package="GlorpQueries" selector="knitResultIn:">knitResultIn: aCursoredStream	"Connect up our built object with any other objects that reference it. Used if we retrieve more than one thing in the same query"	| relatedBuilder |	instance key: keyBuilder instance.	instance value: valueBuilder instance.	"Code from ObjectBuilder&gt;&gt;knitResultIn:"	expression canKnit ifFalse: [^self].	relatedBuilder := aCursoredStream objectBuilderFor: expression base.	(relatedBuilder isNil or: [relatedBuilder instance isNil]) 		ifFalse: 			[expression mapping knitFromBuilder: relatedBuilder toBuilder: self]</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy</body><body package="GlorpQueries" selector="reconcileWithBuilders:andCopy:">reconcileWithBuilders: oldCollection andCopy: newCollection	"Fix up references to our internal sub-builders"	| keyIndex valueIndex |	keyIndex := oldCollection indexOf: keyBuilder.	keyBuilder := newCollection at: keyIndex.	valueIndex := oldCollection indexOf: valueBuilder.	valueBuilder := newCollection at: valueIndex.</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>initialize-release</category><body package="GlorpQueries" selector="setup">setup	"Do any initialization once we've got our parameters"	| base collectionType |	base := query baseExpression.	collectionType := expression == base ifTrue: [query collectionType] ifFalse: [expression mapping query collectionType].	keyBuilder := ElementBuilder for: (collectionType keyExpression asGlorpExpressionOn: expression) in: query.	valueBuilder := ElementBuilder basicFor: (collectionType valueExpression asGlorpExpressionOn: expression) in: query.</body></methods><methods><class-id>Glorp.Query</class-id> <category>accessing</category><body package="GlorpQueries" selector="collectionType">collectionType	"Note that queries default the collection type to array, while mappings default to OrderedCollection. I think it makes sense"	collectionType isNil ifTrue: [collectionType := Array].	^collectionType.</body><body package="GlorpQueries" selector="collectionType:">collectionType: aClass	collectionType := aClass.</body><body package="GlorpQueries" selector="expectedRows">expectedRows	"How many rows do we think it's likely this query will bring back. Used for tweaking things like block factor"	^expectedRows isNil		ifTrue: [expectedRows := self readsOneObject ifTrue: [1] ifFalse: [100]]		ifFalse: [expectedRows].</body><body package="GlorpQueries" selector="expectedRows:">expectedRows: anInteger	"How many rows do we think it's likely this query will bring back. Used for tweaking things like block factor"	expectedRows := anInteger</body><body package="GlorpQueries" selector="maximumLobSizeToRetrieveDirectly">maximumLobSizeToRetrieveDirectly	^maximumLobSizeToRetrieveDirectly</body><body package="GlorpQueries" selector="maximumLobSizeToRetrieveDirectly:">maximumLobSizeToRetrieveDirectly: anInteger	maximumLobSizeToRetrieveDirectly := anInteger.</body><body package="GlorpQueries" selector="platform">platform	^session system platform.</body><body package="GlorpQueries" selector="readsOneObject">readsOneObject	readsOneObject isNil ifTrue: [^false].	^readsOneObject.</body><body package="GlorpQueries" selector="readsOneObject:">readsOneObject: aBoolean 	readsOneObject := aBoolean</body><body package="GlorpQueries" selector="session">session	^session</body><body package="GlorpQueries" selector="session:">session: aSession 	session := aSession</body></methods><methods><class-id>Glorp.Query</class-id> <category>executing</category><body package="GlorpQueries" selector="executeIn:">executeIn: aSession	^self executeWithParameters:#() in: aSession.</body><body package="GlorpQueries" selector="executeWithParameters:in:">executeWithParameters: parameterArray in: aSession 	self subclassResponsibility.</body><body package="GlorpQueries" selector="resultCollectionFor:">resultCollectionFor: aCursoredStream	| results finalAnswer |	collectionType isNil ifTrue: [^aCursoredStream upToEnd].	collectionType == aCursoredStream class ifTrue: [^aCursoredStream].	results := (aCursoredStream newCollectionOfSize: self expectedRows for: collectionType) writeStream.	results nextPutAll: aCursoredStream upToEnd.	finalAnswer := results contents.	session register: finalAnswer.	^finalAnswer.</body></methods><methods><class-id>Glorp.Query</class-id> <category>specifying retrievals</category><body package="GlorpQueries" selector="retrieveDictionaryWithKey:value:">retrieveDictionaryWithKey: keyExpression value: valueExpression	self collectionType: (GlorpDictionaryDescription new keyExpression: keyExpression; valueExpression: valueExpression).</body><body package="GlorpQueries" selector="returnsDictionary">returnsDictionary	^collectionType class == GlorpDictionaryDescription.</body></methods><methods><class-id>Glorp.Query</class-id> <category>sql generation</category><body package="GlorpQueries" selector="printCompoundSelectAliasesOn:">printCompoundSelectAliasesOn: aStream	^self.</body><body package="GlorpQueries" selector="printGroupByOn:">printGroupByOn: aStream	groupBy isNil ifTrue: [^self].	aStream nextPutAll: ' GROUP BY '.	groupBy printSQLOn: aStream withParameters: nil.</body><body package="GlorpQueries" selector="printOrderingOn:">printOrderingOn: aStream	"Before printing, send each expression &gt;&gt;rewriteFunctionArguments.	It has no effect for most expressions and most functions, but is	needed with some platforms (see Substring)."	ordering isNil ifTrue: [^self].	aStream nextPutAll: ' ORDER BY '.	GlorpHelper		do: [:each |			each				rewriteFunctionArguments;				printSQLOn: aStream withParameters: nil]		for: ordering		separatedBy: [aStream nextPutAll: ', ']</body><body package="GlorpQueries" selector="rewriteExcept">rewriteExcept	"Rewrite any EXCEPT operation we have into a NOT EXISTS tests. Only a CompoundQuery would have such an operation"</body><body package="GlorpQueries" selector="rewriteIntersect">rewriteIntersect	"Rewrite any INTERSECT operation we have into an EXISTS tests. Only a CompoundQuery would have such an operation"</body></methods><methods><class-id>Glorp.Query</class-id> <category>ordering</category><body package="GlorpQueries" selector="expressionBlockFor:">expressionBlockFor: anOrderingCriteria	"Allow us to use symbols interchangeably with simple blocks for ordering, so 	#firstName is equivalent to [:each | each firstName]. Also, allow chains of symbols, so #(owner firstName)"	anOrderingCriteria isGlorpExpression ifTrue: [^anOrderingCriteria].	anOrderingCriteria glorpIsBlock ifTrue: [^anOrderingCriteria].	anOrderingCriteria isSymbol 		ifTrue: [^[:each | each perform: anOrderingCriteria]].		"otherwise, we assume it's a collection of symbols, the only other valid case"	anOrderingCriteria do: [:each | each isSymbol ifFalse: [self error: 'invalid ordering criteria']].	^[:each | anOrderingCriteria inject: each into: [:sum :eachExpression |		sum perform: eachExpression]].</body><body package="GlorpQueries" selector="groupBy">groupBy	^groupBy.</body><body package="GlorpQueries" selector="groupBy:">groupBy: aBlock	groupBy := aBlock.</body><body package="GlorpQueries" selector="orderBy:">orderBy: aBlock	ordering isNil 		ifTrue: [ordering := Array with: aBlock]		ifFalse: [ordering := ordering , (Array with: aBlock)].</body><body package="GlorpQueries" selector="ordering">ordering	^ordering.</body><body package="GlorpQueries" selector="setOrdering:">setOrdering: aCollection	ordering := aCollection.</body></methods><methods><class-id>Glorp.Query</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries" selector="copyAttributesTo:">copyAttributesTo: newQuery	"We're creating a new query similar to ourselves, ut not a direct copy. Copy over the relevant attributes. Note that we don't copy over the ordering, because that's less universally appropriate. Caller beware."	newQuery expectedRows: self expectedRows.	newQuery collectionType: self collectionType.	newQuery readsOneObject: self readsOneObject.	newQuery maximumLobSizeToRetrieveDirectly: self maximumLobSizeToRetrieveDirectly.</body><body package="GlorpQueries" selector="postCopy">postCopy	prepared := false.</body></methods><methods><class-id>Glorp.Query</class-id> <category>printing</category><body package="GlorpQueries" selector="printOn:">printOn: aStream	"I hate the printing with namespaces in vw"      | title |        title := self class name.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Glorp.Query</class-id> <category>testing</category><body package="GlorpQueries" selector="shortCircuitEmptyReturn:">shortCircuitEmptyReturn: parameters	^false.</body></methods><methods><class-id>Glorp.Query</class-id> <category>initialize</category><body package="GlorpQueries" selector="initialize">initialize	prepared := false.	maximumLobSizeToRetrieveDirectly := 32768.</body></methods><methods><class-id>Glorp.Query class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="count:">count: aClass	^self count: aClass where: nil.</body><body package="GlorpQueries" selector="count:where:">count: aClass where: anExpression	| query |	query := self returningOneOf: aClass where: anExpression.	query retrieve: #countStar.	^query.</body><body package="GlorpQueries" selector="new">new	^super new initialize.</body><body package="GlorpQueries" selector="read:">read: aClass	"readManyOf: and returningManyOf: are synonyms. This now seems more natural to me, to be consistent with session API"	^self returningManyOf: aClass where: nil.</body><body package="GlorpQueries" selector="read:where:">read: aClass where: anExpression	^self returningManyOf: aClass where: anExpression.</body><body package="GlorpQueries" selector="readManyOf:">readManyOf: aClass	"readManyOf: and returningManyOf: are synonyms. This now seems more natural to me, to be consistent with session API"	^self returningManyOf: aClass where: nil.</body><body package="GlorpQueries" selector="readManyOf:where:">readManyOf: aClass where: anExpression	^self returningManyOf: aClass where: anExpression.</body><body package="GlorpQueries" selector="readOneOf:">readOneOf: aClass	^self returningOneOf: aClass.</body><body package="GlorpQueries" selector="readOneOf:where:">readOneOf: aClass where: anExpression	^self returningOneOf: aClass where: anExpression.</body><body package="GlorpQueries" selector="returningManyOf:">returningManyOf: aClass	^self returningManyOf: aClass where: nil.</body><body package="GlorpQueries" selector="returningManyOf:where:">returningManyOf: aClass where: anExpression	"Backward-compatibility, since we changed the class name."	^SimpleQuery returningManyOf: aClass where: anExpression.</body><body package="GlorpQueries" selector="returningOneOf:">returningOneOf: aClass	"Backward-compatibility, since we changed the class name."	^SimpleQuery returningOneOf: aClass.</body><body package="GlorpQueries" selector="returningOneOf:where:">returningOneOf: aClass where: anExpression	"Backward-compatibility, since we changed the class name."	^SimpleQuery returningOneOf: aClass where: anExpression.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>testing</category><body package="GlorpQueries" selector="hasLimit">hasLimit	^self limit notNil.</body><body package="GlorpQueries" selector="hasOffset">hasOffset	^self offset notNil and: [self offset &gt; 0].</body><body package="GlorpQueries" selector="hasTracing">hasTracing	"Return true if we've given this query a tracing already"	^false.</body><body package="GlorpQueries" selector="limitMakesSense">limitMakesSense	^self hasLimit not or: [self limit &gt; 0].</body><body package="GlorpQueries" selector="requiresFullQuery">requiresFullQuery	^false.</body><body package="GlorpQueries" selector="returnTimedProxies">returnTimedProxies	^proxyType == TimedProxy</body><body package="GlorpQueries" selector="shortCircuitEmptyReturn">shortCircuitEmptyReturn	"If we have a literal false for criteria, we never need to go to the database.	We also don't need to go to database if limit doesnt make sense in terms of knowing beforehand that no results will be returned"	(whereClause class == EmptyExpression and: [whereClause isFalse]) ifTrue: [^true].	self limitMakesSense ifFalse: [^true].	^false.</body><body package="GlorpQueries" selector="shortCircuitEmptyReturn:">shortCircuitEmptyReturn: parameters	"If we have a literal false for criteria, we never need to go to the database.	We also don't need to go to database if limit doesnt make sense in terms of knowing beforehand that no results will be returned"	(whereClause class == EmptyExpression and: [whereClause isFalse])		ifTrue: [^true].	self limitMakesSense ifFalse: [^true].	self prepare.	(whereClause shortCircuitOnNullComparison: parameters) ifTrue: [^true].	^false.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>accessing</category><body package="GlorpQueries" selector="baseExpression">baseExpression	^base.</body><body package="GlorpQueries" selector="baseExpression:">baseExpression: aBaseExpression	base := aBaseExpression.</body><body package="GlorpQueries" selector="defaultTracing">defaultTracing	| defaultTracing |	defaultTracing := Tracing new.	defaultTracing base: base.	^defaultTracing.</body><body package="GlorpQueries" selector="descriptor">descriptor	^session descriptorFor: resultClass.</body><body package="GlorpQueries" selector="limit">limit	^limit.</body><body package="GlorpQueries" selector="limit:">limit: anInteger	limit := anInteger.</body><body package="GlorpQueries" selector="offset">offset	^offset</body><body package="GlorpQueries" selector="offset:">offset: anObject	offset := anObject.</body><body package="GlorpQueries" selector="proxyType">proxyType	"Answer the type of proxies the receiver should build when instantiating objects:		nil - Do not build proxies.		TimedProxy - Build TimedProxies.		Proxy - Build Proxies."	^proxyType</body><body package="GlorpQueries" selector="proxyType:">proxyType: aClass		proxyType := aClass.</body><body package="GlorpQueries" selector="resultClass">resultClass	^resultClass</body><body package="GlorpQueries" selector="resultType">resultType	"Return the database type that we are expecting to return from this query. This only makes sense if we're returning a single field. If we return a collection of types, just return nil here. If we return a mapped object, the #type message will cause an exception."	self tracing retrievalExpressions size = 1 ifFalse: [^nil].	^self tracing retrievalExpressions asArray first type.</body><body package="GlorpQueries" selector="returnProxies">returnProxies	^proxyType notNil</body><body package="GlorpQueries" selector="returnProxies:">returnProxies: aBoolean		aBoolean ifTrue: [proxyType := Proxy] ifFalse: [proxyType := nil].</body><body package="GlorpQueries" selector="returnTimedProxies:">returnTimedProxies: aBoolean	aBoolean ifTrue: [proxyType := TimedProxy] ifFalse: [proxyType := nil]</body><body package="GlorpQueries" selector="setUpBase">setUpBase	whereClause isGlorpExpression ifTrue: [base := whereClause queryLevelBaseExpression] ifFalse: [base := BaseExpression new].</body><body package="GlorpQueries" selector="shouldRefresh">shouldRefresh	^shouldRefresh</body><body package="GlorpQueries" selector="shouldRefresh:">shouldRefresh: aBoolean	shouldRefresh := aBoolean</body><body package="GlorpQueries" selector="tracing">tracing	tracing isNil ifTrue: [tracing := self defaultTracing].	^tracing.</body><body package="GlorpQueries" selector="tracing:">tracing: aTracing	tracing := aTracing.	tracing updateBase: base.	tracing setup.</body><body package="GlorpQueries" selector="whereClause">whereClause	^whereClause</body><body package="GlorpQueries" selector="whereClause:">whereClause: anExpression	whereClause := anExpression.	self setUpBase.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>initialize</category><body package="GlorpQueries" selector="initialize">initialize		super initialize.	proxyType := nil.	shouldRefresh := false.</body><body package="GlorpQueries" selector="initResultClass:whereClause:singleObject:">initResultClass: aClass whereClause: theCriteria singleObject: aBoolean 	resultClass := aClass.	self whereClause: ((theCriteria isNil or: [theCriteria = true or: [theCriteria = false]]) ifTrue: [EmptyExpression on: theCriteria] ifFalse: [theCriteria]).	readsOneObject := aBoolean.	aBoolean ifTrue: [self limit: 1].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>converting</category><body package="GlorpQueries" selector="asFullQuery">asFullQuery	^self.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>executing</category><body package="GlorpQueries" selector="executeWithParameters:in:">executeWithParameters: parameterArray in: aSession 	| |	session := aSession.	self requiresFullQuery 		ifTrue: [^self asFullQuery executeWithParameters: parameterArray in: aSession].	self checkValidity.	self setUpExpressions.	self checkCacheWithParameters: parameterArray ifPresent: [:hit | session register: hit. ^hit].	self setupTracing.	^self 		readFromDatabaseWithParameters: parameterArray.</body><body package="GlorpQueries" selector="readFromDatabaseWithParameters:">readFromDatabaseWithParameters: anArray	| answerStream result |	answerStream := self rowsFromDatabaseWithParameters: anArray.	^readsOneObject		ifTrue: [result := answerStream next. answerStream release. result]		ifFalse: [self resultCollectionFor: answerStream].</body><body package="GlorpQueries" selector="rowsFromDatabaseWithParameters:">rowsFromDatabaseWithParameters: anArray	self subclassResponsibility.</body><body package="GlorpQueries" selector="setUpExpressions">setUpExpressions	(whereClause isGlorpExpression and: [whereClause queryLevelBaseExpression notNil])		ifTrue:			[base := whereClause queryLevelBaseExpression.			base hasDescriptor				ifFalse: [base descriptor: (session descriptorFor: resultClass)]]		ifFalse:			[base isNil ifTrue: [base := BaseExpression new].			base descriptor: (session descriptorFor: resultClass).			whereClause := whereClause asGlorpExpressionOn: base in: self].	ordering isNil		ifFalse:			[ordering := ordering				collect:					[:each | (self expressionBlockFor: each) asGlorpExpressionOn: base in: self]].	groupBy isNil ifFalse: [groupBy := (self expressionBlockFor: groupBy) asGlorpExpressionOn: base in: self].	tracing isNil ifFalse: [tracing updateBase: base].	base descriptor typeResolver setUpExpressionsForQuery: self.</body><body package="GlorpQueries" selector="validateWhereClause">validateWhereClause	resultClass glorpCanHaveDescriptorDirectly ifFalse: [self error: 'Invalid result class for query'].	whereClause isJoin ifFalse: [		whereClause do: [:each | each validate]].	tracing isNil ifTrue: [^self].	tracing allTracings do: [:eachTracing |		eachTracing do: [:eachExpressionNode | eachExpressionNode validate]].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>private</category><body package="GlorpQueries" selector="privateAnd:">privateAnd: anExpression	"AND these two together without checking for common bases, rebuilding, etc. Everything had better be right"	whereClause := whereClause AND: anExpression.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="copyAttributesTo:">copyAttributesTo: newQuery	"We're creating a new query similar to ourselves, but not a direct copy. Copy over the relevant attributes."	super copyAttributesTo: newQuery.	newQuery limit: self limit.	newQuery offset: self offset.	newQuery proxyType: self proxyType.	newQuery shouldRefresh: self shouldRefresh.</body><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	base := BaseExpression new.	whereClause := whereClause asGlorpExpressionOn: base.	session isNil ifFalse: [self setUpExpressions].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>boolean operations</category><body package="GlorpQueries" selector="AND:">AND: anExpression	"Allow you to send AND: or OR: directly to a query to build up a query dynamically without needing to mess with the criteria explicitly"	whereClause := (anExpression		asGlorpExpressionOn: base) AND: ((whereClause asGlorpExpressionOn: base) asGeneralGlorpExpression).</body><body package="GlorpQueries" selector="except:">except: aQuery	^self minus: aQuery.</body><body package="GlorpQueries" selector="intersect:">intersect: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^aQuery].	self shortCircuitEmptyReturn ifTrue: [^self].	^CompoundQuery newIntersect addQuery: self; addQuery: aQuery.</body><body package="GlorpQueries" selector="minus:">minus: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	self shortCircuitEmptyReturn ifTrue: [^aQuery].	^CompoundQuery newMinus addQuery: self; addQuery: aQuery.</body><body package="GlorpQueries" selector="OR:">OR: anExpression	"Allow you to send AND: or OR: directly to a query to build up a query dynamically without needing to mess with the criteria explicitly"	whereClause := (anExpression asGlorpExpressionOn: base)		OR: (whereClause asGlorpExpressionOn: base) asGeneralGlorpExpression.</body><body package="GlorpQueries" selector="unionAll:">unionAll: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	self shortCircuitEmptyReturn ifTrue: [^aQuery].	^CompoundQuery newUnionAll addQuery: self; addQuery: aQuery.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>specifying retrievals</category><body package="GlorpQueries" selector="alsoFetch:">alsoFetch: anExpression	self tracing alsoFetch: (self expressionBlockFor: anExpression).</body><body package="GlorpQueries" selector="retrieve:">retrieve: anExpression	self tracing retrieve: (self expressionBlockFor: anExpression).</body><body package="GlorpQueries" selector="retrieveMax:">retrieveMax: anExpression	self tracing retrieve: ((self expressionBlockFor: anExpression) asGlorpExpression get: #max).</body><body package="GlorpQueries" selector="retrieveMin:">retrieveMin: anExpression	self tracing retrieve: ((self expressionBlockFor: anExpression) asGlorpExpression get: #min).</body><body package="GlorpQueries" selector="retrieveSum:">retrieveSum: anExpression	self tracing retrieve: ((self expressionBlockFor: anExpression) asGlorpExpression get: #sum).</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>caching</category><body package="GlorpQueries" selector="checkCacheWithParameters:ifPresent:">checkCacheWithParameters: aDictionary ifPresent: aBlock	| primaryKey result filteredResult |	readsOneObject ifFalse: [^nil].	self shouldRefresh ifTrue: [^nil].	"Check if we have retrieval expressions for something other than the base. If so, we're not actually reading this object, or at least not just this object"	self tracing retrievalExpressions do: [:each | each base isNil ifFalse: [^self]].	primaryKey := self primaryKeyFrom: aDictionary.	"We can't figure out the primary key"	primaryKey isNil ifTrue: [^nil].	"The primary key is invalid (i.e. has nulls in it). So we've found the entry, and we know it's nil"	primaryKey = #() ifTrue: [^aBlock value: nil].	"If it's expired, make sure we do the read but still refresh"  	(session hasExpired: resultClass key: primaryKey) ifTrue: [		self shouldRefresh: true.		^nil].	result := session 		cacheAt: primaryKey		forClass: resultClass		ifNone: [nil].	filteredResult := session filterDeletionFrom: result.	^filteredResult isNil ifTrue: [nil] ifFalse: [		(session system shouldResetExpiryTimeForObjectOfClass: filteredResult class readFrom: self)			ifTrue: [self session markAsCurrentOfClass: filteredResult class key: primaryKey].		aBlock value: filteredResult].</body><body package="GlorpQueries" selector="primaryKeyFrom:">primaryKeyFrom: aDictionary	"Construct a primary key from the given parameters."	self prepare.	(aDictionary		anySatisfy:			[:each | self session system shouldForeignKeyValueBeTreatedAsNull: each])		ifTrue: [^#()].	^self whereClause primaryKeyFromDictionary: aDictionary.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>preparing</category><body package="GlorpQueries" selector="adjustWhereClause">adjustWhereClause	^self.</body><body package="GlorpQueries" selector="prepare">prepare	prepared ifTrue: [^self].	self setupTracing.	prepared := true.</body><body package="GlorpQueries" selector="shouldExpressionBeJoin:">shouldExpressionBeJoin: anExpression	"Return true if the expression should be a join in our context (which means it refers only to tables we have in our from list) or if it should be ANDed into the where clause). Only relevant if we're using ANSI joins"	^anExpression		allSatisfy:			[:eachNode | 			| queryBase |			queryBase := eachNode queryLevelBaseExpression.			queryBase isNil or: [	queryBase = self baseExpression]].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>tracing</category><body package="GlorpQueries" selector="setupTracing">setupTracing	self setUpExpressions.	self tracing setup.	self tracing additionalExpressions do: [:each |		each hasDescriptor ifTrue: [			each descriptor trace: self tracing context: each].			each validate].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>validation</category><body package="GlorpQueries" selector="checkValidity">checkValidity	resultClass glorpCanHaveDescriptorDirectly ifFalse: [self error: 'resultClass must be a class'].	self descriptor isNil ifTrue: [self error: 'No descriptor for ', self resultClass name].	(ordering notNil and: [self descriptor supportsOrdering not]) ifTrue: [self error: 'The descriptor for ', self resultClass name, ' does not support ordering in queries'].</body></methods><methods><class-id>Glorp.AbstractReadQuery class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="newQuery">newQuery	^SimpleQuery new.</body><body package="GlorpQueries" selector="read:limit:">read: aClass limit: anInteger	^self returningManyOf: aClass limit: anInteger.</body><body package="GlorpQueries" selector="read:where:limit:">read: aClass where: anExpression limit: anInteger	^self		returningManyOf: aClass		where: anExpression		limit: anInteger.</body><body package="GlorpQueries" selector="readManyOf:limit:">readManyOf: aClass limit: anInteger	^self returningManyOf: aClass limit: anInteger.</body><body package="GlorpQueries" selector="readManyOf:where:limit:">readManyOf: aClass where: anExpression limit: anInteger	^self		returningManyOf: aClass		where: anExpression		limit: anInteger.</body><body package="GlorpQueries" selector="returningManyOf:">returningManyOf: aClass	^self returningManyOf: aClass where: nil.</body><body package="GlorpQueries" selector="returningManyOf:limit:">returningManyOf: aClass limit: anInteger	^self		returningManyOf: aClass		where: nil		limit: anInteger.</body><body package="GlorpQueries" selector="returningManyOf:where:">returningManyOf: aClass where: anExpression	^self returningManyOf: aClass where: anExpression limit: nil.</body><body package="GlorpQueries" selector="returningManyOf:where:limit:">returningManyOf: aClass where: anExpression limit: anInteger	^(self newQuery)		limit: anInteger;		initResultClass: aClass			whereClause: anExpression			singleObject: false;		yourself.</body><body package="GlorpQueries" selector="returningOneOf:">returningOneOf: aClass	^self returningOneOf: aClass where: nil.</body><body package="GlorpQueries" selector="returningOneOf:where:">returningOneOf: aClass where: anExpression	^self newQuery		initResultClass: aClass		whereClause: anExpression		singleObject: true.</body></methods><methods><class-id>Glorp.AdabasLikePlatform</class-id> <category>SQL</category><body package="GlorpDatabase" selector="supportsConstraints">supportsConstraints	"^&lt;Boolean&gt; This method returns true, if the database support a contraint concept"	^false</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>accessing</category><body package="GlorpCore" selector="classModel">classModel	^self descriptor classModel</body><body package="GlorpCore" selector="descriptor">descriptor	^self session descriptorFor: self class</body><body package="GlorpCore" selector="session">session	session isNil ifTrue: [session := self class getSession].	^session.</body><body package="GlorpCore" selector="session:">session: aGlorpSession	session := aGlorpSession</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>actions</category><body package="GlorpCore" selector="bePersistent">bePersistent	"Queue our object to be saved to the database upon commit."	self session		requireUnitOfWork;		register: self</body><body package="GlorpCore" selector="commitUnitOfWork">commitUnitOfWork	"Commit the entire unit of work; this may include objects other than myself."	self session hasUnitOfWork ifFalse: [^self].	self session commitUnitOfWork</body><body package="GlorpCore" selector="delete">delete	"Queue our object to be removed from the database on commit."	self session delete: self</body><body package="GlorpCore" selector="refresh">refresh	"Refresh our object from the database and rollback any changes registered in the unit of work."	self rollback.	self session refresh: self</body><body package="GlorpCore" selector="rollback">rollback	"Rollback our entries in the queue so that we are not involved in the commit."	self session hasUnitOfWork ifFalse: [^self].	self session rollbackUnitOfWorkFor: self</body><body package="GlorpCore" selector="rollbackUnitOfWork">rollbackUnitOfWork	"Rollback the entire unit of work; this may include objects other than myself."	self session hasUnitOfWork ifFalse: [^self].	self session rollbackUnitOfWork</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>finding objects</category><body package="GlorpCore" selector="find">find	"This is a query by example facility. We take whichever fields are filled in the object and read back any objects in the database that match."		| instances |	instances := GlorpVirtualCollection on: self class in: self session.	self descriptor mappings do: [:eachMapping | 		instances := self findMapping: eachMapping in: instances].	^instances.</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>private</category><body package="GlorpCore" selector="findMapping:in:">findMapping: aMapping in: aVirtualCollection		aMapping hasAttribute not ifTrue: [^aVirtualCollection].	aMapping attribute name = #session ifTrue: [^aVirtualCollection].	^(aMapping attribute getValueFrom: self)		ifNil: [aVirtualCollection]		ifNotNil: [:value | aVirtualCollection select: [:each | self matchAttribute: (each get: aMapping attribute name) to: value]].</body><body package="GlorpCore" selector="matchAttribute:to:">matchAttribute: anExpression to: value	"We match expressions differently depending on what type they are."		^(value isString and: [value includes: $%]) 		ifTrue: [anExpression like: value] 		ifFalse: [anExpression = value].</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>comparing</category><body package="GlorpCore" selector="=">= anObject	"Implement equality to compare primary keys if they are set. Make sure that if we have proxies, we check through them."	| descriptor myKey |	self class = anObject yourSelf class ifFalse: [^false].	descriptor := self descriptor.		"If the primary keys aren't equal, then we know for sure we are unequal. Otherwise we have to check further."	myKey := descriptor primaryKeyCollectionFor: self.	myKey = (descriptor primaryKeyCollectionFor: anObject)		ifFalse: [^false].	"If the primary key contains nils, then fall back to the default equality comparison. If they don't, and are equal, then the objects are equal."	^(myKey includes: nil) 		ifTrue: [super = anObject yourSelf]		ifFalse: [true].</body><body package="GlorpCore" selector="hash">hash	"Implement hash to compare primary keys if they are set. Make sure that if we have proxies, we check through them."	| myKey |	"If the primary key contains nils, then fall back to the default hash. If they don't, hash the collection."	myKey := self descriptor primaryKeyCollectionFor: self.	^(myKey includes: nil) 		ifTrue: [super hash]		ifFalse: [myKey hash]</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>finding objects</category><body package="GlorpCore" selector="count">count	"Count the number of objects in the database"	"Person count"	^ self getSession count: self</body><body package="GlorpCore" selector="find:">find: primaryKey	"Query the database for an object whose primary key = the given value."	"Person find: 1"	| session |	session := self getSession.	^session execute: (self query: primaryKey).</body><body package="GlorpCore" selector="findAll">findAll	"Query the database for all objects of this class."	"Person findAll"	^self getSession read: self.</body><body package="GlorpCore" selector="findWhere:">findWhere: aBlock	"Query the database for all objects of this class satisfying aBlock. The block has to be a query block, meaning you can't execute arbitrary code, but rather it will be analyzed and used to generate SQL."	"Person findWhere: [:each | (each name = 'John Doe') &amp; (each address houseNum = 1000)]"	^self getSession read: self where: aBlock.</body><body package="GlorpCore" selector="query:">query: primaryKey	"Return a query object that will query the database for an object whose primary key = the given value. If you want to just return the object, use find: instead. The advantage of this is that you can use this to get a basic query, but then modify it before executing it."	"Person query: 1"	| pkAttribute session |	session := self getSession.	pkAttribute := (session system descriptorFor: self) primaryKeyMappings first attribute name.	^Query readOneOf: self where: [:each | (each perform: pkAttribute) = primaryKey].</body><body package="GlorpCore" selector="queryAll">queryAll	"Return a query object that will query the database for all objects of this class. If you want to just return the object, use find: instead. The advantage of this is that you can use this to get a basic query, but then modify it before executing it."	"Person queryAll"	^Query read: self.</body><body package="GlorpCore" selector="queryWhere:">queryWhere: aBlock	"Return a Query object that will query the database for all objects of this class satisfying aBlock. The block has to be a query block, meaning you can't execute arbitrary code, but rather it will be analyzed and used to generate SQL. If you want to just return the objects, use findWhere: instead. The advantage of this is that you can use this to get a basic query, but then modify it before executing it, e.g. using AND: or OR:."	"Person queryWhere: [:each | (each name = 'John Doe') &amp; (each address houseNum = 1000)]"	^Query read: self where: aBlock.</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>accessing</category><body package="GlorpCore" selector="classModel">classModel	^self descriptor classModel</body><body package="GlorpCore" selector="descriptor">descriptor	^self getSession descriptorFor: self</body><body package="GlorpCore" selector="table">table	^self descriptor ifNotNil: [:descriptor | descriptor table]</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>instance creation</category><body package="GlorpCore" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>session</category><body package="GlorpCore" selector="getSession">getSession	"Return the session to be used for the current query. In general, we don't know how to find our session. Callers can catch the CannotFindSession exception and resume it, or subclasses can implement this method to find the session using mechanisms like process environment, a global, or whatever else they have available."	^CannotFindSession raise.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase" selector="connection">connection	^connection</body><body package="GlorpDatabase" selector="connection:">connection: aPlatformDatabaseConnection	connection := aPlatformDatabaseConnection</body><body package="GlorpDatabase" selector="connectionClass">connectionClass	^self connectionClassForLogin: currentLogin</body><body package="GlorpDatabase" selector="connectionClassForLogin:">connectionClassForLogin: aLogin	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="currentLogin">currentLogin	^currentLogin</body><body package="GlorpDatabase" selector="currentLogin:">currentLogin: aLogin 	currentLogin := aLogin</body><body package="GlorpDatabase" selector="deniedCommands">deniedCommands	^deniedCommands.</body><body package="GlorpDatabase" selector="deniedCommands:">deniedCommands: aCollection	deniedCommands := aCollection.</body><body package="GlorpDatabase" selector="encoding">encoding	"The connection is specific to the dialect;  some dialects will need to override this method."	^connection encoding</body><body package="GlorpDatabase" selector="encoding:">encoding: aSymbol	"The platform is a Glorp databasePlatform, so its setter code is generic across all dialects.  The connection is specific to the dialect;  some dialects will need to override how its encoding is set.  In the hope that most dialects will find this works for them, and that coders porting to dialects in which it does not will benefit from seeing the walkback and knowing they have something to do, we attempt to set both at top level."	self platform characterEncoding: aSymbol.	connection encoding: aSymbol.</body><body package="GlorpDatabase" selector="numberOfPreparedStatements">numberOfPreparedStatements	^0</body><body package="GlorpDatabase" selector="platform">platform	^currentLogin database.</body><body package="GlorpDatabase" selector="returnRowCount:">returnRowCount: aBoolean	^self.</body><body package="GlorpDatabase" selector="reusePreparedStatements">reusePreparedStatements	^reusePreparedStatements and: [self useBinding].</body><body package="GlorpDatabase" selector="reusePreparedStatements:">reusePreparedStatements: aBoolean	reusePreparedStatements := aBoolean.</body><body package="GlorpDatabase" selector="schema">schema	^ self currentLogin schema</body><body package="GlorpDatabase" selector="useBinding">useBinding	^self platform useBinding.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="login">login		| |	self loginIfError: [:ex | 		ex pass].	"Just to help avoid confusion if someone thinks they're getting a login object back from this"	^nil.</body><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock	self subclassResponsibility.</body><body package="GlorpDatabase" selector="logout">logout	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="showDialog:">showDialog: aString	self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>copying</category><body package="GlorpDatabase" selector="copy">copy	^self shallowCopy postCopy.</body><body package="GlorpDatabase" selector="postCopy">postCopy</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase" selector="log:">log: aStringOrBlock	"Log an arbitrary string"	| string |	self logging ifFalse: [^self].	string := aStringOrBlock isString		ifTrue: [aStringOrBlock]		ifFalse: [aStringOrBlock value].	string size &gt; 4000 ifTrue: [string := string copyFrom: 1 to: 4000].	self logger		cr;		show: string.</body><body package="GlorpDatabase" selector="logCommand:bound:">logCommand: aDatabaseCommand bound: aBoolean	"Log the execution of a command"	| string |	self changed: #command: with: aDatabaseCommand.	self logging ifFalse: [^self].	string := aDatabaseCommand sqlString. 	aBoolean ifTrue: [string := string , '  ' , aDatabaseCommand bindings printString].	string size &gt; 4000 ifTrue: [string := string copyFrom: 1 to: 4000].	self logger		cr;		show: string.</body><body package="GlorpDatabase" selector="logError:">logError: anErrorObject 	self log: anErrorObject printString</body><body package="GlorpDatabase" selector="logOnly">logOnly	logOnly ifNil: [logOnly := false].	^logOnly and: [self logging]</body><body package="GlorpDatabase" selector="logOnly:">logOnly: aBoolean	logOnly := aBoolean</body><body package="GlorpDatabase" selector="logger">logger	^logger ifNil: [Transcript]</body><body package="GlorpDatabase" selector="logger:">logger: aTextCollector	logger := aTextCollector</body><body package="GlorpDatabase" selector="logging">logging	logging isNil ifTrue: [^self class loggingEnabled].	^logging.</body><body package="GlorpDatabase" selector="logging:">logging: aBoolean 	logging := aBoolean</body><body package="GlorpDatabase" selector="logTime:">logTime: aTimeOrBlock	| time |	self logOnly ifTrue: [^self].	self changed: #time: with: aTimeOrBlock.	self logging ifFalse: [^self].	time := (Dialect isBlock: aTimeOrBlock)		ifTrue: [aTimeOrBlock value]		ifFalse: [aTimeOrBlock].	self logger		cr;		show: '(' , (time / 1000.0) printString , ' s)'.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="addConstraint:">addConstraint: aConstraint 		^self 		addConstraint: aConstraint		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Add constraint &lt;1s&gt; ERROR: (&lt;2s&gt;) ' expandMacrosWith: aConstraint name with: msg).				ex return: nil].</body><body package="GlorpDatabase" selector="addConstraint:ifError:">addConstraint: aConstraint ifError: aBlock	| addString |	addString := self platform createConstraintAddStatement: aConstraint.	addString isEmpty ifTrue: [^self].	^self		executeInDDLOperation: [ self executeSQLStringNoResult: addString ]		ifError: aBlock</body><body package="GlorpDatabase" selector="addFields:">addFields: aCollection 	self 		addFields: aCollection 		ifError: [ :ex  | 	| msg |				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Add field ERROR: (&lt;2s&gt;) ' expandMacrosWith: msg).				ex return: nil]</body><body package="GlorpDatabase" selector="addFields:ifError:">addFields: aCollection ifError: aBlock	aCollection		do: 	[:aField | 			self execute: [self executeSQLStringNoResult: (self platform createAddColumnStatementFor: aField)]				ifError: aBlock ].</body><body package="GlorpDatabase" selector="alterField:newType:">alterField: aField newType: aType 	^self 		alterField: aField 		newType: aType 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column &lt;1s&gt; to set new type &lt;2s&gt; ERROR: (&lt;3s&gt;) ' expandMacrosWith: aField name with: aType sqlString with: msg).				ex return: nil].</body><body package="GlorpDatabase" selector="alterField:newType:ifError:">alterField: aField newType: aType ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatement: aField newType: aType)]			ifError: aBlock ]</body><body package="GlorpDatabase" selector="alterField:setDefault:">alterField: aField setDefault: aType	self 		alterField: aField 		setDefault: aType 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to set default &lt;2s&gt;  ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name with: aType sqlString with: msg).				ex return: nil].</body><body package="GlorpDatabase" selector="alterField:setDefault:ifError:">alterField: aField setDefault: anObject ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatement: aField setDefault: anObject )]			ifError: aBlock ]</body><body package="GlorpDatabase" selector="alterFieldDropDefault:">alterFieldDropDefault: aField	self 		alterFieldDropDefault: aField 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to drop default ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name  with: msg).				ex return: nil].</body><body package="GlorpDatabase" selector="alterFieldDropDefault:ifError:">alterFieldDropDefault: aField ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatementDropDefault: aField)]			ifError: aBlock ]</body><body package="GlorpDatabase" selector="alterFieldDropNotNull:">alterFieldDropNotNull: aField	self 		alterFieldDropNotNull: aField 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to drop not null ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name  with: msg).				ex return: nil].</body><body package="GlorpDatabase" selector="alterFieldDropNotNull:ifError:">alterFieldDropNotNull: aField ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatementDropNotNull: aField)]			ifError: aBlock ]</body><body package="GlorpDatabase" selector="alterFieldSetNotNull:">alterFieldSetNotNull: aField		self 		alterFieldSetNotNull: aField		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to set not null ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name  with: msg).				ex return: nil].</body><body package="GlorpDatabase" selector="alterFieldSetNotNull:ifError:">alterFieldSetNotNull: aField ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatementSetNotNull: aField)]			ifError: aBlock ]</body><body package="GlorpDatabase" selector="basicExecuteSQLString:">basicExecuteSQLString: aString	self subclassResponsibility.</body><body package="GlorpDatabase" selector="basicExecuteSQLString:bindingArray:">basicExecuteSQLString: aString bindingArray: aBindingArray	self subclassResponsibility.</body><body package="GlorpDatabase" selector="basicExecuteSQLString:returnResult:binding:doing:">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	^self subclassResponsibility</body><body package="GlorpDatabase" selector="basicExecuteSQLStringNoResult:doing:">basicExecuteSQLStringNoResult: aString doing: aBlock	^self basicExecuteSQLString: aString returnResult: false binding: nil doing: aBlock.</body><body package="GlorpDatabase" selector="copyDataFromField:toField:ifError:">copyDataFromField: fromField toField: toField ifError: errorBlock	self		executeInDDLOperation: [ self executeSQLStringNoResult: (self platform sqlStatementToCopyDataFromColumn: fromField to: toField )]		ifError: errorBlock</body><body package="GlorpDatabase" selector="copyDataFromTable:toTable:ifError:">copyDataFromTable: fromTable toTable: anotherTable ifError: errorBlock	self		executeInDDLOperation: [ self executeSQLStringNoResult: (self platform sqlStatementToCopyDataFromTable: fromTable to: anotherTable) ]		ifError: errorBlock</body><body package="GlorpDatabase" selector="createSequence:ifError:">createSequence: aDatabaseSequence ifError: aBlock 	self		executeInDDLOperation: [ self executeSQLStringNoResult: aDatabaseSequence creationString]		ifError: aBlock</body><body package="GlorpDatabase" selector="createTable:ifError:">createTable: aGlorpDatabaseTable ifError: aBlock 	"This method should be used to create a database table from aTable"	aGlorpDatabaseTable isImaginary ifTrue: [^self].	self		executeInDDLOperation: [			self executeSQLStringNoResult: (self platform createTableStatementStringFor: aGlorpDatabaseTable)]		ifError: aBlock</body><body package="GlorpDatabase" selector="createTableFKConstraints:ifError:">createTableFKConstraints: aGLORBDatabaseTable ifError: aBlock 	"This method should be used to define foreign key constraints for a database table from aTable"	aGLORBDatabaseTable foreignKeyConstraintsForCreation		do: [ :each | self addConstraint: each ifError: aBlock ].</body><body package="GlorpDatabase" selector="createTableIndexes:ifError:">createTableIndexes: aGlorpDatabaseTable ifError: aBlock	"Create all indexes for this table"		(self platform createTableIndexStatementStringsFor: aGlorpDatabaseTable)		do: [:each | self execute: [self executeSQLStringNoResult: each] ifError: aBlock]</body><body package="GlorpDatabase" selector="dropConstraint:">dropConstraint: aConstraint 		^self 		dropConstraint: aConstraint 		ifError:  [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'no error message provided for top level exception'].				Transcript cr; show: ('Drop constraint &lt;1s&gt; ERROR: (&lt;2s&gt;'  expandMacrosWith: aConstraint name with: msg).				ex return: nil].</body><body package="GlorpDatabase" selector="dropConstraint:ifError:">dropConstraint: aConstraint ifError: aBlock	| dropString |	self platform supportsConstraints ifFalse: [^self].	dropString := self platform createConstraintDropStatement: aConstraint.	dropString isEmpty ifTrue: [^self].	self		executeInDDLOperation: [ self executeSQLStringNoResult: dropString ]		ifError:aBlock</body><body package="GlorpDatabase" selector="dropFields:">dropFields: aCollection 	self 		dropFields: aCollection 		ifError: [ :ex  | 	| msg |				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Drop field ERROR: (&lt;2s&gt;) ' expandMacrosWith: msg).				ex return: nil]</body><body package="GlorpDatabase" selector="dropFields:ifError:">dropFields: aCollection ifError: aBlock	aCollection		do: 	[:aField | 			self execute: [self executeSQLStringNoResult: (self platform createDropColumnStatementFor: aField)]				ifError: aBlock ].</body><body package="GlorpDatabase" selector="dropForeignKeyConstraintsForTable:ifError:">dropForeignKeyConstraintsForTable: aTable ifError: aBlock 	aTable isImaginary ifTrue: [^self].	aTable  foreignKeyConstraints do: [:each | self dropConstraint: each ifError: [ :ex | aBlock value: ex]].</body><body package="GlorpDatabase" selector="dropSequence:ifAbsent:">dropSequence: aDatabaseSequence ifAbsent: aBlock 	self		executeInDDLOperation: [ self executeSQLStringNoResult: aDatabaseSequence dropString ]		ifError: aBlock</body><body package="GlorpDatabase" selector="dropSequences:">dropSequences: anArray	anArray		do:			[:each | 			self				dropSequence: each				ifAbsent:					[:ex | 					Transcript show: (ex messageText ifNil: [ex printString]).					ex return: nil]].</body><body package="GlorpDatabase" selector="dropTable:ifError:">dropTable: aTable ifError: aBlock 	aTable isImaginary ifTrue: [^self].	self dropForeignKeyConstraintsForTable: aTable ifError: aBlock.	self dropTableDefinition: aTable ifError: aBlock.</body><body package="GlorpDatabase" selector="dropTableDefinition:ifError:">dropTableDefinition: aTable ifError: aBlock	"The dropping of the primary key constraints (a singular object not a collection, despite its name) is probably not needed before dropping the table by any database platform.  If 'platform supportsConstraints' is false then it will not be done, since dropConstraint:ifError: assumes it is called on a foreign key constraint (the case in all other callers) and does nothing if the platform does not support them."	aTable isImaginary ifTrue: [^self].	aTable hasPrimaryKeyConstraints ifTrue: [self dropConstraint: aTable  primaryKeyConstraints ifError: [:ex | aBlock value: ex]].	self dropTableNamed: aTable qualifiedName ifAbsent: aBlock.</body><body package="GlorpDatabase" selector="dropTableNamed:">dropTableNamed: aString 	self 		dropTableNamed: aString 		ifAbsent: [:ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Drop table &lt;1s&gt; ERROR: (&lt;2s&gt;) ' expandMacrosWith: aString with: msg).				ex return: nil]</body><body package="GlorpDatabase" selector="dropTableNamed:ifAbsent:">dropTableNamed: aString ifAbsent: aBlock 	self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: (self platform createDropTableStatementFor: aString )]			ifError: aBlock].</body><body package="GlorpDatabase" selector="dropTables:">dropTables: anArray 	anArray do: [:eachTable |				eachTable foreignKeyConstraints 					do: [:eachConstraint | self dropConstraint: eachConstraint]].	anArray do: [:each | 				self dropTableDefinition: each 					ifError: [ :ex | 	| msg|							msg := ex messageText.							msg isEmpty ifTrue: [msg := 'no error message provided for top level exception'].							Transcript cr; show: 'ERROR : (', msg, ' )'.							ex return: nil]].</body><body package="GlorpDatabase" selector="errorsToCatch">errorsToCatch	^Dialect error.</body><body package="GlorpDatabase" selector="execute:">execute: aBlock	^self execute: aBlock ifError: [:ex | ex pass].</body><body package="GlorpDatabase" selector="execute:ifError:">execute: aBlock ifError: errorBlock	^aBlock on: self errorsToCatch do: errorBlock.</body><body package="GlorpDatabase" selector="executeCommand:">executeCommand: command	^self executeCommand: command returnCursor: false.</body><body package="GlorpDatabase" selector="executeCommand:returnCursor:">executeCommand: command returnCursor: aBoolean	^mutex		critical:			[| result |			self checkPermissionFor: command.			result := [(self useBinding and: [command useBinding])				ifTrue: [command executeBoundIn: self]				ifFalse: [command executeUnboundIn: self]]				on: Dialect error				do: [:ex | self handleError: ex for: command].			aBoolean ifTrue: [result] ifFalse: [result upToEnd]].</body><body package="GlorpDatabase" selector="executeCommandBound:">executeCommandBound: command	"By default, we don't handle binding"	^command executeUnboundIn: self.</body><body package="GlorpDatabase" selector="executeCommandUnbound:"> executeCommandUnbound: aCommand	| cursor |	self logCommand: aCommand sqlString bound: false.	self logOnly ifTrue: [^self].	cursor := self basicExecuteSQLString: aCommand sqlString.	cursor command: aCommand.	^cursor.</body><body package="GlorpDatabase" selector="executeSQLString:">executeSQLString: aString	| result block time |	self log: aString.	self logOnly ifTrue: [^self].	block := [result := (self basicExecuteSQLString: aString) upToEnd].	time := self logging		ifTrue: [Time millisecondsToRun: block]		ifFalse:			[block value.			0].	self logTime: time.	^result.</body><body package="GlorpDatabase" selector="executeSQLString:binding:">executeSQLString: aString binding: aBindingArray	| result block time |	self log: aString.	self logOnly ifTrue: [^self].	block := [ 		result := (self basicExecuteSQLString: aString binding: aBindingArray) upToEnd].	time := self logging		ifTrue: [Time millisecondsToRun: block]		ifFalse:			[block value.			0].	self logTime: time.	^result.</body><body package="GlorpDatabase" selector="executeSQLStringNoResult:">executeSQLStringNoResult: aString	^self		executeSQLStringNoResult: aString		doing: []		forCommand: nil.</body><body package="GlorpDatabase" selector="executeSQLStringNoResult:doing:forCommand:">executeSQLStringNoResult: aString doing: aBlock forCommand: aCommand	"Execute the string and discard the result. Evaluate aBlock before releasing the statement's answer stream"	| block time |	aCommand isNil ifTrue: [self log: aString] ifFalse: [self logCommand: aCommand bound: false].	self logOnly ifTrue: [^self].	block := [self basicExecuteSQLStringNoResult: aString doing: aBlock].	time := self logging		ifTrue: [Time millisecondsToRun: block]		ifFalse:			[block value.			0].	self logTime: time.</body><body package="GlorpDatabase" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	self subclassResponsibility.</body><body package="GlorpDatabase" selector="handleError:for:">handleError: exception for: command	"Signal a GlorpDatabase... error.  If it is handled to return true (any handler or defaultAction had better not return true in response to an error that logging in or logging out could reraise and on which it would again return true) and we have a reusable login, try to logout and in again and restart, otherwise exit."	| errorClass error |	errorClass := command isReadCommand		ifTrue: [GlorpDatabaseReadError]		ifFalse: [GlorpDatabaseWriteError].	error := errorClass new.	error command: command.	error databaseError: (self innerExceptionFor: exception).	error accessor: self.	(error signal ~~ true or: [currentLogin isNil or: [currentLogin secure]])		ifTrue: [exception return: nil]		ifFalse:			[self reset.			self logout.			self reLogin.			exception restart].</body><body package="GlorpDatabase" selector="innerExceptionFor:">innerExceptionFor: exception	^exception parameter.</body><body package="GlorpDatabase" selector="populateField:with:ifError:">populateField: aDatabaseField with: aValue ifError: errorBlock	self		executeInDDLOperation: [			self executeSQLStringNoResult: (self platform sqlStatementToPopulateColumn: aDatabaseField with: aValue) ]		ifError: errorBlock</body><body package="GlorpDatabase" selector="renameField:to:ifError:">renameField: aDatabaseField to: nameString ifError: errorBlock	self		executeInDDLOperation: [ self executeSQLStringNoResult: (self platform sqlStatementToRenameColumn: aDatabaseField to: nameString) ]		ifError: errorBlock</body><body package="GlorpDatabase" selector="renameTable:to:inPlatform:ifError:">renameTable: aDatabaseTable to: newTableName inPlatform: aDatabasePlatform ifError: errorBlock	| sqlStatement |	sqlStatement := aDatabasePlatform sqlStatementToRenameTable: aDatabaseTable to: newTableName.		self		executeInDDLOperation: [ self executeSQLStringNoResult: sqlStatement ]		ifError: errorBlock</body><body package="GlorpDatabase" selector="rowCount">rowCount	^self subclassResponsibility</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>permissions</category><body package="GlorpDatabase" selector="allowCommand:during:">allowCommand: aCommand during: aBlock	| oldCommands |	oldCommands := self deniedCommands.	((self deniedCommands ifNil: [#()]) includes: aCommand)		ifTrue: [deniedCommands := deniedCommands copyWithout: aCommand].	aBlock ensure: [deniedCommands := oldCommands].</body><body package="GlorpDatabase" selector="alsoDenyCommand:">alsoDenyCommand: aCommand	self deniedCommands isNil		ifTrue: [self denyCommand: aCommand]		ifFalse:			[self deniedCommands: self deniedCommands , (Array with: aCommand)].</body><body package="GlorpDatabase" selector="beReadOnly">beReadOnly	self denyWrites.</body><body package="GlorpDatabase" selector="checkPermissionFor:">checkPermissionFor: command	deniedCommands isNil ifTrue: [^self].	(deniedCommands includes: command class)		ifTrue: [(GlorpIllegalCommand new command: command) signal].</body><body package="GlorpDatabase" selector="denyCommand:">denyCommand: aCommand	(aCommand isBehavior) ifFalse: [self error: 'invalid command type'].	self denyCommands: (Array with: aCommand).</body><body package="GlorpDatabase" selector="denyCommands:">denyCommands: aCollection	deniedCommands := aCollection asArray.</body><body package="GlorpCore" selector="denyReads">denyReads	deniedCommands := SelectCommand glorpAllSubclasses.</body><body package="GlorpCore" selector="denyWrites">denyWrites	deniedCommands := RowBasedCommand glorpAllSubclasses.</body><body package="GlorpCore" selector="insertOnly">insertOnly	self denyCommands: (Array with: UpdateCommand with: DeleteCommand).</body><body package="GlorpDatabase" selector="permitEverything">permitEverything	"Note that nil is treated as a flag indicating that all commands are allowed"	deniedCommands := nil.</body><body package="GlorpCore" selector="permitNothing">permitNothing	deniedCommands := DatabaseCommand glorpAllSubclasses asArray.</body><body package="GlorpDatabase" selector="permitNothingDuring:">permitNothingDuring: aBlock	| oldCommands |	oldCommands := self deniedCommands.	self permitNothing.	aBlock ensure: [deniedCommands := oldCommands].</body><body package="GlorpCore" selector="permitsInserts">permitsInserts	deniedCommands isNil ifTrue: [^true].	^(deniedCommands includes: InsertCommand) not.</body><body package="GlorpCore" selector="permitsUpdates">permitsUpdates	deniedCommands isNil ifTrue: [^true].	^(deniedCommands includes: UpdateCommand) not.</body><body package="GlorpDatabase" selector="resetPermissions">resetPermissions	self permitEverything.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>cursors</category><body package="GlorpDatabase" selector="completedCommand:">completedCommand: aCommand	"Indicate that we've completed the command. Release associated resources."	^self.</body><body package="GlorpDatabase" selector="cursorFor:">cursorFor: aStream	^GlorpCursoredStream on: aStream accessor: self.</body><body package="GlorpDatabase" selector="cursorFor:command:">cursorFor: answerStream command: aCommand	^aCommand isNil		ifTrue: [self cursorFor: answerStream]		ifFalse: [GlorpCursoredStream on: answerStream for: aCommand accessor: self].</body><body package="GlorpDatabase" selector="isCursorAtEnd:">isCursorAtEnd: aCursor	"Return true if aCursor is at its end. This implementation may not work for all, but it seems like a reasonable default"	^aCursor atEnd.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>notification</category><body package="GlorpDatabase" selector="myDependents">myDependents	^dependents.</body><body package="GlorpDatabase" selector="myDependents:">myDependents: aCollection	dependents := aCollection.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase" selector="beginTransaction">beginTransaction	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="commitTransaction">commitTransaction	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="doDDLOperation:">doDDLOperation: aBlock	"Execute DDL SQL - something which creates/drops/modifies tables or other schema information. The main reason for this method is that some databases require a transaction, while others don't require it, and still others don't allow it. Try to do the right thing."		^self platform requiresTransactionForTableOperations		ifTrue: [self inTransactionDo: aBlock]		ifFalse: aBlock.</body><body package="GlorpDatabase" selector="executeInDDLOperation:ifError:">executeInDDLOperation: aBlock ifError: errorBlock	"Execute DDL SQL - something which creates/drops/modifies tables or other schema information. The main reason for this method is that some databases require a transaction, while others don't require it, and still others don't allow it. Try to do the right thing."	^ self doDDLOperation: [		self			execute: aBlock			ifError: errorBlock ]</body><body package="GlorpDatabase" selector="inTransactionDo:">inTransactionDo: aBlock	"Execute aBlock in a database transaction. If one is already in progress, just continue. If not, start a transaction."	| alreadyInTransaction result |	[ 	alreadyInTransaction := self isInTransaction.	alreadyInTransaction ifFalse: [self beginTransaction].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	alreadyInTransaction ifFalse: [self commitTransaction]]		ifCurtailed:			[alreadyInTransaction ifFalse: [self rollbackTransaction]].	^result.</body><body package="GlorpDatabase" selector="isInTransaction">isInTransaction	^self subclassResponsibility.</body><body package="GlorpDatabase" selector="rollbackTransaction">rollbackTransaction	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>obsolete</category><body package="GlorpCore" selector="createConstraint:">createConstraint: aConstraint	^self addConstraint: aConstraint</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>initialize-release</category><body package="GlorpDatabase" selector="initialize">initialize	deniedCommands := nil.	mutex := Semaphore forMutualExclusion.</body><body package="GlorpDatabase" selector="reset">reset	"Don't reset the permissions, because the replicator wants to reset sessions without changing their characteristics""	self permitEverything."</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>testing</category><body package="GlorpDatabase" selector="isExistingTable:inSchema:">isExistingTable: tableName inSchema: schemaName	| databasePlatform sqlStatement result |	databasePlatform := self currentLogin platform.	sqlStatement := databasePlatform sqlStatementToTestExistenceOfTable: tableName inSchema: schemaName.	result := self executeSQLString: sqlStatement.	^result notEmpty		ifTrue: [result first first &gt; 0]		ifFalse: [false]</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>queries metadata</category><body package="GlorpDatabase" selector="listTableNamesInSchemaNamed:">listTableNamesInSchemaNamed: schemaString	| databasePlatform sqlStatement result |	databasePlatform := self currentLogin platform.	sqlStatement := databasePlatform sqlStatementToListTablesInSchema: schemaString.	result := self executeSQLString: sqlStatement.	^result isEmpty		ifTrue: [#()]		ifFalse: [result collect: [:ea| ea first]]</body></methods><methods><class-id>Glorp.DatabaseAccessor class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="classForThisPlatform">classForThisPlatform	Dialect isVisualWorks ifTrue: [^Dialect smalltalkAt: #'Glorp.VWDatabaseAccessor'].	Dialect isObjectStudio ifTrue: [^Dialect smalltalkAt: #ObjectStudioDatabaseAccessor].	Dialect isGNU ifTrue: [^Dialect smalltalkAt: #JdmDatabaseAccessor].	Dialect isSqueak ifTrue: [^Dialect smalltalkAt: #SqueakDatabaseAccessor].	Dialect isVisualAge ifTrue: [^Dialect smalltalkAt: #VADatabaseAccessor].	Dialect isDolphin ifTrue: [^Dialect smalltalkAt: #DolphinDatabaseAccessor].	self error: 'unknown dialect'.	^self</body><body package="GlorpDatabase" selector="forLogin:">forLogin: aLogin 	^self classForThisPlatform new currentLogin: aLogin</body><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.DatabaseAccessor class</class-id> <category>accessing</category><body package="GlorpDatabase" selector="loggingEnabled">loggingEnabled	LoggingEnabled isNil ifTrue: [LoggingEnabled := false].	^LoggingEnabled</body><body package="GlorpDatabase" selector="loggingEnabled:">loggingEnabled: aBoolean 	LoggingEnabled := aBoolean</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="connectionArgsFromCurrentLogin">connectionArgsFromCurrentLogin	"connect string looks like  hostname:portNumber_db-name. :portNumber is optional"	| str portIndex index dbIndex |	str := self currentLogin connectString.	portIndex := index := str indexOf: $:.	dbIndex := str indexOf: $_.	index = 0 ifTrue: [index := dbIndex].	^(Dialect smalltalkAt: #PGConnectionArgs)		hostname: (str copyFrom: 1 to: index - 1)		portno: (portIndex = 0 ifTrue: [5432] ifFalse: [(str copyFrom: portIndex + 1 to: dbIndex - 1) asNumber])		databaseName: (str copyFrom: dbIndex + 1 to: str size)		userName: self currentLogin username		password: self currentLogin password</body><body package="GlorpDatabase" selector="connectionClassForLogin:">connectionClassForLogin: aLogin 	aLogin database class == PostgreSQLPlatform		ifTrue: [^ Smalltalk at: #PGConnection].	self error: 'Unknown database: ' , aLogin database</body><body package="GlorpDatabase" selector="isLoggedIn">isLoggedIn	connection isNil		ifTrue: [^ false].	^ connection isConnected</body><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock 	self log: 'Login'.	self logOnly ifTrue: [^self].	connection := self connectionClass new.	connection connectionArgs: self connectionArgsFromCurrentLogin.	self		execute: [connection startup]		ifError: aBlock.	self log: 'Login finished'</body><body package="GlorpDatabase" selector="logout">logout	self isLoggedIn ifFalse: [^self].	self log: 'Logout'.	self logOnly ifTrue: [^self].	self execute: [connection terminate].	self log: 'Logout finished'</body><body package="GlorpDatabase" selector="showDialog:">showDialog: aString 	"Do 'Smalltalk at: #PopUpMenu' so that the code will compile in other dialects, even if it won't run"	(Smalltalk at: #PopUpMenu) inform: aString</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase" selector="beginTransaction">beginTransaction	self log: 'Begin Transaction'.	isInTransaction := true.	self logOnly ifTrue: [^self].	connection execute: 'BEGIN TRANSACTION'</body><body package="GlorpDatabase" selector="commitTransaction">commitTransaction	self log: 'Commit Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	connection execute: 'COMMIT TRANSACTION'</body><body package="GlorpDatabase" selector="isInTransaction">isInTransaction	^ isInTransaction</body><body package="GlorpDatabase" selector="rollbackTransaction">rollbackTransaction	self log: 'Rollback Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	connection execute: 'ROLLBACK TRANSACTION'</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>initialize</category><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	isInTransaction := false</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="basicExecuteSQLString:">basicExecuteSQLString: aString	| result rowCollection |	self log: aString.	self logOnly ifTrue: [^self].	result := connection execute: aString.	result errorResponse notNil		ifTrue:			[self externalDatabaseErrorSignal signal: result errorResponse value].	rowCollection := OrderedCollection new.	result rows do: [:ea | rowCollection add: ea data asArray]. 	^rowCollection asArray</body><body package="GlorpDatabase" selector="basicExecuteSQLStringNoResult:doing:">basicExecuteSQLStringNoResult: aString doing: aBlock	| a |	a := self basicExecuteSQLString: aString.	aBlock value.	^a</body><body package="GlorpDatabase" selector="disconnect">disconnect	^ connection disconnect</body><body package="GlorpDatabase" selector="executeCommandUnbound:">executeCommandUnbound: aCommand	| answerStream |	self log: aCommand sqlString.	self logOnly ifTrue: [^self].	answerStream := ReadStream on: (self basicExecuteSQLString: aCommand sqlString).	aCommand needsRowCount		ifTrue:			[aCommand				rowCount:					(self platform supportsRowCount						ifTrue: [answerStream rowCount]						ifFalse: [1])].	^self cursorFor: answerStream command: aCommand.</body><body package="GlorpDatabase" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	^ Dialect error</body><body package="GlorpDatabase" selector="innerExceptionFor:">innerExceptionFor: exception	"I don't know how to get the inner error in Squeak"	^exception messageText.</body><body package="GlorpDatabase" selector="releaseCursor:in:">releaseCursor: aCursor in: aPreparedStatement	"Release the cursor. We're trapping exceptions, so return true or false to indicate success/failure"	aCursor isNil ifTrue: [^self].	^[aCursor close. true] on: Dialect error do: [:ex | ex return: false].</body><body package="GlorpDatabase" selector="rowCount">rowCount	|count|	count := 0.	connection result resultSets		do: [:each| count := count + 			(each completedResponse value subStrings: (Array with: Character space)) last asInteger].	^count</body></methods><methods><class-id>Glorp.GlorpAbstractNumericType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Number.</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	^self platform converterNamed: #numberToDouble.</body><body package="GlorpDatabaseTypes" selector="typeString">typeString	^'float'.</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Float.</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Float.</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'float'.</body></methods><methods><class-id>Glorp.GlorpAbstractIntegerType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToInteger].	^self platform converterNamed: #numberToInteger.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Integer.</body></methods><methods><class-id>Glorp.GlorpAbstractIntegerType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Integer.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	generated := true.</body><body package="GlorpDatabaseTypes" selector="initializeForField:in:">initializeForField: aDatabaseField in: aDescriptorSystem	sequence isNil ifFalse: [^self].	sequence := aDescriptorSystem databaseSequenceNamed: (aDescriptorSystem sequenceNameForField: aDatabaseField).	sequence schema: aDatabaseField table schema.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="hasSequence">hasSequence	^true.</body><body package="GlorpDatabaseTypes" selector="isIdentityColumn">isIdentityColumn	^self sequence isIdentityColumn.</body><body package="GlorpDatabaseTypes" selector="isSerial">isSerial	"answer if this is a database-generated primary key column"	^true</body><body package="GlorpDatabaseTypes" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aCommand withParameters: aDictionary	"We record our type as serial, but that isn't really useful for a cast. We assume serials are integers, so just print a generic integer type instead."	self platform integer printSelectSQLOn: aCommand withParameters: aDictionary.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="hasParameters">hasParameters	^true.</body><body package="GlorpDatabaseTypes" selector="isGenerated">isGenerated	"answer if we should autogenerate a value for this type, i.e. if it is a database-generated primary key column"	^generated</body><body package="GlorpDatabaseTypes" selector="sequence">sequence	^sequence.</body><body package="GlorpDatabaseTypes" selector="sequence:">sequence: aDatabaseSequence	sequence := aDatabaseSequence.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>sequencing</category><body package="GlorpDatabaseTypes" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	^sequence postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor.</body><body package="GlorpDatabaseTypes" selector="preWriteAssignSequenceValueFor:in:using:">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	^sequence preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor.</body></methods><methods><class-id>Glorp.DB2IdentityType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initializeForField:in:">initializeForField: aDatabaseField in: aDescriptorSystem	sequence isNil ifFalse: [^self].	sequence := aDescriptorSystem				databaseIdentitySequenceNamed: (aDescriptorSystem sequenceNameForField: aDatabaseField).	sequence schema: aDatabaseField table schema</body></methods><methods><class-id>Glorp.DB2IdentityType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="isIdentityColumn">isIdentityColumn	^true</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>building objects</category><body package="GlorpQueries" selector="buildersThatReturnResults">buildersThatReturnResults	buildersThatReturnResults isNil ifTrue: [		buildersThatReturnResults := OrderedCollection new.		builders			do: [:each | 					| expression shouldBeRetrieved |				"For some bizarre reason, includes: fails on ObjectStudio for this"				expression := each expression.				shouldBeRetrieved := (self query tracing retrievalExpressions detect: [:foo |					foo == expression] ifNone: [nil]) notNil.				(shouldBeRetrieved and: [					(buildersThatReturnResults anySatisfy: [:eachBuilder | eachBuilder expression == expression]) not])						ifTrue: [buildersThatReturnResults add: each]].		buildersThatReturnResults := buildersThatReturnResults asArray].	^buildersThatReturnResults.</body><body package="GlorpQueries" selector="buildObjectsForRow:">buildObjectsForRow: aRow	self query isNil ifTrue: [^aRow].	builders		do:			[:each | each findInstanceForRow: aRow proxyType: self query proxyType].	builders do: [:each | each buildObjectFrom: aRow].	builders		do:			[:each | 			each				sendPostFetchValidateIn: self session 				OnFailureDo: [each instance: nil]].	builders		do: [:each | each instance == nil ifFalse: [each knitResultIn: self]].	builders do: [:each | self session sendPostFetchEventTo: each instance].	^self buildersThatReturnResults size = 1		ifTrue: [self buildersThatReturnResults first returnValueIn: self]		ifFalse:			[self buildersThatReturnResults collect: [:each | each returnValueIn: self]].</body><body package="GlorpQueries" selector="collectionTypeFor:">collectionTypeFor: aCollectionType	"Make sure that we can reasonably return aCollectionType. If not, default to something we can"	aCollectionType class == GlorpDictionaryDescription ifFalse: [^aCollectionType].	self buildersThatReturnResults size = 1 ifTrue: [^aCollectionType].	^Array.</body><body package="GlorpQueries" selector="elementBuilderFor:">elementBuilderFor: anExpression 	^builders detect: [:each | each expression == anExpression] ifNone: [nil].</body><body package="GlorpQueries" selector="hasCompleteAnswerFor:">hasCompleteAnswerFor: objects	| nextAnswer |	self atEnd ifTrue: [^true].	self mightHaveDuplicateRows ifFalse: [^true].	nextAnswer := self peek.	^objects ~= nextAnswer</body><body package="GlorpQueries" selector="newCollectionOfSize:for:">newCollectionOfSize: aSize for: aCollectionType	"Make sure that we can reasonably return aCollectionType. If not, default to something we can"	| theType |	theType := self collectionTypeFor: aCollectionType.	^theType isBehavior ifTrue: [theType new: aSize] ifFalse: [theType copyEmpty: aSize].</body><body package="GlorpQueries" selector="nextAnswer">nextAnswer	| result |	peekBuffer isNil ifFalse: [		result := peekBuffer.		peekBuffer := nil.		^result].	^self nextAnswerFromUnderlyingCursor.</body><body package="GlorpQueries" selector="nextAnswerFromUnderlyingCursor">nextAnswerFromUnderlyingCursor	| objects |	rawPeekBuffer isNil ifTrue: [rawPeekBuffer := cursor next].	rawPeekBuffer isNil ifTrue: [^nil].	objects := self buildObjectsForRow: rawPeekBuffer.	rawPeekBuffer := nil.	^objects.</body><body package="GlorpQueries" selector="nextObjectFrom:">nextObjectFrom: aRow	| objects |	objects := self buildObjectsForRow: aRow.	self mightHaveDuplicateRows ifFalse: [		self registerInstances.		^objects].</body><body package="GlorpQueries" selector="objectBuilderFor:">objectBuilderFor: anExpression 	"Return the builder for this expression, but only those that directly build compound objects. Most importantly, exclude dictionary builders"	^builders detect: [:each | 		each buildsObjects and: [each expression == anExpression]] ifNone: [nil].</body><body package="GlorpQueries" selector="registerInstances">registerInstances	self session isNil ifTrue: [^self].	builders do: [:each | self session register: each instance].</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>accessing</category><body package="GlorpQueries" selector="command">command	^command</body><body package="GlorpQueries" selector="command:">command: aDatabaseCommand	command := aDatabaseCommand.	aDatabaseCommand isNil ifTrue: [^self].	aDatabaseCommand query isNil ifTrue: [^self].	databaseAccessor := aDatabaseCommand query session accessor.	builders := self query copyOfBuilders.	builders do: [:each | each cursor: self].</body><body package="GlorpQueries" selector="contents">contents	self shouldNotImplement.</body><body package="GlorpQueries" selector="cursor">cursor	^cursor</body><body package="GlorpQueries" selector="cursor:">cursor: aStream	cursor := aStream</body><body package="GlorpQueries" selector="databaseAccessor:">databaseAccessor: aDatabaseAccessor	databaseAccessor := aDatabaseAccessor</body><body package="GlorpQueries" selector="flush">flush	^self.</body><body package="GlorpQueries" selector="mightHaveDuplicateRows">mightHaveDuplicateRows	mightHaveDuplicateRows isNil ifTrue: [mightHaveDuplicateRows := self query isNil ifTrue: [false] ifFalse: [self query mightHaveDuplicateRows]].	^mightHaveDuplicateRows.</body><body package="GlorpQueries" selector="next">next	| answer session |	self atEnd ifTrue: [^nil].	session := self session.	[self atEnd ifTrue: [^nil].	answer := self nextAnswer.	answer == nil] 		whileTrue.	[self hasCompleteAnswerFor: answer] whileFalse: [self nextAnswer].	session == nil ifFalse: [session privateRegisterAsOld: answer].	^answer.</body><body package="GlorpQueries" selector="next:">next: anInteger	| result |	Dialect isObjectStudio ifFalse: [^super next: anInteger].	result := OrderedCollection new: anInteger.	anInteger timesRepeat: [result add: self next].	^result.</body><body package="GlorpQueries" selector="nextPut:">nextPut: anObject	self shouldNotImplement.</body><body package="GlorpQueries" selector="peek">peek	peekBuffer = nil ifFalse: [^peekBuffer].	peekBuffer := self nextAnswer.	^peekBuffer.</body><body package="GlorpQueries" selector="privateGetBuilders">privateGetBuilders	^builders.</body><body package="GlorpQueries" selector="query">query	command isNil ifTrue: [^nil].	^command query.</body><body package="GlorpQueries" selector="query:">query: x</body><body package="GlorpQueries" selector="session">session	^self query isNil ifTrue: [nil] ifFalse: [self query session].</body><body package="GlorpQueries" selector="statement">statement	^statement.</body><body package="GlorpQueries" selector="statement:">statement: aGlorpPreparedStatement	statement := aGlorpPreparedStatement.</body><body package="GlorpQueries" selector="upToEnd">upToEnd	| result |	result := WriteStream on: (Array new: 100).	[self atEnd] whileFalse: [			| nextValue |			"Stupid VA's cursors don't deal with atEnd or isEmpty nicely, so check for nil"			nextValue := self next.			nextValue == nil ifFalse: [	result nextPut: nextValue]].	^result contents</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>testing</category><body package="GlorpQueries" selector="accessor">accessor	^databaseAccessor.</body><body package="GlorpDatabase" selector="atEnd">atEnd	"Release ourselves fairly aggressively when we hit the end"	| accessor |	peekBuffer isNil ifFalse: [^false].	rawPeekBuffer isNil ifFalse: [^false].	cursor isNil ifTrue: [^true].	"For test purposes, fabricate an accessor if we don't have one, it's not really needed for a non-db stream"	accessor := self accessor isNil ifTrue: [DatabaseAccessor new] ifFalse: [self accessor].	^([accessor isCursorAtEnd: cursor] on: Dialect error do: [:ex | databaseAccessor handleError: ex for: command])		ifTrue:			[self release.			true]		ifFalse: [	"We have to do this, because VA won't answer true to atEnd until we've read past end"			self rawPeek isNil].</body><body package="GlorpQueries" selector="isReadable">isReadable	^true.</body><body package="GlorpQueries" selector="isWritable">isWritable	^false.</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>iterating</category><body package="GlorpQueries" selector="collect:">collect: aBlock 	| newStream |	newStream := WriteStream on: (Array new: 100).	[self atEnd] whileFalse: [newStream nextPut: (aBlock value: self next)].	^newStream contents</body><body package="GlorpQueries" selector="detect:">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [self error: 'not found']</body><body package="GlorpQueries" selector="detect:ifNone:">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="GlorpQueries" selector="do:">do: aBlock 	"Evaluate aBlock for each of the elements of the receiver."	[self atEnd]		whileFalse: [aBlock value: self next]</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>initializing</category><body package="GlorpQueries" selector="initialize">initialize</body><body package="GlorpQueries" selector="release">release	super release.	self releaseCursor.	cursor := nil.	rawPeekBuffer := nil.	peekBuffer := nil.	statement isNil		ifFalse:			[databaseAccessor reusePreparedStatements				ifTrue: [statement busy: false]				ifFalse: [statement release].			statement := nil].	databaseAccessor := nil.</body><body package="GlorpQueries" selector="releaseCursor">releaseCursor		self accessor isNil		ifFalse:			[self accessor releaseCursor: cursor in: statement.			self accessor completedCommand: command].</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>debugging</category><body package="GlorpQueries" selector="rows">rows	"This will extract all the rows and replace the internal stream with a regular stream on the rows. This is useful for debugging, but in real use rather destroys the purpose of the cursored stream"	| rows |	rows := cursor upToEnd.	self releaseCursor.	cursor := rows readStream.	^rows.</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>private</category><body package="GlorpDatabase" selector="rawPeek">rawPeek	"Peek at the underlying rows, but don't build objects"	rawPeekBuffer isNil ifFalse: [^rawPeekBuffer].	rawPeekBuffer := cursor next.	^rawPeekBuffer.</body></methods><methods><class-id>Glorp.GlorpCursoredStream class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="on:">on: aStream	^self basicNew cursor: aStream.</body><body package="GlorpQueries" selector="on:accessor:">on: aStream accessor: aDatabaseAccessor	^(self on: aStream)		databaseAccessor: aDatabaseAccessor.</body><body package="GlorpQueries" selector="on:for:">on: aStream for: aCommand	^(self on: aStream)		command: aCommand.</body><body package="GlorpQueries" selector="on:for:accessor:">on: aStream for: aCommand accessor: aDatabaseAccessor	^(self on: aStream)		command: aCommand;		databaseAccessor: aDatabaseAccessor.</body></methods><methods><class-id>Glorp.GlorpSmallIntType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'smallint'.</body></methods><methods><class-id>Glorp.IdentityTypeResolver</class-id> <category>type resolution</category><body package="GlorpMappings" selector="classesRequiringIndependentQueriesFor:">classesRequiringIndependentQueriesFor: aClass	^Array with: aClass</body></methods><methods><class-id>Glorp.IdentityTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings" selector="allTablesFor:">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses. For a non-inheritance descriptor, this is the same as tables."	^aDescriptor tables.</body><body package="GlorpMappings" selector="describedConcreteClassFor:withBuilder:descriptor:">describedConcreteClassFor: aRow withBuilder: builder descriptor: aDescriptor	^aDescriptor describedClass</body><body package="GlorpMappings" selector="typeMappingRootDescriptor">typeMappingRootDescriptor	^members first</body></methods><methods><class-id>Glorp.IdentityTypeResolver</class-id> <category>As yet unclassified</category><body package="GlorpMappings" selector="descriptorsRequiringIndependentQueriesFor:">descriptorsRequiringIndependentQueriesFor: aClass	^members.</body></methods><methods><class-id>Glorp.Cache</class-id> <category>initialize</category><body package="GlorpCore" selector="initialize">initialize</body><body package="GlorpCore" selector="initializeCache">initializeCache	items := policy newItemsIn: self.	extraReferences := policy collectionForExtraReferences.</body><body package="GlorpCore" selector="release">release	policy release: self.	extraReferences := nil.</body></methods><methods><class-id>Glorp.Cache</class-id> <category>accessing</category><body package="GlorpCore" selector="cachePolicy">cachePolicy	^policy.</body><body package="GlorpCore" selector="cachePolicy:">cachePolicy: aCachePolicy	policy := aCachePolicy.	self initializeCache.</body><body package="GlorpCore" selector="mainCache">mainCache	^mainCache</body><body package="GlorpCore" selector="mainCache:">mainCache: aCacheManager	mainCache := aCacheManager</body><body package="GlorpCore" selector="numberOfElements">numberOfElements	^items size.</body><body package="GlorpCore" selector="session">session	^mainCache session.</body><body package="GlorpCore" selector="willRemoveItems">willRemoveItems	^policy willRemoveItems.</body></methods><methods><class-id>Glorp.Cache</class-id> <category>lookup</category><body package="GlorpCore" selector="at:ifAbsent:">at: key ifAbsent: aBlock 	| item value |	item := self basicAt: key ifAbsent: [^aBlock value].	value := policy contentsOf: item.	(self hasItemExpired: item) 		ifTrue: 			[policy takeExpiryActionForKey: key withValue: value in: self. 			(items includesKey: key) ifFalse: [^aBlock value]].	^value.</body><body package="GlorpCore" selector="at:ifAbsentPut:">at: key ifAbsentPut: aBlock 	| item |	item := self at: key ifAbsent: [nil].	^item isNil 		ifTrue: [ | newItem|			newItem := policy cacheEntryFor: aBlock value.			self markEntryAsCurrent: newItem.			items at: key put: newItem]		ifFalse: [self markEntryAsCurrent: item. item].</body><body package="GlorpCore" selector="expireAll">expireAll	items do: [:each | policy expire: each].</body><body package="GlorpCore" selector="expireKey:ifAbsent:">expireKey: key ifAbsent: aBlock	| item |	item := self basicAt: key ifAbsent: [^aBlock value].	policy expire: item.</body><body package="GlorpCore" selector="hasExpired:">hasExpired: key	| item |	item := self basicAt: key ifAbsent: [^false].	^self hasItemExpired: item.</body><body package="GlorpCore" selector="hasItemExpired:">hasItemExpired: anItem	^(policy hasExpired: anItem) and: [(mainCache session isRegistered: (policy contentsOf: anItem)) not].</body><body package="GlorpCore" selector="includesKey:">includesKey: key	"Return true if we include the object. Don't listen to any expiry policy"	self basicAt: key ifAbsent: [^false].	^true.</body><body package="GlorpCore" selector="includesKey:as:">includesKey: key as: anObject	"Return true if we include the object, and it matches the given object. If we include a different object with the same key, raise an exception. Don't listen to any expiry policy"	| item value |	item := self basicAt: key ifAbsent: [^false].	value := policy contentsOf: item.	value == anObject ifFalse: [		(DuplicatePrimaryKeyException new: anObject existing: value) signal].	^true.</body><body package="GlorpCore" selector="includesKey:withClass:">includesKey: key withClass: aClass	"Return true if we include the object, and it matches our class. Don't listen to any expiry policy"	| item value |	item := self basicAt: key ifAbsent: [^false].	value := policy contentsOf: item.	^value isKindOf: aClass.</body><body package="GlorpCore" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: aBlock	^items removeKey: key ifAbsent: aBlock.</body></methods><methods><class-id>Glorp.Cache</class-id> <category>private</category><body package="GlorpCore" selector="basicAt:ifAbsent:">basicAt: anObject ifAbsent: aBlock	^items at: anObject ifAbsent: aBlock.</body><body package="GlorpCore" selector="do:">do: aBlock	items do: aBlock.</body><body package="GlorpCore" selector="expiredInstanceFor:">expiredInstanceFor: key	"Return the expired instance. Used for refreshing so that we don't recursively try and refresh when we get the instance to be refreshed"	| item value |	item := self basicAt: key ifAbsent: [self error: 'No expired instance found'].	value := policy contentsOf: item.	(self hasItemExpired: item) ifFalse: [self error: 'No expired instance found'].	^value.</body><body package="GlorpCore" selector="markAsCurrentAtKey:">markAsCurrentAtKey: key	| item |	item := self basicAt: key ifAbsent: [^false].	^policy markEntryAsCurrent: item in: self.</body><body package="GlorpCore" selector="markEntryAsCurrent:">markEntryAsCurrent: anItem	"The policy has told us to mark an item as current. This is only really useful for weak policies, which tell us to keep an additional pointer to the object in a (presumably) fixed-size collection"	extraReferences isNil ifFalse: [extraReferences add: anItem].</body></methods><methods><class-id>Glorp.Cache</class-id> <category>finalization</category><body package="GlorpCore" selector="mournKeyOf:">mournKeyOf: anEphemeron	policy takeExpiryActionForKey: anEphemeron key withValue: anEphemeron value in: self.</body></methods><methods><class-id>Glorp.Cache class</class-id> <category>instance creation</category><body package="GlorpCore" selector="new">new	^super new initialize.</body><body package="GlorpCore" selector="newFor:in:">newFor: aClass in: aCacheManager 	| newCache descriptor |	descriptor := aCacheManager session isNil ifFalse: [aCacheManager system descriptorFor: aClass].	newCache := Cache new.	newCache mainCache: aCacheManager.	descriptor isNil 		ifTrue: [newCache cachePolicy: CachePolicy default]		ifFalse: [newCache cachePolicy: descriptor cachePolicy].	^newCache.</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="additionalExpressionsOn:">additionalExpressionsOn: anExpression	^#().</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^source.</body><body package="GlorpExpressions" selector="availableSubSelectNumber">availableSubSelectNumber	availableSubSelectNumber := availableSubSelectNumber isNil ifTrue: [1] ifFalse: [availableSubSelectNumber + 1].	^availableSubSelectNumber.</body><body package="GlorpExpressions" selector="controlsTables">controlsTables	^true.</body><body package="GlorpExpressions" selector="fieldsForSelectStatement">fieldsForSelectStatement	^self descriptor mappedFields.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	anExpression isNil ifTrue: [^aBaseExpression].	anExpression == self ifTrue: [^aBaseExpression].	^ultimateBaseExpression isNil ifTrue: [self] ifFalse: [ultimateBaseExpression].</body><body package="GlorpExpressions" selector="tablesToPrint">tablesToPrint	"We derive the base's tables from the fields that are being selected, but make sure that at least the primary table is listed."	self descriptor tables isEmpty ifTrue: [^#()].	^Array with: (self aliasedTableFor: self descriptor primaryTable).</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canBeUsedForRetrieve">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^true.</body><body package="GlorpExpressions" selector="canPrint">canPrint	"Return true if we can print into a where clause"	^false.</body><body package="GlorpExpressions" selector="mapsSimpleObject">mapsSimpleObject	"Try to do a fast test for this, to look for the pseudo-descriptors that direct to-many mappings use."	^self descriptor mappings size = 1 and: [(self descriptor mappingForAttributeNamed: #myValue) notNil].</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="additionalExpressions">additionalExpressions	| expressions |	expressions := OrderedCollection new.	self descriptor typeMapping addTypeMappingCriteriaTo: expressions in: self.	expressions addAll: self multipleTableExpressions.	^expressions</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. We don't have a base, but we *are* a base, so return true"	^true.</body><body package="GlorpExpressions" selector="descriptor">descriptor	^descriptor</body><body package="GlorpExpressions" selector="descriptor:">descriptor: aDescriptor	descriptor := aDescriptor</body><body package="GlorpExpressions" selector="hasDescriptor">hasDescriptor	^self descriptor notNil.</body><body package="GlorpExpressions" selector="mappedFields">mappedFields	^self descriptor mappedFields collect: [:each | self translateField: each].</body><body package="GlorpExpressions" selector="multipleTableExpressions">multipleTableExpressions	^self descriptor multipleTableJoin 		collect: [:each | each asExpressionJoiningSource: self toTarget: self]</body><body package="GlorpExpressions" selector="system">system	self descriptor isNil ifTrue: [^nil].	^self descriptor system.</body><body package="GlorpExpressions" selector="table">table	^self descriptor primaryTable.</body><body package="GlorpExpressions" selector="tables">tables	^self descriptor isNil ifTrue: [#()] ifFalse: [self descriptor tables].</body><body package="GlorpExpressions" selector="targetDescriptor">targetDescriptor	self halt</body><body package="GlorpExpressions" selector="trueBase">trueBase	^self.</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="className">className	^'Base'.</body><body package="GlorpExpressions" selector="printOn:">printOn: aStream 	aStream		nextPutAll: self className;		nextPut: $(.	self printTreeOn: aStream.	aStream nextPut: $)</body><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream 	self descriptor isNil ifTrue: [aStream nextPutAll: 'Empty Base'. ^self].	aStream print: self descriptor describedClass.	self printTableAliasesOn: aStream</body><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary 	"Normally, we're not printable, but we might be if we're inverting a direct to-many mapping. In that case, there should only be one mapped field"	self descriptor mappedFields do: [:each | (self translateField: each) printSQLOn: aStream withParameters: aDictionary].</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary 	"Do nothing. We're not printable"</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream 		print: (self descriptor isNil ifTrue: [nil] ifFalse: [self descriptor describedClass])</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="base">base	^nil.</body><body package="GlorpExpressions" selector="getParameter:">getParameter: aDatabaseField 	^ParameterExpression forField: aDatabaseField basedOn: self.</body><body package="GlorpExpressions" selector="referenceClass">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^self descriptor describedClass.</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^self</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^self</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>mapping</category><body package="GlorpExpressions" selector="valueInBuilder:">valueInBuilder: anElementBuilder	"If we ever get here, this is because we're being used as the reverse of a direct to-many mapping, so we expect to have a descriptor with only one mapping, named #myValue"	| mapping |	mapping := self descriptor mappingForAttributeNamed: #myValue.	^mapping valueInBuilder: anElementBuilder as: (self get: #myValue) field.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^self</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^trueBase ultimateBaseExpression</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="additionalExpressions">additionalExpressions	"We effectively take over the join for the thing we're based on, because we want it to happen in the subselect, not in the main one."	^trueBase additionalExpressionsOn: self.</body><body package="GlorpExpressions" selector="base">base	^trueBase base.</body><body package="GlorpExpressions" selector="descriptor">descriptor	^trueBase descriptor.</body><body package="GlorpExpressions" selector="field">field	^self trueBase mapping field.</body><body package="GlorpExpressions" selector="join">join	^self trueBase join.</body><body package="GlorpExpressions" selector="table">table	^self trueBase table.</body><body package="GlorpExpressions" selector="trueBase">trueBase	^trueBase</body><body package="GlorpExpressions" selector="trueBase:">trueBase: aBaseExpression	trueBase := aBaseExpression.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="additionalExpressionsOn:">additionalExpressionsOn: anExpression	^trueBase additionalExpressionsOn: anExpression.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	anExpression isNil ifTrue: [^aBaseExpression].	anExpression == self ifTrue: [^aBaseExpression].	trueBase := trueBase rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	^self.</body><body package="GlorpExpressions" selector="validate">validate	super validate.	trueBase validate.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="representsDerivedObject">representsDerivedObject	^self trueBase representsDerivedObject</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="className">className	^'SubSelectBase'.</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	"If I'm ever going to print this directly, it's because I'm participating in a direct to-many relationship, so I do have a valid field"	(self translateField: self field) printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="convertedDbValueOf:">convertedDbValueOf: anObject	^self trueBase mapping convertedDbValueOf: anObject.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="on:">on: aBaseExpression	^self new trueBase: aBaseExpression.</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>public</category><body package="GlorpUnitOfWork" selector="containedBy">containedBy	^containedBy.</body><body package="GlorpUnitOfWork" selector="contents">contents	^contents.</body><body package="GlorpUnitOfWork" selector="contents:">contents: anObject	(hasValue and: [contents ~= anObject]) ifTrue: [self error: 'Inconsistent values in field'].	self privateSetContents: anObject.</body><body package="GlorpUnitOfWork" selector="hasValue">hasValue	^hasValue.</body><body package="GlorpUnitOfWork" selector="initialize">initialize	hasValue := false.</body><body package="GlorpUnitOfWork" selector="printOn:">printOn: aStream	aStream 		nextPutAll: '&lt;&lt;'.	self hasValue ifTrue: [aStream print: self contents].	aStream		nextPutAll: '&gt;&gt;'.</body><body package="GlorpUnitOfWork" selector="privateSetContents:">privateSetContents: anObject	contents := anObject.	hasValue := true.</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="allInnerWrappers">allInnerWrappers	^#().</body><body package="GlorpUnitOfWork" selector="basicContents">basicContents	"Return the un-transformed contents"	^self contents.</body><body package="GlorpUnitOfWork" selector="innerWrapper">innerWrapper	^self.</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>unifying</category><body package="GlorpUnitOfWork" selector="containsWrapper:">containsWrapper: aFieldValueWrapper	^self == aFieldValueWrapper.</body><body package="GlorpUnitOfWork" selector="replaceWith:">replaceWith: aFieldValueWrapper	containedBy isNil ifTrue: [^nil].	containedBy		keysAndValuesDo:			[:eachField :eachListOfRows | eachListOfRows do: [:eachRow | eachRow wrapperAt: eachField put: aFieldValueWrapper]].</body><body package="GlorpUnitOfWork" selector="unifyWith:">unifyWith: targetWrapper	(self containsWrapper: targetWrapper) ifTrue: [^self].	(targetWrapper containsWrapper: self) ifTrue: [^self].	targetWrapper hasValue ifFalse: [^targetWrapper replaceWith: self].	self hasValue ifFalse: [^self replaceWith: targetWrapper].	self contents = targetWrapper contents		ifFalse: [self error: 'Conflicting values in rows'].	targetWrapper replaceWith: self.</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>containing</category><body package="GlorpUnitOfWork" selector="isNowContainedBy:and:">isNowContainedBy: aRow and: aField	"Optimize this for memory consumption with the common case of one container. If we're contained by nothing, make it a single association. Otherwise, use a dictionary"	| shortCircuit thisFieldsEntries |	shortCircuit := false.	containedBy == nil ifTrue: [containedBy := aField -&gt; ((IdentitySet new: 2) add: aRow; yourself). ^self].	containedBy class == Association 		ifTrue: [		containedBy key == aField			ifTrue: [thisFieldsEntries := containedBy value]			ifFalse: [ | newContainedBy |				newContainedBy := IdentityDictionary new. 				newContainedBy at: containedBy key put: containedBy value.				containedBy := newContainedBy]].	thisFieldsEntries isNil ifTrue: [		thisFieldsEntries := containedBy at: aField ifAbsentPut: [shortCircuit := true. (IdentitySet new: 2) add: aRow; yourself]].	shortCircuit ifTrue: [^self].	(thisFieldsEntries includes: aRow) ifFalse: [thisFieldsEntries add: aRow].</body></methods><methods><class-id>Glorp.FieldValueWrapper class</class-id> <category>public</category><body package="GlorpUnitOfWork" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="beOuterJoin">beOuterJoin	outerJoin := true.	leftChild beOuterJoin.	rightChild beOuterJoin.</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions" selector="isOuterJoin">isOuterJoin	outerJoin isNil ifTrue: [outerJoin := false].	^outerJoin.</body><body package="GlorpExpressions" selector="leftChild">leftChild	^leftChild</body><body package="GlorpExpressions" selector="leftChild:">leftChild: anExpression 	leftChild := anExpression</body><body package="GlorpExpressions" selector="outerJoin">outerJoin	outerJoin isNil ifTrue: [outerJoin := false].	^outerJoin.</body><body package="GlorpExpressions" selector="outerJoin:">outerJoin: aBoolean	outerJoin := aBoolean.</body><body package="GlorpExpressions" selector="relation">relation	^relation.</body><body package="GlorpExpressions" selector="relation:">relation: aSymbol	relation := aSymbol.</body><body package="GlorpExpressions" selector="rightChild">rightChild	^rightChild</body><body package="GlorpExpressions" selector="rightChild:">rightChild: anExpression	rightChild := anExpression</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^leftChild canHaveBase ifTrue: [leftChild queryLevelBaseExpression] ifFalse: [rightChild queryLevelBaseExpression].</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^leftChild canHaveBase ifTrue: [leftChild ultimateBaseExpression] ifFalse: [rightChild ultimateBaseExpression].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	aStream nextPutAll: relation.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream		print: leftChild;		space;		nextPutAll: relation;		space;		print: rightChild</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="convertValueOf:in:">convertValueOf: anObject in: aDictionary	| translated convertedValue |	translated := anObject isGlorpExpression 		ifTrue: [anObject valueIn: aDictionary]		ifFalse: [anObject].	translated isGlorpExpression ifTrue: [^translated].	convertedValue := self expectsCollectionArgument 		ifTrue: [translated collect: [:each | self leftChild convertedDbValueOf: each]]		ifFalse: [self leftChild convertedDbValueOf: translated].	^convertedValue.</body><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	| clauses |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	leftChild hasImpliedClauses		ifTrue:			[clauses := leftChild allRelationsFor: self.			clauses do: [:each | each do: aBlock skipping: aSet]]		ifFalse:			[leftChild do: aBlock skipping: aSet.			rightChild do: aBlock skipping: aSet.			aBlock value: self.].</body><body package="GlorpExpressions" selector="mappableSourceFieldsDo:">mappableSourceFieldsDo: aBlock	"Used when we are emulating a Join"	self allSourceFields do: [:source |		source isMappable ifTrue: [aBlock value: source]].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="allSourceFields">allSourceFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the source fields as the parameters that this expression takes, and specifically the parameters that are based on fields."	^self inject: OrderedCollection new into: [:sum :each |		each addToTargetFields: sum.		sum].</body><body package="GlorpExpressions" selector="allTargetFields">allTargetFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the target fields as being the source fields of the bottom-most mapping. That is, the fields we'll use to connect to the thing we want are the things that our expression's base (which represents the thing we want) would use to connect to the first level mapping arising from it. If we have a relation, that's a bit of a mess, but guess that we want the left child's information."	^self leftChild allTargetFields.</body><body package="GlorpExpressions" selector="canUseBinding">canUseBinding	"Return true if we can use binding for our right child's value"	^self expectsCollectionArgument not.</body><body package="GlorpExpressions" selector="expectsCollectionArgument">expectsCollectionArgument	^self relationsWithCollectionArguments includes: relation.</body><body package="GlorpExpressions" selector="primaryKeyFromDictionary:">primaryKeyFromDictionary: aDictionary	"Given a set of parameters, return a primary key suitable for retrieving our target. Do this only if the expression is for a primary key, and has no other conditions than the primary key one"	| left right field |	relation = #AND ifTrue: [		left := leftChild primaryKeyFromDictionary: aDictionary.		right := rightChild primaryKeyFromDictionary: aDictionary.		^(left notNil and: [right notNil]) ifTrue: [Array with: left with: right] ifFalse: [nil]].	relation = #= ifFalse: [^nil].	field := leftChild fieldFromMeOrSubclasses.	field isNil ifTrue: [^nil].	field isGlorpExpression ifTrue: [^nil].	^(field isPrimaryKey)		ifTrue: [rightChild valueIn: aDictionary]		ifFalse: [nil].</body><body package="GlorpExpressions" selector="printForANSIJoinTo:on:">printForANSIJoinTo: table on: aCommand	"Print ourselves as table JOIN otherTable USING (criteria). Return the table we joined"	self outerJoin		ifTrue: [aCommand nextPutAll: ' LEFT OUTER JOIN ']		ifFalse: [aCommand nextPutAll: ' INNER JOIN '].	aCommand nextPutAll: table sqlTableName.	aCommand nextPutAll: ' ON '.	self printSQLOn: aCommand withParameters: aCommand parameters.	^table.</body><body package="GlorpExpressions" selector="relationsWithCollectionArguments">relationsWithCollectionArguments	^#(#IN #'NOT IN')</body><body package="GlorpExpressions" selector="tablesForANSIJoin">tablesForANSIJoin	"Which tables will we join. Assumes this is a single-level join"	^self inject: Set new into: [:sum :each |		each tableForANSIJoin isNil ifFalse: [sum add: each tableForANSIJoin].		sum].</body><body package="GlorpExpressions" selector="tableToJoinFrom:">tableToJoinFrom: aTableCollection	"Return a table we could legitimately use at this point to write as an ANSI join - meaning that all but one must be  already used and thus available, and one that isn't. aTableCollection lists the used ones"	| possibleTables |	possibleTables := self tablesForANSIJoin asArray		select: [:each | (aTableCollection includes: each) not].	^possibleTables size = 1 ifTrue: [possibleTables first] ifFalse: [nil].</body><body package="GlorpExpressions" selector="targetKeys">targetKeys	"Assume that part of us is a join, and the rest doesn't count"	^self inject: OrderedCollection new into: [:sum :each |		each isJoin ifTrue: [sum addAll: each targetKeys].		sum].</body><body package="GlorpExpressions" selector="useBindingFor:to:in:">useBindingFor: aValue to: aType in: aCommand	"Return true if we can use binding for our right child's value, in the context of this command"	aCommand useBinding ifFalse: [^false].	self expectsCollectionArgument ifTrue: [^false].	^aCommand canBind: aValue to: aType.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="addBoundExpressionsIn:to:">addBoundExpressionsIn: aCommand to: boundExpressions	"If our right-child can be used for binding, add it to the list. We need to do this at this level because the expressions themselves don't know what type they'll be matched against"	| translated |	rightChild canBind ifFalse: [^self].	(boundExpressions includes: self) ifTrue: [^self].	translated := self convertValueOf: rightChild in: aCommand parameters.	(self useBindingFor: translated to: leftChild type in: aCommand) ifTrue: [boundExpressions add: self].</body><body package="GlorpExpressions" selector="additionalExpressions">additionalExpressions	^#().</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| left right |	left := leftChild asExpressionJoiningSource: source toTarget: target.	right := rightChild asExpressionJoiningSource: source toTarget: target.	^self class new 		relation: relation;		leftChild: left;		rightChild: right.</body><body package="GlorpExpressions" selector="bindingIn:">bindingIn: aCommand	^self convertValueOf: rightChild in: aCommand parameters.</body><body package="GlorpExpressions" selector="bindingType">bindingType	"If we're to be used for binding, return the field type to be bound to"	^self leftChild bindingType.</body><body package="GlorpExpressions" selector="condenseBooleanEquality">condenseBooleanEquality	(relation = #AND | (relation = #OR)) ifFalse: [^self].	(leftChild isGlorpExpression and: [leftChild isConstantExpression])		ifTrue: [			(relation = #AND and: [leftChild value = true]) ifTrue: [^rightChild].			(relation = #AND and: [leftChild value = false]) ifTrue: [^leftChild].			(relation = #OR and: [leftChild value = true]) ifTrue: [^leftChild].			(relation = #OR and: [leftChild value = false]) ifTrue: [^rightChild]].	(rightChild isGlorpExpression and: [rightChild isConstantExpression])		ifTrue: [			(relation = #AND and: [rightChild value = true]) ifTrue: [^leftChild].			(relation = #AND and: [rightChild value = false]) ifTrue: [^rightChild].			(relation = #OR and: [rightChild value = true]) ifTrue: [^rightChild].			(relation = #OR and: [rightChild value = false]) ifTrue: [^leftChild]].	^self.</body><body package="GlorpExpressions" selector="condenseBooleanEqualityExpressions">condenseBooleanEqualityExpressions	leftChild := leftChild condenseBooleanEquality.	rightChild := rightChild condenseBooleanEquality.</body><body package="GlorpDatabase" selector="condensePrimaryKeyComparison">condensePrimaryKeyComparison	"This tries to condense expressions of the form         something relatedObject id = x      with           something foreignKeyToRelatedObjectId = x, saving a join (and making the thing work at all, in the case where x = nil"	| fieldBeingCompared baseObjectExpression join sourceField |	(relation = #= or: [relation = #&lt;&gt;]) ifFalse: [^self].	self leftChild mappedFields size = 1 ifFalse: [^self].	fieldBeingCompared := self leftChild field.	fieldBeingCompared class == DatabaseField ifFalse: [^self].	fieldBeingCompared isPrimaryKey ifFalse: [^self].	baseObjectExpression := self leftChild base.	baseObjectExpression representsDerivedObject ifFalse: [^self].	"If we have an expression for a join, don't even try."	baseObjectExpression join isJoin ifFalse: [^self].	join := baseObjectExpression join asGlorpExpressionOn: baseObjectExpression base.	sourceField := join sourceForTarget: fieldBeingCompared.	sourceField isNil ifTrue: [^self].	"OK, we've got a match, replace ourselves with the shortcut"	^(sourceField isGlorpExpression and: [sourceField isConstantExpression])		ifTrue: [self rightChild get: relation withArguments: (Array with: sourceField)]		ifFalse: [(self leftChild base base getField: sourceField) get: relation withArguments: (Array with: self rightChild)].</body><body package="GlorpExpressions" selector="condensePrimaryKeyComparisons">condensePrimaryKeyComparisons	"Because we're replacing the expression, we need to do it at the parent and replace the previous child"	leftChild := leftChild condensePrimaryKeyComparison.	rightChild := rightChild condensePrimaryKeyComparison.</body><body package="GlorpExpressions" selector="hasBindableExpressionsIn:">hasBindableExpressionsIn: aCommand	"Return true if our right-child can be used for binding. We need to do this at this level because the expressions themselves don't know what type they'll be matched against"	| translated |	rightChild canBind ifFalse: [^false].	translated := self convertValueOf: rightChild in: aCommand parameters.	^self useBindingFor: translated to: leftChild field type in: aCommand.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| expression |	self == anExpression ifTrue: [^aBaseExpression].	expression := (leftChild rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression)		get: relation		withArguments:			(Array				with:					(self rightChildToRebuild rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression)).	self isOuterJoin ifTrue: [expression beOuterJoin].	^expression.</body><body package="GlorpExpressions" selector="removeNonJoinParts">removeNonJoinParts	"Remove anything that's not an actual join. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to use the general ones, because they're not field level. Also only meaningful to remove this for ANDs and ORs, not sub-components."	(relation = #AND or: [relation = #OR]) ifFalse: [^self].	leftChild := leftChild isJoin ifTrue: [leftChild] ifFalse: [true asGlorpExpression].	rightChild := rightChild isJoin ifTrue: [rightChild] ifFalse: [true asGlorpExpression].</body><body package="GlorpExpressions" selector="replaceJoinsWithInverse">replaceJoinsWithInverse	"Replace any actual Join objects we have with their inverse. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to mess with the general ones, because they're not field-level"	leftChild isJoin ifTrue: [leftChild := leftChild inverseJoin].	rightChild isJoin ifTrue: [rightChild := rightChild inverseJoin].</body><body package="GlorpExpressions" selector="rewriteEquality">rewriteEquality	| keyEquality descriptor describedClass |	leftChild := leftChild rewriteBooleanEquality: relation.	leftChild hasDescriptor ifFalse: [^self].	"A slightly convoluted way of checking if this is a pseudo-descriptor for a primitive type used in something like a DirectToManyMapping, in which case we can't rewrite. But if it's a pseudo-descriptor for a dictionary mapping where we actually use the mapping as the key rather than a class, then we're ok. It'd be nice if the code for this were more expressive."	descriptor := leftChild descriptor.	describedClass := descriptor describedClass.	(describedClass ~~ Association and: [(descriptor session descriptorFor: describedClass) isNil]) ifTrue: [^self].	(relation = #= | (relation = #&lt;&gt;) | (relation = #IN)) ifFalse: [^self].	(relation = #IN and: [leftChild descriptor primaryTable primaryKeyFields size &gt; 1]) ifTrue: [		(GlorpInvalidExpressionError signal: 'Cannot convert an object comparison to an IN comparison when the table uses a composite primary key')].	keyEquality := leftChild descriptor		primaryKeyExpressionFor: rightChild		basedOn: leftChild		relation: relation.	^keyEquality.</body><body package="GlorpExpressions" selector="rewriteEqualityExpressions">rewriteEqualityExpressions	leftChild := leftChild rewriteEquality.	rightChild := rightChild rewriteEquality.</body><body package="GlorpExpressions" selector="rewriteFunctionArguments">rewriteFunctionArguments	"If a function needs to adjust its arguments, do that here. The motivating example is one where a string argument is rewritten into a form that's of a different length, e.g. the Postgresql driver does that to strings in Blobs."	leftChild rewriteFunctionArgumentsWith: rightChild.</body><body package="GlorpExpressions" selector="rightChildToRebuild">rightChildToRebuild	^rightChild.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions" selector="printBasicSQLOn:withParameters:">printBasicSQLOn: aCommand withParameters: aDictionary 	aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $(].	leftChild printSQLOn: aCommand withParameters: aDictionary.	self 		printComparisonTo: rightChild		withParameters: aDictionary		on: aCommand.	self printOracleOuterJoinOn: aCommand.	aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $)]</body><body package="GlorpExpressions" selector="printComparisonTo:withParameters:on:">printComparisonTo: value withParameters: aDictionary on: aStream	"Horribly convoluted logic to handle the cases where the value might be a constant, an expression that results in a value (constant or parameter) or a regular expression, with the caveat that any value that turns out to be null has to be printed with IS NULL rather than = NULL."	| translated |	translated := self convertValueOf: value in: aDictionary.	translated isGlorpExpression		ifTrue:			[			translated canPrint ifTrue: [				self printRelationOn: aStream.				translated					printSQLOn: aStream					withParameters: aDictionary]]		ifFalse:			[self				printSimpleValueComparisonTo: translated				on: aStream].</body><body package="GlorpExpressions" selector="printMicrosoftOuterJoinOn:">printMicrosoftOuterJoinOn: aCommand	self isOuterJoin ifFalse: [^self].	aCommand platform useMicrosoftOuterJoins ifTrue: [		aCommand nextPutAll: '*'].</body><body package="GlorpExpressions" selector="printOracleOuterJoinOn:">printOracleOuterJoinOn: aCommand	self isOuterJoin ifFalse: [^self].	(self leftChild class == self class and: [self leftChild isOuterJoin]) ifTrue: [^self].	(self rightChild class == self class and: [self rightChild isOuterJoin]) ifTrue: [^self].	aCommand platform useOracleOuterJoins ifTrue: [		aCommand nextPutAll: ' (+) '].</body><body package="GlorpExpressions" selector="printRelationOn:">printRelationOn: aStream	aStream space.	self printMicrosoftOuterJoinOn: aStream.	aStream 		nextPutAll: self relation;		space.</body><body package="GlorpExpressions" selector="printSimpleValueComparisonTo:on:">printSimpleValueComparisonTo: value on: aStream	value isNil		ifTrue: [self printWithNullOn: aStream]		ifFalse:			[self printRelationOn: aStream.			self printValue: value on: aStream].</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	self leftChild hasImpliedClauses		ifTrue:			[| impliedClauses |			impliedClauses := self leftChild allRelationsFor: self.			impliedClauses outerJoin: self outerJoin.			impliedClauses				printSQLOn: aStream				withParameters: aDictionary]		ifFalse:			[self				printBasicSQLOn: aStream				withParameters: aDictionary].</body><body package="GlorpExpressions" selector="printValue:on:">printValue: value on: aCommand	| type |	type := [self leftChild type] on: Dialect error do: [:ex | self error: 'Invalid comparison operation: ', self printString].	(self useBindingFor: value to: type in: aCommand) ifTrue: [^aCommand nextPutAll: '?'].	self expectsCollectionArgument		ifTrue:			[type				printCollection: value				on: aCommand]		ifFalse:			[type				print: value				on: aCommand].</body><body package="GlorpExpressions" selector="printWithNullOn:">printWithNullOn: aStream	aStream nextPutAll: ' IS '.	self relation = #&lt;&gt; ifTrue: [		aStream nextPutAll: 'NOT '].	aStream nextPutAll: 'NULL'.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="get:withArguments:">get: aSymbol withArguments: anArray	"We treat NOT as a function, so we have to check for functions here"	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^anArray size = 1		ifTrue: [RelationExpression named: aSymbol basedOn: self withArguments: anArray]		ifFalse: ["This is either an error, or something defined as a selector on relation expressions"			self perform: aSymbol withArguments: anArray.].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGeneralGlorpExpression">asGeneralGlorpExpression	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copy.	result leftChild: leftChild asGeneralGlorpExpression.	result rightChild: rightChild asGeneralGlorpExpression.	^result.</body><body package="GlorpExpressions" selector="asGeneralGlorpExpressionWithFields">asGeneralGlorpExpressionWithFields	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copy.	result leftChild: leftChild asGeneralGlorpExpressionWithFields.	result rightChild: rightChild asGeneralGlorpExpressionWithFields.	^result.</body><body package="GlorpExpressions" selector="asIndependentJoins">asIndependentJoins	| |	"If this is an ANDed clause, referring to two different tables split it into independent joins"	relation == #AND ifFalse: [^Array with: self].	leftChild tablesForANSIJoin asSortedCollection = rightChild tablesForANSIJoin asSortedCollection		ifTrue: [^Array with: self].	^(Array with: leftChild with: rightChild) inject: OrderedCollection new into: [:sum :each |		sum addAll: each asIndependentJoins. sum].</body><body package="GlorpExpressions" selector="asJoin">asJoin	| leftField rightField |	leftField := self leftChild field.	rightField := self rightChild field.	(leftField notNil and: [rightField notNil]) ifTrue: [^Join from: leftField to: rightField].	^leftChild asJoin, rightChild asJoin.</body><body package="GlorpDatabase" selector="generalExpressionPart">generalExpressionPart	| left right |	left := leftChild generalExpressionPart.	right := rightChild generalExpressionPart.	(left isNil and: [right isNil]) ifTrue: [^nil].	left isNil ifTrue: [^right].	right isNil ifTrue: [^left].	^self.</body><body package="GlorpExpressions" selector="sourceForTarget:">sourceForTarget: aField	| left |	relation = #= ifFalse: [		left := leftChild sourceForTarget: aField.		left isNil ifFalse: [^left].		^rightChild sourceForTarget: aField].	rightChild field == aField ifTrue: [^leftChild field].	leftChild field == aField ifTrue: [^rightChild field].	^nil.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>copying</category><body package="GlorpExpressions" selector="createFor:withBase:symbol:">createFor: arguments withBase: anExpression symbol: aSymbol	"Create a copy of our expression with the given parameters. Used in function creation, for 'functions' like isNil that really just turn into relations."	^self class		named: relation		basedOn: anExpression		withArguments: (Array with: rightChild).</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>private/initializing</category><body package="GlorpExpressions" selector="named:basedOn:withArguments:">named: aSymbol basedOn: anExpression withArguments: anArray	| base right rightBase |	outerJoin := false.	relation := self operationFor: aSymbol.	leftChild := anExpression.	"The only time we don't expect anExpression to have a base is if it's a constant, in which case the other side should be a variable expression and thus have a base."	base := anExpression canHaveBase ifTrue: [anExpression ultimateBaseExpression] ifFalse: [anArray first ultimateBaseExpression].	right := anArray first.	right isGlorpExpression ifFalse: [rightChild := right asGlorpExpressionOn: base. ^self].	rightBase := right ultimateBaseExpression.	rightChild := rightBase ~= base		ifTrue: [			right asGlorpExpressionOn: ((rightBase notNil and: [rightBase hasDescriptor]) ifTrue: ["Correlated subselect" rightBase] ifFalse: [base])]		ifFalse: [right].</body><body package="GlorpExpressions" selector="operationFor:">operationFor: aSymbol	"Simple translation of operators"	aSymbol == #AND: ifTrue: [^#AND].	aSymbol == #&amp; ifTrue: [^#AND].	aSymbol == #OR: ifTrue: [^#OR].	aSymbol == #| ifTrue: [^#OR].	aSymbol == #~= ifTrue: [^#&lt;&gt;].	 aSymbol == #like: ifTrue: [^#LIKE].	 aSymbol == #ilike: ifTrue: [^#ILIKE].		"Case-insensitive variant of LIKE. Only supported on PostgreSQL at the moment"	 aSymbol == #in: ifTrue: [^#IN].	 aSymbol == #notIn: ifTrue: [^#'NOT IN'].	^aSymbol.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="shortCircuitOnNullComparison:">shortCircuitOnNullComparison: parameters	"Return true if we represent an expression that compares null to a non-nullable value, so we don't ever need to really evaluate it.This could be more sophisticated and test if any part of an ANDed and not NOTed clause does such a comparison. But this will do for the most important cases"	| value |	value := rightChild valueIn: parameters.	^(relation == #=		and: [value isNil and: [leftChild field isNullable not]])</body></methods><methods><class-id>Glorp.RelationExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="named:basedOn:withArguments:">named: aSymbol basedOn: anExpression withArguments: anArray	^self new		named: aSymbol		basedOn: anExpression		withArguments: anArray.</body></methods><methods><class-id>Glorp.CollectionExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary 	"Don't print the left child or ourselves, just the expression that is the right side.e.g. aPerson addresses anySatisfy: [:each | each city='Ottawa'] prints aswhere (address.city = 'Ottawa')The relation 'aPerson addresses' will ensure that the join gets printed"	rightChild printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.CollectionExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Because our argument is a block, and the thing passed to it is our left child, we can assume that our left child will be referenced via that block. So we'll ignore it. This will help when condensing out primary key expressions, because otherwise us iterating over them forces them to stay around."	| |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	rightChild do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>executing</category><body package="GlorpQueries" selector="executeWithParameters:in:">executeWithParameters: parameterArray in: aSession	session := aSession.	^self 		readFromDatabaseWithParameters: parameterArray.</body><body package="GlorpQueries" selector="readFromDatabaseWithParameters:">readFromDatabaseWithParameters: anArray	| answerStream result |	answerStream := self rowsFromDatabaseWithParameters: anArray.	^self readsOneObject		ifTrue: [result := answerStream next. answerStream release. result]		ifFalse: [self resultCollectionFor: answerStream].</body><body package="GlorpQueries" selector="rowsFromDatabaseWithParameters:">rowsFromDatabaseWithParameters: anArray	^session accessor		executeCommand: (self sqlWith: anArray)		returnCursor: true.</body><body package="GlorpCore" selector="sqlWith:">sqlWith: aDictionary	self prepare.	session platform queryWithUnsupportedOperationsEliminatedFrom: self do: [:newQuery | 		^newQuery			prepare;			sqlWith: aDictionary].	^CompoundSelectCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>accessing</category><body package="GlorpQueries" selector="addQuery:">addQuery: aQuery	queries isEmpty ifTrue: [primaryQuery := aQuery].	queries add: aQuery.</body><body package="GlorpQueries" selector="baseExpression">baseExpression	^queries first baseExpression.</body><body package="GlorpQueries" selector="joins">joins	^queries inject: #() into: [:sum :each | sum, each joins].</body><body package="GlorpQueries" selector="limit">limit	^primaryQuery limit.</body><body package="GlorpQueries" selector="limit:">limit: anInteger	"We currently ignore limit sets and use the one from our contained queries."	^self.</body><body package="GlorpQueries" selector="mightHaveDuplicateRows">mightHaveDuplicateRows	^primaryQuery mightHaveDuplicateRows.</body><body package="GlorpQueries" selector="offset">offset	^primaryQuery offset.</body><body package="GlorpQueries" selector="offset:">offset: anInteger	"We currently ignore offset sets and use the one from our contained queries."	^self.</body><body package="GlorpQueries" selector="operation:">operation: aString	operation := aString.</body><body package="GlorpQueries" selector="primaryQuery:">primaryQuery: aQuery	primaryQuery := aQuery.</body><body package="GlorpQueries" selector="proxyType">proxyType	^primaryQuery proxyType.</body><body package="GlorpQueries" selector="proxyType:">proxyType: aClass		"We currently ignore proxy types and use the ones from our main query."	^self.</body><body package="GlorpQueries" selector="queries">queries	^queries</body><body package="GlorpQueries" selector="queries:">queries: aCollectionOfQueries	queries := aCollectionOfQueries</body><body package="GlorpQueries" selector="requiresDistinct">requiresDistinct	^requiresDistinct</body><body package="GlorpQueries" selector="requiresDistinct:">requiresDistinct: aBoolean	requiresDistinct := aBoolean.</body><body package="GlorpQueries" selector="shouldRefresh">shouldRefresh	^primaryQuery shouldRefresh.</body><body package="GlorpQueries" selector="shouldRefresh:">shouldRefresh: aBoolean	"We currently ignore sets of this, and use the value from our primary query."	^self.</body><body package="GlorpQueries" selector="tracing">tracing	^primaryQuery tracing.</body><body package="GlorpQueries" selector="whereClause">whereClause	| allCriteria |	allCriteria := queries inject: #() into: [:sum :each | sum, each whereClause].	^ExpressionGroup new addAll: allCriteria.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>boolean operations</category><body package="GlorpQueries" selector="except:">except: aQuery	^self minus: aQuery.</body><body package="GlorpQueries" selector="minus:">minus: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	^CompoundQuery newMinus addQuery: self; addQuery: aQuery.</body><body package="GlorpQueries" selector="unionAll:">unionAll: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	^self isUnionAll		ifTrue:			[queries add: aQuery.			self]		ifFalse:			[(CompoundQuery newUnionAll)				addQuery: self;				addQuery: aQuery].</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>testing</category><body package="GlorpQueries" selector="isMinus">isMinus	^operation = 'EXCEPT'.</body><body package="GlorpQueries" selector="isUnionAll">isUnionAll	^operation = #'UNION ALL'.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>printing</category><body package="GlorpQueries" selector="printCompoundSelectAliasesOn:">printCompoundSelectAliasesOn: aStream	"We only want one table. This is a somewhat convoluted way of getting 't1' uniformly appended"	aStream nextPutAll: ' '.	self session platform supportsAliasInCompoundQuery ifTrue: [		primaryQuery tablesToPrint first printSQLOn: aStream withParameters: nil].</body><body package="GlorpQueries" selector="printOperationOn:">printOperationOn: aCommand	aCommand space.	aCommand nextPutAll: (self platform compoundOperationFor: operation).	aCommand space.</body><body package="GlorpQueries" selector="sqlString">sqlString	"Mostly for debugging"	^(self sqlWith: #()) sqlString.</body><body package="GlorpQueries" selector="tablesToPrint">tablesToPrint	^self queries first tablesToPrint.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>As yet unclassified</category><body package="GlorpQueries" selector="resultClass">resultClass	^primaryQuery resultClass.</body><body package="GlorpQueries" selector="shortCircuitEmptyReturn">shortCircuitEmptyReturn	^false.</body><body package="GlorpQueries" selector="shortCircuitEmptyReturn:">shortCircuitEmptyReturn: parameters	^false.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>preparing</category><body package="GlorpQueries" selector="copyOfBuilders">copyOfBuilders 	^primaryQuery copyOfBuilders.</body><body package="GlorpQueries" selector="prepare">prepare	| |	queries do: [:each | each session: session].	queries do: [:each | each prepare].	ordering isNil ifFalse: [		ordering := ordering collect: [:each |			(self expressionBlockFor: each) asGlorpExpressionOn: queries first baseExpression]].	groupBy isNil ifFalse: [groupBy := (self expressionBlockFor: groupBy) asGlorpExpressionOn: queries first baseExpression].</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>sql generation</category><body package="GlorpQueries" selector="rewriteExcept">rewriteExcept	"Rewrite any EXCEPT operation we have into a NOT EXISTS test with a correlated subselect. Only a CompoundQuery would have an EXCEPT"		| |	operation == #EXCEPT ifFalse: [^self].	queries := queries collect: [:each | each rewriteExcept].	^self rewriteSetOperationUsing: #notExists:</body><body package="GlorpQueries" selector="rewriteIntersect">rewriteIntersect	"Rewrite any INTERSECT operation we have into an EXISTS test for a correlated subselect. Only a CompoundQuery would have an intersect"		| |	operation == #INTERSECT ifFalse: [^self].	queries := queries collect: [:each | each rewriteIntersect].	^self rewriteSetOperationUsing: #exists:</body><body package="GlorpQueries" selector="rewriteSetOperationUsing:">rewriteSetOperationUsing: aSelector	"Rewrite any INTERSECT OR EXCEPT operation we have into a correlated EXISTS or NOT EXISTS test, respectively. We take the sub-query, and AND into it a constraint that its base expression is equal to the first queries base expression, and then do either an exists: or a notExists:, depending on aSelector."		| newQuery |	newQuery := queries first copy.	2 to: queries size do: [:i | | q expression mainExpression |		q := (queries at: i) copy.		expression := RelationExpression new outerJoin: false; relation: #=; leftChild: newQuery baseExpression; rightChild: q baseExpression.		mainExpression := RelationExpression new outerJoin: false; relation: #AND; leftChild: q whereClause; rightChild: expression.		q whereClause: mainExpression.		newQuery AND: [:each | each perform: aSelector with: q]].	^newQuery.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	queries := queries collect: [:each | each copy].	primaryQuery := queries first.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>initializing</category><body package="GlorpQueries" selector="initialize">initialize	super initialize.	requiresDistinct := true.	queries := OrderedCollection new: 3.</body></methods><methods><class-id>Glorp.CompoundQuery class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="newIntersect">newIntersect	^self new operation: #INTERSECT.</body><body package="GlorpQueries" selector="newMinus">newMinus	^self new operation: #EXCEPT.</body><body package="GlorpQueries" selector="newUnionAll">newUnionAll	^self new operation: #'UNION ALL'.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="bit">bit	^self typeNamed: #bit ifAbsentPut: [GlorpBooleanType new typeString: 'bit'].</body><body package="GlorpDatabase" selector="blob">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'varbinary(max)'; queryType: (self varbinary)].</body><body package="GlorpDatabase" selector="boolean">boolean	^self bit.</body><body package="GlorpDatabase" selector="char">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new].</body><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'varchar(max)'].</body><body package="GlorpDatabase" selector="date">date	"SQL Server does not compare a timestamp that's cast to a date as being equal to a date, which is the behaviour we expect. Its dates are really timestamps internally, so just treat date and timestamp as the same."	^self timestamp.</body><body package="GlorpDatabase" selector="decimal">decimal	^self numeric.</body><body package="GlorpDatabase" selector="double">double	^self float.</body><body package="GlorpDatabase" selector="float">float	^self typeNamed: #float ifAbsentPut: [GlorpMSSQLFloatType new].</body><body package="GlorpDatabase" selector="float4">float4	^self float.</body><body package="GlorpDatabase" selector="float8">float8	^self float.</body><body package="GlorpDatabase" selector="int">int	^self integer.</body><body package="GlorpDatabase" selector="int2">int2	^self smallint.</body><body package="GlorpDatabase" selector="int4">int4	^self integer.</body><body package="GlorpDatabase" selector="int8">int8	^self numeric.</body><body package="GlorpDatabase" selector="integer">integer	^self typeNamed: #integer ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase" selector="nclob">nclob	^self typeNamed: #nclob ifAbsentPut: [GlorpClobType new typeString: 'nvarchar(max)'].</body><body package="GlorpDatabase" selector="numeric">numeric	^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase" selector="nvarchar">nvarchar	^self typeNamed: #nvarchar ifAbsentPut: [GlorpVarCharType new typeString: 'nvarchar'].</body><body package="GlorpDatabase" selector="real">real	^self float.</body><body package="GlorpDatabase" selector="sequence">sequence	^self serial.</body><body package="GlorpDatabase" selector="serial">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'int  IDENTITY (1, 1) '].</body><body package="GlorpDatabase" selector="text">text	^super text queryType: self varchar.</body><body package="GlorpDatabase" selector="time">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'datetime'].</body><body package="GlorpDatabase" selector="timeStampTypeString">timeStampTypeString	^'datetime'.</body><body package="GlorpDatabase" selector="timestamp">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'datetime'].</body><body package="GlorpDatabase" selector="tinyint">tinyint	^self typeNamed: #tinyInt ifAbsentPut: [GlorpIntegerType new typeString: 'tinyint'].</body><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:extraInformation:">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: extraValue	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	extraValue = 'IDENTITY' ifTrue: [^self serial].	^super typeWithDatabaseName: aString characterWidth: aNumber.</body><body package="GlorpDatabase" selector="varbinary">varbinary	^self typeNamed: #varbinary ifAbsentPut: [GlorpVarBinaryType new].</body><body package="GlorpDatabase" selector="varchar">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new].</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated^false</body><body package="GlorpDatabase" selector="capitalWritingOfTableName">capitalWritingOfTableName	"^&lt;Boolean&gt;"	^false</body><body package="GlorpDatabase" selector="initializeReservedWords">initializeReservedWords	super initializeReservedWords.	reservedWords add: 'key'</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^128</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^128</body><body package="GlorpDatabase" selector="sqlTextCurrentServerUTCTimestamp">sqlTextCurrentServerUTCTimestamp	^'SELECT GETUTCDATE()'</body><body package="GlorpDatabase" selector="startColumnAddString">startColumnAddString	"The string we use as a prefix when adding a colum.	Override the superclass default because MS doesn't use COLUMN."	^' '.</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	"I'm guessing here"	^true.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="dateConverter">dateConverter	"SQL server doesn't have plain dates, and doesn't accept them"	^DelegatingDatabaseConverter		named: #date		hostedBy: self		fromStToDb: #dateToTimestampConversion:for:		fromDbToSt: #readDate:for:.	"#printDate:for:"</body><body package="GlorpDatabase" selector="dateToTimestampConversion:for:">dateToTimestampConversion: aDate for: aType	aDate isNil ifTrue: [^aDate].	^aDate asTimestamp.</body><body package="GlorpDatabase" selector="printDate:for:">printDate: aDate for: aType	"Print a date (or timestamp) as yyyy-mm-dd"	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: '{ d '''.	self		printDate: aDate		isoFormatOn: stream.	stream nextPutAll: ''' }'.	^stream contents.</body><body package="GlorpDatabase" selector="printTime:for:">printTime: aTime for: aType	"Print a time (or timestamp) as hh:mm:ss.fff"	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: '{ t '''.	self		printTime: aTime		isoFormatOn: stream		milliseconds: self supportsMillisecondsInTimes.	stream nextPutAll: ''' }'.	^stream contents.</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPutAll: '{ ts '''.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ''' }'.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="isODBCPlatform">isODBCPlatform	^true</body><body package="GlorpDatabase" selector="isSQLServerPlatform">isSQLServerPlatform	^true</body><body package="GlorpDatabase" selector="reusePreparedStatements">reusePreparedStatements	^false</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true.</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"Binding works only with VW EXDI so far.  Reuse of prepared statements is set to false by default (see my class-side)."	^Dialect isVisualWorks.</body><body package="GlorpDatabase" selector="supportsDecimalsOnAllNumerics">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^false.</body><body package="GlorpDatabase" selector="supportsGroupWritingFor:">supportsGroupWritingFor: aCommand	^aCommand supportsGroupWriting.</body><body package="GlorpDatabase" selector="supportsLimit">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^true.</body><body package="GlorpDatabase" selector="supportsMultipleOpenCursors">supportsMultipleOpenCursors	"Can this database support multiple open cursors at once"	^false.</body><body package="GlorpDatabase" selector="supportsTableOwners">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^true</body><body package="GlorpDatabase" selector="useMicrosoftOuterJoins">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins"	^false.</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	"Return true if we use array binding for grouped writes rather than printing the sql multiple times. Only applies if we support grouped writes"	^false.</body><body package="GlorpDatabase" selector="usesIdentityColumns">usesIdentityColumns	^true.</body><body package="GlorpDatabase" selector="usesInformationSchema">usesInformationSchema	^true</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="charactersThatNeedEscaping">charactersThatNeedEscaping	"There seem to be all kind of contradictory bits of information about what sql server does/requires for escaped characters, all of which differ from standard sql. Empirically the only thing that requires escaping appears to be single quote"	^#($' ).</body><body package="GlorpDatabase" selector="escapeFor:">escapeFor: aCharacter	^String with: $' with: aCharacter."	^'\', (aCharacter asInteger printStringRadix: 16)."</body><body package="GlorpDatabase" selector="printBlob:on:for:">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: '0x'.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].</body><body package="GlorpDatabase" selector="removeNestedParensFromString:">removeNestedParensFromString: aString	"Return a Smalltalk instance of the type indicated by aGlorpType.  SQL-Server wraps aString in parentheses, so uwrap it first.  If aString is nil, ensure we return nil."	| debracket |	aString size &lt; 2 ifTrue: [^aString].	"relies on nil size = 0"	debracket := aString copy.	[debracket first = $( and: [debracket last = $)]]		whileTrue: [debracket := debracket copyFrom: 2 to: debracket size - 1].	^debracket</body><body package="GlorpDatabase" selector="toGlorpType:fromString:">toGlorpType: aGlorpType fromString: aString	"Since SQL-Server wraps the string in parentheses, uwrap it first."	^super		toGlorpType: aGlorpType		fromString: (self removeNestedParensFromString: aString)</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase" selector="booleanToBooleanConverter">booleanToBooleanConverter	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertDBBooleanToBoolean:for:.</body><body package="GlorpDatabase" selector="printBoolean:for:">printBoolean: aBoolean for: aType	"If the platform is MS SQL Server, a boolean object in a SELECT needs to be converted to  BIT type, since T, Y, or true make SQLServer complain. "		| string |	aBoolean isNil ifTrue: [^'NULL'].	"We may be getting passed something that's already 1 or 0, or something else instead of a boolean. That probably shouldn't be happening, but let's handle it gracefully. We define gracefully to mean 1 is true, and everything else is false"	string := (aBoolean == 1 or: [aBoolean = true]) 		ifTrue: ['1'] 		ifFalse: ['0'].	^'CONVERT( BIT, ' , string , ' )'.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>exdi specific</category><body package="GlorpDatabase" selector="exdiTypeForDates">exdiTypeForDates	^#Timestamp.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="GlorpDatabase" selector="compoundOperationFor:">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol"	aSymbol == #INTERSECT ifTrue: [^'WHERE EXISTS'].	aSymbol == #MINUS ifTrue: [^'WHERE NOT EXISTS'].	^aSymbol.</body><body package="GlorpDatabase" selector="printPreLimit:on:">printPreLimit: anInteger on: aCommand	aCommand		nextPutAll: ' TOP '.	anInteger printOn: aCommand.	aCommand nextPutAll: ' '.</body><body package="GlorpDatabase" selector="queryWithUnsupportedOperationsEliminatedFrom:do:">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	| newQuery |	newQuery := aQuery rewriteIntersect.	newQuery := newQuery rewriteExcept.	newQuery == aQuery ifFalse: [aBlock value: newQuery].</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body><body package="GlorpDatabase" selector="maximumSizeToGroupWriteFor:">maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows	"If we are going to group write, how many rows of this collection should we do it for at once"	^aCollectionOfDatabaseRows size min: 250.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>functions</category><body package="GlorpDatabase" selector="initializeFunctions">initializeFunctions	| baseExists dbSpecificExists selectList baseNotExists dbSpecificNotExists |	super initializeFunctions.	functions		at: #, put: (InfixFunction named: '+');		at: #copyFrom:to: put: (SubstringFunction named: 'SUBSTRING');		at: #objectId put: (PrefixFunction named: 'OBJECT_ID');		at: #columnPropertySchema:property: put: ((PrefixFunction named: 'COLUMNPROPERTY') type: self integer);		at: #convertTo: put: ((PrefixFunction named: 'CONVERT')). "CONVERT(toType, aThing)"	"Like Oracle, SQL Server doesn't allow functions like EXISTS in a field list,	but will allow a select there as an argument to a function, such as CASE.	So print it that way if we're in the select list."	baseExists := functions at: #exists:.	dbSpecificExists := DualRoleFunction new.	dbSpecificExists function: '#exists:'.	dbSpecificExists whereClauseVersion: baseExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 1 asGlorpExpression with: 0 asGlorpExpression].	dbSpecificExists selectListVersion: selectList.	dbSpecificExists type: self integer.	functions at: #exists: put: dbSpecificExists.	"And similarly NOT EXISTS"	baseNotExists := functions at: #notExists:.	dbSpecificNotExists := DualRoleFunction new.	dbSpecificNotExists function: '#notExists:'.	dbSpecificNotExists whereClauseVersion: baseNotExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 0 asGlorpExpression with: 1 asGlorpExpression].	dbSpecificNotExists selectListVersion: selectList.	dbSpecificNotExists type: self integer.	functions at: #notExists: put: dbSpecificNotExists.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services columns</category><body package="GlorpDatabase" selector="createAlterColumnStatement:newType:usingExpression:">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aType typeString.	expression ifNotNil: [ sqlStatementStream nextPutAll: ' USING ', expression ].	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatement:setDefault:">createAlterColumnStatement: aField setDefault: anObject	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT ';		space.	anObject printOn: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' WITH VALUES'.		^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementDropDefault:">createAlterColumnStatementDropDefault: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT NULL'.	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementDropNotNull:">createAlterColumnStatementDropNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aField type typeString;		space;		nextPutAll:  'NULL'.		^sqlStatementStream contents</body><body package="GlorpDatabase" selector="createAlterColumnStatementSetNotNull:">createAlterColumnStatementSetNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aField type typeString;		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint.		^sqlStatementStream contents</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	"My AccessPlatform subclass has a hardcoded check in StoreDescriptorSystem&gt;&gt;sequenceFor: to ignore this method in favour of calling #justSelectTheMaximumCurrentValueAndAddOneSequenceFor: for AccessPlatform.  Can we retire that?"	^SQLServerSequence</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="printSqlStatementToListTablesInSchema:on:">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Not standardized"	| lowerSchema |	self usesInformationSchema		ifFalse: [^self subclassResponsibility].	lowerSchema := (schemaString isNil or: [schemaString isEmpty])		ifTrue: ['']		ifFalse: [schemaString asLowercase , '.'].	aStream		nextPutAll: 'SELECT table_name FROM ' ;		nextPutAll: lowerSchema;		nextPutAll: 'INFORMATION_SCHEMA.TABLES ';		nextPut: $;</body><body package="GlorpDatabase" selector="printSqlStatementToTestExistenceOfTable:inSchema:on:">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	" This query will test only for tables that the logged on user has access to... "	| lowerTableName lowerSchema |	lowerTableName := tableName asLowercase.	lowerSchema := schemaString isNil		ifTrue: ['']		ifFalse: [schemaString asLowercase, '.'].	aStream		nextPutAll: 'SELECT count(*) FROM ' ;		nextPutAll: lowerSchema;		nextPutAll: 'INFORMATION_SCHEMA.TABLES ';		nextPutAll: 'WHERE lower(table_name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $';		nextPut: $;</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>public</category><body package="GlorpDatabase" selector="creationString">creationString	^'create sequence ', self qualifiedName.</body><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: anAccessor 	aRow at: aField put: (self nextSequenceNumber: anAccessor)</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>accessing</category><body package="GlorpDatabase" selector="name:">name: aString	name := aString copyFrom: 1 to: (aString size min: OraclePlatform new maximumLengthOfTableName).</body><body package="GlorpDatabase" selector="sequenceIncrement">sequenceIncrement	^sequenceIncrement</body><body package="GlorpDatabase" selector="sequenceIncrement:">sequenceIncrement: aNumber 	sequenceIncrement := aNumber</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>testing</category><body package="GlorpDatabase" selector="alwaysGetFromDb">alwaysGetFromDb	^sequenceIncrement = 1</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>private</category><body package="GlorpCore" selector="backupReserveCommand:in:">backupReserveCommand: anInteger in: aSession	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: '.nextval from SYS.ALL_OBJECTS '.	stream nextPutAll: ' WHERE rownum &lt;= '.	stream		nextPutAll:			(aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body><body package="GlorpDatabase" selector="nextSequenceNumber:">nextSequenceNumber: anAccessor 	accessProtect critical: 			[count := count + 1.			^(self alwaysGetFromDb or: [count \\ sequenceIncrement = 1]) 				ifTrue: 					[count := (anAccessor 								executeSQLString: self nextSequenceNumberSelectString) first 								first]				ifFalse: [count]]</body><body package="GlorpDatabase" selector="nextSequenceNumberSelectString">nextSequenceNumberSelectString	^'SELECT ' , self qualifiedName , '.NEXTVAL FROM DUAL'</body><body package="GlorpDatabase" selector="reserveViaBackupMechanism:in:">reserveViaBackupMechanism: anInteger in: aSession	"The regular mechanism didn't work, (probably because there weren't enough rows in the table), try a different technique. Oracle doesn't repeatedly evaluate nextval if we do it multiple times on a line, so instead guess at a table we know should have lots of rows in Oracle and use it"	| rows command |	command := self backupReserveCommand: anInteger in: aSession.	command blockFactor: anInteger.	rows := aSession accessor executeCommand: command.	rows do: [:each | self reservedNumbers add: each first].</body><body package="GlorpDatabase" selector="reserveViaTableSelect:in:for:">reserveViaTableSelect: anInteger in: aSession for: aTable	"In Oracle, there can be performance issues selecting against our tables, which we don't seem to get if we just use SYS.ALLOBJECTS. I'm suspicious the problem is if we have fragmentation of the file containing the table, but regardless, ALLOBJECTS seems consistently fast, so always use it"	self reserveViaBackupMechanism: anInteger in: aSession."	| rows command |	command := self		tableSelectCommandFor: aTable		in: aSession		reserving: anInteger.	command parameters: (Array with: anInteger).	rows := aSession accessor executeCommand: command.	rows do: [:each | self reservedNumbers add: each first]."</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>initalize-release</category><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	count := 0.	sequenceIncrement := 1.	"This seems to hang on the semaphore in ObjectStudio. Fake around it"	accessProtect := Dialect isObjectStudio ifTrue: [nil] ifFalse: [Semaphore forMutualExclusion].</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: '.nextval from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' WHERE rownum &lt;= '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>accessing</category><body package="GlorpDatabase" selector="fields">fields	^fields.</body><body package="GlorpDatabase" selector="name"> name	name isNil ifTrue: [name := self generateName].	^name.</body><body package="GlorpDatabase" selector="name:">name: aString	name := aString.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>testing</category><body package="GlorpDatabase" selector="indexesField:">indexesField: aField	^fields includes: aField.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>initializing</category><body package="GlorpDatabase" selector="addField:">addField: aField	fields add: aField</body><body package="GlorpDatabase" selector="addFields:">addFields: aCollection	fields addAll: aCollection</body><body package="GlorpDatabase" selector="initialize">initialize	fields := OrderedCollection new: 2.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>printing</category><body package="GlorpDatabase" selector="generateName">generateName	"Generate a name for this index that will fit within the size limits of the database. This only takes into account the first field being used. If there's more than one that has multiple columns and the same first one, then the user will have to manually provide a name"	| stream maxLength tableLength roomToBeVerbose minTableLength maxTableLength |	maxLength := fields first table platform maximumLengthOfTableName.	minTableLength := ((maxLength - 8) // 2) min: 10.	maxTableLength := (maxLength // 2) - 1.	roomToBeVerbose := minTableLength &gt;= 10.	tableLength := roomToBeVerbose ifTrue: [maxTableLength] ifFalse: [minTableLength].	stream := WriteStream on: (String new: 100).	stream nextPutAll: (fields first table name copyFrom: 1 to: ((fields first table name size) min: tableLength)).	stream nextPutAll: '_'.	stream nextPutAll: (fields first name copyFrom: 1 to: ((fields first name size) min: tableLength)).	stream nextPutAll: (maxLength - stream position &gt;= 4 ifTrue: ['_IDX'] ifFalse: ['X']).	^stream contents.</body><body package="GlorpDatabase" selector="printStatementOn:">printStatementOn: aStream	aStream nextPut: $(.	fields do: [ :f | aStream nextPutAll: f name; nextPut: $, ].	aStream skip: -1; nextPut: $)</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>comparing</category><body package="GlorpDatabase" selector="isTheSameAs:">isTheSameAs: aDatabaseIndex	"Validate that two indexes are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aDatabaseIndex name asUppercase ifFalse: [^false].	self fields with: aDatabaseIndex fields  do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		^true.</body></methods><methods><class-id>Glorp.DatabaseIndex class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="forField:">forField: aField	^(self new initialize)		addField: aField;		yourself</body><body package="GlorpDatabase" selector="forFields:">forFields: aCollection	^(self new)		addFields: aCollection;		yourself</body><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries" selector="fieldsForSelectStatement">fieldsForSelectStatement	^self fieldsFromThePerspectiveOfTheMainSelect: (self fieldsFromMyPerspective).</body><body package="GlorpQueries" selector="fieldsFromMyPerspective">fieldsFromMyPerspective	^query returnProxies 		ifTrue: [self descriptor table primaryKeyFields]		ifFalse: [self descriptor fieldsForSelectStatement]</body><body package="GlorpQueries" selector="fieldsFromThePerspectiveOfTheMainSelect:">fieldsFromThePerspectiveOfTheMainSelect: aCollection	^expression translateFields: aCollection.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>printing</category><body package="GlorpQueries" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	expression printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>building objects</category><body package="GlorpQueries" selector="buildObjectFrom:">buildObjectFrom: anArray	self row: anArray.	self requiresPopulating ifTrue: [self populateInstance].	(self system shouldResetExpiryTimeForObjectOfClass: instance class readFrom: self query)		ifTrue: [self session markAsCurrentOfClass: instance class key: self key].</body><body package="GlorpQueries" selector="canBuild">canBuild	"If we have a regular object with a nil primary key, or if we have an embedded object whose values are all nil, we can't build anything (probably due to an outer join)"	^self descriptor mapsPrimaryKeys		ifTrue: [self key notNil]		ifFalse: [true].</body><body package="GlorpQueries" selector="canCache">canCache	| keyFields |	keyFields := self descriptor keyFields.	^keyFields notNil and: [keyFields notEmpty].</body><body package="GlorpQueries" selector="createObjectOfClass:">createObjectOfClass: aClass	"Try to create objects using new, so initialization can run. But if we can't do it, then just use basicNew."	^[aClass new] on: Error do: [:ex | ex return: aClass basicNew].</body><body package="GlorpQueries" selector="findInstanceForRow:proxyType:">findInstanceForRow: aRow proxyType: proxyType	instance := nil.	self row: aRow.	self canBuild ifFalse: [^self].	(self shouldProxyInstanceFor: proxyType)		ifTrue: [^self newProxyWithNewQueryForClass: proxyType].	self lookupCachedObject.	self instanceExistsButIsDeleted		ifTrue:			[instance := nil.			^self].	instance isNil		ifFalse:			[requiresPopulating := requiresPopulating | query shouldRefresh.			^self].	requiresPopulating := true.	instance := self createObjectOfClass: (expression descriptor		describedConcreteClassFor: self row		withBuilder: self).	self canCache ifTrue: [self session cacheAt: self key put: instance].</body><body package="GlorpQueries" selector="instanceDescriptor">instanceDescriptor	"Return the descriptor for the instance we're going to build. Note that we have to look it up by instance in order to find subclass. "	| basicDescriptor |	instance isNil ifTrue: [^nil].	basicDescriptor := self system descriptorFor: instance.	basicDescriptor isNil ifFalse: [^basicDescriptor].	^expression descriptor.</body><body package="GlorpQueries" selector="instanceExistsButIsDeleted">instanceExistsButIsDeleted	instance isNil ifTrue: [^false].	instance := self session filterDeletionFrom: instance.	^instance isNil.</body><body package="GlorpQueries" selector="knitResultIn:">knitResultIn: aCursoredStream 	"Connect up our built object with any other objects that reference it. Used if we retrieve more than one thing in the same query"	| relatedBuilder |	expression canKnit ifFalse: [^self].	relatedBuilder := aCursoredStream objectBuilderFor: expression base.	(relatedBuilder isNil or: [relatedBuilder instance isNil]) 		ifFalse: 			[expression mapping knitFromBuilder: relatedBuilder toBuilder: self]</body><body package="GlorpQueries" selector="lookupCachedObject">lookupCachedObject	| resultClass |	self canBuild ifFalse: [^self].	self canCache		ifTrue:			[			resultClass := expression descriptor describedClass.			(self session hasExpired: resultClass key: self key)				ifTrue:					[instance := self session expiredInstanceOf: resultClass key: self key.					requiresPopulating := true.					isExpired := true]				ifFalse:					[instance := self session cacheLookupForClass: resultClass key: self key.					requiresPopulating := instance isNil]].</body><body package="GlorpQueries" selector="newProxyWithNewQueryForClass:">newProxyWithNewQueryForClass: aClass	| parameters |	parameters := IdentityDictionary new.	self descriptor primaryTable primaryKeyFields		do:			[:eachField | parameters at: eachField put: (self valueOfField: eachField in: row)].	instance := aClass new		session: self session;		parameters: parameters;		query: self queryForNewProxy.	self session addToReaper: instance.	^self.</body><body package="GlorpQueries" selector="populateInstance">populateInstance	| tracker |	key isNil ifTrue: [^self].	self instanceDescriptor populateObject: instance inBuilder: self.	tracker := self session modificationTracker.	tracker isNil ifFalse: [tracker track: instance].</body><body package="GlorpQueries" selector="queryForNewProxy">queryForNewProxy	"Create a proxy with a primary key query in which the parameters are the primary key fields. We can't just reuse a mapping's query, it has to be a new primary key one, because the mapping's query has just run and been told to return proxies. This kind of stinks"	| whereExpression |	whereExpression := Join new.	self descriptor primaryTable primaryKeyFields do: [:eachField | 		whereExpression addSource: eachField target: eachField].	^Query		returningOneOf: query resultClass 		where: whereExpression</body><body package="GlorpQueries" selector="shouldProxyInstanceFor:">shouldProxyInstanceFor: proxyType	^proxyType notNil.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>accessing</category><body package="GlorpQueries" selector="cachedQueryFor:">cachedQueryFor: aMapping	^self queryCache at: aMapping ifAbsent: [nil].</body><body package="GlorpQueries" selector="cachedQueryFor:is:">cachedQueryFor: aMapping is: aQuery	"Save a query which we will use when constructing filtered queries"	self queryCache at: aMapping put: aQuery.</body><body package="GlorpQueries" selector="canCauseDuplicateRows">canCauseDuplicateRows	^expression class == MappingExpression and: [expression mapping isToManyRelationship].</body><body package="GlorpQueries" selector="command">command	^cursor command.</body><body package="GlorpQueries" selector="descriptor">descriptor		^expression descriptor.</body><body package="GlorpQueries" selector="instance:">instance: anObject	instance := anObject</body><body package="GlorpQueries" selector="key">key	^self primaryKey.</body><body package="GlorpQueries" selector="primaryKey">primaryKey	"We use self as a special guard value to indicate that the value hasn't changed"	key == self ifFalse: [^key].	self canCache ifFalse: [^nil].	key := self descriptor keyFields		collect: [:each | self valueOfField: each].	key size = 1 ifTrue: [key := key first].	^key.</body><body package="GlorpQueries" selector="queryCache">queryCache	queryCache isNil ifTrue: [queryCache := IdentityDictionary new: 5].	^queryCache.</body><body package="GlorpQueries" selector="requiresPopulating">requiresPopulating	^requiresPopulating and: [self returnProxies not].</body><body package="GlorpQueries" selector="requiresPopulating:">requiresPopulating: aBoolean	requiresPopulating := aBoolean</body><body package="GlorpQueries" selector="returnProxies">returnProxies	^query returnProxies.</body><body package="GlorpQueries" selector="returnValueIn:">returnValueIn: aCursoredStream	"If we're a to-many relationship, what we retrieve: is the collection containing us, not the individual items"	| relatedBuilder |	expression canKnit ifFalse: [^self instance].	expression mapping isToManyRelationship ifFalse: [^self instance].	relatedBuilder := aCursoredStream elementBuilderFor: expression base.	(relatedBuilder isNil or: [relatedBuilder instance isNil]) ifTrue: [^self instance].	^expression mapping getValueFrom: relatedBuilder instance.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>initializing</category><body package="GlorpQueries" selector="initialize">initialize	requiresPopulating := false.	isExpired := false.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	queryCache := nil.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>testing</category><body package="GlorpQueries" selector="buildsObjects">buildsObjects	^true.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>copying</category><body package="GlorpQueries" selector="copy">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries" selector="copyAndGrowBy:">copyAndGrowBy: anInteger	"For VA compatibility"	^super glorpShallowCopy.</body><body package="GlorpQueries" selector="copyFrom:to:">copyFrom: start to: stop	^self realObjects copyFrom: start to: stop.</body><body package="GlorpQueries" selector="postCopy">postCopy	query := query copy.	realObjects := nil.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>testing</category><body package="GlorpQueries" selector="isEmpty">isEmpty	^self realObjects isEmpty.</body><body package="GlorpQueries" selector="isInstantiated">isInstantiated	^realObjects notNil.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>enumerating</category><body package="GlorpQueries" selector="collect:">collect: aBlock	^self realObjects collect: aBlock</body><body package="GlorpQueries" selector="do:">do: aBlock	self realObjects do: aBlock.</body><body package="GlorpQueries" selector="reject:">reject: aBlock	^self copy AND: [:each | (aBlock value: each) not].</body><body package="GlorpQueries" selector="select:">select: aBlock	^self isInstantiated ifTrue: [self realObjects select: aBlock] ifFalse: [self copy AND: aBlock].</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>removing</category><body package="GlorpQueries" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock	self readOnlyError.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>accessing</category><body package="GlorpQueries" selector="first">first	^self realObjects first.</body><body package="GlorpQueries" selector="last">last	^self realObjects last.</body><body package="GlorpQueries" selector="orderBy:">orderBy: aBlockOrExpression	query orderBy: aBlockOrExpression.</body><body package="GlorpQueries" selector="parameters:">parameters: aCollection	parameters := aCollection</body><body package="GlorpQueries" selector="setQuery:">setQuery: aQuery	"Semi-private. Set the internal query"	query := aQuery.</body><body package="GlorpQueries" selector="setSession:">setSession: aSession	"Semi-private. Set the session"	session := aSession.</body><body package="GlorpQueries" selector="size">size	^self realObjects size.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>private</category><body package="GlorpQueries" selector="AND:">AND: aBlock	query AND: aBlock.</body><body package="GlorpQueries" selector="getQuery">getQuery	^query.</body><body package="GlorpQueries" selector="readOnlyError">readOnlyError	self error: 'Virtual collections are read-only'.</body><body package="GlorpQueries" selector="realObjects">realObjects	realObjects isNil ifTrue: [	realObjects := query executeWithParameters: parameters in: session].	^realObjects.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>printing</category><body package="GlorpQueries" selector="printOn:">printOn: aStream	self isInstantiated		ifTrue: [super printOn: aStream]		ifFalse:			[aStream nextPutAll: 'a virtual collection of '.			query notNil ifTrue: [aStream nextPutAll: query resultClass name]].</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>adding</category><body package="GlorpQueries" selector="add:">add: newObject	self readOnlyError.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>initialize-release</category><body package="GlorpQueries" selector="on:in:">on: aClass in: aSession	query := Query returningManyOf: aClass.	session := aSession.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="on:in:">on: aClass in: aSession	^self new on: aClass in: aSession.</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>accessing</category><body package="GlorpDatabase" selector="fields">fields	^fields</body><body package="GlorpDatabase" selector="fields:">fields: anObject	fields := anObject</body><body package="GlorpDatabase" selector="generateName">generateName	^self subclassResponsibility</body><body package="GlorpDatabase" selector="name">name	name isNil ifTrue: [name := self generateName].	^name.</body><body package="GlorpDatabase" selector="name:">name: aString	name := aString.</body><body package="GlorpDatabase" selector="shouldCreateInDatabase">shouldCreateInDatabase	^shouldCreateInDatabase ifNil: [true]</body><body package="GlorpDatabase" selector="shouldCreateInDatabase:">shouldCreateInDatabase: aBoolean	"If false, then this is a constraint that we use for in-memory ordering, but it should not be created in the database, possibly for performance, or because it might cause a cycle"	shouldCreateInDatabase := aBoolean</body><body package="GlorpDatabase" selector="table">table	^table</body><body package="GlorpDatabase" selector="table:">table: anObject	table := anObject</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>printing</category><body package="GlorpDatabase" selector="creationString">creationString	^(self creationStringFor: self table platform) first.</body><body package="GlorpDatabase" selector="creationStringFor:">creationStringFor: aPlatform	^self subclassResponsibility</body><body package="GlorpDatabase" selector="dropString">dropString	^self dropStringFor:  self table platform</body><body package="GlorpDatabase" selector="dropStringFor:">dropStringFor: aPlatform	^aPlatform createConstraintDropStatement: self</body><body package="GlorpDatabase" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self name;		nextPut: $).</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>initializing</category><body package="GlorpDatabase" selector="forTable:">forTable: aTable	table := aTable</body><body package="GlorpDatabase" selector="initialize">initialize	shouldCreateInDatabase := true.</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>testing</category><body package="GlorpDatabase" selector="isForeignKeyConstraint">isForeignKeyConstraint	^false</body><body package="GlorpDatabase" selector="isPrimaryKeyConstraint">isPrimaryKeyConstraint	^false</body><body package="GlorpDatabase" selector="isUniqueConstraint">isUniqueConstraint	^false</body></methods><methods><class-id>Glorp.DatabaseTableConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="forTable:">forTable: aDatabaseTable	^self new		forTable: aDatabaseTable;		yourself</body><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>initializing</category><body package="GlorpDatabase" selector="forTable:">forTable: aTable	super forTable: aTable.	name := self primaryKeyConstraintName.	self primaryKeyFields:  table primaryKeyFields</body><body package="GlorpDatabase" selector="forTable:fields:">forTable: aDatabaseTable fields: collDatabaseFields	self forTable: aDatabaseTable.	self primaryKeyFields: collDatabaseFields</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>printing</category><body package="GlorpDatabase" selector="creationStringFor:">creationStringFor: aPlatform	^aPlatform createPrimaryKeyConstraintAddStatement: self</body><body package="GlorpDatabase" selector="generateName">generateName	^self table name, '_PK'.</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>accessing</category><body package="GlorpDatabase" selector="primaryKeyConstraintName">primaryKeyConstraintName	^self table name, '_PK'.</body><body package="GlorpDatabase" selector="primaryKeyFields">primaryKeyFields	^fields</body><body package="GlorpDatabase" selector="primaryKeyFields:">primaryKeyFields: aCollection	fields := aCollection</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>testing</category><body package="GlorpDatabase" selector="isPrimaryKeyConstraint">isPrimaryKeyConstraint	^true</body><body package="GlorpDatabase" selector="matchesPrimaryKeyConstraint:">matchesPrimaryKeyConstraint: aConstraint	name = aConstraint name ifFalse: [^false].	self primaryKeyFields size ~= aConstraint primaryKeyFields size ifTrue: [^false].	self primaryKeyFields with: aConstraint primaryKeyFields do: [ :field1 :field2 | 		(field1 matchesField: field2) ifFalse: [^false]].	^true</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>comparing</category><body package="GlorpDatabase" selector="isTheSameAs:">isTheSameAs: aPrimaryKeyConstraint	"Validate that two constraints are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aPrimaryKeyConstraint name asUppercase ifFalse: [^false].	self primaryKeyFields size = aPrimaryKeyConstraint primaryKeyFields size ifFalse: [^false].	self primaryKeyFields asSortedCollection with: aPrimaryKeyConstraint primaryKeyFields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self shouldCreateInDatabase = aPrimaryKeyConstraint shouldCreateInDatabase ifFalse: [^false].	^true.</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="forTable:fields:">forTable: aDatabaseTable fields: collDatabaseFields	^self new		forTable: aDatabaseTable  fields: collDatabaseFields;		yourself</body></methods><methods><class-id>Glorp.SQLite3Proxy</class-id> <category>proxy actions</category><body package="GlorpQueries" selector="glorpTriggerProxyAction:">glorpTriggerProxyAction: target	"Evaluate our action with the owner and the newly retrieved target.	Return the result of this evaluation, or self if there is no action.	Since the return value has ambiguous semantics, this needs work."	| owner block |	action isNil ifTrue: [^self].	owner := action key.	block := action value.	^block value: owner value: target.</body></methods><methods><class-id>Glorp.SQLite3Proxy</class-id> <category>api</category><body package="GlorpQueries" selector="getValue">getValue	"This method further modifies the retrieved value using the action block."	self isInstantiated ifTrue: [^value].	parameters isNil ifTrue: [parameters := Dictionary new: 0].		[value := query isNil				ifTrue: [nil]				ifFalse: [query executeWithParameters: parameters in: session]]			ensure: [isInstantiated := true].	value := self glorpTriggerProxyAction: value.	^value</body></methods><methods><class-id>Glorp.SQLite3Proxy</class-id> <category>accessing</category><body package="GlorpQueries" selector="class">class	^SQLite3Proxy</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	aStream print: value</body><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary	self value glorpPrintSelectSQLOn: aStream.	alias notNil ifTrue: [		aStream 			nextPutAll: ' AS ';			nextPutAll: alias].</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	self value glorpPrintSQLOn: aStream.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream print: value</body><body package="GlorpExpressions" selector="printUnqualifiedSQLOn:withParameters:">printUnqualifiedSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canBind">canBind	"Return true if this represents a value that can be bound into a prepared statement"	^true.</body><body package="GlorpExpressions" selector="isConstantExpression">isConstantExpression	^true.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="alias">alias	^alias</body><body package="GlorpExpressions" selector="alias:">alias: anObject	alias := anObject</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^false.</body><body package="GlorpExpressions" selector="field">field	^self.</body><body package="GlorpExpressions" selector="isSameAliasedFieldAs:">isSameAliasedFieldAs: aFieldOrFunction	^self == aFieldOrFunction.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^nil.</body><body package="GlorpExpressions" selector="value">value	^value</body><body package="GlorpExpressions" selector="value:">value: anObject	value := anObject</body><body package="GlorpExpressions" selector="valueIn:">valueIn: aDictionary	^value</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^self.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^self.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGlorpExpressionForDescriptor:">asGlorpExpressionForDescriptor: aDescriptor	"This should only get sent to us if we're the top level of an expression. And since we don't have children, we're also the bottom level. This is only useful for the case where the expression is [:each | true] or [:each | false]."	^(EmptyExpression on: value)		rebuildOn: (BaseExpression new descriptor: aDescriptor).</body><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	^self.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="mappedFields">mappedFields	^Array with: self.</body><body package="GlorpExpressions" selector="table">table	^nil.</body><body package="GlorpExpressions" selector="valueInBuilder:as:">valueInBuilder: aBuilder as: anExpression	^value.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="get:withArguments:">get: aSymbol withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>mapping</category><body package="GlorpExpressions" selector="valueInBuilder:">valueInBuilder: aBuilder	^value.</body></methods><methods><class-id>Glorp.ConstantExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="for:">for: anObject	^self new value: anObject.</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="preWriteAssignSequenceValueFor:in:using:">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	aDatabaseRow at: aDatabaseField put: (self class next)</body><body package="GlorpDatabaseTypes" selector="typeName">typeName	^representationType typeName.</body><body package="GlorpDatabaseTypes" selector="typeString">typeString	^representationType typeString</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="isGenerated">isGenerated	^true</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Integer.</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>initialize-release</category><body package="GlorpDatabaseTypes" selector="representedBy:">representedBy: dbType	representationType := dbType</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^representationType exdiType.</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType class</class-id> <category>instance creation</category><body package="GlorpDatabaseTypes" selector="representedBy:">representedBy: dbType	^super new		representedBy: dbType</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType class</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="next">next	(count isNil)	ifTrue: [count := 0].	count := count + 1.	^count</body><body package="GlorpDatabaseTypes" selector="reset">reset	count := 0</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>printing</category><body package="GlorpCore" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: items size printString.	aStream nextPut: $/.	aStream nextPutAll: maximumSize printString.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>accessing</category><body package="GlorpCore" selector="maximumSize">maximumSize	^maximumSize</body><body package="GlorpCore" selector="maximumSize:">maximumSize: anInteger	maximumSize := anInteger.	items := OrderedCollection new: maximumSize + 1.</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>api</category><body package="GlorpCore" selector="add:">add: anObject	items add: anObject.	items size &gt; maximumSize ifTrue: [items removeFirst].</body></methods><methods><class-id>Glorp.FixedSizeQueue class</class-id> <category>instance creation</category><body package="GlorpCore" selector="maximumSize:">maximumSize: anInteger	^self basicNew maximumSize: anInteger.</body><body package="GlorpCore" selector="new">new	self error: 'must supply a size'.</body><body package="GlorpCore" selector="new:">new: anInteger	^self maximumSize: anInteger.</body></methods><methods><class-id>Glorp.PGSequence</class-id> <category>SQL</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aDatabaseField in: aDatabaseRow using: anAccessor	| statement rows pk |	"this could be made smarter by aggregating keys to fetch into a single sql query - maybe later -tb"	statement := 'select nextval(''',  self qualifiedName, ''')'.	rows := anAccessor executeSQLString: statement.	pk := rows first first.	aDatabaseRow at: aDatabaseField put: pk.</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor"No-op;  for user information, we show, commented, the code that was provided here circa Glorp 0.2.*.	aDatabaseRow at: aDatabaseField		put: (aSession accessor 				executeSQLString: 'SELECT CURRVAL(' , self qualifiedName 	, ')')."</body><body package="GlorpDatabase" selector="reserveViaBackupMechanism:in:">reserveViaBackupMechanism: anInteger in: aSession	"The regular mechanism didn't work, (probably because there weren't enough rows in the table), try a different technique."	| command row |	command := self backupReserveCommand: anInteger in: aSession.	row := (aSession accessor executeCommand: command) first.	self reservedNumbers addAll: row.</body><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select nextval('.			self qualifiedName printOn: stream.			stream nextPutAll: ') from ' , aTable name.			stream nextPutAll: ' limit '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand session: aSession].	^tableSelectCommand.</body><body package="GlorpDatabase" selector="tableToSelectFromIn:for:">tableToSelectFromIn: session for: aTable	"Sometimes it's inefficient to select sequence values against our own table and we can use a database-specific system table instead to be much faster. Subclasses can override where this is the case"	^(session databaseTableClass named: 'pg_attribute').</body></methods><methods><class-id>Glorp.PGSequence</class-id> <category>private</category><body package="GlorpCore" selector="backupReserveCommand:in:">backupReserveCommand: anInteger in: aSession	| stream command |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select '.	GlorpHelper		print: [:i | 'nextval(''' , self qualifiedName , ''')']		on: stream		for: (1 to: anInteger)		separatedBy: ','.	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="arrayBoundFields">arrayBoundFields	"Don't have enough information to do this, I don't think"	^#()</body><body package="GlorpDatabase" selector="bindings">bindings	^parameters.</body><body package="GlorpDatabase" selector="bindingTypes">bindingTypes	^#()</body><body package="GlorpDatabase" selector="maximumLobSizeToRetrieveDirectly">maximumLobSizeToRetrieveDirectly	^maximumBlobSizeToRetrieveDirectly</body><body package="GlorpDatabase" selector="maximumLobSizeToRetrieveDirectly:">maximumLobSizeToRetrieveDirectly: anInteger	maximumBlobSizeToRetrieveDirectly := anInteger</body><body package="GlorpDatabase" selector="parameters">parameters	^parameters.</body><body package="GlorpDatabase" selector="parameters:">parameters: anArray	parameters := anArray</body><body package="GlorpDatabase" selector="parameterTypeSignature">parameterTypeSignature	^''</body><body package="GlorpDatabase" selector="setSQLString:">setSQLString: aString	sqlString := aString.</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>executing</category><body package="GlorpDatabase" selector="printSQL">printSQL	" *** This method was defined by Glorp.DatabaseCommand as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>testing</category><body package="GlorpDatabase" selector="succeeded">succeeded	" *** This method was defined by Glorp.DatabaseCommand as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>initialize-release</category><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	maximumBlobSizeToRetrieveDirectly := super maximumLobSizeToRetrieveDirectly.</body></methods><methods><class-id>Glorp.SQLStringCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="for:">for: aString	^self new setSQLString: aString.</body></methods><methods><class-id>Glorp.GlorpCorePackage class</class-id> <category>instance creation</category><body package="GlorpCore" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>testing</category><body package="GlorpDatabase" selector="generateOverExistingValues">generateOverExistingValues	generatesOverExistingValues := true.</body><body package="GlorpDatabase" selector="generatesOverExistingValues">generatesOverExistingValues	"Do we generate our value even if there's alread one present in the field"	^generatesOverExistingValues.</body><body package="GlorpDatabase" selector="generatesOverExistingValues:">generatesOverExistingValues: aBoolean	"Do we generate our value even if there's alread one present in the field"	generatesOverExistingValues := aBoolean.</body><body package="GlorpDatabase" selector="isGenerated">isGenerated	^true.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>accessing</category><body package="GlorpDatabase" selector="generator">generator	^generator</body><body package="GlorpDatabase" selector="generator:">generator: aDatabaseValueGenerator	generator := aDatabaseValueGenerator</body><body package="GlorpDatabase" selector="underlyingType">underlyingType	^underlyingType</body><body package="GlorpDatabase" selector="underlyingType:">underlyingType: aDatabaseType	underlyingType := aDatabaseType.	platform := aDatabaseType platform.	generator := self generatorFor: aDatabaseType.</body><body package="GlorpDatabase" selector="underlyingType:generator:">underlyingType: aDatabaseType generator: aGenerator	underlyingType := aDatabaseType.	platform := aDatabaseType platform.	generator := aGenerator.</body><body package="GlorpDatabase" selector="width">width	^self underlyingType width.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>initializing</category><body package="GlorpDatabase" selector="generatorFor:">generatorFor: aDatabaseType	aDatabaseType impliedSmalltalkType == Integer ifTrue: [^VersionNumberVersionGenerator new].	aDatabaseType impliedSmalltalkType == Dialect timestampClass ifTrue: [^TimestampVersionGenerator new].	self error: 'unknown version type'.</body><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	generatesOverExistingValues := false.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>SQL</category><body package="GlorpDatabase" selector="print:on:">print: aValue on: aStream	self underlyingType print: aValue on: aStream.</body><body package="GlorpDatabase" selector="typeString">typeString	^underlyingType typeString.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	^self.</body><body package="GlorpDatabase" selector="preWriteAssignSequenceValueFor:in:using:">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	^generator preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>exdi specific</category><body package="GlorpDatabase" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^self underlyingType exdiType.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>converting</category><body package="GlorpDatabase" selector="converterForStType:">converterForStType: aClass	^underlyingType converterForStType: aClass.</body></methods><methods><class-id>Glorp.VersionType class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="underlyingType:">underlyingType: aDatabaseType	^self new underlyingType: aDatabaseType.</body><body package="GlorpDatabase" selector="underlyingType:generator:">underlyingType: aDatabaseType generator: aGenerator	^self new underlyingType: aDatabaseType generator: aGenerator.</body></methods><methods><class-id>Glorp.GlorpWriteFailure</class-id> <category>accessing</category><body package="GlorpMisc" selector="command">command	^command</body><body package="GlorpMisc" selector="command:">command: anObject	command := anObject</body><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Database write failed'.</body><body package="GlorpMisc" selector="object">object	^object</body><body package="GlorpMisc" selector="object:">object: anObject	object := anObject</body><body package="GlorpMisc" selector="session">session	^self command session.</body></methods><methods><class-id>Glorp.GlorpWriteFailure class</class-id> <category>testing</category><body package="GlorpMisc" selector="mayResume">mayResume	^true.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>testing</category><body package="GlorpDatabase" selector="hasMultipleRows">hasMultipleRows	^allRows notNil and: [allRows size &gt; 1].</body><body package="GlorpDatabase" selector="maximumSingleWriteSize">maximumSingleWriteSize	"How many values will write at once. This is only really applicable when not doing binding and concatenating many statements together for one trip to the DB"	^1000.</body><body package="GlorpDatabase" selector="succeeded">succeeded	^failed not.</body><body package="GlorpDatabase" selector="supportsGroupWriting">supportsGroupWriting	"Return true if array binding or a similar mechanism can be used to execute us with multiple commands at once. I think in general this can only ever make sense for inserts (and possibly selects under some circumstances). Updates may want to update only part of the fields."	^false.</body><body package="GlorpDatabase" selector="tooBigForSingleWrite">tooBigForSingleWrite	^self hasMultipleRows and: [allRows size &gt; self maximumSingleWriteSize].</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="allRows">allRows	^allRows.</body><body package="GlorpDatabase" selector="allRows:">allRows: aCollectionOfDatabaseRows	allRows := aCollectionOfDatabaseRows.</body><body package="GlorpDatabase" selector="parameterTypeSignature">parameterTypeSignature	"Return a string indicating the parameter types. Complicated by the possibility of multiple rows, and of null values"	| result |	result := WriteStream on: String new.	self hasMultipleRows		ifTrue:			[row				keysAndValuesDo:					[:eachKey :eachValInFirstRow| 					| nextValue |					eachValInFirstRow notNil						ifTrue: [result nextPutAll: eachValInFirstRow class name]						ifFalse:							[allRows								do:									[:eachRow | 									(nextValue := eachRow at: eachKey ifAbsent: [nil]) notNil										ifTrue: [result nextPutAll: nextValue class name]]]]]		ifFalse:			[row				keysAndValuesDo:					[:eachKey :eachValue | result nextPutAll: eachValue class name]].	^result contents.</body><body package="GlorpDatabase" selector="row">row	^row.</body><body package="GlorpDatabase" selector="row:">row: anObject	row := anObject.	sqlString := nil.</body><body package="GlorpDatabase" selector="rowCount">rowCount	^rowCount.</body><body package="GlorpDatabase" selector="rowCount:">rowCount: anInteger	rowCount := anInteger.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>executing</category><body package="GlorpDatabase" selector="executeBoundIn:">executeBoundIn: anAccessor	| result |	(self hasMultipleRows and: [self shouldUseGroupWriting not])		ifTrue:			[self allRows				do:					[:each | 					self row: each.					result := anAccessor executeCommandBound: self.					result release.					failed := failed or: [self needsRowCount and: [rowCount ~= 1]].					each postWriteAssignSequencesUsing: anAccessor]]		ifFalse:			[result := anAccessor executeCommandBound: self.			result release.			failed := self needsRowCount and: [rowCount ~= self expectedNumberOfModifiedRows].			row postWriteAssignSequencesUsing: anAccessor].	"Results aren't interesting"	^ anAccessor cursorFor: #() readStream</body><body package="GlorpDatabase" selector="expectedNumberOfModifiedRows">expectedNumberOfModifiedRows	^self hasMultipleRows ifTrue: [allRows size] ifFalse: [1].</body><body package="GlorpDatabase" selector="subCommands">subCommands	| startPosition commands endPosition subRows newCommand |	startPosition := 1.	commands := OrderedCollection new.	[startPosition &gt; allRows size] whileFalse: [		endPosition := (startPosition + self maximumSingleWriteSize - 1) min: allRows size.		subRows := allRows copyFrom: startPosition to: endPosition.		newCommand := self class forRows: subRows useBinding: self useBinding session: self session.		commands add: newCommand.		startPosition := endPosition + 1].	^commands.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>bound values</category><body package="GlorpDatabase" selector="arrayBindings">arrayBindings	"Return bindings in a form suitable for Oracle array binding, i.e. a list of arguments, but each argument is itself a list of multiple values"	| allBindings fields |	fields := self arrayBoundFields.	allBindings := (1 to: fields size)		collect: [:each | Array new: allRows size].	1		to: allRows size		do:			[:rowNumber | 			| inputRow |			inputRow := allRows at: rowNumber.			1				to: fields size				do:					[:columnNumber | 					(allBindings at: columnNumber)						at: rowNumber						put: (inputRow at: (fields at: columnNumber) ifAbsent: [nil])]].	^allBindings asArray.</body><body package="GlorpDatabase" selector="arrayBoundFields">arrayBoundFields	"Return the list of fields to be bound in the SQL string we will use for array binding. For array binding, we need to include all possible fields, rather than those that just have values in a particular row"	self subclassResponsibility.</body><body package="GlorpDatabase" selector="batchStatementBindings">batchStatementBindings	"Return our bindings, which we assume are for multiple rows, as one big array, one statement after the other"	| bound fields |	fields := self arrayBoundFields.	bound := OrderedCollection new: allRows size * fields size.	allRows do: [:eachRow | 		fields do: [:each | 			| fieldValue |			fieldValue := eachRow at: each ifAbsent: [nil].			(self canBind: fieldValue to: each type) ifTrue: [bound add: fieldValue]]].	^bound asArray.</body><body package="GlorpDatabase" selector="bindings">bindings	^(self shouldUseGroupWriting)		ifTrue: [self platform bindingsForGroupWritingFor: self]		ifFalse: [self singleRowBindings].</body><body package="GlorpDatabase" selector="bindingTypes">bindingTypes	| all basic size |	^(self shouldUseGroupWriting)		ifTrue: [			basic := self row nonGeneratedFields collect: [:each | each type].			size := basic size.			all := Array new: (allRows size * size).			0 to: allRows size - 1 do: [:i |				| index |				index := i * size.				all replaceElementsFrom: index + 1 to: index + size withArray: basic startingAt: 1].			all]		ifFalse: [self singleRowBoundFields collect: [:each | each type]].</body><body package="GlorpDatabase" selector="executeUnboundIn:">executeUnboundIn: anAccessor	anAccessor returnRowCount: self needsRowCount.	(self hasMultipleRows and: [self shouldUseGroupWriting not])		ifTrue:			[self allRows				do:					[:each | 					self row: each.					anAccessor						executeSQLStringNoResult: self sqlString						doing:							[failed := failed or: [self needsRowCount and: [anAccessor rowCount ~= 1]]]						forCommand: self.					each postWriteAssignSequencesUsing: anAccessor]]		ifFalse:			[self tooBigForSingleWrite				ifTrue:					[self subCommands do: [:each | each executeUnboundIn: anAccessor]]				ifFalse:					[anAccessor						executeSQLStringNoResult: self sqlString						doing:							[failed := self needsRowCount								and: [anAccessor rowCount ~= self expectedNumberOfModifiedRows]]						forCommand: self].			row postWriteAssignSequencesUsing: anAccessor].	^#() readStream.</body><body package="GlorpDatabase" selector="rowAtATimeBindings">rowAtATimeBindings	"Return multiple sets of bindings in a form suitable for iterating over"	| allBindings fields rowTemplate |	fields := self arrayBoundFields.	rowTemplate := Array new: fields size.	allBindings := Array new: allRows size.	1 to: allBindings size do: [:i | | currentRow input |		currentRow := rowTemplate copy.		input := allRows at: i.		allBindings at: i put: currentRow.		1 to: fields size do: [:j |			currentRow at: j put: (input at: (fields at: j) ifAbsent: [nil])]].	^allBindings asArray.</body><body package="GlorpDatabase" selector="singleRowBindings">singleRowBindings	| bound |	bound := OrderedCollection new.	self singleRowBoundFields		do:			[:each | 			| fieldValue |			fieldValue := row at: each ifAbsent: [nil].			(self canBind: fieldValue to: each type) ifTrue: [bound add: fieldValue]].	^bound asArray.</body><body package="GlorpDatabase" selector="singleRowBoundFields">singleRowBoundFields	"Return the list of fields to be bound in the SQL string we will use for a single operation. We only need to include those fields that actually have values in the particular row we're operating on"	self subclassResponsibility.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>initializing</category><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	failed := false.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>reporting</category><body package="GlorpDatabase" selector="tables">tables	^Array with: self row table.</body></methods><methods><class-id>Glorp.RowBasedCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="forRow:useBinding:session:">forRow: aDatabaseRow useBinding: aBoolean session: aSession	^(self new)		row: aDatabaseRow;		useBinding: aBoolean;		session: aSession;		yourself.</body><body package="GlorpDatabase" selector="forRows:useBinding:session:">forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession	^(self new)		allRows: aCollectionOfDatabaseRows;		row: aCollectionOfDatabaseRows first;		useBinding: aBoolean;		session: aSession;		yourself.</body></methods><methods><class-id>Glorp.DeleteCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="arrayBoundFields">arrayBoundFields	"For a delete, it makes no difference, we only ever include the primary key fields"	^self singleRowBoundFields.</body><body package="GlorpDatabase" selector="blockFactor">blockFactor	^1.</body><body package="GlorpDatabase" selector="printSQL">printSQL	self nextPutAll: 'DELETE FROM '.	row table printSQLOn: self withParameters: #().	self nextPutAll: ' WHERE '.	row printPrimaryKeyTemplateOn: self.</body><body package="GlorpDatabase" selector="singleRowBoundFields">singleRowBoundFields	| fields |	fields := row table primaryKeyFields.	fields isEmpty ifTrue: [fields := row fields].	^fields asArray</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	aClass = Date ifTrue: [^self platform converterNamed: #timestampToDate].	^self platform converterNamed: #timestamp.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Dialect timestampClass.</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Timestamp.</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="print:on:">print: aValue on: aStream	self platform printTimestamp: aValue on: aStream for: self.</body></methods><methods><class-id>Glorp.SubstringFunction</class-id> <category>accessing</category><body package="GlorpExpressions" selector="type">type	| aPlatform |	^(aPlatform := self ultimateBaseExpression system platform) isDB2Platform		ifTrue: [super type]		ifFalse: [aPlatform varchar: 255]</body></methods><methods><class-id>Glorp.SubstringFunction</class-id> <category>rewriting</category><body package="GlorpExpressions" selector="rewriteForOracleBlobsWith:">rewriteForOracleBlobsWith: mainArgument	"For Oracle blobs, we can't query with a normal substring function, but rather have to use the DBMS_LOB function, whose arguments are backwards. Further, we don't seem to be able to compare to byte-arrays, so turn it into a string."	| oldBase template startPosition endPosition length |	(mainArgument isGlorpExpression and: [mainArgument isConstantExpression]) ifFalse: [^self].	function := 'UTL_RAW.CAST_TO_VARCHAR2'.	startPosition := arguments first value.	endPosition := arguments last value.	length := arguments last value.	arguments := #().	oldBase := base.	template := PrefixFunction named: 'DBMS_LOB.SUBSTR'.	base := template createFor: (Array with: length asGlorpExpression with: startPosition asGlorpExpression) withBase: oldBase symbol: #dbmsLobSubstr.</body><body package="GlorpExpressions" selector="rewriteForPostgresqlBase64BlobsWith:">rewriteForPostgresqlBase64BlobsWith: mainArgument	"This is pretty awful. We expect our main argument to be a string, and we're a substring function, but we know that for some types, the string representation comes out differently in the database. In particular, the Postgresql driver stores strings into lobs in Base64. So, if our previous argument = the string size, rewrite it to the database size. This makes it work if we do    (someObject blob copyFrom: 1 to: 3) = 'abc'when in fact, the length of that string in the blob will be 4."	| stream actualArgument base64Length base64Start |	(mainArgument isGlorpExpression and: [mainArgument isConstantExpression]) ifFalse: [^self].	self field type = self field platform blob ifFalse: [^self].	(mainArgument value size \\ 3) = 0 ifFalse: [self error: 'Sorry, but you will need to use a number of characters that base64 encodes exactly'].	base64Length := (mainArgument value size // 3) * 4.	arguments at: 2 put: base64Length asGlorpExpression.	base64Start := ((arguments first value // 3) * 4) + 1.	arguments at: 1 put: base64Start asGlorpExpression.	stream := WriteStream on: String new.	self field type print: mainArgument value on: stream.	actualArgument := (ReadStream on: stream contents) skip: 1; upTo: $'.	mainArgument value: actualArgument.</body><body package="GlorpExpressions" selector="rewriteFunctionArgumentsWith:">rewriteFunctionArgumentsWith: mainArgument	"This is pretty awful. We expect our main argument to be a string, and we're a substring function, but we know that for some types, the string representation comes out differently in the database. In particular, the Postgresql driver stores strings into lobs in Base64. So, if our previous argument = the string size, rewrite it to the database size. This makes it work if we do    (someObject blob copyFrom: 1 to: 3) = 'abc'when in fact, the length of that string in the blob will be 4."	| platform |	platform := base ultimateBaseExpression system platform.	(platform class == PostgreSQLPlatform and: [self field type = platform blob]) ifTrue: [^self rewriteForPostgresqlBase64BlobsWith: mainArgument].	(platform isOraclePlatform and: [self field type = platform blob]) ifTrue: [^self rewriteForOracleBlobsWith: mainArgument].</body></methods><methods><class-id>Glorp.SubstringFunction</class-id> <category>preparing</category><body package="GlorpExpressions" selector="rewriteFunctionArguments">rewriteFunctionArguments	"For Postgres, MySQL, SQL Server and DB2, it wants position, length rather than startPosition, endPosition."	| platform |	platform := base ultimateBaseExpression system platform.	(#(#PostgreSQLPlatform #MySQLPlatform #SQLServerPlatform #DB2Platform #OraclePlatform)		includes: platform class name)			ifTrue: [arguments last value: arguments last value - arguments first value + 1]</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>initialize</category><body package="GlorpCore" selector="collectionForExtraReferences">collectionForExtraReferences	^nil.</body><body package="GlorpCore" selector="initialize">initialize	numberOfElements := 100.	expiryAction := #remove.</body><body package="GlorpCore" selector="newItemsIn:">newItemsIn: aCache	^self dictionaryClass new: 20.</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>accessing</category><body package="GlorpCore" selector="dictionaryClass">dictionaryClass	^Dictionary.</body><body package="GlorpCore" selector="expiryAction">expiryAction	^expiryAction</body><body package="GlorpCore" selector="expiryAction:">expiryAction: aSymbol	"See class comment for possible values"	expiryAction := aSymbol</body><body package="GlorpCore" selector="numberOfElements">numberOfElements	^numberOfElements</body><body package="GlorpCore" selector="numberOfElements:">numberOfElements: anInteger	numberOfElements := anInteger</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>wrap/unwrap</category><body package="GlorpCore" selector="cacheEntryFor:">cacheEntryFor: anObject	^anObject.</body><body package="GlorpCore" selector="contentsOf:">contentsOf: aCacheEntry	^aCacheEntry.</body><body package="GlorpCore" selector="hasExpired:">hasExpired: aCacheEntry	^false.</body><body package="GlorpCore" selector="markEntryAsCurrent:in:">markEntryAsCurrent: aCacheEntry in: aCache	^self.</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>expiry</category><body package="GlorpCore" selector="expire:">expire: anItem	"Force anItem to be expired. This may be ignored if the policy doesn't respect this, and is ignored by default"</body><body package="GlorpCore" selector="notifyOfExpiry:in:">notifyOfExpiry: anObject in: aCache 	anObject glorpNoticeOfExpiryIn: aCache session.</body><body package="GlorpCore" selector="release:">release: aCache	(expiryAction == #notify or: [expiryAction == #notifyAndRemove])		ifTrue: [			aCache do: [:each |				(self contentsOf: each)  glorpNoticeOfExpiryIn: aCache session]].</body><body package="GlorpCore" selector="takeExpiryActionForKey:withValue:in:">takeExpiryActionForKey: key withValue: anObject in: aCache	expiryAction == #refresh		ifTrue: [aCache session refresh: anObject].	(#(#notify #notifyAndRemove) includes: expiryAction) ifTrue: [		self notifyOfExpiry: anObject in: aCache].	(#(#remove #notifyAndRemove) includes: expiryAction) ifTrue: [		aCache removeKey: key ifAbsent: []].</body><body package="GlorpCore" selector="willRemoveItems">willRemoveItems	^(expiryAction == #notifyAndRemove or: [expiryAction == #remove])</body></methods><methods><class-id>Glorp.CachePolicy class</class-id> <category>instance creation</category><body package="GlorpCore" selector="default">default	"Use of the WeakVWCache is tied in with Ephemera which we do not expect to get working in VW3."	Dialect isVWWithNameSpaces ifTrue: [^WeakVWCachePolicy new].	^self new</body><body package="GlorpCore" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.MultipleMappingsForInstanceVariable</class-id> <category>accessing</category><body package="GlorpMisc" selector="attributeNames">attributeNames	^attributeNames</body><body package="GlorpMisc" selector="attributeNames:">attributeNames: anObject	attributeNames := anObject</body><body package="GlorpMisc" selector="messageText">messageText	^'Multiple readable mappings for one instance variable:&lt;1s&gt;' expandMacrosWith: self readableMappings  printString</body><body package="GlorpMisc" selector="readableMappings">readableMappings	^readableMappings</body><body package="GlorpMisc" selector="readableMappings:">readableMappings: anObject	readableMappings := anObject</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase" selector="createSession">createSession	"For Oracle, we set the defaultDisplayLobSize:.	For DB2, set the sesssion's setDataChunkSize:"	| session |	session := connection getSession.	(session respondsTo: #defaultDisplayLobSize:) ifTrue: [		session defaultDisplayLobSize: DatabaseCommand new maximumLobSizeToRetrieveDirectly]. 	(session respondsTo: #setDataChunkSize:) ifTrue: [		session setDataChunkSize: DatabaseCommand new maximumLobSizeToRetrieveDirectly]. 	session blockFactor: 100.  "We don't know, so make it big"	^session.</body><body package="GlorpDatabase" selector="createSessionFor:">createSessionFor: aCommand	"For Oracle, we set the defaultDisplayLobSize:.	For DB2, set the sesssion's setDataChunkSize:"	| session types |	session := connection getSession.	(session respondsTo: #defaultDisplayLobSize:) ifTrue: [		session defaultDisplayLobSize: aCommand maximumLobSizeToRetrieveDirectly]. 	(session respondsTo: #setDataChunkSize:) ifTrue: [		session setDataChunkSize: DatabaseCommand new maximumLobSizeToRetrieveDirectly]. 	session blockFactor: aCommand blockFactor.	types := aCommand bindingTypesForEXDI.	types isEmpty ifFalse: [session bindTemplate: types].	^session.</body><body package="GlorpDatabase" selector="currentLogin:">currentLogin: aLogin	self reusePreparedStatements: aLogin database reusePreparedStatements.	super currentLogin: aLogin.</body><body package="GlorpDatabase" selector="driverSession">driverSession	driverSession isNil ifTrue: [driverSession := self createSession].	^driverSession.</body><body package="GlorpDatabase" selector="encoding">encoding	^connection encoding.</body><body package="GlorpDatabase" selector="numberOfPreparedStatements">numberOfPreparedStatements	^preparedStatements numberOfElements.</body><body package="GlorpDatabase" selector="rowCount">rowCount	"GACK. Kind of assumes we know that we just prepared the last statement. And if the driver doesn't support it, just fake it. Very ugly. "	self platform supportsRowCount ifFalse: [^1].	^self driverSession rowCount.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase" selector="beginTransaction">beginTransaction	self log: 'Begin Transaction'.	self logOnly ifTrue: [^self].	connection begin</body><body package="GlorpDatabase" selector="commitTransaction">commitTransaction	self log: 'Commit Transaction'.	self logOnly ifTrue: [^self].	connection commit</body><body package="GlorpDatabase" selector="isInTransaction">isInTransaction	^connection inTransactionMode</body><body package="GlorpDatabase" selector="rollbackTransaction">rollbackTransaction	self log: 'Rollback Transaction'.	self logOnly ifTrue: [^self].	connection rollback</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="basicExecuteSQLString:">basicExecuteSQLString: aString	^self basicExecuteSQLString: aString binding: nil.</body><body package="GlorpDatabase" selector="basicExecuteSQLString:binding:">basicExecuteSQLString: aString binding: aBindingArray 	^self basicExecuteSQLString: aString returnResult: true binding: aBindingArray doing: [].</body><body package="GlorpDatabase" selector="basicExecuteSQLString:returnResult:binding:doing:">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	"Duplicate some of the logic of command execution, primarily because of the need to do special treatment depending if we want a result or not, and to execute the block. Put the statement into the driverSesssion (ugh) so that we can check the rowCount if necessary"	| answerStream command statement session |	answerStream := nil.	command := SQLStringCommand new.	command setSQLString: aString.	command parameters: aBindingArray.	(aBindingArray isNil or: [aBindingArray class ~= Association and: [aBindingArray isEmpty]]) ifTrue: [command useBinding: false].	statement := self preparedStatementFor: command.	session := statement statement.	driverSession := session.	command useBinding ifTrue: [		session bindInput: aBindingArray].	session execute.	"Always do this, because at least with ODBC, if we don't ask for the answer, we don't get errors, and subsequent statements get them"	answerStream := session answer.	answerStream == #noAnswerStream ifTrue: [answerStream := ReadStream on: #()].	answerStream == #noMoreAnswers ifTrue: [answerStream := ReadStream on: #()].	aBlock value.	returnResult 		ifTrue: [ | cursor |			cursor := self cursorFor: answerStream command: command.			cursor statement: statement.			^cursor]		ifFalse: [session disconnect].</body><body package="GlorpDatabase" selector="basicExecuteSQLStringNoResult:doing:">basicExecuteSQLStringNoResult: aString doing: aBlock	^self basicExecuteSQLString: aString returnResult: false binding: nil doing: aBlock.</body><body package="GlorpDatabase" selector="disconnect">disconnect	self reset.	^connection disconnect</body><body package="GlorpDatabase" selector="errorsToCatch">errorsToCatch	^self class errorsToCatch.</body><body package="GlorpDatabase" selector="executeCommand:inDBSession:">executeCommand: aCommand inDBSession: aSession	"Execute the command, given a database session which has already been prepared for this command"	| answerStream cursor |	aSession execute.	answerStream := aSession answer.	aCommand needsRowCount		ifTrue:			[aCommand				rowCount:					(self platform supportsRowCount						ifTrue: [aSession rowCount]						ifFalse: [1])].	cursor := self cursorFor: answerStream command: aCommand.	cursor statement: (GlorpPreparedStatement new statement: aSession).	^cursor.</body><body package="GlorpDatabase" selector="executeCommandBound:">executeCommandBound: aCommand	| statement cursor time block |	self logCommand: aCommand bound: true.	self logOnly ifTrue: [^self].	block := [		statement := self statementFor: aCommand.		statement statement bindInput: aCommand bindings.		cursor := self executeCommand: aCommand inDBSession: statement statement.		cursor statement: statement].	time := Time millisecondsToRun: block.	self logTime: time.	^cursor.</body><body package="GlorpDatabase" selector="executeCommandUnbound:">executeCommandUnbound: aCommand	| statement cursor block time |	self logCommand: aCommand bound: false.	self logOnly ifTrue: [^self].	block := [		statement := self statementFor: aCommand.		cursor := self executeCommand: aCommand inDBSession: statement statement.		cursor statement: statement].	time := Time millisecondsToRun: block.	self logTime: time.	^cursor.</body><body package="GlorpDatabase" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	^connection class externalDatabaseErrorSignal.</body><body package="GlorpDatabase" selector="innerExceptionFor:">innerExceptionFor: exception	(exception parameter isKindOf: GenericException) ifTrue: [^exception parameter].	^exception.</body><body package="GlorpDatabase" selector="newPreparedStatementFor:">newPreparedStatementFor: aCommand	| newSession |	newSession := self createSessionFor: aCommand.	aCommand useBinding		ifTrue: [newSession prepare: aCommand sqlString]		ifFalse: [newSession prepareWithoutBinding: aCommand sqlString].	^(GlorpPreparedStatement new)		signature: aCommand signature;		statement: newSession;		busy: true.</body><body package="GlorpDatabase" selector="preparedStatementFor:">preparedStatementFor: aCommand	| wasMarkedBusyForUs statement |	wasMarkedBusyForUs := false.	statement := preparedStatements		lookupClass: GlorpPreparedStatement		key: aCommand signature		ifAbsentPut:			[wasMarkedBusyForUs := true.			self newPreparedStatementFor: aCommand].	(wasMarkedBusyForUs not and: [statement busy])		ifTrue: [statement := self newPreparedStatementFor: aCommand].	^statement.</body><body package="GlorpDatabase" selector="statementFor:">statementFor: aCommand	^self reusePreparedStatements		ifTrue: [self preparedStatementFor: aCommand]		ifFalse: [self newPreparedStatementFor: aCommand].</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="connectionClassForLogin:">connectionClassForLogin: aLogin 	^aLogin database vwConnectionClass</body><body package="GlorpDatabase" selector="isLoggedIn">isLoggedIn	connection isNil ifTrue: [^false].	^connection isConnected</body><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock	"If the Login is secure, call the connection in its equivalent pattern (#connect:), otherwise set its password and call via #connect."	self log: 'Login'.	self logOnly ifTrue: [^self].	connection := self connectionClass new.	connection initializeFromLogin: currentLogin.	(connection respondsTo: #useStatementCaching:) ifTrue:		[connection supportStatementCaching ifTrue:			[connection useStatementCaching: true]].	self		execute:			[self currentLogin secure				ifTrue: [connection connect: currentLogin password]				ifFalse: [connection connect]]		ifError: aBlock.	self log: 'Login finished'.</body><body package="GlorpDatabase" selector="logout">logout	self isLoggedIn ifFalse: [^self].	self log: 'Logout'.	self logOnly ifTrue: [^self].	self execute: [connection disconnect. self reset] ifError: [:ex | ex return: nil].	self log: 'Logout finished'</body><body package="GlorpDatabase" selector="reLogin">reLogin	"Attempt to re-login to a database that's not responding. Give it a maximum of 5 attempts"	| attempts |	attempts := 0.	[attempts &lt; 5 and: [self isLoggedIn not]] whileTrue: [		attempts := attempts + 1.		self loginIfError: [:ex | nil]].</body><body package="GlorpDatabase" selector="showDialog:">showDialog: aString	(Smalltalk at: #Dialog) warn: aString.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>copying</category><body package="GlorpDatabase" selector="postCopy">postCopy	super postCopy.	self initializePreparedStatementCache.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>cursors</category><body package="GlorpDatabase" selector="cursorFor:">cursorFor: answerStream	answerStream == #noAnswerStream ifTrue: [^#() readStream].	answerStream == #noMoreAnswers ifTrue: [^#() readStream].	^ super cursorFor: answerStream</body><body package="GlorpDatabase" selector="cursorFor:command:">cursorFor: answerStream command: aCommand	| stream |	stream := answerStream.	answerStream == #noAnswerStream ifTrue: [		stream := #() readStream].	answerStream == #noMoreAnswers ifTrue: [		stream := #() readStream].	^ super cursorFor: stream command: aCommand</body><body package="GlorpDatabase" selector="releaseCursor:in:">releaseCursor: aCursor in: aPreparedStatement	"Release the cursor. We're trapping exceptions, so return true or false to indicate success/failure"	aCursor isNil ifTrue: [^self].	aPreparedStatement isNil ifTrue: [		 ^(aCursor class ~~ ReadStream) ifTrue: [self halt] ifFalse: [self]].	[aPreparedStatement statement isNil or: [aPreparedStatement statement answer == #noMoreAnswers]] whileFalse.	^[aCursor close. true] on: Dialect error do: [:ex | ex return: false].</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>initialize-release</category><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	reusePreparedStatements := true.	self initializePreparedStatementCache.</body><body package="GlorpCore" selector="initializePreparedStatementCache">initializePreparedStatementCache	| policy cache |	policy := CachePolicy default.	policy numberOfElements: 20.	policy expiryAction: #notifyAndRemove.	preparedStatements := CacheManager new.	cache := preparedStatements cacheForClass:GlorpPreparedStatement.	cache cachePolicy: policy.</body><body package="GlorpDatabase" selector="reset">reset	super reset.		preparedStatements release.	self initializePreparedStatementCache.	driverSession := nil.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor class</class-id> <category>exception handling</category><body package="GlorpDatabase" selector="errorsToCatch">errorsToCatch	| pgError |	pgError := Smalltalk at: #PostgreSQLEXDIException ifAbsent: [^Error].	^Error, pgError.</body></methods><methods><class-id>Glorp.TimedProxy</class-id> <category>accessing</category><body package="GlorpQueries" selector="class">class	^TimedProxy.</body><body package="GlorpQueries" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	self glorpTouch.	^super doesNotUnderstand: aMessage</body><body package="GlorpQueries" selector="glorpAssociation">glorpAssociation	^association</body><body package="GlorpQueries" selector="glorpAssociation:">glorpAssociation: anAssociation	association := anAssociation</body><body package="GlorpQueries" selector="glorpId">glorpId	^id</body><body package="GlorpQueries" selector="glorpId:">glorpId: uniqueInteger	id := uniqueInteger</body><body package="GlorpQueries" selector="glorpReaper:">glorpReaper: aTimedProxyReaper	reaper := aTimedProxyReaper</body><body package="GlorpQueries" selector="glorpSecondsToLive">glorpSecondsToLive	"Answer the number of seconds the receiver should live after having been instantiated or sent a message."	^secondsToLive</body><body package="GlorpQueries" selector="glorpSecondsToLive:">glorpSecondsToLive: seconds	secondsToLive := seconds.	self updateExpiryTime.	reaper notNil ifTrue: [self glorpTouch]</body><body package="GlorpQueries" selector="glorpTimeToDie">glorpTimeToDie	"Answer the time at which the receiver is scheduled to die."	^timeToDie</body><body package="GlorpQueries" selector="glorpTouch">glorpTouch	self updateExpiryTime.	reaper isNil ifFalse: [reaper touch: self].</body><body package="GlorpQueries" selector="proxyInitialize">proxyInitialize	super proxyInitialize.	secondsToLive := 30.	self updateExpiryTime.</body><body package="GlorpQueries" selector="uninstantiate">uninstantiate	super uninstantiate.	association := nil.</body><body package="GlorpQueries" selector="updateExpiryTime">updateExpiryTime	timeToDie := Time millisecondClockValue + (secondsToLive * 1000).</body></methods><methods><class-id>Glorp.JoinBaseExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^target.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="basicExecuteSQLString:">basicExecuteSQLString: aString	^self basicExecuteSQLString: aString binding: nil</body><body package="GlorpDatabase" selector="executeCommandUnbound:">executeCommandUnbound: aCommand	| answerStream |	self log: aCommand sqlString.	"change to self logCommand: aCommand sqlString bound: false." 	self logOnly ifTrue: [^self].	answerStream := self basicExecuteSQLStringWithResult: aCommand sqlString doing: [].	aCommand needsRowCount		ifTrue:			[aCommand				rowCount:					(self platform supportsRowCount						ifTrue: [answerStream rowCount]						ifFalse: [1])].	^self cursorFor: answerStream command: aCommand.</body><body package="GlorpDatabase" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	^self class externalDatabaseErrorSignal.</body><body package="GlorpDatabase" selector="innerExceptionFor:">innerExceptionFor: exception	^exception exception.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase" selector="returnRowCount:">returnRowCount: aBoolean	connection isNil ifFalse: [connection queryRowCount: true].</body><body package="GlorpDatabase" selector="rowCount">rowCount	^connection rowCount.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase" selector="beginTransaction">beginTransaction	self log: 'Begin Transaction'.	isInTransaction := true.	self logOnly ifTrue: [^self].	self connection beginUnitOfWork.</body><body package="GlorpDatabase" selector="commitTransaction">commitTransaction	self log: 'Commit Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	self connection commitUnitOfWorkIfError: 			[:err |			self log: 'Commit Transaction failed.'. 			self connection autoCommit: true.			self todo: 'Need to handle this error somehow....'.			"errorBlock value: err"].</body><body package="GlorpDatabase" selector="isInTransaction">isInTransaction	^isInTransaction</body><body package="GlorpDatabase" selector="rollbackTransaction">rollbackTransaction	self log: 'Rollback Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	self connection rollbackUnitOfWork.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="connectionClassForLogin:">connectionClassForLogin: aLogin 	aLogin database isDB2Platform ifTrue: [^ Smalltalk at: #AbtIbmCliDatabaseManager].	aLogin database class == OraclePlatform 		ifTrue: [^Smalltalk at: #AbtOracle10DatabaseManager].	aLogin database isODBCPlatform 		ifTrue: [^Smalltalk at: #AbtOdbcDatabaseManager].	aLogin database isPostgreSQLPlatform 		ifTrue: [self error: 'PostgreSQL is not yet supported under VA'].	self error: 'Unknown database platform' , aLogin database printString</body><body package="GlorpDatabase" selector="isLoggedIn">isLoggedIn	^connection notNil</body><body package="GlorpDatabase" selector="logStream">logStream	^Transcript</body><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock 	"		This method creates a NEW database connection.	"	| dbMgrClass anAbtDatabaseLogonSpec anAbtDatabaseConnectionSpec aliasNameString baseAliasName |	self log: 'Login'.	self logOnly ifTrue: [^self].	aliasNameString := baseAliasName := currentLogin connectString.	"		We try to generate a unique alias name to get a new connection and to 		prevent the normal VAST behaviour to reuse a connection	"		[((Smalltalk at: #AbtDbmSystem) 		activeDatabaseConnectionWithAlias: aliasNameString) notNil] 			whileTrue: 				[aliasNameString := baseAliasName , Time millisecondClockValue printString].	"		Get the native VA class responsible for doing the work against the		three special connections available in VA	"	dbMgrClass := self connectionClass.	"		Get the logon specification for the database ... do not use		any server information	"	anAbtDatabaseLogonSpec := (Smalltalk at: #AbtDatabaseLogonSpec) 				id: currentLogin username				password: currentLogin password				server: self serverName.	"			Get the specification for the connection ...    "	anAbtDatabaseConnectionSpec := (Smalltalk at: #AbtDatabaseConnectionSpec) 				forDbmClass: dbMgrClass				dataSourceName: self databaseName.	connection := anAbtDatabaseConnectionSpec 				connectUsingAlias: aliasNameString				logonSpec: anAbtDatabaseLogonSpec				ifError: 					[:error | 					"throw away the connection ..."					connection := nil.					aBlock value: error].	connection isNil ifFalse: [		connection databaseMgr errorBlock: [:err | self externalDatabaseErrorSignal signalWith: err]].</body><body package="GlorpDatabase" selector="logout">logout	self isLoggedIn ifFalse: [^self].	self log: 'Logout'.	self logOnly ifTrue: [^self].	"disconnectIfError: doesn't properly catch errors."	[	[connection disconnectIfError: [:ex | self logError: ex]]		ensure:	[connection := nil]]		  on: Dialect error		  do: [:ex | ex return: nil].	self log: 'Logout finished'</body><body package="GlorpDatabase" selector="showDialog:">showDialog: aString	(Smalltalk at: #CwMessagePrompter) warn: aString.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>As yet unclassified</category><body package="GlorpDatabase" selector="basicExecuteSQLString:binding:">basicExecuteSQLString: aString binding: aBindingArray	"VA does not return results for as many statements as VW.  Some calls that take returnResult: true in VWdo not want to return a result in the basic VA RDB framework that we call.  We therefore check the String andonly ask for a return if it is a select statement.  (This is experimental and could be reviewed.)"	^self		basicExecuteSQLString: aString		returnResult: (aString copyFrom: 1 to: (6 min: aString size)) asUppercase = 'SELECT'		binding: aBindingArray		doing: []</body><body package="GlorpDatabase" selector="basicExecuteSQLString:returnResult:binding:doing:">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	"^&lt;GlorpCursoredStream | empty readStream&gt; This method executes a general SQL command against the connection.If a result is requested, it returns a GlorpCursoredStream wrapping an AbtResultTable that (should) hold an AbtCursor.  Ifnot, it returns self to cursorFor: which returns an empty readStream since along one calling route VA does not provide aresult if the string is not a select whereas VW does in general, and the caller sends upToEnd.	Later, develop to use GlorpPreparedStatements (c.f. this method in VW) and resultTableFromQuerySpec:withValues:...VW creates an SQLStringCommand to put in the cursor."	^self cursorFor:  (returnResult		"was check if aString was SELECT statement, now moved to a caller"		ifFalse:			[connection				executeSQLStatement: aString				ifError: [:err | GlorpError signalWith: err].			aBlock value.			self]					"must return self to be handled in cursorFor:"		ifTrue:			[self basicExecuteSQLStringWithResult: aString doing: aBlock])</body><body package="GlorpDatabase" selector="basicExecuteSQLStringNoResult:doing:">basicExecuteSQLStringNoResult: aString doing: aBlock	^self basicExecuteSQLString: aString returnResult: false binding: nil doing: aBlock.</body><body package="GlorpDatabase" selector="basicExecuteSQLStringWithResult:doing:">basicExecuteSQLStringWithResult: aString doing: aBlock	"^&lt;AbtResultTable | self&gt; This VA-specific method returns an AbtResultTable unless it fails.  Later,add a binding: parameter and call resultTableFromQuerySpec:withValues:ifError:"	| resultTable |	resultTable := connection		resultTableFromQuerySpec: ((Smalltalk at: #AbtQuerySpec) new statement: aString)		ifError: [:err | GlorpError signalWith: err].	^resultTable isAbtError		ifTrue: 			[GlorpError signalWith: resultTable.			#() readStream]		ifFalse:			[aBlock value.			resultTable]</body><body package="GlorpDatabase" selector="databaseName">databaseName	"connect string looks like  hostname:portNumber_db-name. :portNumber is optional.	If the string is zero, return nil."	| str dbIndex |	str := self currentLogin connectString.	dbIndex := str indexOf: $_.	^str copyFrom: dbIndex + 1 to: str size</body><body package="GlorpDatabase" selector="serverName">serverName	"connect string looks like  hostname:portNumber_db-name. The :portNumber is optional;	for the moment, we ignore it.  If the hostName is empty, return nil."	| str dbIndex "portIndex index" |	str := self currentLogin connectString."	portIndex := index := str indexOf: $:."	dbIndex := str indexOf: $_."	index = 0 ifTrue: [index := dbIndex]."	^dbIndex = 0 ifFalse: [str copyFrom: 1 to: dbIndex - 1]</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>initialize</category><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	isInTransaction := false.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>development</category><body package="GlorpDatabase" selector="todo:">todo: aString	^self</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>cursors</category><body package="GlorpDatabase" selector="cursorFor:">cursorFor: aStream	"basicExecuteSQLString: binding: sets returnResult: to false if aString does not begin with 'SELECT' butits non-VA-specific caller executeSQLString:binding: sends upToEnd to what it returns, expecting the moreusual behaviour of returnResult always being true on that branch.  Thu we return an empty readStream, likethe VW implementation of this method in other no-return cases."	aStream == self ifTrue: [^#() readStream].	aStream onFinalizeDo: #close.	"In V8Beta, the finalize cycle has not always been run by the time the database' databaseMgr has been nilled,	causing a DNU when trying to get the error block (that it will not run).  If this persists, replace #close above with		Message selector: #closeIfError: arguments: (Array with: aStream errorBlock)	so we get the block when we know we can."	^super cursorFor: aStream.</body><body package="GlorpDatabase" selector="isCursorAtEnd:">isCursorAtEnd: aCursor	"Return true if aCursor is at its end."	^aCursor actuallyAtEnd.</body><body package="GlorpDatabase" selector="releaseCursor:in:">releaseCursor: aCursor in: aPreparedStatement	aCursor close.</body></methods><methods><class-id>Glorp.VADatabaseAccessor class</class-id> <category>initialization</category><body package="GlorpDatabase" selector="initializeDatabaseErrorSignal">initializeDatabaseErrorSignal	databaseErrorSignal := ((Smalltalk at: #SystemExceptions) at: 'ExError') newChild.	databaseErrorSignal markReadOnly: false;		description: 'Database error';		resumable: true;		defaultHandler: nil;		markReadOnly: true</body></methods><methods><class-id>Glorp.VADatabaseAccessor class</class-id> <category>accessing</category><body package="GlorpDatabase" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	databaseErrorSignal isNil ifTrue: [self initializeDatabaseErrorSignal ].	^databaseErrorSignal</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries" selector="asText">asText	^self basicPrintString asText.</body><body package="GlorpQueries" selector="basicPrintString">basicPrintString	^self printString.</body><body package="GlorpQueries" selector="class">class	^MessageArchiver</body><body package="GlorpQueries" selector="halt">halt	"Support this so that we can debug inside query blocks. For portability, send it to a different object so that we don't have to care how halt is implemented"	(Array with: self) halt.</body><body package="GlorpQueries" selector="inspect">inspect	"Not exactly the intended semantics, but should be portable"	(Array with: self) inspect.</body><body package="GlorpQueries" selector="inspectorSize">inspectorSize  ^2</body><body package="GlorpQueries" selector="mustBeBoolean">mustBeBoolean	nil error: 'mustBeBoolean - this probably indicates you are trying to use an optimized message like and: or ifTrue: inside a Glorp expression block. Use AND: or &amp; instead.'</body><body package="GlorpQueries" selector="printOn:">printOn: aStream	aStream nextPutAll: self printString.</body><body package="GlorpQueries" selector="printString">printString	"Hard-code this for maximum dialect portability"	^'a MessageArchiver'.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>expression creation</category><body package="GlorpQueries" selector="asGlorpExpression">asGlorpExpression	^self asGlorpExpressionOn: BaseExpression new</body><body package="GlorpQueries" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression 	| arguments |	myReceiver == nil ifTrue: [^query isNil ifTrue: [aBaseExpression] ifFalse: [query baseExpression]].	arguments := myArguments collect: [:each | each asGlorpExpressionOn: aBaseExpression].	^self sendMessageTo: (myReceiver asGlorpExpressionOn: aBaseExpression) withArguments: arguments.</body><body package="GlorpQueries" selector="asGlorpExpressionOn:basedOn:withUltimateBase:">asGlorpExpressionOn: aBaseExpression basedOn: aMessageArchiver withUltimateBase: ultimateBaseExpression	"We know we are built from aMessageArchiver, but parts of us may refer to an outer scope. Those parts should be built on ultimateBaseExpression rather than aBaseExpression. e.g. consider  [:each | each amount amount = ((Query readManyOf: GlorpBankTransaction			where: [:eachTrans | eachTrans owner = each owner]) 				retrieve: [:eachTrans | eachTrans amount amount max])]."	| arguments |	self == aMessageArchiver ifTrue: [^aBaseExpression].	myReceiver == nil ifTrue: [^query isNil ifTrue: [ultimateBaseExpression] ifFalse: [query baseExpression]].	arguments := myArguments		collect:			[:each | 			each				asGlorpExpressionOn: aBaseExpression				basedOn: aMessageArchiver				withUltimateBase: ultimateBaseExpression].	^self 		sendMessageTo: (myReceiver			asGlorpExpressionOn: aBaseExpression			basedOn: aMessageArchiver			withUltimateBase: ultimateBaseExpression)		withArguments: arguments.</body><body package="GlorpQueries" selector="sendMessageTo:withArguments:">sendMessageTo: anExpression withArguments: arguments	"Build our node by sending our message to anExpression"	^anExpression get: mySelector withArguments: arguments.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>doesNotUnderstand</category><body package="GlorpQueries" selector="=">= anObject	"Needed because VA's abtObservableWrapper implements =. Should be portable."	^MessageArchiver 		receiver: self		selector: #= 		arguments: (Array with: anObject).</body><body package="GlorpQueries" selector="basicDoesNotUnderstand:">basicDoesNotUnderstand: aMessage 	"Invoke this to avoid infinite recursion in the case of internal errors. We want a dialect-independent way of getting a walkback window, so we'll invoke it against a different object"	(Array with: self) doesNotUnderstand: aMessage.</body><body package="GlorpQueries" selector="basicDoesNotUnderstand:args:">basicDoesNotUnderstand: sel args: args 	"Invoke this to avoid infinite recursion in the case of internal errors. We want a dialect-independent way of getting a walkback window, so we'll invoke it against a different object"	(Array with: self) doesNotUnderstand: sel args: args.</body><body package="GlorpQueries" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	| sel |	sel := aMessage selector.	sel == #doesNotUnderstand: ifTrue: [self basicDoesNotUnderstand: aMessage].	(sel size &gt;= 8 and: [(sel copyFrom: 1 to: 8) = 'perform:']) 		ifTrue: 			[^self get: aMessage arguments first				withArguments: (aMessage arguments copyFrom: 2 to: aMessage arguments size)].	^self get: sel withArguments: aMessage arguments.</body><body package="GlorpQueries" selector="doesNotUnderstand:args:">doesNotUnderstand: sel args: args 	"This is the variant for ObjectStudio"	sel == #doesNotUnderstand: ifTrue: [self basicDoesNotUnderstand: sel args: args].	(sel size &gt;= 8 and: [(sel copyFrom: 1 to: 8) = 'perform:']) 		ifTrue: 			[^self get: args first				withArguments: (args copyFrom: 2 to: args size)].	^self get: sel withArguments: args.</body><body package="GlorpQueries" selector="os_Equal:">os_Equal: anObject	^self = anObject</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>private/accessing</category><body package="GlorpQueries" selector="privateGlorpQuery">privateGlorpQuery	^query.</body><body package="GlorpQueries" selector="privateGlorpQuery:">privateGlorpQuery: aQuery	query := aQuery.</body><body package="GlorpQueries" selector="privateGlorpReceiver">privateGlorpReceiver	^myReceiver</body><body package="GlorpQueries" selector="privateGlorpSelector">privateGlorpSelector	^mySelector</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>testing</category><body package="GlorpQueries" selector="glorpIsBlock">glorpIsBlock	^false.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>initialize</category><body package="GlorpQueries" selector="receiver:selector:arguments:">receiver: aMessageCollector selector: aSymbol arguments: aCollection	myReceiver := aMessageCollector.	mySelector := aSymbol.	myArguments := aCollection.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>expression protocol</category><body package="GlorpQueries" selector="get:">get: aSymbol 	^MessageArchiver receiver: self		selector: aSymbol		arguments: #().</body><body package="GlorpQueries" selector="get:withArguments:">get: aSymbol withArguments: anArray 	| arguments |	arguments := anArray collect: [:each | each glorpIsBlock 		ifTrue: [(Dialect argumentCountFor: each) = 1			ifTrue: [each value: self]			ifFalse: [each value]]		ifFalse: [each]].	^MessageArchiver receiver: self		selector: aSymbol		arguments: arguments.</body><body package="GlorpQueries" selector="getMapping:named:">getMapping: aMapping named: aString	"In this case, the name may actually be a string rather than a symbol."	^MessageArchiverForGetMapping		receiver: self		selector: aString		arguments: (Array with: aMapping with: aString).</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>As yet unclassified</category><body package="GlorpQueries" selector="inspectorClasses">inspectorClasses	^Array with: (Dialect smalltalkAt: 'Tools.Trippy.BasicInspector')</body></methods><methods><class-id>Glorp.MessageArchiver class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="receiver:selector:arguments:">receiver: aMessageCollector selector: aSymbol arguments: aCollection	^self new		receiver: aMessageCollector		selector: aSymbol		arguments: aCollection.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canBeUsedForRetrieve">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^self mapping canBeUsedForRetrieve.</body><body package="GlorpExpressions" selector="canKnit">canKnit	"Return true if, when building objects, we can knit the object corresponding to this expression to a related object. Roughly speaking, is this a mapping expression"	^true.</body><body package="GlorpExpressions" selector="canPrint">canPrint	"Return true if we can print into a where clause"	^self hasField.</body><body package="GlorpExpressions" selector="hasImpliedClauses">hasImpliedClauses	^self mapping notNil and: [self mapping hasImpliedClauses].</body><body package="GlorpExpressions" selector="mapsSimpleObject">mapsSimpleObject	^self mapping mapsSimpleObject.</body><body package="GlorpExpressions" selector="representsDerivedObject">representsDerivedObject	^self mapping isRelationship.</body><body package="GlorpExpressions" selector="returnsDictionary">returnsDictionary	"Return true if we representa  ampping to a dictionary"	^self mapping isToManyRelationship and: [self mapping collectionType == Dictionary].</body><body package="GlorpExpressions" selector="willPrintAsWhereClause">willPrintAsWhereClause	^self hasField.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="additionalExpressions">additionalExpressions	^self additionalExpressionsOn: self.</body><body package="GlorpExpressions" selector="additionalExpressionsOn:">additionalExpressionsOn: anExpression	"We can get hijacked, so pass in the expression to use rather than just using self"	| exp |	self mapping isNil ifTrue: [^#()].	exp := self mapping joinExpressionFor: anExpression.	outerJoin ifTrue: [exp beOuterJoin].	^(self multipleTableExpressionsOn: anExpression), (exp isNil ifTrue: [#()] ifFalse: [Array with: exp]).</body><body package="GlorpExpressions" selector="allControlledTables">allControlledTables	"Return all the tables that we control, directly or indirectly. Basically, if we are a mapping expression with a link table, return the link table as well as any tables of ours."	| all join |	self controlsTables ifFalse: [^#()].	all := Set new.	all addAll: self tables.	mapping := self mapping.	mapping isNil 		ifFalse: [			join := mapping join.			join isNil ifFalse: [all addAll: join allControlledTables]].	^all.</body><body package="GlorpExpressions" selector="allRelationsFor:do:andBetweenDo:">allRelationsFor: rootExpression do: aBlock andBetweenDo: anotherBlock	"We might have multiple clauses to print, depending on our mapping"	self mapping 		allRelationsFor: rootExpression		do: aBlock		andBetweenDo: anotherBlock.</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newBase |	newBase := base asExpressionJoiningSource: source toTarget: target.	^newBase getMapping: self mapping named: name.</body><body package="GlorpExpressions" selector="fieldsForSelectStatement">fieldsForSelectStatement		^self mapping fieldsForSelectStatement.</body><body package="GlorpExpressions" selector="mustReGetMappingIfRebuildingOn:">mustReGetMappingIfRebuildingOn: newBase	"Return true if we need to do a full get: when rebuilding, rather than being able to preserve the mapping that we had before."	"If we didn't have a mapping yet, then just do a get"	mapping isNil ifTrue: [^true].	"If this is a phantom mapping, we must not try to re-get it."	self phantom ifTrue: [^false].	"Otherwise, we're a normal mapping, and we don't need to re-get the mapping unless the class is different, probably because of inheritance. But note that in some cases we may not know our descriptor yet."	self base hasDescriptor ifFalse: [^false].	self base descriptor isNil ifTrue: [^false].	^self base descriptor ~= newBase descriptor.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression		| expression newBase |	self == anExpression ifTrue: [^aBaseExpression].	newBase := base rebuildOn: aBaseExpression startingFrom: anExpression		withOuterScopeBase: ultimateBaseExpression.		"For phantom mappings we have to pass through our mapping since they can't compute their own. For the normal case, if we have a mapping, and our base class hasn't changed, then just re-use the same mapping as an optimization."	expression := (mapping isNil or: [self mustReGetMappingIfRebuildingOn: newBase])		ifTrue: [newBase get: name]		ifFalse: [newBase getMapping: self mapping named: name].	outerJoin ifTrue: [expression asOuterJoin].	expression phantom: self phantom.	^expression.</body><body package="GlorpExpressions" selector="rewriteBooleanEquality:">rewriteBooleanEquality: relation	"If we are a boolean that doesn't have a comparison relation on top of us, replace us with an ' = true'"	"Only rewrite booleans"	(self mapping notNil and: [self mapping attribute type = Boolean]) ifFalse: [^self].	"See if we're already part of an equality comparison, don't rewrite twice"	(relation = #= | (relation = #&lt;&gt;) | (relation = #IN)) ifTrue: [^self].	"If we're a boolean function, we don't need or want the comparison. e.g. EXISTS. This is a bit hard to test for."	(self mapping field isGlorpExpression and: [self mapping field field isNil]) ifTrue: [^self].	^self get: #= withArguments: (Array with: true asGlorpExpression).</body><body package="GlorpExpressions" selector="tablesToPrint">tablesToPrint	self hasDescriptor ifFalse: [^#()].	^self tables collect: [:each |		self aliasedTableFor: each].</body><body package="GlorpExpressions" selector="translateField:">translateField: aDatabaseField	| translatedField |	translatedField := (self mapping translateFields: (Array with: aDatabaseField)) first.	^super translateField: (translatedField isNil ifTrue: [aDatabaseField] ifFalse: [translatedField]).</body><body package="GlorpExpressions" selector="translateFields:">translateFields: anOrderedCollection 	"Ugh. Unify these mechnisms"	^super translateFields: (self mapping translateFields: anOrderedCollection).</body><body package="GlorpExpressions" selector="validate">validate	self mappingFromMeOrSubclasses isNil ifTrue: [self error: 'no mapping for ', self printString].</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="allSourceFields">allSourceFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the source fields as the parameters that this expression takes, and specifically the parameters that are based on fields."	^self inject: OrderedCollection new into: [:sum :each |		each addToTargetFields: sum.		sum].</body><body package="GlorpExpressions" selector="allTargetFields">allTargetFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the target fields as being the source fields of the bottom-most mapping. That is, the fields we'll use to connect to the thing we want are the things that our expression's base (which represents the thing we want) would use to connect to the first level mapping arising from it."	^self penultimateBaseExpression join allSourceFields.</body><body package="GlorpExpressions" selector="bePhantom">bePhantom	phantom := true.</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions" selector="descriptor">descriptor	| system theMapping |	system := self system.	system isNil ifTrue: [^nil].	theMapping := self mappingFromMeOrSubclasses.	theMapping isNil ifTrue: [^nil].	^system descriptorFor: theMapping referenceClass.</body><body package="GlorpExpressions" selector="field">field	self mapping isNil ifTrue: [self error: '"', name, '" is not a mapped property name in ', base descriptor describedClass name].	self hasDescriptor ifTrue: [		"If we have a descriptor, then either we're a mapping to a full object, in which case we can't answer this properly, or we're a direct to-many mapping, in which case we can."		self mapping mapsSimpleObject			ifTrue: [^self translateField: self mapping field]			ifFalse: [self error: '"',name, 				'" is not an attribute that resolves to a field in the mapped tables for ', 					base descriptor describedClass name]].	^base translateField: self mapping field.</body><body package="GlorpExpressions" selector="fieldFromMeOrSubclasses">fieldFromMeOrSubclasses	"Return the field for this mapping, but if the field is not mapped here, and the class uses inheritance, check for subclasses, and use a random one of the subclass mappings."	| subMapping |	subMapping := self mappingFromMeOrSubclasses.	^subMapping isNil ifTrue: [self field] ifFalse: [subMapping field].</body><body package="GlorpExpressions" selector="hasDescriptor">hasDescriptor	"Does the object that we describe have its own descriptor"	| myMapping |	myMapping := self mapping.	^myMapping notNil and: [myMapping isRelationship]</body><body package="GlorpExpressions" selector="hasField">hasField	self mapping isNil ifTrue: [^false]."If we have a descriptor, then either we're a mapping to a full object, in which case we can't answer this properly, or we're a direct to-many mapping, in which case we can."	self hasDescriptor ifTrue: [		^self mapping mapsSimpleObject].	^true.</body><body package="GlorpExpressions" selector="join">join	self mapping isNil ifTrue: [^nil].	^self mapping join.</body><body package="GlorpExpressions" selector="mappedFields">mappedFields		self mapping isNil ifTrue: [^#()].	self mapping isRelationship ifTrue: [self error: '"',name, '" is not an attribute that resolves to a field in the mapped tables for ', base descriptor describedClass name].	^self mapping mappedFields collect: [:each | base translateField: each].</body><body package="GlorpExpressions" selector="mappingFromMeOrSubclasses">mappingFromMeOrSubclasses	"Return the mapping for me, but if the field is not mapped here, and the class uses inheritance, check for subclasses, and use a random one of the subclass mappings."	| subclassDescriptors |	self mapping isNil ifFalse: [^self mapping].	self sourceDescriptor isNil ifTrue: [^self mapping].	subclassDescriptors := (self sourceDescriptor typeResolver descriptorsRequiringIndependentQueriesFor: self sourceDescriptor describedClass).	subclassDescriptors do: [:each | 		| subMapping |		subMapping := each mappingForAttributeNamed: name.		subMapping isNil ifFalse: [^subMapping]].	"If subclasses didn't work, just fall through to the normal error processing."	^self mapping.</body><body package="GlorpExpressions" selector="multipleTableExpressions">multipleTableExpressions	^self multipleTableExpressionsOn: self.</body><body package="GlorpExpressions" selector="multipleTableExpressionsOn:">multipleTableExpressionsOn: anExpression	^self mapping multipleTableExpressionsFor: anExpression.</body><body package="GlorpExpressions" selector="name">name	^name.</body><body package="GlorpExpressions" selector="phantom">phantom	^phantom</body><body package="GlorpExpressions" selector="phantom:">phantom: aBoolean	phantom := aBoolean</body><body package="GlorpExpressions" selector="sourceDescriptor">sourceDescriptor	^base descriptor.</body><body package="GlorpExpressions" selector="system">system	^base system.</body><body package="GlorpExpressions" selector="table">table	self hasDescriptor ifTrue: [^self descriptor primaryTable].	^self field table.</body><body package="GlorpExpressions" selector="tables">tables	self controlsTables ifFalse: [^#()].	^self tablesContainingMe.</body><body package="GlorpExpressions" selector="tablesContainingMe">tablesContainingMe	"Return a list of tables that contain this object, whether or not we control them. This is mostly the same as tables, but will differ for embedded mappings."	| set |	self descriptor isNil ifTrue: [^#()].	set := self descriptor tables asSet.	^set.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>private/initialization</category><body package="GlorpExpressions" selector="mapping:">mapping: aMapping	mapping := aMapping.</body><body package="GlorpExpressions" selector="named:basedOn:">named: aSymbol basedOn: anExpression	name := aSymbol.	base := anExpression.	outerJoin := false.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="asOuterJoin">asOuterJoin	outerJoin := true.</body><body package="GlorpExpressions" selector="base">base	^base.</body><body package="GlorpExpressions" selector="isEmpty">isEmpty	"Only useful for mappings that represent collections. This checks to see if the collection has elements by building a not exists subselect."		^self base existenceCheck: self as: #notExists:</body><body package="GlorpExpressions" selector="notEmpty">notEmpty	"Only useful for mappings that represent collections. This checks to see if the collection has elements by building a not exists subselect."		^self base existenceCheck: self as: #exists:</body><body package="GlorpExpressions" selector="referenceClass">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^self mapping referenceClass.</body><body package="GlorpExpressions" selector="sqlSelect:">sqlSelect: anExpression	"Only useful for mappings that represent collections. This restricts the range of values in a variable. Most useful as part of an aggregation. e.g.     read: SomeClass where: [:each | (each collection select: [:eachItem | eachItem attribute = someValue]) sqlCount &gt; 10]"	"We may be passed an expression corresponding to either a field, or to a full object, depending on the aggregate function. In either case, build backwards from the first full object"	| objectExpression newMapping previousJoin |	objectExpression := self mapping isRelationship 		ifTrue: [self] ifFalse: [self base].	newMapping := self mapping class new.	newMapping attributeName: #temporaryAttributeFromSubselect.	newMapping referenceClass: self mapping referenceClass.	newMapping descriptor: self mapping descriptor.	newMapping linkFields: self mapping linkFields.	newMapping usesLinkTable: self mapping usesLinkTable.	previousJoin := self mapping join.	newMapping join: ((anExpression rebuildOn: previousJoin ultimateBaseExpression startingFrom: self) AND: previousJoin asGlorpExpression).	^objectExpression base getMapping: newMapping named: ( 'a temporary restricted mapping for #select: based on ', self mapping attributeName).</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="penultimateBaseExpression">penultimateBaseExpression	"Return the one from the last base expression in our tree. Useful if we want to find the first mapping involved in the expression"	self base base isNil ifTrue: [^self].	^self base penultimateBaseExpression.</body><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	aStream nextPutAll: name.	self printTableAliasesOn: aStream.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream		print: base;		nextPut: $.;		nextPutAll: (name isString ifTrue: [name] ifFalse: [name printString])</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>fields</category><body package="GlorpExpressions" selector="aliasedTableFor:">aliasedTableFor: aDatabaseTable 	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable]		ifFalse: [base aliasedTableFor: (self mapping translateTable: aDatabaseTable)]</body><body package="GlorpExpressions" selector="aliasedTableFor:ifAbsent:">aliasedTableFor: aDatabaseTable ifAbsent: aBlock	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable ifAbsent: aBlock]		ifFalse: [base aliasedTableFor: aDatabaseTable ifAbsent: aBlock]</body><body package="GlorpExpressions" selector="controlsTables">controlsTables	| theMapping |	theMapping := self mappingFromMeOrSubclasses.	theMapping isNil ifTrue: [^true].	^theMapping controlsTables</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary 	self hasField ifFalse: [^self].	self field asField printSelectSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary 	self hasField ifFalse: [^self].	self field asField printSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions" selector="printUnqualifiedSQLOn:withParameters:">printUnqualifiedSQLOn: aStream withParameters: aDictionary 	self field asField printUnqualifiedSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>converting</category><body package="GlorpExpressions" selector="convertedDbValueOf:">convertedDbValueOf: anObject	^self mapping convertedDbValueOf: anObject.</body><body package="GlorpExpressions" selector="convertedStValueOf:">convertedStValueOf: anObject	^self mapping convertedStValueOf: anObject.</body><body package="GlorpExpressions" selector="valueInBuilder:">valueInBuilder: anElementBuilder	^self valueInBuilder: anElementBuilder as: self base.</body><body package="GlorpExpressions" selector="valueInBuilder:as:">valueInBuilder: anElementBuilder as: anExpression	^self mapping valueIn: anElementBuilder as: anExpression.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>private/accessing</category><body package="GlorpExpressions" selector="requiresDistinct:">requiresDistinct: aBoolean	super requiresDistinct: aBoolean.	base requiresDistinct: aBoolean.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>internal</category><body package="GlorpExpressions" selector="allRelationsFor:">allRelationsFor: rootExpression	^self mapping allRelationsFor: rootExpression.</body><body package="GlorpExpressions" selector="mapping">mapping	mapping isNil ifTrue: [		| descriptor |		descriptor := self sourceDescriptor.		descriptor isNil ifTrue: [^nil].		mapping := descriptor mappingForAttributeNamed: name].	^mapping.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree"	| myField |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.	(self hasField and: [(myField := self field) isGlorpExpression])		ifTrue: [myField do: aBlock skipping: aSet].</body><body package="GlorpExpressions" selector="mappableFieldsDo:">mappableFieldsDo: aBlock	"Used when we are emulating a Join"	self allSourceFields with: self allTargetFields do: [:source :target |		source isMappable ifTrue: [aBlock value: source value: target]].</body><body package="GlorpExpressions" selector="mappableSourceFieldsDo:">mappableSourceFieldsDo: aBlock	"Used when we are emulating a Join"	self allSourceFields do: [:source |		source isMappable ifTrue: [aBlock value: source]].</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>initialize</category><body package="GlorpExpressions" selector="initialize">initialize	super initialize.	phantom := false.</body></methods><methods><class-id>Glorp.MappingExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="named:basedOn:">named: aSymbol basedOn: anExpression	^self new		named: aSymbol		basedOn: anExpression.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="boolean">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'boolean'].</body><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'clob'].</body><body package="GlorpDatabase" selector="date">date	^self typeNamed: #date ifAbsentPut: [GlorpDateType new].</body><body package="GlorpDatabase" selector="double">double	^self float8</body><body package="GlorpDatabase" selector="float">float	^self float4.</body><body package="GlorpDatabase" selector="float4">float4	^self typeNamed: #float4 ifAbsentPut: [GlorpFloatType new typeString: 'float'].</body><body package="GlorpDatabase" selector="float8">float8	^self typeNamed: #float8 ifAbsentPut: [GlorpDoubleType new typeString: 'double precision'].</body><body package="GlorpDatabase" selector="int2">int2	^self smallint.</body><body package="GlorpDatabase" selector="int4">int4	^self integer.</body><body package="GlorpDatabase" selector="int8">int8	^self integer</body><body package="GlorpDatabase" selector="numeric">numeric	^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase" selector="sequence">sequence	^self inMemorySequence</body><body package="GlorpDatabase" selector="serial">serial	^self sequence</body><body package="GlorpDatabase" selector="text">text	^self clob.</body><body package="GlorpDatabase" selector="time">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time'].</body><body package="GlorpDatabase" selector="timestamp">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'timestamp'].</body><body package="GlorpDatabase" selector="varchar">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new].</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated^false</body><body package="GlorpDatabase" selector="primaryKeysAreAutomaticallyUnique">primaryKeysAreAutomaticallyUnique	^true.</body><body package="GlorpDatabase" selector="sqlTextForNULLAttributeConstraint">sqlTextForNULLAttributeConstraint	"^&lt;String&gt;"	^''</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	"I'm guessing here"	^true.</body><body package="GlorpDatabase" selector="usesNullForEmptyStrings">usesNullForEmptyStrings	"Return true if this database is likely to use nil as an empty string value"	^false.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="isOcelotPlatform">isOcelotPlatform	^true</body><body package="GlorpDatabase" selector="isODBCPlatform">isODBCPlatform	^true</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	^false.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="paddingCharacter">paddingCharacter	^32 asCharacter.</body><body package="GlorpDatabase" selector="padString:for:">padString: aString for: aType 	| padding |	aString isNil ifTrue: [^nil].	(self usesNullForEmptyStrings and: [aString isEmpty]) ifTrue: [^nil].	aString size &gt; aType width 				ifTrue: [^aString copyFrom: 1 to: aType width].					aType isVariableWidth ifTrue: [^aString].	padding := String new: aType width - aString size.	padding atAllPut: 32 asCharacter.	^aString , padding</body><body package="GlorpDatabase" selector="unpadString:for:">unpadString: aString for: aType	aString isNil ifTrue: [^nil].	^aType isVariableWidth 		ifTrue: [aString]		ifFalse: [(ReadStream on: aString) upTo: 32 asCharacter].</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>conversion times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDate for: aType	| stream |	aDate isNil ifTrue: [^nil].	stream := WriteStream on: String new.	stream nextPutAll: 'date '''.	self		printDate: aDate		isoFormatOn: stream.	stream nextPutAll: ''''.	^stream contents.</body><body package="GlorpDatabase" selector="printTime:for:">printTime: aTime for: aType	| stream |	aTime isNil ifTrue: [^nil].	stream := WriteStream on: String new.	stream nextPutAll: 'time '''.	self		printTime: aTime		isoFormatOn: stream.	stream nextPutAll: ''''.	^stream contents.</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPutAll: 'timestamp '''.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPut: $ .	self		printTime: aTimestamp		isoFormatOn: stream.	"	milliseconds: true."	stream nextPutAll: ''''.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	^InMemorySequence.</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	^true</body><body package="GlorpDatabase" selector="initializeReservedWords">initializeReservedWords	reservedWords := Set new.	reservedWords 		add: 'type';		add: 'value';		add: 'password';		add: 'unique';		add: 'date';		add: 'current';		add: 'order';		add: 'active';		add: 'action';		add: 'database';		add: 'table';		add: 'timestamp';		add: 'position'.</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^31</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^31</body><body package="GlorpDatabase" selector="requiresTransactionForTableOperations">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^false.</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	^false.</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	^FirebirdSequence.</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'blob sub_type text'].</body><body package="GlorpDatabase" selector="sequence">sequence	^self typeNamed: #sequence ifAbsentPut: [GlorpSerialType new typeString: (self integer typeString)].</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="isODBCPlatform">isODBCPlatform	"IBEXDI defines an EXDI connection class, not an ODBC one." 	^false</body><body package="GlorpDatabase" selector="reusePreparedStatements">reusePreparedStatements	"Firebird/InterBase supports binding of parameters (i.e. instead of printing them as strings within the SQL statement);  indeed, when handling Blobs, the current IBEXDI implementation demands it.  However if RowBasedCommands (INSERT, DELETE, UPDATE) attempt to reuse bound statements, there are failures;  every 79th or 358th or whatever reuse of such a statement returns bad data.  (SELECT statements are fine.)  This was hidden when failure to release the GlorpCursor in RowBasedCommands left statements busy, so unreusable;  the fix (first made in Glorp 0.3.181) revealed it.  We return false here so that reusePreparedStatements is initialized to false for any accessor whose login uses this platform."	^false"To study further:  is it that prepared-statement-signature-matching needs to distingush the types of the contents of an EqualOnContentsReadStream, or does the database need a bug fix, or does the IBEXDI need to handle Blobs differently?  If the problems with RowBaseCommands cannot be resolved, can we / should we distinguish between reusing them and reusing SELECT statements?"</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"Firebird/InterBase supports binding in all statements (indeed its EXDI appears to require it for blobs) and can also reuse SELECT statements, but reuse of RowBasedCommands (INSERT, DELETE, UPDATE) for Blobs is unreliable although binding of such statements is essential (see my #reusePreparedStatementsIfSupported method comment)."	^true</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>conversion</category><body package="GlorpDatabase" selector="blobDataToStreamConverter">blobDataToStreamConverter	^DelegatingDatabaseConverter		named: #blobDataToStream		hostedBy: self		fromStToDb: #convertBlobData:for:		fromDbToSt: #nullConversion:for:.</body><body package="GlorpDatabase" selector="convertBlobData:for:">convertBlobData: aData for: aType	"From standard Store getBlobData called in writeSession;  Firebird seems to need it.  Glorp needs to think that two such streams on the same data are equal."	^EqualOnContentReadStream on: aData</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>accessing</category><body package="GlorpDatabase" selector="vwEXDIConnectionClass">vwEXDIConnectionClass	^'InterBaseConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'IBEXDI'</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="printSqlStatementToListTablesInSchema:on:">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Firebird uses the same table for tables, views and possibly other stuff.  It does not support schemas within a database "	aStream		nextPutAll: 'SELECT rdb$relation_name as table_name FROM rdb$relations ';		nextPutAll: 'WHERE rdb$view_blr is null and (rdb$system_flag is null or rdb$system_flag = 0);'</body><body package="GlorpDatabase" selector="printSqlStatementToTestExistenceOfTable:inSchema:on:">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	"Firebird uses the same table for tables, views and possibly other stuff, does NOT support schemas. 	As currently written, this query will not test for existence of views OR system tables."	aStream		nextPutAll: 'SELECT count(*) FROM rdb$relations ';		nextPutAll: 'WHERE rdb$relation_name = ';		nextPut: $';		nextPutAll: tableName;		nextPut: $';		nextPutAll: ' AND rdb$view_blr is null AND (rdb$system_flag is null OR rdb$system_flag = 0);'</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="base">base	^base</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions" selector="field">field	^lookupKey</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canBind">canBind	"Return true if this represents a value that can be bound into a prepared statement"	^true.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="convertedDbValueOf:">convertedDbValueOf: anObject	"We don't do any conversion"	^anObject</body><body package="GlorpExpressions" selector="printOn:">printOn: aStream 	aStream nextPutAll: 'Parameter('.	self printTreeOn: aStream.	aStream nextPut: $)</body><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream	lookupKey printSQLOn: aStream withParameters: #()</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	self field type print: (self valueIn: aDictionary) on: aStream.</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	[lookupKey printSQLOn: aStream withParameters: #()] on: Dialect error do: [:ex | lookupKey printOn: aStream].</body><body package="GlorpExpressions" selector="valueIn:">valueIn: aDictionary 	^aDictionary at: lookupKey.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="get:withArguments:">get: aSelector withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSelector withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSelector		basedOn: self		withArguments: anArray</body><body package="GlorpExpressions" selector="getMapping:named:">getMapping: aMapping named: aSymbol	"Get an expression given the actual mapping. Only if you really know what you're doing! In this case, what we're probably doing is rewriting a parameter that's a mapped object into a set of parameters, one for each of its primary keys."	| expression |	expression := nil.	aMapping mappedFields do: [:each |		expression := (each asGlorpExpressionOn: self) AND: expression].	^expression.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="addToTargetFields:">addToTargetFields: aCollection	"If we can provide target fields, add them to the collection"	lookupKey class == DatabaseField ifTrue: [		aCollection add: lookupKey].</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^source getField: lookupKey.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	self == anExpression ifTrue: [^aBaseExpression].	self base == ultimateBaseExpression ifTrue: [^self].	^aBaseExpression getParameter: lookupKey.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>initialize/release</category><body package="GlorpExpressions" selector="field:base:">field: aDatabaseField base: aBaseExpression 	lookupKey := aDatabaseField.	base := aBaseExpression</body></methods><methods><class-id>Glorp.ParameterExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="forField:basedOn:">forField: aField basedOn: anObjectExpression	^self new field: aField base: anObjectExpression; yourself</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	^self platform converterNamed: #date.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Date.</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^self platform exdiTypeForDates.</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'date'</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="print:on:">print: aValue on: aStream	aStream nextPutAll: (self platform printDate: aValue for: self).</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Boolean.</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToBoolean].	^self platform nullConverter.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Boolean.</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="print:on:">print: aValue on: aStream	aStream nextPutAll: (self platform printBoolean: aValue for: self).</body></methods><methods><class-id>Glorp.GlorpExtensionsPackage class</class-id> <category>instance creation</category><body package="GlorpExtensions" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="AND:">AND: anExpression	anExpression isNil ifTrue: [^self].	^anExpression asGlorpExpression.</body><body package="GlorpExpressions" selector="OR:">OR: anExpression	anExpression isNil ifTrue: [^self].	^anExpression</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="base">base	^base.</body><body package="GlorpExpressions" selector="base:">base: aBaseExpression	base := aBaseExpression.</body><body package="GlorpExpressions" selector="isFalse">isFalse	^value not</body><body package="GlorpExpressions" selector="isTrue">isTrue	^value</body><body package="GlorpExpressions" selector="value:">value: aValue	"a value is expected to be nil, true, or false. we treat nil as true"	value := aValue isNil ifTrue: [true] ifFalse: [aValue].</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	^true.</body><body package="GlorpExpressions" selector="canPrint">canPrint	"Return true if we can print into a where clause"	^false.</body><body package="GlorpExpressions" selector="isEmptyExpression">isEmptyExpression	^true.</body><body package="GlorpExpressions" selector="willPrintAsWhereClause">willPrintAsWhereClause	^false.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aCommand withParameters: aDictionary	^self.</body><body package="GlorpExpressions" selector="tablesForANSIJoin">tablesForANSIJoin	^#().</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	aStream nextPutAll: 'empty expression'.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree"	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| copy |	self == anExpression ifTrue: [^aBaseExpression].	self base == ultimateBaseExpression ifTrue: [^self].	copy := self copy.	copy base: aBaseExpression.	^copy.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	base isNil ifTrue: [base := BaseExpression new].	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>initialize</category><body package="GlorpExpressions" selector="initialize">initialize	super initialize.	value := true.</body></methods><methods><class-id>Glorp.EmptyExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="on:">on: aValue	^self new value: aValue.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="key1">key1	^key1</body><body package="GlorpUnitOfWork" selector="key1:">key1: anObject	key1 := anObject</body><body package="GlorpUnitOfWork" selector="key2">key2	^key2</body><body package="GlorpUnitOfWork" selector="key2:">key2: anObject	key2 := anObject</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>comparing</category><body package="GlorpUnitOfWork" selector="=">= aRowMapKey	aRowMapKey class == self class ifFalse: [^false].	^(key1 == aRowMapKey key1 and: [key2 == aRowMapKey key2]) or: [		key2 == aRowMapKey key1 and: [key1 == aRowMapKey key2]].</body><body package="GlorpUnitOfWork" selector="hash">hash	| hash1 hash2 hash1Temp longHash |	hash1 := key1 identityHash.	hash2 := key2 identityHash.	hash1 &gt; hash2 ifTrue: [		hash1Temp := hash1.		hash1 := hash2.		hash2 := hash1Temp].	longHash := (hash1 bitShift: 8) bitXor: hash2.	^Dialect fitHashIntoSmallInteger: longHash.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="adjustIn:">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted key1: (aCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body><body package="GlorpUnitOfWork" selector="reverseAdjustIn:">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted key1: (aRowMapForMementos reversedCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aRowMapForMementos reversedCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body></methods><methods><class-id>Glorp.DuplicatePrimaryKeyException</class-id> <category>accessing</category><body package="GlorpCore" selector="defaultMessageText">defaultMessageText	^'Duplicate objects with same primary key'.</body><body package="GlorpCore" selector="existingObject">existingObject	^existingObject</body><body package="GlorpCore" selector="existingObject:">existingObject: anObject	existingObject := anObject</body><body package="GlorpCore" selector="newObject">newObject	^newObject</body><body package="GlorpCore" selector="newObject:">newObject: anObject	newObject := anObject</body></methods><methods><class-id>Glorp.DuplicatePrimaryKeyException class</class-id> <category>instance creation</category><body package="GlorpCore" selector="new:existing:">new: newObject existing: existingObject	^self new		newObject: newObject;		existingObject: existingObject;		yourself.</body></methods><methods><class-id>Glorp.GlorpIllegalCommand</class-id> <category>accessing</category><body package="GlorpMisc" selector="command">command	^command</body><body package="GlorpMisc" selector="command:">command: aDatabaseCommand	command := aDatabaseCommand</body><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Illegal Command'</body><body package="GlorpMisc" selector="session">session	^command session.</body></methods><methods><class-id>Glorp.Join</class-id> <category>preparing</category><body package="GlorpExpressions" selector="additionalExpressions">additionalExpressions	^#()</body><body package="GlorpExpressions" selector="additionalExpressionsIn:">additionalExpressionsIn: aQuery 	^#()</body><body package="GlorpExpressions" selector="addToTargetFields:">addToTargetFields: aCollection	"If we can provide target fields, add them to the collection"	aCollection addAll: targets.</body><body package="GlorpExpressions" selector="allTablesToPrint">allTablesToPrint	^targets inject: Set new into: [:sum :each | 		sum add: each table. sum].</body><body package="GlorpUnitOfWork" selector="condenseBooleanEquality">condenseBooleanEquality	^self.</body><body package="GlorpUnitOfWork" selector="condenseBooleanEqualityExpressions">condenseBooleanEqualityExpressions	^self.</body><body package="GlorpExpressions" selector="onlyJoinParts">onlyJoinParts	"Strip out any generic parts, leaving only the things that are actually joins"		^self.</body><body package="GlorpExpressions" selector="prepareIn:">prepareIn: aQuery 	"Do nothing."	aQuery whereClause: (self asGeneralGlorpExpression).	aQuery whereClause prepareIn: aQuery.</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^self asGlorpExpressionOn: aBaseExpression.</body><body package="GlorpExpressions" selector="removeNonJoinParts">removeNonJoinParts	"Remove anything that's not an actual join. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to use the general ones, because they're not field level."	^self.</body><body package="GlorpExpressions" selector="replaceJoinsWithInverse">replaceJoinsWithInverse	"Replace any actual Join objects we have with their inverse. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to mess with the general ones, because they're not field-level. As actual joins, we ignore this, because it will be done at the parent level"	^self.</body><body package="GlorpUnitOfWork" selector="rewriteEquality">rewriteEquality	^self.</body><body package="GlorpExpressions" selector="sourceForTarget:">sourceForTarget: aField	| index |	index := targets indexOf: aField.	index = 0 ifTrue: [^nil].	^sources at: index.</body><body package="GlorpExpressions" selector="targetForSource:">targetForSource: aField	| index |	index := sources indexOf: aField.	index = 0 ifTrue: [^nil].	^targets at: index.</body></methods><methods><class-id>Glorp.Join</class-id> <category>accessing</category><body package="GlorpExpressions" selector="allControlledTables">allControlledTables	^self allTables.</body><body package="GlorpExpressions" selector="allSourceFields">allSourceFields	^sources</body><body package="GlorpExpressions" selector="allTables">allTables	^(targets collect: [:each | each table]) asSet.</body><body package="GlorpExpressions" selector="allTargetFields">allTargetFields	^targets</body><body package="GlorpExpressions" selector="base">base	^base.</body><body package="GlorpExpressions" selector="base:">base: aBaseExpression	base := aBaseExpression.</body><body package="GlorpExpressions" selector="from:to:">from: aField to: anotherField	^self addSource: aField target: anotherField.</body><body package="GlorpExpressions" selector="hasDescriptor">hasDescriptor	^false.</body><body package="GlorpExpressions" selector="numberOfParameters">numberOfParameters	^sources size</body><body package="GlorpExpressions" selector="outerJoin">outerJoin	^outerJoin.</body><body package="GlorpExpressions" selector="outerJoin:">outerJoin: aBoolean	outerJoin := aBoolean.</body><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^self ultimateBaseExpression.</body><body package="GlorpExpressions" selector="targetKeys">targetKeys	^targets.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.Join</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOn:">printOn: aStream	sources with: targets do: [:source :target |		aStream nextPut: $(.		source printSQLOn: aStream withParameters: #().		aStream nextPutAll: ' = '.		target printSQLOn: aStream withParameters: #().		aStream nextPutAll: ') ']</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary 	1 to: sources size		do: 			[:i | 			| eachTarget eachSource sourceValue |			eachTarget := targets at: i.			eachSource := sources at: i.			eachTarget printSQLOn: aStream withParameters: aDictionary.			sourceValue := (self isConstant: eachSource) ifTrue: [eachSource value] ifFalse: [aDictionary at: eachSource].			sourceValue isNil 				ifTrue: [aStream nextPutAll: ' IS NULL ']				ifFalse: 					[aStream nextPutAll: ' = '.					sourceValue printOn: aStream].			i = targets size ifFalse: [aStream nextPutAll: ' AND ']]</body></methods><methods><class-id>Glorp.Join</class-id> <category>api</category><body package="GlorpQueries" selector="addSource:target:">addSource: aField target: anotherField 	| value targetValue |	value := (self isConstant: aField) 				ifTrue: [ConstantExpression for: aField]				ifFalse: [aField].	sources add: value.	targetValue := anotherField class == SimpleQuery		ifTrue: [anotherField asGlorpExpressionOn: base] 		ifFalse: [anotherField].	(self isConstant: targetValue) ifTrue: [		self error: 'You are attempting to set a constant value as the target of a relationship. I suspect you want to set it on the source instead. Either that or you''re trying to use a field name where a field object is required.'].	targets add: targetValue</body><body package="GlorpExpressions" selector="asGlorpExpression">asGlorpExpression	^self.</body><body package="GlorpExpressions" selector="asGlorpExpressionForDescriptor:">asGlorpExpressionForDescriptor: aDescriptor	base descriptor: aDescriptor.</body><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copy.	copy base: aBaseExpression.	copy outerJoin: outerJoin.	^copy.</body><body package="GlorpExpressions" selector="asOuterJoin">asOuterJoin	^self copy beOuterJoin.</body><body package="GlorpExpressions" selector="beOuterJoin">beOuterJoin	outerJoin := true.</body><body package="GlorpUnitOfWork" selector="mapFromSource:andTarget:intoRowsIn:">mapFromSource: sourceObject andTarget: targetObject intoRowsIn: aRowMap	(sourceObject isNil or: [targetObject isNil]) ifTrue: [^self].	1		to: sources size		do:			[:i | 			| eachSourceField eachTargetField |			eachSourceField := sources at: i.			eachTargetField := targets at: i.			(self isConstant: eachSourceField)				ifTrue: [aRowMap at: eachTargetField key: targetObject put: eachSourceField value]				ifFalse:					[aRowMap						unifyField: eachSourceField						key: sourceObject						withField: eachTargetField						key: targetObject]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Joins act as if they don't have children, and just evaluate for themselves"	| |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	aBlock value: self.</body><body package="GlorpExpressions" selector="fieldsDo:">fieldsDo: aBlock	sources with: targets do: aBlock.</body><body package="GlorpExpressions" selector="mappableFieldsDo:">mappableFieldsDo: aBlock	sources with: targets do: [:source :target |		source isMappable ifTrue: [aBlock value: source value: target]].</body><body package="GlorpExpressions" selector="mappableSourceFieldsDo:">mappableSourceFieldsDo: aBlock	sources do: [:source  |		source isMappable ifTrue: [aBlock value: source]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>testing</category><body package="GlorpExpressions" selector="isEmptyExpression">isEmptyExpression	^sources isEmpty.</body><body package="GlorpExpressions" selector="isGlorpExpression">isGlorpExpression	^true.</body><body package="GlorpExpressions" selector="isJoin">isJoin	^true.</body><body package="GlorpExpressions" selector="isOuterJoin">isOuterJoin	^outerJoin.</body><body package="GlorpExpressions" selector="shortCircuitOnNullComparison:">shortCircuitOnNullComparison: parameters	"Return true if we represent an expression that compares null to a non-nullable value (in any of our clauses), so we don't ever need to really evaluate it"	self fieldsDo: [:source :target |		(target isNullable not and: [(parameters at: source) isNil]) ifTrue: [^true]].	^false.</body></methods><methods><class-id>Glorp.Join</class-id> <category>initialize</category><body package="GlorpExpressions" selector="initialize">initialize	sources := OrderedCollection new: 2.	targets := OrderedCollection new: 2.	base := BaseExpression new.	outerJoin := false.</body><body package="GlorpExpressions" selector="sourceFields:targetFields:">sourceFields: sourceFields targetFields: targetFields	sources := sourceFields.	targets := targetFields.</body></methods><methods><class-id>Glorp.Join</class-id> <category>comparing</category><body package="GlorpExpressions" selector="=">= aJoin	aJoin class == self class ifFalse: [^false].	aJoin allSourceFields = sources ifFalse: [^false].	aJoin allTargetFields = targets ifFalse: [^false].	^true.</body></methods><methods><class-id>Glorp.Join</class-id> <category>converting</category><body package="GlorpExpressions" selector=",">, aJoin	| newJoin |	aJoin isNil ifTrue: [^self].	aJoin == self ifTrue: [^self].	newJoin := (self class fromAll: (sources, aJoin allSourceFields) toAll: (targets, aJoin targetKeys)) removeDuplicates.	"If either one of the contributors is an outer join, make the result be an outer join"	newJoin outerJoin: (self outerJoin | aJoin outerJoin).	^newJoin</body><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| sourceFieldExpression targetFieldExpression completeExpression relationExpression |	completeExpression := EmptyExpression new base: base.	sources with: targets		do: 	[:sourceField :targetField | 			sourceFieldExpression := source getFieldKnownNotToBeAName: sourceField.			targetFieldExpression := target getFieldKnownNotToBeAName: targetField.			relationExpression := sourceFieldExpression equals: targetFieldExpression.			completeExpression := relationExpression AND: completeExpression].	outerJoin ifTrue: [completeExpression beOuterJoin].	^completeExpression</body><body package="GlorpExpressions" selector="asGeneralGlorpExpression">asGeneralGlorpExpression	"Convert this to a 'normal' expression representing the same information"	| main clause |	main := EmptyExpression new base: base.	sources with: targets		do: 			[:eachSource :eachTarget | 			| srcExp targetExp |			srcExp := self sourceExpressionFor: eachSource.			targetExp := self targetExpressionFor: eachTarget.			"Reversing the order is important because the source is the parameter, and sql won't accept '27 = FOO' "			clause := targetExp equals: srcExp.			main := main AND: clause].	outerJoin ifTrue: [main beOuterJoin].	^main</body><body package="GlorpExpressions" selector="asGeneralGlorpExpressionWithFields">asGeneralGlorpExpressionWithFields	"The normal conversion of a join is to an expression equating fields and parameters. Instead, generate one with field to field comparisons"	| main clause |	main := nil.	sources with: targets		do: 			[:eachSource :eachTarget | 			| srcExp targetExp |			srcExp := self targetExpressionFor: eachSource.			targetExp := self targetExpressionFor: eachTarget.			clause := srcExp equals: targetExp.			main := main == nil ifTrue: [clause] ifFalse: [main AND: clause]].	outerJoin ifTrue: [main beOuterJoin].	^main</body><body package="GlorpExpressions" selector="generalExpressionPart">generalExpressionPart	^nil.</body><body package="GlorpExpressions" selector="inverseJoin">inverseJoin	| inverse |	inverse := self class new		base: base;		sourceFields: targets		targetFields: sources.	inverse owningMapping: self owningMapping.	^inverse.</body><body package="GlorpUnitOfWork" selector="isConstant:">isConstant: aTarget	"The target can be either a constant (which gets turned into a ConstantExpression) or (usually) a DatabaseField, representing a parameter to the query"	(aTarget class == DatabaseField) ifTrue: [^false].	(aTarget isGlorpExpression and: [aTarget isConstantExpression not]) ifTrue: [^false].	^true.</body><body package="GlorpExpressions" selector="removeDuplicates">removeDuplicates	| existing newSources newTargets |	existing := Set new.	newSources := OrderedCollection new: sources size.	newTargets := OrderedCollection new: targets size.	sources		with: targets		do:			[:eachSource :eachTarget | 			| association |			association := eachSource -&gt; eachTarget.			(existing includes: association)				ifFalse:					[existing add: association.					newSources add: eachSource.					newTargets add: eachTarget]].	sources := newSources.	targets := newTargets.</body><body package="GlorpExpressions" selector="replacing:withEquivalenceFrom:">replacing: aTable withEquivalenceFrom: aJoin	"Create a new join in which references to fields in aTable have been replaced with the equivalent based on a Join (we assume that aTable references are in the sources of aJoin). If the field doesn't occur in the translation, just remove it"	| newSources newTargets newSource |	newSources := OrderedCollection new.	newTargets := OrderedCollection new.	self fieldsDo: [:eachSource :eachTarget |		(eachSource isGlorpExpression not and: [eachSource table = aTable])			ifTrue: [				newSource := aJoin targetForSource: eachSource.				newSource isNil ifFalse: [					newSources add: newSource.					newTargets add: eachTarget]]].	^self class fromAll: newSources toAll: newTargets.</body><body package="GlorpExpressions" selector="sourceExpressionFor:">sourceExpressionFor: source		^((self isConstant: source) or: [source isMappable not]) "This might be a subselect"		ifTrue: [source]		ifFalse: [base getParameter: source].</body><body package="GlorpExpressions" selector="targetExpressionFor:">targetExpressionFor: eachTarget 	^(self isConstant: eachTarget)		ifTrue: [eachTarget]		ifFalse: [			eachTarget isGlorpExpression 			ifTrue: [eachTarget] 			ifFalse: [(base getTable: eachTarget table) getField: eachTarget]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>primary keys</category><body package="GlorpExpressions" selector="primaryKeyFromDictionary:">primaryKeyFromDictionary: aDictionary	"Given a set of parameters, return a primary key suitable for retrieving our target. Return either a value for the key, nil for no key found, or an array for compound keys."		sources size = 1 ifTrue: [^aDictionary at: sources first ifAbsent: [nil]].	^sources collect: [:each | aDictionary at: each ifAbsent: [nil]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>debugging</category><body package="GlorpExpressions" selector="owningMapping">owningMapping	"Return the mapping (if there is one) that is responsible for. Not needed for the code, but might be a useful debugging aid if trying to figure out where a @#%#@% join came from"	^owningMapping.</body><body package="GlorpExpressions" selector="owningMapping:">owningMapping: aMapping	owningMapping := aMapping.</body></methods><methods><class-id>Glorp.Join</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="rebuildOn:">rebuildOn: aGlorpMappingExpression 	^self asGlorpExpressionOn: aGlorpMappingExpression.</body></methods><methods><class-id>Glorp.Join class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="from:to:">from: aField to: anotherField	^self new		addSource: aField target: anotherField.</body><body package="GlorpExpressions" selector="from:to:from:to:">from: from1Field to: to1Fieldfrom: from2Field to: to2Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field.</body><body package="GlorpExpressions" selector="from:to:from:to:from:to:">from: from1Field to: to1Fieldfrom: from2Field to: to2Fieldfrom: from3Field to: to3Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field;		addSource: from3Field target: to3Field.</body><body package="GlorpExpressions" selector="from:to:from:to:from:to:from:to:">from: from1Field to: to1Fieldfrom: from2Field to: to2Fieldfrom: from3Field to: to3Fieldfrom: from4Field to: to4Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field;		addSource: from3Field target: to3Field;				addSource: from4Field target: to4Field</body><body package="GlorpExpressions" selector="from:to:from:to:from:to:from:to:from:to:">from: from1Field to: to1Fieldfrom: from2Field to: to2Fieldfrom: from3Field to: to3Fieldfrom: from4Field to: to4Fieldfrom: from5Field to: to5Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field;		addSource: from3Field target: to3Field;				addSource: from4Field target: to4Field;		addSource: from5Field target: to5Field.</body><body package="GlorpExpressions" selector="fromAll:toAll:">fromAll: sourceFields toAll: targetFields	^self new		sourceFields: sourceFields targetFields: targetFields.</body><body package="GlorpExpressions" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>testing</category><body package="GlorpDatabase" selector="isDistinct">isDistinct	^false.</body><body package="GlorpDatabase" selector="isGenerated">isGenerated	^type isGenerated or: [defaultValue notNil].</body><body package="GlorpDatabase" selector="isIndexed">isIndexed	^self table hasIndexForField: self.</body><body package="GlorpDatabase" selector="isLockKey">isLockKey	isLockKey isNil ifTrue: [isLockKey := false].	^isLockKey</body><body package="GlorpDatabase" selector="isMappable">isMappable	"Return true if we're something that can be returned in a select statement. Always true for fields"	^true.</body><body package="GlorpDatabase" selector="isNullable">isNullable		^isNullable.</body><body package="GlorpDatabase" selector="isPrimaryKey">isPrimaryKey	"Private - Answer the value of the receiver's ''isPrimaryKey'' instance variable."	^isPrimaryKey yourSelf.</body><body package="GlorpDatabase" selector="isUnique">isUnique	isUnique isNil ifTrue: [isUnique := false].	^isUnique.</body><body package="GlorpCore" selector="matchesField:">matchesField: aField	table name = aField table name ifFalse: [^false].	name = aField name ifFalse: [^false].	isNullable = aField isNullable ifFalse: [^false].	isPrimaryKey = aField isPrimaryKey ifFalse: [^false].	isUnique = aField isUnique ifFalse: [^false].	^true</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>querying</category><body package="GlorpDatabase" selector="qualifiedName">qualifiedName	^table isNil 		ifTrue: [self name]		ifFalse: [self table qualifiedName, '.', self name].</body><body package="GlorpDatabase" selector="quotedQualifiedName">quotedQualifiedName	| basicName |	basicName := self platform nameForColumn: self name.	^table isNil 		ifTrue: [basicName]		ifFalse: [self table qualifiedName, '.', basicName].</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>initializing</category><body package="GlorpDatabase" selector="initialize">initialize	isPrimaryKey := false.	isNullable := true.	isUnique := false.	isLockKey := false.</body><body package="GlorpDatabase" selector="postInitializeIn:">postInitializeIn: aDescriptorSystem	"Any initialization that has to be delayed until we're in the table"	type initializeForField: self in: aDescriptorSystem.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>converting</category><body package="GlorpDatabase" selector="asDistinctFieldOn:">asDistinctFieldOn: anExpression	^(anExpression getField: self) asDistinctFieldOn: anExpression.</body><body package="GlorpDatabase" selector="asField">asField	^self.</body><body package="GlorpDatabase" selector="asGlorpExpression">asGlorpExpression	^ParameterExpression forField: self basedOn: nil.</body><body package="GlorpDatabase" selector="asGlorpExpressionOn:">asGlorpExpressionOn: anExpression	^ParameterExpression forField: self basedOn: anExpression.</body><body package="GlorpDatabase" selector="converterForStType:">converterForStType: aClass	^self type converterForStType: (aClass isBehavior ifTrue: [aClass] ifFalse: [aClass class]).</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>configuring</category><body package="GlorpDatabase" selector="beIndexed">beIndexed	self table addIndex: (DatabaseIndex forField: self).</body><body package="GlorpDatabase" selector="beLockKey">beLockKey	isLockKey := true.	self table isNil ifFalse: [self table addAsLockKeyField: self]</body><body package="GlorpDatabase" selector="beNullable:">beNullable: aBoolean	self isPrimaryKey ifFalse: [ isNullable := aBoolean ]</body><body package="GlorpDatabase" selector="bePrimaryKey">bePrimaryKey	isPrimaryKey := true.	isNullable := false.	self table isNil ifFalse: [self table addAsPrimaryKeyField: self]</body><body package="GlorpDatabase" selector="defaultValue:">defaultValue: anObject	defaultValue := anObject</body><body package="GlorpDatabase" selector="isUnique:">isUnique: aBoolean	isUnique := aBoolean.</body><body package="GlorpDatabase" selector="type:">type: aDatabaseType	type := aDatabaseType.	(type notNil and: [type isSerial]) ifTrue: [self bePrimaryKey].</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>accessing</category><body package="GlorpDatabase" selector="defaultValue">defaultValue	^defaultValue</body><body package="GlorpDatabase" selector="foreignKeyConstraints">foreignKeyConstraints	^self table foreignKeyConstraints select: [:each | each sourceFields includes: self].</body><body package="GlorpDatabase" selector="impliedSmalltalkType">impliedSmalltalkType	"Return the default Smalltalk type corresponding to our database type"	^self type impliedSmalltalkType.</body><body package="GlorpDatabase" selector="name">name	"Private - Answer the value of the receiver's ''name'' instance variable."	^name</body><body package="GlorpDatabase" selector="name:">name: aString	"Private - Set the value of the receiver's ''name'' instance variable to the argument, anObject."	name := aString asString.</body><body package="GlorpDatabase" selector="platform">platform	^self type platform.</body><body package="GlorpDatabase" selector="position">position	^position</body><body package="GlorpDatabase" selector="position:">position: anObject	position := anObject</body><body package="GlorpDatabase" selector="table">table	^table</body><body package="GlorpDatabase" selector="table:">table: anObject	table := anObject</body><body package="GlorpDatabase" selector="tablesToPrint">tablesToPrint	^Array with: table</body><body package="GlorpDatabase" selector="type">type	^type</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>printing</category><body package="GlorpDatabase" selector="printOn:">printOn: aStream		aStream nextPutAll: 'Field'.	aStream 		nextPutAll: '(';		nextPutAll: (table isNil ifTrue: [''] ifFalse: [table name]);		nextPutAll: '.';		nextPutAll: name;		nextPutAll: ')'.</body><body package="GlorpDatabase" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: anArray 	self printSQLOn: aStream withParameters: anArray.</body><body package="GlorpDatabase" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: anArray 	aStream nextPutAll: self quotedQualifiedName.</body><body package="GlorpDatabase" selector="printUnqualifiedSQLOn:withParameters:">printUnqualifiedSQLOn: aStream withParameters: anArray 	aStream nextPutAll: self name.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>database</category><body package="GlorpDatabase" selector="typeString">typeString	^type typeString</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>copying</category><body package="GlorpDatabase" selector="isSameAliasedFieldAs:">isSameAliasedFieldAs: aField	"Return true if we are the same as another aliased field. For non-aliased fields, identity is assured, so this is redundant. Note that we == the string. This will work because we know these must both be shallow copies of the same thing"	self class == aField class ifFalse: [^false].	^self table == aField table and: [self name == aField name].</body><body package="GlorpDatabase" selector="withTable:">withTable: aTable	"Return a copy of ourselves, with the table set to aTable. Presumably aTable is an aliased version of our table"	^self copy table: aTable.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>comparing</category><body package="GlorpDatabase" selector="&lt;=">&lt;= aField	^self name &lt;= aField name</body><body package="GlorpDatabase" selector="isTheSameAs:">isTheSameAs: aDatabaseField	"Validate that two fields are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aDatabaseField name asUppercase ifFalse: [^false].	self isPrimaryKey = aDatabaseField isPrimaryKey ifFalse: [^false].	self isTheSameTypeAs: aDatabaseField.	self isNullable = aDatabaseField isNullable ifFalse: [^false].	self isUnique = aDatabaseField isUnique ifFalse: [^false].	self isLockKey = aDatabaseField isLockKey ifFalse: [^false].	self defaultValue = aDatabaseField defaultValue ifFalse: [^false].	^true.</body><body package="GlorpDatabase" selector="isTheSameTypeAs:">isTheSameTypeAs: aDatabaseField	| myType aType |	self isPrimaryKey		ifTrue:		   [myType := self type.		   aType := aDatabaseField type.		   ^(myType = aType 				or: [(myType isSerial or: [aType isSerial ]) 					and: [myType impliedSmalltalkType = aType impliedSmalltalkType ]]) ].			^self type = aDatabaseField type</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>obsolete</category><body package="GlorpDatabase" selector="asConstraintReferenceString">asConstraintReferenceString	^table name, ' (', self name, ')'.</body><body package="GlorpDatabase" selector="printForConstraintNameOn:maxLength:">printForConstraintNameOn: aStream maxLength: maxLength 	| constraintName |	constraintName := table name , '_' , name.	constraintName size &gt; maxLength 		ifTrue: [constraintName := constraintName copyFrom: 1 to: maxLength].	aStream nextPutAll: constraintName</body><body package="GlorpDatabase" selector="printNameOn:withParameters:">printNameOn: aStream withParameters: anArray 	aStream nextPutAll: self name</body><body package="GlorpDatabase" selector="printQualifiedSQLOn:withParameters:">printQualifiedSQLOn: aStream withParameters: aDictionary 	aStream nextPutAll: self qualifiedName</body></methods><methods><class-id>Glorp.DatabaseField class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="named:">named: aString	^self error: 'type needed'</body><body package="GlorpDatabase" selector="named:type:">named: aString type: dbType	^super new initialize		name: aString;		type: dbType</body><body package="GlorpDatabase" selector="new">new	^self error: 'dbType needed'</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="hasParameters">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^true.</body><body package="GlorpDatabaseTypes" selector="hasWidth">hasWidth	"Return true if this type has a width attribute - basically meaning it's a string or LOB type. Note that this is different from the isVariableWidth test, which tells us if a field has fixed vs. varying width. So a CHAR field hasWidth=&gt;true, but isVariableWidth=&gt;false, while a VARCHAR field hasWidth=&gt;true isVariableWidth=&gt;false, and a NUMBER has both false."	^true.</body><body package="GlorpDatabaseTypes" selector="isStringType">isStringType	^true.</body><body package="GlorpDatabaseTypes" selector="isVariableWidth">isVariableWidth	self subclassResponsibility.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#String.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToStringTF].	(aClass includesBehavior: Symbol) ifTrue: [^self platform converterNamed: #symbolToString].	width isNil ifFalse: [		(aClass includesBehavior: String) ifTrue: [^self platform converterNamed: #stringToString]].	(aClass includesBehavior: Integer) ifTrue: [^self platform converterNamed: #integerToString].	^super converterForStType: aClass.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^String.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="queryType">queryType	queryType isNil ifTrue: [^self].	^queryType.</body><body package="GlorpDatabaseTypes" selector="queryType:">queryType: aType	queryType := aType</body><body package="GlorpDatabaseTypes" selector="width">width	^width.</body><body package="GlorpDatabaseTypes" selector="width:">width: anInteger	width := anInteger = 0 ifTrue: [nil] ifFalse: [anInteger]</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	typeString isNil		ifTrue:			[typeString := self typeName.			width isNil				ifFalse: [typeString := typeString , '(' , width printString , ')']].	^typeString.</body><body package="GlorpDatabaseTypes" selector="typeString:">typeString: aString	"If we set the typeString, we are presumably setting it to the non-parameterized name as well"	typeString := aString.	super typeString: aString.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>private</category><body package="GlorpDatabaseTypes" selector="typeName">typeName	^typeString.</body><body package="GlorpDatabaseTypes" selector="typeName:">typeName: aString	typeString := aString.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes" selector="=">= aType	super = aType ifFalse: [^false].	self width = aType width ifFalse: [^false].	self queryType == self ifFalse: [		self queryType = aType queryType ifFalse: [^false]].	^true.</body><body package="GlorpDatabaseTypes" selector="hash">hash	^self queryType == self		ifTrue: [super hash bitXor: self width hash]		ifFalse: [(super hash bitXor: self width hash) bitXor: self queryType hash]</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="hasParameters">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^false.</body><body package="GlorpDatabaseTypes" selector="isVariableWidth">isVariableWidth	^true.</body><body package="GlorpDatabaseTypes" selector="requiresCast">requiresCast	^(self platform class = PostgreSQLPlatform) or: [self platform class = SQLServerPlatform]</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#LargeString.</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'text'.	width := nil.</body></methods><methods><class-id>Glorp.GlorpDictionaryDescription</class-id> <category>accessing</category><body package="GlorpQueries" selector="keyExpression">keyExpression	^keyExpression</body><body package="GlorpQueries" selector="keyExpression:">keyExpression: anExpression	keyExpression := anExpression</body><body package="GlorpQueries" selector="valueExpression">valueExpression	^valueExpression</body><body package="GlorpQueries" selector="valueExpression:">valueExpression: anExpression	valueExpression := anExpression</body></methods><methods><class-id>Glorp.GlorpDictionaryDescription</class-id> <category>instance creation</category><body package="GlorpQueries" selector="copyEmpty:">copyEmpty: anInteger	"Masquerade as a instance of a collection :-)"	^Dictionary new: anInteger.</body><body package="GlorpQueries" selector="new">new	"Masquerade as a class"	^Dictionary new.</body><body package="GlorpQueries" selector="new:">new: anInteger	"Masquerade as a class"	^Dictionary new: anInteger.</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="addTypeMappingCriteriaTo:in:">addTypeMappingCriteriaTo: collection in: expression	^self</body><body package="GlorpMappings" selector="allDescribedConcreteClasses">allDescribedConcreteClasses	^Array with: (self describedClass)</body><body package="GlorpMappings" selector="describedClass">describedClass	^self descriptor describedClass</body><body package="GlorpMappings" selector="describedConcreteClassFor:withBuilder:">describedConcreteClassFor: aRow withBuilder: builder	^self mappedClass</body><body package="GlorpMappings" selector="descriptorForSuperclass">descriptorForSuperclass	^self system descriptorFor: self mappedClass superclass</body><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap	"do  nothing"</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anElementBuilder	"do  nothing"</body><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:">referencedIndependentObjectsFrom: anObject	^#().</body><body package="GlorpMappings" selector="typeMappingRoot">typeMappingRoot	^self isTypeMappingRoot 		ifTrue: [self mappedClass]		ifFalse: [self descriptorForSuperclass typeMapping typeMappingRoot]</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="canBeTypeMappingParent">canBeTypeMappingParent	^true</body><body package="GlorpMappings" selector="hasAttribute">hasAttribute	"Return true if this maps an attribute, which is normally true"	^false.</body><body package="GlorpMappings" selector="isAbstract">isAbstract	self subclassResponsibility</body><body package="GlorpMappings" selector="isRelationship">isRelationship	^false.</body><body package="GlorpMappings" selector="isTypeMapping">isTypeMapping	^true</body><body package="GlorpMappings" selector="isTypeMappingRoot">isTypeMappingRoot	| superClassDescriptor |	superClassDescriptor := self descriptorForSuperclass.	^superClassDescriptor isNil or: [ superClassDescriptor typeMapping canBeTypeMappingParent not ]</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="mappedClass">mappedClass	^self descriptor describedClass</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validateAttribute">validateAttribute	" TypeMapping doesn't use the attribute, validation would therefore fail. Probably should introduce AttributeMapping as sibling to TypeMapping "</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>accessing</category><body package="GlorpCore" selector="delay">delay	"Answer the delay, in seconds, between runs of the reaper process."	^delay</body><body package="GlorpCore" selector="delay:">delay: seconds	"Set delay between runs of the reaper process in seconds."	delay := seconds</body><body package="GlorpCore" selector="maximumWork">maximumWork	"Answer the maximum amount of time the reaper thread will run for before yielding."	^maximumWork</body><body package="GlorpCore" selector="maximumWork:">maximumWork: milliseconds	"Set the maximum amount of time the reaper thread will run for before yielding."	maximumWork := milliseconds</body><body package="GlorpCore" selector="nextSequenceNumber">nextSequenceNumber	| id |	id := nextId.	nextId := nextId + 1.	^id</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>reaping</category><body package="GlorpCore" selector="finish">finish"	Transcript cr; show: 'Done', (Time millisecondClockValue // 1000) printString."	done := true.</body><body package="GlorpCore" selector="forkReaperThread">forkReaperThread	| block |	block := [		[done] whileFalse: [			(Delay forSeconds: self delay) wait.			self reapExpiredObjects]].	reaperThread := block forkAt: Processor userBackgroundPriority</body><body package="GlorpCore" selector="mournKeyOf:">mournKeyOf: anEphemeron	"Don't really need to do anything."	anEphemeron value uninstantiate.</body><body package="GlorpCore" selector="privateReapObjects">privateReapObjects	"Private - Go through all of the objects (sorted by time) and remove those which have expired from the receiver's weakValueDictionary.	Answer the number of objects reaped."	| numberReaped timesUp |	startTime := Time millisecondClockValue.	numberReaped := 0.	timesUp := false.	[(Delay forMilliseconds: 100) wait.	timesUp := true] forkAt: Processor activePriorityPlusOne.	keysSortedByExpiryTime		do:			[:association | 			done | timesUp ifTrue: [^numberReaped].			(self shouldReap: association)				ifTrue:					[| timedProxy |					numberReaped := numberReaped + 1.					association key isNil						ifFalse:							["Been touched in the meantime. Just skip over it, but don't reap"							timedProxy := weakValueDictionary								removeKey: association key								ifAbsent: [nil].							timedProxy class == TimedProxy ifTrue: [timedProxy uninstantiate]]]				ifFalse: [^numberReaped]].	^numberReaped.</body><body package="GlorpCore" selector="reapExpiredObjects">reapExpiredObjects	| numberReaped |	[mutex wait.	keysSortedByExpiryTime isEmpty ifTrue: [self finish].	done ifTrue: [^self].	numberReaped := self privateReapObjects.	"If the cache is empty, shut down"	numberReaped timesRepeat: [keysSortedByExpiryTime removeFirst].	indexOffset := indexOffset + numberReaped] ensure: [mutex signal].</body><body package="GlorpCore" selector="restartIfNecessary">restartIfNecessary	[mutex wait.	done		ifTrue:			["Transcript cr; show: 'Restarting', (Time millisecondClockValue // 1000) printString."			done := false.			self forkReaperThread]] ensure: [mutex signal].</body><body package="GlorpCore" selector="shouldReap:">shouldReap: anAssociation	"Check that either we've passed the start time, or that there's been a wraparound in the millisecond value and we're now larger than it by some ridiculous margin, which we'll call 24 hours."	| expireTime milliseconds shouldReap |	anAssociation key isNil ifTrue: [^true].  "It's been touched. Skip over but don't reap, handled elsewhere"	expireTime := anAssociation value.	milliseconds := "24 * 60 * 60 * 1000" 86400000.	shouldReap := expireTime &lt;= startTime or: [expireTime - milliseconds &gt; startTime].	^shouldReap.</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>caching</category><body package="GlorpCore" selector="add:">add: aTimedProxy	[mutex wait.	self noWaitAdd: aTimedProxy] ensure: [mutex signal].	self restartIfNecessary.</body><body package="GlorpCore" selector="at:ifAbsent:">at: id ifAbsent: errorBlock	| result |	[mutex wait.	result := weakValueDictionary at: id ifAbsent: [^errorBlock value]]		ensure: [mutex signal].	^result.</body><body package="GlorpCore" selector="includes:">includes: aTimedProxy	self at: aTimedProxy glorpId ifAbsent: [^false].	^true</body><body package="GlorpCore" selector="noWaitAdd:">noWaitAdd: aTimedProxy	| association id |	aTimedProxy glorpId isNil ifTrue: [aTimedProxy glorpId: self nextSequenceNumber].	id := aTimedProxy glorpId.		association := Association key: id value: aTimedProxy glorpTimeToDie.	weakValueDictionary at: id put: aTimedProxy.	aTimedProxy glorpAssociation: association.	keysSortedByExpiryTime add: association.	aTimedProxy glorpReaper: self.</body><body package="GlorpCore" selector="remove:ifAbsent:">remove: aTimedProxy ifAbsent: errorBlock	^self removeKey: aTimedProxy glorpId ifAbsent: errorBlock.</body><body package="GlorpCore" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: errorBlock	"Note: The key is NOT removed from keysSortedByExpiryTime. The reaper	will eventually reap the given key, and ignore it since it is already gone.	Removing objects from the middle of keysSortedByExpiryTime will screw	up the indexing of objects that are registered later. Don't do it."	| result |	[mutex wait.	result := weakValueDictionary removeKey: key ifAbsent: [^errorBlock value]]		ensure: [mutex signal].	^result.</body><body package="GlorpCore" selector="touch:">touch: aTimedProxy	[| association |	mutex wait.	association := aTimedProxy glorpAssociation.	association isNil ifTrue: [^self].	association key: nil.	"This indicates that the key should not be reaped at this time."	self noWaitAdd: aTimedProxy] ensure: [mutex signal].</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>initializing</category><body package="GlorpCore" selector="initialize">initialize	done := false.	self delay: 5. "seconds"	self maximumWork: 100. "milliseconds"	nextId := 1.	weakValueDictionary := Dialect weakValueDictionaryClass new.	weakValueDictionary manager: self.	"Note: The sort used by keysSortedByExpiryTime _must_ be stable."	keysSortedByExpiryTime := SortedCollection sortBlock: [:associationA :associationB | associationA value "timeToDie" &lt;= associationB value].	indexOffset := 0.	mutex := Semaphore forMutualExclusion.	self forkReaperThread</body><body package="GlorpCore" selector="release">release	done := true.	maximumWork := 0.	reaperThread notNil ifTrue: [reaperThread terminate].	reaperThread := nil.</body></methods><methods><class-id>Glorp.TimedProxyReaper class</class-id> <category>As yet unclassified</category><body package="GlorpCore" selector="delay:">delay: seconds	^self new delay: seconds</body><body package="GlorpCore" selector="delay:maximumWork:">delay: seconds maximumWork: milliseconds	^self new delay: seconds; maximumWork: milliseconds</body><body package="GlorpCore" selector="new">new	^super new initialize</body></methods><methods><class-id>Glorp.TransformingFieldValueWrapper</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="allInnerWrappers">allInnerWrappers	^innerWrapper allInnerWrappers, (Array with: innerWrapper).</body><body package="GlorpUnitOfWork" selector="basicContents">basicContents	"Return the un-transformed contents"	^innerWrapper contents.</body><body package="GlorpUnitOfWork" selector="contents">contents	^forwardTransformation value: innerWrapper contents.</body><body package="GlorpUnitOfWork" selector="contents:">contents: anObject	innerWrapper contents: (inverseTransformation value: anObject).</body><body package="GlorpUnitOfWork" selector="forwardTransformation">forwardTransformation	^forwardTransformation</body><body package="GlorpUnitOfWork" selector="forwardTransformation:">forwardTransformation: aBlock	forwardTransformation := aBlock</body><body package="GlorpUnitOfWork" selector="hasValue">hasValue	^innerWrapper hasValue.</body><body package="GlorpUnitOfWork" selector="innerWrapper">innerWrapper	^innerWrapper</body><body package="GlorpUnitOfWork" selector="innerWrapper:">innerWrapper: aFieldValueWrapper	innerWrapper := aFieldValueWrapper</body><body package="GlorpUnitOfWork" selector="inverseTransformation">inverseTransformation	^inverseTransformation</body><body package="GlorpUnitOfWork" selector="inverseTransformation:">inverseTransformation: aBlock	inverseTransformation := aBlock</body><body package="GlorpUnitOfWork" selector="privateSetContents:">privateSetContents: anObject	innerWrapper privateSetContents: (inverseTransformation value: anObject).</body></methods><methods><class-id>Glorp.TransformingFieldValueWrapper</class-id> <category>unifying</category><body package="GlorpUnitOfWork" selector="containsWrapper:">containsWrapper: aFieldValueWrapper	^self == aFieldValueWrapper or: [innerWrapper == aFieldValueWrapper		or: [aFieldValueWrapper innerWrapper == self			or: [aFieldValueWrapper innerWrapper == self innerWrapper]]].</body><body package="GlorpUnitOfWork" selector="replaceWith:">replaceWith: aFieldValueWrapper	innerWrapper replaceWith: aFieldValueWrapper.</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="addTypeMappingCriteriaTo:in:">addTypeMappingCriteriaTo: collection in: base	| singleRightValue r l |	singleRightValue := self keys size = 1.	r := ConstantExpression for: (singleRightValue											ifTrue: [self keys asArray first]											ifFalse: [self keys]).	l := FieldExpression forField: self field basedOn: base.	collection add: (singleRightValue ifTrue: [l equals: r] ifFalse: [l in: r]).</body><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap	| row |	self canWrite ifFalse: [^self].	row := aRowMap findOrAddRowForTable: self field table withKey: anObject.	row at: field put: key.</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	^self.</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="field">field	"If we don't have this, look it up from one of our sub-mappings"	| concrete |	field isNil ifTrue: [		concrete := self descriptor typeResolver concreteMembers detect: [:each | each typeMapping field notNil].		field := concrete typeMapping field].	^field.</body><body package="GlorpMappings" selector="keyDictionary">keyDictionary	keyDictionary isNil ifTrue: [ self buildKeyDictionary ].	^keyDictionary</body><body package="GlorpMappings" selector="keyedBy">keyedBy	^key</body><body package="GlorpMappings" selector="keyedBy:">keyedBy: aKey	key := aKey</body><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^Array with: self field.</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>types</category><body package="GlorpMappings" selector="describedConcreteClassFor:withBuilder:">describedConcreteClassFor: aRow withBuilder: builder	^self keyDictionary at: (aRow atIndex: (builder translateFieldPosition: field))</body><body package="GlorpMappings" selector="keys">keys	^self keyDictionary keys</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>initialize-release</category><body package="GlorpMappings" selector="buildKeyDictionary">buildKeyDictionary	| subclassDescriptor |	keyDictionary := Dictionary new.	key isNil ifFalse: [keyDictionary at: key put: descriptor describedClass].	descriptor describedClass glorpAllSubclasses do: 			[:each | 			subclassDescriptor := descriptor system descriptorFor: each.			(subclassDescriptor isNil 				or: [subclassDescriptor typeMapping keyedBy isNil]) 					ifFalse: 						[keyDictionary at: subclassDescriptor typeMapping keyedBy							put: subclassDescriptor describedClass]]</body><body package="GlorpMappings" selector="field:keyedBy:">field: aField keyedBy: aKey	field := aField.	key := aKey.</body></methods><methods><class-id>Glorp.FilteredTypeMapping class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="to:keyedBy:">to: field keyedBy: key	^self new		field: field		keyedBy: key</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>initializing</category><body package="GlorpQueries" selector="setUp">setUp	availableTables := Set new.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>printing</category><body package="GlorpQueries" selector="nextJoin">nextJoin	^joinsToProcess detect: [:eachJoinExpression |		eachJoinExpression tablesForANSIJoin anySatisfy: [:eachTable |			availableTables includes: eachTable]].</body><body package="GlorpQueries" selector="printJoinsOn:">printJoinsOn: aCommand	"This is pretty hideous. Figure out an order in which to print these stupid joins. As a bonus, they may be circular, so we may have to collapse joins together. And if we collapse, we can't print as we go because we don't know how many parentheses to add, so store them up and print them all at the end"	| allJoins |	joinsToProcess := query joins copy.	availableTables := Set with: self rootTable.	allJoins := OrderedCollection new.	[joinsToProcess isEmpty] whileFalse: [		| next nextTable allRelatedJoins fullJoin|		next := self nextJoin.		joinsToProcess remove: next.		nextTable := next tableToJoinFrom: availableTables.		allRelatedJoins := joinsToProcess select: [:each | (each tableToJoinFrom: availableTables) = nextTable].		fullJoin := allRelatedJoins inject: next into: [:sum :each | sum AND: each].		joinsToProcess removeAll: allRelatedJoins.		allJoins add: (fullJoin-&gt;nextTable).		availableTables addAll: (next tablesForANSIJoin)].	allJoins size timesRepeat: [aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $(]].	aCommand nextPutAll: self rootTable sqlTableName.	allJoins do: [:each | 		each key printForANSIJoinTo: each value on: aCommand.		aCommand platform parenthesizeCommandsInCompoundQuery ifTrue: [aCommand nextPut: $)]].	self printLeftoverTablesOn: aCommand.</body><body package="GlorpQueries" selector="printLeftoverTablesOn:">printLeftoverTablesOn: aCommand	"Now there might be leftover tables whose joins were implied directly by the where clause"	| leftOverTables |	leftOverTables := self allTables asSet copy.	availableTables do: [:each | leftOverTables remove: each ifAbsent: []].	leftOverTables isEmpty ifFalse: [aCommand nextPutAll: ', '].	GlorpHelper		print: [:each | each sqlTableName]		on: aCommand		for: leftOverTables		separatedBy: ', '.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>accessing</category><body package="GlorpQueries" selector="allTables">allTables	^query tablesToPrint.</body><body package="GlorpQueries" selector="query:">query: aQuery	query := aQuery.		self setUp.</body><body package="GlorpQueries" selector="rootTable">rootTable	"Pick a table to start with"	^self allTables first.</body></methods><methods><class-id>Glorp.JoinPrinter class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="for:">for: aQuery	^self new query: aQuery.</body></methods><methods><class-id>Glorp.WeakVWCachePolicy</class-id> <category>expiry</category><body package="GlorpCore" selector="collectionForExtraReferences">collectionForExtraReferences	^FixedSizeQueue maximumSize: self numberOfReferencesToKeepAround.</body><body package="GlorpCore" selector="markEntryAsCurrent:in:">markEntryAsCurrent: item in: aCache	aCache markEntryAsCurrent: item.</body></methods><methods><class-id>Glorp.WeakVWCachePolicy</class-id> <category>accessing</category><body package="GlorpCore" selector="dictionaryClass">dictionaryClass	^Dialect smalltalkAt: #EphemeralValueDictionary ifAbsent: [Dictionary].</body><body package="GlorpCore" selector="numberOfReferencesToKeepAround">numberOfReferencesToKeepAround	^numberOfElements.</body></methods><methods><class-id>Glorp.WeakVWCachePolicy</class-id> <category>initialize-release</category><body package="GlorpCore" selector="newItemsIn:">newItemsIn: aCache	| items |	items := super newItemsIn: aCache.	items manager: aCache.	^items.</body></methods><methods><class-id>Glorp.TableSorter</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="addTable:">addTable: aTable 	tables add: aTable</body><body package="GlorpUnitOfWork" selector="hasBeenVisited:">hasBeenVisited: aTable	^visitedTables includes: aTable.</body><body package="GlorpUnitOfWork" selector="markVisited:">markVisited: aTable	visitedTables add: aTable.</body></methods><methods><class-id>Glorp.TableSorter</class-id> <category>initializing</category><body package="GlorpUnitOfWork" selector="initialize">initialize	tables := OrderedCollection new: 100.	visitedTables := IdentitySet new: 100.</body></methods><methods><class-id>Glorp.TableSorter</class-id> <category>sorting</category><body package="GlorpUnitOfWork" selector="sort">sort	orderedTables := OrderedCollection new: tables size.	tables do: [:each | self visit: each].	^orderedTables select: [:each | tables includes: each].</body><body package="GlorpUnitOfWork" selector="visit:">visit: aTable 	"The essential bit of topological sort. Visit each node in post-order, traversing dependencies, based on foreign key constraints to database-generated fields. "	(self hasBeenVisited: aTable) ifTrue: [^self].	self markVisited: aTable.	self visitDependentTablesFor: aTable.	orderedTables add: aTable</body><body package="GlorpUnitOfWork" selector="visitDependentTablesFor:">visitDependentTablesFor: aTable 	aTable foreignKeyConstraints do: [:eachConstraint |           self visit: eachConstraint targetTable.]</body></methods><methods><class-id>Glorp.TableSorter class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="for:">for: tables	| sorter |	sorter := self new.	tables do: [:each |		sorter addTable: each].	^sorter.</body><body package="GlorpUnitOfWork" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	^self platform converterNamed: #numberToDouble.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Dialect doublePrecisionFloatClass.</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Double.</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'double precision'.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	^false.</body><body package="GlorpDatabase" selector="charactersThatNeedEscaping">charactersThatNeedEscaping	^#($' $\)</body><body package="GlorpDatabase" selector="initializeReservedWords">initializeReservedWords	reservedWords := Set new.	reservedWords 		add: 'key'.</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)	Don't know the answer for this platform;  make something large up."	^64</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	"Don't know, make something large up."	^64</body><body package="GlorpDatabase" selector="nameForPrimaryKeyConstraintsWhenDropping">nameForPrimaryKeyConstraintsWhenDropping	"Return the name we use to describe a constraint when dropping them. This is required because MySQL wants you to use 'DROP PRIMARY KEY' rather than the ANSI 'DROP CONSTRAINT'."	^'PRIMARY KEY'.</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	^false.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="blob">blob	"Return the MySQL type for long blob."	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'LONGBLOB'].</body><body package="GlorpDatabase" selector="clob">clob	"Return the MySQL type for long text."	^self typeNamed: #clob ifAbsentPut: [GlorpMySQLClobType new typeString: 'LONGTEXT'].</body><body package="GlorpDatabase" selector="date">date	"Return the type we use to represent dates."	^self typeNamed: #date ifAbsentPut: [GlorpDateType new].</body><body package="GlorpDatabase" selector="double">double	^self typeNamed: #double ifAbsentPut: [GlorpDoubleType new typeString: 'double' ].</body><body package="GlorpDatabase" selector="float">float	^self typeNamed: #float ifAbsentPut: [GlorpFloatType new typeString: 'float' ].</body><body package="GlorpDatabase" selector="float4">float4	^self float.</body><body package="GlorpDatabase" selector="float8">float8	^self double.</body><body package="GlorpDatabase" selector="int2">int2	^self smallint</body><body package="GlorpDatabase" selector="int4">int4	^self typeNamed: #int4 ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase" selector="int8">int8	^self typeNamed: #int8 ifAbsentPut: [GlorpIntegerType new typeString: 'bigint'].</body><body package="GlorpDatabase" selector="integer">integer	^self typeNamed: #integer ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase" selector="number">number	^self typeNamed: #number ifAbsentPut: [GlorpNumericType new typeString: 'decimal'].</body><body package="GlorpDatabase" selector="sequence">sequence	^self serial.</body><body package="GlorpDatabase" selector="serial">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'int AUTO_INCREMENT'].</body><body package="GlorpDatabase" selector="smallint">smallint	^self typeNamed: #smallint ifAbsentPut: [GlorpSmallIntType new typeString: 'SMALLINT'].</body><body package="GlorpDatabase" selector="time">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time'].</body><body package="GlorpDatabase" selector="timestamp">timestamp	"Although MySQL has a type called 'timestamp', 'datetime' is more suitable."	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'DATETIME'].</body><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:extraInformation:">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: extraValue	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	extraValue = 'auto_increment' ifTrue: [^self serial].	^super typeWithDatabaseName: aString characterWidth: aNumber.</body><body package="GlorpDatabase" selector="varchar">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new].</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="canUseInWhereClause:type:">canUseInWhereClause: aValue type: aType	"This is mostly for test support purposes. If we know we can't use a particular kind of value in the where clause on some database, don't try."	(super canUseInWhereClause: aValue type: aType) ifFalse: [^false].	"On MySQL we don't seem to be able to compare constants against blobs."	aType = self blob ifTrue: [^false].	^true.</body><body package="GlorpDatabase" selector="isMySQLPlatform">isMySQLPlatform	^true.</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true.</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"MySQL supports binding, although early versions didn't."	^true.</body><body package="GlorpDatabase" selector="supportsDecimalsOnAllNumerics">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^false.</body><body package="GlorpDatabase" selector="supportsIntersect">supportsIntersect	"Do we support operations like UNION ALL And INTERSECT."	^false.</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	^false.</body><body package="GlorpDatabase" selector="usesIdentityColumns">usesIdentityColumns	^true.</body><body package="GlorpDatabase" selector="usesInformationSchema">usesInformationSchema	^true</body><body package="GlorpDatabase" selector="usesPrimaryKeyUniqueConstraintNames">usesPrimaryKeyUniqueConstraintNames	"When dropping/creating primary key constraints, do they have distinguished names."	^false.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="endColumnQuote">endColumnQuote	"Return the character used to start quoting the name of a column so that we can avoid conflicts with reserved names. The default MySQL quoting is to use backquotes rather than the ANSI style."	^'`'.</body><body package="GlorpDatabase" selector="startColumnQuote">startColumnQuote	"Return the character used to start quoting the name of a column so that we can avoid conflicts with reserved names. The default MySQL quoting is to use backquotes rather than the ANSI style."	^'`'.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDate for: aType	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $".	self		printDate: aDate		isoFormatOn: stream.	stream nextPut: $".	^stream contents.</body><body package="GlorpDatabase" selector="printTime:for:">printTime: aTime for: aType	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $".	self		printTime: aTime		isoFormatOn: stream		milliseconds: false.	stream nextPut: $".	^stream contents.</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPut: $".	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream		milliseconds: false.	stream nextPut: $".</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="stringToByteArrayOneWayConverter">stringToByteArrayOneWayConverter	"This is a special converter for MySQL that is a null conversion on the way out, but converts the byte arrays that we get back from blobs into strings."	^DelegatingDatabaseConverter		named: #stringToByteArrayOneWay		hostedBy: self		fromStToDb: #nullConversion:for:		fromDbToSt: #byteArrayToString:for:.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	^MySQLSequence.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>database-specific</category><body package="GlorpDatabase" selector="queryWithUnsupportedOperationsEliminatedFrom:do:">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	| newQuery |	newQuery := aQuery rewriteIntersect.	newQuery := newQuery rewriteExcept.	newQuery == aQuery ifFalse: [aBlock value: newQuery].</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>accessing</category><body package="GlorpDatabase" selector="vwEXDIConnectionClass">vwEXDIConnectionClass	^'MySQLConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'MySQLEXDI'</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services constraints</category><body package="GlorpDatabase" selector="writeConstraintToDrop:onStream:">writeConstraintToDrop: aConstraint onStream: aStream	"Return the term we use to describe a constraint when dropping them.  This is required because MySQL wants you to use		'DROP PRIMARY KEY' for primary key constraints (and then says don't name the constraint name in the drop statement!)		'DROP FOREIGN KEY'  for foreign key constraints		'DROP KEY' for unique constraints (it also supports DROP INDEX for this)	rather than the ANSI 'DROP CONSTRAINT'."	aConstraint isForeignKeyConstraint ifTrue: [aStream nextPutAll: 'FOREIGN KEY'].	aConstraint isPrimaryKeyConstraint ifTrue: [aStream nextPutAll: 'PRIMARY KEY'].	aConstraint isUniqueConstraint ifTrue: [aStream nextPutAll: 'KEY'].	aConstraint isPrimaryKeyConstraint ifFalse:		[aStream			nextPut: $ ;			nextPutAll: aConstraint name].</body></methods><methods><class-id>Glorp.MySQLPlatform class</class-id> <category>*eoglorp</category><body package="GlorpDatabase" selector="createLoginFromConnectionDictionary:">createLoginFromConnectionDictionary: aDict	" *** This method was defined by Glorp.DatabasePlatform class as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="basicReferenceDescriptor">basicReferenceDescriptor	^self system descriptorFor: self basicReferenceClass.</body><body package="GlorpMappings" selector="field">field	^self valueField.</body><body package="GlorpMappings" selector="keyField">keyField	^keyMapping field.</body><body package="GlorpMappings" selector="keyField:">keyField: aDatabaseField	keyMapping := self newMapping: DirectMapping.	keyMapping attributeName: #key.	keyMapping from: #key to: aDatabaseField.</body><body package="GlorpMappings" selector="keyMapping">keyMapping	^keyMapping</body><body package="GlorpMappings" selector="keyMapping:">keyMapping: aMapping	keyMapping := aMapping</body><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	| fields |	fields := super mappedFields copy.	fields addAll: keyMapping mappedFields.	valueMapping isNil ifFalse: [		fields addAll: valueMapping mappedFields].	^fields.</body><body package="GlorpMappings" selector="name">name	"This can get called when we're masquering as a class, for purposes of indexing descriptors, so just print something useful"	^self printString.</body><body package="GlorpMappings" selector="referenceClass">referenceClass	"Return ourselves as the reference class, as a sort of a proxy for what we really want, which is a primitive, and varies according to the relationship anyway. Note that we have stuffed in a descriptor in the system, with ourselves (this instance) as the class.""	^self mapsSimpleObject ifTrue: [self] ifFalse: [super referenceClass]."	^self.</body><body package="GlorpMappings" selector="referenceDescriptor">referenceDescriptor	| ref |	ref := super referenceDescriptor.	^ref isNil 		ifTrue: [			"This means we haven't yet added our fake descriptor, and are in initialization, so just return the descriptor for the 'real' reference class"			self system descriptorFor: self basicReferenceClass]		ifFalse: [ref].</body><body package="GlorpMappings" selector="valueField">valueField	^valueMapping field.</body><body package="GlorpMappings" selector="valueField:">valueField: aDatabaseField	| mapping |	mapping := self newMapping: DirectMapping.	mapping attributeName: #value.	mapping from: #value to: aDatabaseField.	self valueMapping: mapping.</body><body package="GlorpMappings" selector="valueMapping">valueMapping	^valueMapping.</body><body package="GlorpMappings" selector="valueMapping:">valueMapping: aMapping	valueMapping := aMapping.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="associationClassModel">associationClassModel	| model |	model := GlorpClassModel for: Association.	model newAttributeNamed: #key.	model newAttributeNamed: #value.	^model.</body><body package="GlorpMappings" selector="associationDescriptor">associationDescriptor	associationDescriptor isNil ifTrue: [		associationDescriptor := Descriptor new.		associationDescriptor system: self system.		associationDescriptor classModel: self associationClassModel].	^associationDescriptor.</body><body package="GlorpMappings" selector="buildQuery">buildQuery	| keyExpression valueExpression |	query := super buildQuery.	keyExpression := self keyExpression.	valueExpression := self valueExpression.	query retrieveDictionaryWithKey: keyExpression value: valueExpression.	^query.</body><body package="GlorpMappings" selector="buildRowMapKeyForSource:target:index:">buildRowMapKeyForSource: source target: target index: index	^self mapsSimpleObject 		ifTrue: [			MultipleRowMapKey				with: target yourSelf				with: source yourSelf				with: index]		ifFalse: [super buildRowMapKeyForSource: source target: target index: index].</body><body package="GlorpMappings" selector="chooseBaseForMapping:from:and:">chooseBaseForMapping: aMapping from: base and: phantomExpression	aMapping isNil ifTrue: [^base].	^(aMapping mappedFields		allSatisfy: [:each | base tables includes: each table])		ifTrue: [base]		ifFalse: [phantomExpression].</body><body package="GlorpMappings" selector="keyExpression">keyExpression	"Return the expression to use for our key. The key can be built using data from either the target object, or from the link table, so build the expression on one or the other, as appropriate"	 | base intermediate |	base := BaseExpression new.	intermediate := (self descriptor tables includes: keyMapping mappedFields first table)		ifTrue: [base] 		ifFalse: [base getTable: keyMapping mappedFields first table].	^intermediate getMapping: keyMapping named: #key.</body><body package="GlorpMappings" selector="newMapping:">newMapping: aMappingClass	"Implement this so that we can create our sub-mappings without having them added to the parent descriptor as independent mappings"	| mapping |	mapping := aMappingClass new.	mapping descriptor: self associationDescriptor.	descriptor resetMappedFields.	^mapping.</body><body package="GlorpMappings" selector="pseudoDescriptor">pseudoDescriptor	"Return a pretend descriptor for our reference class. Since that class is a primitive, it won't have a real descriptor, and it may vary by usage anyway"	| pseudoDescriptor |	pseudoDescriptor := Descriptor new.	pseudoDescriptor system: descriptor system.	^pseudoDescriptor.</body><body package="GlorpMappings" selector="setGeneralQueryRetrievalIn:basedOn:phantom:">setGeneralQueryRetrievalIn: newQuery basedOn: base phantom: phantomExpression	| keyExpression valueExpression collType keyExpressionBase valueExpressionBase |	self descriptor primaryKeyMappings		do:			[:eachMapping | newQuery retrieve: (phantomExpression get: eachMapping attributeName)].	keyExpressionBase := self		chooseBaseForMapping: keyMapping		from: base		and: phantomExpression.	keyExpression := self keyExpression asGlorpExpressionOn: keyExpressionBase.	valueExpressionBase := self		chooseBaseForMapping: valueMapping		from: base		and: phantomExpression.	valueExpression := self valueExpression		asGlorpExpressionOn: valueExpressionBase.	collType := (GlorpDictionaryDescription new)		keyExpression: keyExpression;		valueExpression: valueExpression.	newQuery collectionType: collType.	newQuery retrieve: base.</body><body package="GlorpMappings" selector="valueExpression">valueExpression	 | base intermediate |	valueMapping isNil ifTrue: [ ^[:each | each value] ].	base := BaseExpression new.	intermediate := (self descriptor tables includes: valueMapping mappedFields first table)		ifTrue: [base] 		ifFalse: [base getTable: valueMapping mappedFields first table].	^intermediate getMapping: valueMapping named: #value.</body><body package="GlorpMappings" selector="writeExtraInformationInto:atKey:forSourceObject:targetObject:atIndex:">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject atIndex: eachKey	"Write out any additional information that goes in the link table or else the target table. That means our key, if necessary. If we have a specific value mapping, rather than just using the normal attributes of this mapping, then write that as well. That normally happens when our value is simple"		"We need to know if the key mapping is trying to write to the link table, or to the target. If it's to the link table, then we always use the row map key. If it's to the target table, then we need to use whatever is appropriate for the target table, which is a row map key if we have a simple target, and otherwise it's just the target object"	| target |	target := (keyMapping mappedTables includes: self linkTable)		ifTrue: [rowMapKey]		ifFalse: [self mapsSimpleObject ifTrue: [rowMapKey] ifFalse: [targetObject]].	keyMapping		mapFromObject: eachKey -&gt; nil		toTarget: target		puttingRowsIn: aRowMap.	valueMapping isNil ifTrue: [^self].	"I'm not sure this will ever be relevant. If the value mapping goes to the link table, then does that mean the key is really the value? And if so, why not just consider the other one to be the link?"	target := (valueMapping mappedTables includes: self linkTable)		ifTrue: [rowMapKey]		ifFalse: [self mapsSimpleObject ifTrue: [rowMapKey] ifFalse: [targetObject]].	valueMapping		mapFromObject: nil -&gt; targetObject		toTarget: target		puttingRowsIn: aRowMap.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="glorpCanHaveDescriptorDirectly">glorpCanHaveDescriptorDirectly	"We allow instances of ourselves to have a descriptor, which normally only classes can do. This is so that we can have multiple different descriptors in use for e.g. String, depending on the particular usage.""	^self mapsSimpleObject."	^true.</body><body package="GlorpMappings" selector="mapsSimpleObject">mapsSimpleObject	^valueMapping notNil and: [valueMapping mapsSimpleObject].</body><body package="GlorpMappings" selector="needsSpecialRowMapKey">needsSpecialRowMapKey	^super needsSpecialRowMapKey or: [		self mapsSimpleObject].</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>initializing</category><body package="GlorpMappings" selector="defaultCollectionType">defaultCollectionType	^Dictionary.</body><body package="GlorpMappings" selector="initialize">initialize	super initialize.	usesLinkTable := true.</body><body package="GlorpMappings" selector="initializeValueMapping">initializeValueMapping	| des |	self descriptor system privateAndBasicAddDescriptorFor: self as: self associationDescriptor.	(self associationDescriptor classModel attributeNamed: #key) type: self attribute keyType.	(self associationDescriptor classModel attributeNamed: #value) type: self attribute type.	des := self referenceDescriptor.	(des isNil or: [des tables isEmpty]) ifTrue: [self initializeValueMappingJoin].</body><body package="GlorpMappings" selector="initializeValueMappingJoin">initializeValueMappingJoin	| tables |	"We don't know which of these will come first in the descriptor, so call the other initialization if it looks like we have enough information, and it hasn't been done"	self referenceDescriptor isNil ifTrue: [self initializeValueMapping].	"Have we already done this?"	self referenceDescriptor tables isEmpty ifFalse: [^self].	tables := self targetTables asArray.	tables do: [:each | self referenceDescriptor addTable: each].	(self referenceDescriptor newMapping: DirectMapping) 		from: #key to: self keyField.	self mapsSimpleObject 		ifTrue: [			(self referenceDescriptor newMapping: DirectMapping) 			from: #value to: self valueField]		ifFalse: [			(self referenceDescriptor newMapping: OneToOneMapping)				attributeName: #value;					linkFields: self linkFields;				usesLinkTable: self usesLinkTable;				join: self join;				controlsTables: false].</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	self initializeValueMapping.	super validate.	self attribute isDictionaryAttribute		ifFalse: [self error: 'Dictionary Mapping that does not have a dictionary type in the attribute'].	"The reason you can't do this, is that we end up throwing away the primary key of the target table when we read in the objects, and we have no way to properly do deletes/updates without that information"	(self usesLinkTable and: [self mapsSimpleObject]) ifTrue: [self error: 'Dictionary mappings to simple objects cannot use a link table'].</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>attributes</category><body package="GlorpMappings" selector="attributesDo:">attributesDo: aBlock	attributes do: aBlock</body><body package="GlorpMappings" selector="newAttributeNamed:">newAttributeNamed: aSymbol	^self addAttribute: (GlorpAttributeModel named: aSymbol).</body><body package="GlorpMappings" selector="newAttributeNamed:collection:of:">newAttributeNamed: aSymbol collection: collectionClass of: aClass	^self addAttribute: (GlorpAttributeModel named: aSymbol collection: collectionClass of: aClass).</body><body package="GlorpMappings" selector="newAttributeNamed:collectionOf:">newAttributeNamed: aSymbol collectionOf: aClass	^self addAttribute: (GlorpAttributeModel named: aSymbol collectionOf: aClass).</body><body package="GlorpMappings" selector="newAttributeNamed:dictionaryFrom:to:">newAttributeNamed: aSymbol dictionaryFrom: keyClass to: valueClass	^self addAttribute: (GlorpAttributeModel named: aSymbol dictionaryFrom: keyClass to: valueClass).</body><body package="GlorpMappings" selector="newAttributeNamed:type:">newAttributeNamed: aSymbol type: aClass	^self addAttribute: (GlorpAttributeModel named: aSymbol type: aClass).</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>accessing</category><body package="GlorpMappings" selector="addAttribute:">addAttribute: anAttributeDescription	attributes add: anAttributeDescription.	anAttributeDescription classModel: self.	^anAttributeDescription.</body><body package="GlorpMappings" selector="attributeNamed:">attributeNamed: aSymbol	^attributes detect: [:each | each name = aSymbol] ifNone: [self newAttributeNamed: aSymbol].</body><body package="GlorpMappings" selector="attributeNamed:type:">attributeNamed: aSymbol type: aClass	^attributes		detect:			[:each | each name = aSymbol and: [each type isNil or: [each type = aClass]]]		ifNone: [self newAttributeNamed: aSymbol type: aClass].</body><body package="GlorpMappings" selector="attributeNamed:type:collectionType:">attributeNamed: aSymbol type: aClass collectionType: collectionClass	^attributes		detect:			[:each | 			| collectionTypeMatches typeMatches nameMatches |			nameMatches := each name = aSymbol.			typeMatches := each type isNil or: [each type = aClass].			collectionTypeMatches := each collectionType isNil				or: [each collectionType = collectionClass].			nameMatches &amp; typeMatches &amp; collectionTypeMatches]		ifNone: [self newAttributeNamed: aSymbol type: aClass].</body><body package="GlorpMappings" selector="attributes">attributes	^attributes.</body><body package="GlorpMappings" selector="describedClass">describedClass	^describedClass</body><body package="GlorpMappings" selector="describedClass:">describedClass: aClass	describedClass := aClass.	subclasses := aClass allSubclasses isEmpty ifTrue: [nil] ifFalse: [aClass allSubclasses asArray].</body><body package="GlorpMappings" selector="hasAttributeNamed:">hasAttributeNamed: aSymbol	attributes do: [:attribute | attribute name = aSymbol ifTrue: [^true]].	^false</body><body package="GlorpMappings" selector="system">system	^system</body><body package="GlorpMappings" selector="system:">system: aDescriptorSystem	system := aDescriptorSystem</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>printing</category><body package="GlorpMappings" selector="printOn:">printOn: aStream	aStream nextPutAll: '~~'.	self describedClass isNil ifFalse: [aStream nextPutAll: self describedClass name].	aStream nextPutAll: '~~'.</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>initializing</category><body package="GlorpMappings" selector="initialize">initialize	attributes := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>validation</category><body package="GlorpMappings" selector="matches:">matches: anObject	"Try to optimize this check as much as possible. We cache the list of subclasses, and inline the check for isKindOf:"	| theClass |	theClass := anObject glorpRealObject class.	describedClass == theClass ifTrue: [^true].	nil == subclasses ifTrue: [^false].	1 to: subclasses size do: [:i | theClass == (subclasses at: i)		ifTrue: [^true]].	^false.</body><body package="GlorpMappings" selector="validateIn:">validateIn: aDescriptorSystem 	attributes do: [:each | each validate]</body></methods><methods><class-id>Glorp.GlorpClassModel class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="for:">for: aClass	^self new describedClass: aClass.</body><body package="GlorpMappings" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>accessing</category><body package="GlorpExpressions" selector="add:">add: anExpression	anExpression isNil ifTrue: [^self].	children add: anExpression.</body><body package="GlorpExpressions" selector="addAll:">addAll: anExpressionCollection	anExpressionCollection isNil ifTrue: [^self].	children addAll: anExpressionCollection.</body><body package="GlorpExpressions" selector="children">children	^children.</body><body package="GlorpExpressions" selector="isEmpty">isEmpty	^self size = 0.</body><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^nil.</body><body package="GlorpExpressions" selector="size">size	^children size.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>initialize</category><body package="GlorpExpressions" selector="initialize">initialize	super initialize.	children := OrderedCollection new.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	children do: 	[:each | each do: aBlock skipping: aSet].	aBlock value: self.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>printing</category><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream	children do: [:each |		aStream nextPut: $(.		each printOn: aStream.		aStream nextPut: $).		aStream cr].</body></methods><methods><class-id>Glorp.ExpressionGroup class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="with:">with: anExpression	^self new add: anExpression.</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>testing</category><body package="GlorpDatabase" selector="isSQLite3Platform">isSQLite3Platform	^true</body><body package="GlorpDatabase" selector="requiresTransactionForTableOperations">requiresTransactionForTableOperations	^false</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax."	^true.</body><body package="GlorpDatabase" selector="supportsAlterTableForConstraints">supportsAlterTableForConstraints	^false</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"Return true if this platform supports binding parameters rather than printing them as strings into the SQL statement"	^true.</body><body package="GlorpDatabase" selector="supportsSchemaForLogin">supportsSchemaForLogin	^false</body><body package="GlorpDatabase" selector="supportsSchemas">supportsSchemas	^false</body><body package="GlorpDatabase" selector="supportsStringQueryOnBlobs">supportsStringQueryOnBlobs	"This is something of a guess but I see no evidence that SQLite does and the relevant test certainly fails."	^false</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	^false.</body><body package="GlorpDatabase" selector="usesIdentityColumns">usesIdentityColumns	^true.</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	^false</body><body package="GlorpDatabase" selector="canBind:to:">canBind: aValue to: aType	"See #supportsVariableSizedNumerics comment."	(Dialect isVisualWorks and: [aValue class == Dialect fixedPointClass]) ifTrue: [^false].	^super canBind: aValue to: aType</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"It is the boast of SQLite that their limits are only for stability purposes:  if it fits in 32 bits then they will handle it.  Since the maximum length of an SQL statement is limited to SQLITE_MAX_LENGTH (defaults to 1000000, cannot be higher than 1073741824), table names had better be shorter and in normal use should be much shorter.  I chose the number below at random;  change it if it causes you any inconvenience."	^128</body><body package="GlorpDatabase" selector="parenthesizeCommandsInCompoundQuery">parenthesizeCommandsInCompoundQuery	^false</body><body package="GlorpDatabase" selector="supportsAuthentication">supportsAuthentication	"SQLite does not support authentication:  anyone can login with any username and password.  The only security is that provided by the OS for the file being used as the database."	^false</body><body package="GlorpDatabase" selector="supportsConstraints">supportsConstraints	"Return false, because this platform does not support constraint add or drop statements.	However, foreign key constraints can be created as part of the create table statement.	Also, a foreign key constraint can be created in the statement that adds that column to	the table. (Eg., ALTER TABLE ADD COLUMN ...)."	^false</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	"The only time-type-related functions in SQLite are CURRENT_TIME format HH:MM:SS and CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SS, neither of which support milliseconds.  As against that, since we map to and from strings, we can easily include milliseconds in these strings.  For now, I go with the SQLite function choice and say no, but I have verified that tests work fine when I set this to true."	^false</body><body package="GlorpDatabase" selector="supportsVariableSizedNumerics">supportsVariableSizedNumerics	"SQLite supports a single 8-byte IEEE floating point type:  e.g. give it 321.12s and it will return 321.12d.  Perhaps clever Glorp converters could arrange for Glorp to know which fields are really FixedPoint numbers, as we do for Date, Time and Timestamp (which SQLite also does not support) but I'll leave that until there's demand for it (ee also #canBind:to:)."	^false</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>types</category><body package="GlorpDatabase" selector="date">date	"SQLite does not support any time-related types;  use text as the type and convert in readDate.../toDate..."	^self typeNamed: #date ifAbsentPut: [GlorpDateType new typeString: 'date']</body><body package="GlorpDatabase" selector="double">double	^self typeNamed: #double ifAbsentPut: [GlorpDoubleType new typeString: 'double' ].</body><body package="GlorpDatabase" selector="float4">float4	"The only kind of REAL that SQLite supports is an 8-byte IEEE floating point number, so we just map float4 to float8."	^self double</body><body package="GlorpDatabase" selector="float8">float8	"The only kind of REAL that SQLite supports is an 8-byte IEEE floating point number."	^self double</body><body package="GlorpDatabase" selector="int2">int2	^self smallint.</body><body package="GlorpDatabase" selector="int4">int4	^self typeNamed: #int4 ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase" selector="int8">int8	^self int4.</body><body package="GlorpDatabase" selector="nvarchar">nvarchar	^self text</body><body package="GlorpDatabase" selector="sequence">sequence	^self serial</body><body package="GlorpDatabase" selector="serial">serial	"In SQLLite, the column declared as INTEGER PRIMARY KEY will default to ROWID, unless the inserted value is not null. But in Sqlite3 a declaration like: INTEGER PRIMARY KEY AUTOINCREMENT will cause ROWID to be fetched from the sqlite_sequence table, which provides always increasing values."	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'INTEGER PRIMARY KEY AUTOINCREMENT'].</body><body package="GlorpDatabase" selector="text">text	^self typeNamed: #nvarchar ifAbsentPut: [GlorpTextType new typeString: 'text']</body><body package="GlorpDatabase" selector="time">time	"SQLite does not support any time-related types;  use text as the type and convert in readTime.../toTime..."	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time']</body><body package="GlorpDatabase" selector="timestamp">timestamp	"SQLite does not support any time-related types;  use text as the type and convert in readTimestamp.../toTimestamp..."	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'timestamp']</body><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:">typeWithDatabaseName: aString characterWidth: aNumber	"Since this is SQLite, let the type names be more flexible."	| aTypeName total block |	block := [:sum :name | sum + (aString asLowercase findString: name startingAt: 1)].	aTypeName := aString.	total := #('char' 'clob' 'text') inject: 0 into: block.	total &gt; 0		ifTrue: [aTypeName := 'text']		ifFalse: 			[total := #('num' 'double' 'float') inject: 0 into: block.			total &gt; 0				ifTrue: [aTypeName := 'numeric']				ifFalse: 					[total := #('int') inject: 0 into: block.					total &gt; 0						ifTrue: [aTypeName := 'integer']						ifFalse: 							[total := #('blob') inject: 0 into: block.							total &gt; 0 ifTrue: [aTypeName := 'blob']]]].	aString isEmpty ifTrue: [aTypeName := 'blob'].	^super typeWithDatabaseName: aTypeName characterWidth: aNumber</body><body package="GlorpDatabase" selector="varbinary">varbinary	" *** This method was defined by Glorp.DatabasePlatform as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpDatabase" selector="varchar">varchar	^self text.</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDateString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form '1959-09-30'."	aDateString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aDateString class = Date ifTrue: [self error: 'SQLite does not support date types;  this should have been a String'].	^aDateString printString</body><body package="GlorpDatabase" selector="printTime:for:">printTime: aTimeString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form 10:20:23."	aTimeString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aTimeString class = Time ifTrue: [self error: 'SQLite does not support time types;  this should have been a String'].	^aTimeString printString</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestampString on: stream for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form '1959-03-27 10:20:23'."	aTimestampString isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aTimestampString class = Timestamp ifTrue: [self error: 'SQLite does not support timestamp types;  this should have been a String'].	stream nextPut: $'.	stream nextPutAll: aTimestampString.	stream nextPut: $'.</body><body package="GlorpDatabase" selector="toDate:for:">toDate: anObject for: aType	"SQLite does not handle timestamps;  all such must be treated as strings and the to... and read... formats must agree.  SQLite does use column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSso our string conversions must agree with these formats."	| stream |	anObject isNil ifTrue: [^nil].	stream := String new writeStream.	self		printDate: (super toDate: anObject for: aType)		isoFormatOn: stream.	^stream contents</body><body package="GlorpDatabase" selector="toTime:for:">toTime: anObject for: aType	"SQLite does not handle timestamps;  all such must be treated as strings and the to... and read... formats must agree.  SQLite does use column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSso our string conversions must agree with these formats."	| stream |	anObject isNil ifTrue: [^nil].	stream := String new writeStream.	self		printTime: (super toTime: anObject for: aType)		isoFormatOn: stream.	^stream contents</body><body package="GlorpDatabase" selector="toTimestamp:for:">toTimestamp: anObject for: aType	"SQLite does not handle timestamps;  all such must be treated as strings and the to... and read... formats must agree.  SQLite does use column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSso our string conversions must agree with these formats."	| stream timestampObject |	anObject isNil ifTrue: [^nil].	stream := String new writeStream.	timestampObject := super toTimestamp: anObject for: aType.	self		printDate: timestampObject		isoFormatOn: stream.	stream space.	self		printTime: timestampObject		isoFormatOn: stream.	^stream contents</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>accessing</category><body package="GlorpDatabase" selector="vwEXDIConnectionClass">vwEXDIConnectionClass	^'SQLite3Connection' asQualifiedReference valueIfUndefinedLoadFrom: 'SQLite3EXDI'</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	^SQLite3Sequence</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase" selector="convertIntegerToBoolean:for:">convertIntegerToBoolean: anInteger for: aType	"This method accomodates an error in earlier SQLite 3 dlls. For the table_info() PRAGMA, 99 means True."	anInteger isNil ifTrue: [^anInteger].	anInteger &gt;= 1 ifTrue: [^true].	anInteger = 0 ifTrue: [^false].	self error: 'invalid boolean conversion'</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="createTableStatementStringFor:">createTableStatementStringFor: aGLORPDatabaseTable 	"^&lt;String&gt; This method returns a string which can be used to create a database table ..."	| sqlStatementStream tmpString fkeys |	tmpString := 'create table'.	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: (self capitalWritingOfSQLCommands 					ifTrue: [tmpString asUppercase]					ifFalse: [tmpString]);		space.	self printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream.	"Now print the columns specification for each field in the table ..."	self printColumnsSpecificationFor: aGLORPDatabaseTable		on: sqlStatementStream.	"Print the primary key constraint, unless using serial pkeys, since it would be a redundant declaration."	(aGLORPDatabaseTable hasPrimaryKeyConstraints and: [aGLORPDatabaseTable primaryKeyFields first type isSerial not])			ifTrue: [sqlStatementStream nextPutAll: ', '.					(aGLORPDatabaseTable primaryKeyConstraints creationStringFor: self)						do: [ :each | sqlStatementStream nextPutAll: each.]						separatedBy: [sqlStatementStream nextPut: $,]].	fkeys := aGLORPDatabaseTable foreignKeyConstraintsForCreation.	fkeys notEmpty			ifTrue: [sqlStatementStream nextPutAll: ', '.					(fkeys collect: [:each| self createForeignKeyConstraintAddStatement: each])						do: [ :each | sqlStatementStream nextPutAll: each first]						separatedBy: [sqlStatementStream nextPut: $,]].	sqlStatementStream		nextPut: $).	^sqlStatementStream contents</body><body package="GlorpDatabase" selector="printSqlStatementToListTablesInSchema:on:">printSqlStatementToListTablesInSchema: schemaString on: aStream	"SQLite3 uses a readonly system table "	aStream		nextPutAll: 'SELECT name as table_name FROM sqlite_master ';		nextPutAll: 'WHERE type = ';		nextPut: $';		nextPutAll: 'table';		nextPut: $';		nextPut: $;</body><body package="GlorpDatabase" selector="printSqlStatementToTestExistenceOfTable:inSchema:on:">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	"SQLite3 uses a readonly system table and doesn't support schemas, as far as I know"	| lowerTableName |	lowerTableName := tableName asLowercase.	aStream		nextPutAll: 'SELECT count(*) FROM sqlite_master ';		nextPutAll: 'WHERE lower(name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $';		nextPutAll: ' AND type = ';		nextPut: $';		nextPutAll: 'table';		nextPut: $';		nextPut: $;</body></methods><methods><class-id>Glorp.CannotAutomaticallyDetermineJoin</class-id> <category>accessing</category><body package="GlorpMisc" selector="constraints">constraints	constraints isNil ifTrue: [constraints := #()].	^constraints</body><body package="GlorpMisc" selector="constraints:">constraints: aCollection	constraints := aCollection</body><body package="GlorpMisc" selector="defaultMessageText">defaultMessageText	^'Cannot calculate the join automatically, not enough information.'.</body><body package="GlorpMisc" selector="tables">tables	^tables</body><body package="GlorpMisc" selector="tables:">tables: databaseTables	tables := databaseTables</body></methods><methods><class-id>Glorp.VersionNumberVersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="nextValueFor:in:">nextValueFor: aField in: aRow	| oldValue |	oldValue := aRow at: aField ifAbsent: [0].	^(oldValue isNil ifTrue: [0] ifFalse: [oldValue]) + 1</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	^'sysname'.</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="isStringType">isStringType	^true.</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^String.</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#String.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="addAllKeys:">addAllKeys: aKeyCollection	keys addAll: aKeyCollection.</body><body package="GlorpUnitOfWork" selector="addKey:">addKey: aKey	keys add: aKey.</body><body package="GlorpUnitOfWork" selector="keys">keys	^keys.</body><body package="GlorpUnitOfWork" selector="keys:">keys: aCollection	keys := (aCollection asSortedCollection: self sortBlock).</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>printing</category><body package="GlorpUnitOfWork" selector="printOn:">printOn: aStream	aStream nextPutAll: 'KEY('.	self hash printOn: aStream.	aStream nextPutAll: '):'.	keys printOn: aStream.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork" selector="adjustIn:">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted keys: (keys collect: [:each | aCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body><body package="GlorpUnitOfWork" selector="reverseAdjustIn:">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the originals rather than the copies"	| adjusted |	adjusted := self copy.	adjusted keys: (keys collect: [:each | 		aRowMapForMementos reversedCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>initialize-release</category><body package="GlorpUnitOfWork" selector="initialize">initialize	keys := (SortedCollection new: 4) sortBlock: self sortBlock.</body><body package="GlorpUnitOfWork" selector="sortBlock">sortBlock	^[:a :b | a identityHash &lt;= b identityHash].</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>comparing</category><body package="GlorpUnitOfWork" selector="=">= aRowMapKey	aRowMapKey class == self class ifFalse: [^false].	aRowMapKey keys size = keys size ifFalse: [^false].	"We can't rely on the order being the same because of the obscure but real case of two different related objects with the same identityHash"	aRowMapKey keys do: [:each |		(keys includes: each) ifFalse: [^false]].	^true.</body><body package="GlorpUnitOfWork" selector="hash">hash	"Note: the two things with the same identity hash problem is OK here because if they do then the hashes are (by definition) the same, and the order doesn't matter"	| increment hash |	increment := 14 // keys size.	hash := 0.	keys doWithIndex: [:each :index |		hash := hash bitXor: (each identityHash bitShift: increment * index)].	^hash.</body></methods><methods><class-id>Glorp.MultipleRowMapKey class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="GlorpUnitOfWork" selector="with:with:with:">with: key1 with: key2 with: key3	(key1 isNil or: [key2 isNil or: [key3 isNil]]) ifTrue: [self error: 'Nil key in row map, probably indicates an invalid object structure'].	^self new 		addKey: key1;		addKey: key2;		addKey: key3;		yourself.</body><body package="GlorpUnitOfWork" selector="withAll:">withAll: aCollection		^self new 		addAllKeys: aCollection;		yourself.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>private/mapping</category><body package="GlorpUnitOfWork" selector="adjustForMementos:">adjustForMementos: objects	^self.</body><body package="GlorpUnitOfWork" selector="collectionMementoFor:">collectionMementoFor: aCollection	^aCollection.</body><body package="GlorpUnitOfWork" selector="dictionaryClassRequiredForKey:">dictionaryClassRequiredForKey: anObject	^(self isRowMapKey: anObject)		ifTrue: [Dictionary]		ifFalse: [IdentityDictionary].</body><body package="GlorpUnitOfWork" selector="reverseLookup:">reverseLookup: anObject	^anObject.</body><body package="GlorpUnitOfWork" selector="rowsForKey:">rowsForKey: aKey	"Return a collection of all rows for any table which are keyed by aKey"	| rowsForKey |	rowsForKey := OrderedCollection new: 5.	rowDictionary		do:			[:each | 			| row |			row := each at: aKey ifAbsent: [nil].			(row notNil and: [(self isDeleted: row) not]) ifTrue: [rowsForKey add: row]].	^rowsForKey.</body><body package="GlorpUnitOfWork" selector="subMapForTable:">subMapForTable: aTable		^self subMapForTable: aTable withKey: nil.</body><body package="GlorpUnitOfWork" selector="subMapForTable:ifAbsent:">subMapForTable: aTable ifAbsent: aBlock 	^rowDictionary at: aTable ifAbsent: aBlock</body><body package="GlorpUnitOfWork" selector="subMapForTable:withKey:">subMapForTable: aTable withKey: anObject 	anObject isGlorpProxy ifTrue: [self halt].	^rowDictionary at: aTable		ifAbsentPut: [(self dictionaryClassRequiredForKey: anObject) new]</body><body package="GlorpUnitOfWork" selector="tables">tables	^rowDictionary keys.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>iterating</category><body package="GlorpUnitOfWork" selector="keysAndValuesDo:">keysAndValuesDo: aBlock 	self tables do: [:each | 		(self subMapForTable: each) keysAndValuesDo: aBlock].</body><body package="GlorpUnitOfWork" selector="objects">objects	| objects |	objects := IdentitySet new.	self tables do: [:each | objects addAll: (self subMapForTable: each) keys].	^objects</body><body package="GlorpUnitOfWork" selector="objectsAndRowsDo:">objectsAndRowsDo: aTwoArgumentBlock	rowDictionary		do:			[:eachObjectToRowDictionary | 			eachObjectToRowDictionary				keysAndValuesDo:					[:key :value | 					(self isDeleted: value)						ifFalse: [aTwoArgumentBlock value: key value: value]]].</body><body package="GlorpUnitOfWork" selector="objectsAndRowsForTable:do:">objectsAndRowsForTable: aTable do: aTwoArgumentBlock	^(self subMapForTable: aTable)		keysAndValuesDo:			[:key :value | 			(self isDeleted: value)				ifFalse: [aTwoArgumentBlock value: key value: value]].</body><body package="GlorpUnitOfWork" selector="objectsDo:">objectsDo: aBlock	self tables		do:			[:each | 			(self subMapForTable: each)				keysAndValuesDo:					[:key :value | (self isDeleted: value) ifFalse: [aBlock value: key]]].</body><body package="GlorpUnitOfWork" selector="rowsDo:">rowsDo: aBlock 	self tables do: [:each | self rowsForTable: each do: aBlock]</body><body package="GlorpUnitOfWork" selector="rowsForTable:do:">rowsForTable: aTable do: aBlock	^(self subMapForTable: aTable)		keysAndValuesDo:			[:key :value | (self isDeleted: value) ifFalse: [aBlock value: value]].</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>testing</category><body package="GlorpUnitOfWork" selector="isEmpty">isEmpty	self compress.	self rowsDo: [:each | (self isDeleted: each) ifFalse: [^false]].	^true.</body><body package="GlorpUnitOfWork" selector="notEmpty">notEmpty	^self isEmpty not</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>lookup</category><body package="GlorpUnitOfWork" selector="addRow:">addRow: aRow	^self addRow: aRow forTable: aRow table withKey: aRow owner.</body><body package="GlorpUnitOfWork" selector="addRow:forTable:withKey:">addRow: aRow forTable: aTable withKey: aKey 	| submap |	aKey isGlorpProxy ifTrue: [self halt].	submap := self subMapForTable: aTable withKey: aKey.	submap at: aKey put: aRow.	^aRow.</body><body package="GlorpUnitOfWork" selector="deleteRowForTable:withKey:ifAbsent:">deleteRowForTable: aTable withKey: aKey ifAbsent: aBlock	"Don't actually delete, the fixup of the hash tables is too expensive. Mark invisible instead, overloading the status variable that we know we're not using until later"	| row |	row := (self subMapForTable: aTable) at: aKey ifAbsent: aBlock.	row isNil ifFalse: [self privateDeleteRow: row].</body><body package="GlorpUnitOfWork" selector="includesRowForTable:withKey:">includesRowForTable: aTable withKey: aKey	| row |	row := (self subMapForTable: aTable ifAbsent: [^false]) at: aKey ifAbsent: [^false].	^(self isDeleted: row) not.</body><body package="GlorpUnitOfWork" selector="rowForTable:withKey:">rowForTable: aTable withKey: aKey 	^self rowForTable: aTable withKey: aKey ifAbsent: [self error: 'missing element'].</body><body package="GlorpUnitOfWork" selector="rowForTable:withKey:ifAbsent:">rowForTable: aTable withKey: aKey ifAbsent: aBlock	| row |	row := (self subMapForTable: aTable) at: aKey ifAbsent: aBlock.	^(self isDeleted: row) ifTrue: [aBlock value] ifFalse: [row].</body><body package="GlorpUnitOfWork" selector="rowForTable:withKey:ifPresent:">rowForTable: aTable withKey: aKey ifPresent: aBlock	^(self subMapForTable: aTable)		at: aKey		ifPresent:			[:row | (self isDeleted: row) ifTrue: [nil] ifFalse: [aBlock value: row]].</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>set operations</category><body package="GlorpUnitOfWork" selector="additiveDifferencesFrom:into:">additiveDifferencesFrom: aRowMap into: differencesMap	"Add everything which is in us, but not in aRowMap into differencesMap"	| newRow |	self objectsAndRowsDo: [:object :row |		| correspondingRow |		correspondingRow := aRowMap			rowForTable: row table			withKey: object			ifAbsent: [DatabaseRow new].		(row equals: correspondingRow)			ifFalse:				[newRow := differencesMap					addRow: (row withAllFieldsIn: correspondingRow)					forTable: row table					withKey: object.				newRow forDeletion: row forDeletion]].</body><body package="GlorpUnitOfWork" selector="differenceFrom:">differenceFrom: aMementoRowMap	| differencesMap |	differencesMap := RowMap new.	self	additiveDifferencesFrom: aMementoRowMap into: differencesMap.	self	subtractiveDifferencesFrom: aMementoRowMap into: differencesMap.	^differencesMap.</body><body package="GlorpUnitOfWork" selector="subtractiveDifferencesFrom:into:">subtractiveDifferencesFrom: aRowMap into: differencesMap	"Figure out which things are in aRowMap but not in us. These should be flagged as delete rows. Since we have no further use for aRowMap after this, we can compute this destructively by removing everything that's in us"	self objectsAndRowsDo: [:object :row |		aRowMap			deleteRowForTable: row table			withKey: object			ifAbsent: []].	aRowMap		objectsAndRowsDo:			[:object :row | 			| adjustedObject |			adjustedObject := (aRowMap reverseLookup: object).			row forDeletion: true.			differencesMap				addRow: row				forTable: row table				withKey: adjustedObject].</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>api</category><body package="GlorpUnitOfWork" selector="at:key:put:">at: aField key: anObject put: aValue	(self findOrAddRowForTable: aField table withKey: anObject) at: aField put: aValue.</body><body package="GlorpUnitOfWork" selector="findOrAddRowForTable:withKey:">findOrAddRowForTable: aTable withKey: aKey	| submap row |	submap := self subMapForTable: aTable withKey: aKey.	row := submap		at: aKey		ifAbsentPut: [DatabaseRow newForTable: aTable withOwner: aKey].	^(self isDeleted: row)		ifTrue:			[| newRow |			newRow := DatabaseRow newForTable: aTable withOwner: aKey.			submap at: aKey put: newRow.			newRow]		ifFalse: [row].</body><body package="GlorpUnitOfWork" selector="isRowMapKey:">isRowMapKey: anObject	^anObject class == RowMapKey or: [anObject class == MultipleRowMapKey].</body><body package="GlorpUnitOfWork" selector="mementoFor:">mementoFor: anObject	^anObject.</body><body package="GlorpUnitOfWork" selector="unifyField:key:withField:key:">unifyField: eachSourceField key: sourceObject withField: eachTargetField key: targetObject	| sourceRow targetRow |	sourceRow := self findOrAddRowForTable: eachSourceField table withKey: sourceObject.	targetRow := self findOrAddRowForTable: eachTargetField table withKey: targetObject.	sourceRow unifyField: eachSourceField withField: eachTargetField inRow: targetRow.</body><body package="GlorpUnitOfWork" selector="unifyField:key:withField:key:transformationForward:inverse:">unifyField: sourceField key: sourceObject withField: targetField key: targetObject transformationForward: forwardTransformation inverse: inverseTransformation	| sourceRow targetRow existingWrapper newWrapper |	sourceRow := self findOrAddRowForTable: sourceField table withKey: sourceObject.	targetRow := self findOrAddRowForTable: targetField table withKey: targetObject.	sourceRow unifyField: sourceField withField: targetField inRow: targetRow.	existingWrapper := targetRow wrapperAt: targetField.	(existingWrapper class == TransformingFieldValueWrapper and: [		existingWrapper forwardTransformation == forwardTransformation and: [			existingWrapper inverseTransformation == inverseTransformation]])				ifTrue: [^self].	newWrapper := (TransformingFieldValueWrapper new)		innerWrapper: existingWrapper;		forwardTransformation: forwardTransformation;		inverseTransformation: inverseTransformation.	targetRow wrapperAt: targetField put: newWrapper.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>initialize/release</category><body package="GlorpUnitOfWork" selector="initialize">initialize      self initialize: 17</body><body package="GlorpUnitOfWork" selector="initialize:">initialize: size	rowDictionary := IdentityDictionary new: size.	hasDeletions := false.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>counting</category><body package="GlorpUnitOfWork" selector="numberOfEntries">numberOfEntries	self compress.	^rowDictionary inject: 0 into: [:sum :each | sum + each size]</body><body package="GlorpUnitOfWork" selector="numberOfEntriesForTable:">numberOfEntriesForTable: aTable	self compress.	^(self subMapForTable: aTable) size.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>private/deletion</category><body package="GlorpUnitOfWork" selector="collapseMatchingInsertsAndDeletes">collapseMatchingInsertsAndDeletes	^rowDictionary		inject: IdentitySet new		into:			[:sum :eachTablesRowList | 			sum addAll: (self collapseMatchingInsertsAndDeletesFor: eachTablesRowList).			sum].</body><body package="GlorpUnitOfWork" selector="collapseMatchingInsertsAndDeletesFor:">collapseMatchingInsertsAndDeletesFor: eachTablesRows	"Find any inserts and deletes for these rows which have the same primary key. We expect these to be link table rows, because for rows that map to objects, object identity should ensure this never happens. Force the insert to be an update instead (by returning it to the calling method, which will force that to happen) and remove the deletion"	| deletions updates matchedDeletions deletion nonGeneratedFieldSize |	(self isSuitableForCollapsing: eachTablesRows) ifFalse: [^#()].	deletions := Dictionary new: 50.	updates := OrderedCollection new.	eachTablesRows do: [:each | each forDeletion ifTrue: [		deletions at: (each primaryKey) put: each]].	deletions isEmpty ifTrue: [^#()].	matchedDeletions := IdentitySet new: deletions size.	nonGeneratedFieldSize := (eachTablesRows detect: [:each | true]) nonGeneratedFields size.	eachTablesRows do: [:each |		| pk |		pk := each primaryKey.		((deletions includesKey: pk) and: [each forDeletion not]) ifTrue: [			each numberOfFields = nonGeneratedFieldSize ifFalse: [self error: 'link table entry requiring update is only partially populated'].			deletion := deletions at: pk.			(matchedDeletions includes: deletion)				ifFalse: [					"Now here's a very special case. If there are no non-primary key fields, then we collapse this down to a no-op. We've deleted and re-inserted with exactly the same information. However, we still leave it in the list of updated rows, because we want it to be put into the session cache if it's not already there at the end."					each table primaryKeyFields size = each fields size						ifTrue: [self privateDeleteRow: each].					updates add: each.					matchedDeletions add: deletion.					self privateDeleteRow: deletion]]].	^updates</body><body package="GlorpUnitOfWork" selector="compress">compress	"Remove all deleted rows and rebuild"	| newDictionary |	hasDeletions ifFalse: [^self].	Transcript cr; show: 'compressing'.	hasDeletions := false.	newDictionary := IdentityDictionary new: rowDictionary size.	rowDictionary keysAndValuesDo: [:eachTable :eachRowDict |		| newRowDict |		newRowDict := IdentityDictionary new: eachRowDict size.		eachRowDict keysAndValuesDo: [:eachObject :eachRow |			(self isDeleted: eachRow) ifFalse: [				newRowDict at: eachObject put: eachRow]].		newDictionary at: eachTable put: newRowDict].	rowDictionary := newDictionary.</body><body package="GlorpUnitOfWork" selector="isDeleted:">isDeleted: row	^row status == #invisible.</body><body package="GlorpUnitOfWork" selector="isSuitableForCollapsing:">isSuitableForCollapsing: eachTablesRows	"Return true if this set of rows are suitable for collapsing the inserts and deletes together. It's suitable if this is a link table, and if there is a primary key defined which we can use to decide if the rows match or not"	eachTablesRows isEmpty ifTrue: [^false].	eachTablesRows		keysAndValuesDo:			[:eachKey :eachRow | 				"(self isRowMapKey: eachKey) ifFalse: [^false]."				eachRow table primaryKeyFields isEmpty ifTrue: [^false].				^true ].</body><body package="GlorpUnitOfWork" selector="privateDeleteRow:">privateDeleteRow: row	row status: #invisible.	hasDeletions := true.</body></methods><methods><class-id>Glorp.RowMap class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="forRows:">forRows: aCollection	"Convenience - construct a row map from a given set of rows"	| map |	map := self new.	aCollection do: [:each | map addRow: each].	^map.</body><body package="GlorpUnitOfWork" selector="new">new	^super new initialize.</body><body package="GlorpUnitOfWork" selector="new:">new: size	^super new initialize: size.</body></methods><methods><class-id>Glorp.RowMapForMementos</class-id> <category>private/mapping</category><body package="GlorpUnitOfWork" selector="collectionMementoFor:">collectionMementoFor: aCollection	aCollection glorpIsCollection ifFalse: [^aCollection].	^collectionMementos at: aCollection ifAbsent: [correspondenceMap at: aCollection].</body><body package="GlorpUnitOfWork" selector="originalObjectFor:">originalObjectFor: anObject	^correspondenceMap at: anObject.</body><body package="GlorpUnitOfWork" selector="reverseLookup:">reverseLookup: anObject      (self isRowMapKey: anObject) ifTrue: [            ^anObject reverseAdjustIn: self].      ^ self reversedCorrespondenceMap at: anObject.</body></methods><methods><class-id>Glorp.RowMapForMementos</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="collectionMementos:">collectionMementos: aDictionary	collectionMementos := aDictionary.</body><body package="GlorpUnitOfWork" selector="correspondenceMap">correspondenceMap	^correspondenceMap</body><body package="GlorpUnitOfWork" selector="correspondenceMap:">correspondenceMap: anObject	correspondenceMap := anObject</body></methods><methods><class-id>Glorp.RowMapForMementos</class-id> <category>api</category><body package="GlorpUnitOfWork" selector="adjustForMementos:">adjustForMementos: objects	"We may be being passed row map keys that refer to originals when they should refer to mementos. Fix.This is horribly ugly."	1 to: objects size do: [:i | | possibleRowMapKey |		possibleRowMapKey := objects at: i.		(self isRowMapKey: possibleRowMapKey) ifTrue: [			objects at: i put: (possibleRowMapKey adjustIn: correspondenceMap)]].	^objects.</body><body package="GlorpUnitOfWork" selector="deleteRowForTable:withKey:ifAbsent:">deleteRowForTable: aTable withKey: aKey ifAbsent: aBlock	^super deleteRowForTable: aTable withKey: (self mementoFor: aKey) ifAbsent: aBlock.</body><body package="GlorpUnitOfWork" selector="findOrAddRowForTable:withKey:">findOrAddRowForTable: aTable withKey: aKey 	^super findOrAddRowForTable: aTable withKey: (self mementoFor: aKey).</body><body package="GlorpUnitOfWork" selector="mementoFor:">mementoFor: aKey	^(self isRowMapKey: aKey)		ifTrue: [aKey adjustIn: correspondenceMap]		ifFalse: [correspondenceMap at: aKey ifAbsent: [aKey]].</body><body package="GlorpUnitOfWork" selector="reversedCorrespondenceMap">reversedCorrespondenceMap	(reversedCorrespondenceMap isNil		or: [reversedCorrespondenceMap size ~= correspondenceMap size])		ifTrue:			[reversedCorrespondenceMap := IdentityDictionary				new: correspondenceMap size.			correspondenceMap				keysAndValuesDo: [:k :v | reversedCorrespondenceMap at: v put: k]].	^reversedCorrespondenceMap.</body><body package="GlorpUnitOfWork" selector="rowForTable:withKey:ifAbsent:">rowForTable: aTable withKey: aKey ifAbsent: aBlock	^super		rowForTable: aTable		withKey: (self mementoFor: aKey)		ifAbsent: aBlock.</body></methods><methods><class-id>Glorp.RowMapForMementos class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="withCorrespondenceMap:">withCorrespondenceMap: aDictionary	^self new		correspondenceMap: aDictionary.</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>accessing</category><body package="GlorpDatabase" selector="generateName">generateName	| stream maxLength tableLength roomToBeVerbose shortTableLength longTableLength |	(self fields isNil or: [self fields isEmpty]) ifTrue: [^'INVALID CONSTRAINT'].	"Figure out if we have room for verbose separators or if we should maximize the space for the table/field names"	maxLength := self fields first table platform maximumLengthOfTableName.	shortTableLength := ((maxLength - 7) // 2) min: 10.	longTableLength := (maxLength - 7).	roomToBeVerbose := shortTableLength &gt;= 10.	tableLength := roomToBeVerbose ifTrue: [longTableLength] ifFalse: [shortTableLength].	stream := WriteStream on: (String new: 100).	self printForConstraintNames: self fields on: stream maxLength: tableLength.	stream nextPutAll: (roomToBeVerbose ifTrue: ['_UNIQ'] ifFalse: ['U']).	^stream contents.</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>printing</category><body package="GlorpDatabase" selector="creationStringFor:">creationStringFor: aPlatform	^aPlatform createUniqueConstraintAddStatement: self</body><body package="GlorpDatabase" selector="printForConstraintNames:on:maxLength:">printForConstraintNames: aCollection on: aStream maxLength: maxLength 	| constraintName |	constraintName := self table name.	aCollection do:		[:each | constraintName := constraintName, each name].	constraintName size &gt; maxLength 		ifTrue: [constraintName := constraintName copyFrom: 1 to: maxLength].	aStream nextPutAll: constraintName</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>testing</category><body package="GlorpDatabase" selector="isUniqueConstraint">isUniqueConstraint	^true</body><body package="GlorpDatabase" selector="matchesUniqueConstraint:">matchesUniqueConstraint: aConstraint		name asUppercase = aConstraint name asUppercase ifFalse: [^false].	self fields size ~= aConstraint fields size ifTrue: [^false].	self fields with: aConstraint fields do: [:each :other | (each matchesField: other) ifFalse: [^false]].	^true</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="forTable:fields:">forTable: aTable fields: aCollectionOfFields	self table: aTable.	self fields: aCollectionOfFields</body></methods><methods><class-id>Glorp.UniqueConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="forTable:fields:">forTable: aTable fields: aCollectionOfFields	| instance |	instance := self new.	instance forTable: aTable fields: aCollectionOfFields.	^instance</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>private</category><body package="GlorpMappings" selector="embeddedObjectsFor:">embeddedObjectsFor: anObject	"Return all the objects embedded into this one"	| embedded descriptor |	descriptor := self descriptorFor: anObject.	descriptor isNil ifTrue: [^#()].	embedded := OrderedCollection new: 3.	descriptor mappings do: [:each |		(each class == EmbeddedValueOneToOneMapping) ifTrue: [			embedded add: (each getValueFrom: anObject)]].	^embedded.</body><body package="GlorpCore" selector="expiredInstanceOf:key:">expiredInstanceOf: aClass key: key	^cache expiredInstanceOf: aClass key: key.</body><body package="GlorpCore" selector="markAsCurrentOfClass:key:">markAsCurrentOfClass: aClass key: key	cache markAsCurrentOfClass: aClass key: key.</body><body package="GlorpCore" selector="privateGetCache">privateGetCache	^cache.</body><body package="GlorpCore" selector="privateGetCurrentUnitOfWork">privateGetCurrentUnitOfWork	^currentUnitOfWork.</body><body package="GlorpCore" selector="privateRegisterAsNew:">privateRegisterAsNew: anObject 	"Register the object as one which is not already in cache. Private! Normally just use the register: operation."	currentUnitOfWork isNil ifTrue: [^self].	currentUnitOfWork registerAsNew: anObject.</body><body package="GlorpCore" selector="privateRegisterAsOld:">privateRegisterAsOld: anObject 	"Register the object as something we already read from the database, skipping the isNew: test. Private! Normally you would just use register:"	| realObject |	currentUnitOfWork isNil ifTrue: [^self].	realObject := self realObjectFor: anObject ifNone: [^self].	currentUnitOfWork register: realObject</body><body package="GlorpCore" selector="realObjectFor:">realObjectFor: anObject 	"If this is a proxy, return the contents (if available). Otherwise, return nil"	^self realObjectFor: anObject ifNone: [nil].</body><body package="GlorpCore" selector="realObjectFor:ifNone:">realObjectFor: anObject ifNone: aBlock	"If this is a proxy, return the contents (if available). Otherwise, evalute the block"	^anObject isGlorpProxy 		ifTrue: [anObject isInstantiated ifTrue: [anObject getValue] ifFalse: [aBlock value]]		ifFalse: [anObject]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>caching</category><body package="GlorpCore" selector="cacheAt:forClass:ifNone:">cacheAt: aKey  forClass: aClass ifNone: failureBlock	^cache lookupClass: aClass key: aKey ifAbsent: failureBlock.</body><body package="GlorpCore" selector="cacheAt:put:">cacheAt: keyObject put: valueObject 	^cache at: keyObject insert: valueObject</body><body package="GlorpCore" selector="cacheContainsObject:">cacheContainsObject: anObject	| descriptor key |	(descriptor := self descriptorFor: anObject) isNil ifTrue: [^false].	(key := descriptor primaryKeyFor: anObject) isNil ifTrue: [^false].	^[self cacheContainsObject: anObject key: key] on: DuplicatePrimaryKeyException do: [:ex | false]</body><body package="GlorpCore" selector="cacheContainsObject:key:">cacheContainsObject: anObject key: aKey 	"Just test containment, don't return the result or trigger anything due to expiration"	aKey isNil ifTrue: [^false].	^cache		containsObject: anObject		key: aKey.</body><body package="GlorpCore" selector="cacheContainsObjectForClass:key:">cacheContainsObjectForClass: aClass key: aKey 	"Just test containment, don't return the result or trigger anything due to expiration"	aKey isNil ifTrue: [^false].	^cache		containsObjectForClass: aClass		key: aKey.</body><body package="GlorpCore" selector="cacheContainsObjectForRow:">cacheContainsObjectForRow: aDatabaseRow	^self 		cacheContainsObjectForClass: aDatabaseRow owner class		key: aDatabaseRow primaryKey</body><body package="GlorpCore" selector="cacheLookupForClass:key:">cacheLookupForClass: aClass key: aKey 	^self 		cacheAt: aKey		forClass: aClass		ifNone: [nil]</body><body package="GlorpCore" selector="cacheLookupObjectForRow:">cacheLookupObjectForRow: aDatabaseRow	^self 		cacheLookupForClass: aDatabaseRow owner class		key: aDatabaseRow primaryKey</body><body package="GlorpCore" selector="cacheRemoveObject:">cacheRemoveObject: anObject	| key |	key := (self descriptorFor: anObject) primaryKeyFor: anObject.	cache removeClass: anObject class key: key ifAbsent: [].</body><body package="GlorpCore" selector="hasExpired:key:">hasExpired: aClass key: key	^cache hasExpired: aClass key: key.</body><body package="GlorpCore" selector="hasObjectExpiredOfClass:withKey:">hasObjectExpiredOfClass: aClass withKey: key	^cache hasObjectExpiredOfClass: aClass withKey: key.</body><body package="GlorpCore" selector="isRegistered:">isRegistered: anObject	currentUnitOfWork isNil ifTrue: [^false].	^currentUnitOfWork isRegistered: anObject.</body><body package="GlorpCore" selector="lookupRootClassFor:">lookupRootClassFor: aClass	| descriptor |	descriptor := self system descriptorFor: aClass.	^descriptor notNil			ifTrue: [ descriptor typeMappingRootDescriptor describedClass ]			ifFalse: [ aClass ]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>accessing</category><body package="GlorpCore" selector="accessor">accessor	^accessor</body><body package="GlorpCore" selector="accessor:">accessor: aDatabaseAccessor 	accessor := aDatabaseAccessor.	system isNil ifFalse: [system platform: (accessor platform)].</body><body package="GlorpCore" selector="addToReaper:">addToReaper: aProxy	aProxy class == TimedProxy ifFalse: [^self].	self reaper add: aProxy.</body><body package="GlorpCore" selector="applicationData">applicationData	^applicationData</body><body package="GlorpCore" selector="applicationData:">applicationData: anObject		applicationData := anObject</body><body package="GlorpCore" selector="cacheFor:">cacheFor: anObject	^cache cacheFor: anObject.</body><body package="GlorpCore" selector="cacheForClass:">cacheForClass: aClass	^cache cacheForClass: aClass.</body><body package="GlorpCore" selector="currentLogin">currentLogin	^accessor currentLogin</body><body package="GlorpCore" selector="currentServerUTCTimestampOrNil">currentServerUTCTimestampOrNil	"This is kind of ugly, but it is Smalltalk Dialect neutral"	| sqlString result |	sqlString := [self platform sqlTextCurrentServerUTCTimestamp]		on: Dialect error		do:  [:exception | exception return: nil].	sqlString == nil ifTrue: [^nil].	result := [self accessor executeSQLString: sqlString]		on: Dialect error		do:  [:exception | exception return: nil].	^result == nil		ifTrue: [nil]		ifFalse: 			[(result first isEmpty or: [(result first first isKindOf: Dialect timestampClass) not])				ifTrue: [nil]				ifFalse: [result first first]]</body><body package="GlorpMappings" selector="databaseTableClass">databaseTableClass	^system databaseTableClass</body><body package="GlorpCore" selector="errorAction">errorAction	^errorAction</body><body package="GlorpCore" selector="errorAction:">errorAction: aThreeArgumentBlockExceptionSessionCommand	errorAction := aThreeArgumentBlockExceptionSessionCommand.</body><body package="GlorpCore" selector="modificationTracker">modificationTracker	"If we killed off the tracker due to a session reset, then bring it back again."	modificationTracker == #needed ifTrue: [self useModificationTracker].	^modificationTracker</body><body package="GlorpCore" selector="modificationTracker:">modificationTracker: aGlorpModificationTrackingPolicy	modificationTracker := aGlorpModificationTrackingPolicy</body><body package="GlorpCore" selector="platform">platform	^self system platform.</body><body package="GlorpCore" selector="reaper">reaper	reaper isNil ifTrue: [self initializeReaper].	^reaper.</body><body package="GlorpCore" selector="reusePreparedStatements:">reusePreparedStatements: aBoolean	accessor reusePreparedStatements: aBoolean.</body><body package="GlorpCore" selector="schema">schema	^ self accessor schema</body><body package="GlorpCore" selector="system">system	^system</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>api/transactions</category><body package="GlorpCore" selector="beginTransaction">beginTransaction	accessor beginTransaction.</body><body package="GlorpCore" selector="beginUnitOfWork">beginUnitOfWork	self hasUnitOfWork ifTrue: [self error: 'Cannot nest units of work yet'].	currentUnitOfWork := UnitOfWork new.	currentUnitOfWork session: self.</body><body package="GlorpCore" selector="commitTransaction">commitTransaction	accessor commitTransaction</body><body package="GlorpCore" selector="commitUnitOfWork">commitUnitOfWork	[self isInTransaction		ifTrue: [currentUnitOfWork commit]		ifFalse: [self inTransactionDo: [currentUnitOfWork commit]]] 	ifCurtailed: [self rollbackUnitOfWork].	currentUnitOfWork := nil.</body><body package="GlorpCore" selector="commitUnitOfWorkAndContinue">commitUnitOfWorkAndContinue	"Commit the current unit of work, but then keep going with the same set of registered objects, with their state updated to reflect current values."	| registeredObjects |		currentUnitOfWork isNil ifTrue: [^self error: 'Not in unit of work'].	registeredObjects := currentUnitOfWork registeredObjects.	currentUnitOfWork deletedObjects do: [:each | registeredObjects remove: each].	self commitUnitOfWork.	self beginUnitOfWork.	self registerAll: registeredObjects.</body><body package="GlorpCore" selector="doDDLOperation:">doDDLOperation: aBlock	"Execute DDL SQL - something which creates/drops/modifies tables or other schema information. The main reason for this method is that some databases require a transaction, while others don't require it, and still others don't allow it. Try to do the right thing."		^self accessor doDDLOperation: aBlock.</body><body package="GlorpCore" selector="hasUnitOfWork">hasUnitOfWork	^currentUnitOfWork notNil.</body><body package="GlorpCore" selector="inTransactionDo:">inTransactionDo: aBlock	"Execute aBlock in a database transaction. If one is already in progress, just continue. If not, start a transaction."	^self accessor inTransactionDo: aBlock.</body><body package="GlorpCore" selector="inUnitOfWorkDo:">inUnitOfWorkDo: aBlock	| result myUnitOfWork |	[	myUnitOfWork := self hasUnitOfWork not.	myUnitOfWork ifTrue: [self beginUnitOfWork].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	myUnitOfWork ifTrue: [		self commitUnitOfWork]]		ifCurtailed:			[myUnitOfWork ifTrue: [self rollbackUnitOfWork]].	^result.</body><body package="GlorpCore" selector="isInTransaction">isInTransaction	^accessor isInTransaction.</body><body package="GlorpCore" selector="modify:in:">modify: anObject in: aBlock	"Evaluate aBlock inside a unit of work. Start a database transaction at the beginning and commit it at the end. If we don't terminate normally, roll everything back. Register anObject before starting. Explicitly circumvent the registration of  the block result at the end, because that can cause problems if we're doing things like delete and re-insert and end up returning e.g. the deleted object"	| result |	self transact: [		self register: anObject.		result := aBlock value.		nil].	^result.</body><body package="GlorpCore" selector="requireUnitOfWork">requireUnitOfWork	"Start a unit of work if there isn't one already."	self hasUnitOfWork ifFalse: [self beginUnitOfWork].</body><body package="GlorpCore" selector="rollbackTransaction">rollbackTransaction	accessor execute: [ accessor rollbackTransaction].</body><body package="GlorpCore" selector="rollbackUnitOfWork">rollbackUnitOfWork	currentUnitOfWork isNil ifTrue: [^self].	currentUnitOfWork abort.	currentUnitOfWork := nil.</body><body package="GlorpCore" selector="rollbackUnitOfWorkFor:">rollbackUnitOfWorkFor: anObject	currentUnitOfWork abort: anObject</body><body package="GlorpCore" selector="save:">save: anObject 	"Make sure anObject will be written to the database by starting a unit of work if we aren't already in one, and registering the object. This is in most ways the same as just registering an object, but it tells us to disregard whether/how the object has changed and to save all of its fields. This is useful if we need to register an object *after* changes have occurred, and can be used to implement something more like an object by object save facility. Still somewhat experimental."	| realObject |	realObject := self realObjectFor: anObject ifNone: [^self].		self hasUnitOfWork		ifTrue:	[currentUnitOfWork registerAsNew: realObject]		ifFalse:			[self inUnitOfWorkDo: [				currentUnitOfWork registerAsNew: realObject]].</body><body package="GlorpCore" selector="saveAndContinue">saveAndContinue	"A shorter synonym"	^self commitUnitOfWorkAndContinue.</body><body package="GlorpCore" selector="transact:">transact: aBlock	"Evaluate aBlock inside a unit of work. Start a database transaction at the beginning and commit it at the end. If we don' terminate normally, roll everything back.  This might more consistently be  called inUnitOfWorkWithTransactionDo:, but that's too verbose"	| alreadyInTransaction alreadyInUnitOfWork result |	[[	alreadyInUnitOfWork := false.	alreadyInTransaction := self isInTransaction.	alreadyInTransaction ifFalse: [self beginTransaction].	alreadyInUnitOfWork := self hasUnitOfWork.	alreadyInUnitOfWork ifFalse: [self beginUnitOfWork].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	self register: result.	alreadyInUnitOfWork ifFalse: [self commitUnitOfWork].	alreadyInTransaction ifFalse: [self commitTransaction]]		ifCurtailed:			[alreadyInUnitOfWork ifFalse: [self rollbackUnitOfWork]]]			ifCurtailed: [alreadyInTransaction ifFalse: [self rollbackTransaction]].	^result.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>api/queries</category><body package="GlorpCore" selector="count:">count: aClass	^self execute: (SimpleQuery count: aClass).</body><body package="GlorpCore" selector="count:where:">count: aClass where: anExpression	^self execute: (SimpleQuery count: aClass where: anExpression).</body><body package="GlorpCore" selector="delete:">delete: anObject	| realObject |	"Get the real object, instantiating if necessary"	realObject := anObject glorpRealObject.	self hasUnitOfWork		ifTrue: [currentUnitOfWork delete: realObject]		ifFalse:			[self inUnitOfWorkDo: [				currentUnitOfWork delete: realObject]].</body><body package="GlorpCore" selector="deleteAll:">deleteAll: aCollection 	aCollection do: [:each | self delete: each].</body><body package="GlorpCore" selector="execute:">execute: aQuery	^aQuery executeWithParameters: #() in: self.</body><body package="GlorpCore" selector="hasExpired:">hasExpired: anObject 	^cache hasExpired: anObject.</body><body package="GlorpCore" selector="read:">read: aClass	^self execute: (SimpleQuery returningManyOf: aClass).</body><body package="GlorpCore" selector="read:limit:">read: aClass limit: anInteger	^self execute: (SimpleQuery returningManyOf: aClass limit: anInteger).</body><body package="GlorpCore" selector="read:orderBy:">read: aClass orderBy: aCriteria	| query |	query := SimpleQuery returningManyOf: aClass.	query orderBy: aCriteria.	^self execute: query.</body><body package="GlorpCore" selector="read:where:">read: aClass where: aBlock	^self execute: (SimpleQuery returningManyOf: aClass where: aBlock).</body><body package="GlorpCore" selector="read:where:limit:">read: aClass where: aBlock limit: anInteger	^self		execute:			(SimpleQuery				returningManyOf: aClass				where: aBlock				limit: anInteger).</body><body package="GlorpCore" selector="readManyOf:">readManyOf: aClass	^self execute: (SimpleQuery returningManyOf: aClass).</body><body package="GlorpCore" selector="readManyOf:limit:">readManyOf: aClass limit: anInteger	^self execute: (SimpleQuery returningManyOf: aClass limit: anInteger).</body><body package="GlorpCore" selector="readManyOf:orderBy:">readManyOf: aClass orderBy: aCriteria	| query |	query := SimpleQuery returningManyOf: aClass.	query orderBy: aCriteria.	^self execute: query.</body><body package="GlorpCore" selector="readManyOf:where:">readManyOf: aClass where: aBlock	^self execute: (SimpleQuery returningManyOf: aClass where: aBlock).</body><body package="GlorpCore" selector="readManyOf:where:limit:">readManyOf: aClass where: aBlock limit: anInteger	^self		execute:			(SimpleQuery				returningManyOf: aClass				where: aBlock				limit: anInteger).</body><body package="GlorpCore" selector="readOneOf:">readOneOf: aClass	^self execute: (SimpleQuery returningOneOf: aClass).</body><body package="GlorpCore" selector="readOneOf:where:">readOneOf: aClass where: aBlock	^self execute: (Query returningOneOf: aClass where: aBlock).</body><body package="GlorpCore" selector="refresh:">refresh: anObject	| exp query realObject descriptor |	realObject := self realObjectFor: anObject ifNone: [^self].	descriptor := self descriptorFor: realObject.	descriptor isNil		ifTrue: [self error: 'Cannot refresh an object with no descriptor'].	exp := descriptor		primaryKeyExpressionFor: realObject		basedOn: BaseExpression new		relation: #=.	query := Query returningOneOf: realObject class where: exp.	query shouldRefresh: true.	^self execute: query.</body><body package="GlorpCore" selector="undelete:">undelete: anObject	self undelete: anObject ifNotDeleted: [self error: 'Trying to undelete something that was not deleted'].</body><body package="GlorpCore" selector="undelete:ifNotDeleted:">undelete: anObject ifNotDeleted: aBlock	| realObject |	"Get the real object, instantiating if necessary"	realObject := anObject glorpRealObject.	self hasUnitOfWork		ifTrue: [currentUnitOfWork undelete: realObject ifNotDeleted: aBlock]		ifFalse:			[self error: 'Can only undelete while the unit of work is in progress'].</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>copying</category><body package="GlorpCore" selector="copy">copy	^self shallowCopy postCopy.</body><body package="GlorpCore" selector="postCopy">postCopy	super postCopy.	self initializeCache.	currentUnitOfWork := nil.	accessor := accessor copy.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>api</category><body package="GlorpCore" selector="descriptorFor:">descriptorFor: aClassOrInstance	^system descriptorFor: aClassOrInstance.</body><body package="GlorpCore" selector="forceSaveOf:">forceSaveOf: anObject 	"This is the same as registering an object, but it tells us to disregard whether/how the object has changed and to save all of its fields. This is useful if we need to register an object after changes have occurred, and can be used to implement something more like an object by object save facility. Still somewhat experimental."	| realObject |	realObject := self realObjectFor: anObject ifNone: [^self].		self inUnitOfWorkDo: [currentUnitOfWork registerAsNew: realObject].</body><body package="GlorpCore" selector="hasDescriptorFor:">hasDescriptorFor: aClass	^system hasDescriptorFor: aClass.</body><body package="GlorpCore" selector="register:">register: anObject 	"Register the object with our current unit of work. We need to do this *before* making changes to the objects."	| realObject |	currentUnitOfWork isNil ifTrue: [^self].	realObject := self realObjectFor: anObject ifNone: [^self].	(self isNew: realObject) 		ifTrue: [currentUnitOfWork registerAsNew: realObject]		ifFalse: [currentUnitOfWork register: realObject]</body><body package="GlorpCore" selector="registerAll:">registerAll: aCollection	aCollection do: [:ea | self register: ea].</body><body package="GlorpCore" selector="registerForDelete:">registerForDelete: anObject 	"Register the object with our current unit of work, with intent to delete it."	| realObject |	currentUnitOfWork isNil ifTrue: [^self].	realObject := self realObjectFor: anObject ifNone: [^self].	currentUnitOfWork registerForDelete: realObject.</body><body package="GlorpCore" selector="system:">system: aSystem 	aSystem session: self.	accessor isNil ifFalse: [aSystem platform: (accessor currentLogin database)].	system := aSystem.	system validate.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>internal/writing</category><body package="GlorpCore" selector="commandForRow:">commandForRow: aDatabaseRow 		(aDatabaseRow forDeletion) ifTrue: [^DeleteCommand forRow: aDatabaseRow useBinding: self useBinding session: self].	^(self shouldInsert: aDatabaseRow)		ifTrue: [^InsertCommand forRow: aDatabaseRow useBinding: self useBinding session: self]		ifFalse: [^UpdateCommand forRow: aDatabaseRow useBinding: self useBinding session: self].</body><body package="GlorpCore" selector="createDeleteRowsFor:in:">createDeleteRowsFor: anObject in: rowMap	"Create records for rows that require deletion"	(self descriptorFor: anObject) createDeleteRowsFor: anObject in: rowMap.</body><body package="GlorpCore" selector="createRowsFor:in:">createRowsFor: anObject in: rowMap	| descriptor |	(descriptor := self descriptorFor: anObject class) isNil		ifFalse: [descriptor createRowsFor: anObject in: rowMap].</body><body package="GlorpCore" selector="shouldInsert:">shouldInsert: aDatabaseRow 	(currentUnitOfWork notNil and: [currentUnitOfWork forcesUpdateFor: aDatabaseRow]) ifTrue: [^false].	^(self cacheContainsObjectForRow: aDatabaseRow) not.</body><body package="GlorpCore" selector="tablesInCommitOrder">tablesInCommitOrder	^system tablesInCommitOrder.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>events</category><body package="GlorpCore" selector="sendPostFetchEventTo:">sendPostFetchEventTo: anObject	^anObject glorpPostFetch: self.</body><body package="GlorpCore" selector="sendPostFetchValidateEventTo:">sendPostFetchValidateEventTo: anObject	^anObject glorpPostFetchValidate: self.</body><body package="GlorpCore" selector="sendPostWriteEventTo:">sendPostWriteEventTo: anObject	anObject glorpPostWrite: self.</body><body package="GlorpCore" selector="sendPreWriteEventTo:">sendPreWriteEventTo: anObject	anObject glorpPreWrite: self.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>virtual collections</category><body package="GlorpCore" selector="virtualCollectionOf:">virtualCollectionOf: aClass	^GlorpVirtualCollection on: aClass in: self.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>initialize</category><body package="GlorpCore" selector="dontUseModificationTracker">dontUseModificationTracker	modificationTracker release.	modificationTracker := nil.</body><body package="GlorpCore" selector="initialize">initialize		self initializeCache.</body><body package="GlorpCore" selector="initializeCache">initializeCache	cache release.	cache := CacheManager forSession: self.</body><body package="GlorpCore" selector="initializeReaper">initializeReaper	self releaseReaper.	reaper := TimedProxyReaper new.</body><body package="GlorpCore" selector="releaseReaper">releaseReaper	reaper release.</body><body package="GlorpCore" selector="reset">reset	self initializeCache.	self releaseReaper.	accessor reset.	currentUnitOfWork := nil.	modificationTracker release.	modificationTracker isNil ifFalse: [modificationTracker := #needed].</body><body package="GlorpCore" selector="resetPermissions">resetPermissions	accessor isNil ifFalse: [accessor resetPermissions].</body><body package="GlorpCore" selector="shouldUseModificationTracker:">shouldUseModificationTracker: aBoolean	aBoolean		ifTrue: [modificationTracker isNil ifTrue: [self useModificationTracker]]		ifFalse: [modificationTracker := nil].</body><body package="GlorpCore" selector="useModificationTracker">useModificationTracker	Dialect isVisualWorks ifFalse: [^self].	modificationTracker := (Smalltalk		at: #'Glorp.GlorpVWWriteBarrierTracker'		ifAbsent: [nil]) ifNotNil: [:class | class new].	modificationTracker session: self.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>testing</category><body package="GlorpCore" selector="isNew:">isNew: anObject 	"When registering, do we need to add this object to the collection of new objects? New objects are treated specially when computing what needs to be written, since we don't have their previous state"	| key descriptor |	(currentUnitOfWork notNil and: [currentUnitOfWork isRegistered: anObject]) ifTrue: [^false].	descriptor := self descriptorFor: anObject.	descriptor isNil ifTrue: [^false].	"For embedded values we assume that they are not new. This appears to work. I can't really justify it."	self needsWork: 'cross your fingers'.	descriptor mapsPrimaryKeys ifFalse: [^false].	key := descriptor primaryKeyFor: anObject.	key isNil ifTrue: [^true].	"If the cache contains the object, but the existing entry is due to be deleted, then count this entry as a new one being added with the same primary key (ick) as the old one"	^[(self cacheContainsObject: anObject key: key) not]		on: DuplicatePrimaryKeyException		do: [:ex |			(currentUnitOfWork notNil and: [currentUnitOfWork willDelete: ex existingObject]) 				ifTrue: [					self cacheRemoveObject: ex existingObject.					ex return: true]				ifFalse: [ex pass]].</body><body package="GlorpCore" selector="isUninstantiatedProxy:">isUninstantiatedProxy: anObject	^anObject isGlorpProxy and: [anObject isInstantiated not].</body><body package="GlorpCore" selector="reusePreparedStatements">reusePreparedStatements	^accessor reusePreparedStatements</body><body package="GlorpCore" selector="useBinding">useBinding	self accessor isNil ifTrue: [^false].	^self accessor useBinding.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>read/write</category><body package="GlorpCore" selector="filterDeletionFrom:">filterDeletionFrom: anObject	self hasUnitOfWork ifFalse: [^anObject].	currentUnitOfWork shouldFilterDeletions ifFalse: [^anObject].	(currentUnitOfWork willDelete: anObject)		ifTrue: [^nil].	^anObject.</body><body package="GlorpCore" selector="groupWrite:">groupWrite: aCollectionOfDatabaseRows	| command |	aCollectionOfDatabaseRows		do: [:each | each preWriteAssignSequencesUsing: self].	command := self commandForHomogeneousRows: aCollectionOfDatabaseRows.	accessor executeCommand: command.	^command succeeded		ifTrue: [true]		ifFalse:			[((GlorpWriteFailure new)				command: command;				object: (aCollectionOfDatabaseRows collect: [:each | each owner]))				signal].</body><body package="GlorpCore" selector="writeHomogeneousRows:">writeHomogeneousRows: aCollectionOfDatabaseRows	"Write out a collection of rows belonging to a single table"	| representativeRow succeeded maximumSize start |	aCollectionOfDatabaseRows isEmpty ifTrue: [^true].	representativeRow := aCollectionOfDatabaseRows first.	representativeRow shouldBeWritten ifFalse: [^true].	succeeded := true.	maximumSize := self system maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows.	start := 1.	[start &gt; aCollectionOfDatabaseRows size] whileFalse: [		| end |		end := (start + maximumSize - 1) min: aCollectionOfDatabaseRows size.		succeeded := succeeded			&amp; (self writeHomogeneousRows: aCollectionOfDatabaseRows from: start to: end).		start := end + 1].	^succeeded.</body><body package="GlorpCore" selector="writeHomogeneousRows:from:to:">writeHomogeneousRows: aCollectionOfDatabaseRows from: startIndex to: endIndex	"Write out the specified range from a collection of rows belonging to a single table"	| succeeded |	succeeded := true.	^(self system 				canUseGroupedWritesFor: (aCollectionOfDatabaseRows at: startIndex) table)		ifTrue: [self groupWrite: (aCollectionOfDatabaseRows copyFrom: startIndex to: endIndex)]		ifFalse:			[startIndex to: endIndex do: [:i |				 |eachRow rowSucceeded |				eachRow := aCollectionOfDatabaseRows at: i.				rowSucceeded := self writeRow: eachRow.				succeeded := succeeded &amp; rowSucceeded].			succeeded].</body><body package="GlorpCore" selector="writeRow:">writeRow: aDatabaseRow	| command success |	aDatabaseRow shouldBeWritten ifFalse: [^true].	aDatabaseRow preWriteAssignSequencesUsing: self.	command := self commandForRow: aDatabaseRow.	accessor executeCommand: command.	success := true.	command succeeded		ifFalse:			[success := (GlorpWriteFailure new)				command: command;				object: (Array with: aDatabaseRow owner);				signal].	^success.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>login</category><body package="GlorpCore" selector="isLoggedIn">isLoggedIn	^accessor isLoggedIn.</body><body package="GlorpCore" selector="login">login	self isLoggedIn ifTrue: [^nil].	^self loginIfError: [:ex | ex pass]</body><body package="GlorpCore" selector="loginIfError:">loginIfError: aBlock	| result |	result := self accessor loginIfError: aBlock.	system platform characterEncoding: accessor encoding.	^result.</body><body package="GlorpCore" selector="logout">logout	^self accessor logout.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>table creation</category><body package="GlorpCore" selector="createTables">createTables	"Create the tables for our descriptor system. This will fail if the tables already exist. Use recreateTables for that."	self createTables: system allTables.</body><body package="GlorpCore" selector="createTables:">createTables: aCollection	"Create the tables for our descriptor system. This will fail if the tables already exist. Use recreateTables for that."	| sequences |	system platform areSequencesExplicitlyCreated		ifTrue:			[sequences := self system allSequencesFor: aCollection.			sequences do: [:each | accessor createSequence: each ifError: [:ex | self halt]]].	aCollection do: [:each | accessor createTable: each ifError: [:ex | self halt]].	aCollection do: [:each | accessor createTableIndexes: each ifError: [:ex | self halt]].	self platform supportsConstraints ifTrue: [aCollection do: [:each | accessor createTableFKConstraints: each ifError: [:ex | self halt]]].</body><body package="GlorpCore" selector="dropTables">dropTables	"Drop the tables for our descriptor system, and their associated sequences."	self dropTables: system allTables.</body><body package="GlorpCore" selector="dropTables:">dropTables: aCollection	"Drop the tables for our descriptor system, and their associated sequences."	| sequences |	accessor dropTables: ((TableSorter for: aCollection) sort reverse).	system platform areSequencesExplicitlyCreated ifTrue: [		sequences := system allSequencesFor: aCollection.		accessor dropSequences: sequences].</body><body package="GlorpCore" selector="migrateFromSystem:toSystem:">migrateFromSystem: from toSystem: to	| fromTables toTables toDelete toAdd toModify newVersion |	fromTables := from allTables copy.	toTables := to allTables copy.	toDelete := fromTables reject: [:each | 		toTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toAdd := toTables reject: [:each | 		fromTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toModify := fromTables reject: [:each | (toDelete includes: each) or: [toAdd includes: each]].	self doDDLOperation: [		self createTables: toAdd.		self dropTables: toDelete.		toModify do: [:each | 			newVersion := to tableNamed: each sqlString.			self updateTableFrom: each to: newVersion]].</body><body package="GlorpCore" selector="migrateFromVersion:toVersion:">migrateFromVersion: fromVersionNumber toVersion: toVersionNumber 	self halt.	"Get the class name of our system, strip off version number, replace with to and from, create systems for them."</body><body package="GlorpCore" selector="recreateTables">recreateTables	"Drop and re-create the tables for our descriptor system, and their associated sequences."	self recreateTables: system allTables.</body><body package="GlorpCore" selector="recreateTables:">recreateTables: aCollection	"Drop the tables for our descriptor system, and their associated sequences."	| sequences |	accessor dropTables: (TableSorter for: aCollection) sort reverse.	system platform areSequencesExplicitlyCreated		ifTrue:			[			sequences := self system allSequencesFor: aCollection.			accessor dropSequences: sequences.			sequences				do: [:each | accessor createSequence: each ifError: [:ex | self halt]]].	aCollection do: [:each | accessor createTable: each ifError: [:ex | self halt]].	aCollection do: [:each | accessor createTableIndexes: each ifError: [:ex | self halt]].	self platform supportsConstraints ifTrue: [aCollection do: [:each | accessor createTableFKConstraints: each ifError: [:ex | self halt]]].</body><body package="GlorpCore" selector="recreateTables:ifError:">recreateTables: aCollection ifError: aBlock	"Drop the tables for our descriptor system, and their associated sequences."	(TableSorter for: aCollection) sort reverse		do: [ :table | accessor dropTable: table ifError: [ :ex | ex "so we can insert a breakpoint"] ].	system platform areSequencesExplicitlyCreated		ifTrue: [(self system allSequencesFor: aCollection)					do: [:each | 						accessor dropSequence: each ifAbsent: [:ex | ex "so we can insert a breakpoint" ].						accessor createSequence: each ifError: [:ex | ^aBlock value: ex ]]].	aCollection do: [:each | accessor createTable: each ifError: [:ex | ^aBlock value: ex]].	aCollection do: [:each | accessor createTableIndexes: each ifError: [:ex | ^aBlock value: ex ]].	self platform supportsConstraints ifTrue: [aCollection do: [:each | accessor createTableFKConstraints: each ifError: [:ex | ^aBlock value: ex]]].</body><body package="GlorpCore" selector="recreateTablesIfError:">recreateTablesIfError: aBlock	"Drop and re-create the tables for our descriptor system, and their associated sequences."	self recreateTables: system allTables ifError: aBlock .</body><body package="GlorpCore" selector="updateTableFrom:to:">updateTableFrom: aTable to: newTable	"Update the given table based on the metadata."		| newFields deletedFields modifiedFields newFKConstraints deletedFKConstraints newUniqueConstraints deletedUniqueConstraints |	newFKConstraints := newTable foreignKeyConstraints reject: 		[:each | aTable hasForeignKeyConstraintMatching: each].	deletedFKConstraints := aTable foreignKeyConstraints reject: 		[:each | newTable hasForeignKeyConstraintMatching: each].	newUniqueConstraints := newTable uniqueConstraints reject: 		[:each | aTable hasUniqueConstraintMatching: each].	deletedUniqueConstraints := aTable uniqueConstraints reject: 		[:each | newTable hasUniqueConstraintMatching: each].	"So far, we just handle adding and deleting fields, not changing them."	newFields := newTable fields reject: 		[:each | aTable hasFieldNamed: each name].	deletedFields := aTable fields reject: 		[:each | newTable hasFieldNamed: each name].	modifiedFields := newTable fields reject: 		[:each | newFields includes: each].	modifiedFields := modifiedFields reject: 		[:each | (aTable fieldNamed: each name) isTheSameAs: each].		"Cheap version, for modified fields, drop and re-add them."	newFields addAll: modifiedFields.	deletedFields addAll: modifiedFields.	deletedFKConstraints do: [:each | accessor dropConstraint: each].	deletedUniqueConstraints do: [:each | accessor dropConstraint: each].	accessor dropFields: deletedFields.	accessor addFields: newFields.	newFKConstraints do: [:each | accessor addConstraint: each].	newUniqueConstraints do: [:each | accessor addConstraint: each]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>As yet unclassified</category><body package="GlorpCore" selector="commandForHomogeneousRows:">commandForHomogeneousRows: aCollectionOfDatabaseRows	"Create the command for this set of rows. These are assumed to be homogeneous, in that they are all for the same table, and are all the same type of operation (i.e. all insert or all update)"	| representativeRow |	representativeRow := aCollectionOfDatabaseRows first.	representativeRow forDeletion ifTrue: [self error: 'invalid way of handling deletes (this should never happen)'].	^(self shouldInsert: representativeRow)		ifTrue: [InsertCommand forRows: aCollectionOfDatabaseRows useBinding: self useBinding session: self]		ifFalse: [UpdateCommand forRows: aCollectionOfDatabaseRows useBinding: self useBinding session: self].</body></methods><methods><class-id>Glorp.GlorpSession class</class-id> <category>instance creation</category><body package="GlorpCore" selector="forSystem:">forSystem: aSystem 	^self new system: aSystem</body><body package="GlorpCore" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>collections</category><body package="GlorpMisc" selector="needsCollectionMementoFor:">needsCollectionMementoFor: aCollection	^true.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>files</category><body package="GlorpMisc" selector="contentsOfFileNamed:">contentsOfFileNamed: aString 	"Given a text file name, read its contents"	| stream contents fileClass |	Dialect isVisualWorks ifTrue: [^aString asFilename contentsOfEntireFile].	Dialect isSqueak ifTrue: [		stream := (Dialect smalltalkAt: #CrLfFileStream) oldFileNamed: aString.		[contents := stream contents] ensure: [stream close].		^contents].	fileClass := Dialect isVisualAge 				ifTrue: [self smalltalkAt: #CfsReadFileStream]				ifFalse: 					[Dialect isDolphin ifTrue: [self smalltalkAt: #File] ifFalse: [self halt]].	stream := fileClass read: aString.	[contents := stream contents] ensure: [stream close].	^contents</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>strings</category><body package="GlorpMisc" selector="convert:toByteArrayWithEncoding:">convert: aString toByteArrayWithEncoding: encodingName	self isVisualWorks ifTrue: [^aString asByteArrayEncoding: encodingName].	self error: 'Not yet implemented'.</body><body package="GlorpMisc" selector="convert:toStringWithEncoding:">convert: aByteArray toStringWithEncoding: encodingName	self isVisualWorks ifTrue: [^aByteArray asStringEncoding: encodingName].	self error: 'Not yet implemented'.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>reflection</category><body package="GlorpMisc" selector="selectorsFor:do:">selectorsFor: aClass do: aBlock	"Stupid dialects"	self isVisualWorks ifTrue: [^aClass selectorsAndMethodsDo: [:key :value | aBlock value: key]].	self isVisualAge ifTrue: [^ aClass methodDictionary keysDo: aBlock].	self isSqueak ifTrue: [^aClass methodDict keysDo: aBlock].	self error: 'Not yet implemented'.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>private</category><body package="GlorpExtensions" selector="basicIsDolphin">basicIsDolphin	^Smalltalk includesKey: #DolphinSplash.</body><body package="GlorpExtensions" selector="basicIsGNU">basicIsGNU	^Smalltalk includesKey: #BindingDictionary.</body><body package="GlorpExtensions" selector="basicIsObjectStudio">basicIsObjectStudio	^Smalltalk class name == #SmalltalkClass.</body><body package="GlorpExtensions" selector="basicIsSqueak">basicIsSqueak	^ (Smalltalk respondsTo: #vmVersion) and: [(Smalltalk vmVersion copyFrom: 1 to: 6) = 'Squeak'.]</body><body package="GlorpExtensions" selector="basicIsVisualAge">basicIsVisualAge	^ Smalltalk class name == #EsSmalltalkNamespace	"	| sys |	sys := Smalltalk at: #System ifAbsent: [^false].	(sys respondsTo: #vmType) ifFalse: [^false].	^sys vmType = 'ES'"</body><body package="GlorpExtensions" selector="basicIsVisualWorks">basicIsVisualWorks	^ Smalltalk class name == #NameSpace	"Smalltalk class selectors do: [ :s | 		(s == #versionName and: [ (Smalltalk versionName copyFrom: 1 to: 11) = 'VisualWorks']) 		    ifTrue: [^true]].	^false"</body><body package="GlorpExtensions" selector="basicIsVisualWorksWithoutNamespaces">basicIsVisualWorksWithoutNamespaces	^Smalltalk class name == #SystemDictionary</body><body package="GlorpExtensions" selector="determineDialect">determineDialect	self basicIsDolphin ifTrue: [^ dialectName := #Dolphin].	self basicIsGNU ifTrue: [^ dialectName := #GNU].	self basicIsVisualAge ifTrue: [^ dialectName := #VisualAge].	self basicIsVisualWorks ifTrue: [^ dialectName := #VisualWorks].	self basicIsSqueak ifTrue: [^ dialectName := #Squeak].	self basicIsObjectStudio ifTrue: [^dialectName := #ObjectStudio].	self basicIsVisualWorksWithoutNamespaces ifTrue: [^dialectName := #VisualWorks].	self error: 'I don''t know what dialect this is'.	^ self</body><body package="GlorpExtensions" selector="lookedUpNames">lookedUpNames	lookedUpNames isNil ifTrue: [lookedUpNames := IdentityDictionary new].	^lookedUpNames.</body><body package="GlorpExtensions" selector="reset">reset	"self reset"	lookedUpNames := nil.	timestampClass := nil.	dialectName := nil.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>dates</category><body package="GlorpExtensions" selector="addSeconds:to:">addSeconds: seconds to: aTime	self isVisualWorks ifTrue: [^ Time fromSeconds: aTime asSeconds + seconds].	self isDolphin ifTrue: [^ self addTimeForDolphin: aTime seconds: seconds].	self isGNU ifTrue: [^ aTime addSeconds: seconds].	self isVisualAge ifTrue: [^Time fromSeconds: aTime asSeconds + seconds].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions" selector="addTimeForDolphin:seconds:">addTimeForDolphin: aTime seconds: seconds	"Dolphin's time/date arithmetic is pretty weak, especially for timestamps. Hack around it. This is likely only to work for seconds &lt;24 hours"	| result |	^ aTime class == Time		ifTrue: [Time fromMilliseconds: (aTime asMilliseconds + (seconds * 1000)) \\ 86400000.]		ifFalse: [			result := self timestampClass date: aTime date				time: (self addTimeForDolphin: aTime time seconds: seconds).			(seconds &gt; 0 and: [result time &lt; aTime time.])				ifTrue: [result date: (result date addDays: 1).].			(seconds &lt; 0 and: [result time &gt; aTime time.])				ifTrue: [result date: (result date addDays: -1).].			^ result		]</body><body package="GlorpExtensions" selector="newDateWithYears:months:days:">newDateWithYears: years months: months days: days	(self isVisualWorks or: [self isSqueak]) ifTrue: [^ Date newDay: days monthNumber: months year: years].	self isGNU ifTrue: [^ Date newDay: days monthIndex: months year: years].	self isVisualAge ifTrue: [^Date newDay: days monthIndex: months year: years].	self isObjectStudio ifTrue: [^Date newDay: days imonth: months year: years].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions" selector="newTimeWithHours:minutes:seconds:milliseconds:">newTimeWithHours: hours minutes: minutes seconds: seconds milliseconds: milliseconds	self isGNU ifTrue: [^ Time fromSeconds: hours * 60 * 60 + (minutes * 60) + seconds].	(self isVisualWorks or: [self isSqueak]) ifTrue: [^ Time fromSeconds: hours * 60 * 60 + (minutes * 60) + seconds].	self isVisualAge		ifTrue: [			^ Time fromMilliseconds: ((hours * 60 * 60) + (minutes * 60) + seconds) * 1000 + milliseconds		].	self isObjectStudio ifTrue: [^Time hour: hours minute: minutes second: seconds millisecond: milliseconds].	self error: 'Not implemented yet'.	^ self</body><body package="GlorpExtensions" selector="newTimestampFromDate:time:">newTimestampFromDate: aDate time: aTime	self isVisualWorks ifTrue: [^self timestampClass fromDate: aDate andTime: aTime].	self error: 'Not yet implemented'.</body><body package="GlorpExtensions" selector="newTimestampWithYears:months:days:hours:minutes:seconds:milliseconds:offset:">newTimestampWithYears: years	months: months	days: days	hours: hours	minutes: minutes	seconds: seconds	milliseconds: millis	offset: offset	| date time ts |	self isGNU		ifTrue: [			^ self timestampClass year: years				month: months				day: days				hour: hours				minute: minutes				second: seconds				offset: ((Dialect smalltalkAt: #Duration) fromSeconds: offset)		].	date := self newDateWithYears: years months: months days: days.	time := self newTimeWithHours: hours minutes: minutes seconds: seconds milliseconds: millis.	self isVisualWorks		ifTrue: [^ (self timestampClass fromDate: date andTime: time) addMilliseconds: millis].	self isSqueak		ifTrue: [ts := self timestampClass date: date time: time.			ts time addSeconds: (millis / 1000) asInteger.				^ts]. 	self isVisualAge		ifTrue: [^(Dialect smalltalkAt: #AbtTimestamp) date: date time: time].	self isObjectStudio ifTrue: [^self timestampClass newDate: date time: time].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions" selector="readFixedPointFrom:">readFixedPointFrom: aString	self isVisualWorks ifTrue: [^ (self smalltalkAt: #FixedPoint) readFrom: (ReadStream on: aString)].	(self isDolphin or: [self isSqueak]) ifTrue: [^ Number readFrom: (ReadStream on: aString , 's')].	self isGNU		ifTrue: [			^ (Number readFrom: (ReadStream on: aString)) asScaledDecimal:				aString size - (aString indexOf: $. ifAbsent: [aString size.])		].	self isVisualAge ifTrue: [ ^(self smalltalkAt: #Decimal) fromString: aString].	self isObjectStudio ifTrue: [^(self smalltalkAt: #Decimal) newString: aString].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions" selector="supportsMillisecondsInTimeStamps">supportsMillisecondsInTimeStamps	self isGNU ifTrue: [^ false].	self isVisualWorks ifTrue: [^ true].	self isDolphin ifTrue: [^ true].	self isVisualAge ifTrue: [^ true].	self isObjectStudio ifTrue: [^true].	self error: 'not yet implemented'.	^ self</body><body package="GlorpExtensions" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	self isGNU ifTrue: [^ false].	self isVisualWorks ifTrue: [^ false].	self isSqueak ifTrue: [^false].	self isDolphin ifTrue: [^ true].	self isVisualAge ifTrue: [^ true].	self isObjectStudio ifTrue: [^true]. "Sort of. Supports hundredths of a second"	^ self</body><body package="GlorpExtensions" selector="timeOffsetFromGMT">timeOffsetFromGMT	self isVisualWorks ifTrue: [^(self smalltalkAt: #TimeZone) default secondsFromGMT / (60 * 60)].	self isGNU ifTrue: [Time timezoneBias / (60 * 60)].	^ 0</body><body package="GlorpExtensions" selector="timestampClass">timestampClass	timestampClass == nil ifFalse: [^ timestampClass].	Dialect isVisualWorks ifTrue: [^ timestampClass := self smalltalkAt: #Timestamp].	Dialect isObjectStudio ifTrue: [^timestampClass := self smalltalkAt: #Timestamp].	Dialect isGNU ifTrue: [^ timestampClass := self smalltalkAt: #DateTime].	(Dialect isSqueak or: [Dialect isDolphin.])		ifTrue: [^ timestampClass := self smalltalkAt: #TimeStamp].	Dialect isVisualAge ifTrue: [^ timestampClass := self smalltalkAt: #Timestamp].	self error: 'Not yet implemented'.	^ self</body><body package="GlorpExtensions" selector="timestampNow">timestampNow	Dialect isGNU ifTrue: [^ self timestampClass dateAndTimeNow].	Dialect isSqueak ifTrue: [^ self timestampClass current].	Dialect isVisualWorks ifTrue: [^ self timestampClass now].	Dialect isDolphin ifTrue: [^ self timestampClass current].	Dialect isVisualAge ifTrue: [^ self timestampClass now].	Dialect isObjectStudio ifTrue: [^self timestampClass now].	self error: 'Not yet implemented'.	^ self</body><body package="GlorpExtensions" selector="timestampNowUTC">timestampNowUTC	Dialect isVisualWorks ifTrue: [^ (self smalltalkAt: #Timestamp) fromSeconds: Time secondClock].	Dialect isDolphin ifTrue: [self error: 'not supported'].	Dialect isGNU ifTrue: [^ self timestampClass utcDateAndTimeNow].	self error: 'Not yet implemented'.	^ self</body><body package="GlorpExtensions" selector="totalSeconds">totalSeconds	self isGNU ifTrue: [^ Time utcSecondClock].	self isVisualAge ifTrue: [^ (self smalltalkAt: #AbtTimestamp) now totalSeconds].	^ Time totalSeconds</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>binding</category><body package="GlorpExtensions" selector="unbindableClassNames">unbindableClassNames	self isVisualWorks ifTrue: [^ #()].	^ #()</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>numbers</category><body package="GlorpExtensions" selector="coerceToDoublePrecisionFloat:">coerceToDoublePrecisionFloat: aNumber	self isVisualWorks ifTrue: [^ aNumber asDouble].	self isVisualAge ifTrue: [^ aNumber asFloat].	self isSqueak ifTrue: [^aNumber asFloat].	self isGNU ifTrue: [^ aNumber asFloatD].	^ aNumber</body><body package="GlorpExtensions" selector="doesPrecisionOf:equal:">doesPrecisionOf: aNumber equal: aPrecision	^aNumber class == self fixedPointClass and: [aNumber scale = aPrecision].</body><body package="GlorpExtensions" selector="doublePrecisionFloatClass">doublePrecisionFloatClass	self isVisualWorks ifTrue: [^ self smalltalkAt: #Double].	self isGNU ifTrue: [^ self smalltalkAt: #FloatD].	^ Float</body><body package="GlorpExtensions" selector="fixedPointClass">fixedPointClass	Dialect isVisualWorks ifTrue: [^self smalltalkAt: #FixedPoint].</body><body package="GlorpExtensions" selector="isFloatingPoint:">isFloatingPoint: aNumber	^aNumber class == self doublePrecisionFloatClass or: [aNumber class == Float].</body><body package="GlorpExtensions" selector="singlePrecisionFloatClass">singlePrecisionFloatClass	^ Float</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>general portability</category><body package="GlorpExtensions" selector="argumentCountFor:">argumentCountFor: aBlock	Dialect isVisualWorks ifTrue: [^aBlock numArgs].	Dialect isObjectStudio ifTrue: [^aBlock numArgs].	Dialect isVisualAge ifTrue: [^aBlock argumentCount].	Dialect isDolphin ifTrue: [^aBlock argumentCount].	Dialect isSqueak ifTrue: [^aBlock numArgs].	"argumentCount would also work"	Dialect isGNU ifTrue: [^ self error: 'not implemented yet'].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions" selector="error">error	"If VASmalltalk 8 has switched entirely to ANSI exceptions, perhaps we can retire this.Meanwhile, it is used in some Glorp on:do: calls."	^Dialect isVisualAge		ifTrue: [Error, (Dialect smalltalkAt: #ExError)]		ifFalse: [Error]</body><body package="GlorpExtensions" selector="fitHashIntoSmallInteger:">fitHashIntoSmallInteger: aNumber	"Truncate the number to fit into smallinteger range. Mostly useful for ObjectStudio where hashes have to be 16 bits or less"	^Dialect isObjectStudio ifTrue: [aNumber hash] ifFalse: [aNumber].</body><body package="GlorpExtensions" selector="garbageCollect">garbageCollect	Dialect isVisualWorks ifTrue: [^ ObjectMemory quickGC].	Dialect isObjectStudio ifTrue: [^(self smalltalkAt: #System) garbageCollect].	Dialect isGNU ifTrue: [^ ObjectMemory globalGarbageCollect].	Dialect isVisualAge ifTrue: [^ (self smalltalkAt: #System) globalGarbageCollect].	Dialect isSqueak ifTrue: [^Smalltalk garbageCollect].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions" selector="instVarNameFor:">instVarNameFor: aName	Dialect isGNU ifTrue: [^ aName asSymbol].	^ aName asString</body><body package="GlorpExtensions" selector="isBlock:">isBlock: anObject	"Return true if this is a block"	self isVisualAge ifTrue: [^anObject isKindOf: (self smalltalkAt: #Block)].	^anObject class == [] class.</body><body package="GlorpExtensions" selector="isHeadless">isHeadless	"Dialect isHeadless"	Dialect isVisualWorks ifTrue: [^ (Smalltalk at: 'WindowingSystem' ifAbsent: [^true]) isHeadless].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions" selector="quitTheImage">quitTheImage	"Quit the entire image"	self isVisualWorks ifTrue: [^(self smalltalkAt: #ObjectMemory) quit].	self isSqueak ifTrue: [^(self smalltalkAt: #SmalltalkImage) current snapshot: false andQuit: true].	self isDolphin ifTrue: [^(self smalltalkAt: #SessionManager) current quit].	self isVisualAge ifTrue: [^  self error: 'Not implemented yet'.].	self isObjectStudio ifTrue: [^ self error: 'Not implemented yet'.].	self isGNU ifTrue: [^ self error: 'Not implemented yet'.].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions" selector="tokensBasedOn:in:">tokensBasedOn: aString in: stringToTokenize	self isVisualWorks ifTrue: [^ stringToTokenize tokensBasedOn: aString first].	self isSqueak ifTrue: [^ stringToTokenize findTokens: aString].	self isDolphin ifTrue: [^ stringToTokenize subStrings: aString].	self isVisualAge ifTrue: [^ (stringToTokenize subStrings: aString first)].	self isObjectStudio ifTrue: [^(stringToTokenize asArrayOfSubstringsDelimiter: aString first)].	self isGNU ifTrue: [^ stringToTokenize subStrings: aString first].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions" selector="weakValueDictionaryClass">weakValueDictionaryClass	Dialect isVisualWorks ifTrue: [^self smalltalkAt: #EphemeralValueDictionary].	Dialect isSqueak ifTrue: [^self smalltalkAt: #WeakValueDictionary].	self error: 'Not yet implemented for this dialect'.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>forward references</category><body package="GlorpExtensions" selector="glorpConstantExpressionClass">glorpConstantExpressionClass	^ConstantExpression.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>identifying</category><body package="GlorpExtensions" selector="dialectName">dialectName	dialectName isNil ifTrue: [self determineDialect.].	^ dialectName</body><body package="GlorpExtensions" selector="isDolphin">isDolphin	^ self dialectName = #Dolphin</body><body package="GlorpExtensions" selector="isGNU">isGNU	^ self dialectName = #GNU</body><body package="GlorpExtensions" selector="isNamespaceAware">isNamespaceAware	isNamespaceAware isNil ifTrue: [isNamespaceAware := self basicIsVisualWorks].	^isNamespaceAware</body><body package="GlorpExtensions" selector="isObjectStudio">isObjectStudio	^ self dialectName = #ObjectStudio</body><body package="GlorpExtensions" selector="isSqueak">isSqueak	^ self dialectName = #Squeak</body><body package="GlorpExtensions" selector="isVWWithNameSpaces">isVWWithNameSpaces	"For cases where our hacked backports of asQualifiedReference and etc. to VW3 are not sufficient."	^self isVisualWorks and: [self isNamespaceAware]</body><body package="GlorpExtensions" selector="isVisualAge">isVisualAge	^ self dialectName = #VisualAge</body><body package="GlorpExtensions" selector="isVisualWorks">isVisualWorks	^ self dialectName = #VisualWorks</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>class lookup</category><body package="GlorpExtensions" selector="lookupClassNamed:inContextOf:">lookupClassNamed: aString inContextOf: aClass	"Look up the class by name, but use the namespace of the class. Mostly useful if we're trying to guess from unqualified names in dialects with namespaces."	^self lookupClassNamed: aString inContextOf: aClass ifAbsent: [nil].</body><body package="GlorpExtensions" selector="lookupClassNamed:inContextOf:ifAbsent:">lookupClassNamed: aString inContextOf: aClass ifAbsent: aBlock	"Look up the class by name, but use the namespace of the class. Mostly useful if we're trying to guess from unqualified names in dialects with namespaces."	self isVisualWorks ifFalse: [^self smalltalkAt: aString ifAbsent: aBlock].	^aClass environment at: aString ifAbsent: aBlock.</body><body package="GlorpExtensions" selector="smalltalkAssociationAt:">smalltalkAssociationAt: aName	^ self smalltalkAssociationAt: aName ifAbsent: [self error: 'element not found'.]</body><body package="GlorpExtensions" selector="smalltalkAssociationAt:ifAbsent:">smalltalkAssociationAt: aName ifAbsent: aBlock	self isVisualWorks ifTrue: [^ aName asQualifiedReference].	^ Smalltalk associationAt: aName asSymbol ifAbsent: aBlock</body><body package="GlorpExtensions" selector="smalltalkAt:">smalltalkAt: aName	^ self smalltalkAt: aName ifAbsent: [self error: 'element not found'].</body><body package="GlorpExtensions" selector="smalltalkAt:ifAbsent:">smalltalkAt: aName ifAbsent: aBlock	"We may look these names up a lot, so cache them in a small, local dictionary"	| cached value symbol |	symbol := aName asSymbol.	cached := self lookedUpNames at: symbol ifAbsent: [nil].	cached isNil ifFalse: [		(cached isBehavior and: [cached isObsolete]) ifFalse: [^cached]].	value := self isVisualWorks			ifTrue: [((symbol includes: $.)				ifTrue: [symbol asStrictReference]				ifFalse: [symbol asQualifiedReference]) valueOrDo: [^aBlock value]]			ifFalse: [Smalltalk at: symbol ifAbsent: aBlock].	self lookedUpNames		at: symbol		put: value.	^value.</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="controlsTables">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^false</body><body package="GlorpMappings" selector="isRelationship">isRelationship	"True when the mapping associates different persistent classes."	^false</body><body package="GlorpMappings" selector="isStoredInSameTable">isStoredInSameTable	^true</body><body package="GlorpMappings" selector="mappedFields">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^Array with: self field</body><body package="GlorpMappings" selector="mapsSimpleObject">mapsSimpleObject	^true.</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="buildQuery">buildQuery	"We just want to read our main object back again. So we create a join from our primary key fields to themselves. One side will remain field references, the other side will turn into parameters when it's converted to a where clause."	| whereClause |	whereClause := Join new.	descriptor primaryTable primaryKeyFields do: [:each |		whereClause addSource: each target: each].	query := Query returningOneOf: descriptor describedClass where: whereClause.	query retrieve: self attribute name.	query session: self session.	^query.</body><body package="GlorpMappings" selector="convertValueToDatabaseForm:">convertValueToDatabaseForm: aValue		converter isNil ifTrue: [^aValue].	^converter convertedDbValueOf: aValue.</body><body package="GlorpMappings" selector="expressionFor:basedOn:relation:">expressionFor: anObject basedOn: anExpression relation: aSymbol	"Return our expression using the object's values. e.g. if this was a direct mapping from id-&gt;ID and the object had id: 3, then return TABLE.ID=3"	| value |	value := anObject isNil		ifTrue: [nil]		ifFalse:			[anObject isGlorpExpression				ifTrue: [anObject getMapping: self named: self attributeName]				ifFalse: [anObject glorpIsCollection					ifTrue: [anObject collect: [:each | attribute getValueFrom: each]]					ifFalse: [attribute getValueFrom: anObject]]].	^(anExpression get: self attribute name) get: aSymbol withArguments: (Array with: value).</body><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap	^self mapFromObject: anObject toTarget: anObject puttingRowsIn: aRowMap.</body><body package="GlorpMappings" selector="mapFromObject:toTarget:puttingRowsIn:">mapFromObject: anObject toTarget: target puttingRowsIn: aRowMap	| dbValue value row |	self canWrite ifFalse: [^self].	value := self getValueFrom: anObject.	value := self session realObjectFor: value ifNone: [^self].	dbValue := self convertedDbValueOf: value.	row := aRowMap findOrAddRowForTable: self field table withKey: target.	row at: field put: dbValue.</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anElementBuilder	| value |	self shouldProxy ifTrue: [		^self setValueIn: anObject to: ((self newProxyIn: anElementBuilder)						session: descriptor session;						parameters: (self parametersIn: anElementBuilder);						glorpOwner: anObject)].	value := self valueInBuilder: anElementBuilder.	self setValueIn: anObject to: value.</body><body package="GlorpMappings" selector="parametersIn:">parametersIn: anElementBuilder	| parameters |	parameters := IdentityDictionary new.	descriptor primaryTable primaryKeyFields do: [:each | parameters at: each put: (anElementBuilder valueOfField: each)].	^parameters.</body><body package="GlorpMappings" selector="query">query	query isNil ifTrue: [self buildQuery].	^query.</body><body package="GlorpMappings" selector="queryFor:">queryFor: anObjectBuilder	"If we have a specific query we should use in this case, rather than our general one, construct it. Right now that only applies if we're using filtered reads"	^self query.</body><body package="GlorpMappings" selector="readBackNewRowInformationFor:fromRowsIn:">readBackNewRowInformationFor: anObject fromRowsIn: aRowMap 	| value row |	field isGenerated ifFalse: [^self].	self canWrite ifFalse: [^false].	row := aRowMap findOrAddRowForTable: self field table withKey: anObject.	value := self convertedStValueOf: (row at: field ifAbsent: [^self]).	attribute setValueIn: anObject to: value</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	^self.</body><body package="GlorpMappings" selector="valueIn:as:">valueIn: anElementBuilder as: anExpression	| dbValue valueToGet |	valueToGet := anExpression canTranslateFields 		ifTrue: [anExpression translateField: field] 		ifFalse: [anExpression].	dbValue := anElementBuilder		valueOfField: valueToGet.	^self convertedStValueOf: dbValue.</body><body package="GlorpMappings" selector="valueInBuilder:">valueInBuilder: anElementBuilder	^self valueInBuilder: anElementBuilder as: field.</body><body package="GlorpMappings" selector="valueInBuilder:as:">valueInBuilder: anElementBuilder as: anExpression	| dbValue |	dbValue := anElementBuilder valueOfField: anExpression.	^self convertedStValueOf: dbValue.</body><body package="GlorpMappings" selector="valueOfField:fromObject:">valueOfField: aField fromObject: anObject	field = aField ifFalse: [self error: 'Mapping doesn''t describe field'].	^self convertedDbValueOf: (self getValueFrom: anObject).</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="converter">converter	^converter.</body><body package="GlorpMappings" selector="converter:">converter: aDatabaseConverter	converter := aDatabaseConverter.</body><body package="GlorpMappings" selector="field">field	^field</body><body package="GlorpMappings" selector="field:">field: aDatabaseFieldOrExpression	field := (Dialect isBlock: aDatabaseFieldOrExpression)		ifTrue: [			self beReadOnly.			aDatabaseFieldOrExpression asGlorpExpressionOn: (BaseExpression new descriptor: descriptor)]		ifFalse: [aDatabaseFieldOrExpression].</body><body package="GlorpMappings" selector="fieldsForDescriptorSelectStatement">fieldsForDescriptorSelectStatement	"Return a collection of fields that this mapping will read from a row when the containing object is read, as opposed to when we're specifically told to use this field. Normally it amounts to the same thing, but if a direct mapping is proxied, we don't want its field when the parent is read"	^self shouldProxy ifTrue: [self descriptor primaryTable primaryKeyFields] ifFalse: [super fieldsForDescriptorSelectStatement].</body><body package="GlorpMappings" selector="shouldProxy">shouldProxy	^shouldProxy.</body><body package="GlorpMappings" selector="shouldProxy:">shouldProxy: aBoolean	shouldProxy := aBoolean.</body><body package="GlorpMappings" selector="type:">type: aClass	self attribute type: aClass.	field isNil ifFalse: [		self setConverterBetween: aClass and: field].</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>private</category><body package="GlorpMappings" selector="convertedDbValueOf:">convertedDbValueOf: stValue 	^converter isNil		ifTrue: [stValue]		ifFalse: [converter convert: stValue toDatabaseRepresentationAs: self field type]</body><body package="GlorpMappings" selector="convertedStValueOf:">convertedStValueOf: dbValue 	^(converter isNil)		ifTrue: [dbValue]		ifFalse: [converter convert: dbValue fromDatabaseRepresentationAs: self field type]</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>enumerating</category><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:">referencedIndependentObjectsFrom: anObject	^#().</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>printing SQL</category><body package="GlorpMappings" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	self field printSQLOn: aStream withParameters:aDictionary.</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	super validate.	(field isGlorpExpression and: [self readOnly not]) ifTrue: [self error: 'Mappings to functions cannot be written'].</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>initialize-release</category><body package="GlorpMappings" selector="from:to:">from: anAttributeName to: aField	| type |	self attributeName: anAttributeName.	self field: (descriptor fieldFor: aField).	type := self attribute type isNil ifTrue: [field impliedSmalltalkType] ifFalse: [self attribute type].	self type: type.</body><body package="GlorpMappings" selector="from:type:to:">from: anAttributeName type: aClass to: aField	self		attributeName: anAttributeName;		field: aField;		type: aClass.</body><body package="GlorpMappings" selector="fromPseudoVariable:to:">fromPseudoVariable: anAttributeName to: aField	^self fromPseudoVariable: anAttributeName		type: aField impliedSmalltalkType		to: aField</body><body package="GlorpMappings" selector="fromPseudoVariable:type:to:">fromPseudoVariable: anAttributeName type: aClass to: aField	self from: anAttributeName type: aClass to: aField.	self beForPseudoVariable.</body><body package="GlorpMappings" selector="initialize">initialize	super initialize.	shouldProxy := false.</body><body package="GlorpMappings" selector="setConverterBetween:and:">setConverterBetween: aClass and: aDbField 	aClass isNil ifTrue: [^self].	converter := descriptor ifNotNil: 					[descriptor system converterBetweenStType: aClass andField: aDbField]				ifNil: [aDbField converterForStType: aClass]</body></methods><methods><class-id>Glorp.DirectMapping class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="from:to:">from: attributeName to: field	^self from: attributeName		type: field impliedSmalltalkType		to: field</body><body package="GlorpMappings" selector="from:type:to:">from: attributeName type: aClass to: field	^self new		attributeName: attributeName;		field: field;		type: aClass.</body><body package="GlorpMappings" selector="fromPseudoVariable:to:">fromPseudoVariable: attributeName to: field	^self fromPseudoVariable: attributeName		type: field impliedSmalltalkType		to: field</body><body package="GlorpMappings" selector="fromPseudoVariable:type:to:">fromPseudoVariable: attributeName type: aClass to: field	^self new		attributeName: attributeName;		field: field;		beForPseudoVariable.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>accessing</category><body package="GlorpDatabase" selector="addSourceField:">addSourceField: aField	(self sourceFields allSatisfy: [:each | aField table = each table]) ifFalse: [self error: 'Fields in foreign key constraints must all have the same source table'].	self sourceFields add: aField.</body><body package="GlorpDatabase" selector="addTargetField:">addTargetField: aField	(self targetFields allSatisfy: [:each | aField table = each table]) ifFalse: [self error: 'Fields in foreign key constraints must all have the same target table'].	self targetFields add: aField.</body><body package="GlorpDatabase" selector="someSourceField">someSourceField	"Return any one of our source fields"	^self sourceFields first.</body><body package="GlorpDatabase" selector="sourceField:">sourceField: aField	self sourceFields isEmpty ifFalse: [self error: 'Adding a field to a non-empty constraint'].	self sourceFields add: aField.</body><body package="GlorpDatabase" selector="sourceFields">sourceFields	^sourceFields</body><body package="GlorpDatabase" selector="sourceFields:">sourceFields: aCollection		sourceFields := aCollection.</body><body package="GlorpDatabase" selector="sourceTable">sourceTable	"All the source fields have to come from the same table, so just pick one"	^self sourceFields first table.</body><body package="GlorpDatabase" selector="suffixExpression">suffixExpression	^suffixExpression</body><body package="GlorpDatabase" selector="suffixExpression:">suffixExpression: anObject	suffixExpression := anObject.</body><body package="GlorpDatabase" selector="table">table	^self sourceTable.</body><body package="GlorpDatabase" selector="targetField:">targetField: aField	self targetFields isEmpty ifFalse: [self error: 'Adding a field to a non-empty constraint'].	self targetFields add: aField.</body><body package="GlorpDatabase" selector="targetFields">targetFields	^targetFields</body><body package="GlorpDatabase" selector="targetFields:">targetFields: aCollection	targetFields := aCollection.</body><body package="GlorpDatabase" selector="targetTable">targetTable	"All the target fields have to come from the same table, so just pick one"	^self targetFields isEmpty ifTrue: [nil] ifFalse: [self targetFields first table].</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>initializing</category><body package="GlorpDatabase" selector="initialize"> initialize	self sourceFields: (OrderedCollection new: 2).	targetFields := OrderedCollection new: 2.</body><body package="GlorpDatabase" selector="sourceField:targetField:">sourceField: aDatabaseField targetField: anotherDatabaseField	self		sourceField: aDatabaseField		targetField: anotherDatabaseField		suffixExpression: nil.</body><body package="GlorpDatabase" selector="sourceField:targetField:suffixExpression:">sourceField: aDatabaseField targetField: anotherDatabaseField suffixExpression: suffixExpressionString	self		sourceField: aDatabaseField;		targetField: anotherDatabaseField;		suffixExpression: suffixExpressionString.</body><body package="GlorpDatabase" selector="sourceFields:targetFields:suffixExpression:">sourceFields: sourceFieldCollection targetFields: targetFieldCollection suffixExpression: suffixExpressionString	self		sourceFields: sourceFieldCollection;		targetFields: targetFieldCollection;		suffixExpression: suffixExpressionString.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>testing</category><body package="GlorpDatabase" selector="isForeignKeyConstraint">isForeignKeyConstraint	^true</body><body package="GlorpDatabase" selector="isImaginary">isImaginary	^self targetTable isImaginary or: [self sourceTable isImaginary].</body><body package="GlorpDatabase" selector="isSimilarForeignKeyConstraint:">isSimilarForeignKeyConstraint: aConstraint	self sourceFields size ~= aConstraint sourceFields size ifTrue: [^false].	self sourceFields asSortedCollection with: aConstraint sourceFields asSortedCollection do: [:field1 :field2 | 		(field1 matchesField: field2) ifFalse: [^false]].	self targetFields size ~= aConstraint targetFields size ifTrue: [^false].	self targetFields asSortedCollection with: aConstraint targetFields asSortedCollection do: [:field1 :field2 | 		(field1 matchesField: field2) ifFalse: [^false]].	^true</body><body package="GlorpDatabase" selector="matchesForeignKeyConstraint:">matchesForeignKeyConstraint: aConstraint	name asUppercase = aConstraint name asUppercase ifFalse: [^false].	self sourceFields size ~= aConstraint sourceFields size ifTrue: [^false].	self sourceFields with: aConstraint sourceFields do: [:field1 :field2 | 		(field1 matchesField: field2) ifFalse: [^false]].	self targetFields size ~= aConstraint targetFields size ifTrue: [^false].	self targetFields with: aConstraint targetFields do: [:field1 :field2 | 		(field1 matchesField: field2) ifFalse: [^false]].	^true</body><body package="GlorpDatabase" selector="refersToTable:">refersToTable: aTable	^self targetTable yourself == aTable.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>comparing</category><body package="GlorpDatabase" selector="isTheSameAs:">isTheSameAs: aForeignKeyConstraint	"Validate that two constraints are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aForeignKeyConstraint name asUppercase ifFalse: [^false].	self suffixExpression = aForeignKeyConstraint suffixExpression ifFalse: [^false].	self sourceFields size ~= aForeignKeyConstraint sourceFields size ifTrue: [^false].	self sourceFields asSortedCollection with: aForeignKeyConstraint sourceFields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self targetFields size ~= aForeignKeyConstraint targetFields size ifTrue: [^false].	self targetFields asSortedCollection with: aForeignKeyConstraint targetFields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self shouldCreateInDatabase = aForeignKeyConstraint shouldCreateInDatabase ifFalse: [^false].	^true.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>converting</category><body package="GlorpDatabase" selector="asJoin">asJoin	^Join fromAll: self sourceFields toAll: self targetFields.</body><body package="GlorpDatabase" selector="asReverseJoin">asReverseJoin	^Join fromAll: self targetFields toAll: self sourceFields.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>printing</category><body package="GlorpDatabase" selector="creationStringFor:">creationStringFor: aPlatform	^aPlatform createForeignKeyConstraintAddStatement: self</body><body package="GlorpDatabase" selector="generateName">generateName	| stream maxLength tableLength roomToBeVerbose shortTableLength longTableLength |	self sourceFields isEmpty ifTrue: [^'INVALID CONSTRAINT'].	"Figure out if we have room for verbose separators or if we should maximize the space for the table/field names"	maxLength := self sourceFields first table platform maximumLengthOfTableName.	shortTableLength := ((maxLength - 8) // 2) min: 10.	longTableLength := (maxLength // 2) - 1.	roomToBeVerbose := shortTableLength &gt;= 10.	tableLength := roomToBeVerbose ifTrue: [shortTableLength] ifFalse: [longTableLength].	stream := WriteStream on: (String new: 100).	self printForConstraintName: self sourceFields first on: stream maxLength: tableLength.	roomToBeVerbose ifTrue: [stream nextPutAll: '_TO_'].	self printForConstraintName: self targetFields first on: stream maxLength: tableLength.	stream nextPutAll: (roomToBeVerbose ifTrue: ['_REF'] ifFalse: ['R']).	^stream contents.</body><body package="GlorpDatabase" selector="printForConstraintName:on:maxLength:">printForConstraintName: aField on: aStream maxLength: maxLength 	| constraintName |	constraintName := aField table name , '_' , aField name.	constraintName size &gt; maxLength 		ifTrue: [constraintName := constraintName copyFrom: 1 to: maxLength].	aStream nextPutAll: constraintName</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>relationships</category><body package="GlorpDatabase" selector="rowsRelatedTo:">rowsRelatedTo: aRow	| myWrapper relatedRows sourceField targetField allWrappers |	"Note that we don't care which field, as presumably all of them must point the same place for a composite key, so grab the first pair"	sourceField := self sourceFields first.	targetField := self targetFields first.	myWrapper := aRow wrapperAt: sourceField ifAbsent: [nil].	myWrapper isNil ifTrue: [^#()].	relatedRows := Set new: 5.	allWrappers := OrderedCollection with: myWrapper.	allWrappers addAll: myWrapper allInnerWrappers.	allWrappers		do: [:eachWrapper |			(eachWrapper containedBy glorpAtIdentity: targetField ifAbsent: [#()])				do: [:eachRow | eachRow == aRow ifFalse: [relatedRows add: eachRow]]].	^relatedRows.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="sourceField:targetField:">sourceField: aDatabaseField targetField: anotherDatabaseField	^self		sourceField: aDatabaseField		targetField: anotherDatabaseField		suffixExpression: nil.</body><body package="GlorpDatabase" selector="sourceField:targetField:suffixExpression:">sourceField: aDatabaseField targetField: anotherDatabaseField suffixExpression: suffixExpression	^(self new)		sourceField: aDatabaseField targetField: anotherDatabaseField suffixExpression: suffixExpression;		yourself.</body><body package="GlorpDatabase" selector="sourceFields:targetFields:">sourceFields: sourceFields targetFields: targetFields	^self		sourceFields: sourceFields		targetFields: targetFields		suffixExpression: nil.</body><body package="GlorpDatabase" selector="sourceFields:targetFields:suffixExpression:">sourceFields: sourceFields targetFields: targetFields suffixExpression: suffixExpression	^(self new)		sourceFields: sourceFields targetFields: targetFields suffixExpression: suffixExpression;		yourself.</body></methods><methods><class-id>Glorp.GlorpDatabaseWriteError</class-id> <category>accessing</category><body package="GlorpMisc" selector="accessor">accessor	^accessor</body><body package="GlorpMisc" selector="accessor:">accessor: anObject	accessor := anObject</body><body package="GlorpMisc" selector="command">command	^command</body><body package="GlorpMisc" selector="command:">command: aDatabaseCommand	command := aDatabaseCommand</body><body package="GlorpMisc" selector="databaseError">databaseError	^databaseError</body><body package="GlorpMisc" selector="databaseError:">databaseError: aDatabaseErrorObject	databaseError := aDatabaseErrorObject</body><body package="GlorpMisc" selector="session">session	^command session.</body></methods><methods><class-id>Glorp.GlorpDatabaseWriteError</class-id> <category>initialize-release</category><body package="GlorpMisc" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	command := nil.	databaseError := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>private</category><body package="GlorpUnitOfWork" selector="deletedObjects">deletedObjects	^deletedObjects.</body><body package="GlorpUnitOfWork" selector="notFilteringDeletesDo:">notFilteringDeletesDo: aBlock	"Execute aBlock, with filtering of deletes turned off. This is useful if we are in the process of deleting an object. Suppose we are deleting an object that has a link table relationship, but we have already deleted one of the linked objects. We need to make sure we also delete the link table entry, which means we need to know about that linked object, so we don't want Glorp filtering it out for us."	| oldCommitPhase |	[oldCommitPhase := commitPhase.	commitPhase := #registering.	aBlock value] ensure: [commitPhase := oldCommitPhase].</body><body package="GlorpUnitOfWork" selector="privateGetRowMap">privateGetRowMap	^rowMap</body><body package="GlorpUnitOfWork" selector="privateGetTransaction">privateGetTransaction	^transaction.</body><body package="GlorpUnitOfWork" selector="registerAsNew:">registerAsNew: anObject 	anObject isNil ifTrue: [^nil].	commitPhase == #building ifTrue: [self halt]. "Should not happen. Probably indicates that we're triggering proxies while firing the mappings"	self newObjects add: anObject.	self register: anObject.	^anObject</body><body package="GlorpUnitOfWork" selector="sendPostWriteNotification">sendPostWriteNotification	self 		registeredObjectsDo: [:eachObject | session sendPostWriteEventTo: eachObject]</body><body package="GlorpUnitOfWork" selector="sendPreWriteNotification">sendPreWriteNotification	self 		registeredObjectsDo: [:eachObject | session sendPreWriteEventTo: eachObject]</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="correspondenceMap">correspondenceMap	^transaction undoMap</body><body package="GlorpUnitOfWork" selector="newObjects">newObjects	newObjects isNil ifTrue: [newObjects := IdentitySet new].	^newObjects</body><body package="GlorpUnitOfWork" selector="numberOfRows">numberOfRows	^commitPlan size + deletePlan size.</body><body package="GlorpUnitOfWork" selector="rowsToWrite">rowsToWrite	^commitPlan.</body><body package="GlorpUnitOfWork" selector="session">session	^session</body><body package="GlorpUnitOfWork" selector="session:">session: aGlorpSession	session := aGlorpSession</body><body package="GlorpUnitOfWork" selector="system">system	^session system.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>deletion</category><body package="GlorpUnitOfWork" selector="computeCollectionDeletes">computeCollectionDeletes	"If we have objects that are part of exclusive collections, and they have been removed from those collections, then they must be deleted. Note that we do this *before* we register the transitive closure at the end of the unit of work. That means we won't know about any new objects yet, but we don't care because new objects won't be deleted in this way. And that way if we delete and then add another object with (ick) the same primary key, we shouldn't have a clash because the delete will already have been issued."	self registeredObjects do: [:each |		| descriptor |		(descriptor := session descriptorFor: each class) isNil			ifFalse: [descriptor mappings do: [:eachMapping |				self computeCollectionDeletesFor: eachMapping inObject: each]]].</body><body package="GlorpUnitOfWork" selector="computeCollectionDeletesFor:inObject:">computeCollectionDeletesFor: aMapping inObject: anObject	"Figure out which, if any, dependent objects we should delete based on changes to the corresponding collection in anObject"	| collection memento collectionMemento |	aMapping isExclusive ifFalse: [^self].	aMapping attribute isCollectionAttribute ifFalse: [^self].	collection := aMapping getValueFrom: anObject.	collection := self session realObjectFor: collection ifNone: [^self].	(aMapping isValidTarget: collection) ifFalse: [^self].	memento := transaction mementoFor: anObject.	collectionMemento := transaction collectionMementoFor: (self session realObjectFor: (aMapping getValueFrom: memento)).	"OK, now we have the state of the original collection and the new collection, we can look for differences."	collectionMemento do: [:each |		| matching |		(each isGlorpProxy not or: [each isInstantiated]) ifTrue: [			matching := collection 				detect: [:eachElement | 					(eachElement isGlorpProxy not or: [eachElement isInstantiated])						and: [each yourSelf == eachElement yourSelf]]				ifNone: [nil].			matching == nil ifTrue: [session delete: each]		]	].</body><body package="GlorpUnitOfWork" selector="delete:">delete: anObject	(self isRegistered: anObject) ifFalse: [session registerForDelete: anObject].	deletedObjects add: anObject.	(session embeddedObjectsFor: anObject) do: [:each | self delete: each].</body><body package="GlorpUnitOfWork" selector="hasPendingDeletions">hasPendingDeletions	^deletedObjects isEmpty not.</body><body package="GlorpUnitOfWork" selector="undelete:ifNotDeleted:">undelete: anObject ifNotDeleted: aBlock	deletedObjects remove: anObject ifAbsent: aBlock.	(session embeddedObjectsFor: anObject) do: [:each | self undelete: each].</body><body package="GlorpUnitOfWork" selector="willDelete:">willDelete: anObject	"Return true if we will delete anObject when we commit."		^(deletedObjects includes: anObject) or: [deleting includes: anObject].</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>registering</category><body package="GlorpUnitOfWork" selector="isRegistered:">isRegistered: anObject	^transaction isRegistered: anObject.</body><body package="GlorpUnitOfWork" selector="register:">register: anObject 	| realObject |	commitPhase == #building ifTrue: [self halt]. "Should not happen. Probably indicates that we're triggering proxies while firing the mappings"	realObject := transaction register: anObject.	self registerTransitiveClosureFrom: realObject.</body><body package="GlorpUnitOfWork" selector="registerForDelete:">registerForDelete: anObject 	"Register anObject with intent to delete it."	[deleting add: anObject.	self register: anObject] ensure: [deleting remove: anObject ifAbsent: []].</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>begin/commit/abort</category><body package="GlorpUnitOfWork" selector="abort">abort	self reinitialize.</body><body package="GlorpUnitOfWork" selector="abort:">abort: anObject	transaction abort: anObject</body><body package="GlorpUnitOfWork" selector="begin">begin	self reinitialize.</body><body package="GlorpUnitOfWork" selector="commit">commit	[self preCommit.	self writeRows] ifCurtailed: [succeeded := false].	succeeded		ifTrue: [self postCommit]		ifFalse:			[GlorpTransactionFailure signal].</body><body package="GlorpUnitOfWork" selector="createMementoRowMapFor:">createMementoRowMapFor: objects 	"Create a rowmap for the objects whose state was already known. We subtract this from the rowmap of all known objects to get the rows that need to be written. New objects are also registered, so we only generate rows here for non-new objects"	| localRowMap |	localRowMap := RowMapForMementos 				withCorrespondenceMap: self correspondenceMap.	localRowMap collectionMementos: transaction collectionMementos.	objects keysAndValuesDo: 			[:original :memento | 			(self newObjects includes: original) 				ifFalse: [session createRowsFor: memento in: localRowMap]].	^localRowMap</body><body package="GlorpUnitOfWork" selector="createRowMapFor:">createRowMapFor: objects	| localRowMap |	localRowMap := RowMap new: objects size.	objects do: [:each | session createRowsFor: each in: localRowMap].	^localRowMap</body><body package="GlorpUnitOfWork" selector="createRows">createRows	self createRowsForPartialWrites.</body><body package="GlorpUnitOfWork" selector="createRowsForCompleteWrites">createRowsForCompleteWrites	"reference implementation. not called from anywhere"	self registeredObjectsDo: [:eachObject | session createRowsFor: eachObject in: rowMap].	deletedObjects do: [:eachObject | session createDeleteRowsFor: eachObject in: rowMap].</body><body package="GlorpUnitOfWork" selector="createRowsForPartialWrites">createRowsForPartialWrites	| registeredObjectsRowMap mementoObjectsRowMap |	registeredObjectsRowMap := self createRowMapFor: self registeredObjects.	deletedObjects 		do: [:eachObject | session createDeleteRowsFor: eachObject in: registeredObjectsRowMap].	mementoObjectsRowMap := self createMementoRowMapFor: self mementoObjects.	rowMap := registeredObjectsRowMap differenceFrom: mementoObjectsRowMap.</body><body package="GlorpUnitOfWork" selector="mementoObjects">mementoObjects	"Warning: Excessive cleverness!!! The mementoObjects we want to iterate over are the values in the correspondenceMap dictionary. We were getting the values and returning them, but if all we need to do is iterate, then the dictionary itself works fine"	^self correspondenceMap.</body><body package="GlorpUnitOfWork" selector="postCommit">postCommit	self sendPostWriteNotification.	self updateSessionCache.	self validateRowsPostWrite.</body><body package="GlorpUnitOfWork" selector="preCommit">preCommit	commitPhase := #registering.	self registerTransitiveClosure.	commitPhase := #building.	self createRows.	linkRowsForUpdate := rowMap collapseMatchingInsertsAndDeletes.	self buildCommitPlan.	commitPhase := nil.	self sendPreWriteNotification.	self validateRows.</body><body package="GlorpUnitOfWork" selector="propagateDeletes">propagateDeletes	"If we have objects which are to be deleted, and they have exclusive relationships to other objects, then we must also delete those other objects."	| deletionQueue |	deletionQueue := OrderedCollection new: deletedObjects size.	deletionQueue addAll: deletedObjects.	[deletionQueue isEmpty]		whileFalse:			[| each |			each := deletionQueue removeFirst.			(self session descriptorFor: each) mappings				do:					[:eachMapping | 					eachMapping isExclusive						ifTrue:							[eachMapping								loopOverAttributeOf: each								doing:									[:index :subObject | 									| realSubObject |									realSubObject := subObject yourSelf.									(realSubObject notNil and: [(deletedObjects includes: realSubObject) not])										ifTrue:											[session delete: subObject.											deletionQueue add: realSubObject]]]]].</body><body package="GlorpUnitOfWork" selector="registeredObjects">registeredObjects	^self correspondenceMap keys</body><body package="GlorpUnitOfWork" selector="registerTransitiveClosure">registerTransitiveClosure	"Look for new objects reachable from currently registered objects, and propagate deletions"	self computeCollectionDeletes.	self		registeredObjectsDo:			[:eachObject | self registerTransitiveClosureFrom: eachObject].	self propagateDeletes.</body><body package="GlorpUnitOfWork" selector="rollback">rollback	self abort.</body><body package="GlorpUnitOfWork" selector="validateRows">validateRows	"Perform basic validation. Always test for equal named but non-identical tables, a sign of a malformed  system or other loss of identity. Also delegate to the descriptorSystem, which may have useful application-specific validations to do."		| tables tableNames |	tables := Set new.	rowMap rowsDo: [:each |		tables add: each table].	tableNames := tables collect: [:each | each qualifiedName].	tables asSet size = tableNames asSet size ifFalse: [self error: 'multiple table objects with the same name'].	self system validateRows: self.</body><body package="GlorpUnitOfWork" selector="validateRowsPostWrite">validateRowsPostWrite	"Perform basic validation after writing is done. It's better to validate beforehand, but some things are easier to catch afterwards"		self system validateRowsPostWrite: self.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>private/mapping</category><body package="GlorpUnitOfWork" selector="addObject:toCacheKeyedBy:">addObject: eachObject toCacheKeyedBy: key 	| tracker |		self session cacheAt: key put: eachObject.	tracker := self session modificationTracker.	tracker isNil ifFalse: [tracker track: eachObject]</body><body package="GlorpUnitOfWork" selector="addToCommitPlan:">addToCommitPlan: aRow	aRow shouldBeWritten ifFalse: [^self].	commitPlan add: aRow.</body><body package="GlorpUnitOfWork" selector="addToDeletePlan:">addToDeletePlan: aRow		deletePlan add: aRow.</body><body package="GlorpUnitOfWork" selector="assignSequenceNumbers">assignSequenceNumbers	commitPlan do: [:each | each preWriteAssignSequencesUsing: self session].</body><body package="GlorpUnitOfWork" selector="buildCommitPlan">buildCommitPlan	| tablesInCommitOrder |	commitPlan := OrderedCollection new.	deletePlan := OrderedCollection new.	tablesInCommitOrder := session tablesInCommitOrder.	tablesInCommitOrder do: 			[:eachTable | 			self rowsForTable: eachTable				do: 					[:eachRow | 					eachRow forDeletion 						ifTrue: [self addToDeletePlan: eachRow]						ifFalse: [self addToCommitPlan: eachRow]]].	self sortCommitPlanRows.</body><body package="GlorpUnitOfWork" selector="instantiateIfRequiredFor:mapping:">instantiateIfRequiredFor: anObject mapping: eachMapping	"Sometimes we have to instantiate the targets if they weren't. Specifically, if there's a relationship where the target has a foreign key to us. e.g. if X has a 1-many to Y, and we don't instantiate the collection of Y, but then replace it with some other collection. The Y's keys have to be updated, so we need to make sure they're read. There are other cases, too"	| originalTarget targetObject mapping instantiated |	mapping := eachMapping applicableMappingForObject: anObject.	mapping isRelationship ifFalse: [^false].	mapping readOnly ifTrue: [^false].	targetObject := mapping getValueFrom: anObject.	(self isNewObject: anObject)		ifTrue:			[^self instantiateIfRequiredForNewObjectReferenceTo: targetObject].	instantiated := (self willDelete: anObject)		ifTrue:			[self instantiateIfRequiredForDeletedObjectReferencing: targetObject from: anObject in: eachMapping]		ifFalse: [false].	originalTarget := self originalValueFor: anObject mapping: mapping.	^instantiated or: [self		instantiateIfRequiredForReferenceChangedFrom: originalTarget		to: targetObject].</body><body package="GlorpUnitOfWork" selector="instantiateIfRequiredForDeletedObjectReferencing:from:in:">instantiateIfRequiredForDeletedObjectReferencing: targetObject from: anObject in: aMapping	"If we are deleted, then we need to have at least one mapping for each of our primary keys instantiated. If we're lucky, there's a direct mapping, and it's easy. Note that this only looks for the primary table. This might not be correct, but it's not clear, and for secondary tables there's a multiple table join that can be used without needing a mapping. And I'm not prepared to think about secondary tables whose keys are mapped only as relationships. In addition, if we use a link table, then we need to instantiate the reference, because we'll need to have enough information to delete the link table entry/entries."	| mappingsToUseForPrimaryKeys |	aMapping mapsPrimaryKeys ifFalse: [^false].		aMapping usesLinkTable ifTrue: [		"Make sure we get the non-filtered version, and return false so that if the reference has changed, we'll also get the original version."		self notFilteringDeletesDo: [targetObject yourSelf]. ^false].	mappingsToUseForPrimaryKeys := aMapping descriptor primaryKeyMappingsFor: aMapping descriptor primaryTable.	"For any of the fields we map, is there anyone else who can get us the value. If not, instantiate us. It might be better to optimize this a bit to look for e.g. one-one mappings before to-many."	aMapping mappedFields do: [:each |		| mappings |		mappings := mappingsToUseForPrimaryKeys at: each ifAbsent: [nil].		mappings isNil ifFalse: [			(mappings allSatisfy: [:eachMapping | 				(eachMapping hasValueThatCanProvideField: each from: anObject) not])					ifTrue: [						targetObject yourSelf.						^true]]].	^false.</body><body package="GlorpUnitOfWork" selector="instantiateIfRequiredForNewObjectReferenceTo:">instantiateIfRequiredForNewObjectReferenceTo: targetObject	"If it's a new object, then we always need to instantiate"	targetObject isGlorpProxy ifFalse: [^false].	targetObject getValue.	^true.</body><body package="GlorpUnitOfWork" selector="instantiateIfRequiredForReferenceChangedFrom:to:">instantiateIfRequiredForReferenceChangedFrom: originalTarget to: newTarget	"For an existing relationship, we need to instantiate if the object we're referring to changed, and either was or is now a proxy. Actually we might get away without if it used to be, but now isn't, but better safe than sorry."	| wasProxy  |	originalTarget == newTarget ifTrue: [^false].	wasProxy := false.	self notFilteringDeletesDo: [		originalTarget isGlorpProxy ifTrue: [wasProxy := true. originalTarget getValue].		newTarget isGlorpProxy ifTrue: [wasProxy := true. newTarget getValue]].	^wasProxy.</body><body package="GlorpUnitOfWork" selector="originalValueFor:mapping:">originalValueFor: anObject mapping: eachMapping	| memento |	memento := transaction undoMap at: anObject.	^eachMapping getValueFrom: memento.</body><body package="GlorpUnitOfWork" selector="readBackNewRowInformation">readBackNewRowInformation	| changedObjects |	changedObjects := rowMap objects.	changedObjects		do: 			[:each | 			| descriptor |			descriptor := session descriptorFor: each.			descriptor isNil ifFalse: [descriptor readBackNewRowInformationFor: each in: rowMap]]</body><body package="GlorpUnitOfWork" selector="registerTransitiveClosureFrom:">registerTransitiveClosureFrom: anObject	| descriptor |	anObject glorpIsCollection ifTrue: [		anObject do: [:each | session register: each].		^self].	descriptor := session descriptorFor: anObject class.	descriptor isNil ifTrue: [^self].	descriptor mappings do: [:eachMapping |			self instantiateIfRequiredFor: anObject mapping: eachMapping].	descriptor referencedIndependentObjectsFrom: anObject do: [:eachObject |		session register: eachObject].</body><body package="GlorpUnitOfWork" selector="relatedRowsFor:">relatedRowsFor: each	| rows extraRows |	rows := each relatedRowsIn: rowMap.	extraRows := self session system additionalRelatedRowsFor: each in: rowMap.	extraRows isNil ifFalse: [rows addAll: extraRows].	^rows select: [:eachRelatedRow | eachRelatedRow status notNil].</body><body package="GlorpUnitOfWork" selector="reserveSequenceNumbers">reserveSequenceNumbers	rowsByTable := commitPlan glorpGroupedBy: [:each | each table].	rowsByTable keysAndValuesDo: [:eachTable :rows | 		eachTable sequences do: [:eachSequence | 			eachSequence 				reserveSequenceNumbers: (					rows inject: 0 into: [:sum :each | 						(each needsValueFromSequence: eachSequence) 							ifTrue: [sum + 1] ifFalse: [sum]])					in: self session					for: eachTable]]</body><body package="GlorpUnitOfWork" selector="sortCommitPlanRows">sortCommitPlanRows	| sorter |	sorter := GlorpRowSorter new		getChildrenVia: [:each | self relatedRowsFor: each].	commitPlan := sorter sort: commitPlan.	sorter := GlorpRowSorter new		getChildrenVia: [:each | self relatedRowsFor: each].	deletePlan := sorter sort: deletePlan.</body><body package="GlorpUnitOfWork" selector="updateSessionCache">updateSessionCache	rowMap		keysAndValuesDo: [:eachObject :eachRow | 			eachRow shouldBeWritten ifTrue: [				self updateSessionCacheFor: eachObject withRow: eachRow]].	deletedObjects do: [:each |		session cacheRemoveObject: each].	linkRowsForUpdate do: [:eachRow |		eachRow shouldBeWritten ifTrue: [			self updateSessionCacheFor: eachRow owner withRow: eachRow]].</body><body package="GlorpUnitOfWork" selector="updateSessionCacheFor:withRow:">updateSessionCacheFor: anObject withRow: aRow 	| key |	(rowMap isRowMapKey: anObject) ifTrue: [^self].  "Not cachable"	key := aRow primaryKey.	key isNil ifTrue: [^self].	(session cacheContainsObjectForClass: anObject class key: key) 		ifFalse: [self addObject: anObject toCacheKeyedBy: key].</body><body package="GlorpUnitOfWork" selector="writeRows">writeRows	succeeded := true.	self reserveSequenceNumbers.	self assignSequenceNumbers.	self session tablesInCommitOrder do: [:eachTable | self writeRowsForTable: eachTable].	deletePlan reverseDo: [:eachRow | | rowSucceeded |		rowSucceeded := session writeRow: eachRow.		succeeded := succeeded &amp; rowSucceeded].	self readBackNewRowInformation.</body><body package="GlorpUnitOfWork" selector="writeRowsForTable:">writeRowsForTable: aTable	| rows rowsByOperation |	rows := rowsByTable at: aTable ifAbsent: [#()].	^rows isEmpty ifFalse: [		rowsByOperation := rows glorpGroupedBy: [:eachRow | session shouldInsert: eachRow].		rowsByOperation do: [:eachListOfHomogeneousRows | 			succeeded := succeeded &amp; (session writeHomogeneousRows: eachListOfHomogeneousRows)]].</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>enumerating</category><body package="GlorpUnitOfWork" selector="registeredObjectsDo:">registeredObjectsDo: aBlock	transaction registeredObjectsDo: [:each |		(each glorpIsCollection or: [session hasDescriptorFor: each]) ifTrue: [			aBlock value: each]].</body><body package="GlorpUnitOfWork" selector="rowsForTable:do:">rowsForTable: aTable do: aBlock	rowMap rowsForTable: aTable do: aBlock.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>initializing</category><body package="GlorpUnitOfWork" selector="initialize">initialize	transaction := ObjectTransaction new.	self reinitialize</body><body package="GlorpUnitOfWork" selector="reinitialize">reinitialize	rowMap := RowMap new.	commitPhase := nil.	deletedObjects := IdentitySet new.	deleting := IdentitySet new.	commitPlan := OrderedCollection new.	deletePlan := OrderedCollection new.	transaction abort.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>testing</category><body package="GlorpUnitOfWork" selector="forcesUpdateFor:">forcesUpdateFor: aDatabaseRow	^linkRowsForUpdate notNil and: [linkRowsForUpdate includes: aDatabaseRow].</body><body package="GlorpUnitOfWork" selector="isNewObject:">isNewObject: anObject 	^self newObjects includes: anObject.</body><body package="GlorpUnitOfWork" selector="shouldFilterDeletions">shouldFilterDeletions	"Should we filter deleted objects from the results of queries. We don't do this if we're in the process of registering the transitive closure, because any fetches we do there are in order to get information we need for the commit (e.g. primary keys). If we filtered the deleted objects, then we may not be able to figure out primary keys for the objects to be deleted"	^commitPhase ~~ #registering.</body></methods><methods><class-id>Glorp.UnitOfWork class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>accessing</category><body package="GlorpMappings" selector="allClasses">allClasses	allClasses isEmpty ifTrue: [allClasses := self constructAllClasses].	^allClasses</body><body package="GlorpMappings" selector="allClassModels">allClassModels	^self allClasses collect: [:each | 		self classModelFor: each].</body><body package="GlorpMappings" selector="allDescriptors">allDescriptors	^self allClasses collect: [:each | 		self descriptorFor: each].</body><body package="GlorpMappings" selector="allSequences">allSequences	sequences isEmpty ifFalse: [^sequences].	sequences := self allSequencesFor: self allTables.	^sequences.</body><body package="GlorpMappings" selector="allSequencesFor:">allSequencesFor: aCollection	"Find all the sequences associated with aCollectionOfTables"	| result |	result := Dictionary new.	aCollection do: [:each |		each allSequences keysAndValuesDo: [:eachName :eachSequence |				result at: eachName put: eachSequence]].	^result.</body><body package="GlorpMappings" selector="allTableNames">allTableNames	"Return a list of all the table names that this system uses."	^#().</body><body package="GlorpMappings" selector="allTables">allTables	tables isEmpty ifTrue: [self constructAllTables].	^tables.</body><body package="GlorpMappings" selector="cachePolicy">cachePolicy	"Return the default cache policy that will be used for descriptors that don't specify their own policy"	cachePolicy isNil ifTrue: [cachePolicy := CachePolicy default].	^cachePolicy.</body><body package="GlorpMappings" selector="cachePolicy:">cachePolicy: aCachePolicy	cachePolicy := aCachePolicy.</body><body package="GlorpMappings" selector="databaseSchema">databaseSchema	^ self session schema</body><body package="GlorpMappings" selector="defaultTracing">defaultTracing	^Tracing new</body><body package="GlorpMappings" selector="platform">platform	^platform</body><body package="GlorpMappings" selector="platform:">platform: dbPlatform	platform := dbPlatform</body><body package="GlorpMappings" selector="session">session	^session</body><body package="GlorpMappings" selector="session:">session: anObject	session := anObject</body><body package="GlorpMappings" selector="useDirectAccessForMapping">useDirectAccessForMapping	^useDirectAccessForMapping</body><body package="GlorpMappings" selector="useDirectAccessForMapping:">useDirectAccessForMapping: anObject	useDirectAccessForMapping := anObject</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>api</category><body package="GlorpMappings" selector="addClassModelFor:">addClassModelFor: aClass	^classModels		at: aClass		ifAbsentPut: [self newClassModelFor: aClass]</body><body package="GlorpMappings" selector="classModelFor:">classModelFor: aClass	(self allClasses includes: aClass) ifFalse: [^nil].	^classModels		at: aClass		ifAbsentPut: [self newClassModelFor: aClass]</body><body package="GlorpMappings" selector="createMappingsFromClassModelIn:">createMappingsFromClassModelIn: aDescriptor 	aDescriptor classModel attributesDo: 			[:each | 			(aDescriptor mappingForAttributeNamed: each name) isNil 				ifTrue: 					[self createMappingIn: aDescriptor						fromClassModelForAttributeNamed: each name]]</body><body package="GlorpMappings" selector="databaseIdentitySequenceNamed:">databaseIdentitySequenceNamed: aString	^self databaseSequenceNamed: aString</body><body package="GlorpMappings" selector="databaseSequenceNamed:">databaseSequenceNamed: aString	^sequences at: aString asUppercase ifAbsentPut: [platform newDatabaseSequenceNamed: aString].</body><body package="GlorpMappings" selector="databaseSequenceNamed:ifAbsentPut:">databaseSequenceNamed: aString ifAbsentPut: aBlock	^sequences at: aString asUppercase ifAbsentPut: aBlock.</body><body package="GlorpMappings" selector="databaseTableClass">databaseTableClass	^self class databaseTableClass</body><body package="GlorpMappings" selector="descriptorFor:">descriptorFor: aClassOrObject 	| theClass newDescriptor |	aClassOrObject == Proxy ifTrue: [self error: 'Cannot find descriptor for the class Proxy. Pass in the instance'].	theClass := aClassOrObject glorpCanHaveDescriptorDirectly 				ifTrue: [aClassOrObject]				ifFalse: [aClassOrObject isGlorpProxy 							ifTrue: [aClassOrObject getValue class]							ifFalse: [aClassOrObject class]].	^descriptors		at: theClass		ifAbsent: [			(self allClasses includes: theClass) ifTrue: [				newDescriptor := self newDescriptorFor: theClass.				descriptors at: theClass put: newDescriptor.				self initializeDescriptor: newDescriptor.				newDescriptor.			]].</body><body package="GlorpMappings" selector="descriptorForTable:">descriptorForTable: aTable	"Return a descriptor that uses aTable. If there is more than one, the choice is random."	^descriptors detect: [:each | each tables includes: aTable] ifNone: [nil].</body><body package="GlorpMappings" selector="descriptorsForTable:">descriptorsForTable: aTable	"Return all descriptors that use aTable."	^descriptors select: [:each | each tables includes: aTable].</body><body package="GlorpMappings" selector="existingTableNamed:">existingTableNamed: aString	^tables at: aString asUppercase ifAbsent: [self error: 'missing table'].</body><body package="GlorpMappings" selector="flushAllClasses">flushAllClasses	allClasses := OrderedCollection new.</body><body package="GlorpMappings" selector="hasDescriptorFor:">hasDescriptorFor: aClassOrObject 	^(self descriptorFor: aClassOrObject) notNil.</body><body package="GlorpMappings" selector="sequenceTypeNamed:">sequenceTypeNamed: aString	"Return a sequence type whose sequence has the given name."	^self platform sequence sequence: (self databaseSequenceNamed: aString).</body><body package="GlorpMappings" selector="tableNamed:">tableNamed: aString	^self tableNamed: aString ifNone: [NoTableFound new parameter: aString; raiseRequest].</body><body package="GlorpMappings" selector="tableNamed:ifNone:">tableNamed: aString ifNone: aBlock	^tables at: aString asString asUppercase		ifAbsent: 			[| newTable |			newTable := self databaseTableClass new.			newTable name: aString.			tables at: aString asUppercase put: newTable.			self initializeTable: newTable.			newTable isEmpty				ifTrue: 					[tables removeKey: aString asUppercase.					^aBlock value].			newTable]</body><body package="GlorpMappings" selector="typeResolverFor:">typeResolverFor: aClassOrObject 	| theClass |	aClassOrObject == Proxy ifTrue: [self error: 'Cannot find type resolver for the class Proxy. Pass in the instance'].	theClass := aClassOrObject glorpCanHaveDescriptorDirectly 				ifTrue: [aClassOrObject]				ifFalse: [aClassOrObject isGlorpProxy ifTrue: [aClassOrObject getValue class] ifFalse: [aClassOrObject class]].	^typeResolvers at: theClass ifAbsentPut: [self newTypeResolverFor: theClass]</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMappings" selector="converterBetweenStType:andField:">converterBetweenStType: aClass andField: aField 	| selector |	selector := ('converterBetween' , aClass name , 'AndField:') asSymbol.	(self respondsTo: selector) ifTrue: [^self perform: selector with: aField].	^aField converterForStType: aClass</body><body package="GlorpMappings" selector="createMappingIn:fromClassModelForAttributeNamed:">createMappingIn: aDescriptor fromClassModelForAttributeNamed: aSymbol 	| attribute referenceModel |	attribute := aDescriptor classModel attributeNamed: aSymbol.	referenceModel := self classModelFor: attribute type.	referenceModel isNil 		ifTrue: 			[^(aDescriptor newMapping: DirectMapping) from: aSymbol				to: (aDescriptor table 						fieldNamed: (self fieldNameForAttributeName: aSymbol))]		ifFalse: 			[attribute isCollectionAttribute 				ifTrue: [^(aDescriptor newMapping: ToManyMapping) attributeName: aSymbol]				ifFalse: [^(aDescriptor newMapping: OneToOneMapping) attributeName: aSymbol]]</body><body package="GlorpMappings" selector="initializeClassModel:">initializeClassModel: aClassModel	| selector |	selector := ('classModelFor' , aClassModel describedClass name , ':')		asSymbol.	(self respondsTo: selector)		ifTrue: [^self perform: selector with: aClassModel].	(aClassModel describedClass respondsTo: #glorpSetupClassModel:forSystem:)		ifTrue:			[^aClassModel describedClass				glorpSetupClassModel: aClassModel				forSystem: self].	"Otherwise, just initialize it dynamically, so that old code with only descriptors will still work"	^aClassModel.</body><body package="GlorpMappings" selector="initializeDescriptor:">initializeDescriptor: aDescriptor 	| selector |	selector := ('descriptorFor' , aDescriptor describedClass name , ':') asSymbol.	(self respondsTo: selector) 		ifTrue: [self perform: selector with: aDescriptor]		ifFalse: [			(aDescriptor describedClass respondsTo: #glorpSetupDescriptor:forSystem:)				ifTrue: [aDescriptor describedClass								glorpSetupDescriptor: aDescriptor								forSystem: self]				ifFalse: [self noDescriptorInitializerFound: aDescriptor]].</body><body package="GlorpMappings" selector="initializeTable:">initializeTable: newTable	| initializerName |	initializerName := ('tableFor' , (newTable name asUppercase) , ':') asSymbol.	(self respondsTo: initializerName)		ifTrue: [self perform: initializerName with: newTable]		ifFalse: [self noTableInitializerFound: newTable].	newTable postInitializeIn: self.</body><body package="GlorpMappings" selector="newClassModelFor:">newClassModelFor: aClass	| newClassModel |	newClassModel := GlorpClassModel new.	newClassModel system: self.	newClassModel describedClass: aClass.	self initializeClassModel: newClassModel.	^newClassModel.</body><body package="GlorpMappings" selector="newDescriptorFor:">newDescriptorFor: aClass	| newDescriptor |	(self allClasses includes: aClass) ifFalse: [^nil].	newDescriptor := Descriptor new.	newDescriptor system: self.	newDescriptor classModel: (self classModelFor: aClass).	^newDescriptor.</body><body package="GlorpMappings" selector="newTypeResolverFor:">newTypeResolverFor: aClass 	| selector |	(self allClasses includes: aClass) ifFalse: [^nil].	selector := ('typeResolverFor' , aClass name) asSymbol.	^(self respondsTo: selector) 		ifTrue: [self perform: selector]		ifFalse: [aClass glorpTypeResolver]</body><body package="GlorpMappings" selector="privateAndBasicAddDescriptorFor:as:">privateAndBasicAddDescriptorFor: anObject as: aDescriptor	"Just add the descriptor and don't try to validate. anObject may not actually even be a class. Assume the descriptor is already properly initialized"	descriptors at: anObject put: aDescriptor.	aDescriptor system: self.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>initialization</category><body package="GlorpMappings" selector="addClassesFromDescriptorMethodsFor:">addClassesFromDescriptorMethodsFor: aClass	| match |	match := 'descriptorFor'.	Dialect selectorsFor: aClass do: 			[:each | 			(each copyFrom: 1 to: (match size min: each size)) = match				ifTrue:					[| className actualClass |					className := each copyFrom: match size + 1 to: each size - 1.					actualClass := Dialect						lookupClassNamed: className						inContextOf: self class						ifAbsent: [nil].					actualClass isNil ifFalse: [allClasses add: actualClass]]].</body><body package="GlorpMappings" selector="addTablesFromInitializeMethodsFor:">addTablesFromInitializeMethodsFor: aClass	| match |	match := 'tableFor'. 	Dialect selectorsFor: aClass do:			[:each | 			(each copyFrom: 1 to: (match size min: each size)) = match				ifTrue:					[| tableName |					tableName := each copyFrom: match size + 1 to: each size - 1.					self tableNamed: tableName]].</body><body package="GlorpMappings" selector="constructAllClasses">constructAllClasses	"Subclasses can override this method to add classes. But by default we also look for all descriptor methods in our system, and add them to the class list, so if the methods are written there, then we don't need to do anything further. If the descriptor methods are defined on the classes themselves, then we'll still have to construct the class list manually."	self constructClassesFromDescriptorMethods.	^allClasses.</body><body package="GlorpMappings" selector="constructAllTables">constructAllTables	"Subclasses can override this method to add tables to the list. But by default we also look for all table methods in our system, and add them to the class list, so if the methods are written there, then we don't need to do anything further. If the table methods are defined on the classes themselves, then we'll still have to construct the list manually."	self allTableNames do: [:each | 		self tableNamed: each asString].	self constructTablesFromInitializeMethods.	^tables.</body><body package="GlorpMappings" selector="constructClassesFromDescriptorMethods">constructClassesFromDescriptorMethods	self withAllSuperclassesDo: [:aClass | self addClassesFromDescriptorMethodsFor: aClass].	self class includeAllClassesWithDescriptorMethods		ifTrue:			[Object withAllSubclasses				do:					[:each | 					(each class						compiledMethodAt: #glorpSetupDescriptor:forSystem:						ifAbsent: [nil]) isNil ifFalse: [allClasses add: each]]].</body><body package="GlorpMappings" selector="constructTablesFromInitializeMethods">constructTablesFromInitializeMethods	self withAllSuperclassesDo: [:aClass | self addTablesFromInitializeMethodsFor: aClass].</body><body package="GlorpMappings" selector="initialize">initialize	descriptors := Dictionary new.	tables := Dictionary new.	classModels := Dictionary new.	typeResolvers := Dictionary new.	sequences := Dictionary new.	useDirectAccessForMapping := true.	allClasses := OrderedCollection new.</body><body package="GlorpMappings" selector="setUpDefaults">setUpDefaults	"For systems that are configurable, set them up for testing configuration"</body><body package="GlorpMappings" selector="withAllSuperclassesDo:">withAllSuperclassesDo: aBlock	| currentClass |	currentClass := self class.	[currentClass == Object]		whileFalse:			[aBlock value: currentClass.			currentClass := currentClass superclass].</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>testing</category><body package="GlorpMappings" selector="canUseGroupedWrites">canUseGroupedWrites	"We can use grouped writes as long as there are no identity columns in use"	self platform usesIdentityColumns ifFalse: [^true].	^(self allTables anySatisfy: [:each |		each primaryKeyFields anySatisfy: [:eachField |			eachField type isSerial and: [eachField type sequence isIdentityColumn]]]) not.</body><body package="GlorpMappings" selector="canUseGroupedWritesFor:">canUseGroupedWritesFor: aTable	"We can use grouped writes as long as there are no identity columns in use"	self platform usesIdentityColumns ifFalse: [^true].	^(aTable primaryKeyFields anySatisfy: [:eachField |			eachField type isSerial and: [eachField type sequence isIdentityColumn]]) not.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>settings</category><body package="GlorpMappings" selector="shouldForeignKeyValueBeTreatedAsNull:">shouldForeignKeyValueBeTreatedAsNull: aValue	"Return true if this foreign key value should be treated as null, meaning there's no relationship. Normally this means just nil, but descriptor systems can override if they have special values which they use (e.g. 0) that indicate a missing relationship. This can improve performance by avoiding unnecessary queries to the database for things we know will never return a result"	^aValue isNil.</body><body package="GlorpMappings" selector="shouldResetExpiryTimeForObjectOfClass:readFrom:">shouldResetExpiryTimeForObjectOfClass: aClass readFrom: aQuery	"Return true if, when an object is read from a query, even if it's not refreshing. we 'touch' it, resetting its expiry time. By default, we do this if the cache policy for that type of object will remove from the cache. The rationale is that this means we're using the object. Removing an object in use is a very bad thing, and can cause loss of identity and other bad things. However, if expiry only indicates a need to refresh, we don't need to touch the object. Subclasses can override to provide different behaviour."	aQuery shouldRefresh ifTrue: [^true].	aQuery returnProxies ifTrue: [^false].	^(self session cacheForClass: aClass)  willRemoveItems</body><body package="GlorpMappings" selector="useJoinsForAnySatisfy">useJoinsForAnySatisfy	useJoinsForAnySatisfy isNil ifTrue: [useJoinsForAnySatisfy := false].	^useJoinsForAnySatisfy.</body><body package="GlorpMappings" selector="useJoinsForAnySatisfy:">useJoinsForAnySatisfy: aBoolean	useJoinsForAnySatisfy := aBoolean.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>validation</category><body package="GlorpMappings" selector="noDescriptorInitializerFound:">noDescriptorInitializerFound: aDescriptor	self error: 'No descriptor initializer found for ', aDescriptor printString.</body><body package="GlorpMappings" selector="noTableInitializerFound:">noTableInitializerFound: aDatabaseTable	self error: 'No table initializer found for ', aDatabaseTable printString.</body><body package="GlorpMappings" selector="unmappedInstanceVariables">unmappedInstanceVariables	"Return a list, for all of our classes, of instance variables with no mappings. This can be used by inspection to see if we're missing mappings we think we ought to have."	"self unmappedInstanceVariables"	| unmapped |	unmapped := Dictionary new.	self allClasses do: [:eachClass |		eachClass allInstVarNames do: [:eachInstVarName |			((self descriptorFor: eachClass) mappingForAttributeNamed: eachInstVarName asSymbol)				isNil ifTrue: [					(unmapped at: eachClass ifAbsentPut: [OrderedCollection new])						add: eachInstVarName]]].	^unmapped.</body><body package="GlorpMappings" selector="validate">validate	session isNil ifFalse: [session system == self ifFalse: [InvalidSessionSetup  raiseErrorString:  'Invalid session setup']].	self allTables do: [:each | each validateIn: self].	self allClassModels do: [:each | each validateIn: self].	self allDescriptors do: [:each | each validate].</body><body package="GlorpMappings" selector="validateDescriptor:">validateDescriptor: aDescriptor	"Validate aDescriptor in the context of this system, doing any specific validations that need the full environment information or rely on subclass-specific information here."</body><body package="GlorpMappings" selector="validateRows:">validateRows: aUnitOfWork	"This is a hook to allow the system to do application-specific validation of the rows to be written. I suppose it's also possible to modify the rows here. Subclasses can override if they have useful work to do here. This will be called after the rows are generated, pre-write notification has been sent, rows have been sorted for writing, and and just before sequence numbers (if pre-write) are assigned, and writing starts"</body><body package="GlorpMappings" selector="validateRowsPostWrite:">validateRowsPostWrite: aUnitOfWork	"Validate after writing. This is a bit late, but some things may not be catchable ahead of time"</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>optimization parameters</category><body package="GlorpMappings" selector="maximumSizeToGroupWriteFor:">maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows	"If we are going to group write, how many rows of this collection should we do it for at once. Normally we delegate this to the platform, but we allow the system to intervene if desired"	^platform maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows.</body><body package="GlorpMappings" selector="shouldUpdateOnlyChangedFieldsFor:">shouldUpdateOnlyChangedFieldsFor: aRow	"Return true if we should write only changed fields out in an update statement, or if we should write all of them. The tradeoff is that writing only the changed ones will produce less SQL, but make more variations of the statement, and require us to keep more prepared statements around if we're using binding. By default, use this option only if we're not using binding by default"	^aRow useBinding not.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>callbacks</category><body package="GlorpMappings" selector="additionalRelatedRowsFor:in:">additionalRelatedRowsFor: aRow in: aRowMap	"This method serves as a hook. It is called when sorting rows before writing to the database, and can be used to return a list of additional related rows that aren't found by the normal foreign key constraints. These rows will act as an ordering constraint, and will have to be written before aRow."	^nil.</body><body package="GlorpMappings" selector="fieldNameForAttributeName:">fieldNameForAttributeName: aSymbol 	^aSymbol asString asUppercase</body><body package="GlorpMappings" selector="joinFor:toTables:fromConstraints:toConstraints:">joinFor: aMapping toTables: toTables fromConstraints: fromConstraints toConstraints: toConstraints	"Return the join to be used for aMapping. The set of tables we expect this to be related to, and the constraints from this table, and to this table are provided as possibly useful input."	| numberOfConstraints |	numberOfConstraints := (Set new addAll: toConstraints; addAll: fromConstraints; yourself) size.	numberOfConstraints = 0 ifTrue: [		CannotAutomaticallyDetermineJoin new 			tables: toTables;			constraints: (toConstraints, fromConstraints);			signal: 'Cannot automatically determine join, no constraints found.'].	numberOfConstraints &gt; 1 ifTrue: [		CannotAutomaticallyDetermineJoin new			tables: toTables;			constraints: (toConstraints, fromConstraints);			signal: 'Cannot automatically determine join, too many constraints found.'].	^toConstraints isEmpty ifTrue: [fromConstraints first asReverseJoin] ifFalse: [toConstraints first asJoin].</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>session creation</category><body package="GlorpMappings" selector="sessionForLogin:">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| newSession |	platform isNil ifTrue: [self platform: aGlorpLogin database].	aGlorpLogin database class = self platform class ifFalse: [self error: 'Login is incompatible with the database specified in the descriptor system'].	newSession := GlorpSession new.	newSession accessor: (DatabaseAccessor forLogin: aGlorpLogin).	newSession system: self.	^newSession.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>internal/writing</category><body package="GlorpMappings" selector="tablesInCommitOrder">tablesInCommitOrder	^(TableSorter for: self allTables) sort.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>sequences</category><body package="GlorpMappings" selector="sequenceNameForField:">sequenceNameForField: aDatabaseField	"Return the name of the sequence we will use for a field. Subclasses can override to use different naming conventions."	^(aDatabaseField table sqlString), '_', (aDatabaseField name), '_seq'</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="forPlatform:">forPlatform: dbPlatform	^super new initialize;		platform: dbPlatform</body><body package="GlorpMappings" selector="new">new	^super new initialize.</body><body package="GlorpMappings" selector="sessionForLogin:">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| system session |	system := self forPlatform: aGlorpLogin database.	session := GlorpSession new.	session accessor: (DatabaseAccessor forLogin: aGlorpLogin).	session system: system.	^session.</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>configuration</category><body package="GlorpMappings" selector="includeAllClassesWithDescriptorMethods">includeAllClassesWithDescriptorMethods	"If this is true, the descriptor system will automatically include all classes that define the #glorpSetupDescriptor:forSystem: method on the class side. If false, it will only include classes which have descriptor methods defined in this class, or those explicitly added in the #constructAllClasses method."	^false.</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>utility</category><body package="GlorpMappings" selector="createTablesFor:">createTablesFor: aLogin	"Create the tables for this descriptor system in the given database. This will fail if the tables already exist. Use recreateTables for that."	| session |	session := self sessionForLogin: aLogin.	session login.	[session createTables] ensure: 		[session logout].</body><body package="GlorpMappings" selector="dropTablesFor:">dropTablesFor: aLogin	"Drop the tables for this descriptor system in the given database."	| session |	session := self sessionForLogin: aLogin.	session login.	[session dropTables] ensure: [session logout].</body><body package="GlorpMappings" selector="recreateTablesFor:">recreateTablesFor: aLogin	"Drop and recreate the tables for this descriptor system in the given database."	| session |	session := self sessionForLogin: aLogin.	session login.	[session recreateTables] ensure: [session logout].</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>class defaults</category><body package="GlorpMappings" selector="databaseTableClass">databaseTableClass	^DatabaseTable</body></methods><methods><class-id>Glorp.MySQLSequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor 	aDatabaseRow at: aDatabaseField		put: ((anAccessor 				executeSQLString: 'SELECT LAST_INSERT_ID()') first atIndex: 1).</body><body package="GlorpDatabase" selector="reserveSequenceNumbers:in:for:">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body></methods><methods><class-id>Glorp.MySQLSequence</class-id> <category>testing</category><body package="GlorpDatabase" selector="isIdentityColumn">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="hasParameters">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^true.</body><body package="GlorpDatabaseTypes" selector="isIntegerType">isIntegerType	"If we have no precision and no scale, we're effectively an Integer"	^self precision isNil and: [self scale isNil]</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="precision">precision	^precision.</body><body package="GlorpDatabaseTypes" selector="precision:">precision: anInteger	precision := anInteger.</body><body package="GlorpDatabaseTypes" selector="scale">scale	^scale.</body><body package="GlorpDatabaseTypes" selector="scale:">scale: anInteger	scale := anInteger.</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'numeric'.</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	"Can we do better than this??"	^#FixedPoint</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToInteger].	^self platform converterNamed: #numberToNumber.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	self isIntegerType ifTrue: [^Integer].	^super impliedSmalltalkType</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	| w |	platform supportsVariableSizedNumerics ifFalse: [^typeString].	w := WriteStream on: String new.	w nextPutAll: typeString.	precision isNil 		ifFalse: 			[w nextPutAll: '(' , precision printString.			scale isNil ifFalse: [w nextPutAll: ',' , scale printString].			w nextPutAll: ')'].	^w contents</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes" selector="=">= aType	"We do a special case check here that something that reads back as numeric with no scale/precision counts as being the same as an integer type"	((aType class == self platform integer class) and: [self isIntegerType]) ifTrue: [^true].	super = aType ifFalse: [^false].	self precision = aType precision ifFalse: [^false].	self scale = aType scale ifFalse: [^false].	^true.</body><body package="GlorpDatabaseTypes" selector="hash">hash	"A very special case here, if we're effectively an Integer, then we need to hash in a way compatible with GlorpIntegerType"	self isIntegerType ifTrue: [^self platform hash bitXor: self impliedSmalltalkType hash].	^(super hash bitXor: self precision hash) bitXor: self scale hash</body></methods><methods><class-id>Glorp.TableBasedSequence</class-id> <category>accessing</category><body package="GlorpDatabase" selector="sequenceTableName">sequenceTableName	"Private - Answer the value of the receiver's ''sequenceTableName'' instance variable."	^sequenceTableName</body><body package="GlorpDatabase" selector="sequenceTableName:">sequenceTableName: aString	sequenceTableName := aString</body></methods><methods><class-id>Glorp.TableBasedSequence</class-id> <category>testing</category><body package="GlorpDatabase" selector="isIdentityColumn">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.TableBasedSequence class</class-id> <category>defaults</category><body package="GlorpDatabase" selector="default">default	^self new sequenceTableName: 'SEQUENCE'.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>converting</category><body package="GlorpExpressions" selector="asGeneralGlorpExpression">asGeneralGlorpExpression	"We know that we represent querying for an abstract class, so we don't want to convert ourselves to a join form, but rather just to a source mapping form. There are some assumptions in here, but it should work for the basic cases anyway."	| base expression anyJoin descriptor |	anyJoin := self anyJoin.	base := anyJoin base.	descriptor := base system descriptorForTable: anyJoin allTargetFields first table.	expression := EmptyExpression new base: base.	anyJoin mappableFieldsDo: [:source :target |		| mapping thingToCompare |		mapping := descriptor mappingForField: target.		thingToCompare := mapping isNil			ifTrue: [base getField: target]			ifFalse: [base get: mapping attributeName].		expression := expression AND: (thingToCompare get: #= withArguments: (Array with: (source asGlorpExpressionOn: base)))].	^expression.</body><body package="GlorpExpressions" selector="asGeneralGlorpExpressionWithFields">asGeneralGlorpExpressionWithFields	"The normal conversion of a join is to an expression equating fields and parameters. Instead, generate one with field to field comparisons. "	| base expression mappingName anyJoin descriptor |	anyJoin := self anyJoin.	base := anyJoin base.	descriptor := base system descriptorForTable: anyJoin allTargetFields first table.	expression := EmptyExpression new base: base.	anyJoin mappableFieldsDo: [:source :target |		mappingName := (descriptor mappingForField: target) attributeName.		expression := expression AND: ((base get: mappingName) get: #= withArguments: (Array with: (self targetExpressionFor: source)))].	^expression.</body><body package="GlorpExpressions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copy.	copy joins: (copy joins collect: [:each | each asGlorpExpressionOn: aBaseExpression]).	^copy.</body><body package="GlorpExpressions" selector="isConstant:">isConstant: aTarget	"The target can be either a constant (which gets turned into a ConstantExpression) or (usually) a DatabaseField, representing a parameter to the query"	(aTarget class == DatabaseField) ifTrue: [^false].	(aTarget isGlorpExpression and: [aTarget isConstantExpression not]) ifTrue: [^false].	^true.</body><body package="GlorpExpressions" selector="targetExpressionFor:">targetExpressionFor: eachTarget 	^(self isConstant: eachTarget)		ifTrue: [eachTarget]		ifFalse: [			eachTarget isGlorpExpression 			ifTrue: [eachTarget] 			ifFalse: [(self anyJoin base getTable: eachTarget table) getField: eachTarget]].</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>accessing</category><body package="GlorpExpressions" selector="addJoinFor:as:">addJoinFor: aClass as: aJoin	joins at: aClass put: aJoin.</body><body package="GlorpExpressions" selector="allSourceFields">allSourceFields	"We assume that variable joins vary in the targets, not the in sources."	^self anyJoin allSourceFields</body><body package="GlorpExpressions" selector="allTargetFields">allTargetFields	^joins inject: OrderedCollection new into: [:sum :each | sum addAll: each allTargetFields. sum].</body><body package="GlorpExpressions" selector="anyJoin">anyJoin	^joins detect: [:each | true].</body><body package="GlorpExpressions" selector="generalExpressionPart">generalExpressionPart	^nil.</body><body package="GlorpExpressions" selector="joins">joins	^joins.</body><body package="GlorpExpressions" selector="joins:">joins: aCollection	joins := aCollection.</body><body package="GlorpExpressions" selector="mappableSourceFieldsDo:">mappableSourceFieldsDo: aBlock	self anyJoin mappableSourceFieldsDo: aBlock.</body><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^self ultimateBaseExpression.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^self anyJoin base.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOn:">printOn: aStream	[aStream query] on: Error do: [:ex | ^super printOn: aStream].	(joins at: aStream query resultClass) printOn: aStream.</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary 	[aStream query] on: Error do: [:ex | ^super printOn: aStream].	(joins at: aStream query resultClass) printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>initialize-release</category><body package="GlorpExpressions" selector="initialize">initialize	joins := IdentityDictionary new.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>testing</category><body package="GlorpExpressions" selector="isGlorpExpression">isGlorpExpression	^true.</body><body package="GlorpExpressions" selector="isJoin">isJoin	^true.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>preparing</category><body package="GlorpExpressions" selector="prepareIn:">prepareIn: aQuery</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^(self joins at: aBaseExpression descriptor describedClass) 		rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="primaryKeyFromDictionary:">primaryKeyFromDictionary: anIdentityDictionary 	^self anyJoin primaryKeyFromDictionary: anIdentityDictionary.</body><body package="GlorpExpressions" selector="shortCircuitOnNullComparison:">shortCircuitOnNullComparison: anIdentityDictionary 	joins do: [:each |		(each shortCircuitOnNullComparison: anIdentityDictionary)			ifFalse: [^false]].	^true.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>api</category><body package="GlorpExpressions" selector="mapFromSource:andTarget:intoRowsIn:">mapFromSource: sourceObject andTarget: targetObject intoRowsIn: aRowMap	(sourceObject isNil or: [targetObject isNil]) ifTrue: [^self].	^(joins at: targetObject class)		mapFromSource: sourceObject		andTarget: targetObject		intoRowsIn: aRowMap.</body></methods><methods><class-id>Glorp.VariableJoin class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.JustSelectTheMaximumSequenceValueAndAddOne</class-id> <category>other</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession	| stream rows value |	"I repeat: ick"	stream := WriteStream on: (String new: 50).	stream nextPutAll: 'SELECT MAX('.	aField printSQLOn: stream withParameters: #().	stream nextPutAll: ') FROM '.	aRow table printSQLOn: stream withParameters: #().	rows := aSession accessor executeSQLString: stream contents.	value := rows first first isNil ifTrue: [1] ifFalse: [rows first first + 1].	aRow at: aField put: value.	^value.</body><body package="GlorpDatabase" selector="reserveSequenceNumbers:in:for:">reserveSequenceNumbers: anInteger in: anAccessor for: aTable	| numberNeeded firstNumber fakeRow |	numberNeeded := anInteger - self availableReservedNumbers.	numberNeeded &lt;= 0 ifTrue: [^self].	fakeRow := DatabaseRow newForTable: self field table.	firstNumber := self		getSequenceValueFromDatabaseFor: self field		in: fakeRow		using: anAccessor.	self reservedNumbers addAll: (firstNumber to: firstNumber + numberNeeded - 1).</body></methods><methods><class-id>Glorp.JustSelectTheMaximumSequenceValueAndAddOne</class-id> <category>accessing</category><body package="GlorpDatabase" selector="field">field	field isNil ifTrue: [field := table primaryKeyFields first].	^field.</body><body package="GlorpDatabase" selector="field:">field: aDatabaseField	field := aDatabaseField.</body><body package="GlorpDatabase" selector="table:">table: aTable	table := aTable.</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>accessing</category><body package="GlorpCore" selector="timeout">timeout	^timeout</body><body package="GlorpCore" selector="timeout:">timeout: seconds	timeout := seconds</body><body package="GlorpCore" selector="timeoutSeconds">timeoutSeconds	^timeout</body><body package="GlorpCore" selector="timeoutSeconds:">timeoutSeconds: anInteger	timeout := anInteger.</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>wrap/unwrap</category><body package="GlorpCore" selector="cacheEntryFor:">cacheEntryFor: anObject	^Array with: self totalSeconds with: anObject.</body><body package="GlorpCore" selector="contentsOf:">contentsOf: aCacheEntry	^aCacheEntry at: 2.</body><body package="GlorpCore" selector="expire:">expire: aCacheEntry	^aCacheEntry at: 1 put: 0.</body><body package="GlorpCore" selector="hasExpired:">hasExpired: aCacheEntry	^(self totalSeconds - (aCacheEntry at: 1)) &gt;= timeout.</body><body package="GlorpCore" selector="markEntryAsCurrent:in:">markEntryAsCurrent: aCacheEntry in: aCache	aCacheEntry at: 1 put: self totalSeconds.</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>utility</category><body package="GlorpCore" selector="totalSeconds">totalSeconds	^Dialect totalSeconds.</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>initialize</category><body package="GlorpCore" selector="initialize">initialize	super initialize.	timeout := 300.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>SQL</category><body package="GlorpDatabase" selector="supportsVariableSizedNumerics">supportsVariableSizedNumerics	"Return true if this platform can support numbers with a varying size and number of decimal places. Access, notably, doesn't seem to be able to"	^false.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	^false.</body><body package="GlorpDatabase" selector="initializeReservedWords">initializeReservedWords	super initializeReservedWords.	reservedWords add: 'timestamp'.</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^64</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^64</body><body package="GlorpDatabase" selector="supportsAuthentication">supportsAuthentication	^false</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	^false.</body><body package="GlorpDatabase" selector="usesNullForFalse">usesNullForFalse	"Return true if this database is likely to use nil as an empty string value"	^true.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="canBind:to:">canBind: aValue to: aType	(Dialect isVisualWorks and: [aValue class == Dialect fixedPointClass]) ifTrue: [^false].	^super canBind: aValue to: aType.</body><body package="GlorpDatabase" selector="isAccessPlatform">isAccessPlatform	^true</body><body package="GlorpDatabase" selector="requiresCastsForNullsInUnions">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^true.</body><body package="GlorpDatabase" selector="supportsAliasInCompoundQuery">supportsAliasInCompoundQuery	"Return true if, when we have a subselect, we can (and/or must) alias the result with a table name. Access doesn't like the table name"	^false.</body><body package="GlorpDatabase" selector="supportsDecimalsOnAllNumerics">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^true.</body><body package="GlorpDatabase" selector="supportsGroupWritingFor:">supportsGroupWritingFor: aCommand	^false.</body><body package="GlorpDatabase" selector="supportsInformationSchema">supportsInformationSchema	^false.</body><body package="GlorpDatabase" selector="supportsSchemas">supportsSchemas	^false</body><body package="GlorpDatabase" selector="supportsStringQueryOnBlobs">supportsStringQueryOnBlobs	"Return true if we can do string queries on parts of blobs."	^false.</body><body package="GlorpDatabase" selector="supportsTableOwners">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^false</body><body package="GlorpDatabase" selector="useMicrosoftOuterJoins">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins. Oddly enough, false for access 2k"	^false.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase" selector="booleanToBooleanConverter">booleanToBooleanConverter	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToDBBoolean:for:		fromDbToSt: #convertDBBooleanToBoolean:for:.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="blob">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'longbinary'].</body><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'memo'].</body><body package="GlorpDatabase" selector="longText">longText	^self typeNamed: #longText ifAbsentPut: [GlorpClobType new typeString: 'memo'].</body><body package="GlorpDatabase" selector="memo">memo	^self typeNamed: #memo ifAbsentPut: [GlorpClobType new typeString: 'memo'].</body><body package="GlorpDatabase" selector="serial">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'autoincrement'].</body><body package="GlorpDatabase" selector="text">text	^self typeNamed: #text ifAbsentPut: [GlorpClobType new typeString: 'longtext'].</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="endColumnQuote">endColumnQuote	^']'.</body><body package="GlorpDatabase" selector="startColumnQuote">startColumnQuote	^'['.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>functions</category><body package="GlorpDatabase" selector="initializeFunctions">initializeFunctions	super initializeFunctions.	functions		at: #copyFrom:to: put: (SubstringFunction named: 'MID')</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="isVariableWidth">isVariableWidth	^false.</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="typeString">typeString	^self typeName, '(', width printString, ')'.</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'char'.</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>bound values</category><body package="GlorpDatabase" selector="bindingTypes">bindingTypes	^super bindingTypes, (row lockKeyFields collect: [:each | each type]).</body><body package="GlorpDatabase" selector="singleRowBindings">singleRowBindings	| basic lockFields lockValues |	basic := super singleRowBindings.	lockFields := row lockKeyFields.	lockFields isEmpty ifTrue: [^basic].	lockValues := OrderedCollection new: 2.	row lockKeyFields do: [:each | 				| fieldValue |			fieldValue := row oldVersionAt: each ifAbsent: [nil].			(self canBind: fieldValue to: each type) ifTrue: [lockValues add: fieldValue]].	^basic, lockValues.</body><body package="GlorpDatabase" selector="singleRowBoundFields">singleRowBoundFields	"Note: We will actually have to bind one more thing than this, the optimistic lock fields (if present). That's handled in the caller"	| basicFields |	basicFields := self fieldsNeedingUpdate.	^basicFields , row table primaryKeyFields asArray</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>testing</category><body package="GlorpDatabase" selector="shouldUpdateOnlyChangedFields">shouldUpdateOnlyChangedFields	"Return true if we should write only changed fields out in an update statement, or if we should write all of them. The tradeoff is that writing only the changed ones will produce less SQL, but make more variations of the statement, and require us to keep more prepared statements around if we're using binding. By default, use this option only if we're not using binding by default. It would be nice if we could delegate this decision to somewhere the user has control over, e.g. the descriptor system, but we don't actually know about it"	^self system shouldUpdateOnlyChangedFieldsFor: self.</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="arrayBindings">arrayBindings	"I don't think we can array bind updates. There may be values in the row that we haven't read, and if we attempt to write all the fields we'll be overwriting them with nulls. It's possible that there's a set of rows with all the same fields and we could update them all the same way, but that isn't done yet"	self error: 'cannot array bind an update'.</body><body package="GlorpDatabase" selector="arrayBoundFields">arrayBoundFields	^row table nonPrimaryKeyFields asArray , row table primaryKeyFields asArray.</body><body package="GlorpDatabase" selector="blockFactor">blockFactor	^1.</body><body package="GlorpDatabase" selector="fieldsNeedingUpdate">fieldsNeedingUpdate	^self shouldUpdateOnlyChangedFields 		ifTrue: [row fieldsNeedingUpdate]		ifFalse: [row nonPrimaryKeyFields]</body><body package="GlorpDatabase" selector="needsRowCount">needsRowCount	^row lockKeyFields isEmpty not.</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>printing</category><body package="GlorpDatabase" selector="printSQL">printSQL	| bodyFields |	self nextPutAll: 'UPDATE '.	row table printSQLOn: self withParameters: #().	self nextPutAll: ' SET '.	bodyFields := self fieldsNeedingUpdate.	GlorpHelper 		do: [:field | row printEqualityTemplateForField: field on: self]		for: bodyFields		separatedBy: [self nextPut: $,].	self nextPutAll: ' WHERE '.	row printPrimaryKeyTemplateOn: self.	row lockKeyFields notEmpty		ifTrue: 			[self nextPutAll: ' AND '.			GlorpHelper				do: [:field | row printLockEqualityForField: field on: self]				for: row lockKeyFields				separatedBy: [self nextPutAll: ' AND ']]</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>testing</category><body package="GlorpQueries" selector="hasEmptyWhereClause">hasEmptyWhereClause	"If we have regular where clause entries, or if we have joins that aren't going to be printed in the tables portion, then we're not empty"	whereClause willPrintAsWhereClause ifTrue: [^false].	self useANSIJoins ifTrue: [^true].	^joins isEmpty.</body><body package="GlorpQueries" selector="hasTracing">hasTracing	"Return true if we've given this query a tracing already"	^builders notNil.</body><body package="GlorpQueries" selector="mightHaveDuplicateRows">mightHaveDuplicateRows	^builders anySatisfy: [:each | each canCauseDuplicateRows].</body><body package="GlorpQueries" selector="requiresFullQuery">requiresFullQuery	| descriptor independent |	descriptor := self descriptor.	"This isn't even a valid query."	descriptor isNil ifTrue: [^false].	independent := descriptor classesRequiringIndependentQueries.	^(independent size ~= 1) or: [(independent at: 1) ~= descriptor describedClass].</body><body package="GlorpQueries" selector="useANSIJoins">useANSIJoins	^self session platform supportsANSIJoins.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>sql generation</category><body package="GlorpQueries" selector="computeTablesToPrint">computeTablesToPrint	| allTables stoppingPoint |	allTables := Set new.	fields do: [:each | allTables addAll: each tablesToPrint].	stoppingPoint := base.	allTables		addAll:			(stoppingPoint isNil				ifTrue: [whereClause allTablesToPrint]				ifFalse: [whereClause allTablesToPrintStoppingAt: stoppingPoint]).	joins		do:			[:eachJoin | 			allTables				addAll:					(stoppingPoint isNil						ifTrue: [eachJoin allTablesToPrint]						ifFalse: [eachJoin allTablesToPrintStoppingAt: stoppingPoint])].	ordering isNil		ifFalse: [ordering do: [:each | 			each field isNil ifFalse: [allTables add: each field table]]].	(groupBy notNil and: [groupBy field notNil])		ifTrue: [allTables add: groupBy field table].	self tracing allTracings		do: [:each | allTables addAll: each allTablesToPrint].	^allTables asSortedCollection.</body><body package="GlorpQueries" selector="printANSITablesOn:">printANSITablesOn: aCommand	"Print ourselves using the JOIN... USING syntax. Note that we have to put the joins in the right order because we're not allowed to refer to tables not mentioned yet. Great syntax. Reminds me of Pascal. And so easy to deal with."	| printer |	printer := JoinPrinter for: self.	printer printJoinsOn: aCommand.</body><body package="GlorpQueries" selector="printJoinsOn:">printJoinsOn: aCommand	| noLeadIn|	self platform supportsANSIJoins ifTrue: [^self].	joins isEmpty ifTrue: [^self].	noLeadIn := whereClause isEmptyExpression.	noLeadIn ifFalse: [aCommand nextPutAll: ' AND ('].	GlorpHelper 			do: [:each | each printSQLOn: aCommand withParameters: aCommand parameters]			for: joins			separatedBy: [aCommand nextPutAll: ' AND '].	noLeadIn ifFalse: [aCommand nextPut: $)].</body><body package="GlorpQueries" selector="printNormalTablesOn:">printNormalTablesOn: aCommand	self printNormalTablesOn: aCommand excluding: #().</body><body package="GlorpQueries" selector="printNormalTablesOn:excluding:">printNormalTablesOn: aCommand excluding: aCollection	aCollection do: [:each | self tablesToPrint remove: each].	GlorpHelper		print: [:table | table sqlTableName]		on: aCommand		for: self tablesToPrint		separatedBy: ', '.	^self tablesToPrint.</body><body package="GlorpQueries" selector="printOffsetOn:">printOffsetOn: aCommand	self hasOffset ifFalse: [^self].	self platform printOffset: self offset on: aCommand.</body><body package="GlorpQueries" selector="printPostLimitOn:">printPostLimitOn: aCommand	self hasLimit ifFalse: [^self].	self platform printPostLimit: self limit on: aCommand.</body><body package="GlorpQueries" selector="printPreLimitOn:">printPreLimitOn: aCommand	self hasLimit ifFalse: [^self].	self platform printPreLimit: self limit on: aCommand.</body><body package="GlorpQueries" selector="printSelectFields:on:">printSelectFields: aCollection on: stream 	| fieldsToPrint |	(aCollection anySatisfy: [:each | each isDistinct]) 		ifTrue: [			fieldsToPrint := aCollection collect: [:each | each asField].			stream nextPutAll: 'DISTINCT ']		ifFalse: [fieldsToPrint := aCollection].	"For SQL Server, the TOP has to come after the distinct, but before the fields"	self printPreLimitOn: stream.				GlorpHelper 		do: [:field | field printSelectSQLOn: stream withParameters: nil. ]		for: fieldsToPrint		separatedBy: [stream nextPutAll: ', '].</body><body package="GlorpQueries" selector="printSelectFieldsOn:">printSelectFieldsOn: stream      self printSelectFields: fields on: stream</body><body package="GlorpQueries" selector="printTablesOn:">printTablesOn: aCommand	aCommand		cr;		nextPutAll: ' FROM '.	self useANSIJoins		ifTrue: [self printANSITablesOn: aCommand]		ifFalse: [self printNormalTablesOn: aCommand].</body><body package="GlorpQueries" selector="printWhereClauseOn:">printWhereClauseOn: aCommand	self hasEmptyWhereClause		ifFalse:			[aCommand				cr;				nextPutAll: ' WHERE '.			whereClause printSQLOn: aCommand withParameters: aCommand parameters].</body><body package="GlorpQueries" selector="signature">signature	session useBinding ifFalse: [^''].	^self sqlWith: Dictionary new.</body><body package="GlorpQueries" selector="sqlString">sqlString	"Mostly for debugging"	^(self sqlWith: #()) sqlString.</body><body package="GlorpQueries" selector="tablesToPrint">tablesToPrint	tablesToPrint isNil ifTrue: [tablesToPrint := self computeTablesToPrint].	^tablesToPrint.</body><body package="GlorpQueries" selector="tablesToPrint:">tablesToPrint: aCollection	tablesToPrint := aCollection.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>executing</category><body package="GlorpQueries" selector="computeFields">computeFields	builders 		do: [:each | self computeFieldsFor: each]</body><body package="GlorpQueries" selector="computeFieldsFor:">computeFieldsFor: anElementBuilder 	| translatedFields |	translatedFields := self 		addFields: anElementBuilder fieldsForSelectStatement		returningTranslationForFields: anElementBuilder fieldsFromMyPerspective		distinct: anElementBuilder requiresDistinct.	anElementBuilder fieldTranslations: translatedFields.</body><body package="GlorpQueries" selector="rowsFromDatabaseWithParameters:">rowsFromDatabaseWithParameters: anArray	| alreadyTriedAction command |	(self shortCircuitEmptyReturn: anArray) ifTrue: [^session accessor cursorFor: (ReadStream on: #()) command: (self sqlWith: anArray)].	alreadyTriedAction := false.	command := self sqlWith: anArray.	^[session accessor		executeCommand: command		returnCursor: true] 	on: GlorpDatabaseReadError 	do: [:ex | 		alreadyTriedAction ifTrue: [ex pass] ifFalse: [alreadyTriedAction := true].		session errorAction isNil 			ifTrue: [ex pass] 			ifFalse: [				session errorAction value: ex value: session value: self.					ex retry]].</body><body package="GlorpQueries" selector="setUpExpressions">setUpExpressions	super setUpExpressions.	self validateWhereClause.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>preparing</category><body package="GlorpQueries" selector="addAllOrderingsForBuilder:">addAllOrderingsForBuilder: aBuilder		| expression fieldExpressions |	expression := aBuilder expression.	fieldExpressions := expression descriptor primaryTable primaryKeyFields collect: [:each | expression getField: each].	fieldExpressions do: [:each | self addSingleOrderingForBuilder: each].</body><body package="GlorpQueries" selector="addJoin:">addJoin: anExpression	joins addAll: anExpression asIndependentJoins.</body><body package="GlorpQueries" selector="addOrderingForToManyJoins">addOrderingForToManyJoins	"If we have a join to a to-many relation, then we need for all the joined bits to be grouped together in order in the result set"	| problemBuilders baseBuilders |	problemBuilders := builders select: [:each | each canCauseDuplicateRows].	baseBuilders := problemBuilders		collect:			[:each | 			builders				detect: [:eachBuilder | eachBuilder expression == each expression base]				ifNone: [nil]].	baseBuilders do: [:each | 		each isNil ifFalse: [self addAllOrderingsForBuilder: each]].</body><body package="GlorpQueries" selector="addSingleOrderingForBuilder:">addSingleOrderingForBuilder: aFieldExpression	"Add the ordering to the query, as long as we don't already have an equivalent ordering there."		ordering isNil ifTrue: [^self orderBy: aFieldExpression].	ordering 		detect: [:eachExistingOrdering | 			eachExistingOrdering = aFieldExpression 				or: [eachExistingOrdering field = aFieldExpression field and: [eachExistingOrdering base = aFieldExpression base]]]		ifNone: [self orderBy: aFieldExpression].</body><body package="GlorpQueries" selector="adjustWhereClause">adjustWhereClause	"Make any adjustments to the where clause. This includes adjusting direct object equality expressions to be primary key comparisons, removing primary key comparisons where we can compare a foreign key, and condensing boolean constants out of expressions."	whereClause := whereClause rewriteEquality. "Special because otherwise we'd be throwing away the top-level one"	whereClause := whereClause rewriteBooleanEquality: nil.	whereClause do: [:each | each rewriteEqualityExpressions].	whereClause do: [:each | each condensePrimaryKeyComparisons].	whereClause := whereClause condensePrimaryKeyComparison.	whereClause := whereClause condenseBooleanEquality.	whereClause do: [:each | each condenseBooleanEqualityExpressions].	(whereClause isConstantExpression and: [whereClause value = true])		ifTrue: [			whereClause := EmptyExpression on: whereClause value.			whereClause base: base.].	whereClause do: [:each | each rewriteFunctionArguments].</body><body package="GlorpQueries" selector="assignTableAliases">assignTableAliases	| tableNumber allExpressions |	whereClause isJoin ifTrue: [^self].	tableNumber := 1.	allExpressions := ExpressionGroup with: whereClause.	allExpressions addAll: ordering.	allExpressions add: groupBy.	allExpressions addAll: joins.	builders do: [:each | allExpressions add: each expression].	allExpressions		do:			[:each | tableNumber := each assignTableAliasesStartingAt: tableNumber prefix: self tablePrefix].	"We've aliased tables, joins may now become independent"	joins := joins inject: OrderedCollection new into: [:sum :each | (sum addAll: each asIndependentJoins). sum].</body><body package="GlorpQueries" selector="copyOfBuilders">copyOfBuilders 	"Copy the builders, but make sure that subBuilders also get matched up"	| newBuilders |	newBuilders := builders collect: [:each | each copy].	newBuilders do: [:each | each reconcileWithBuilders: builders andCopy: newBuilders].	^newBuilders.</body><body package="GlorpQueries" selector="fixJoins">fixJoins	| pseudoJoins realJoins |	pseudoJoins := joins select: [:each | each tablesForANSIJoin size &lt; 2].	pseudoJoins do: [:each | whereClause := each AND: whereClause].	realJoins :=  joins select: [:each| each tablesForANSIJoin size &gt;= 2].	joins := realJoins.</body><body package="GlorpQueries" selector="isPrepared">isPrepared	^prepared.</body><body package="GlorpQueries" selector="prepare">prepare	prepared ifTrue: [^self].	self setupTracing.	whereClause prepareIn: self.	self assignTableAliases.	self fixJoins.	self computeFields.	prepared := true.</body><body package="GlorpQueries" selector="setupTracing">setupTracing	| |	builders isNil ifFalse: [^self].	"Already been done"	super setupTracing.	builders := tracing allTracings asArray		inject: #()		into:			[:sum :each | sum , (ElementBuilder for: each in: self) withAllSubBuilders].	self addOrderingForToManyJoins.</body><body package="GlorpQueries" selector="traceExpressionInContextFor:">traceExpressionInContextFor: anExpression	^anExpression rebuildOn: base.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>accessing</category><body package="GlorpCore" selector="addBoundExpressionsIn:to:">addBoundExpressionsIn: aCommand to: aCollection	self joins , self fields, (Array with: self whereClause)		do:			[:eachBigExpression | 			eachBigExpression isGlorpExpression				ifTrue: [eachBigExpression do:					[:eachIndividualExpressionNode | 					eachIndividualExpressionNode						addBoundExpressionsIn: aCommand						to: aCollection]]].</body><body package="GlorpQueries" selector="builders">builders	^builders.</body><body package="GlorpQueries" selector="command:">command: aDatabaseCommand	"Explicitly set the database command we will use. This is normally used in order to provide a SQLStringSelectCommand, and specify the sql for the query."	customCommand := aDatabaseCommand.</body><body package="GlorpQueries" selector="elementBuilderFor:">elementBuilderFor: anExpression 	^builders detect: [:each | each expression == anExpression] ifNone: [nil].</body><body package="GlorpQueries" selector="fields">fields	fields isNil ifTrue: [self prepare].	^fields</body><body package="GlorpQueries" selector="joins">joins	^joins.</body><body package="GlorpQueries" selector="sql:">sql: aString	"Specify the sql string to use for this query, instead of having it be generated. Note that doing this will override the normal sql generation mechanisms."	self command: (SQLStringSelectCommand new setSQLString: aString).</body><body package="GlorpQueries" selector="tablePrefix">tablePrefix	^tablePrefix</body><body package="GlorpQueries" selector="tablePrefix:">tablePrefix: aString	tablePrefix := aString.</body><body package="GlorpQueries" selector="where:">where: anExpression	whereClause := anExpression.	self setUpBase.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>fields</category><body package="GlorpQueries" selector="addFields:returningTranslationForFields:distinct:">addFields: aliasedFields returningTranslationForFields: originalFields distinct: isDistinct	"The query has computed a set of fields the way the mappings see them, which are then transformed to account for field aliasing in embedded mappings. Add those to our collection, and set up the translation which knows which fields are at which index in the resulting row. If necessary, note that those fields are selected as distinct"	| translation |	translation := IdentityDictionary new.	aliasedFields		with: originalFields		do:			[:aliased :original | 			| position fieldToAdd|			position := self findPositionofAliasedField: aliased.			position = 0				ifTrue:  					[fieldToAdd := isDistinct ifTrue: [aliased asDistinctFieldOn: self baseExpression] ifFalse: [aliased].					fields add: fieldToAdd .					position := fields size].			translation at: original put: position].	^translation.</body><body package="GlorpQueries" selector="findPositionofAliasedField:">findPositionofAliasedField: aField	1 to: fields size do: [:i |		| existingField |		existingField := fields at: i.		existingField asField isNil			ifTrue: [				existingField isSameAliasedFieldAs: aField]			ifFalse: [						(existingField asField isSameAliasedFieldAs: aField)			ifTrue: [^i]]].	^0.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>initialize</category><body package="GlorpQueries" selector="initResultClass:whereClause:singleObject:">initResultClass: aClass whereClause: anExpression singleObject: aBoolean 	super 		initResultClass: aClass		whereClause: anExpression		singleObject: aBoolean.	prepared := false.	fields := OrderedCollection new.	joins := OrderedCollection new.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>printing</category><body package="GlorpQueries" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' for '.	aStream nextPutAll: (resultClass isNil ifTrue: ['nil'] ifFalse: [resultClass name]).</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>As yet unclassified</category><body package="GlorpQueries" selector="queries">queries	"A hack so you can write things that manipulate both this and compound queries the same way"	^Array with: self.</body><body package="GlorpCore" selector="sqlWith:">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^QuerySelectCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>converting</category><body package="GlorpQueries" selector="asFullQuery">asFullQuery	| newQuery |	newQuery := ReadQuery new		initResultClass: resultClass whereClause: whereClause singleObject: readsOneObject.	self copyAttributesTo: newQuery.	newQuery setOrdering: ordering.	newQuery groupBy: groupBy.	^newQuery.</body><body package="GlorpQueries" selector="asGlorpExpression">asGlorpExpression	^self asGlorpExpressionOn: BaseExpression new.</body><body package="GlorpMappings" selector="asGlorpExpressionOn:">asGlorpExpressionOn: anExpression	"If we're being converted into an expression, that means we're a subselect inside an expression block. We don't actually have any relationship to anExpression, so create our own base and make a pseudo-mapping with no join to describe the relationship. Don't even give it a string-name, just use ourselves as the key"		| expression localBase phantomMapping phantomExpression |	phantomMapping := OneToOneMapping new		referenceClass: self resultClass;		attributeName: #temporaryAttributeFromSubselect;		join: Join new;		descriptor: (anExpression system descriptorFor: self resultClass).	phantomExpression := anExpression getMapping: phantomMapping named: self.	expression := GeneralSubSelectExpression 		basedOn: phantomExpression.	expression query: self.	localBase := SubSelectBaseExpression on: phantomExpression.	self baseExpression: localBase.	self tablePrefix: ('s', anExpression ultimateBaseExpression availableSubSelectNumber printString, 't').	^expression.</body><body package="GlorpQueries" selector="asGlorpExpressionOn:basedOn:withUltimateBase:">asGlorpExpressionOn: anExpression basedOn: aMessageArchiver withUltimateBase: aBaseExpression	^self asGlorpExpressionOn: aBaseExpression.</body><body package="GlorpQueries" selector="basicRebuildOn:startingFrom:withOuterScopeBase:">basicRebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	"Rebuild the query, which is part of a subselect expression, into the new context. The only thing that really matters here is that we get correlated subselect pieces inside the query right. The rest is independent of our main expression"	prepared := false.	builders := nil.	base := SubSelectBaseExpression on: (base trueBase rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	whereClause := whereClause asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression.	joins := joins collect: [:each | each asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression].	ordering isNil ifFalse: [ordering := ordering collect: [:each | each asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression]].	groupBy isNil ifFalse: [groupBy := groupBy asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression]."	fields := fields collect: [:each | each isGlorpExpression 		ifTrue: [each asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression]		ifFalse: [each]]."	fields := OrderedCollection new.</body><body package="GlorpQueries" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	"Rebuild the query, which is part of a subselect expression, into the new context. Don't do it if it's not necessary. But if it is necessary, also the copy the query. Otherwise two mappings using the same subselect query will mess each other up."	self == anExpression ifTrue: [^aBaseExpression].	self baseExpression ultimateBaseExpression == ultimateBaseExpression ifTrue: [^self].	^self shallowCopy basicRebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>private</category><body package="GlorpQueries" selector="privateAddBuilder:">privateAddBuilder: anElementBuilder	builders := builders copyWith: anElementBuilder.</body><body package="GlorpQueries" selector="privateReplaceBuilderWith:">privateReplaceBuilderWith: anElementBuilder	| oldBuilder |	oldBuilder := self elementBuilderFor: anElementBuilder expression.	oldBuilder isNil ifTrue: [self error: 'No builder found to replace.'].	builders at: (builders indexOf: oldBuilder) put: anElementBuilder.</body><body package="GlorpQueries" selector="privateSetFields:">privateSetFields: aCollection	fields := aCollection.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	fields := OrderedCollection new.	joins := OrderedCollection new.	builders := nil.	tablesToPrint := nil.</body></methods><methods><class-id>Glorp.SQLite3PragmaQuery</class-id> <category>sql generation</category><body package="GlorpQueries" selector="printWhereClauseOn:">printWhereClauseOn: aCommand	self hasEmptyWhereClause		ifFalse: 			[whereClause rightChild printSQLOn: aCommand withParameters: aCommand parameters]</body><body package="GlorpQueries" selector="sqlWith:">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^SQLite3PragmaCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.SQLite3PragmaQuery class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="newQuery">newQuery	^SQLite3PragmaQuery new	"^super newQuery"</body><body package="GlorpQueries" selector="returningManyOf:where:">returningManyOf: aClass where: anExpression	"Backward-compatibility, since we changed the class name."	^self returningManyOf: aClass where: anExpression limit: nil</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="hasParameters">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^true.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^ByteArray.</body><body package="GlorpDatabaseTypes" selector="isVariableWidth">isVariableWidth	"Return true if this type allows varying length data within a particular instance. e.g., this is true for a varchar, but false for a fixed size character field"	^true.</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	^#ByteArray.</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="width">width	^width.</body><body package="GlorpDatabaseTypes" selector="width:">width: anInteger	width := anInteger</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>initialize-release</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'varbinary'</body></methods><methods><class-id>Glorp.AddingWriteStream</class-id> <category>accessing</category><body package="GlorpExtensions" selector="contents">contents	^target.</body><body package="GlorpExtensions" selector="nextPut:">nextPut: anObject	target add: anObject.</body><body package="GlorpExtensions" selector="nextPutAll:">nextPutAll: aCollection	target glorpAddAll: aCollection.</body><body package="GlorpExtensions" selector="on:">on: aSet	target := aSet.</body><body package="GlorpExtensions" selector="target">target	^target</body><body package="GlorpExtensions" selector="target:">target: aCollection	target := aCollection</body></methods><methods><class-id>Glorp.AddingWriteStream class</class-id> <category>instance creation</category><body package="GlorpExtensions" selector="on:">on: aCollection	^self new target: aCollection.</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>private/caching</category><body package="GlorpCore" selector="cacheFor:">cacheFor: anObject	"Get the cache for a particular object. Since this could conceivably be passed a proxy, check for that. The cache for an uninstantiated proxy is kind of ambiguous, treat it as nil.  This could also be a class"	| nonMetaClass |	nonMetaClass := anObject isBehavior ifTrue: [anObject] ifFalse: [anObject class].	^nonMetaClass == Proxy		ifTrue: [anObject isInstantiated ifTrue: [self cacheFor: anObject getValue] ifFalse: [nil]]		ifFalse: [self cacheForClass: nonMetaClass].</body><body package="GlorpCore" selector="expiredInstanceOf:key:">expiredInstanceOf: aClass key: aKey	^(self cacheForClass: aClass) expiredInstanceFor: aKey.</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>querying</category><body package="GlorpCore" selector="containsObject:key:">containsObject: anObject key: aKey	| cache |	cache := self cacheForClass: anObject class.	^cache includesKey: aKey as: anObject.</body><body package="GlorpCore" selector="containsObjectForClass:key:">containsObjectForClass: aClass key: aKey	| cache |	cache := self cacheForClass: aClass.	^cache includesKey: aKey.</body><body package="GlorpCore" selector="expireAll">expireAll	subCaches do: [:each | each expireAll].</body><body package="GlorpCore" selector="expireClass:key:">expireClass: aClass key: aKey	^self expireClass: aClass key: aKey ifAbsent: [self error: 'Object not in cache'].</body><body package="GlorpCore" selector="expireClass:key:ifAbsent:">expireClass: aClass key: aKey ifAbsent: failBlock 	| cache |	cache := self cacheForClass: aClass.	(cache includesKey: aKey withClass: aClass) ifFalse: [^failBlock value].	cache expireKey: aKey ifAbsent: [ failBlock value ].</body><body package="GlorpCore" selector="hasExpired:">hasExpired: anObject	| key cache |	key := (session descriptorFor: anObject) primaryKeyFor: anObject.	cache := self cacheFor: anObject.	cache isNil ifTrue: [^false].  "We have an uninstantiated proxy."	^cache hasExpired: key.</body><body package="GlorpCore" selector="hasExpired:key:">hasExpired: aClass key: key	| cache |	cache := self cacheFor: aClass.	^cache hasExpired: key.</body><body package="GlorpCore" selector="hasObjectExpiredOfClass:withKey:">hasObjectExpiredOfClass: aClass withKey: key	| cache |	cache := self cacheForClass: aClass.	^cache hasExpired: key.</body><body package="GlorpCore" selector="lookupClass:key:">lookupClass: aClass key: aKey	^self lookupClass: aClass key: aKey ifAbsent: [self error: 'cache miss'].</body><body package="GlorpCore" selector="lookupClass:key:ifAbsent:">lookupClass: aClass key: aKey ifAbsent: failBlock	| object |	object := (self cacheForClass: aClass) at: aKey ifAbsent: failBlock.	^(object isKindOf: aClass)		ifTrue: [ object ]		ifFalse: [ failBlock value ].</body><body package="GlorpCore" selector="lookupClass:key:ifAbsentPut:">lookupClass: aClass key: aKey ifAbsentPut: failBlock	^(self cacheForClass: aClass) at: aKey ifAbsentPut: failBlock.</body><body package="GlorpCore" selector="markAsCurrentOfClass:key:">markAsCurrentOfClass: aClass key: key	| cache |	aClass == Proxy ifTrue: [^self].	cache := self cacheForClass: aClass.	cache markAsCurrentAtKey: key.</body><body package="GlorpCore" selector="removeClass:key:">removeClass: aClass key: aKey	^self removeClass: aClass key: aKey ifAbsent: [self error: 'Object not in cache'].</body><body package="GlorpCore" selector="removeClass:key:ifAbsent:">removeClass: aClass key: aKey ifAbsent: failBlock 	| cache |	cache := self cacheForClass: aClass.	(cache includesKey: aKey withClass: aClass) ifFalse: [^failBlock value].	cache removeKey: aKey ifAbsent: [ failBlock value ].</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>adding</category><body package="GlorpCore" selector="at:insert:">at: aKey insert: anObject	| subCache |	subCache := self cacheForClass: anObject class.	subCache at: aKey ifAbsentPut: [anObject].</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>accessing</category><body package="GlorpCore" selector="numberOfElements">numberOfElements	^subCaches inject: 0 into: [:sum :each |		sum + each numberOfElements].</body><body package="GlorpCore" selector="session">session	^session.</body><body package="GlorpCore" selector="session:">session: aSession 	session := aSession.</body><body package="GlorpCore" selector="system">system	^self session system.</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>initialize/release</category><body package="GlorpCore" selector="cacheForClass:">cacheForClass: aClass	^subCaches at: aClass		ifAbsentPut: [self makeCacheFor: aClass]</body><body package="GlorpCore" selector="initialize">initialize	subCaches := IdentityDictionary new: 100.</body><body package="GlorpCore" selector="makeCacheFor:">makeCacheFor: aClass 	| rootClass cache |	rootClass := session isNil ifTrue: [aClass] ifFalse: [session lookupRootClassFor: aClass].	cache := subCaches at: rootClass ifAbsentPut: [ Cache newFor: rootClass in: self ].	subCaches at: aClass put: cache.	^cache</body><body package="GlorpCore" selector="release">release	subCaches do: [:each | each release].</body></methods><methods><class-id>Glorp.CacheManager class</class-id> <category>instance creation</category><body package="GlorpCore" selector="forSession:">forSession: aSession 	^self new session: aSession.</body><body package="GlorpCore" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>accessing</category><body package="GlorpMappings" selector="beForPseudoVariable">beForPseudoVariable	"Make this be a pseudo-variable - one which is neither read nor written, and doesn't have a corresponding instance variable, but is only used for queries."	canRead := false.	canWrite := false.</body><body package="GlorpMappings" selector="canRead">canRead	^canRead</body><body package="GlorpMappings" selector="canRead:">canRead: aBoolean	canRead := aBoolean</body><body package="GlorpMappings" selector="canWrite">canWrite	^canWrite</body><body package="GlorpMappings" selector="canWrite:">canWrite: aBoolean	canWrite := aBoolean</body><body package="GlorpMappings" selector="classModel">classModel	^classModel</body><body package="GlorpMappings" selector="classModel:">classModel: aGlorpClassModel	classModel := aGlorpClassModel</body><body package="GlorpMappings" selector="collectionType">collectionType	^collectionType</body><body package="GlorpMappings" selector="collectionType:">collectionType: aClass	collectionType := aClass</body><body package="GlorpMappings" selector="keyType">keyType	^keyType</body><body package="GlorpMappings" selector="keyType:">keyType: aClass	keyType := aClass</body><body package="GlorpMappings" selector="name">name	^name isNil ifTrue: [''] ifFalse: [name]</body><body package="GlorpMappings" selector="name:">name: aSymbol	| symbol |	symbol := aSymbol isNil ifTrue: [aSymbol] ifFalse: [aSymbol asSymbol].	name := symbol.</body><body package="GlorpMappings" selector="system">system	classModel isNil ifTrue: [^nil].	^classModel system.</body><body package="GlorpMappings" selector="type">type	^type</body><body package="GlorpMappings" selector="type:">type: aClass	type := aClass</body><body package="GlorpMappings" selector="useDirectAccess:">useDirectAccess: aBoolean	useDirectAccess := aBoolean.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>testing</category><body package="GlorpMappings" selector="isForPseudoVariable">isForPseudoVariable	"Return true if this is a pseudo-variable - one which is neither read nor written, and doesn't have a corresponding instance variable, but is only used for queries."	^(canRead not &amp; canWrite not) or: [self isValid not].</body><body package="GlorpMappings" selector="useDirectAccess">useDirectAccess	useDirectAccess isNil ifFalse: [^useDirectAccess].	self system isNil ifTrue: [^true].  "A global default, although only applicable if we're not in a valid setup"	^self system useDirectAccessForMapping.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>private</category><body package="GlorpMappings" selector="directGetValueFrom:">directGetValueFrom: anObject 	| index |	index := self instVarIndexIn: anObject.	index = 0 ifTrue: [self raiseInvalidAttributeError].	^anObject instVarAt: index</body><body package="GlorpMappings" selector="directSetValueIn:to:">directSetValueIn: anObject to: aValue 	| index |	index := self instVarIndexIn: anObject.	index = 0 ifTrue: [self raiseInvalidAttributeError].	^anObject instVarAt: index put: aValue</body><body package="GlorpMappings" selector="instVarIndex">instVarIndex	| soughtName |	attributeIndex == nil ifFalse: [^attributeIndex].	soughtName := Dialect instVarNameFor: name.	^attributeIndex := self classModel describedClass allInstVarNames 				indexOf: soughtName</body><body package="GlorpMappings" selector="instVarIndexIn:">instVarIndexIn: anObject 	^self instVarIndex</body><body package="GlorpMappings" selector="isValid">isValid	^name notNil and: [classModel notNil].</body><body package="GlorpMappings" selector="newCollection">newCollection	^collectionType isBehavior ifTrue: [collectionType new] ifFalse: [collectionType copyEmpty].</body><body package="GlorpMappings" selector="privateUseDirectAccess">privateUseDirectAccess	^useDirectAccess.</body><body package="GlorpMappings" selector="raiseInvalidAttributeError">raiseInvalidAttributeError	self error: 'Invalid attribute: ', classModel printString, '&gt;&gt;', name printString.</body><body package="GlorpMappings" selector="setSelector">setSelector	setSelector  == nil ifTrue: [setSelector := (name, ':') asSymbol].	^setSelector.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>printing</category><body package="GlorpMappings" selector="printOn:">printOn: aStream	aStream nextPutAll: self classModel printString, '&gt;&gt;', self name.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>get/set</category><body package="GlorpMappings" selector="checkTargetType:">checkTargetType: anObject	"Check that anObject's type corresponds to something we know how to handle for this attribute. We expect this to be a real object, not a collection."	self checkTargetType: anObject against: self type.</body><body package="GlorpMappings" selector="checkTargetType:against:">checkTargetType: anObject against: aClass	"Check that anObject's type corresponds to aClass, which we expect as our values. We expect this to be a real object, not a collection."	| targetModel |	anObject yourSelf isNil ifTrue: [^self].	aClass isNil ifTrue: [self error: 'No type to check against in class model'].	anObject glorpIsCollection ifTrue: [(GlorpInvalidTypeError new object: anObject; expectedType: self collectionType) signal].	targetModel := self system classModelFor: aClass.	targetModel notNil ifTrue: [		(targetModel matches: anObject)			ifFalse: [(GlorpInvalidTypeError new object: anObject; expectedType: aClass) signal]].</body><body package="GlorpMappings" selector="checkTargetTypeForKey:value:">checkTargetTypeForKey: aKey value: anObject	"Check that anObject's type corresponds to something we know how to handle for this attribute. We expect this to be a real object, not a collection. This is the version used for checking a dictionary, where we check both key and value, but only if they correspond to mapped classes."	(self system classModelFor: self keyType) isNil 		ifFalse: [self checkTargetType: aKey against: self keyType].	(self system classModelFor: self type) isNil		ifFalse: [self checkTargetType: anObject against: type].</body><body package="GlorpMappings" selector="checkType:">checkType: anObject	(self classModel matches: anObject)		ifFalse: [self error: 'Wrong type of object'].</body><body package="GlorpMappings" selector="getValueFrom:">getValueFrom: anObject	| real |	real := anObject yourSelf.	self checkType: real.	self useDirectAccess ifTrue: [^self directGetValueFrom: real].	^real perform: self name.</body><body package="GlorpMappings" selector="setValueIn:to:">setValueIn: anObject to: aValue 	| real |	self isValid ifFalse: [^self].	real := anObject yourSelf.	self checkType: real.	self useDirectAccess ifTrue: [^self directSetValueIn: real to: aValue].	^real perform: self setSelector with: aValue</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>validation</category><body package="GlorpMappings" selector="isCollectionAttribute">isCollectionAttribute	^collectionType notNil.</body><body package="GlorpMappings" selector="isReadable">isReadable	self canRead ifFalse: [^false].	^self useDirectAccess 		ifTrue: [self instVarIndex &gt; 0]		ifFalse: [self classModel describedClass canUnderstand: self name]</body><body package="GlorpMappings" selector="isWritable">isWritable	self canWrite ifFalse: [^false].	^self useDirectAccess 		ifTrue: [self instVarIndex &gt; 0]		ifFalse: [self classModel describedClass canUnderstand: self setSelector]</body><body package="GlorpMappings" selector="validate">validate	name isEmpty ifTrue: [self error: 'Invalid attribute name']</body><body package="GlorpMappings" selector="validateCanRead">validateCanRead	self isReadable ifFalse: [self raiseInvalidAttributeError]</body><body package="GlorpMappings" selector="validateCanWrite">validateCanWrite	self isWritable ifFalse: [self raiseInvalidAttributeError]</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>knitting</category><body package="GlorpMappings" selector="add:to:in:">add: anObject to: aCollection in: ourObject	"If this is an array we can't just add to it, we must concatenate and re-set the value"	| newCollection |	aCollection class == Array 		ifTrue: [				newCollection := aCollection, (Array with: anObject).			self setValueIn: ourObject to: newCollection.			^self].	(anObject class == Association and: [anObject key == nil])		ifFalse: [aCollection add: anObject].</body><body package="GlorpMappings" selector="knit:to:">knit: ourObject to: anotherObject 	"Set up the relationship from our object to another one, indicated by our mapping."	self isCollectionAttribute 		ifTrue: 			[| collection |			collection := self getValueFrom: ourObject.			(collection isGlorpProxy and: [collection isInstantiated not]) 				ifTrue: 					[collection := self newCollection.					self setValueIn: ourObject to: collection.					self 						add: anotherObject						to: collection						in: ourObject.					^self].			(collection includes: anotherObject) 				ifFalse: 					[self 						add: anotherObject						to: collection						in: ourObject]]		ifFalse: [self setValueIn: ourObject to: anotherObject]</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>mapping</category><body package="GlorpMappings" selector="isDictionaryAttribute">isDictionaryAttribute	^collectionType isBehavior and: [collectionType includesBehavior: Dictionary].</body><body package="GlorpMappings" selector="loopOver:doing:">loopOver: mightBeACollection doing: aBlock	"It is possible that the value for a dictionary attribute is nil. If so, do not map it back"	| index |	self isCollectionAttribute ifFalse: [self checkTargetType: mightBeACollection. ^aBlock value: 1 value: mightBeACollection].	mightBeACollection isNil ifTrue: [^nil].	self isDictionaryAttribute ifTrue: [^mightBeACollection keysAndValuesDo: [:key :value |		self checkTargetTypeForKey: key value: value. 		value ifNotNil: [aBlock value: key value: value]]].	index := 1.	mightBeACollection glorpIsCollection ifFalse: [		(GlorpInvalidTypeError new object: mightBeACollection; expectedType: self collectionType) signal].	mightBeACollection		do:			[:each |			| object | 			object := each glorpRealObject. 			self checkTargetType: object.			aBlock value: index value: object.			index := index + 1].</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>initialization</category><body package="GlorpMappings" selector="initialize">initialize	canRead := true.	canWrite := true.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>copying</category><body package="GlorpMappings" selector="copyFrom:">copyFrom: anAttributeModel	"Copy over the attributes if it defines them and we don't"	anAttributeModel isNil ifTrue: [^self].	self type isNil ifTrue: [self type: anAttributeModel type].	self collectionType isNil		ifTrue: [self collectionType: anAttributeModel collectionType].	self privateUseDirectAccess isNil		ifTrue: [useDirectAccess := anAttributeModel privateUseDirectAccess].	canRead := anAttributeModel canRead.	canWrite := anAttributeModel canWrite.</body></methods><methods><class-id>Glorp.GlorpAttributeModel class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="named:">named: aSymbol	^self new name: aSymbol.</body><body package="GlorpMappings" selector="named:collection:of:">named: aSymbol collection: aCollectionClass of: aClass	^(self new)		name: aSymbol;		type: aClass;		collectionType: aCollectionClass.</body><body package="GlorpMappings" selector="named:collectionOf:">named: aSymbol collectionOf: aClass	^self named: aSymbol collection: OrderedCollection of: aClass.</body><body package="GlorpMappings" selector="named:dictionary:from:to:">named: aSymbol dictionary: dictionaryClass from: keyClass to: valueClass	^(self new)		name: aSymbol;		type: valueClass;		keyType: keyClass;		collectionType: dictionaryClass.</body><body package="GlorpMappings" selector="named:dictionaryFrom:to:">named: aSymbol dictionaryFrom: keyClass to: valueClass	^self named: aSymbol dictionary: Dictionary from: keyClass to: valueClass.</body><body package="GlorpMappings" selector="named:type:">named: aSymbol type: aClass	^self new name: aSymbol; type: aClass.</body><body package="GlorpMappings" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpExpressionsPackage class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.GlorpMiscPackage class</class-id> <category>instance creation</category><body package="GlorpMisc" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.SQLServerSequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor 	aDatabaseRow at: aDatabaseField		put: ((anAccessor 				executeSQLString: 'SELECT @@IDENTITY') first atIndex: 1).</body><body package="GlorpDatabase" selector="reserveSequenceNumbers:in:for:">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body></methods><methods><class-id>Glorp.SQLServerSequence</class-id> <category>testing</category><body package="GlorpDatabase" selector="isIdentityColumn">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="controlsTables">controlsTables	^false</body><body package="GlorpMappings" selector="hasImpliedClauses">hasImpliedClauses	"We may imply more than one clause, or a clause which is different from the one directly implied by the relationship"	^true</body><body package="GlorpMappings" selector="isRelationship">isRelationship	"True when the mapping associates different persistent classes."	^false</body><body package="GlorpMappings" selector="isStoredInSameTable">isStoredInSameTable	^true.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>printing SQL</category><body package="GlorpMappings" selector="allRelationsFor:">allRelationsFor: rootExpression	"We may have multiple relationships."	| tables rows result rightChild rightHandSide |	tables := self mappedTables.	rows := Dictionary new.	tables do: [:each | rows at: each put: (DatabaseRow newForTable: each)].	rightChild := rootExpression rightChild.	rightHandSide := rightChild isConstantExpression ifTrue: [rightChild value] ifFalse: [rightChild].	toDbMappingBlock value: rows value: rightHandSide value: Dictionary new. 	result := nil.	rows do: [:eachRow |		| table |		table := rootExpression leftChild base getTable: eachRow table.		eachRow fieldsAndValidValuesDo: [:eachField :eachValue |  | newExp |			newExp := (table getField: eachField) get: rootExpression relation withArguments: (Array with: eachValue).			result := newExp AND: result.]].	^result.</body><body package="GlorpMappings" selector="convertedDbValueOf:">convertedDbValueOf: anObject	| tables rows |	tables := self mappedTables.	rows := Dictionary new.	tables do: [:each | rows at: each put: (DatabaseRow newForTable: each)].	toDbMappingBlock value: rows value: anObject.	rows keysAndValuesDo: [:eachTable :eachRow |		^eachRow at: mappedFields first].</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="field">field	| fields |	fields := self mappedFields.	fields size = 1 ifFalse: [self error: 'This mapping does not correspond to exactly one field'].	^fields first.</body><body package="GlorpMappings" selector="mappedFields">mappedFields	^mappedFields.</body><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:">referencedIndependentObjectsFrom: anObject	"Assumes that the only object this might affect is our primary attribute. That's probably valid. I think."	| object otherDescriptor |	object := self getValueFrom: anObject.	(object isGlorpProxy and: [object isInstantiated not]) ifTrue: [^#()].	otherDescriptor := self system descriptorFor: object.	^otherDescriptor isNil ifTrue: [#()] ifFalse: [Array with: object].</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	^self.</body><body package="GlorpMappings" selector="valueIn:as:">valueIn: anElementBuilder as: anExpression	^fromDbMappingBlock		value: anElementBuilder row		value: anElementBuilder		value: anExpression.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>initialize/release</category><body package="GlorpMappings" selector="forAttribute:fromDb:toDb:mappingFields:">forAttribute: aSymbol fromDb: fromBlock toDb: toBlock mappingFields: aFieldCollection	self		setAttribute: aSymbol		fromDb: fromBlock		toDb: toBlock		mappingFields: aFieldCollection.</body><body package="GlorpMappings" selector="initialize">initialize	super initialize.	self shouldProxy: false.</body><body package="GlorpMappings" selector="setAttribute:fromDb:toDb:mappingFields:">setAttribute: aSymbol fromDb: fromBlock toDb: toBlock mappingFields: aFieldCollection 	self attributeName: aSymbol.	fromDbMappingBlock := fromBlock.	toDbMappingBlock := toBlock.	mappedFields := aFieldCollection.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>public</category><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap	| target sourceRows targetRows valueDescriptor |	self canWrite ifFalse: [^self].	target := self getValueFrom: anObject.	target := self session realObjectFor: target.	target := aRowMap mementoFor: target.	sourceRows := Dictionary new: 3.	targetRows := Dictionary new: 3.	descriptor tables do: [:each |		sourceRows at: each put: (aRowMap findOrAddRowForTable: each withKey: anObject)].	valueDescriptor := self system descriptorFor: target.	valueDescriptor isNil ifFalse: [		valueDescriptor tables do: [:each |			targetRows at: each put: (aRowMap findOrAddRowForTable: each withKey: target)]].	toDbMappingBlock value: sourceRows value: target value: targetRows.</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anElementBuilder	| readBlock row |	row := anElementBuilder row.	readBlock := [fromDbMappingBlock value: row value: anElementBuilder value: BaseExpression new].	self shouldProxy 		ifTrue: [self setValueIn: anObject to: (AdHocProxy readBlock: readBlock)]		ifFalse: [self setValueIn: anObject to: readBlock value]</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="shouldProxy">shouldProxy	^shouldProxy.</body><body package="GlorpMappings" selector="shouldProxy:">shouldProxy: aBoolean	shouldProxy := aBoolean.</body></methods><methods><class-id>Glorp.AdHocMapping class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="forAttribute:fromDb:toDb:mappingFields:">forAttribute: aSymbol fromDb: fromBlock toDb: toBlock mappingFields: aFieldCollection 	^super new 		setAttribute: aSymbol		fromDb: fromBlock		toDb: toBlock		mappingFields: aFieldCollection</body></methods><methods><class-id>Glorp.NullConverter</class-id> <category>converting</category><body package="GlorpDatabase" selector="convert:fromDatabaseRepresentationAs:">convert: anObject fromDatabaseRepresentationAs: aDatabaseType	^anObject.</body><body package="GlorpDatabase" selector="convert:toDatabaseRepresentationAs:">convert: anObject toDatabaseRepresentationAs: aDatabaseType	^anObject.</body></methods><methods><class-id>Glorp.GlorpFloatType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'float4'.</body></methods><methods><class-id>Glorp.GlorpFloatType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Float.</body></methods><methods><class-id>Glorp.GlorpFloatType</class-id> <category>converting</category><body package="GlorpDatabaseTypes" selector="converterForStType:">converterForStType: aClass	^self platform converterNamed: #numberToFloat.</body><body package="GlorpDatabaseTypes" selector="impliedSmalltalkType">impliedSmalltalkType	^Float.</body></methods><methods><class-id>Glorp.TimestampVersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="nextValueFor:in:">nextValueFor: aField in: aRow	"If a platform maps the timestamp class to something else (e.g. SQLite maps timestamps to strings as it has no support for time-related types), then it must be allowed to do so here as well.  For most platforms, the wrapping #toTimestamp:for: call will be a noop."	^aField type platform		toTimestamp: Dialect timestampNow		for: aField type</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>preparing</category><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	"Rebuilding just one of them will rebuild our whole structure, since it all comes from the same definition."	rebuilt := whereClauseVersion rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	rebuilt == whereClauseVersion ifTrue: [^self].	rebuilt arguments: (self arguments collect: [:each | each rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression]).	^rebuilt.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>printing</category><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary	selectListVersion printSelectSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	whereClauseVersion printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>accessing</category><body package="GlorpExpressions" selector="arguments">arguments	^arguments.</body><body package="GlorpExpressions" selector="arguments:">arguments: anArray	arguments := anArray.	whereClauseVersion arguments: anArray.	selectListVersion arguments: anArray.</body><body package="GlorpExpressions" selector="base:">base: anExpression	base := anExpression.	"whereClauseVersion base: anExpression."	selectListVersion base: anExpression.</body><body package="GlorpExpressions" selector="basicArguments:">basicArguments: anArray	arguments := anArray.</body><body package="GlorpExpressions" selector="basicBase:">basicBase: anExpression	base := anExpression.</body><body package="GlorpExpressions" selector="field">field	^whereClauseVersion field.</body><body package="GlorpExpressions" selector="selectListVersion">selectListVersion	^selectListVersion.</body><body package="GlorpExpressions" selector="selectListVersion:">selectListVersion: aFunctionExpression	selectListVersion := aFunctionExpression.</body><body package="GlorpExpressions" selector="symbol:">symbol: aSymbol	symbol := aSymbol.	whereClauseVersion symbol: aSymbol.	selectListVersion symbol: aSymbol.</body><body package="GlorpExpressions" selector="type:">type: aSymbol	super type: aSymbol.	whereClauseVersion type: aSymbol.	selectListVersion type: aSymbol.</body><body package="GlorpExpressions" selector="whereClauseVersion">whereClauseVersion	^whereClauseVersion.</body><body package="GlorpExpressions" selector="whereClauseVersion:">whereClauseVersion: aFunctionExpression	whereClauseVersion := aFunctionExpression.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>converting</category><body package="GlorpExpressions" selector="asField">asField	^self.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	super do: aBlock skipping: aSet.	arguments do: [:each |		each do: aBlock skipping: aSet].</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions" selector="copy">copy	| new |	new := super copy.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copy.	new whereClauseVersion: whereClauseVersion copy.	^new.</body><body package="GlorpExpressions" selector="createFor:withBase:symbol:">createFor: argumentList withBase: anExpression symbol: aSymbol	| new newBase newArgument newFunction |	new := super createFor: argumentList withBase: anExpression symbol: aSymbol.	"For the where clause version, we've got a dualRoleFunction. We can't just rebuild the whole thing, so rebuild the children, and then re-assemble it recreating from the template."	newBase := new whereClauseVersion base isNil ifTrue: [anExpression] ifFalse: [new whereClauseVersion base rebuildOn: anExpression].	newArgument := new whereClauseVersion argument rebuildOn: anExpression.	newFunction := self whereClauseVersion copy.	newFunction symbol: aSymbol.	newFunction base: newBase.	newFunction argument: newArgument.	new whereClauseVersion: newFunction.	"Don't try to rebuild the selectListVersion at all, because at least for the motivating case we have, it's just a shell, not a full blown expression, and it will already have been copied."	^new.</body></methods><methods><class-id>Glorp.InsertCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="arrayBoundFields">arrayBoundFields	"For array binding, include all the fields, except if we're inserting into a database with identity columns, where we must omit those columns"	^self platform usesIdentityColumns		ifTrue: [row table fields reject: [:each | each type isIdentityColumn]]		ifFalse: [row table fields].</body><body package="GlorpDatabase" selector="basicPrintSQLFor:">basicPrintSQLFor: aRow	| fields |	self nextPutAll: 'INSERT INTO '.	aRow table printSQLOn: self withParameters: #().	fields := self shouldUseGroupWriting		ifTrue: [self arrayBoundFields]		ifFalse: [aRow nonGeneratedFieldsWithValues].	self nextPutAll: ' ('.	GlorpHelper		do: [:each | self nextPutAll: (self platform nameForColumn: each name)]		for: fields		separatedBy: [self nextPutAll: ','].	self nextPutAll: ') '.	self nextPutAll: ' VALUES ('.	GlorpHelper		do:			[:each | 			(self canBind: (aRow at: each ifAbsent: [nil]) to: each type)				ifTrue: [self nextPut: $?]				ifFalse: [aRow printValueOfField: each on: self]]		for: fields		separatedBy: [self nextPutAll: ','].	self nextPutAll: ')'.</body><body package="GlorpDatabase" selector="printSQL">printSQL	| iterations |	iterations := self shouldUseGroupWriting		ifTrue:			[self platform usesArrayBindingRatherThanGrouping				ifTrue: [1]				ifFalse: [allRows size]]		ifFalse: [1].	GlorpHelper		do:			[:i | self basicPrintSQLFor: (i = 1 ifTrue: [row] ifFalse: [allRows at: i])]		for: (1 to: iterations)		separatedBy: [self nextPutAll: '; '].</body><body package="GlorpDatabase" selector="singleRowBoundFields">singleRowBoundFields	"Include only the fields that have values in our particular row"	^row nonGeneratedFieldsWithValues</body></methods><methods><class-id>Glorp.InsertCommand</class-id> <category>testing</category><body package="GlorpDatabase" selector="supportsGroupWriting">supportsGroupWriting	^true.</body></methods><methods><class-id>Glorp.FilteringQuery</class-id> <category>accessing</category><body package="GlorpQueries" selector="collectBlock">collectBlock	^collectBlock</body><body package="GlorpQueries" selector="collectBlock:">collectBlock: aBlock	collectBlock:= aBlock.</body><body package="GlorpQueries" selector="collection">collection	^collection</body><body package="GlorpQueries" selector="collection:">collection: aCollection	aCollection class == GlorpVirtualCollection ifTrue: [collectionType := aCollection getQuery collectionType].	collection := aCollection.</body><body package="GlorpQueries" selector="filter">filter	^filter</body><body package="GlorpQueries" selector="filter:">filter: aBlock	filter := aBlock</body><body package="GlorpQueries" selector="resultClass">resultClass	collection class == GlorpVirtualCollection ifTrue: [^collection getQuery resultClass].	^(collection detect: [:each | true] ifNone: [nil]) class</body></methods><methods><class-id>Glorp.FilteringQuery</class-id> <category>executing</category><body package="GlorpQueries" selector="collectionTypesAgree:">collectionTypesAgree: aCollection	^self collectionType new class == aCollection class</body><body package="GlorpQueries" selector="executeWithParameters:in:">executeWithParameters: parameterArray in: aSession	| filtered result |	session := aSession.	collection class == GlorpVirtualCollection		ifTrue:			[collection setSession: aSession.			collection parameters: parameterArray.			collection := collection realObjects].	filtered := self filterResultsForParameters: parameterArray.	result := self transformsValues		ifTrue: [filtered collect: [:each | self valueFor: each]]		ifFalse: [filtered].	result := (self collectionTypesAgree: result) ifTrue: [result] ifFalse: [self resultCollectionFor: result readStream].	^self readsOneObject		ifTrue: [result detect: [:each | true] ifNone: [nil]]		ifFalse: [result].</body><body package="GlorpQueries" selector="filterResultsForParameters:">filterResultsForParameters: parameterArray	| passing seen |	seen := IdentitySet new.	passing := collection		select:			[:each | 			| passes new value |			passes := filter value: each value: parameterArray.			value := self valueFor: each.			passes				ifTrue:					[new := (seen includes: value) not.					new ifTrue: [seen add: value]].			passes and: [new]].	^passing.</body><body package="GlorpQueries" selector="transformsValues">transformsValues	^collectBlock notNil.</body><body package="GlorpQueries" selector="valueFor:">valueFor: anObject	collectBlock isNil ifTrue: [^anObject].	^collectBlock value: anObject.</body></methods><methods><class-id>Glorp.FilteringQuery</class-id> <category>testing</category><body package="GlorpQueries" selector="shortCircuitEmptyReturn:">shortCircuitEmptyReturn: parameters	^false.</body></methods><methods><class-id>Glorp.FilteringQuery class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="on:filter:">on: aCollection filter: aBlock	^self new		collection: aCollection; 		filter: aBlock.</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Timestamp.</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'TIME WITH TIME ZONE'.</body></methods><methods><class-id>Glorp.GlorpRowSorter</class-id> <category>sorting</category><body package="GlorpUnitOfWork" selector="childrenOf:">childrenOf: anItem	^childCache at: anItem ifAbsentPut: [		childSelector isSymbol			ifTrue: [anItem perform: childSelector]			ifFalse: [childSelector value: anItem]].</body><body package="GlorpUnitOfWork" selector="currentChildren">currentChildren	^self childrenOf: current.</body><body package="GlorpUnitOfWork" selector="currentItemIsDone">currentItemIsDone	^current status = #done.</body><body package="GlorpUnitOfWork" selector="currentItemIsInProgress">currentItemIsInProgress	^current status = #visitedOnce.</body><body package="GlorpUnitOfWork" selector="currentItemIsNew">currentItemIsNew	^current status = #notVisited.</body><body package="GlorpUnitOfWork" selector="hasSomethingToProcess">hasSomethingToProcess	self next.	^current notNil.</body><body package="GlorpUnitOfWork" selector="initialVisit">initialVisit	| children |	children := self currentChildren select: [:each  | each status == #notVisited].	children do: [:each | each parent: current].	queue addAll: children.	current status: #visitedOnce.	children isEmpty ifTrue: [queue add: current].</body><body package="GlorpUnitOfWork" selector="next">next	queue isEmpty ifTrue: [		| candidate |		candidate := items detect: [:each | each status == #notVisited] ifNone: [nil].		candidate isNil ifTrue: [			"We're probably at the end, but check again for part-way done nodes, which can happen if there are heavy cycles"			items reset. 			candidate := items detect: [:each | each status == #visitedOnce] ifNone: [nil]].		candidate isNil ifFalse: [queue add: candidate]].	current := queue isEmpty ifTrue: [nil] ifFalse: [queue removeFirst].</body><body package="GlorpUnitOfWork" selector="processCurrent">processCurrent	self currentItemIsNew ifTrue: [^self initialVisit].	self currentItemIsInProgress ifTrue: [^self secondVisit].	self currentItemIsDone ifTrue: [^self].	self error: 'Unknown item status'.</body><body package="GlorpUnitOfWork" selector="secondVisit">secondVisit	sorted add: current.	current status: #done.	current parent isNil		ifFalse:			[((self childrenOf: current parent)				allSatisfy: [:each | each status == #done])				ifTrue: [queue add: current parent].			current parent: nil].</body><body package="GlorpUnitOfWork" selector="sort:">sort: aCollection	items := aCollection readStream.	aCollection do: [:each | each status: #notVisited].	[self hasSomethingToProcess] whileTrue: [self processCurrent].	^sorted.</body></methods><methods><class-id>Glorp.GlorpRowSorter</class-id> <category>accessing</category><body package="GlorpUnitOfWork" selector="getChildrenVia:">getChildrenVia: aSelector	childSelector := aSelector.</body></methods><methods><class-id>Glorp.GlorpRowSorter</class-id> <category>initializing</category><body package="GlorpUnitOfWork" selector="initialize">initialize	queue := OrderedCollection new: 100.	sorted := OrderedCollection new: 100.	childCache := IdentityDictionary new: 100.</body></methods><methods><class-id>Glorp.GlorpRowSorter class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.Cast</class-id> <category>initialize-release</category><body package="GlorpExpressions" selector="initialize">initialize	super initialize.	function := 'CAST'.	separator := ' AS '.</body></methods><methods><class-id>Glorp.Cast</class-id> <category>preparing</category><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^super rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression."	| rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuilt := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	rebuilt := self class value: base as: arguments first.	rebuilt alias: self alias.	^rebuilt."</body></methods><methods><class-id>Glorp.Cast</class-id> <category>accessing</category><body package="GlorpExpressions" selector="type">type	^arguments last value.</body></methods><methods><class-id>Glorp.Cast class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="value:as:">value: anObject as: aDatabaseType	self error: 'this is work in progress, you probably shouldn''t use it yet'.	(anObject isNil or: [anObject isGlorpExpression and: [anObject isConstantExpression and: [anObject value isNil]]])		ifTrue: [^anObject].	^self new base: anObject asGlorpExpression; arguments: (Array with: aDatabaseType asGlorpExpression).</body></methods><methods><class-id>Glorp.GlorpDatabaseReadError</class-id> <category>accessing</category><body package="GlorpMisc" selector="accessor">accessor	^accessor</body><body package="GlorpMisc" selector="accessor:">accessor: aDatabaseAccessor	accessor := aDatabaseAccessor</body><body package="GlorpMisc" selector="command">command	^command</body><body package="GlorpMisc" selector="command:">command: aDatabaseCommand	command := aDatabaseCommand</body><body package="GlorpMisc" selector="databaseError">databaseError	^databaseError</body><body package="GlorpMisc" selector="databaseError:">databaseError: aDatabaseErrorObject	databaseError := aDatabaseErrorObject</body><body package="GlorpMisc" selector="session">session	^command session.</body></methods><methods><class-id>Glorp.GlorpDatabaseReadError class</class-id> <category>initialize-release</category><body package="GlorpMisc" selector="mayResume">mayResume	^true.</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkPackage class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.GlorpMappingsPackage class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.SQLite3PragmaMapping</class-id> <category>public</category><body package="GlorpMappings" selector="setValueIn:to:">setValueIn: anObject to: aValue	"This method serves as a hook to do special work for the collection objects, #fields and #foreignKeysData.	It connects the objects to their owning tables (a SQLite3DatabaseTable object), and also resets the field	type for a primary key field whose owning table has 'AUTOINCREMENT' declared for its pkey field. Such	a field has type #serial. It would be nicer if that info were available elsewhere, but right now, this is where	the table and field first meet (and where that info can now be shared)."	self canRead ifFalse: [^self].	self attribute setValueIn: anObject to: aValue.	self attribute name = #fields		ifTrue: 			[aValue do: 					[:fld |					fld table: anObject.					fld isPrimaryKey						ifTrue: [anObject hasAutoIncrement ifTrue: [fld type: self descriptor system platform serial]]]].	self attribute name = #foreignKeysData		ifTrue: [aValue do: [:fld | fld sourceTableName: anObject name]]</body></methods><methods><class-id>Glorp.SQLite3PragmaMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="buildQuery">buildQuery	| toMany |	toMany := self attribute isCollectionAttribute.	query := toMany		ifTrue: [SQLite3PragmaQuery read: self referenceClass where: self join]		ifFalse: [SQLite3PragmaQuery readOneOf: self referenceClass where: self join].	query session: self session.	query baseExpression descriptor: (self session descriptorFor: self referenceClass).	query collectionType: self collectionType.	self usesLinkTable ifTrue: [		query AND: (self expressionFromLinkToReferenceTableWithBase: query baseExpression)].	orderBy isNil ifFalse: [orderBy do: [:each | query orderBy: each]].	^query.</body></methods><methods><class-id>Glorp.SQLite3PragmaMapping</class-id> <category>initialize-release</category><body package="GlorpMappings" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Glorp.GlorpDatabasePackage class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.SQLStringSelectCommand</class-id> <category>accessing</category><body package="GlorpDatabase" selector="bindings">bindings	"We're not actually sure if we're part of a query with a where clause, or being used in a more ad hoc way. So if we have a query, use either our pre-set parameters, or the query's bindings, whichever produces more. In a tie, pick the query's bindings."	| queryBindings |	query isNil ifTrue: [^parameters].	queryBindings := super bindings.	^queryBindings size &gt;= parameters size 		ifTrue: [queryBindings]		ifFalse: [parameters].</body><body package="GlorpDatabase" selector="bindingTypes">bindingTypes	^query isNil ifTrue: [#()] ifFalse: [super bindingTypes].</body><body package="GlorpDatabase" selector="blockFactor">blockFactor	blockFactor isNil ifTrue: [		blockFactor := query isNil ifTrue: [5] ifFalse: [super blockFactor]].	^blockFactor.</body><body package="GlorpDatabase" selector="setSQLString:">setSQLString: aString	sqlString := aString.</body></methods><methods><class-id>Glorp.SQLStringSelectCommand</class-id> <category>reporting</category><body package="GlorpDatabase" selector="tables">tables	^query isNil ifTrue: [Array with: #Unknown] ifFalse: [super tables].</body></methods><methods><class-id>Glorp.SQLStringSelectCommand</class-id> <category>sql</category><body package="GlorpDatabase" selector="printSQL">printSQL	"We assume the SQL is provided."	^self.</body></methods><methods><class-id>Glorp.SQLStringSelectCommand class</class-id> <category>As yet unclassified</category><body package="GlorpDatabase" selector="sqlString:parameters:useBinding:session:">sqlString: aString parameters: aDictionaryOrArray useBinding: aBoolean session: aSession	^(self new)		setSQLString: aString;		parameters: aDictionaryOrArray;		useBinding: aBoolean;		session: aSession.</body></methods><methods><class-id>Glorp.SQLite3PragmaCommand</class-id> <category>sql</category><body package="GlorpDatabase" selector="printSQL">printSQL	stream nextPutAll: 'PRAGMA '.	query resultClass = Glorp.DatabaseField		ifTrue: [stream nextPutAll: 'table_info ('].	query resultClass = Glorp.SQLite3ForeignKeyData		ifTrue: [stream nextPutAll: 'foreign_key_list('].	query resultClass = Glorp.SQLite3IndexData		ifTrue: [stream nextPutAll: 'index_list('].	query resultClass = Glorp.SQLite3IndexColumnData		ifTrue: [stream nextPutAll: 'index_info('].	"query printSelectFieldsOn: self."	self findBoundExpressions.	"query printTablesOn: self."	query printWhereClauseOn: self.	stream nextPutAll: ')'	"query printJoinsOn: self.	query printOrderingOn: self.	query printGroupByOn: self.	query printPostLimitOn: self.	query printOffsetOn: self."</body></methods><methods><class-id>Glorp.GlorpIntegerType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'integer'.</body></methods><methods><class-id>Glorp.GlorpIntegerType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes" selector="=">= aType	(aType class == self platform numeric class and: [aType isIntegerType]) ifTrue: [^true].	^super = aType</body><body package="GlorpDatabaseTypes" selector="hash">hash	"Our hash must be identical to GlorpNumericType's hash when it is an #isInteger"	^self platform hash bitXor: self impliedSmalltalkType hash</body></methods><methods><class-id>Glorp.HorizontalTypeMapping</class-id> <category>initializing</category><body package="GlorpMappings" selector="mappedClass:">mappedClass: aClass	mappedClass := aClass</body></methods><methods><class-id>Glorp.HorizontalTypeMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="allDescribedConcreteClasses">allDescribedConcreteClasses	| col |	col := OrderedCollection new		add: self describedClass;		addAll: self describedClass glorpAllSubclasses;		yourself.	self needsWork: 'This belongs in someone else''s responsibility'.	^col select: [:each |		(self system descriptorFor: each) typeMapping isAbstract not ].</body><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap	"do nothing"</body><body package="GlorpMappings" selector="mappedFields">mappedFields	^#()</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	^self</body></methods><methods><class-id>Glorp.HorizontalTypeMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="beAbstract">beAbstract	isAbstract := true</body><body package="GlorpMappings" selector="isAbstract">isAbstract	^isAbstract isNil ifTrue: [ isAbstract := false ] ifFalse: [ isAbstract ]</body></methods><methods><class-id>Glorp.HorizontalTypeMapping class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="forClass:">forClass: aClass	^self new		mappedClass: aClass;		yourself</body></methods><methods><class-id>Glorp.NullSequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:">postWriteAssignSequenceValueFor: aField in: aRow</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body><body package="GlorpDatabase" selector="preWriteAssignSequenceValueFor:in:">preWriteAssignSequenceValueFor: aField in: aRow</body></methods><methods><class-id>Glorp.NullSequence</class-id> <category>public</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body></methods><methods><class-id>Glorp.NullSequence class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="new">new	Singleton isNil ifTrue: [Singleton := self basicNew].	^Singleton.</body></methods><methods><class-id>Glorp.NullSequence class</class-id> <category>defaults</category><body package="GlorpDatabase" selector="default">default	^self new.</body></methods><methods><class-id>Glorp.InMemorySequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:">postWriteAssignSequenceValueFor: aField in: aRow</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body><body package="GlorpDatabase" selector="preWriteAssignSequenceValueFor:in:">preWriteAssignSequenceValueFor: aField in: aRow	aRow at: aField put: (count := count + 1).</body></methods><methods><class-id>Glorp.InMemorySequence</class-id> <category>initialize/release</category><body package="GlorpDatabase" selector="initialize">initialize	super initialize.	count := 0.</body></methods><methods><class-id>Glorp.InMemorySequence</class-id> <category>public</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession	aRow at: aField put: (count := count + 1).</body></methods><methods><class-id>Glorp.InMemorySequence class</class-id> <category>defaults</category><body package="GlorpDatabase" selector="default">default	^self new.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>accessing</category><body package="GlorpDatabase" selector="allSequences">allSequences	"Return a dictionary of all the sequences associated with this table, indexed by name."	| result |	result := Dictionary new.	self fields do: [:eachField |  		eachField type hasSequence ifTrue:			[result at: eachField type sequence name put: eachField type sequence]].	^result.</body><body package="GlorpDatabase" selector="creator">creator	^self schema</body><body package="GlorpDatabase" selector="creator:">creator: aString	"For backward-compatibility. Use schema: instead."	self schema: aString.</body><body package="GlorpDatabase" selector="fields">fields	^fields</body><body package="GlorpDatabase" selector="foreignKeyConstraints">foreignKeyConstraints	"Private - Answer the value of the receiver's ''foreignKeyConstraints'' instance variable."	^foreignKeyConstraints</body><body package="GlorpDatabase" selector="foreignKeyConstraintsForCreation">foreignKeyConstraintsForCreation	"Return the foreign key constraints that should actually be created in the database. Omit those that refer to imaginary tables"	^foreignKeyConstraints select: [:each |		each isImaginary not and: [each shouldCreateInDatabase]].</body><body package="GlorpDatabase" selector="isAliased">isAliased	^parent notNil.</body><body package="GlorpDatabase" selector="isImaginary">isImaginary	^isImaginary.</body><body package="GlorpDatabase" selector="isImaginary:">isImaginary: aBoolean	isImaginary := aBoolean.</body><body package="GlorpDatabase" selector="lockKeyFields">lockKeyFields	^lockKeyFields</body><body package="GlorpDatabase" selector="name">name	^name</body><body package="GlorpDatabase" selector="name:">name: anObject	name := anObject</body><body package="GlorpDatabase" selector="nonPrimaryKeyFields">nonPrimaryKeyFields	^self fields reject: [:each | each isPrimaryKey].</body><body package="GlorpDatabase" selector="parent">parent	^parent.</body><body package="GlorpDatabase" selector="parent:">parent: aDatabaseTable	parent := aDatabaseTable.</body><body package="GlorpDatabase" selector="platform">platform	fields do: [:each | ^each type platform].	^nil.</body><body package="GlorpDatabase" selector="primaryKeyConstraints">primaryKeyConstraints	"Answer the value of the receiver's ''PrimaryKeyConstraints'' instance variable."	^self hasPrimaryKeyConstraints		ifTrue: [ PrimaryKeyConstraint forTable: self ]		ifFalse: [ nil ]</body><body package="GlorpDatabase" selector="primaryKeyFields">primaryKeyFields	primaryKeyFields isNil ifTrue: [primaryKeyFields := fields select: [:each | each isPrimaryKey yourSelf "might be a proxy"]].	^primaryKeyFields.</body><body package="GlorpDatabase" selector="qualifiedName">qualifiedName	^(schema isNil or: [schema isEmpty]) ifTrue: [name] ifFalse: [schema, '.', name].</body><body package="GlorpDatabase" selector="replacementSubSelect:">replacementSubSelect: aQuery	replacementSubSelect := aQuery.</body><body package="GlorpDatabase" selector="schema">schema	^schema</body><body package="GlorpDatabase" selector="schema:">schema: aString	schema := aString.	parent isNil ifTrue: [		self sequences do: [:each | each schema: aString]].</body><body package="GlorpDatabase" selector="sequences">sequences	"Return a collection (which is likely either empty or of size 1) of all the sequences we use."	| sequences |	sequences := OrderedCollection new: 2.	self primaryKeyFields do: [:each | each type hasSequence ifTrue: [sequences add: each type sequence]].	^sequences.</body><body package="GlorpDatabase" selector="shouldBeWritten">shouldBeWritten	^isImaginary not.</body><body package="GlorpDatabase" selector="uniqueConstraints">uniqueConstraints	"Private - Answer the value of the receiver's ''uniqueConstraints'' instance variable."	^uniqueConstraints</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>fields</category><body package="GlorpDatabase" selector="addField:">addField: aField	fields add: aField.	aField isPrimaryKey ifTrue: [		self addAsPrimaryKeyField: aField].	aField table: self.	aField position: fields size.	^aField.</body><body package="GlorpDatabase" selector="addForeignKeyFrom:to:">addForeignKeyFrom: sourceField to: targetField	^self		addForeignKeyFrom: sourceField		to: targetField		suffixExpression: nil.</body><body package="GlorpDatabase" selector="addForeignKeyFrom:to:from:to:">addForeignKeyFrom: sourceField to: targetField from: sourceField2 to: targetField2	^self		addForeignKeyFromAll: (Array with: sourceField with: sourceField2)		toAll: (Array with: targetField with: targetField2)		suffixExpression: nil.</body><body package="GlorpDatabase" selector="addForeignKeyFrom:to:from:to:from:to:">addForeignKeyFrom: sourceField to: targetField from: sourceField2 to: targetField2 from: sourceField3 to: targetField3	^self		addForeignKeyFromAll: (Array with: sourceField with: sourceField2 with: sourceField3)		toAll: (Array with: targetField with: targetField2 with: targetField3)		suffixExpression: nil.</body><body package="GlorpDatabase" selector="addForeignKeyFrom:to:suffixExpression:">addForeignKeyFrom: sourceField to: targetField suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceField: sourceField					targetField: targetField					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printString).	foreignKeyConstraints add: newFK.	^newFK.</body><body package="GlorpDatabase" selector="addForeignKeyFrom:toField:">addForeignKeyFrom: sourceField toField: targetField	^self addForeignKeyFrom: sourceField to: targetField</body><body package="GlorpDatabase" selector="addForeignKeyFrom:toTable:">addForeignKeyFrom: sourceField toTable: targetTable	^self addForeignKeyFrom: sourceField toField: (targetTable fieldNamed: 'ID' ifAbsent: [^nil])</body><body package="GlorpDatabase" selector="addForeignKeyFromAll:toAll:">addForeignKeyFromAll: sourceFields toAll: targetFields	^self addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: nil.</body><body package="GlorpDatabase" selector="addForeignKeyFromAll:toAll:suffixExpression:">addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceFields: sourceFields					targetFields: targetFields					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printString).	^foreignKeyConstraints add: newFK.</body><body package="GlorpDatabase" selector="addUniqueConstraintFor:">addUniqueConstraintFor: sourceFields	| newConstraint |	newConstraint := UniqueConstraint		forTable: self		fields: sourceFields.	^uniqueConstraints add: newConstraint</body><body package="GlorpDatabase" selector="createFieldNamed:type:">createFieldNamed: aString type: dbType	| existingField |	existingField := fields detect: [:each | each name = aString] ifNone: [nil].	(existingField notNil)	ifTrue: [self error: 'field ', aString, ' already exists'].	^self addField: (DatabaseField named: aString type: dbType)</body><body package="GlorpDatabase" selector="fieldNamed:">fieldNamed: aString	^self fieldNamed: aString ifAbsent: [self error: 'No field ', aString, ' in ', self name].</body><body package="GlorpDatabase" selector="fieldNamed:ifAbsent:">fieldNamed: aString ifAbsent: aBlock	^self fieldNamed: aString ifAbsent: aBlock caseSensitive: false.</body><body package="GlorpDatabase" selector="fieldNamed:ifAbsent:caseSensitive:">fieldNamed: aString ifAbsent: aBlock caseSensitive: aBoolean	| fieldName |	fieldName := aBoolean ifTrue: [aString asString] ifFalse: [aString asUppercase].	^fields		detect:			[:each | (aBoolean ifTrue: [each name] ifFalse: [each name asUppercase]) = fieldName]		ifNone: aBlock.</body><body package="GlorpDatabase" selector="newFieldNamed:">newFieldNamed: aString	^self error: 'use #createFieldNamed:type:'</body><body package="GlorpDatabase" selector="removeFieldNamed:">removeFieldNamed: aString	^self removeFieldNamed: aString ifAbsent: [self error: 'No such field'].</body><body package="GlorpDatabase" selector="removeFieldNamed:ifAbsent:">removeFieldNamed: aString ifAbsent: aBlock		fields remove: (self fieldNamed: aString ifAbsent: aBlock).	1 to: fields size do: [:i | (fields at: i) position: i].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>printing</category><body package="GlorpDatabase" selector="imaginaryReplacementName">imaginaryReplacementName	| stream |	stream := WriteStream on: (String new: 100).	stream nextPut: $(.	stream nextPutAll: (replacementSubSelect sqlWith: #()) sqlString.	stream nextPutAll: ') '.	^stream contents.</body><body package="GlorpDatabase" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: '(';		nextPutAll: ((schema isNil or: [schema isEmpty]) ifTrue: [''] ifFalse: [schema, '.']);		nextPutAll: (name isNil ifTrue: [''] ifFalse: [name]);		nextPutAll: ')'.</body><body package="GlorpDatabase" selector="printSQLOn:withParameters:">printSQLOn: aWriteStream withParameters: aDictionary	aWriteStream nextPutAll: self qualifiedName</body><body package="GlorpDatabase" selector="sqlString">sqlString	^name.</body><body package="GlorpDatabase" selector="sqlTableName">sqlTableName	"Our name, as appropriate for the list of tables in a SQL statement. Take into account aliasing"	^parent isNil		ifTrue:			[self isImaginary				ifTrue: [self imaginaryReplacementName]				ifFalse: [self qualifiedName]]		ifFalse: [parent sqlTableName , ' ' , self qualifiedName].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>testing</category><body package="GlorpDatabase" selector="hasCompositePrimaryKey">hasCompositePrimaryKey	^primaryKeyFields size &gt; 1.</body><body package="GlorpDatabase" selector="hasConstraints">hasConstraints	^self hasForeignKeyConstraints or: [self hasPrimaryKeyConstraints or: [self hasUniqueConstraints]]</body><body package="GlorpDatabase" selector="hasConstraintsTo:">hasConstraintsTo: aTable	self foreignKeyConstraints		do: [:each | (each refersToTable: aTable) ifTrue: [^true]].	^false.</body><body package="GlorpDatabase" selector="hasConstraintsToAnyOf:">hasConstraintsToAnyOf: aCollectionOfTables	aCollectionOfTables do: [:each |		(self hasConstraintsTo: each) ifTrue: [^true]].	^false.</body><body package="GlorpDatabase" selector="hasFieldNamed:">hasFieldNamed: aString	^(self fieldNamed: aString ifAbsent: [nil] caseSensitive: false) notNil.</body><body package="GlorpCore" selector="hasForeignKeyConstraintMatching:">hasForeignKeyConstraintMatching: aConstraint	^self foreignKeyConstraints		anySatisfy: [:each | (each matchesForeignKeyConstraint: aConstraint)].</body><body package="GlorpCore" selector="hasForeignKeyConstraintTheSameAs:">hasForeignKeyConstraintTheSameAs: aConstraint	^self foreignKeyConstraints anySatisfy: [:each | (each isTheSameAs: aConstraint)].</body><body package="GlorpDatabase" selector="hasForeignKeyConstraints">hasForeignKeyConstraints	^foreignKeyConstraints isEmpty not</body><body package="GlorpDatabase" selector="hasIndexNamed:">hasIndexNamed: aString	^indexes contains: [:each | each name = aString]</body><body package="GlorpDatabase" selector="hasPrimaryKeyConstraints">hasPrimaryKeyConstraints	^self primaryKeyFields isEmpty not.</body><body package="GlorpCore" selector="hasUniqueConstraintMatching:">hasUniqueConstraintMatching: aConstraint		^self uniqueConstraints anySatisfy: [:each | each matchesUniqueConstraint: aConstraint]</body><body package="GlorpDatabase" selector="hasUniqueConstraints">hasUniqueConstraints	^uniqueConstraints isEmpty not</body><body package="GlorpDatabase" selector="isEmpty">isEmpty	^fields isEmpty.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>private/fields</category><body package="GlorpDatabase" selector="addAsLockKeyField:">addAsLockKeyField: aField 	lockKeyFields add: aField</body><body package="GlorpDatabase" selector="addAsPrimaryKeyField:">addAsPrimaryKeyField: aField	(fields includes: aField) ifFalse: [self error: 'Primary key field not part of the table'].	aField isPrimaryKey ifFalse: ["Somebody is calling this as API, since there's an example out on the net that does it that way - just do the right thing instead"		^aField bePrimaryKey].	(primaryKeyFields notNil and: [primaryKeyFields includes: aField]) ifTrue: [^self].	primaryKeyFields := primaryKeyFields isNil ifTrue: [Array with: aField] ifFalse: [primaryKeyFields, (Array with: aField)].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>validation</category><body package="GlorpDatabase" selector="validateIn:">validateIn: aDescriptorSystem	"Do any tests we can to make sure that this definition makes sense in this context"</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>indexes</category><body package="GlorpDatabase" selector="addIndex:">addIndex: aDatabaseIndex	^indexes add: aDatabaseIndex.</body><body package="GlorpDatabase" selector="addIndexForField:">addIndexForField: aField	^indexes add: (DatabaseIndex forField: aField).</body><body package="GlorpDatabase" selector="addIndexForField:and:">addIndexForField: aField and: anotherField	^self addIndexForFields: (Array with: aField with: anotherField).</body><body package="GlorpDatabase" selector="addIndexForField:and:and:">addIndexForField: aField and: anotherField and: thirdField	^self addIndexForFields: (Array with: aField with: anotherField with: thirdField).</body><body package="GlorpDatabase" selector="addIndexForFields:">addIndexForFields: aFieldCollection	^indexes add: (DatabaseIndex forFields: aFieldCollection).</body><body package="GlorpDatabase" selector="hasIndexForField:">hasIndexForField: aField	^(indexes detect: [:each | each indexesField: aField] ifNone: [nil]) notNil.</body><body package="GlorpDatabase" selector="indexes">indexes	^indexes.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>constraints</category><body package="GlorpDatabase" selector="foreignKeyConstraintsForField:">foreignKeyConstraintsForField: aField	^self foreignKeyConstraints select: [:each | each sourceFields includes: aField].</body><body package="GlorpDatabase" selector="hasForeignKeyConstraintsForField:">hasForeignKeyConstraintsForField: aField	^self foreignKeyConstraints anySatisfy: [:each | each sourceFields includes: aField].</body><body package="GlorpDatabase" selector="hasForeignKeyConstraintsForTargetField:">hasForeignKeyConstraintsForTargetField: aField	^self foreignKeyConstraints anySatisfy: [:each | each targetFields includes: aField].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>initialize</category><body package="GlorpDatabase" selector="initialize">initialize	schema := ''.	fields := OrderedCollection new.	foreignKeyConstraints := OrderedCollection new: 4.	uniqueConstraints := OrderedCollection new.	lockKeyFields := OrderedCollection new.	indexes := OrderedCollection new.	isImaginary := false.</body><body package="GlorpDatabase" selector="postInitializeIn:">postInitializeIn: aDescriptorSystem	"Any initialization that happens after all the fields have been added"	1 to: fields size do: [:i |		| each | 		"If fields were read from the database, set their position now"		each := fields at: i.		each table: self.		each position: i.		each postInitializeIn: aDescriptorSystem].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>comparing</category><body package="GlorpDatabase" selector="&lt;=">&lt;= aTable	^self qualifiedName &lt;= aTable qualifiedName.</body><body package="GlorpDatabase" selector="isTheSameAs:">isTheSameAs: aDatabaseTable	"Validate that two tables are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aDatabaseTable name asUppercase ifFalse: [^false].	"For the test purposes, we won't worry about schema right now.""	self schema = aDatabaseTable schema ifFalse: [^false]."	self fields size = aDatabaseTable fields size ifFalse: [^false].	self fields asSortedCollection with: aDatabaseTable fields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].	self foreignKeyConstraints size = aDatabaseTable foreignKeyConstraints size ifFalse: [^false].	self foreignKeyConstraints with: aDatabaseTable foreignKeyConstraints do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self indexes with: aDatabaseTable indexes do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].	self lockKeyFields with: aDatabaseTable lockKeyFields do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self primaryKeyFields size = aDatabaseTable primaryKeyFields size ifFalse: [^false].	self primaryKeyFields asSortedCollection with: aDatabaseTable primaryKeyFields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].	self isImaginary = aDatabaseTable isImaginary ifFalse: [^false].	^true.	"Note, we ignore parent and replacementSubselect"</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>obsolete</category><body package="GlorpDatabase" selector="addFields:fromAccessor:">addFields: aCollection fromAccessor: aDatabaseAccessor	| stream |	aCollection		do:			[:each | 			aDatabaseAccessor				execute:					[stream := WriteStream on: String new.					stream						nextPutAll: 'ALTER TABLE ';						nextPutAll: self name;						nextPutAll: ' ADD ';						nextPutAll: self platform startColumnAddString.					self platform printColumn: each on: stream.					stream nextPutAll: self platform endColumnAddString.					aDatabaseAccessor executeSQLStringNoResult: stream contents]				ifError: [:ex | ex pass]].</body><body package="GlorpDatabase" selector="dropFields:fromAccessor:">dropFields: aCollection fromAccessor: aDatabaseAccessor	aCollection		do:			[:each | 			aDatabaseAccessor				execute:					[aDatabaseAccessor						executeSQLStringNoResult:							'ALTER TABLE ' , self name , ' DROP COLUMN ' , each name]				ifError: [:ex | ex pass]].</body><body package="GlorpDatabase" selector="dropForeignKeyConstraintsFromAccessor:">dropForeignKeyConstraintsFromAccessor: aDatabaseAccessor 	self foreignKeyConstraints 		do: [:each | aDatabaseAccessor dropConstraint: each]</body><body package="GlorpDatabase" selector="dropFromAccessor:">dropFromAccessor: aDatabaseAccessor	aDatabaseAccessor dropTable: self  ifError: [].</body><body package="GlorpDatabase" selector="dropPrimaryKeyConstraintsFromAccessor:">dropPrimaryKeyConstraintsFromAccessor: aDatabaseAccessor	(self primaryKeyFields isEmpty not and: [self platform usesPrimaryKeyUniqueConstraintNames])		ifTrue: [			aDatabaseAccessor	execute:				[aDatabaseAccessor						executeSQLStringNoResult:							'ALTER TABLE ' , self name , ' DROP '								, self platform nameForPrimaryKeyConstraintsWhenDropping , ' '								, self primaryKeyUniqueConstraintName]				ifError:					[:ex | 					Transcript show: ex messageText.					ex return: nil].		aDatabaseAccessor execute: [			aDatabaseAccessor executeSQLStringNoResult:					'ALTER TABLE ' , self name , ' DROP '						, self platform nameForPrimaryKeyConstraintsWhenDropping , ' '						, self primaryKeyConstraintName]			ifError: [:ex | 				Transcript show: ex messageText.				ex return: nil]].</body><body package="GlorpDatabase" selector="primaryKeyConstraintName">primaryKeyConstraintName	^self name, '_PK'.</body><body package="GlorpDatabase" selector="primaryKeyUniqueConstraintName">primaryKeyUniqueConstraintName	^self platform usesPrimaryKeyUniqueConstraintNames ifTrue: [self name, '_UNIQ'] ifFalse: [''].</body><body package="GlorpDatabase" selector="printAddPrimaryKeyConstraintsOn:for:">printAddPrimaryKeyConstraintsOn: aStream for: aDatabaseAccessor 	self primaryKeyFields isEmpty ifTrue: [^self].	aStream nextPutAll: 'ALTER TABLE ' , self name.	aStream nextPutAll: ' ADD CONSTRAINT '.	aStream nextPutAll: self primaryKeyConstraintName.	aStream nextPutAll: ' PRIMARY KEY  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	aStream		nextPutAll: ',';		cr.	aStream nextPutAll: ' ADD CONSTRAINT '.	aStream nextPutAll: self primaryKeyUniqueConstraintName.	aStream nextPutAll: ' UNIQUE  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $)</body><body package="GlorpDatabase" selector="printDelimiterOn:">printDelimiterOn: aStream		aStream		nextPut: $,;		cr</body><body package="GlorpDatabase" selector="printPrimaryKeyConstraintsOn:for:">printPrimaryKeyConstraintsOn: aStream for: aDatabaseAccessor 	self primaryKeyFields isEmpty ifTrue: [^self].	aStream nextPutAll: 'CONSTRAINT '.	aStream nextPutAll: self primaryKeyConstraintName.	aStream nextPutAll: ' PRIMARY KEY  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	aStream		nextPutAll: ',';		cr.	aStream nextPutAll: 'CONSTRAINT '.	aStream nextPutAll: self primaryKeyUniqueConstraintName.	aStream nextPutAll: ' UNIQUE  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $)</body></methods><methods><class-id>Glorp.DatabaseTable class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="named:">named: aString	^self new name: aString.</body><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="basicExecuteSQLString:">basicExecuteSQLString: aString	| result cursor records |	result := connection execSql: aString.	records := result records.	"Fix up nulls"	records do: [:each |		1 to: each size do: [:i |			(each at: i) == #'(NULL)' ifTrue: [each at: i put: nil]]].	cursor := self cursorFor: (ReadStream on: result records).	cursor statement: result.	^cursor.</body><body package="GlorpDatabase" selector="basicExecuteSQLString:bindingArray:">basicExecuteSQLString: aString bindingArray: aBindingArray	" *** This method was defined by Glorp.DatabaseAccessor as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpDatabase" selector="basicExecuteSQLString:returnResult:binding:doing:">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	^connection execSql: aString.</body><body package="GlorpDatabase" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	^Error.</body><body package="GlorpDatabase" selector="isInTransaction">isInTransaction	^inTransaction.</body><body package="GlorpDatabase" selector="releaseCursor:in:">releaseCursor: aCursor in: aPreparedStatement</body><body package="GlorpDatabase" selector="rowCount">rowCount	^connection rowsProcessed.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="isLoggedIn">isLoggedIn	connection isNil ifTrue: [^false].	^connection isActive</body><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock	| |"	connection :=self connectionClass 		name: currentLogin connectString		alias: currentLogin connectString		password: currentLogin password		drive: 'c'		comment: currentLogin connectString		create: false."	connection := self connectionClass		logOnServer: currentLogin connectString		 user: currentLogin username		 password: currentLogin password		 alias: currentLogin connectString.	(connection isKindOf: Message)		ifTrue: [^self errorBoxMessage: connection asString].	connection start.</body><body package="GlorpDatabase" selector="logout">logout	connection class logOff.</body><body package="GlorpDatabase" selector="rollbackTransaction">rollbackTransaction	inTransaction := false.	^connection rollback.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase" selector="beginTransaction">beginTransaction	inTransaction := true.	^connection beginTran.</body><body package="GlorpDatabase" selector="commitTransaction">commitTransaction	inTransaction := false.	^connection commit.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase" selector="connectionClassForLogin:">connectionClassForLogin: aLogin	aLogin database class == OraclePlatform		ifTrue: [^Smalltalk at: #OracleOCIDatabase ifAbsent: [self error: 'no such driver']].	aLogin database isODBCPlatform ifTrue: [^Smalltalk at: #ODBCDatabase].	self error: 'Unknown database: ' , aLogin database name.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>initialize-release</category><body package="GlorpDatabase" selector="initialize">initialize	inTransaction := false.</body><body package="GlorpDatabase" selector="showDialog:">showDialog: aString	" *** This method was defined by Glorp.DatabaseAccessor as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Glorp.MySQLODBCPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="isODBCPlatform">isODBCPlatform	^true.</body></methods><methods><class-id>Glorp.StandaloneFunction</class-id> <category>mapping</category><body package="GlorpExpressions" selector="mappedFields">mappedFields	^Array with: self.</body><body package="GlorpExpressions" selector="valueInBuilder:">valueInBuilder: anElementBuilder	^anElementBuilder valueOfField: self</body><body package="GlorpExpressions" selector="valueInBuilder:as:">valueInBuilder: anElementBuilder as: anExpression	^anElementBuilder valueOfField: anExpression.</body></methods><methods><class-id>Glorp.StandaloneFunction</class-id> <category>printing</category><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	aStream nextPutAll: ' '; nextPutAll: function.</body></methods><methods><class-id>Glorp.StandaloneFunction</class-id> <category>accessing</category><body package="GlorpExpressions" selector="field">field	^nil.</body><body package="GlorpExpressions" selector="type">type	type isNil ifFalse: [^type].	^self defaultType.</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase" selector="loginIfError:">loginIfError: aBlock	self		execute:			[connection := ((Smalltalk at: #DBConnection) new)				dsn: currentLogin connectString;				uid: currentLogin username;				pwd: currentLogin password;				connect.]		ifError: aBlock</body><body package="GlorpDatabase" selector="logout">logout	connection notNil		ifTrue:			[[connection close.] ensure: [connection := nil]].</body><body package="GlorpDatabase" selector="showDialog:">showDialog: aString	(Smalltalk at: #MessageBox) warning: aString.</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase" selector="beginTransaction">beginTransaction	connection beginRWTxn.</body><body package="GlorpDatabase" selector="commitTransaction">commitTransaction	self log: 'Commit Transaction'.	self logOnly ifTrue: [^self].	connection commitTxn</body><body package="GlorpDatabase" selector="isInTransaction">isInTransaction	^connection isInTransaction</body><body package="GlorpDatabase" selector="rollbackTransaction">rollbackTransaction	self log: 'Rollback Transaction'.	self logOnly ifTrue: [^self].	connection rollbackTxn</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase" selector="isLoggedIn">isLoggedIn	^connection notNil.</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase" selector="basicExecuteSQLString:">basicExecuteSQLString: aString	| resultSet array |	self log: aString.	self logOnly ifTrue: [^self].	resultSet := connection query: aString.	"Write statements don't like asArray if there's not result. DDL statements don't even like the isEmpty test"	array := [resultSet isEmpty ifTrue: [#()] ifFalse: [resultSet asArray]]		on: Dialect error		do: [:ex | ex return: #()].	resultSet		close;		free.	^ReadStream on: array read.</body><body package="GlorpDatabase" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	^Smalltalk at: #DBError</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>accessing</category><body package="GlorpQueries" selector="addQuery:">addQuery: aQuery	queries add: aQuery.</body><body package="GlorpQueries" selector="baseExpression">baseExpression	^queries first baseExpression.</body><body package="GlorpQueries" selector="collectionType">collectionType	^self primaryQuery collectionType.</body><body package="GlorpQueries" selector="primaryQuery">primaryQuery	^queries first.</body><body package="GlorpQueries" selector="proxyType">proxyType	^self primaryQuery proxyType.</body><body package="GlorpQueries" selector="proxyType:">proxyType: aClass		"We currently ignore proxy types and use the ones from our main query."	^self.</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>preparing</category><body package="GlorpQueries" selector="copyOfBuilders">copyOfBuilders 	^self primaryQuery copyOfBuilders.</body><body package="GlorpQueries" selector="prepare">prepare	queries do: [:each | each session: session].	queries do: [:each | each prepare].</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>initialize</category><body package="GlorpQueries" selector="initialize">initialize	super initialize.	queries := OrderedCollection new.</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>executing</category><body package="GlorpQueries" selector="executeWithParameters:in:">executeWithParameters: parameterArray in: aSession	| results |	results := self collectionType new writeStream.	queries do: [:each |		results nextPutAll: (each executeWithParameters: parameterArray in: aSession)].	^results contents.</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>copying</category><body package="GlorpQueries" selector="postCopy">postCopy	super postCopy.	queries := queries collect: [:each | each copy].</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>testing</category><body package="GlorpDatabase" selector="canBind:to:">canBind: aValue to: aType	"The Postgres EXDI seems to have trouble binding date formats"	aType = self date ifTrue: [^false].	aType = self time ifTrue: [^false].	aType = self timestamp ifTrue: [^false].	aType = self timetz ifTrue: [^false].	(Dialect isVisualWorks and: [aValue class == Dialect doublePrecisionFloatClass]) ifTrue: [^false].	(Dialect isVisualWorks and: [aValue class == Dialect fixedPointClass]) ifTrue: [^false].	^super canBind: aValue to: aType.</body><body package="GlorpDatabase" selector="measuresStringFieldWidthsInBytes">measuresStringFieldWidthsInBytes	"Return true if we measure the width of a string in bytes rather than characters. So, a 255-character field can hold 255 bytes worth of string, not 255 characters. This is important with encodings"	^true.</body><body package="GlorpDatabase" selector="requiresCastsForNullsInUnions">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^true.</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax."	^true.</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"Binding works only with VW EXDI so far"	^Dialect isVisualWorks.</body><body package="GlorpDatabase" selector="supportsCaseInsensitiveLike">supportsCaseInsensitiveLike	^true.</body><body package="GlorpDatabase" selector="supportsGroupWritingFor:">supportsGroupWritingFor: aCommand	^aCommand supportsGroupWriting.</body><body package="GlorpDatabase" selector="supportsLimit">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^true.</body><body package="GlorpDatabase" selector="supportsOffset">supportsOffset	"Do we support anything analogous to the postgresql OFFSET, skipping the first N rows"	^true.</body><body package="GlorpDatabase" selector="supportsSchemaForLogin">supportsSchemaForLogin	^false</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	"Return true if we use array binding for grouped writes rather than printing the sql multiple times. Only applies if we support grouped writes"	^false.</body><body package="GlorpDatabase" selector="usesInformationSchema">usesInformationSchema	^true</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>types</category><body package="GlorpDatabase" selector="bigint">bigint	^self typeNamed: #bigint ifAbsentPut: [GlorpIntegerType new typeString: 'bigint'].</body><body package="GlorpDatabase" selector="blob">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'bytea'].</body><body package="GlorpDatabase" selector="boolean">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'boolean'].</body><body package="GlorpDatabase" selector="char">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new typeName: 'character'].</body><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'text'].</body><body package="GlorpDatabase" selector="date">date	^self typeNamed: #date ifAbsentPut: [GlorpDateType new typeString: 'date'].</body><body package="GlorpDatabase" selector="decimal">decimal	^self numeric.</body><body package="GlorpDatabase" selector="double">double	^self float8</body><body package="GlorpDatabase" selector="float">float	^self float4.</body><body package="GlorpDatabase" selector="float4">float4	^self typeNamed: #float4 ifAbsentPut: [GlorpFloatType new].</body><body package="GlorpDatabase" selector="float8">float8	^self typeNamed: #float8 ifAbsentPut: [GlorpDoubleType new].</body><body package="GlorpDatabase" selector="int">int	^self int4</body><body package="GlorpDatabase" selector="int2">int2	^self typeNamed: #int2 ifAbsentPut: [GlorpIntegerType new typeString: 'int2'].</body><body package="GlorpDatabase" selector="int4">int4	^self typeNamed: #int4 ifAbsentPut: [GlorpIntegerType new typeString: 'int4'].</body><body package="GlorpDatabase" selector="int8">int8	^self typeNamed: #int8 ifAbsentPut: [GlorpIntegerType new typeString: 'int8'].</body><body package="GlorpDatabase" selector="numeric">numeric	^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase" selector="real">real	^self float4</body><body package="GlorpDatabase" selector="sequence">sequence	^self serial</body><body package="GlorpDatabase" selector="serial">serial	"For postgresql, we use sequences, and explicitly get the values ourselves, so just tell the database that they're integers."	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'integer'].</body><body package="GlorpDatabase" selector="smallint">smallint	^self int2</body><body package="GlorpDatabase" selector="time">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time'].</body><body package="GlorpDatabase" selector="timeStampTypeString">timeStampTypeString	^'timestamp'.</body><body package="GlorpDatabase" selector="timestamp">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'timestamp without time zone'].</body><body package="GlorpDatabase" selector="timetz">timetz	^self typeNamed: #timetz ifAbsentPut: [GlorpPGTimeWithTimeZoneType new].</body><body package="GlorpDatabase" selector="varchar">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new typeName: 'character varying'].</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDate for: aType	"Print a date (or timestamp) as yyyy-mm-dd"	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $'.	self		printDate: aDate		isoFormatOn: stream.	stream nextPut: $'.	^stream contents.</body><body package="GlorpDatabase" selector="printTime:for:">printTime: aTime for: aType	"Print a time (or timestamp) as hh:mm:ss.fff"	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $'.	self		printTime: aTime		isoFormatOn: stream.	stream nextPut: $'.	^stream contents.</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPut: $'.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream.	stream nextPut: $'.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	^PGSequence.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>SQL</category><body package="GlorpDatabase" selector="isPostgreSQLPlatform">isPostgreSQLPlatform	^true.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>database-specific</category><body package="GlorpDatabase" selector="printOffset:on:">printOffset: anInteger on: aCommand	aCommand		nextPutAll: ' OFFSET '.	anInteger printOn: aCommand.</body><body package="GlorpDatabase" selector="printPostLimit:on:">printPostLimit: anInteger on: aCommand	aCommand		nextPutAll: ' LIMIT '.	anInteger printOn: aCommand.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	^true.</body><body package="GlorpDatabase" selector="charactersThatNeedEscaping">charactersThatNeedEscaping	^#($' $\)</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^31</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^31</body><body package="GlorpDatabase" selector="requiresTransactionForTableOperations">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^false.</body><body package="GlorpDatabase" selector="sqlTextCurrentServerUTCTimestamp">sqlTextCurrentServerUTCTimestamp	^'SELECT CURRENT_TIMESTAMP AT TIME ZONE ''UTC'' '</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	"I think this depends on settings, but it's easier right now to just turn it off"	^false.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="byteArrayToSQLStringConverter">byteArrayToSQLStringConverter	^DelegatingDatabaseConverter		named: #byteArrayToSQLString		hostedBy: self		fromStToDb: #convertByteArrayToSQLString:for:		fromDbToSt: #convertSQLStringToByteArray:for:.</body><body package="GlorpDatabase" selector="convertSQLStringToByteArray:for:">convertSQLStringToByteArray: aString for: aType	| aStream str | 	aString isNil ifTrue: [^nil].	aStream := (ByteArray new: aString size // 4) writeStream.	str := aString readStream.	[str atEnd] whileFalse: [ |nextChar|		nextChar := str next.		aStream nextPut: (nextChar = $\								ifTrue: [str peek = $\											ifTrue: [str next asInteger]											ifFalse: [Number readFrom: (str next: 3) base: 8]]								ifFalse: [nextChar asInteger])	].	aStream close.	^aStream contents</body><body package="GlorpDatabase" selector="printBlob:on:for:">printBlob: aByteArray on: aStream for: aType	| base64Stream |	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	Dialect isSqueak ifTrue: [^self squeakPrintBlob: aByteArray on: aStream for: aType].	aStream nextPut: $'.	base64Stream := (Dialect smalltalkAt: #Base64EncodingWriteStream) onStream: aStream.	base64Stream lineBreaksEnabled: false.	base64Stream nextPutAll: aByteArray.	base64Stream emitClosingCharacters.	aStream nextPut: $'.</body><body package="GlorpDatabase" selector="squeakPrintBlob:on:for:">squeakPrintBlob: aByteArray on: aStream for: aType	aStream nextPut: $'.	aByteArray do: [:each |		aStream nextPutAll: '\\'.		each asInteger printOn: aStream paddedWith: $0 to: 3 base: 8].	aStream nextPutAll: '''::bytea'.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>accessing</category><body package="GlorpDatabase" selector="vwEXDIConnectionClass">vwEXDIConnectionClass	^'PostgreSQLEXDIConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'PostgreSQLEXDI'</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>type helpers</category><body package="GlorpDatabase" selector="typesWithValues">typesWithValues	super typesWithValues.	self boolean.	self bigint.	self date.	self decimal.	self double.	self float.	self float4.	self float8.	self int2.	self int.	self integer.	self numeric.	self real.	self sequence.	self serial.	self timetz.	^self types.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="tableNameFor:">tableNameFor: aStringRepresentingATableName	"Return the table name, as modified to be used in a database statement."		^(aStringRepresentingATableName		detect: [:each | each isUppercase]		ifNone: [nil]) isNil	ifTrue: [aStringRepresentingATableName]	ifFalse: ['"' , aStringRepresentingATableName , '"'].</body></methods><methods><class-id>Glorp.PostgreSQLPlatform class</class-id> <category>testing</category><body package="GlorpDatabase" selector="useBindingByDefault">useBindingByDefault	^false</body></methods><methods><class-id>Glorp.MessageArchiverForGetMapping</class-id> <category>expression creation</category><body package="GlorpQueries" selector="sendMessageTo:withArguments:">sendMessageTo: anExpression withArguments: arguments	"Send our own particular message. Note that our arguments will have been wrapped as constant expressions, and we don't want that, so unwrap them"	^anExpression getMapping: arguments first value named: (arguments at: 2) value.</body></methods><methods><class-id>Glorp.HorizontalTypeResolver</class-id> <category>testing</category><body package="GlorpMappings" selector="isTypeMappingRoot:">isTypeMappingRoot: aDescriptor	^aDescriptor == rootDescriptor</body><body package="GlorpMappings" selector="supportsOrderingFor:">supportsOrderingFor: aDescriptor	concreteMembers detect: [:each | each == aDescriptor] ifNone: [^false].	^true.</body></methods><methods><class-id>Glorp.HorizontalTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings" selector="allTablesFor:">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses."	^(self descriptorsRequiringIndependentQueriesFor: aDescriptor describedClass) inject: OrderedCollection new into: [:sum :eachDescriptor |		sum addAll: ((eachDescriptor == aDescriptor) ifTrue: [eachDescriptor tables] ifFalse: [eachDescriptor allTables]).		sum].</body><body package="GlorpMappings" selector="classesRequiringIndependentQueriesFor:">classesRequiringIndependentQueriesFor: aClass	^(self descriptorsRequiringIndependentQueriesFor: aClass) collect: [:each |		each describedClass].</body><body package="GlorpMappings" selector="describedConcreteClassFor:withBuilder:descriptor:">describedConcreteClassFor: row withBuilder: builder descriptor: aDescriptor	^aDescriptor describedClass</body><body package="GlorpMappings" selector="descriptorsRequiringIndependentQueriesFor:">descriptorsRequiringIndependentQueriesFor: aClass	^self concreteMembers select: [ :each | each describedClass includesBehavior: aClass ].</body><body package="GlorpMappings" selector="shouldUseSingleQuery">shouldUseSingleQuery	"Return true if we should attempt to combine queries for multiple subclasses in disjoint tables into one."	shouldUseSingleQuery isNil ifTrue: [shouldUseSingleQuery := false].	^shouldUseSingleQuery.</body><body package="GlorpMappings" selector="useSingleQuery:">useSingleQuery: aBoolean	shouldUseSingleQuery := aBoolean</body></methods><methods><class-id>Glorp.HorizontalTypeResolver</class-id> <category>query setup</category><body package="GlorpMappings" selector="mappingForSubclass:connectTo:">mappingForSubclass: aDescriptor connectTo: existingSubclassMapping	"Create a pseudo-mapping for the subclass."	| attributeName mapping newJoin |	attributeName := self pseudoAttributeNameForClass: aDescriptor describedClass.	mapping := self rootDescriptor mappingForAttributeNamed: attributeName.	mapping isNil ifTrue: [		rootDescriptor classModel newAttributeNamed: attributeName type: aDescriptor describedClass.		mapping := (rootDescriptor newMapping: OneToOneMapping)			attributeName: attributeName.		mapping beForPseudoVariable.		existingSubclassMapping isNil ifFalse: [			newJoin := Join new.			mapping join: newJoin]].	^mapping.</body><body package="GlorpMappings" selector="pseudoAttributeNameForClass:">pseudoAttributeNameForClass: aClass	^('subclassPseudoVariable', aClass name) asSymbol.</body><body package="GlorpMappings" selector="setUpExpressionsForQuery:">setUpExpressionsForQuery: aQuery	| mapping firstMapping allDescriptors |	(self concreteMembers includes: aQuery resultClass) ifTrue: [^self].	self shouldUseSingleQuery ifFalse: [^self].	firstMapping := nil.	allDescriptors := self		descriptorsRequiringIndependentQueriesFor: aQuery resultClass.	allDescriptors size = 1 ifTrue: [^self].	allDescriptors		do:			[:eachSubclassDescriptor | 			mapping := self				mappingForSubclass: eachSubclassDescriptor				connectTo: firstMapping.			firstMapping isNil ifTrue: [firstMapping := mapping].			aQuery				alsoFetch:					[:object | (object getMapping: mapping named: mapping attribute name) bePhantom asOuterJoin]].</body></methods><methods><class-id>Glorp.HorizontalTypeResolver class</class-id> <category>instance creation</category><body package="GlorpMappings" selector="forRootClass:">forRootClass: aClass	^self new		rootClass: aClass;		yourself.</body></methods><methods><class-id>GlorpHelper class</class-id> <category>helpers</category><body package="GlorpMisc" selector="do:for:separatedBy:">do: aBlock for: aCollection separatedBy: separatorBlock	| array |	array := aCollection asArray.	1 to: array size do: [:i |		| each |		each := array at: i.		aBlock value: each.		i = array size ifFalse: [			separatorBlock value]].</body><body package="GlorpMisc" selector="print:on:for:separatedBy:">print: printBlock on: stream for: aCollection separatedBy: separatorString	| array |	array := aCollection asArray.	1 to: array size do: [:index |		stream nextPutAll: (printBlock value: (array at: index)).		index == array size ifFalse: [			stream nextPutAll: separatorString]].</body><body package="GlorpMisc" selector="separate:by:">separate: aCollection by: aOneArgumentBlock	^aCollection inject: Dictionary new into: [:dict :each |		| val |		val := aOneArgumentBlock value: each.		(dict at: val ifAbsentPut: [OrderedCollection new]) add: each].</body></methods><methods><class-id>GlorpHelper class</class-id> <category>classes</category><body package="GlorpMisc" selector="dialect">dialect	"Provide a way to refer to the dialect class from an extension or class that doesn't include the Glorp namespace, while still avoiding explicit namespace imports (which confuse other dialects when the 'pool dictionaries' don't exist)."	| glorpNamespace |	glorpNamespace := Smalltalk at: #Glorp ifAbsent: [nil].	^((glorpNamespace isNil ifTrue: [Smalltalk] ifFalse: [glorpNamespace]) at: #Dialect ifAbsent: [Smalltalk at: #Dialect]).</body><body package="GlorpMisc" selector="glorpConstantExpressionClass">glorpConstantExpressionClass	^self dialect glorpConstantExpressionClass</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>binding</category><body package="GlorpDatabase" selector="bindingsForGroupWritingFor:">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body><body package="GlorpDatabase" selector="maximumSizeToGroupWriteFor:">maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows	"If we are going to group write, how many rows of this collection should we do it for at once"	^aCollectionOfDatabaseRows size min: 250.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase" selector="printDate:for:">printDate: aDate for: aType	"Print a date (or timestamp) as yyyy-mm-dd"	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $'.	self		printDate: aDate		isoFormatOn: stream.	stream nextPut: $'.	^stream contents.</body><body package="GlorpDatabase" selector="printTime:for:">printTime: aTime for: aType	"Print a time (or timestamp) as hh:mm:ss.fff"	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: 'TIME( '''.	self		printTime: aTime		isoFormatOn: stream		milliseconds: self supportsMillisecondsInTimes.	stream nextPutAll: ''' )'.	^stream contents.</body><body package="GlorpDatabase" selector="printTimestamp:on:for:">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPut: $'.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream.	stream nextPut: $'.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>types</category><body package="GlorpDatabase" selector="blob">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'BLOB'].</body><body package="GlorpDatabase" selector="char">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new typeString: 'CHARACTER'].</body><body package="GlorpDatabase" selector="clob">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'CLOB'].</body><body package="GlorpDatabase" selector="date">date	"Return the type we use to represent dates."	^self typeNamed: #date ifAbsentPut: [GlorpDateType new].</body><body package="GlorpDatabase" selector="decimal">decimal	^self numeric.</body><body package="GlorpDatabase" selector="double">double	^self typeNamed: #double ifAbsentPut: [GlorpDoubleType new typeString: 'DOUBLE' ].</body><body package="GlorpDatabase" selector="float">float	^self typeNamed: #float ifAbsentPut: [GlorpFloatType new typeString: 'REAL' ].</body><body package="GlorpDatabase" selector="float4">float4	^self float.</body><body package="GlorpDatabase" selector="float8">float8	^self double.</body><body package="GlorpDatabase" selector="int">int	^self integer.</body><body package="GlorpDatabase" selector="int2">int2	^self smallint.</body><body package="GlorpDatabase" selector="int4">int4	^self integer.</body><body package="GlorpDatabase" selector="int8">int8	^self typeNamed: #int8 ifAbsentPut: [GlorpIntegerType new typeString: 'BIGINT'].</body><body package="GlorpDatabase" selector="nclob">nclob	^self typeNamed: #nclob ifAbsentPut: [GlorpClobType new typeString: 'dbclob'].</body><body package="GlorpDatabase" selector="numeric">numeric	"DB2 NUMERIC columns default to precision=5, scale=0."		^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new typeString: 'DECIMAL']</body><body package="GlorpDatabase" selector="nvarchar">nvarchar	^self typeNamed: #nvarchar ifAbsentPut: [GlorpVarCharType new typeString: 'nvarchar'].</body><body package="GlorpDatabase" selector="real">real	^self float.</body><body package="GlorpDatabase" selector="sequence">sequence	^self serial.</body><body package="GlorpDatabase" selector="serial">serial	"This is the sequence based type used by Glorp."	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: (self integer typeString)].</body><body package="GlorpDatabase" selector="serialIdentity">serialIdentity	"This is the identity column type used by DB2, but not supported by Glorp. It is here just	so that we can recognize identity columns when they are encountered."	^self typeNamed: #serialIdentity ifAbsentPut: [DB2IdentityType new typeString: 'integer generated always as identity '].</body><body package="GlorpDatabase" selector="text">text	^super text queryType: self varchar.</body><body package="GlorpDatabase" selector="time">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'TIME'].</body><body package="GlorpDatabase" selector="timeStampTypeString">timeStampTypeString	^'datetime'.</body><body package="GlorpDatabase" selector="timestamp">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'TIMESTAMP'].</body><body package="GlorpDatabase" selector="tinyint">tinyint	^self typeNamed: #tinyInt ifAbsentPut: [GlorpIntegerType new typeString: 'SMALLINT'].</body><body package="GlorpDatabase" selector="varbinary">varbinary	^self typeNamed: #varbinary ifAbsentPut: [GlorpVarBinaryType new].</body><body package="GlorpDatabase" selector="varchar">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new typeString: 'VARCHAR'].</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>constants</category><body package="GlorpDatabase" selector="areSequencesExplicitlyCreated">areSequencesExplicitlyCreated	^true</body><body package="GlorpDatabase" selector="databaseIdentitySequenceClass">databaseIdentitySequenceClass	"Uses the IDENTITY column mechanism."	^DB2IdentitySequence</body><body package="GlorpDatabase" selector="maximumLengthOfColumnName">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the max. length of a column name"	^128</body><body package="GlorpDatabase" selector="maximumLengthOfTableName">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^128</body><body package="GlorpDatabase" selector="sqlTextForNULLAttributeConstraint">sqlTextForNULLAttributeConstraint	"^&lt;String&gt;"	^''</body><body package="GlorpDatabase" selector="supportsConstraints">supportsConstraints	^true</body><body package="GlorpDatabase" selector="supportsMillisecondsInTimes">supportsMillisecondsInTimes	"Use TIMESTAMP for up to microseconds."	^false</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>conversion-strings</category><body package="GlorpDatabase" selector="charactersThatNeedEscaping">charactersThatNeedEscaping	"There seem to be all kind of contradictory bits of information about what sql server does/requires for escaped characters, all of which differ from standard sql. Empirically the only thing that requires escaping appears to be single quote"	^#($' ).</body><body package="GlorpDatabase" selector="escapeFor:">escapeFor: aCharacter	^String with: $' with: aCharacter."	^'\', (aCharacter asInteger printStringRadix: 16)."</body><body package="GlorpDatabase" selector="printBlob:on:for:">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: 'BLOB(X'''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPutAll: ''') '."	aStream nextPutAll: 'CAST(X'''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPutAll: ''' AS BLOB) '."</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>testing</category><body package="GlorpDatabase" selector="canUseInWhereClause:type:">canUseInWhereClause: aValue type: aType	"This is mostly for test support purposes. If we know we can't use a particular kind of value in the where clause on some database, don't try."	(super canUseInWhereClause: aValue type: aType) ifFalse: [^false].	"In DB2 we don't seem to be able to compare lobs against anything.	But if you convert the lob itself, that works sometimes. Eg.,		... WHERE CHAR(clb) = 'abcdefghijklmnop'.		... WHERE SUBSTR(clb,1, 16) LIKE 'abcdefghijklmnop'.		... WHERE CHAR(SUBSTR(clb,1, 16)) = 'abcdefghijklmnop'.	Note that LIKE works with SUBSTR(), but = works with CHAR()."	((Set with: (self blob) with: (self clob) with: (self nclob)) includes: aType) ifTrue: [^false].	^true.</body><body package="GlorpDatabase" selector="isDB2Platform">isDB2Platform	^true</body><body package="GlorpDatabase" selector="maximumQueryValueSize">maximumQueryValueSize	"If there's a limit on how big a bound input parameter can be for a query, return it here.	For literal strings and lobs, at least, the DB2 limit is 32K. Not sure about bound objects.	If those can be larger, then we can indicate that fact by introducing a companion method	later. Note that we write literal LOBs as 2-byte hex chars per byte. So, the limit is	actually 16384-9-1, eg., blob(X'0A41') makes 9 extras."	^16374</body><body package="GlorpDatabase" selector="requiresCastsForNullsInUnions">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^true.</body><body package="GlorpDatabase" selector="supportsANSIJoins">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true.</body><body package="GlorpDatabase" selector="supportsBinding">supportsBinding	"Binding works only with VW EXDI so far"	^Dialect isVisualWorks.</body><body package="GlorpDatabase" selector="supportsDecimalsOnAllNumerics">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place.	NUMERIC(5) will not store 321.12 (it'll keep 321.)."	^false.</body><body package="GlorpDatabase" selector="supportsGroupWritingFor:">supportsGroupWritingFor: aCommand	"^aCommand supportsGroupWriting."	"INSERT ...; INSERT ...; INSERT... fails,	but this works: INSERT INTO table (id, c) VALUES (1,'1'), (2,'2'), (3,'3').	For now, just do everything separately."	^false</body><body package="GlorpDatabase" selector="supportsLimit">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^true.</body><body package="GlorpDatabase" selector="supportsTableOwners">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^true</body><body package="GlorpDatabase" selector="typeWithDatabaseName:characterWidth:extraInformation:">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: extraValue	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	extraValue = 'IDENTITY' ifTrue: [^self serialIdentity].	^super typeWithDatabaseName: aString characterWidth: aNumber.</body><body package="GlorpDatabase" selector="useMicrosoftOuterJoins">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins"	^false.</body><body package="GlorpDatabase" selector="usesArrayBindingRatherThanGrouping">usesArrayBindingRatherThanGrouping	"Return true if we use array binding for grouped writes rather than printing the sql multiple times. Only applies if we support grouped writes"	^false.</body><body package="GlorpDatabase" selector="usesIdentityColumns">usesIdentityColumns	^false</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>database-specific</category><body package="GlorpDatabase" selector="compoundOperationFor:">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol"	aSymbol == #INTERSECT ifTrue: [^'WHERE EXISTS'].	aSymbol == #MINUS ifTrue: [^'WHERE NOT EXISTS'].	^aSymbol.</body><body package="GlorpDatabase" selector="printPostLimit:on:">printPostLimit: anInteger on: aCommand		aCommand nextPutAll: ' FETCH FIRST  '.	anInteger printOn: aCommand.	aCommand nextPutAll: ' ROWS ONLY '</body><body package="GlorpDatabase" selector="queryWithUnsupportedOperationsEliminatedFrom:do:">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	| newQuery |	newQuery := aQuery rewriteIntersect.	newQuery := newQuery rewriteExcept.	newQuery == aQuery ifFalse: [aBlock value: newQuery].</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>accessing</category><body package="GlorpDatabase" selector="vwEXDIConnectionClass">vwEXDIConnectionClass	^'DB2Connection' asQualifiedReference valueIfUndefinedLoadFrom: 'DB2EXDI'</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase" selector="booleanToBooleanConverter">booleanToBooleanConverter	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertDBBooleanToBoolean:for:.</body><body package="GlorpDatabase" selector="printBoolean:for:">printBoolean: aBoolean for: aType	"If the platform is MS SQL Server, a boolean object in a SELECT needs to be converted to  BIT type, since T, Y, or true make SQLServer complain. "		| string |	aBoolean isNil ifTrue: [^'NULL'].	"We may be getting passed something that's already 1 or 0, or something else instead of a boolean. That probably shouldn't be happening, but let's handle it gracefully. We define gracefully to mean 1 is true, and everything else is false"	string := (aBoolean == 1 or: [aBoolean = true]) 		ifTrue: ['1'] 		ifFalse: ['0'].	^'CONVERT( BIT, ' , string , ' )'.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>type helpers</category><body package="GlorpDatabase" selector="typesWithValues">typesWithValues	"Return our types list, but makes sure it has at least basic types in it"	self date.	self double.	self int8.	self decimal.	self real.	^super typesWithValues</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>services columns</category><body package="GlorpDatabase" selector="createAlterColumnStatement:newType:usingExpression:">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  ' SET DATA TYPE ';		nextPutAll: aType typeString.	expression ifNotNil: [ sqlStatementStream nextPutAll: ' USING ', expression ].	^sqlStatementStream contents</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>sequences</category><body package="GlorpDatabase" selector="databaseSequenceClass">databaseSequenceClass	"Use the SEQUENCE generator instead of the IDENTITY column mechanism."	^DB2Sequence</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>services constraints</category><body package="GlorpDatabase" selector="createConstraintAddStatement:">createConstraintAddStatement:  aConstraint	| sqlStatementStream |	aConstraint shouldCreateInDatabase ifFalse: [^''].	self supportsConstraints			ifTrue: [sqlStatementStream := WriteStream on: String new.					sqlStatementStream						nextPutAll:  'ALTER TABLE';						space.					self printDDLTableNameFor: aConstraint table on: sqlStatementStream.					(aConstraint creationStringFor: self)						do: [ :each | sqlStatementStream nextPutAll: ' ADD ', each.]						separatedBy: [sqlStatementStream nextPut: Character space].					^sqlStatementStream contents].	^String new</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>functions</category><body package="GlorpDatabase" selector="initializeFunctions">initializeFunctions	"DB2 doesn't allow CAST(date AS timestamp), but it does have a TIMESTAMP function."	| baseExists dbSpecificExists selectList baseNotExists dbSpecificNotExists |	super initializeFunctions.	functions		at: #, put: (InfixFunction named: '+');		at: #timestamp: put: ((PrefixFunction named: 'TIMESTAMP') type: (self timestamp)); "TIMESTAMP(date, time)"		at: #time0 put: ((StandaloneFunction named: 'TIME(''00:00:00'')') type: (self time));		at: #castTo: put: ((PrefixFunction named: 'CAST') separator: ' AS '). "CAST(aThing AS aType)"		"at: #like: put: (InfixFunction named: 'LIKE').		at: #copyFrom:to: put: (SubstringFunction named: 'SUBSTRING');"	"Like Oracle, SQL Server doesn't allow functions like EXISTS in a field list,	but will allow a select there as an argument to a function, such as CASE.	So print it that way if we're in the select list."	baseExists := functions at: #exists:.	dbSpecificExists := DualRoleFunction new.	dbSpecificExists function: '#exists:'.	dbSpecificExists whereClauseVersion: baseExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 1 asGlorpExpression with: 0 asGlorpExpression].	dbSpecificExists selectListVersion: selectList.	dbSpecificExists type: self integer.	functions at: #exists: put: dbSpecificExists.	"And similarly NOT EXISTS"	baseNotExists := functions at: #notExists:.	dbSpecificNotExists := DualRoleFunction new.	dbSpecificNotExists function: '#notExists:'.	dbSpecificNotExists whereClauseVersion: baseNotExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 0 asGlorpExpression with: 1 asGlorpExpression].	dbSpecificNotExists selectListVersion: selectList.	dbSpecificNotExists type: self integer.	functions at: #notExists: put: dbSpecificNotExists.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>services tables</category><body package="GlorpDatabase" selector="printSqlStatementToListTablesInSchema:on:">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Not standardized"	| lowerSchema |	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream nextPutAll: 'SELECT table_name FROM sysibm.tables '.	(lowerSchema notNil and: [lowerSchema notEmpty]) ifTrue:		[aStream			nextPutAll: 'WHERE lower(table_schema) = ';			nextPut: $';			nextPutAll: lowerSchema;			nextPut: $']</body><body package="GlorpDatabase" selector="printSqlStatementToTestExistenceOfTable:inSchema:on:">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	" This query will test only for tables that the logged on user has access to... "	| lowerTableName lowerSchema |	lowerTableName := tableName asLowercase.	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT count(*) FROM sysibm.tables ';		nextPutAll: 'WHERE lower(table_name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $'.	(lowerSchema notNil and: [lowerSchema notEmpty]) ifTrue:		[aStream			nextPutAll: ' AND lower(table_schema) = ';			nextPut: $';			nextPutAll: lowerSchema;			nextPut: $']</body></methods><methods><class-id>Glorp.DB2Platform class</class-id> <category>LICENSE</category><body package="GlorpDatabase" selector="LICENSE">LICENSE	^'Copyright 2000-2004 Alan Knight.This class is part of the GLORP system (see http://www.glorp.org), licensed under the GNU Lesser General Public License, with clarifications with respect to Smalltalk library usage (LGPL(S)). This code is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE . See the package comment, or the COPYING.TXT file that should accompany this distribution, or the GNU Lesser General Public License.'</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>internal</category><body package="GlorpExpressions" selector="named:basedOn:withArguments:">named: aSymbol basedOn: anExpression withArguments: anArray	| right |	outerJoin := false.	relation := self operationFor: aSymbol.	leftChild := anExpression base.	localBase := SubSelectBaseExpression on: anExpression.	right := anArray first.	rightChild := right rebuildOn: localBase startingFrom: anExpression.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="descriptor">descriptor	^self leftChild descriptor.</body><body package="GlorpQueries" selector="initializeQuery">initializeQuery	query := Query		returningManyOf: localBase descriptor describedClass		where: rightChild.	query tablePrefix: ('s', localBase ultimateBaseExpression availableSubSelectNumber printString, 't')."	query baseExpression: localBase."	query session: localBase descriptor session.	localBase descriptor tables do: [:eachTable |		eachTable primaryKeyFields do: [:each | query retrieve: [:base | base getField: each]]].</body><body package="GlorpExpressions" selector="query">query	query isNil ifTrue: [self initializeQuery].	^query.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="addBoundExpressionsIn:to:">addBoundExpressionsIn: aCommand to: boundExpressions	self query prepare.	self query addBoundExpressionsIn: aCommand to: boundExpressions.</body><body package="GlorpDatabase" selector="condensePrimaryKeyComparison">condensePrimaryKeyComparison	"Relies on this having been called after the children are condensed. If the child has had its reference to our base condensed away, then we aren't necessary, the comparison is at the same level and no longer needs a subselect"	^leftChild queryLevelBaseExpression == rightChild queryLevelBaseExpression ifTrue: [rightChild] ifFalse: [self].</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| expression left |	self == anExpression ifTrue: [^aBaseExpression].	"We've swallowed our left child, so we have to unswallow it before rebuilding"	left := localBase trueBase rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	expression := left 		get: relation		withArguments:			(Array				with:					(self rightChildToRebuild rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression)).	self isOuterJoin ifTrue: [expression beOuterJoin].	^expression.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary 	| command toPrint |	toPrint := relation = #noneSatisfy: ifTrue: ['NOT EXISTS ('] ifFalse: [' EXISTS ('].	aStream nextPutAll: toPrint.	command := self query sqlWith: aDictionary.	aStream nextPutAll: command sqlString.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>executing</category><body package="GlorpQueries" selector="executeSubQueries:withParameters:">executeSubQueries: subQueries withParameters: anArray	^self shouldUseSingleQuery		ifTrue: [self executeSubQueriesCombined: subQueries withParameters: anArray]		ifFalse: [self executeSubQueriesIndividually: subQueries withParameters: anArray].</body><body package="GlorpQueries" selector="executeSubQueriesCombined:withParameters:">executeSubQueriesCombined: subQueries withParameters: anArray	"Execute out sub queries as a single query with a UNION ALL between the sub-queries. Then select from the results the one which has a value for that row. Used for horizontal inheritance queries."	| combinedQuery |	combinedQuery := CompoundQuery newUnionAll.	self copyAttributesTo: combinedQuery.	combinedQuery requiresDistinct: false.	subQueries 	do: 	[:eachQuery | 		combinedQuery addQuery: eachQuery].	^combinedQuery executeWithParameters: anArray in: session.</body><body package="GlorpQueries" selector="executeSubQueriesIndividually:withParameters:">executeSubQueriesIndividually: subQueries withParameters: anArray	| result |	result := OrderedCollection new.	subQueries 	do: 	[:eachQuery | 		| individualResult |		individualResult := eachQuery readFromDatabaseWithParameters: anArray.		eachQuery readsOneObject			ifTrue: [individualResult isNil ifFalse: [result add: individualResult]]			ifFalse: [result addAll: individualResult]].	^self readsOneObject ifTrue: [result first] ifFalse: [result].</body><body package="GlorpQueries" selector="readFromDatabaseWithParameters:">readFromDatabaseWithParameters: anArray 	| subQueries |	subQueries := self descriptor classesRequiringIndependentQueries 		collect: [:eachClass | 			self shouldUseSingleQuery 				ifTrue: [self asQueryWithNullsForOtherClasses: eachClass]				ifFalse: [self asSimpleQueryFor: eachClass]].	^self executeSubQueries: subQueries withParameters: anArray.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>accessing</category><body package="GlorpQueries" selector="shouldUseSingleQuery">shouldUseSingleQuery	^self descriptor typeResolver shouldUseSingleQuery.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>converting</category><body package="GlorpQueries" selector="asQueryWithNullsForOtherClasses:">asQueryWithNullsForOtherClasses: aClass	"Construct a specialized form of the query that's set up to retrieve instances of aClass, but with a bunch of empty fields that get populated with nulls, so we can retrieve several different classes at the same go."	| newQuery nullField fieldsToIgnore markerExpression fieldsMinusTheConstant pseudoMappingName newBase tablesToIgnore |	newQuery := self asSimpleQueryFor: aClass.	"We need to rebuild the where clause to refer to one of the subclass pseudo-mappings, because that's what we're retrieving. We don't want it against the actual class we're querying for, because we need the fields to be exactly the same for each of the sub-queries."	pseudoMappingName := self descriptor typeResolver		pseudoAttributeNameForClass: aClass.	newBase := newQuery baseExpression get: pseudoMappingName.	newBase bePhantom.	newQuery where: (newQuery whereClause rebuildOn: newBase).		"We don't want it to try and retrieve the parent class. Instead, we alsoFetch: each of the subclasses, and insert a special builder that will select from among the valid results. To prevent it from trying to do anything with the main class itself, remove that from the tracing, and replace it with a special constant marker that we know will generate only one field, that we can remove later."	newQuery tracing retrievalExpressions remove: newQuery tracing base.	newQuery tracing allTracings remove: newQuery tracing base.	markerExpression := ConstantExpression for: 'ignore me'.	newQuery tracing retrievalExpressions add: markerExpression.	newQuery tracing allTracings add: markerExpression.	newQuery prepare.	newQuery		privateReplaceBuilderWith:			(SelectingElementBuilder new expression: markerExpression).		"For each retrieval that isn't our class, change the fields being returned to nulls, and wrap a cast around them so that SQL doesn't complain. First, we figure out which fields those are."	fieldsToIgnore := IdentityDictionary new.	newQuery tracing alsoFetchExpressions		do:			[:each | 			each mapping referenceClass = aClass				ifFalse:					[each fieldAliases						do: [:eachFieldAlias | fieldsToIgnore at: eachFieldAlias put: each]]].		"Now we remove the constant field we know we caused to be generated earlier, and replace the others that we don't want with nulls"	fieldsMinusTheConstant := newQuery fields		copyFrom: 1		to: newQuery fields size - 1.	newQuery		privateSetFields:			(fieldsMinusTheConstant				collect:					[:eachField | 					(fieldsToIgnore includesKey: eachField)						ifFalse: [eachField]						ifTrue:							[nullField := self nullFieldFor: eachField.							nullField]]).		"Supress all tables except the one(s) we actually want."	newQuery prepare.	tablesToIgnore := (fieldsToIgnore keys collect: [:each | each table]) asSet asArray.	tablesToIgnore := tablesToIgnore, (newQuery baseExpression tablesToPrint).	newQuery tablesToPrint: (newQuery tablesToPrint reject: [:each | tablesToIgnore includes: each]) asArray.		^newQuery.</body><body package="GlorpQueries" selector="asSimpleQueryFor:">asSimpleQueryFor: aClass	| newQuery newCriteria newBase |	"Rebuild the expression, because this means a full query is being split into multiple sub-queries, e.g. for an inheritance read. The expression may get prepared differently in each case (e.g. table aliases), so we can't share"	newBase := BaseExpression new.	newBase descriptor: (session system descriptorFor: aClass).	newCriteria := whereClause rebuildOn: newBase startingFrom: newBase withOuterScopeBase: newBase.	newQuery := SimpleQuery new		initResultClass: aClass		whereClause: newCriteria		singleObject: readsOneObject.	self copyAttributesTo: newQuery.	newQuery session: session.	newQuery setOrdering: ordering.	newQuery groupBy: groupBy.	newQuery setUpExpressions.	newQuery tracing: tracing copy.	^newQuery.</body><body package="GlorpQueries" selector="nullFieldFor:">nullFieldFor: eachField	self platform requiresCastsForNullsInUnions ifFalse: [^(ConstantExpression for: nil) alias: eachField table name, 'nullField', eachField position printString].	^FunctionExpression		for: #cast:		withArguments: (Array with: (ConstantExpression for: eachField type))		basedOn: (ConstantExpression for: nil).</body></methods><methods><class-id>Glorp.GlorpTextType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes" selector="exdiType">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#LargeString.</body></methods><methods><class-id>Glorp.GlorpTextType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="isVariableWidth">isVariableWidth	^true.</body></methods><methods><class-id>Glorp.GlorpTextType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'text'.</body></methods><methods><class-id>Glorp.ConditionalToManyMapping</class-id> <category>conditions</category><body package="GlorpMappings" selector="conditionalField:">conditionalField: aField	self conditional conditionalField: aField.</body><body package="GlorpMappings" selector="conditionalMethod:">conditionalMethod: aSymbol	self conditional conditionalMethod: aSymbol.</body><body package="GlorpMappings" selector="forField:attribute:if:useMapping:">forField: aField attribute: attributeBlock if: testBlock useMapping: aMapping	self conditionalField: aField.	self conditionalMethod: attributeBlock.	self if: testBlock then: aMapping.</body><body package="GlorpMappings" selector="if:then:">if: conditionSelector then: aMapping	self conditional if: conditionSelector then: aMapping.</body><body package="GlorpMappings" selector="otherwise:">otherwise: aMapping	self conditional otherwise: aMapping.</body></methods><methods><class-id>Glorp.ConditionalToManyMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="conditional">conditional	conditional isNil ifTrue: [conditional := self newMapping: ConditionalMapping].	^conditional.</body><body package="GlorpMappings" selector="conditional:">conditional: anObject	conditional := anObject</body><body package="GlorpMappings" selector="mappedFields">mappedFields	^self conditional mappedFields</body><body package="GlorpMappings" selector="newMapping:">newMapping: aMappingClass	"Implement this so that we can create our sub-mappings without having them added to the parent descriptor as independent mappings"	| mapping |	mapping := aMappingClass new.	mapping descriptor: self descriptor.	descriptor resetMappedFields.	^mapping.</body></methods><methods><class-id>Glorp.ConditionalToManyMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="applicableMappingForObject:">applicableMappingForObject: anObject	"We can actually be called here with our parent object, but the contexts in which that happens we basically just want to do nothing, so return our conditional mapping."	[self attribute checkTargetType: anObject] on: GlorpInvalidTypeError do: [:ex | ^self conditional].	^self conditional applicableMappingForObject: anObject.</body><body package="GlorpMappings" selector="applicableMappingForRow:in:">applicableMappingForRow: anArray in: anElementBuilder	^self conditional applicableMappingForRow: anArray in: anElementBuilder.</body><body package="GlorpMappings" selector="buildQuery">buildQuery	query := CompositeQuery new.	self conditional casesDo: [:each |		query addQuery: each query].	^query</body><body package="GlorpMappings" selector="mapOneFromObject:toTarget:intermediate:atPosition:puttingRowsIn:">mapOneFromObject: sourceObject toTarget: targetObject intermediate: aRowMapKey atPosition: index puttingRowsIn: aRowMap		(self applicableMappingForObject: targetObject) mapOneFromObject:			sourceObject toTarget: targetObject intermediate: aRowMapKey atPosition:			index puttingRowsIn: aRowMap.</body><body package="GlorpMappings" selector="parametersIn:">parametersIn: anElementBuilder	| parameters |	self shouldUseFilteredRead ifTrue: [^anElementBuilder command parameters].	parameters := IdentityDictionary new.	self conditional casesDo: [:each |		each join mappableSourceFieldsDo:			[:eachSource | parameters at: eachSource put: (anElementBuilder valueOfField: eachSource)]].	^parameters.</body><body package="GlorpMappings" selector="rowMapKeyForSource:target:index:">rowMapKeyForSource: source target: target index: index	^(self applicableMappingForObject: target) rowMapKeyForSource: source target: target index: index.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>accessing</category><body package="GlorpExpressions" selector="alias">alias	^alias</body><body package="GlorpExpressions" selector="alias:">alias: aString	"What column name, if anything, should we print for 'as X' when retrieving"	alias := aString</body><body package="GlorpExpressions" selector="base">base	^base.</body><body package="GlorpExpressions" selector="basicField">basicField	^field.</body><body package="GlorpExpressions" selector="canHaveBase">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions" selector="converterForStType:">converterForStType: aClass	^self field converterForStType: aClass.</body><body package="GlorpExpressions" selector="field">field	^base translateField: field</body><body package="GlorpExpressions" selector="fieldExpression">fieldExpression	^self.</body><body package="GlorpExpressions" selector="impliedSmalltalkType">impliedSmalltalkType	^self field impliedSmalltalkType.</body><body package="GlorpExpressions" selector="name">name	^field name.</body><body package="GlorpExpressions" selector="table">table	^self field table.</body><body package="GlorpExpressions" selector="type">type	^self field type.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>navigating</category><body package="GlorpExpressions" selector="queryLevelBaseExpression">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions" selector="ultimateBaseExpression">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>printing</category><body package="GlorpExpressions" selector="printOnlySelfOn:">printOnlySelfOn: aStream 	base printsTable		ifTrue: [field printUnqualifiedSQLOn: aStream withParameters: #()]		ifFalse: [field printSQLOn: aStream withParameters: #()]</body><body package="GlorpExpressions" selector="printTreeOn:">printTreeOn: aStream 	base printOn: aStream.	aStream nextPut: $..	base printsTable 		ifTrue: [field printUnqualifiedSQLOn: aStream withParameters: #()]		ifFalse: [field printSQLOn: aStream withParameters: #()]</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions" selector="convertedDbValueOf:">convertedDbValueOf: anObject	"We don't do any conversion"	^anObject</body><body package="GlorpExpressions" selector="rebuildOn:startingFrom:withOuterScopeBase:">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| result |	self == anExpression ifTrue: [^aBaseExpression].	result := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) getField: field.	result alias: self alias.	^result.</body><body package="GlorpExpressions" selector="tableForANSIJoin">tableForANSIJoin	^self field table.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions" selector="printSelectSQLOn:withParameters:">printSelectSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters:aDictionary.	alias notNil ifTrue: [aStream nextPutAll: ' AS '; nextPutAll: alias].</body><body package="GlorpExpressions" selector="printSQLOn:withParameters:">printSQLOn: aStream withParameters: aDictionary	self field printSQLOn: aStream withParameters:aDictionary.</body><body package="GlorpExpressions" selector="printUnqualifiedSQLOn:withParameters:">printUnqualifiedSQLOn: aStream withParameters: aDictionary	self field printUnqualifiedSQLOn: aStream withParameters:aDictionary.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>initializing</category><body package="GlorpExpressions" selector="field:base:">field: aField base: anObjectExpression	field := aField.	base := anObjectExpression.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>preparing</category><body package="GlorpExpressions" selector="asExpressionJoiningSource:toTarget:">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newTarget |	newTarget := (target allControlledTables includes: field table) 		ifTrue: [target]		ifFalse: [base asExpressionJoiningSource: source toTarget: target].	^newTarget getField: field.</body><body package="GlorpExpressions" selector="tables">tables	^base tables.</body><body package="GlorpExpressions" selector="tablesToPrint">tablesToPrint	^Array with: self table</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>iterating</category><body package="GlorpExpressions" selector="do:skipping:">do: aBlock skipping: aSet	"Iterate over the expression tree"	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>api</category><body package="GlorpExpressions" selector="get:withArguments:">get: aSymbol withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	anArray isEmpty ifTrue: [self error: 'Field expressions do not have attributes'].	^RelationExpression named: aSymbol basedOn: self withArguments: anArray.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>testing</category><body package="GlorpExpressions" selector="canBeUsedForRetrieve">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^true.</body><body package="GlorpExpressions" selector="hasField">hasField	^true.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>copying</category><body package="GlorpExpressions" selector="setTable:">setTable: aTable	"Modify (do not copy) ourselves to use aTable. Presumably aTable is an aliased version of our table"	field := field withTable: aTable.</body><body package="GlorpExpressions" selector="withTable:">withTable: aTable	"Modify (do not copy) ourselves to use aTable. Presumably aTable is an aliased version of our table"	field := field withTable: aTable.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>mapping</category><body package="GlorpExpressions" selector="mappedFields">mappedFields	^Array with: self field.</body><body package="GlorpExpressions" selector="valueInBuilder:">valueInBuilder: anElementBuilder	^self valueInBuilder: anElementBuilder as: self field.</body><body package="GlorpExpressions" selector="valueInBuilder:as:">valueInBuilder: anElementBuilder as: anExpression	^anElementBuilder valueOfField: anExpression.</body></methods><methods><class-id>Glorp.FieldExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions" selector="forField:basedOn:">forField: aField basedOn: anObjectExpression	^self new field: aField base: anObjectExpression; yourself</body></methods><methods><class-id>Glorp.GlorpDatabaseTypesPackage class</class-id> <category>instance creation</category><body package="GlorpDatabaseTypes" selector="LICENSE">LICENSE"LGPL(S)The code is Copyright (C) 2000-2010  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA"</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>accessing</category><body package="GlorpDatabase" selector="name:">name: aString	name := aString copyFrom: 1 to: (aString size min: DB2Platform new maximumLengthOfTableName).</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>private</category><body package="GlorpCore" selector="backupReserveCommand:in:">backupReserveCommand: anInteger in: aSession	"syscat.tables is a public view of all the tables.	Don't bind the number in the fetch first nn clause."	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select next value for '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: ' from SYSCAT.TABLES'.	stream nextPutAll: ' fetch first '.	stream nextPutAll: anInteger printString.	stream nextPutAll: ' rows only'.	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body><body package="GlorpDatabase" selector="nextSequenceNumberSelectString">nextSequenceNumberSelectString	"Using SYSIBM is not ideal because it's supposed to be internal, but it seems to be accepted."	^'SELECT NEXT VALUE FOR ' , self qualifiedName , ' FROM SYSIBM.SYSDUMMY1'</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>public</category><body package="GlorpDatabase" selector="creationString">creationString	^'create sequence ', self qualifiedName.</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>SQL</category><body package="GlorpCore" selector="tableSelectCommandFor:in:reserving:">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Don't bind the number in the fetch first nn clause."	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select next value for '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: ' from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' fetch first '.			stream nextPutAll: anInteger printString.			stream nextPutAll: ' rows only'.			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.Login</class-id> <category>accessing</category><body package="GlorpDatabase" selector="=">= aLogin 	^self class == aLogin class and: 			[self name = aLogin name and: 					[self database class = aLogin database class and: 							[self username = aLogin username and: 									[self connectString = aLogin connectString]]]]</body><body package="GlorpDatabase" selector="connectString">connectString	^connectString</body><body package="GlorpDatabase" selector="connectString:">connectString: aString 	connectString := aString</body><body package="GlorpDatabase" selector="database">database	^database</body><body package="GlorpDatabase" selector="database:">database: aDatabasePlatform 	database := aDatabasePlatform</body><body package="GlorpDatabase" selector="hash">hash	^self name hash + self database class hash + self username hash + self connectString hash</body><body package="GlorpDatabase" selector="name">name	name isNil ifTrue: [^self connectString] ifFalse: [^name].</body><body package="GlorpDatabase" selector="name:">name: aString	name := aString.</body><body package="GlorpDatabase" selector="password">password	"Return the password for this login. If we are in a secure mode, then erase the password as soon as it is accessed."	| returnValue |	returnValue := password.	secure ifTrue: [password := nil].	^returnValue.</body><body package="GlorpDatabase" selector="password:">password: aString 	password := aString</body><body package="GlorpDatabase" selector="platform">platform	^self database.</body><body package="GlorpDatabase" selector="schema">schema	^schema</body><body package="GlorpDatabase" selector="schema:">schema: aString	schema := aString.</body><body package="GlorpDatabase" selector="secure">secure	^secure</body><body package="GlorpDatabase" selector="secure:">secure: aBoolean	secure := aBoolean</body><body package="GlorpDatabase" selector="username">username	^username</body><body package="GlorpDatabase" selector="username:">username: aString 	username := aString</body></methods><methods><class-id>Glorp.Login</class-id> <category>printing</category><body package="GlorpDatabase" selector="printOn:">printOn: aStream	aStream nextPutAll: 'a Login('.	database printOn: aStream.	aStream nextPutAll: ', '.	username printOn: aStream.	aStream nextPutAll: ', '.	connectString printOn: aStream.	aStream nextPutAll: ', '.	schema printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.Login</class-id> <category>session creation</category><body package="GlorpDatabase" selector="sessionForDescriptorSystem:">sessionForDescriptorSystem: aDescriptorSystemClass	"Create a session for this login, using aDescriptorSystemClass for its metadata"	^aDescriptorSystemClass sessionForLogin: self.</body></methods><methods><class-id>Glorp.Login</class-id> <category>initialize-release</category><body package="GlorpDatabase" selector="initialize">initialize	secure := true.</body></methods><methods><class-id>Glorp.Login class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="new">new	^super new initialize.</body></methods><methods><class-id>Glorp.TimedStrongCachePolicy</class-id> <category>initialize</category><body package="GlorpCore" selector="initialize">initialize	super initialize.	timeout := 300.</body></methods><methods><class-id>Glorp.TimedStrongCachePolicy</class-id> <category>wrap/unwrap</category><body package="GlorpCore" selector="cacheEntryFor:">cacheEntryFor: anObject	^Array with: self totalSeconds with: anObject.</body><body package="GlorpCore" selector="contentsOf:">contentsOf: aCacheEntry	^aCacheEntry at: 2.</body><body package="GlorpCore" selector="expire:">expire: aCacheEntry	^aCacheEntry at: 1 put: 0.</body><body package="GlorpCore" selector="hasExpired:">hasExpired: aCacheEntry	^(self totalSeconds - (aCacheEntry at: 1)) &gt;= timeout.</body><body package="GlorpCore" selector="markEntryAsCurrent:in:">markEntryAsCurrent: aCacheEntry in: aCache	aCacheEntry at: 1 put: self totalSeconds.</body></methods><methods><class-id>Glorp.TimedStrongCachePolicy</class-id> <category>accessing</category><body package="GlorpCore" selector="timeout">timeout	^timeout</body><body package="GlorpCore" selector="timeout:">timeout: seconds	timeout := seconds</body><body package="GlorpCore" selector="timeoutSeconds">timeoutSeconds	^timeout</body><body package="GlorpCore" selector="timeoutSeconds:">timeoutSeconds: anInteger	timeout := anInteger.</body></methods><methods><class-id>Glorp.TimedStrongCachePolicy</class-id> <category>utility</category><body package="GlorpCore" selector="totalSeconds">totalSeconds	^Dialect totalSeconds.</body></methods><methods><class-id>Glorp.SelectingElementBuilder</class-id> <category>building objects</category><body package="GlorpQueries" selector="buildObjectFrom:">buildObjectFrom: anArray	^self.</body><body package="GlorpQueries" selector="findInstanceForRow:proxyType:">findInstanceForRow: aRow proxyType: proxyType	^self.</body><body package="GlorpQueries" selector="returnValueIn:">returnValueIn: aCursoredStream	| builder |	builder := aCursoredStream privateGetBuilders		detect:			[:each | 			each instance notNil				and: [each expression ~~ aCursoredStream command query baseExpression]]		ifNone:			[self error: 'Internal error in computing horizontal inheritance query.'].	^builder instance.</body></methods><methods><class-id>Glorp.SelectingElementBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries" selector="fieldsForSelectStatement">fieldsForSelectStatement	^#().</body><body package="GlorpQueries" selector="fieldsFromMyPerspective">fieldsFromMyPerspective	^#().</body></methods><methods><class-id>Glorp.IdentityTypeMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="mappedFields">mappedFields	^#()</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	"do nothing"</body></methods><methods><class-id>Glorp.IdentityTypeMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="canBeTypeMappingParent">canBeTypeMappingParent	^false</body><body package="GlorpMappings" selector="isAbstract">isAbstract	^false</body><body package="GlorpMappings" selector="isTypeMappingRoot">isTypeMappingRoot	^true</body></methods><methods><class-id>Glorp.SQLite3Sequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body><body package="GlorpDatabase" selector="name:">name: aString	"We ignore names"</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor		| value |	value := anAccessor connection isNil ifTrue: [nil] ifFalse: [anAccessor connection lastAutoIncrementValue asInteger].	aDatabaseRow at: aDatabaseField put: value</body><body package="GlorpDatabase" selector="reserveSequenceNumbers:in:for:">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body><body package="GlorpDatabase" selector="schema:">schema: aString	"This is SQLite - we don't have schemas"</body></methods><methods><class-id>Glorp.SQLite3Sequence</class-id> <category>testing</category><body package="GlorpDatabase" selector="isIdentityColumn">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="attributeName:">attributeName: anAttributeName	^self attributeName: anAttributeName referenceClass: nil.</body><body package="GlorpMappings" selector="attributeName:referenceClass:">attributeName: anAttributeName referenceClass: aClass	"In addition to setting the attribute, use that information to further configure our faked-up descriptor. We can pass in a reference class here, although this is only really useful if we don't already have an explicit classModel."	| model |	super attributeName: anAttributeName.	aClass isNil ifFalse: [attribute type: aClass].	model := GlorpClassModel for: super referenceClass.	"We add a mapping for our value. We don't normally use this, because we expect people to refer directly to the attribute, but it means, for example, that the field shows up in our mapped fields without us having to fake it up. And you could write a query referring to anAttribute myValue if you wanted"	model newAttributeNamed: #myValue type: self attribute type.	self referenceDescriptor classModel: model.</body><body package="GlorpMappings" selector="buildQuery">buildQuery	query := super buildQuery.	query retrieve: [:x | x getField: resultField].	^query.</body><body package="GlorpMappings" selector="descriptor:">descriptor: aDescriptor	super descriptor: aDescriptor.	aDescriptor system privateAndBasicAddDescriptorFor: self as: self pseudoDescriptor.</body><body package="GlorpMappings" selector="field">field	^resultField.</body><body package="GlorpMappings" selector="join:">join: aJoin	"In addition to setting up the join, use that information to configure our faked up descriptor"	| tables |	super join: aJoin.	tables := self targetTables asArray.	tables size &gt; 1		ifTrue: [self error: 'Cannot have multiple tables for a direct toMany'].	self referenceDescriptor table: tables first.	"We add a mapping for our value. We don't normally use this, because we expect people to refer directly to the attribute, but it means, for example, that the field shows up in our mapped fields without us having to fake it up. And you could write a query referring to anAttribute myValue if you wanted"	(self referenceDescriptor newMapping: DirectMapping) 		from: #myValue to: resultField.</body><body package="GlorpMappings" selector="referenceClass">referenceClass	"Return ourselves as the reference class, as a sort of a proxy for what we really want, which is a primitive, and varies according to the relationship anyway. Note that we have stuffed in a descriptor in the system, with ourselves (this instance) as the class."	^self.</body><body package="GlorpMappings" selector="resultField">resultField	^resultField.</body><body package="GlorpMappings" selector="resultField:">resultField: aField	resultField := aField.</body><body package="GlorpMappings" selector="writeExtraInformationInto:atKey:forSourceObject:targetObject:atIndex:">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject atIndex: index	super		writeExtraInformationInto: aRowMap		atKey: rowMapKey		forSourceObject: sourceObject		targetObject: targetObject		atIndex: index.	aRowMap		at: self resultField		key: rowMapKey		put: targetObject.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="buildRowMapKeyForSource:target:index:">buildRowMapKeyForSource: source target: target index: index	"What should this do??? We want to distinguish the entries in e.g. # (1 2 3 3 4 3 5). Or do we? They aren't distinguishable in the DB. Does that mean we always want to write the order field? Or what? What if this is a set in memory. Then we really can't have two entries"	^MultipleRowMapKey		with: target yourSelf		with: source yourSelf		with: index.</body><body package="GlorpMappings" selector="pseudoDescriptor">pseudoDescriptor	"Return a pretend descriptor for our reference class. Since that class is a primitive, it won't have a real descriptor, and it may vary by usage anyway"	| pseudoDescriptor |	pseudoDescriptor := Descriptor new.	pseudoDescriptor system: descriptor system.	^pseudoDescriptor.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="glorpCanHaveDescriptorDirectly">glorpCanHaveDescriptorDirectly	"We allow instances of ourselves to have a descriptor, which normally only classes can do. This is so that we can have multiple different descriptors in use for e.g. String, depending on the particular usage."	^true.</body><body package="GlorpMappings" selector="mapsSimpleObject">mapsSimpleObject	^true.</body><body package="GlorpMappings" selector="needsSpecialRowMapKey">needsSpecialRowMapKey	"Return true if we have to use a special key object for the row map, rather than just our target. We always do, because our target may not have identity."	^true.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>converting</category><body package="GlorpMappings" selector="convertedDbValueOf:">convertedDbValueOf: anObject	"It may be that we need to introduce a converter here, the same as with a regular direct mapping"	^anObject.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validate">validate	super validate.	"We have to write the order field. Otherwise, we get confused e.g. on deletion, because we don't have a way of telling the rows in the rowmap apart when the indexes have changed"	(self readOnly not and: [shouldWriteTheOrderField not]) ifTrue: [self error: 'To-many mappings to simple types must write an order field so that we have some way to tell the rows apart'].	"If we're for a pseudo-variable, we're neither reading nor writing, so we don''t need the order."	self isForPseudoVariable ifTrue: [^self].	orderBy isNil ifTrue: [self error: 'To-many mappings to simple types must specify and write an order field so that we have some way to tell the rows apart'].</body></methods><methods><class-id>Glorp.DynamicDescriptorSystem</class-id> <category>accessing</category><body package="GlorpMappings" selector="addEmptyDescriptorFor:">addEmptyDescriptorFor: aClass 	| descriptor |	descriptor := Descriptor new.	descriptor system: self.	self privateDescriptorAt: aClass put: descriptor.	descriptor classModel: (self classModelFor: aClass).	^descriptor</body><body package="GlorpMappings" selector="addEmptyTableNamed:">addEmptyTableNamed: aString 	| table |	table := self databaseTableClass named: aString.	self privateTableAt: aString put: table.	^table</body><body package="GlorpMappings" selector="allClasses">allClasses	^descriptors keys</body><body package="GlorpMappings" selector="allTableNames">allTableNames	^tables keys</body><body package="GlorpMappings" selector="attributeNameToFieldNameBlock:">attributeNameToFieldNameBlock: aBlock	attributeNameToFieldNameBlock := aBlock</body><body package="GlorpMappings" selector="initializeClassModel:">initializeClassModel: aClassModel	"Assume we'll initialize it either before or after this"</body></methods><methods><class-id>Glorp.DynamicDescriptorSystem</class-id> <category>private</category><body package="GlorpMappings" selector="privateDescriptorAt:put:">privateDescriptorAt: aClass put: aDescriptor	"Normally you don't want to be setting tables explicitly, as it may defeat the identity management but it's here if needed"	descriptors at: aClass put: aDescriptor.</body><body package="GlorpMappings" selector="privateTableAt:put:">privateTableAt: aString put: aTable	"Normally you don't want to be setting tables explicitly, as it may defeat the identity management but it's here if needed"	tables at: aString asUppercase put: aTable.</body></methods><methods><class-id>Glorp.DynamicDescriptorSystem</class-id> <category>hooks</category><body package="GlorpMappings" selector="fieldNameForAttributeName:">fieldNameForAttributeName: aSymbol 	attributeNameToFieldNameBlock isNil  		ifTrue: [^super fieldNameForAttributeName: aSymbol].	^attributeNameToFieldNameBlock value: aSymbol</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>mapping</category><body package="GlorpMappings" selector="applicableMappingForConditionalValue:">applicableMappingForConditionalValue: rowValue	cases		do:			[:each | 			((Dialect isBlock: each key)				ifTrue: [each key value: rowValue]				ifFalse: [self descriptor system perform: each key with: rowValue])				ifTrue: [^each value]].	^otherwiseCase.</body><body package="GlorpMappings" selector="applicableMappingForObject:">applicableMappingForObject: anObject	| conditionalValue |	conditionalValue := self conditionalValueFor: anObject.	^self applicableMappingForConditionalValue: conditionalValue.</body><body package="GlorpMappings" selector="applicableMappingForRow:in:">applicableMappingForRow: anArray in: anElementBuilder	"If a conditional field has been specified, then pass in the extracted value. Otherwise pass in the whole row"	| rowValue |	rowValue := conditionalField isNil		ifFalse: [anElementBuilder valueOfField: conditionalField in: anArray]		ifTrue: [anArray].	^self applicableMappingForConditionalValue: rowValue.</body><body package="GlorpMappings" selector="conditionalValueFor:">conditionalValueFor: anObject	^(Dialect isBlock: conditionalMethod)		ifTrue: [conditionalMethod value: anObject]		ifFalse: [anObject perform: conditionalMethod].</body><body package="GlorpMappings" selector="mapFromObject:intoRowsIn:">mapFromObject: anObject intoRowsIn: aRowMap 	self canWrite ifFalse: [^self].	(self applicableMappingForObject: anObject) 		mapFromObject: anObject		intoRowsIn: aRowMap.	conditionalFieldMapping isNil ifTrue: [^self].	conditionalFieldMapping 		mapFromObject: (self conditionalValueFor: anObject)		intoRowsIn: aRowMap</body><body package="GlorpMappings" selector="mapObject:inElementBuilder:">mapObject: anObject inElementBuilder: anElementBuilder	(self applicableMappingForRow: anElementBuilder row in: anElementBuilder)		mapObject: anObject		inElementBuilder: anElementBuilder.</body><body package="GlorpMappings" selector="newMapping:">newMapping: aMappingClass	"Implement this so that we can create our sub-mappings without having them added to the parent descriptor as independent mappings"	| mapping |	mapping := aMappingClass new.	mapping descriptor: self descriptor.	descriptor resetMappedFields.	^mapping.</body><body package="GlorpMappings" selector="referencedIndependentObjectsFrom:">referencedIndependentObjectsFrom: anObject	| allReferencedObjects |	allReferencedObjects := OrderedCollection new.	cases do: [:each | 		allReferencedObjects addAll: (each value referencedIndependentObjectsFrom: anObject)].	^allReferencedObjects.</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>initialize/release</category><body package="GlorpMappings" selector="initialize">initialize		super initialize.	cases := OrderedCollection new.</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>accessing</category><body package="GlorpMappings" selector="attributeName">attributeName	^self representativeMapping attributeName.</body><body package="GlorpMappings" selector="cases">cases	^cases.</body><body package="GlorpMappings" selector="casesDo:">casesDo: aBlock	"Iterate over all of our cases"	cases do: [:each | aBlock value: each value].	aBlock value: otherwiseCase.</body><body package="GlorpMappings" selector="conditionalField:">conditionalField: aField	(conditionalField notNil and: [conditionalField ~~ aField]) ifTrue: [self error: 'You can only test one field in a conditional mapping'].	conditionalField := aField.</body><body package="GlorpMappings" selector="conditionalFieldMapping">conditionalFieldMapping	^conditionalFieldMapping</body><body package="GlorpMappings" selector="conditionalFieldMapping:">conditionalFieldMapping: aMapping	"This is a write-only mapping for the conditional field value, which writes out the result of performing the conditional method"	conditionalFieldMapping := aMapping.	descriptor isNil ifFalse: [aMapping descriptor: descriptor].	(descriptor mappings includes: aMapping) ifTrue: [self error: 'Mapping is part of a conditional and part of the main descriptor. Be sure to send newMapping: to the conditional, not to the descriptor'].</body><body package="GlorpMappings" selector="conditionalMethod:">conditionalMethod: aSymbol	(conditionalMethod notNil and: [conditionalMethod ~~ aSymbol]) ifTrue: [self error: 'You can only test one attribute in a conditional mapping'].	conditionalMethod := aSymbol.</body><body package="GlorpMappings" selector="descriptor:">descriptor: aDescriptor	super descriptor: aDescriptor.	cases do: [:each | each value descriptor: aDescriptor].	otherwiseCase isNil ifFalse: [otherwiseCase descriptor: aDescriptor].	conditionalFieldMapping isNil ifFalse: [conditionalFieldMapping descriptor: aDescriptor].</body><body package="GlorpMappings" selector="field">field	^self mappedFields asArray first.</body><body package="GlorpMappings" selector="mappedFields">mappedFields	| all |	all := Set new.	conditionalFieldMapping isNil 		ifTrue: [all add: conditionalField]		ifFalse: [all addAll: conditionalFieldMapping mappedFields].	cases do: [:each |		all addAll: each value mappedFields].	^all.</body><body package="GlorpMappings" selector="otherwise">otherwise	^otherwiseCase.</body><body package="GlorpMappings" selector="referenceClass">referenceClass	^self representativeMapping referenceClass.</body><body package="GlorpMappings" selector="representativeMapping">representativeMapping	"At some points we may need to have this mapping behave some way without knowing yet which of its cases is satisfied. We assume that there is some basic level of similarity so that we can use one mapping as a representative to discover, e.g. what the reference class is. This works all right for cases where we have a mapping or a constant. It wouldn't work very well if we have a one to one mapping to one class in case (a) but a many-many to an entirely different class in the other"	^cases first value.</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>conditions</category><body package="GlorpMappings" selector="forField:attribute:if:useMapping:">forField: aField attribute: attributeBlock if: testBlock useMapping: aMapping	self conditionalField: aField.	self conditionalMethod: attributeBlock.	self if: testBlock then: aMapping.</body><body package="GlorpMappings" selector="if:then:">if: conditionSelector then: aMapping	cases add: (Association key: conditionSelector value: aMapping).	descriptor isNil ifFalse: [aMapping descriptor: descriptor].	(descriptor mappings includes: aMapping) ifTrue: [self error: 'Mapping is part of a conditional and part of the main descriptor. Be sure to send newMapping: to the conditional, not to the descriptor'].</body><body package="GlorpMappings" selector="otherwise:">otherwise: aMapping	otherwiseCase := aMapping.	descriptor isNil ifFalse: [otherwiseCase descriptor: descriptor].	(descriptor mappings includes: aMapping) ifTrue: [self error: 'Mapping is part of a conditional and part of the main descriptor. Be sure to send newMapping: to the conditional, not to the descriptor'].</body><body package="GlorpMappings" selector="trace:context:">trace: aTracing context: anExpression	"To make a join, we need to look at all of our possible cases"	conditionalFieldMapping isNil ifFalse: [		conditionalFieldMapping trace: aTracing context: anExpression].	cases do: [:each |		each value trace: aTracing context: anExpression].</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>testing</category><body package="GlorpMappings" selector="controlsTables">controlsTables	^self cases first value controlsTables.</body><body package="GlorpMappings" selector="hasField">hasField	^self mappedFields size = 1.</body><body package="GlorpMappings" selector="isRelationship">isRelationship	^false</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>validation</category><body package="GlorpMappings" selector="validateAttribute">validateAttribute	cases do: [:each | each value validateAttribute].	otherwiseCase validateAttribute.	conditionalFieldMapping isNil ifFalse: [conditionalFieldMapping validateAttribute].</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>preparing</category><body package="GlorpMappings" selector="joinExpressionFor:">joinExpressionFor: anExpression	^self representativeMapping joinExpressionFor: anExpression.</body></methods><methods><class-id>Glorp.DataElementBuilder</class-id> <category>building objects</category><body package="GlorpQueries" selector="buildObjectFrom:">buildObjectFrom: anArray	self row: anArray.	instance := self valueOf: expression.</body><body package="GlorpQueries" selector="didValidationFail:">didValidationFail: validateResult	"In other words, don't treat the result of the validation send to the object as a failure if the object was the boolean false, so returning self would normally be interpreted as the failure"	validateResult == self instance ifTrue: [^false].	^super didValidationFail: validateResult.</body><body package="GlorpQueries" selector="findInstanceForRow:proxyType:">findInstanceForRow: aRow proxyType: proxyType	^self.</body></methods><methods><class-id>Glorp.DataElementBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries" selector="fieldsForSelectStatement">fieldsForSelectStatement	^Array with: expression.</body><body package="GlorpQueries" selector="fieldsFromMyPerspective">fieldsFromMyPerspective	^expression mappedFields.</body></methods><methods><class-id>Glorp.GlorpPreparedStatement</class-id> <category>accessing</category><body package="GlorpDatabase" selector="busy">busy	^busy.</body><body package="GlorpDatabase" selector="busy:">busy: aBoolean	busy := aBoolean.</body><body package="GlorpDatabase" selector="signature">signature	^signature</body><body package="GlorpDatabase" selector="signature:">signature: aString	signature := aString</body><body package="GlorpDatabase" selector="statement">statement	^statement</body><body package="GlorpDatabase" selector="statement:">statement: aStatementHandle	statement := aStatementHandle</body></methods><methods><class-id>Glorp.GlorpPreparedStatement</class-id> <category>initialize-release</category><body package="GlorpDatabase" selector="initialize">initialize	busy := false.</body></methods><methods><class-id>Glorp.GlorpPreparedStatement</class-id> <category>As yet unclassified</category><body package="GlorpDatabase" selector="glorpNoticeOfExpiryIn:">glorpNoticeOfExpiryIn: aSession	self release.</body><body package="GlorpDatabase" selector="release">release	super release.	statement isNil ifFalse: [		| stmt |		stmt := statement.		statement := nil.		stmt disconnect].</body></methods><methods><class-id>Glorp.GlorpPreparedStatement class</class-id> <category>instance creation</category><body package="GlorpDatabase" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.PluggableDatabaseConverter</class-id> <category>converting</category><body package="GlorpDatabase" selector="convert:fromDatabaseRepresentationAs:">convert: anObject fromDatabaseRepresentationAs: aDatabaseType 	^dbToSt isNil ifTrue: [anObject] ifFalse: [dbToSt value: anObject]</body><body package="GlorpDatabase" selector="convert:toDatabaseRepresentationAs:">convert: anObject toDatabaseRepresentationAs: aDatabaseType 	^stToDb isNil ifTrue: [anObject] ifFalse: [stToDb value: anObject]</body></methods><methods><class-id>Glorp.PluggableDatabaseConverter</class-id> <category>accessing</category><body package="GlorpDatabase" selector="dbToStConverter:">dbToStConverter: aBlock	dbToSt := aBlock.</body><body package="GlorpDatabase" selector="stToDbConverter:">stToDbConverter: aBlock	stToDb := aBlock.</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>testing</category><body package="GlorpDatabaseTypes" selector="isVariableWidth">isVariableWidth	"Return true if this type allows varying length data within a particular instance. e.g., this is true for a varchar, but false for a fixed size character field"	^true.</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes" selector="initialize">initialize	super initialize.	typeString := 'varchar'.</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes" selector="typeString">typeString		^self typeName,   ( width ifNil: [''] ifNotNil: [ :w |'(', w printString, ')'])</body></methods><methods><class-id>Glorp.DB2IdentitySequence</class-id> <category>SQL</category><body package="GlorpDatabase" selector="reserveSequenceNumbers:in:for:">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body></methods><methods><class-id>Glorp.DB2IdentitySequence</class-id> <category>sequencing</category><body package="GlorpDatabase" selector="getSequenceValueFromDatabaseFor:in:using:">getSequenceValueFromDatabaseFor: aDatabaseField in: aDatabaseRow using: anAccessor	"I do nothing, but I am here for subclassResponsibility reasons"</body><body package="GlorpDatabase" selector="postWriteAssignSequenceValueFor:in:using:">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor 	aDatabaseRow at: aDatabaseField		put: (((anAccessor 				executeSQLString: 'VALUES IDENTITY_VAL_LOCAL()') first atIndex: 1) asInteger).</body></methods><methods><class-id>Glorp.DB2IdentitySequence</class-id> <category>testing</category><body package="GlorpDatabase" selector="isIdentityColumn">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>api</category><body package="GlorpQueries" selector="getValue">getValue	self isInstantiated ifTrue: [^value].	[value := readBlock value] ensure: [isInstantiated := true].	^value</body><body package="GlorpQueries" selector="glorpReadBlock:">glorpReadBlock: aZeroArgumentBlock	readBlock := aZeroArgumentBlock</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>printing</category><body package="GlorpQueries" selector="printOn:">printOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue printOn: aStream]		ifFalse: [aStream nextPutAll: 'uninstantiated AdHocProxy'].	aStream nextPut: $}</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>initialize</category><body package="GlorpQueries" selector="proxyInitialize">proxyInitialize	super proxyInitialize.	readBlock := [nil]</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>accessing</category><body package="GlorpQueries" selector="class">class	^AdHocProxy</body></methods><methods><class-id>Glorp.AdHocProxy class</class-id> <category>instance creation</category><body package="GlorpQueries" selector="readBlock:">readBlock: aZeroArgumentBlock	^self new glorpReadBlock: aZeroArgumentBlock</body></methods><methods><class-id>ProtoObject</class-id> <category>doesNotUnderstand</category><body package="GlorpQueries" selector="asGlorpExpression">asGlorpExpression	^GlorpHelper glorpConstantExpressionClass for: self.</body><body package="GlorpQueries" selector="asGlorpExpressionOn:">asGlorpExpressionOn: anExpression	^self asGlorpExpression.</body><body package="GlorpQueries" selector="asGlorpExpressionOn:basedOn:withUltimateBase:">asGlorpExpressionOn: anExpression basedOn: aMessageArchiver withUltimateBase: aBaseExpression	^self asGlorpExpression.</body></methods><methods><class-id>ProtoObject</class-id> <category>testing</category><body package="GlorpQueries" selector="isGlorpExpression">isGlorpExpression	^false.</body></methods><methods><class-id>ProtoObject</class-id> <category>doesNotUnderstand</category><body package="GlorpQueries" selector="isGlorpProxy">isGlorpProxy	^false.</body><body package="GlorpQueries" selector="isKindOf:">isKindOf: aClass	^self class includesBehavior: aClass.</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="GlorpExtensions" selector="asGlorpExpression">asGlorpExpression	^GlorpHelper glorpConstantExpressionClass for: self.</body><body package="GlorpExtensions" selector="asGlorpExpressionOn:">asGlorpExpressionOn: anExpression	^self asGlorpExpression.</body><body package="GlorpExtensions" selector="asGlorpExpressionOn:basedOn:withUltimateBase:">asGlorpExpressionOn: anExpression basedOn: aMessageArchiver withUltimateBase: aBaseExpression	^self asGlorpExpression.</body><body package="GlorpExtensions" selector="glorpBasicSize">glorpBasicSize	^self basicSize.</body><body package="GlorpExtensions" selector="glorpCanHaveDescriptorDirectly">glorpCanHaveDescriptorDirectly	^self isBehavior.</body><body package="GlorpExtensions" selector="glorpIsCollection">glorpIsCollection	^false.</body><body package="GlorpExtensions" selector="glorpPostFetch:">glorpPostFetch: aSession	"This is a selector that objects can implement in order to receive notification when Glorp has read them."</body><body package="GlorpExtensions" selector="glorpPostFetchValidate:">glorpPostFetchValidate: aSession	"This allows us to do post-read notification of the objects. Note that if this method explicitly returns a false, then we will treat that as meaning that the object is invalid and should not be read. Yes, this is kind of a hack."</body><body package="GlorpExtensions" selector="glorpPostWrite:">glorpPostWrite: aSession</body><body package="GlorpExtensions" selector="glorpPreWrite:">glorpPreWrite: aSession	"This is a selector that objects can implement in order to receive notification when Glorp is about to write them. Only objects that have pending modifications will receive this notice. However, note that because of that, the data to be written will have already been calculated before this method is called, which makes it difficult to use this to update the method. If you want to put in audit information (e.g. the time at which the object was written, the associated username) then you probably want to use a generator associated with the field instead. See, for example GlorpRecordWithUpdate in the test suite."</body><body package="GlorpExtensions" selector="glorpPrintSelectSQLOn:">glorpPrintSelectSQLOn: aCommand	self glorpPrintSQLOn: aCommand.</body><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	self printOn: aCommand.</body><body package="GlorpExtensions" selector="glorpRealObject">glorpRealObject	"Return the real object. Will force instantiation of a proxy, even on compilers which inline yourself"	^self.</body><body package="GlorpExtensions" selector="isGlorpExpression">isGlorpExpression	^false.</body><body package="GlorpExtensions" selector="isGlorpProxy">isGlorpProxy	^false.</body><body package="GlorpExtensions" selector="needsWork:">needsWork: aString	^self.</body><body package="GlorpExtensions" selector="todo">todo	"marker"</body><body package="GlorpExtensions" selector="yourSelf">yourSelf	"Return the real object. Will force instantiation of a proxy, even on compilers which inline yourself"	^self.</body></methods><methods><class-id>Core.String</class-id> <category>glorp</category><body package="GlorpExtensions" selector="glorpIsCollection">glorpIsCollection	"For our purposes, these aren't collections, but rather a simple database type"	^false.</body><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	| platform requiresEscape |	platform := [aCommand platform] on: MessageNotUnderstood do: [:ex | ex return: nil].	aCommand nextPut: $'.	1		to: self size		do:			[:i | 			| char |			char := self at: i.			requiresEscape := platform isNil ifTrue: [false] ifFalse: [platform requiresEscapeFor: char].			requiresEscape				ifTrue: [aCommand nextPutAll: (aCommand platform escapeFor: char)]				ifFalse: [aCommand nextPut: char]].	aCommand nextPut: $'.</body><body package="GlorpExtensions" selector="like:">like: wildcardString	" 'abcde' like: 'abc%'  "	| newString |	newString := wildcardString copy.	newString replaceAll: $% with: $*.	newString replaceAll: $_ with: $#.	^newString match: self.</body></methods><methods><class-id>Core.Collection</class-id> <category>adding</category><body package="GlorpExtensions" selector="glorpAddAll:">glorpAddAll: aCollection	^self addAll: aCollection.</body><body package="GlorpExtensions" selector="glorpAddAllToDictionary:">glorpAddAllToDictionary: aDictionary	"Assumes that we are a collection of associations"	self do: [:each | aDictionary add: each].</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GlorpExtensions" selector="glorpGroupedBy:">glorpGroupedBy: aBlock	"Same as VW groupedBy:. This is too useful not to be able to use, but we don't want to conflict with other dialects/extensions that might implement, so make our own prefixed version"	"Return a dictionary whose keys are the result of evaluating aBlock for all elements in	 the collection, and the value for each key is the collection of elements that evaluated	 to that key. e.g.	     #(1 2 3 4 5) groupedBy: [:each | each odd]	   a Dictionary  	     true ---&gt; #( 1 3 5)	     false --&gt; #(2 4)"	| result |	result := Dictionary new.	self do:		[:each | | key collection |		key := aBlock value: each.		collection := result at: key ifAbsentPut: [OrderedCollection new].		collection add: each].	self species ~~ OrderedCollection ifTrue:		["Convert the result collections to be the right type.		  Note that it should be safe to modify the dictionary		  while iterating because we only replace values for existing keys"		result keysAndValuesDo:			[:key :value | result at: key put: (self species withAll: value)]].	^result</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="GlorpExtensions" selector="glorpIsCollection">glorpIsCollection	^true.</body></methods><methods><class-id>Core.Collection</class-id> <category>glorp</category><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	aCommand nextPut: $(.	self isEmpty		ifTrue: [aCommand nextPutAll: 'NULL']		ifFalse:			[GlorpHelper				do: [:each | each glorpPrintSQLOn: aCommand]				for: self				separatedBy: [aCommand nextPutAll: ', ']].	aCommand nextPut: $).</body><body package="GlorpExtensions" selector="glorpPrintSQLOn:for:">glorpPrintSQLOn: aStream for: aType	aStream nextPut: $(.	self isEmpty		ifTrue: [aStream nextPutAll: 'NULL']		ifFalse:			[GlorpHelper				do: [:each | aType print: each on: aStream]				for: self				separatedBy: [aStream nextPutAll: ', ']].	aStream nextPut: $).</body><body package="GlorpExtensions" selector="glorpRegisterCollectionInternalsIn:">glorpRegisterCollectionInternalsIn: anObjectTransaction 	"Explicitly register any internal structures (e.g. a VW identity dictionary's valueArray) with the transaction. Assume we can safely register everything inside the collection reflectively. The obvious exceptions would be dependents and sortblocks. This is a cheat, and for peculiar cases you'll need to override this in the subclass"	| names |	names := self class allInstVarNames.	(1 to: names size) do: 			[:index | 			(#('dependents' 'sortBlock') includes: (names at: index)) 				ifFalse: [anObjectTransaction register: (self instVarAt: index)]]</body></methods><methods><class-id>Core.Collection</class-id> <category>streams</category><body package="GlorpExtensions" selector="writeStream">writeStream	^AddingWriteStream on: self</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>streams</category><body package="GlorpExtensions" selector="writeStream">writeStream	^AddingWriteStream on: self.</body></methods><methods><class-id>Core.ByteArray</class-id> <category>testing</category><body package="GlorpExtensions" selector="glorpIsCollection">glorpIsCollection	"For our purposes, these aren't collections, but rather a simple database type"	^false.</body></methods><methods><class-id>Core.ByteArray</class-id> <category>glorp</category><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	|strm|	strm := WriteStream on: String new.	strm nextPutAll: '0x'.	strm nextPutAll: self asHexString.	aCommand nextPutAll: strm contents</body></methods><methods><class-id>Core.Dictionary</class-id> <category>adding</category><body package="GlorpExtensions" selector="glorpAddAll:">glorpAddAll: aCollection	"An addAll: that can work for either a dictionary argument or a collection of associations"	aCollection glorpAddAllToDictionary: self.</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	aCommand nextPutAll: 'NULL'.</body></methods><methods><class-id>Core.Association</class-id> <category>accessing</category><body package="GlorpExtensions" selector="glorpAtIdentity:ifAbsent:">glorpAtIdentity: aKey ifAbsent: aBlock	"A cheat to let use use this like an identity dictionary"	^key == aKey ifTrue: [value] ifFalse: aBlock.</body><body package="GlorpExtensions" selector="keysAndValuesDo:">keysAndValuesDo: aBlock	"A memory allocation hack. Let us use a single association in place of a dictionary"	aBlock value: key value: value.</body></methods><methods><class-id>Core.ReadStream</class-id> <category>Not categorized</category><body package="GlorpExtensions" selector="actuallyAtEnd">actuallyAtEnd	"For working around a VA cursor problem"	^self atEnd</body><body package="GlorpExtensions" selector="collect:">collect: aBlock	| newStream |	newStream := collection species new writeStream.	[self atEnd] whileFalse: [newStream nextPut: (aBlock value: self next)].	^newStream contents"Use #writeStream, not WriteStream on: collection species, for portability;  VA cannot stream over all AdditiveSequenceableCollections."</body></methods><methods><class-id>Core.ReadStream</class-id> <category>building objects</category><body package="GlorpExtensions" selector="collectionTypeFor:">collectionTypeFor: aClass	^aClass.</body></methods><methods><class-id>Core.ReadStream</class-id> <category>Not categorized</category><body package="GlorpExtensions" selector="detect:">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [self error: 'not found']</body><body package="GlorpExtensions" selector="detect:ifNone:">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="GlorpExtensions" selector="includes:">includes: anObject	self do: [:each | each = anObject ifTrue: [^true]].	^false.</body><body package="GlorpExtensions" selector="newCollectionOfSize:for:">newCollectionOfSize: aSize for: aCollectionType	^aCollectionType isBehavior ifTrue: [aCollectionType new: aSize] ifFalse: [aCollectionType copyEmpty: aSize].</body><body package="GlorpExtensions" selector="select:">select: aBlock	| newStream |	newStream := collection species new writeStream.	[self atEnd] whileFalse: [		| current |		current := self next.		(aBlock value: current) ifTrue: [newStream nextPut: current]].	^newStream contents"Use #writeStream, not WriteStream on: collection species, for portability;  VA cannot stream over all AdditiveSequenceableCollections."</body><body package="GlorpExtensions" selector="statement:">statement: aGlorpPreparedStatement	"This is the statement used to create us. If it's coming back to a simple read stream, then we must have already used all its data, and can thus reuse it"	aGlorpPreparedStatement busy: false.</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="GlorpExtensions" selector="glorpPadToTwoDigits:">glorpPadToTwoDigits: anInteger	| string |	string := anInteger truncated printString.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	"Print as 24 hour time"	aCommand 		nextPut: $';		nextPutAll: 	(self glorpPadToTwoDigits: self hours);		nextPut: $:;		nextPutAll: (self glorpPadToTwoDigits: self minutes);		nextPut: $:;		nextPutAll: (self glorpPadToTwoDigits: self seconds);		nextPut: $'.</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>accessing</category><body package="GlorpExtensions" selector="glorpAtIdentity:ifAbsent:">glorpAtIdentity: aKey ifAbsent: aBlock	^self at: aKey ifAbsent: aBlock.</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="GlorpExtensions" selector="glorpPrintSQLOn:">glorpPrintSQLOn: aCommand	"Print the date in ISO format. 'yyyy-mm-dd'  Don't rely on any dialect-specific formatting or padding mechanisms"	| monthString dayString |	aCommand 		nextPut: $';		print: self year;		nextPut: $-.	monthString := self monthIndex printString.	monthString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: monthString.	aCommand nextPut: $-.	dayString := self dayOfMonth printString.	dayString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: dayString.	aCommand nextPut: $'.</body></methods><initialize><class-id>Glorp.FunctionExpression</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ProtoObject</name><environment>Smalltalk</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpVWPort</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class></st-source>