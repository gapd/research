<?xml version="1.0"?><st-source><!-- Name: GlorpVWPortNonBaseNotice: LGPL(S)The code is Copyright (C) 2000-2003  Alan KnightThis is a Smalltalk library, licensed under the LGPL, and distributed WITHOUTANY WARRANTY (see below).  However, it is not obvious how some ofthe terms and concepts in the license should be sensibly applied to SmalltalkThe various Smalltalk image models often do not directly correspond to the ideas of programs and libraries that are linked to form executables. We, the authors, would like to clarify our interpretation of the LGPL as itapplies to Smalltalk, and what we permit you to do with this code. Wewill sometimes use the term LGPL(S) to distinguish the use of the LGPL with these clarifications.This code is intended to be usable as a library, without the intention to restrict the license of the program that uses it. Thus, you may use this librarythe same way you would normally use any other Smalltalk library. That is, you may load it into an image or otherwise make it available for use in whateverways are appropriate to the Smalltalk implementation you are using (including,but not limited to file-in, linking a shared library, or loading a binary representation such as a parcel,  BOSS file, image segment or image component).You may write code that uses the library, including subclassing library classesand having the library call back to your code using blocks, the #perform: mechanism, or similar mechanisms. You may use this code,  including creatingand distributing packaged images, libraries, development images and executablesthat include the library code. We do not consider these activities sufficientto make the entire program/image/executable or any portion of it beyond thelibrary itself be considered a derivative work, and in any case we place norestrictions on what licenses you may use for code that uses this library inthese or similar manners.If, however, you modify the class definitions or methods of the library, we doconsider those modified sections a derivative work, and as such they are fully subjectto the restrictions described in the LGPL. Basically, you'll need to release thesource of any modifications.If you require any further clarification, we'd be happy to provide it. You can contactthe authors c/o Alan Knight, knight@acm.org.    This program is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.    You should have received a copy of the GNU Lesser General Public    License along with this library; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USAComment: I hold Glorp VW behaviour that we do not want in the base, now that Store uses Glorp, but which conscious users of Glorp will want.	- WriteBarriers:  methods to invoke them are in base Glorp but unused (and sole reference to GlorpVWWriteBarrierTracker is already indirected for portability.  WebVelocity uses this.	- *EXDI overrides to switch off threading.  These are performance enhancements.  When you hit the DB often for small calls, as Glorp does, threading is slower.  However we do not want base users to be forced into being non-threaded for these calls when they may think they are threaded.ToDo:  rewrite non-threading to be policy / Glorp-use-only, whatever.DbIdentifier: bear73DbTrace: 313112DevelopmentPrerequisites: #(#(#any 'Regex11' '') #(#any 'WriteBarriers' '') #(#any 'ODBCEXDI' '') #(#any 'OracleEXDI' '') #(#any 'ODBCThapiEXDI' '') #(#any 'OracleThapiEXDI' ''))PackageName: GlorpVWPortNonBaseParcel: #('GlorpVWPortNonBase')ParcelName: GlorpVWPortNonBasePrerequisiteParcels: #(#('WriteBarriers' '') #('Regex11' ''))PrintStringCache: (7.7.1 - 29,aknight)Version: 7.7.1 - 29Date: 11:59:56 AM December 21, 2010 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (dec10.3) of December 21, 2010 on December 21, 2010 at 11:59:56 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GlorpVWWriteBarrierTracker</name><environment>Glorp</environment><super>WriteBarriers.Tracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpVWPortNonBase</package></attributes></class><comment><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id><body>This is used in conjunction with the WriteBarriers package to use the Cincom Smalltalk Immutability feature to implement register-on-write functionality. Objects read from the database are marked as read-only. When they are modified, this object is notified, and will register them with the current unit of work if they're not registered already, and start a unit of work if there isn't one pending. One tracker exists per GlorpSession and the tracker for that session is responsible for all objects read from the database using that session.Instance Variables:	session	&lt;GlorpSession&gt;	The session with which we register objects when they are modified.</body></comment><methods><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id> <category>private</category><body package="GlorpVWPortNonBase" selector="applyModificationTo:selector:index:value:">applyModificationTo: anObject selector: selector index: index value: value	" anObject has been modified. #isTracking: ensures that anObject was read by our session and is in our cache. Now we can put it in to a unit of work and allow the changes to be recordered. "	(session isRegistered: anObject) ifFalse:		[session requireUnitOfWork.		session register: anObject].	super applyModificationTo: anObject selector: selector index: index value: value.</body><body package="GlorpVWPortNonBase" selector="privateTrack:">privateTrack: anObject	"Responsibility inherited from our superclass. Do nothing. We already know about all the objects we're tracking."</body><body package="GlorpVWPortNonBase" selector="privateUntrack:">privateUntrack: anObject	"Responsibility inherited from our superclass. Do nothing. We already know about all the objects we're tracking."</body></methods><methods><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id> <category>accessing</category><body package="GlorpVWPortNonBase" selector="session">session	^session.</body><body package="GlorpVWPortNonBase" selector="session:">session: aGlorpSession 	session := aGlorpSession.</body></methods><methods><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id> <category>API</category><body package="GlorpVWPortNonBase" selector="isTracking:">isTracking: anObject	" anObject is being modified. One tracker exists per session, so we answer true if anObject is in our cache. "	anObject isGlorpProxy ifTrue: [^false].	^session cacheContainsObject: anObject</body></methods><methods><class-id>Database.ODBCSession class</class-id> <category>accessing</category><body package="GlorpVWPortNonBase" selector="nonThreadedConnectionClass">nonThreadedConnectionClass	"Answer the class to use for connection objects associated with receiver."	^ODBCConnection</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-answer set</category><body package="GlorpVWPortNonBase" selector="describeAnswerColumns">describeAnswerColumns	"Fill in the columnDescriptions array."	| xif descrs cbColNameMax columnDescriptionClass szColName pcbColName pfSqlType pcbColDef pibScale pfNullable rc precision colDesc fSqlType longType |	xif := self class xifNonThreaded.	descrs := Array new: self numColumns.	cbColNameMax := (self connection getInformationType: #SQL_MAX_COLUMN_NAME_LEN) + 1.	columnDescriptionClass := self connection class columnDescriptionClass.	[ "Begin unwind protection."	szColName := xif UCHAR perform: xif mallocSelector with: cbColNameMax.	pcbColName := xif SWORD perform: xif mallocSelector with: 1.	pfSqlType := xif SWORD perform: xif mallocSelector with: 1.	pcbColDef := xif UDWORD perform: xif mallocSelector with: 1.	pibScale := xif SWORD perform: xif mallocSelector with: 1.	pfNullable := xif SWORD perform: xif mallocSelector with: 1.	1 to: self numColumns do:		[ :aColumn |		rc := xif SQLDescribeCol: self hstmt					with: aColumn					with: szColName					with: cbColNameMax					with: pcbColName					with: pfSqlType					with: pcbColDef					with: pibScale					with: pfNullable.		precision := pcbColDef contents.		( traceLevel &gt;= 2) ifTrue:			[ (self traceStream)				print: rc;  nextPutAll: ' = SQLDescribeCol( hstmt=';				nextPutAll: (self  hstmt referentAddress printStringRadix: 16);				nextPutAll: ', icol =';  print: aColumn;				nextPutAll:  ', szColName: '; print: szColName copyCStringFromHeap;				nextPutAll:  ', cbColName: '; print: pcbColName contents;				nextPutAll:  ', fSQLType: '; print: pfSqlType contents;				nextPutAll:  ', cbColDef: '; print: precision;				nextPutAll:  ', ibScale: ';  print: pibScale contents;				nextPutAll:  ', fNullable: ';  print: pfNullable contents;				nextPutAll:  ' )'.			self class trace: self emitTrace ].		( rc == xif SQL_SUCCESS		or: [ rc == xif SQL_SUCCESS_WITH_INFO] ) ifFalse:			[ | errs |		  	errs := self getStatementErrors.			^self class connectionClass unableToDescribeSignal raiseWith: errs errorString: errs first dbmsErrorString ].		"If this is a SQL Native client, a varchar(max), varbinary(max), or nvarchar(max) column has precision = 0.		If so, then reset its precision and sql type to make this column appear to be a LONG."		fSqlType := pfSqlType contents.		(precision = 0 and: [self isSQLNativeClient])			ifTrue: [(longType := self getLongTypeFor: fSqlType) notNil				ifTrue: [precision := self getMaxLongData.						fSqlType := longType]].		(colDesc := columnDescriptionClass new) 			index: aColumn;			name: szColName copyCStringFromHeap;			fSqlType: fSqlType;			type: (xif class fSqlTypeToConversionMap at: colDesc fSqlType);			maxColumnConstraint: precision;			precision: precision;			scale: pibScale contents;			nullable: (pfNullable contents == xif SQL_NULLABLE).		descrs at: aColumn put: colDesc ]	"End unwind protection." ]		ensure:			[ szColName notNil ifTrue: [ szColName freePointer ].			pcbColName notNil ifTrue: [ pcbColName freePointer ].			pfSqlType notNil ifTrue: [ pfSqlType freePointer ].			pcbColDef notNil ifTrue: [ pcbColDef freePointer ].			pibScale notNil ifTrue: [ pibScale freePointer ].			pfNullable notNil ifTrue: [ pfNullable freePointer ] ].	self columnDescriptions: descrs</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-execution</category><body package="GlorpVWPortNonBase" selector="freeStatementExternal:">freeStatementExternal: releaseOption	"Release resources associated with a session."	| xif rc |	self hstmt isNil ifTrue: [ ^self ].	xif := self class xifNonThreaded.	rc := xif SQLFreeStmt: self hstmt with: (xif perform: releaseOption).	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLFreeStmt( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', '; print: releaseOption;			nextPutAll: ')'.	         self class trace: self emitTrace ].	rc == xif SQL_SUCCESS ifFalse:		[ | errs |		errs := self getStatementErrors.		self class connectionClass unableToFreeResourceSignal raiseRequestWith: errs errorString: errs first dbmsErrorString ].</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-answer set</category><body package="GlorpVWPortNonBase" selector="hasAnswerSetExternal">hasAnswerSetExternal	| xif rc pccol |	xif := self class xifNonThreaded.	self numColumns: 0. "default to none"	[ "Begin unwind protection."	pccol := xif SWORD perform: xif mallocSelector with: 1.	rc := xif SQLNumResultCols: self hstmt with: pccol.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLNumResultCols( hstmt=';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', *pccol =';  print: pccol contents;			nextPutAll: ' )'.		self class trace: self emitTrace ].	rc == xif SQL_SUCCESS ifFalse:		[ | errs |		errs := self getStatementErrors.		^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self numColumns: pccol contents.	"End unwind protection." ]		ensure: 			[ pccol notNil ifTrue: [ pccol freePointer ] ].	self numColumns &gt; 0 ifTrue:		[ ^true ].	"Simulate auto-commit transaction behavior?"	self handleAutoCommit.	^false</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>accessing</category><body package="GlorpVWPortNonBase" selector="xifNonThreaded">xifNonThreaded	"Answer the ExternalInterface subclass instance in use."	^self nonThreadedConnectionClass xif</body></methods><methods><class-id>Database.OracleThreadedConnection class</class-id> <category>private-accessing</category><body package="GlorpVWPortNonBase" selector="xifNonThreaded">xifNonThreaded	^self superclass xif.</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>private-accessing</category><body package="GlorpVWPortNonBase" selector="xifNonThreaded">xifNonThreaded	"Answer the ExternalInterface subclass instance to use."	^self xif.</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-execution</category><body package="GlorpVWPortNonBase" selector="getAttributeExternal:type:length:descriptor:type:">getAttributeExternal: attributePointer type: attributeType length: attributeLengthPointer descriptor: descriptor  type: descriptorType	| xif rtval |	xif := self class xifNonThreaded.		rtval := xif OCIAttrGet: descriptor				    with:  (xif perform: descriptorType  )				    with:  attributePointer 				    with:  attributeLengthPointer				    with: (xif perform: attributeType )				    with: self herr.	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)	print: rtval;  nextPutAll: ' = OCIAttribGet( descriptor = ';	nextPutAll: (descriptor referentAddress printStringRadix: 16);	nextPutAll: ',  descriptorType = '; 	nextPutAll: descriptorType printString;	nextPutAll: ', attribute  = ';	nextPutAll: (attributePointer referentAddress printStringRadix: 16);	nextPutAll: ', attributeType  = ';      nextPutAll: attributeType  printString;	nextPutAll: ', length  = '; print: attributeLengthPointer contents;	nextPutAll: ', herr = ';	nextPutAll: (self herr referentAddress printStringRadix: 16);	nextPutAll: ')'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ | errs |		errs := self getErrors.	        ^self class unableToRetrieveDescriptorInfoSignal raiseWith: errs errorString: errs first dbmsErrorString  ]</body><body package="GlorpVWPortNonBase" selector="getSchemaObjectAttributeFromDescriptorExternal:type:startingAt:">getSchemaObjectAttributeFromDescriptorExternal: hDescriptor type: descriptorType startingAt: position	"Retrieve parameter descriptor for the ."	| xif  rtval herr schemaObjectAttribute |	xif := self class xifNonThreaded.	herr := self herr.	((self parameterPointer isNil) or: [ self parameterPointer isValid not ]) ifTrue:  [		self parameterPointer: ( xif OCIParam pointerType perform: xif mallocSelector with: 1).		self parameterPointer contents: (xif OCIParam pointerType cast: nil ).	].	rtval := xif OCIParamGet: hDescriptor						with: (xif perform: descriptorType)						with: herr 						with: self parameterPointer						with: position.	(rtval == xif OCI_NO_DATA)		ifTrue: [ ^nil ].	(rtval == xif OCI_SUCCESS)		ifFalse: [ ^nil ].	schemaObjectAttribute := self parameterPointer contents.	^schemaObjectAttribute</body></methods><methods><class-id>Database.OracleSession class</class-id> <category>accessing</category><body package="GlorpVWPortNonBase" selector="nonThreadedConnectionClass">nonThreadedConnectionClass	"Answer the connection class for sessions"		^OracleConnection</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-answer set</category><body package="GlorpVWPortNonBase" selector="cancelAnswerSetExternal">cancelAnswerSetExternal	"Explicity cancel current or previous query results."	| xif  rtval errs hstmt herr |	xif := self class xifNonThreaded.	hstmt := self hstmt.	herr := self herr.	self useStatementCaching ifTrue: [		rtval := xif OCIStmtFetch2: hstmt				with: herr				with: 0				with: xif OCI_FETCH_NEXT				with: 1				with: xif OCI_DEFAULT.	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rtval;				nextPutAll: ' = OCIStmtFetch2( hstmt =';				nextPutAll: (hstmt referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ' , nrows = 0 ';				nextPutAll: ' , orientation = OCI_FETCH_NEXT ';				nextPutAll: ' , fetchOffset = 1 ';				nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	] ifFalse: [		rtval := xif OCIStmtFetch: hstmt 						with: herr 						with: 0						with: xif OCI_FETCH_NEXT					     with: xif OCI_DEFAULT.		(traceLevel &gt;= 2) ifTrue: 			[ (self traceStream)			print: rtval; nextPutAll: ' = OCIStmtFetch( hstmt =';			nextPutAll: (hstmt referentAddress printStringRadix: 16);			nextPutAll: ', herr = ';			nextPutAll: (herr referentAddress printStringRadix: 16);			nextPutAll: ' , nrows = 0 ';			nextPutAll: ' , orientation = OCI_FETCH_NEXT '; 			nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	].	(rtval == xif OCI_NO_DATA)		ifTrue: [	"Try to flush the server's error list"				self getStatementErrors.			     	^nil.  ].	(rtval == xif OCI_SUCCESS	or: [rtval == xif OCI_SUCCESS_WITH_INFO])		ifFalse: [ errs := self getStatementErrors.			       ^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].				 	^self</body><body package="GlorpVWPortNonBase" selector="defineRowBufferExternal:buffer:">defineRowBufferExternal: aColumn buffer: aBuffer	| xif rtval |	xif := self class xifNonThreaded.	self definePointer isNil ifTrue: [		self definePointer: (xif OCIDefine pointerType perform: xif mallocSelector with: 1).		self definePointer contents: (xif OCIDefine pointerType cast: nil). "This is essential!!"	].	rtval := xif 				OCIDefineByPos: self hstmt				with: self definePointer				with: self herr				with: aColumn				with: aBuffer pointer				with: aBuffer elementSize				with: aBuffer databaseType				with: aBuffer indicatorsPointer				with: aBuffer lengthsPointer				with: aBuffer rcodesPointer				with: xif OCI_DEFAULT.	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := connection getErrors.			^self connection class unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>OracleConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>henvHolder herrHolder hsvcctxHolder hsrvrHolder hsessHolder htxnHolder executionMode transactionMode authenticationMode useStatementCaching attributeLengthPointerHolder attributePointerHolder parameterPointerHolder descriptorPointerHolder </inst-vars><class-inst-vars>signalMap libraryInitialized </class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><class><name>OracleSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultsCache hstmtHolder herrHolder bindValuePointersHolder maxLongBytes queryIsPLSQL currentRowIndex totalRows rowsInBlock dependentLobs sqlPointerHolder maxBindSize answerLobProxy defaultDisplayLobSize isReleasedFromCacheHolder lobBufferSize reuseColumnBuffers definePointerHolder bindPointerHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><class><name>ODBCSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmtHolder resultsCache bindValuePointers mustResendQueryHolder fetchLongResultsAnyOrder maxLongData sqlStatementOptionCache queryIsPROC unicode encoding unicodeEncoding lobBufferSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><class><name>Tracker</name><environment>WriteBarriers</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ModificationManagementToo</category><attributes><package>WriteBarriers</package></attributes></class></st-source>