<?xml version="1.0"?><st-source><!-- Name: PostgreSQLEXDIComment: © 2000 - 2008 Bruce Badger. Licensed under the LGPL.The VisualWorks PostgreSQL EXDI interface allows access to PostgreSQL databases from VisualWorks in just the same way as access is provided for a Sybase or Oracle database from VisualWorks.To obtain the library (but then, how are you reading this if you have not worked that out?) the best bet is to connect to use the version shipped with VisualWorks or grab the latest version from the Cincom public Store.  Alternatively:    * Have a look at the project home page.    * Get the latest version of the libraries from SourceForge .    * Uncompress the .tgz file into your working directory (or somwhere else on your parcel path).        From a clean VisualWorks image (I'm now working in a 7.5NC image) load the PostgreSQLEXDI parcel,       this will load everything else you need. That's it. Now you just need a PostgreSQL database        to connect to (the project home page has some tips that may help get you going).    * Have a look at the two test classes (PostgreSQLTest and PostgreSQLEXDITest) to see       examples of what works so far. It's a good idea to run all of the tests in these classes (just       run the respective unit tests) to check that everything is installed OK.    * Try using the Ad Hoc SQL tool. From the VisualWorks launcher choose Database>Ad Hoc SQL.       Note that the environment string format is {mycomputer:port}_{db name}        (e.g. 192.168.10.3:5432_storedb). The default host is localhost and the default port is 5432. Try        the query: select * from pg_class.Current limitations    * Limited authentication support. Clear text and MD5 passwords only.    * Documentation is very limited - but with your help, it will get better.Using Database Connect for PostgreSQLThis part of the documentation is intended to mirror the database connect for Oracle/Sybase etc. documentation that comes with VisualWorks. As you can see, this has some way to go! Feel free to contribute.Data Conversion and BindingWhen receiving data from the database, all data returned by the PostgreSQL EXDI is converted into instances of Smalltalk classes. These conversions are summarized in the table below. Although abstract classes are used to simplify the table, the object holding the data is always an instance of a concrete class.BLOBsUsing PostgreSQL BLOBs are not treated as regular data types, and can not simply be included in SQL statements. PostgreSQL allows BLOBs to be manipulated through function calls. Each BLOB has a unique oid allocated by the function used to create it in the database. It is the oid of a blob which may be placed in a field and manipulated using regular SQL.The PostgreSQL EXDI tries to hide the complexities of dealing with function calls, but the technique currently employed results in the creation of a new BLOB in the database every time a BLOB is included in an SQL statement. For example, if you store a sound in a table, and then update that sound (replacing the old sound), the old sound BLOB will still exist in the database, but will not be refered to; in a Smalltalk image it would be subject to garbage collection, but PostgreSQL does not have garbage collection.To avoid old and unused BLOBs building up in a database, you must add database trigers (or some such thing) to remove old BLOBs from the database.- - Please send your comments to bbadger@openskills.com.  Thanks.DbIdentifier: bb20100717DbTrace: 946DevelopmentPrerequisites: #(#(#any 'Base64Encoding' '') #(#any 'Database' '') #(#any 'PostgreSQLDriver' '') #(#any 'PostgreSQLLogging' ''))HideSource: falsePackageName: PostgreSQLEXDIPackageName:: PostgreSQLEXDIParcel: #('PostgreSQLEXDI')ParcelName: PostgreSQLEXDIPrerequisiteParcels: #(#('Base64Encoding' '') #('Database' '') #('PostgreSQLDriver' '') #('PostgreSQLLogging' ''))PrintStringCache: (1.5 001,bbadger)SaveSource: trueVersion: 1.5Date: 11:31:46 PM November 8, 2010 --><time-stamp>From VisualWorks®, 7.7 of November 25, 2009 on November 8, 2010 at 11:31:46 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PostgreSQLEXDIFieldValue</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIFieldValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	object	&lt;ClassOfVariable&gt;	description of variable's function	string	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIByteArrayValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIByteArrayValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	oid	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIEnvironmentString</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIEnvironmentString</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	environmentString	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDINullValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>nullValue </class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDINullValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIBLOB</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIBLOB</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	byteArray	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIError</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIError</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIBLOBValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIBLOBValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	oid	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDITransaction</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDITransaction</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIColumnDescription</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIColumnDescription</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIStringValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIStringValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIException</name><environment>Smalltalk</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIException</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIBLOBManipulationOutsideTransaction</name><environment>Smalltalk</environment><super>PostgreSQLEXDIException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIBLOBManipulationOutsideTransaction</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDISession</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowStream currentPostgresRow noticeResponsesAreSuppressed resultList translationsFromPostgres </inst-vars><class-inst-vars>translationsFromPostgres </class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDISession</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	rowStream	&lt;ClassOfVariable&gt;	description of variable's function	currentPostgresRow	&lt;ClassOfVariable&gt;	description of variable's function	noticeResponsesAreSuppressed	&lt;ClassOfVariable&gt;	description of variable's function	resultList	&lt;ClassOfVariable&gt;	description of variable's function	translationsFromPostgres	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIFieldValueException</name><environment>Smalltalk</environment><super>PostgreSQLEXDIException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIFieldValueException</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIConnection</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentParameters connection parameterSet </inst-vars><class-inst-vars>storeBroker traceLog </class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIConnection</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	environmentParameters	&lt;ClassOfVariable&gt;	description of variable's function	connection	&lt;ClassOfVariable&gt;	description of variable's function	parameterSet	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIFieldValueFunctionCallRequest</name><environment>Smalltalk</environment><super>PostgreSQLEXDIException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIFieldValueFunctionCallRequest</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI" selector="onObject:">onObject: anObject 	"^self 	Iinitialize myself to represent anObject."	object := anObject.	^self</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="object">object	"^an Object 	I return my object. If it's nil, I try and make it from my string value."	object isNil ifTrue: [object := self objectFromString].	^object</body><body package="PostgreSQLEXDI" selector="string">string	"^a String	I return my string representation. If it's nil, I try and make it from my object value."	string isNil ifTrue: [string := self stringFromObject].	^string</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="objectFromString">objectFromString	"^an Object 	My subclasses must implement this."	^self subclassResponsibility</body><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	My subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>emitting</category><body package="PostgreSQLEXDI" selector="writeStringTo:">writeStringTo: aStream 	"^self 	I simply write my string value to aStream."	aStream nextPutAll: self string.	^self</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>license</category><body package="PostgreSQLEXDI" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIFieldValue class</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="canHandle:">canHandle: anObject 	"^a Boolean 	I return true if my instances can handle this kind of objects, otherwise I return false."	^self subclassResponsibility</body><body package="PostgreSQLEXDI" selector="onObject:">onObject: anObject 	"^a PostgreSQLEXDIFieldValue 	I return an instance of myself to represent anObject. My subclasses may override this method (I'm 	thinking of the cass which handles nil)."	^self new onObject: anObject</body></methods><methods><class-id>PostgreSQLEXDIFieldValue class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI" selector="forObject:">forObject: anObject 	"^a PostgreSQLEXDIFieldValue 	I return an instance of one of my subclasses. I ask each of them if they can represent anObject, 	and the first one to say yes get's it. If none of my subclasses are interested, I throw an exception."	| volunteerClass |	volunteerClass := self subclasses detect: [:aSubclass | aSubclass canHandle: anObject]				ifNone: [PostgreSQLEXDIFieldValueException raiseSignal: 'Unable to map object to value.'].	^volunteerClass onObject: anObject</body></methods><methods><class-id>PostgreSQLEXDIByteArrayValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	ByteArrays can be stored in PostgreSQL fields of type bytea, but they must be Base 64 encoded 	first. This encoding makes the byte array about 30% longer but in return it means that the data can 	be stored on the target row rather than in a separate BLOB."	| writeStream |	writeStream := Base64EncodingWriteStream on: (String new: ((self object size) * (3 / 2)) rounded).	writeStream disableLineBreaks.	writeStream nextPutAll: self object.	writeStream close.	^writeStream contents printString</body></methods><methods><class-id>PostgreSQLEXDIByteArrayValue class</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="canHandle:">canHandle: anObject 	"^a Boolean 	I only handle ByteArrays. If anObject is a ByteArray I return true, otherwise I return false."	^anObject isKindOf: ByteArray</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="environmentString">environmentString	"^a String 	I return the raw environment string."	^environmentString</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI" selector="on:">on: aString 	"^self 	I initialize myself to represent the values encoded in aString, which is presumed 	to be an environment string as described in the EXDI manual."	environmentString := aString.	^self</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="hostAndPort">hostAndPort	"^a String 	I return the combined host:port number string if it exists in the environment string, otherwise, I return 	nil."	^(self environmentString includes: $_)		ifTrue: [self environmentString copyUpTo: $_]		ifFalse: [nil]</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>license</category><body package="PostgreSQLEXDI" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>services</category><body package="PostgreSQLEXDI" selector="databaseName">databaseName	"^aString 	I return a string which is the database name as specified in the environment string I represent. I will 	return nil if no database name is specified."	^self environmentString isNil		ifTrue: [nil]		ifFalse: [(self environmentString includes: $_)				ifTrue: [self environmentString copyFrom: (self environmentString indexOf: $_)							+ 1 to: self environmentString size]				ifFalse: [self environmentString]]</body><body package="PostgreSQLEXDI" selector="hostName">hostName	"^aString 	I return a string which is the host name as specified in the environment string I represent. I will return 	nil if no host name is specified."	^self hostAndPort isNil		ifTrue: [nil]		ifFalse: [(self hostAndPort includes: $:)				ifTrue: [self hostAndPort copyUpTo: $:]				ifFalse: [self hostAndPort ]]</body><body package="PostgreSQLEXDI" selector="portNumber">portNumber	"^anInteger 	I return an Integer which is the port number as specified in the environment string I represent. I will 	return nil if no port number is specified."	| hostAndPort |	hostAndPort := self hostAndPort.	^hostAndPort isNil		ifTrue: [nil]		ifFalse: [(hostAndPort includes: $:)				ifTrue: [(hostAndPort copyFrom: (hostAndPort indexOf: $:)							+ 1 to: hostAndPort size) asNumber]				ifFalse: [nil]]</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI" selector="on:">on: aString 	"^a PostgreSQLEXDIEnvironmentString 	I return a new instance of myself which represents the values encoded in aString, which is presumed 	to be an environment string as described in the EXDI manual."	^self new on: aString</body></methods><methods><class-id>PostgreSQLEXDINullValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	My string value is always NULL."	^'NULL'</body></methods><methods><class-id>PostgreSQLEXDINullValue class</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="canHandle:">canHandle: anObject 	"^a Boolean 	I return true if my instances can handle this kind of objects, otherwise I return false."	^anObject isNil</body><body package="PostgreSQLEXDI" selector="onObject:">onObject: anObject 	"^a PostgreSQLEXDIFieldValue 	I return my singleton instance."	nullValue isNil ifTrue: [nullValue := self new onObject: anObject].	^nullValue</body></methods><methods><class-id>PostgreSQLEXDIBLOB</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI" selector="on:">on: aByteArray 	"^self 	I initialize myself to represent aByteArray as a Binary Large OBject ( a BLOB)."	byteArray := aByteArray.	^self</body></methods><methods><class-id>PostgreSQLEXDIBLOB</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="byteArray">byteArray	"^a ByteArray 	I return the ByteArray I represent."	^byteArray</body></methods><methods><class-id>PostgreSQLEXDIBLOB class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI" selector="on:">on: aByteArray 	"^a PostgreSQLEXDIBLOB 	I return a new instance of myself which represents aByteArray as a Binary Large OBject ( a BLOB)."	^self new on: aByteArray</body></methods><methods><class-id>PostgreSQLEXDIBLOBValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="callFunctionInTheContextOf:">callFunctionInTheContextOf: aSession 	"^self 	I decide what actions I have to take to get the blob I represent correctly represented on the server, 	and then I make a note of the oid of the blob. I make sure that we are in a transaction - if we're not, 	I throw a non-proceedable exception. 	This is a *very* crude implementation which is intended to just get things going. Note that a new blob 	is created regardless of whether this is an insert or update action. Also note that the deletion of a row 	will not delete a BLOB it's referring to. Triggers must be added to tables containing blobs to remove 	old/stale BLOBs."	| connection functionCall result oidValue blobDescriptorValue |	aSession connection inTransactionMode 		ifFalse: [PostgreSQLEXDIBLOBManipulationOutsideTransaction raiseSignal].	connection := aSession connection connection.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #lo_creat).	functionCall 		addArgument: (ByteValue size: 4 value: #[0 6 0 0] asByteArray for: functionCall).	result := functionCall execute.	oidValue := result functionResponse value asIntValue.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #lo_open).	functionCall addArgument: oidValue.	functionCall 		addArgument: (ByteValue size: 4 value: #[0 6 0 0] asByteArray for: functionCall).	result := functionCall execute.	blobDescriptorValue := result functionResponse value asIntValue.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #lowrite).	functionCall addArgument: blobDescriptorValue.	functionCall 		addArgument: (ByteValue size: self object byteArray size value: self object byteArray  for: functionCall).	result := functionCall execute.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #lo_close).	functionCall addArgument: blobDescriptorValue.	result := functionCall execute.	self oid: oidValue value.	^self</body><body package="PostgreSQLEXDI" selector="oid">oid	"^an Integer 	I return the oid of the blob I represent."	^oid</body><body package="PostgreSQLEXDI" selector="oid:">oid: anInteger 	"^self 	I record the oid of the blob I represent."	oid := anInteger.	^self</body><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	My string value is the string form of the integer which is the oid of the BLOB I represent. This is a 	non-trivial matter. I must submit several fuction calls to the PostgreSQL back end which create &amp; 	update the blob. By myself, I can't see the database; I need to get hold of the database connection. 	To acieve this, I throw an exception which is caught by the session. The session in turn then sends 	me the &gt;&gt;callFunctionInTheContextOf: with itself as the argument. This enables me to get hold of 	the connection and call the appropriate blob functions on the back end.  I then return control to 	the session, which in turn resumes the exception returning control here. Finally I take the oid of the 	blob and return it's value as a string. Phew!! 	NOTE: This way of handling blobs results in a new BLOB for every update. It is very important that 	database triggers are used to remove old blobs from the database when a row containing BLOB 	references is updated or deleted."	PostgreSQLEXDIFieldValueFunctionCallRequest signalWith: self.	^self oid printString</body></methods><methods><class-id>PostgreSQLEXDIBLOBValue class</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="canHandle:">canHandle: anObject 	"^a Boolean 	I only handle PostgreSQLEXDIBLOBs. If anObject is a PostgreSQLEXDIBLOB I return true, otherwise 	I return false."	^anObject isKindOf: PostgreSQLEXDIBLOB</body></methods><methods><class-id>PostgreSQLEXDITransaction</class-id> <category>license</category><body package="PostgreSQLEXDI" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDITransaction</class-id> <category>private-library calls</category><body package="PostgreSQLEXDI" selector="beginExternal">beginExternal	"^self 	Transactions are connection related not session related for PostgreSQL, so I just return myself."	^self</body><body package="PostgreSQLEXDI" selector="commitExternal">commitExternal	"^self 	Transactions are connection related not session related for PostgreSQL, so I just return myself."	^self</body><body package="PostgreSQLEXDI" selector="rollbackExternal">rollbackExternal	"^self 	Transactions are connection related not session related for PostgreSQL, so I just return myself."	^self</body></methods><methods><class-id>PostgreSQLEXDITransaction class</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="connectionClass">connectionClass	^PostgreSQLEXDIConnection</body></methods><methods><class-id>PostgreSQLEXDIColumnDescription</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI" selector="for:">for: aFieldDescription 	"^self	I initialize myself to represent aFieldDescription.""		index: aColumn;"		self name: aFieldDescription name.		self maxColumnConstraint: aFieldDescription typeSize."		type: (self connection class columnDescriptionClass getType: column type);		scale: column decimalPlaces;		precision: nil;		nullable: column isNotNull not;"		^self</body></methods><methods><class-id>PostgreSQLEXDIColumnDescription</class-id> <category>license</category><body package="PostgreSQLEXDI" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIColumnDescription class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI" selector="for:">for: aFieldDescription 	"^a PostgreSQLEXDIColumnDescription 	I return a new instance of myself to 	represent aFieldDescription."	^self new for: aFieldDescription</body></methods><methods><class-id>PostgreSQLEXDIStringValue</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="stringFromObject">stringFromObject	"^a String 	This is a rather crude implementation for now."	| rawStream refinedStream obj|	obj := object.	self object isSymbol ifTrue:[ obj := object asString].	rawStream := obj printString readStream.	refinedStream := String new writeStream.	[rawStream atEnd]		whileFalse: 			[| character |			character := rawStream next.			character = $\ ifTrue: [refinedStream nextPut: $\].			refinedStream nextPut: character].	^refinedStream contents</body></methods><methods><class-id>PostgreSQLEXDIStringValue class</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="canHandle:">canHandle: anObject 	"^a Boolean 	I my instances can handle most things by getting their &gt;&gt;printString, but they can't handle nil or 	BLOBs (ByteArray). So, I return true unless an object is nil or a ByteArray."	^anObject notNil and: [(anObject isKindOf: ByteArray) not and: [(anObject isKindOf: PostgreSQLEXDIBLOB) not]]</body></methods><methods><class-id>PostgreSQLEXDIException</class-id> <category>license</category><body package="PostgreSQLEXDI" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="currentPostgresRow">currentPostgresRow	^currentPostgresRow</body><body package="PostgreSQLEXDI" selector="currentPostgresRow:">currentPostgresRow: aRow 	currentPostgresRow := aRow.	^self</body><body package="PostgreSQLEXDI" selector="noticeResponsesAreSuppressed">noticeResponsesAreSuppressed	"^a Boolean 	I return true if notice responses (thrown as exceptions by the driver layer) are to be suppressed, 	otherwise, I return false. If the notices are suppressed, this EXDI interface just proceeds through 	them. If they are not suppressed, the exceptions just pass through the EXDI layer, and must be 	handled by the EXDI client. I default to suppressing the notice responses."	noticeResponsesAreSuppressed isNil ifTrue: [noticeResponsesAreSuppressed := true].	^noticeResponsesAreSuppressed</body><body package="PostgreSQLEXDI" selector="queryResult">queryResult	"^ a PostgreSQLQueryResultList 	I return the result(s) of the query. A single query can include a number of SQL queries all in the one 	query string. For this reason, aPostgreSQLQueryResultList can hold many results. Each of these 	results can be obtained by repeatedly sending &gt;&gt;answer to the session (me)."	^resultList first</body><body package="PostgreSQLEXDI" selector="resultList:">resultList: aPostgreSQLQueryResultList 	"^self 	I record the result of the query. c.f. self&gt;&gt;result"	resultList := aPostgreSQLQueryResultList</body><body package="PostgreSQLEXDI" selector="rowStream">rowStream	"^a ReadStream 	I return a stream on the collection of rows 	in my result."	rowStream isNil ifTrue: [rowStream := self queryResult rows readStream].	^rowStream</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-library calls</category><body package="PostgreSQLEXDI" selector="acquireExternal">acquireExternal	"^self 	This is a no-op for now"	^self</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-execution</category><body package="PostgreSQLEXDI" selector="cancelExternal">cancelExternal	"^self 	This is a no-op for me at the moment."	^self</body><body package="PostgreSQLEXDI" selector="dismissExternal">dismissExternal	"^self 	This is a no-op for me at the moment."	^self</body><body package="PostgreSQLEXDI" selector="executeExternal">executeExternal	"^self 	Execute the prepared query."	| queryMessage |	queryMessage := self connection connection newQuery.	queryMessage queryString: self query.	[self resultList: queryMessage execute]		on: PostgreSQLException		do:			[:exception | 			| error |			exception isNoticeResponse				ifTrue:					[self noticeResponsesAreSuppressed						ifTrue: [exception resume]						ifFalse: [exception pass]]				ifFalse:					[error := PostgreSQLEXDIError new.					error dbmsErrorString: exception messageText.					self connection class externalDatabaseErrorSignal						raiseWith: (Array with: error)						errorString: exception description]].	^self</body><body package="PostgreSQLEXDI" selector="readyExternal">readyExternal	"Answer whether or not the dbms has 	processed the SQL statement . For now, it's 	aways a yes (true)."	^true</body><body package="PostgreSQLEXDI" selector="resultsExternal">resultsExternal	"^a Boolean 	I return true if there are any results available, otherwise I return false. I know that there are results if 	a row description has been returned by PostgreSQL."	^self queryResult rowDescription notNil</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-binding</category><body package="PostgreSQLEXDI" selector="bindExternal">bindExternal	"^self 	I blend the &gt;&gt;bindVariables with the &gt;&gt;queryFragments to form a viable SQL query string. I convert 	the variables to string values acceptable to PostgreSQL as appropriate. Some more complex values 	(I'm thinking of ByteArrays and BLOBs here) require that functions be called in the back end server. 	Processing these complex values results in an exception being thrown in order to have some action 	taken in the context of this session - i.e. calling a function. Once the action has completed, the 	exception may be resumed, and the binding can proceed."	| queryStream |	queryStream := WriteStream on: (String new: 255).	queryStream nextPutAll: queryFragments first.		[2 to: queryFragments size		by: 2		do: 			[:index | 			| bindMarker value |			bindMarker := queryFragments at: index.			value := PostgreSQLEXDIFieldValue 						forObject: (self inBindInputAt: bindMarker).			value writeStringTo: queryStream.			queryStream nextPutAll: (queryFragments at: index + 1)]] 			on: PostgreSQLEXDIFieldValueFunctionCallRequest			do: 				[:exception | 				exception parameter callFunctionInTheContextOf: self.				exception resume].	query := queryStream contents.	^self</body><body package="PostgreSQLEXDI" selector="prepareExternal">prepareExternal	"^self 	This is a no-op for now"	^self</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-answer set</category><body package="PostgreSQLEXDI" selector="advanceExternal">advanceExternal	"^a row-like-thing or nil 	Advance the current row. If blockFactor is supported, this may entail fetching many rows but doing 	it infrequently. If there are no more rows, answer nil. Otherwise, answering self is sufficient."	self currentPostgresRow: (self rowStream atEnd			ifTrue: [nil]			ifFalse: [self rowStream next]).	^self currentPostgresRow</body><body package="PostgreSQLEXDI" selector="allocateRowBufferExternal:">allocateRowBufferExternal: aColumn 	"^self 	I return an object describing space allocated 	for holding one column's 	worth of 	information as returned by the dbms api. 	The driver is responsible 	for defining the 	structure of the object returned. Space is 	already allocated. I just return nil."	^nil</body><body package="PostgreSQLEXDI" selector="answerStreamDismissed">answerStreamDismissed	"^self 	The EXDI has decided to explicitly dismiss the stream resources for this session. I take the que to 	drop my stream and external results. The Oracle EXDI mapping also overrides this method, so that 	gives this approach some credibility."	super answerStreamDismissed.	self resultList: nil.	self resetRowStream.	^self</body><body package="PostgreSQLEXDI" selector="cancelAnswerSetExternal">cancelAnswerSetExternal	"^self 	Cancel any resources associated with the current answer set. This is a no-op for now."	^self</body><body package="PostgreSQLEXDI" selector="getColumnDescriptionExternal:">getColumnDescriptionExternal: aColumn 	| fieldDescription result |	result := self queryResult.	^(result rowDescription notNil and: [aColumn &lt;= result rowDescription fieldDescriptions size])		ifTrue: 			[fieldDescription := result rowDescription fieldDescriptions at: aColumn.			self connection class columnDescriptionClass for: fieldDescription]		ifFalse: [nil]</body><body package="PostgreSQLEXDI" selector="getFieldExternal:">getFieldExternal: aColumn 	"^an Object 	I return the value in aColumn translated per the EDXI rules. The object may be nil."	| field columnTypeName |	field := self currentPostgresRow fields at: aColumn.	field isNil ifTrue: [^nil].	columnTypeName := self currentPostgresRow typeOfColumn: aColumn.	^self valueFrom: field asString ofType: columnTypeName</body><body package="PostgreSQLEXDI" selector="hasAnswerSetExternal">hasAnswerSetExternal	"^a Boolean 	I return true if there are any results available, otherwise I return false. I know that there are results if 	a row description has been returned by PostgreSQL."	^self queryResult rowDescription notNil</body><body package="PostgreSQLEXDI" selector="moreResultsExternal">moreResultsExternal	^false</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="noticeResponsesAreSuppressed:">noticeResponsesAreSuppressed: aBoolean 	"^a Boolean 	I record wether notice responses are suppressed or not. See self&gt;&gt;noticeResponsesAreSuppressed."	noticeResponsesAreSuppressed := aBoolean.	^self</body><body package="PostgreSQLEXDI" selector="resetRowStream">resetRowStream	"^self 	*PRIVATE*	I reset my rowStream to nil. This is done when EXDI chooses to dismiss the external resources used 	by a session/"	rowStream := nil.	^self</body><body package="PostgreSQLEXDI" selector="translationsFromPostgres">translationsFromPostgres	"^an IdentityDictionary 	I return my session specific disctionary of translation blocks. Because different session may wish 	to translate thinfs differently, the blocks must be local to the session."	translationsFromPostgres isNil ifTrue: [translationsFromPostgres := self class translationsFromPostgres copy].	^translationsFromPostgres</body><body package="PostgreSQLEXDI" selector="valueFrom:ofType:">valueFrom: aString ofType: aSymbol 	"^an Object 	I translate aString into something more useful on the basis of aSymbol."	| translationBlock |	translationBlock := self translationsFromPostgres at: aSymbol				ifAbsent: [^aString].	^translationBlock value: self value: aString readStream</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>license</category><body package="PostgreSQLEXDI" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>services</category><body package="PostgreSQLEXDI" selector="passNoticeResponses">passNoticeResponses	"^self 	I pass notice responses on to the EXDI client. See self&gt;&gt;noticeResponsesAreSuppressed."	self noticeResponsesAreSuppressed: false.	^self</body><body package="PostgreSQLEXDI" selector="suppressNoticeResponses">suppressNoticeResponses	"^self 	I suppress notice responses. See self&gt;&gt;noticeResponsesAreSuppressed."	self noticeResponsesAreSuppressed: true.	^self</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>data processing</category><body package="PostgreSQLEXDI" selector="cancel">cancel	"Interrupt the processing of the prepared SQL text or stored procedure.	Note that this method has been added to allow PostgreSQLTest class&gt;&gt;test15 to work.	Changed at the suggestion of Chris Lopeman of CDL -Object Link Inc."	^self isPrepared ifTrue: [self] ifFalse: [super cancel]</body><body package="PostgreSQLEXDI" selector="isPrepared">isPrepared	"Answer true if the receiver has prepared SQL.	Note that this method has been added to allow PostgreSQLTest class&gt;&gt;test15 to work.	Changed at the suggestion of Chris Lopeman of CDL -Object Link Inc."	^self state == #prepared</body><body package="PostgreSQLEXDI" selector="rowCount">rowCount	"^an IntegerAnswer an Integer representing the number of rows affected by the previous query.  Valid only after the query has been answered.  You can uncomment the implementation below, if you like, but it's not accurate and may be worse than useless.Making this work correctly *is* on the list of things to do.Note that PostgreSQLEXDITest class&gt;&gt;test08 has been modified to not use &gt;&gt;rowCount for now.Note that the current active implementation is taken from GLORP most likely written by Alan Knight."	"^self queryResult rows size"	^resultList queryResults first completedResponses inject: 0		into: [:sum :each | sum + (each commandTag tokensBasedOn: Character space) last asNumber]	"^PostgreSQLEXDIException 		raiseSignal: 'Sorry, &gt;&gt;rowCount is not implemented yet for PostgreSQL'"</body></methods><methods><class-id>PostgreSQLEXDISession class</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="connectionClass">connectionClass	"^ PostgreSQLEXDIConnection class 	I return the PostgreSQL connection class."	^PostgreSQLEXDIConnection</body></methods><methods><class-id>PostgreSQLEXDISession class</class-id> <category>value translation</category><body package="PostgreSQLEXDI" selector="resetTranslationsFromPostgres">resetTranslationsFromPostgres	"^self 	I reset my dictionary of translations. This is really only a developers tool. It's needed to pick up new 	implementations of the translation blocks which would otherwise be cached."	"PostgreSQLEXDISession resetTranslationsFromPostgres"	translationsFromPostgres := nil.	^self</body><body package="PostgreSQLEXDI" selector="translationsFromPostgres">translationsFromPostgres	"^an IdentityDictionary 	I return my dictionary of translations keyed by PostgreSQL data type. I delegate this to my class."	translationsFromPostgres isNil ifTrue: [translationsFromPostgres := self buildTranslationsFromPostgres].	^translationsFromPostgres</body></methods><methods><class-id>PostgreSQLEXDISession class</class-id> <category>value translation private</category><body package="PostgreSQLEXDI" selector="buildTranslationsFromPostgres">buildTranslationsFromPostgres	"^an IdentityDictionary 	I return a dictionary of blocks keyed on the PostgreSQL data type symbol."	| translations |	translations := IdentityDictionary new.	translations at: #bool put: [:aSession :aStream | aStream next == $t].	translations at: #box put: self fromBoxBlock.	translations at: #bpchar put: [:aSession :aStream | aStream contents].	translations at: #bytea put: [:aSession :aStream | self byteaFrom: aStream for: aSession].	translations at: #char put: [:aSession :aStream | aStream contents].	translations at: #cidr put: [:aSession :aStream | aStream contents].	translations at: #circle put: self fromCircleBlock.	translations at: #date put: self fromDateBlock.	translations at: #float4 put: self fromFloatBlock.	translations at: #float8 put: self fromFloatBlock.	translations at: #inet put: [:aSession :aStream | aStream contents].	translations at: #integer put: [:aSession :aStream | aStream asNumber].	translations at: #int2 put: [:aSession :aStream | aStream contents asNumber].	translations at: #int4 put: [:aSession :aStream | aStream contents asNumber].	translations at: #int8 put: [:aSession :aStream | aStream contents asNumber].	translations at: #interval put: self fromIntervalBlock.	translations at: #lseg put: self fromLineSegmentBlock.	translations at: #macaddr put: [:aSession :aStream | aStream contents].	translations at: #name put: [:aSession :aStream | aStream contents].	translations at: #numeric put: [:aSession :aStream | (aStream contents , 's') asNumber].	translations at: #oid put: [:aSession :aStream | aStream contents asNumber].	translations at: #path put: self fromPathBlock.	translations at: #point put: self fromPointBlock.	translations at: #polygon put: self fromPathBlock.	translations at: #regproc put: [:aSession :aStream | aStream contents].	translations at: #text put: [:aSession :aStream | aStream contents].	translations at: #time put: self fromTimeBlock.	translations at: #timestamp put: self fromTimestampBlock.	translations at: #timestamptz put: self fromTimestamptzBlock.	translations at: #varchar put: [:aSession :aStream | aStream contents].	^translations</body><body package="PostgreSQLEXDI" selector="byteaFrom:for:">byteaFrom: aStream for: aSession 	"^a ByteArray 	I return a ByteArray created from the contents of aStream in the context of aSession."	| readStream decodedString |	readStream := Base64EncodingReadStream onStream: aStream.	decodedString := readStream upToEnd.	^decodedString</body><body package="PostgreSQLEXDI" selector="fromBoxBlock">fromBoxBlock	"^a Block 	I return the block that can pull a Rectangle from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'box'. The block returns a Rectangle."	^	[:aSession :aStream | 	| originPoint cornerPoint |	originPoint := self fromPointBlock value: aSession value: (aStream upTo: $)) readStream.	cornerPoint := self fromPointBlock value: aSession value: (aStream upTo: $]) readStream.	Rectangle origin: originPoint corner: cornerPoint]</body><body package="PostgreSQLEXDI" selector="fromCircleBlock">fromCircleBlock	"^a Block 	I return the block that can pull a Circle from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'circle'. The block returns a Circle."	^	[:aSession :aStream | 	| center radius |	aStream upTo: $&lt;.	center := self fromPointBlock value: aSession value: (aStream upTo: $)) readStream.	aStream upTo: $,.	radius := (aStream upTo: $&gt;) asNumber.	Circle center: center radius: radius]</body><body package="PostgreSQLEXDI" selector="fromDateBlock">fromDateBlock	"^a Block 	I return the block that can pull a Date from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'date'. The block returns a Date."	^	[:aSession :aStream | 	| year monthIndex day |	year := (aStream upTo: $-) asNumber.	monthIndex := (aStream upTo: $-) asNumber.	day := aStream upToEnd asNumber.	Date		newDay: day		monthNumber: monthIndex		year: year]</body><body package="PostgreSQLEXDI" selector="fromFloatBlock">fromFloatBlock	"^a Block 	I return the block that can pull a Double from a stream, where that stream contains a string in the 	form defined for the PostgreSQL types 'float4' and 'float8'. The block returns a Double."	^[:aSession :aStream | (aStream contents , 'd') asNumber]</body><body package="PostgreSQLEXDI" selector="fromIntervalBlock">fromIntervalBlock	"^a Block 	I return the block that can pull an interval from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'interval'. The block returns the integer number of seconds in 	the 	interval."	^	[:aSession :aStream | 	| totalSeconds |	totalSeconds := (aStream upTo: $ ) asNumber * 86400.	totalSeconds := totalSeconds + ((aStream upTo: $:) asNumber * 3600).	totalSeconds := totalSeconds + ((aStream upTo: $:) asNumber * 60).	totalSeconds + aStream upToEnd asNumber]</body><body package="PostgreSQLEXDI" selector="fromLineSegmentBlock">fromLineSegmentBlock	"^a Block 	I return the block that can pull a LineSegment from a stream, where that stream contains a string in 	the form defined for the PostgreSQL type 'lseg'. The block returns a LineSegment."	^	[:aSession :aStream | 	| start end |	aStream upTo: $[.	start := self fromPointBlock value: aSession value: (aStream upTo: $,) readStream.	end := self fromPointBlock value: aSession value: (aStream upTo: $]) readStream.	LineSegment from: start to: end]</body><body package="PostgreSQLEXDI" selector="fromPathBlock">fromPathBlock	"^a Block 	I return the block that can pull a Polyline from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'path'. The block returns a Polyline. The format of the string is 	'((x,y),(x,y) ...)' for closed paths, and '[(x,y),(x,y) ...]' for open paths. I don't really care because I 	make them both onto a Polyline."	^	[:aSession :aStream | 	| vertices |	vertices := OrderedCollection new.	aStream skip: 1.	aStream upTo: $(.	[aStream atEnd]		whileFalse: 			[aStream skip: -1.			vertices add: (self fromPointBlock value: aSession value: (aStream upTo: $)) readStream).			aStream upTo: $(].	Polyline vertices: vertices asArray]</body><body package="PostgreSQLEXDI" selector="fromPointBlock">fromPointBlock	"^a Block 	I return the block that can pull a Point from a stream, where that stream contains a string in the form 	defined for the PostgreSQL type 'point'."	^	[:aSession :aStream | 	| x y |	aStream upTo: $(.	x := (aStream upTo: $,) asNumber.	y := (aStream upTo: $)) asNumber.	Point x: x y: y]</body><body package="PostgreSQLEXDI" selector="fromTimeBlock">fromTimeBlock	"^a Block 	I return the block that can pull a Time from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'time'. The block returns a Time."	^[:aSession :aStream | Time readFrom: aStream]</body><body package="PostgreSQLEXDI" selector="fromTimestampBlock">fromTimestampBlock	"^a Block I return the block that can pull a Timestamp from a stream, where that stream contains a string in  the form defined for the PostgreSQL type 'timestamp'. The block returns a Timestamp.Note that this is a very crude implementation.  You really must check this and modify it to suit your configuration of PostgreSQL."	^[:aSession :aStream | 	| date time milliseconds |	date := self fromDateBlock		value: aSession		value: (aStream upTo: $ ) readStream.	time := self fromTimeBlock		value: aSession		value: (aStream upTo: $ ) readStream.	milliseconds := aStream upToEnd asNumber.	(Timestamp fromDate: date andTime: time) millisecond: milliseconds]</body><body package="PostgreSQLEXDI" selector="fromTimestamptzBlock">fromTimestamptzBlock	"^a Block I return the block that can pull a Timestamp from a stream, where that stream contains a string in the form defined for the PostgreSQL type 'timestampz'. The block returns a Timestamp.Note that this is a very crude implementation.  You really must check this and modify it to suit your configuration of PostgreSQL."	^[:aSession :aStream | 	| date time milliseconds |	date := self fromDateBlock		value: aSession		value: (aStream upTo: $ ) readStream.	time := self fromTimeBlock		value: aSession		value: (aStream next: 8) readStream.	milliseconds := aStream upToEnd asNumber.	(Timestamp fromDate: date andTime: time) millisecond: milliseconds]</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="connection">connection	^connection</body><body package="PostgreSQLEXDI" selector="environment">environment	"^a String 	I return my environment string. This specifies where the target database service is, and how to get 	to it. Typically this means database name, host and port number. If the environment is nil, I initialize 	to the default environment as known to my class."	super environment isNil ifTrue: [self environment: self class defaultEnvironment].	^super environment</body><body package="PostgreSQLEXDI" selector="environment:">environment: aString 	"^self 	I override my superclass behaviour to make the 'map logical' stuff work. The thing is, it's in the 	VisualWorks EXDI manual, but the EXDI implementation seems to just ignore it - good grief!"	super environment: (self class mapLogical: aString).	^self</body><body package="PostgreSQLEXDI" selector="environmentParameters">environmentParameters	"^a PostgreSQLEXDIEnvironmentString 	I return an environment string structure which knows how to get the host name, port number and 	database name out of a raw envionment string."	environmentParameters isNil ifTrue: [environmentParameters := PostgreSQLEXDIEnvironmentString on: self environment].	^environmentParameters</body><body package="PostgreSQLEXDI" selector="parameterSet">parameterSet	"^a ParameterSet 	I return a parameter set based on the values 	given when I was created."	parameterSet isNil		ifTrue: 			[parameterSet := ConnectionParameterSet new.			parameterSet				host: self hostName;				port: self portNumber;				databaseName: self databaseName;				userName: self username;				password: self password].	^parameterSet</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>private</category><body package="PostgreSQLEXDI" selector="databaseName">databaseName	"^a String 	I return the name of the database I represent a connection to."	^self environmentParameters databaseName</body><body package="PostgreSQLEXDI" selector="hostName">hostName	"^a String 	I return the hostname of the machine running the postgresql backend. If the user has not specified a 	host name, the default is 'localhost'."	| userSpecifiedHostName |	userSpecifiedHostName := self environmentParameters hostName.	^userSpecifiedHostName isNil		ifTrue: ['localhost']		ifFalse: [userSpecifiedHostName]</body><body package="PostgreSQLEXDI" selector="portNumber">portNumber	"^an Integer 	I return the port number that the server is running on. If the user has not specified a port number, I 	use the default for PostgreSQL which is 5432."	| userSpecifiedPortNumber |	userSpecifiedPortNumber := self environmentParameters portNumber.	^userSpecifiedPortNumber isNil		ifTrue: [5432]		ifFalse: [userSpecifiedPortNumber]</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>license</category><body package="PostgreSQLEXDI" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>private-library calls</category><body package="PostgreSQLEXDI" selector="acquireExternal">acquireExternal	"^self 	Acquire the external resources. VW3.0 implementation."	connection := PostgreSQLConnection using: self parameterSet.	^self</body><body package="PostgreSQLEXDI" selector="acquireExternal:">acquireExternal: aPassword 	"^self 	Acquire the external resources. VW5i implementation."	self parameterSet password: aPassword.	^self acquireExternal</body><body package="PostgreSQLEXDI" selector="beginExternal">beginExternal	"^self 	I perform my superclass actions, then I start the transaction using 'begin'. I could have used 'begin 	transaction' or 'begin work' but the backend would just ignore the second word, so why bother sending 	it?	Note that this method did use 'each disconnect' for each participant which broke PostgreSQLTest class&gt;&gt;test15.	Changed to 'each cancel' at the suggestion of Chris Lopeman of CDL -Object Link Inc."	super beginExternal.	self participantsDo: [:each | each cancel].	(self getSession)		prepare: 'begin';		execute;		answer;		disconnect.	^self</body><body package="PostgreSQLEXDI" selector="commitExternal">commitExternal	"^self 	I perform my superclass actions and check that it's really OK to commit. Then I commit the 	transaction using 'commit'. I could have used 'commit transaction' or 'commit work' but the backend 	would just ignore the second word, so why bother sending it?	Note that this method did use 'each disconnect' for each participant which broke PostgreSQLTest class&gt;&gt;test15.	Changed to 'each cancel' at the suggestion of Chris Lopeman of CDL -Object Link Inc."	super commitExternal ifFalse: [^self].	self participantsDo: [:each | each cancel].	(self getSession)		prepare: 'commit';		execute;		answer;		disconnect.	^self</body><body package="PostgreSQLEXDI" selector="dismissExternal">dismissExternal	"^self 	I close the connection."	self connection close</body><body package="PostgreSQLEXDI" selector="rollbackExternal">rollbackExternal	"^self 	I perform my superclass actions and check that it's really OK to rollback. Then I rollback the 	transaction using 'rollback'. I could have used 'rollback transaction' or 'rollback work' but the backend 	would just ignore the second word, so why bother sending it?	Note that this method did use 'each disconnect' for each participant which broke PostgreSQLTest class&gt;&gt;test15.	Changed to 'each cancel' at the suggestion of Chris Lopeman of CDL -Object Link Inc."	super rollbackExternal ifFalse: [^self].	self participantsDo: [:each | each cancel].	(self getSession)		prepare: 'rollback';		execute;		answer;		disconnect</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>services</category><body package="PostgreSQLEXDI" selector="encoding">encoding	"^a SymbolThis is just a convinience method for getting the string encoding to the used by my underlying connection."	^self connection stringEncodingName</body><body package="PostgreSQLEXDI" selector="encoding:">encoding: aSymbol 	"^selfThis is just a convinience method for setting the string encoding to the used by my underlying connection."	^self connection encoding: aSymbol</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>accessing</category><body package="PostgreSQLEXDI" selector="columnDescriptionClass">columnDescriptionClass	^PostgreSQLEXDIColumnDescription</body><body package="PostgreSQLEXDI" selector="kind">kind	"^a Symbol 	I return a symbol representing the type ofDMBS the I provide services for. That would be 	PostgreSQL databases for me."	^#PostgreSQL</body><body package="PostgreSQLEXDI" selector="sessionClass">sessionClass	^PostgreSQLEXDISession</body><body package="PostgreSQLEXDI" selector="storeBroker">storeBroker	"^a Class 	I return the class of the Store Broker I am to work with. In order for this to be useful, it must have 	been initialized by an external entity (the Store broker itself when loaded?)."	^storeBroker</body><body package="PostgreSQLEXDI" selector="storeBroker:">storeBroker: aClass 	"^self 	I record the class of the Store Broker I am to work with."	storeBroker := aClass.	^self</body><body package="PostgreSQLEXDI" selector="version">version	"^aString 	I return a String which identifies the version of the EXDI layer I'm 	using. For some reason, my superclass implementation does *not* 	return a String. This looks like a bug."	^super version asString , (String with: Character cr) , 'PostgreSQL EXDI layer ' , PostgreSQLDriverLicense license versionName</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>activation</category><body package="PostgreSQLEXDI" selector="pause">pause	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to 	indefinitely suspend operations. I don't take any special action to pause, so this is a no-op for me."	^self</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>private-activation</category><body package="PostgreSQLEXDI" selector="install">install	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to 	take the necessary steps for returning from a snapshot. Notify dependents 	when fully installed so that appropriate action may be taken."	^self</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>private-accessing</category><body package="PostgreSQLEXDI" selector="transactionClass">transactionClass	"a Class 	I return the class to be used for transaction objects associated with my instances. In this case, 	that's the PostgreSQLTransaction class"	^PostgreSQLEXDITransaction</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>tracing</category><body package="PostgreSQLEXDI" selector="traceLevel:">traceLevel: newTraceLevel 	"^self 	I set the level of tracing that is enabled for this class to anInteger. I 	get my superclass to do it's thing, then I set the PostgreSQL logging 	facilities to do the right thing. This method is rather horrible and 	procedural - please let me know if you think of a better way of 	doing this."	super traceLevel: newTraceLevel.	(self traceCollector isNil or: [newTraceLevel isZero])		ifTrue: [traceLog notNil				ifTrue: 					[traceLog close.					traceLog := nil.					^self]].	traceLog isNil ifTrue: [traceLog := PostgreSQLConnectionLog logEverythingTo: self traceCollector].	^self</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>signal constants</category><body package="PostgreSQLEXDI" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	"^PostgreSQLError	I answer the most general external database error signal. Because I work 	with ANSI exceptions this is a subclass of Exception rather than an 	instance of Signal. Note that there is a more general exception class (i.e. 	PostgreSQLException) but not all exceptions are errors (e.g. a 	PostgreSQLNoticeResponse), hence PostgreSQLError being returned here."	^PostgreSQLError</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class></st-source>