<?xml version="1.0"?><st-source><!-- Name: OSkLoggerComment: Copyright @2006 Bruce BadgerMade available under the LGPL This package contains a logging mechanism where a single OSkLog can be used to gather log reports from many sources and write the information to a number targets (or none, if you like).DbIdentifier: bb20100717DbTrace: 335DevelopmentPrerequisites: #(#(#any 'Sport' '') #(#any 'OSkStreams' ''))PackageName: OSkLoggerParcel: #('OSkLogger')PrerequisiteParcels: #(#('Sport' '') #('OSkStreams' ''))PrintStringCache: (1 169,bbadger)Version: 1 169Date: 11:31:23 PM November 8, 2010 --><time-stamp>From VisualWorksÂ®, 7.7 of November 25, 2009 on November 8, 2010 at 11:31:23 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OSkLogEntry</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><class><name>OSkLogTarget</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>log </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><class><name>OSkFileLogTarget</name><environment>Smalltalk</environment><super>OSkLogTarget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename fileStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><class><name>OSkByteArrayLogEntry</name><environment>Smalltalk</environment><super>OSkLogEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subjectWriteStream reportStream outputPosition latestLogFragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><comment><class-id>OSkByteArrayLogEntry</class-id><body>Many log entries exists fleetingly.  They are created to represent a value or an exception, and once they have been written to the targets they are of no further use.  This entry hangs around and can be handed to a target many times.The idea is that we need to get the logged bytes out to the targets as they are being added, so the this entry will submit itself to the target log for output every time something (a ByteArray) is added to it.  This is important in cases where a stream of bytes is causing an application to crash - we need to know the bytes that did it.</body></comment><class><name>OSkStringLogEntry</name><environment>Smalltalk</environment><super>OSkLogEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><class><name>OSkStreamLogTarget</name><environment>Smalltalk</environment><super>OSkLogTarget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><class><name>OSkExceptionLogEntry</name><environment>Smalltalk</environment><super>OSkLogEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception comment stackDumpString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><class><name>OSkTranscriptLogTarget</name><environment>Smalltalk</environment><super>OSkLogTarget</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><class><name>OSkLogSwitch</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logTargets logQueue </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>OSkLogger</category><attributes><package>OSkLogger</package></attributes></class><comment><class-id>OSkLogSwitch</class-id><body>Instances of this class accept log entries for many sources and direct them to many (zero or more) targets.  It really is just a switch.To add a new target to the switch use &gt;&gt;addTarget:.  All targets are sent all log entries.Any number of sources may log through a single OSkLogSwitch as every log entry is first written to a queue before being handed to the targets for rendering.</body></comment><methods><class-id>OSkLogEntry</class-id> <category>services</category><body package="OSkLogger" selector="log">log	"^selfI log myself to the default OSkLog.  This is a lazy but easy way to use logging."	OSkLogSwitch default log: self.	^self</body><body package="OSkLogger" selector="timestampString">timestampString	^self timestamp asRFC1123String</body></methods><methods><class-id>OSkLogEntry</class-id> <category>rendering</category><body package="OSkLogger" selector="closingTag">closingTag	"^a StringI return the tag which closes the external XML representation of myself."	| targetStream |	targetStream := WriteStream on: String new.	targetStream		nextPut: $&lt;;		nextPut: $/;		nextPutAll: self tagName;		nextPut: $&gt;.	^targetStream contents</body><body package="OSkLogger" selector="tagName">tagName	"^a StringMy tag name is always my class name."	^self class name</body><body package="OSkLogger" selector="writeClosingTagTo:">writeClosingTagTo: targetStream 	"^selfI write the tag which identifies the kind of entry being logged."	targetStream		cr;		nextPutAll: self closingTag.	^self</body><body package="OSkLogger" selector="writeContentTo:">writeContentTo: targetStream 	^self subclassResponsibility</body><body package="OSkLogger" selector="writeOpeningTagTo:">writeOpeningTagTo: targetStream 	"^selfI write the tag which identifies the kind of entry being logged."	targetStream		cr;		nextPut: $&lt;;		nextPutAll: self class name;		nextPut: $&gt;.	^self</body><body package="OSkLogger" selector="writeTimestampTo:">writeTimestampTo: targetStream 	targetStream		cr;		nextPutAll: '&lt;t&gt;';		nextPutAll: self timestampString;		nextPutAll: '&lt;/t&gt;'.	^self</body><body package="OSkLogger" selector="writeTo:">writeTo: targetStream 	self writeOpeningTagTo: targetStream.	self writeTimestampTo: targetStream.	self writeContentTo: targetStream.	self writeClosingTagTo: targetStream.	^self</body></methods><methods><class-id>OSkLogEntry</class-id> <category>initialize-release</category><body package="OSkLogger" selector="for:">for: aSubject 	"^selfMy subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>OSkLogEntry</class-id> <category>accessing</category><body package="OSkLogger" selector="timestamp">timestamp	"^an OSkTimestampThis is the time of the event associated with the log entry."	timestamp isNil ifTrue: [timestamp := SpTimestamp now].	^timestamp</body></methods><methods><class-id>OSkLogEntry class</class-id> <category>instance creation</category><body package="OSkLogger" selector="for:">for: aSubject 	"^an OSkLogEntryIt is always be possible to create a log entry in this way, even if the norm is to use another method."	^self new for: aSubject</body></methods><methods><class-id>OSkLogTarget</class-id> <category>handling</category><body package="OSkLogger" selector="handle:">handle: anEntry 	"^selfI write anEntry to my target stream and then flush the stream to make sure that the information is written out (the flush only makes any difference for external streams)."	anEntry writeTo: self targetStream.	self flush.	^self</body></methods><methods><class-id>OSkLogTarget</class-id> <category>initialize-release</category><body package="OSkLogger" selector="for:">for: anOSkLog 	anOSkLog addTarget: self.	log := anOSkLog.	^self</body></methods><methods><class-id>OSkLogTarget</class-id> <category>services</category><body package="OSkLogger" selector="close">close	"^selfThis is a no-op by default, but my subclasses may override."	^self</body><body package="OSkLogger" selector="flush">flush	"^selfMy subclasses may override this if some specific action is required to force the logged information to non-volatile media."	^self</body><body package="OSkLogger" selector="targetStream">targetStream	"^a Stream-like objectI return the stream to which characters can be written.  This is how things end up being logged."	^self subclassResponsibility</body></methods><methods><class-id>OSkFileLogTarget</class-id> <category>accessing</category><body package="OSkLogger" selector="filename">filename	^filename</body><body package="OSkLogger" selector="fileStream">fileStream	"^selfIf my filestream has not been established yet, or if my filestream is closed, I create a new write stream on my filename."	(fileStream isNil or: [fileStream closed]) 		ifTrue: [fileStream := self filename appendStream].	^fileStream</body></methods><methods><class-id>OSkFileLogTarget</class-id> <category>services</category><body package="OSkLogger" selector="close">close	self fileStream close.	^self</body><body package="OSkLogger" selector="flush">flush	"^selfI really want to make sure that the logged information makes it to the file on disk."	^self fileStream flush</body><body package="OSkLogger" selector="targetStream">targetStream	"^an ExternalWriteStreamAs a file based log target, by target is the file stream, of course!"	^self fileStream</body></methods><methods><class-id>OSkFileLogTarget</class-id> <category>initialize-release</category><body package="OSkLogger" selector="onFileNamed:for:">onFileNamed: aString for: anOSkLog 	self for: anOSkLog.	filename := SpFilename named: aString.	^self</body></methods><methods><class-id>OSkFileLogTarget class</class-id> <category>instance creation</category><body package="OSkLogger" selector="onFileNamed:for:">onFileNamed: aString for: anOSkLog 	^self new onFileNamed: aString for: anOSkLog</body></methods><methods><class-id>OSkByteArrayLogEntry</class-id> <category>accessing</category><body package="OSkLogger" selector="outputPosition">outputPosition	"^an IntegerThis is the point that we are up to in writing the subject bytes out to the log.The weird initialization is because in GemStone, streams reset to position 1, not 0.  Initializing in this way wastes a stream and a "	outputPosition isNil ifTrue: [outputPosition := SpEnvironment streamStartPosition].	^outputPosition</body><body package="OSkLogger" selector="outputPosition:">outputPosition: anObject	outputPosition := anObject</body><body package="OSkLogger" selector="subjectWriteStream">subjectWriteStream	"^a WriteStreamI return the stream I use to capture the bytes to be logged. I would use a ReadWrite stream but this is not available in GemStone, so I just use a write stream.  Any read access to the stream must be to a snapshot of the contents (i.e. the contents per &gt;&gt;contents)."	subjectWriteStream isNil 		ifTrue: [subjectWriteStream := WriteStream on: (ByteArray new: 1024)].	^subjectWriteStream</body></methods><methods><class-id>OSkByteArrayLogEntry</class-id> <category>initialize-release</category><body package="OSkLogger" selector="for:">for: aByteArray 	"^selfI add aByteArray to my subject ByteArray."	self subjectWriteStream nextPutAll: aByteArray.	self timestamp.	^self</body><body package="OSkLogger" selector="initializeFrom:">initializeFrom: aStream 	"^self or nilI try to parse my state from aStream.  If I can, I initialize myself.  If I can't get the information I need from aStream, I return nil."	| entryStream |	aStream throughAll: self class name.	entryStream := OSkSubStream onStream: aStream upToAll: self closingTag.	entryStream atEnd 		ifFalse: 			[self parseTimestampFrom: entryStream.			self parseSubjectByteArrayFrom: entryStream].	^(timestamp isNil or: [subjectWriteStream isNil]) 		ifTrue: [nil]		ifFalse: [self]</body></methods><methods><class-id>OSkByteArrayLogEntry</class-id> <category>rendering</category><body package="OSkLogger" selector="bytesPerLineOnOutput">bytesPerLineOnOutput	^20</body><body package="OSkLogger" selector="flush">flush	"^selfI write the next part of the report on the subject ByteArray to the default log."	^self flushTo: OSkLogSwitch default</body><body package="OSkLogger" selector="flushTo:">flushTo: aLog 	"^selfI write the next part of the report on the subject ByteArray to aLog."	aLog log: self.	^self</body><body package="OSkLogger" selector="writeContentTo:">writeContentTo: targetStream 	"^selfI write my latest fragment to the target.  If more bytes are added to me, there will be a new 'latest fragment'. "	targetStream nextPutAll: self latestLogFragment.	^self</body></methods><methods><class-id>OSkByteArrayLogEntry</class-id> <category>private</category><body package="OSkLogger" selector="latestLogFragment">latestLogFragment	"^selfI return the latest fragment of the ByteArray I represent.  This fragment is good until more content is added."	latestLogFragment isNil 		ifTrue: 			[| sourceStream targetStream |			sourceStream := ReadStream on: self subjectWriteStream contents.			sourceStream position: self outputPosition.			targetStream := WriteStream 						on: (String new: self subjectWriteStream contents size).			self writeLatestLogFragmentFrom: sourceStream to: targetStream.			self outputPosition: sourceStream position.			latestLogFragment := targetStream contents].	^latestLogFragment</body><body package="OSkLogger" selector="resetLogFragment">resetLogFragment	"^selfIt looks like some new bytes have been added.  This means that the latest log fragment is no longer valid.  For now, I just nil it."	latestLogFragment := nil.	^self</body><body package="OSkLogger" selector="writeByte:asHexPairTo:">writeByte: subjectByte asHexPairTo: targetStream 	| hexDigits |	hexDigits := #($0 $1 $2 $3 $4 $5 $6 $7 $8 $9 $A $B $C $D $E $F).	subjectByte &lt; 16 		ifTrue: [targetStream nextPut: $0]		ifFalse: [targetStream nextPut: (hexDigits at: subjectByte // 16 + 1)].	targetStream nextPut: (hexDigits at: subjectByte \\ 16 + 1).	^self</body><body package="OSkLogger" selector="writeLatestLogFragmentFrom:to:">writeLatestLogFragmentFrom: sourceStream to: targetStream 	"^selfI write a crude XML representation of the remaining bytes in sourceStream to targetStream."	[sourceStream atEnd] whileFalse: 			[| byteCount characterStream |			byteCount := 1.			characterStream := WriteStream on: (String new: self bytesPerLineOnOutput).			targetStream				cr;				nextPutAll: '&lt;x&gt;'.			[sourceStream atEnd or: [byteCount &gt; self bytesPerLineOnOutput]] 				whileFalse: 					[| subjectByte |					subjectByte := sourceStream next.					self writeByte: subjectByte asHexPairTo: targetStream.					characterStream 						nextPut: (SpEnvironment characterFromInteger: subjectByte).					byteCount := byteCount + 1].			targetStream nextPutAll: '&lt;/x&gt;'.			self writePrintableCharactersFrom: characterStream to: targetStream]</body><body package="OSkLogger" selector="writePrintableCharactersFrom:to:">writePrintableCharactersFrom: characterStream to: targetStream 	"^selfI write the printable characters from characterStream to the targetStream replacing non-printable characters with a dot.  For now, I only consider alpha and numeric characters to be 'printable'.  This avoids any funny business with having the characters use in an XML string - as indeed they are."	targetStream nextPutAll: '&lt;p&gt;'.	characterStream contents do: 			[:aCharacter | 			aCharacter isAlphaNumeric 				ifTrue: [targetStream nextPut: aCharacter]				ifFalse: [targetStream nextPut: $.]].	targetStream nextPutAll: '&lt;/p&gt;'.	^self</body></methods><methods><class-id>OSkByteArrayLogEntry</class-id> <category>services</category><body package="OSkLogger" selector="addOctets:">addOctets: aByteArray 	"^selfI add the octets to my underlying stream.  This means that the current log fragment (if any) is no longer valid."	self subjectWriteStream nextPutAll: aByteArray.	self resetLogFragment.	^self</body><body package="OSkLogger" selector="contents">contents	"^a ByteArrayI return the current contents of my subjectWriteStream."	^self subjectWriteStream contents</body><body package="OSkLogger" selector="log:">log: aByteArray 	"^selfI add the bytes to my underlying stream, and immediately flush these to the default log."	self addOctets: aByteArray.	self flush.	^self</body></methods><methods><class-id>OSkByteArrayLogEntry</class-id> <category>private-parsing</category><body package="OSkLogger" selector="parseSubjectByteArrayFrom:">parseSubjectByteArrayFrom: aStream 		[aStream throughAll: '&lt;x&gt;'.	aStream atEnd] whileFalse: 				[| hexString bytes |				hexString := aStream upToAll: '&lt;/x&gt;'.				bytes := SpEnvironment byteArrayFromHexString: hexString.				self subjectWriteStream nextPutAll: bytes].	^self</body><body package="OSkLogger" selector="parseTimestampFrom:">parseTimestampFrom: aStream 	aStream throughAll: '&lt;t&gt;'.	aStream atEnd 		ifFalse: 			[timestamp := SpTimestamp fromRFC1123String: (aStream upToAll: '&lt;/t&gt;')].	^self</body></methods><methods><class-id>OSkByteArrayLogEntry class</class-id> <category>services</category><body package="OSkLogger" selector="entriesFromLogStream:">entriesFromLogStream: aStream 	"^an OrderedCollectionI parse the contents of aStream and create (well, re-create) instances of myself that represent these log entries in the stream."	| entries nextEntry |	entries := OrderedCollection new.	[(nextEntry := self new initializeFrom: aStream) isNil] 		whileFalse: [entries add: nextEntry].	^entries</body><body package="OSkLogger" selector="entriesFromLogString:">entriesFromLogString: aString 	"^an OrderedCollectionI parse the contents of aString and create (well, re-create) instances of myself that represent the log entries represented in aString."	| sourceStream |	sourceStream := ReadStream on: aString.	^self entriesFromLogStream: sourceStream</body></methods><methods><class-id>OSkStringLogEntry</class-id> <category>accessing</category><body package="OSkLogger" selector="string">string	"^a StringThis is the string value that I represent the logging of."	^string</body></methods><methods><class-id>OSkStringLogEntry</class-id> <category>initialize-release</category><body package="OSkLogger" selector="for:">for: aString 	string := aString.	self timestamp.	^self</body></methods><methods><class-id>OSkStringLogEntry</class-id> <category>rendering</category><body package="OSkLogger" selector="writeContentTo:">writeContentTo: targetStream 	targetStream nextPutAll: self string.	^self</body></methods><methods><class-id>OSkStringLogEntry class</class-id> <category>instance creation</category><body package="OSkLogger" selector="for:">for: aString 	"^an OSkLogEntryI return a new instance of myself on aString."	^self new for: aString</body></methods><methods><class-id>OSkStringLogEntry class</class-id> <category>services</category><body package="OSkLogger" selector="log:">log: aString 	"^an OSkLogEntryCreate a new instance of myself and log it on the defaukt OSkLog."	| newEntry |	newEntry := self for: aString.	OSkLogSwitch default log: newEntry.	^newEntry</body></methods><methods><class-id>OSkStreamLogTarget</class-id> <category>services</category><body package="OSkLogger" selector="targetStream">targetStream	"^a Stream"	^targetStream</body></methods><methods><class-id>OSkStreamLogTarget</class-id> <category>initialize-release</category><body package="OSkLogger" selector="on:for:">on: aStream for: anOSkLogSwitch 	self for: anOSkLogSwitch.	targetStream := aStream.	^self</body></methods><methods><class-id>OSkStreamLogTarget class</class-id> <category>instance creation</category><body package="OSkLogger" selector="on:for:">on: aStream for: anOSkLogSwitch 	^self new on: aStream for: anOSkLogSwitch</body></methods><methods><class-id>OSkExceptionLogEntry</class-id> <category>accessing</category><body package="OSkLogger" selector="comment">comment	^comment</body><body package="OSkLogger" selector="exception">exception	^exception</body></methods><methods><class-id>OSkExceptionLogEntry</class-id> <category>private</category><body package="OSkLogger" selector="stackDumpString">stackDumpString	"^aStringNote that I cache the stack dump string because I may be logged to more than one target, and if one of the targets is the system transcript, then the report will change from one target to another ... because the stack dump includes the transcript at the time that the report is generated!"	stackDumpString isNil 		ifTrue: 			[| targetStream |			targetStream := WriteStream on: String new.			self writeStackDumpTo: targetStream.			stackDumpString := targetStream contents].	^stackDumpString</body><body package="OSkLogger" selector="writeStackDumpTo:">writeStackDumpTo: targetStream 	SpEnvironment 		writeStackDumpForException: self exception		context: self exception initialContext		to: targetStream.	^self</body></methods><methods><class-id>OSkExceptionLogEntry</class-id> <category>initialize-release</category><body package="OSkLogger" selector="for:">for: anException 	"^selfI record the subject exception and set the timestamp."	exception := anException.	self timestamp.	^self</body><body package="OSkLogger" selector="for:withComment:">for: anException withComment: aString 	self for: anException.	comment := aString.	^self</body></methods><methods><class-id>OSkExceptionLogEntry</class-id> <category>rendering</category><body package="OSkLogger" selector="writeContentTo:">writeContentTo: targetStream 	self comment isNil ifFalse: [targetStream nextPutAll: self comment].	targetStream		cr;		cr;		nextPutAll: self stackDumpString.	^self</body></methods><methods><class-id>OSkExceptionLogEntry class</class-id> <category>instance creation</category><body package="OSkLogger" selector="for:">for: anException 	"^an OSkLogEntryI return a new instance of myself on anException."	^self for: anException withComment: nil</body><body package="OSkLogger" selector="for:withComment:">for: anException withComment: aString 	"^an OSkLogEntryI return a new instance of myself on anException."	^self new for: anException withComment: aString</body></methods><methods><class-id>OSkExceptionLogEntry class</class-id> <category>services</category><body package="OSkLogger" selector="log:">log: anException 	"^an OSkLogEntryCreate a new instance of myself and log it on the defaukt OSkLog."	| newEntry |	newEntry := self for: anException.	OSkLogSwitch default log: newEntry.	^newEntry</body></methods><methods><class-id>OSkTranscriptLogTarget</class-id> <category>services</category><body package="OSkLogger" selector="targetStream">targetStream	"^OSkTranscriptFor me, the Transcript is my target stream.  Easy."	^SpTranscript</body></methods><methods><class-id>OSkTranscriptLogTarget class</class-id> <category>instance creation</category><body package="OSkLogger" selector="for:">for: anOSkLog 	^self new for: anOSkLog</body></methods><methods><class-id>OSkLogSwitch</class-id> <category>accessing</category><body package="OSkLogger" selector="logQueue">logQueue	"^an OrderedCollectionI return the log queue.  All log entries are added to this queue from here are written out to the targets.   Really, this should almost always be empty as log entries should be removed as soon as they appear."	logQueue isNil ifTrue: [logQueue := OrderedCollection new].	^logQueue</body><body package="OSkLogger" selector="logTargets">logTargets	"^an OrderedCollectionThis is the collection of log targets.  As each log entry is taken from the queue the targets are offered the entry in order.  What they do with the log entry is up to them."	logTargets isNil ifTrue: [logTargets := OrderedCollection new].	^logTargets</body></methods><methods><class-id>OSkLogSwitch</class-id> <category>services</category><body package="OSkLogger" selector="addTarget:">addTarget: aLogTarget 	"^selfI add aLogTarget to the end of my collection of targets."	(self logTargets includes: aLogTarget) 		ifFalse: [self logTargets addLast: aLogTarget].	^self</body><body package="OSkLogger" selector="close">close	"^selfI close and remove all my targets.  This means any further entries will simly be dropped."	self logTargets copy do: 			[:aTarget | 			aTarget close.			self logTargets remove: aTarget].	^self</body><body package="OSkLogger" selector="log:">log: anEntry 	"^selfI add an Entry to my log queue.  I do this in the expectation that it will immediately be taken from the queue and offered to the log targets."	"self logQueue addLast: anEntry."	self propogate: anEntry.	^self</body><body package="OSkLogger" selector="logString:">logString: aString 	"^selfThis is a helper method that cretes a string log entry and logs it to me."	self log: (OSkStringLogEntry for: aString).	^self</body></methods><methods><class-id>OSkLogSwitch</class-id> <category>private</category><body package="OSkLogger" selector="propogate:">propogate: anEntry 	"^selfI go through my list of targets in order, and inform each of anEntry."	self logTargets do: [:aLogTarget | aLogTarget handle: anEntry].	^self</body></methods><methods><class-id>OSkLogSwitch class</class-id> <category>services</category><body package="OSkLogger" selector="default">default	"^an OSkLogSwitchI return my default instance, which I create if necessary.  The default instance just has a Transcript target."	default isNil ifTrue: [default := self transcriptOnlyLogSwitch].	^default</body><body package="OSkLogger" selector="default:">default: anOSkLogSwitch 	"^selfI set the image-wide default log switch to anOSkLogSwitch."	default := anOSkLogSwitch.	^self</body><body package="OSkLogger" selector="fileOnlyLogSwitchOnFileNamed:">fileOnlyLogSwitchOnFileNamed: aFileNameString	"^an OSkLogSwitchI create a log switch that logs to the named file only.  Of course, once the switch is created more targets can be added, but this is a quick and simple of setting up logging to a file."	| newSwitch |	newSwitch := self new.	OSkFileLogTarget onFileNamed: aFileNameString for: newSwitch.	^newSwitch</body><body package="OSkLogger" selector="log:">log: anOSkLogEntry 	^self default log: anOSkLogEntry</body><body package="OSkLogger" selector="logString:">logString: aString 	^self default logString: aString</body><body package="OSkLogger" selector="makeDefaultLogToFileNamed:">makeDefaultLogToFileNamed: aString 	"^selfThis is an easy way to get logging to start working and to write to a file.  After running this, all you need to do is create a log entry and tell it to &gt;&gt;log.  e.g. (OSkStringLogEntry on: 'Hello, World.') log."	"OSkLogSwitch makeDefaultLogToFileNamed: 'qaz.log'.       OSkStringLogEntry log: 'Hello, World.'.       OSkLogSwitch resetDefault"	| newSwitch |	newSwitch := OSkLogSwitch new.	OSkFileLogTarget onFileNamed: aString for: newSwitch.	self default: newSwitch.	^self</body><body package="OSkLogger" selector="resetDefault">resetDefault	"^selfI drop my current default instance."	default isNil 		ifFalse: 			[default close.			default := nil].	^self</body><body package="OSkLogger" selector="transcriptOnlyLogSwitch">transcriptOnlyLogSwitch	"^an OSkLogSwitchI create a log switch that logs to the transcript only.  Of course, once the switch is created more targets can be added, but this is a quick and simple of setting up logging to the Transcript."	| newSwitch |	newSwitch := self new.	OSkTranscriptLogTarget for: newSwitch.	^newSwitch</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>