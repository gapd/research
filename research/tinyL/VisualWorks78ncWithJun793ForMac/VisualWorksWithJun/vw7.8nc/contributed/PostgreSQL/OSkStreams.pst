<?xml version="1.0"?><st-source><!-- Name: OSkStreamsComment: Copyright @2006 Bruce BadgerMade available under the LGPL This package contains stream support classesDbIdentifier: bb20100717DbTrace: 297PackageName: OSkStreamsParcel: #('OSkStreams')PrintStringCache: (1 024,bbadger)Version: 1 024Date: 11:31:18 PM November 8, 2010 --><time-stamp>From VisualWorksÂ®, 7.7 of November 25, 2009 on November 8, 2010 at 11:31:18 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OSkSubStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection absolutePosition absoluteStartPosition absoluteEndPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkStreams</package></attributes></class><comment><class-id>OSkSubStream</class-id><body>OSkSubStream instances stream over a subset of the elements already being handled by another stream or OSkSubStream.An OSkSubStream appears to behave as if it were created on a copy of a subset of the elements in the collection of the original stream, but no copy is taken unnecessarily.  The fact that a copy is not always made is the key benefit of the OSkSubstream.  Very handy for parsing data from a socket.A copy of the data *is* made if the original stream is not an OSkSubstream.  In future this should be extended to only take a copy if the underlying data is transient (e.g. flowing from a socket).The OSkSubSteam knows the absolute start position and end position in the underlying collection of the elements it is to stream over.  It knows the current absolute position too.  A &gt;&gt;reset takes the current absolutePosition to the absoluteStartPosition.  After a reset &gt;&gt;position returns 0.  A sub stream is &gt;&gt;atEnd when the absolutePosition == the absoluteEndPosition.</body></comment><methods><class-id>OSkSubStream</class-id> <category>accessing</category><body package="OSkStreams" selector="absoluteEndPosition">absoluteEndPosition	"^an IntegerI return the absolute index of the last element in my collection."	^absoluteEndPosition</body><body package="OSkStreams" selector="absolutePosition">absolutePosition	"^an IntegerI return my current absolute position in the underlying collection."	absolutePosition isNil 		ifTrue: [absolutePosition := self absoluteStartPosition].	^absolutePosition</body><body package="OSkStreams" selector="absoluteStartPosition">absoluteStartPosition	"^an IntegerI return the absolute starting position for this stream.  This position is immediately before the first element of the sub collection being streamed over.  e.g. if the absolute index of the first element is 1 then the absolute start position would be 0."	^absoluteStartPosition</body><body package="OSkStreams" selector="collection">collection	"^a CollectionI return the collection I'm acting as a stream upon."	^collection</body></methods><methods><class-id>OSkSubStream</class-id> <category>services</category><body package="OSkStreams" selector="atEnd">atEnd"^a BooleanI return true if my absolute position is past the last element, i.e. if there are no more elements available using &gt;&gt;next."	^self absolutePosition &gt;= self absoluteEndPosition</body><body package="OSkStreams" selector="contents">contents	"^a CollectionI return a copy of my collection from my start index to my end index.  This mimicks the way that a stream responses to &gt;&gt;contents."	^self collection copyFrom: absoluteStartPosition to: absoluteEndPosition</body><body package="OSkStreams" selector="delegateToStreamUsing:">delegateToStreamUsing: aBlock 	"^a collectionThis is very much a 'make it work' implementation.  It may even 'work right' but it sure won't 'work fast'.  Also it looks like it will run off the end of the underlying collection (well, run past the absolute end position, anyway).  Not good."	| searchStream result |	searchStream := ReadStream on: self collection.	searchStream position: self absolutePosition.	result := aBlock value: searchStream.	absolutePosition := searchStream position.	^result</body><body package="OSkStreams" selector="length">length	"^an IntegerSub-streams have length.  They are never open ended.  They might be empty though, in which case the absolute start and end position are the same."	^self absoluteEndPosition - self absoluteStartPosition</body><body package="OSkStreams" selector="next">next	"^an ElementI return the next element from the collection I represent a stream upon.  If we are already at the end, just return nil."	^self atEnd 		ifTrue: [nil]		ifFalse: 			[absolutePosition := self absolutePosition + 1.			self collection 				at: self absolutePosition - SpEnvironment streamStartPosition]</body><body package="OSkStreams" selector="next:">next: numberOfElements 	"^an OrderedCollectionI return anArray containing numberOfElements elements which are the next numberOfElements from my collection.  If there are not enough elements, I return as many as exist."	| availableElements result |	availableElements := numberOfElements 				max: self absoluteEndPosition - self absolutePosition.	result := self collection class new: availableElements.	1 to: availableElements		do: [:resultIndex | result at: resultIndex put: self next].	^result</body><body package="OSkStreams" selector="peek">peek	"^an ElementI return the next element from the collection I represent a stream upon without incrementing the position.  If we are already at the end, just return nil."	^self atEnd ifTrue: [nil] ifFalse: [self collection at: self absolutePosition + 1]</body><body package="OSkStreams" selector="position">position	"^an IntegerThis is the apparant position to the user of this sub stream.  So,  &gt;&gt;position after a &gt;&gt;reset is SpEnvironment streamStartPosition."	^self absolutePosition - self absoluteStartPosition + SpEnvironment streamStartPosition</body><body package="OSkStreams" selector="position:">position: anInteger 	"^selfI am being asked to set my position to anInteger.  This is not the &gt;&gt;absolutePosition in my underlying collection, but the apparent position to a user of this sub stream.  After a reset, &gt;&gt;position is zero, so here we need to set the &gt;&gt;absolutePosition to the reset position + anInteger such that &gt;&gt;position returns anInteger."	self reset.	self skip: anInteger - SpEnvironment streamStartPosition.	^self</body><body package="OSkStreams" selector="reset">reset	"^selfI set my current position to my starting position, well, I let the lazy initialization on position do it in fact."	absolutePosition := nil.	^self</body><body package="OSkStreams" selector="skip:">skip: anInteger 	"^selfI increment my position by anInteger, but not beyond the atEnd position."	absolutePosition := absoluteEndPosition min: self absolutePosition + anInteger.	^self</body><body package="OSkStreams" selector="throughAll:">throughAll: aCollection 	"^a collectionThis is very much a 'make it work' implementation.  It may even 'work right' but it sure won't 'work fast'."	^self delegateToStreamUsing: [:aStream | aStream throughAll: aCollection]</body><body package="OSkStreams" selector="upTo:">upTo: anObject 	"^a collectionReturn a collection of the same class as my &gt;&gt;collection containing elements from my &gt;&gt;collection up to but not unluding anObject.  My position is left either atEnd or after anObject which ever is the higher position."	| targetStream nextElement |	targetStream := WriteStream on: self collection class new.		[self atEnd not and: 			[nextElement := self next.			(nextElement == anObject) not]] 			whileTrue: [targetStream nextPut: nextElement].	^targetStream contents</body><body package="OSkStreams" selector="upToAll:">upToAll: aCollection 	"^a collectionThis is very much a 'make it work' implementation.  It may even 'work right' but it sure won't 'work fast'."	^self delegateToStreamUsing: [:aStream | aStream upToAll: aCollection]</body><body package="OSkStreams" selector="upToEnd">upToEnd	"^a CollectionI return the elements from my client stream from the current position up to my endIndex."	^self next: self absoluteEndPosition - self absolutePosition</body></methods><methods><class-id>OSkSubStream</class-id> <category>testing</category><body package="OSkStreams" selector="isOSkSubStream">isOSkSubStream	^true</body></methods><methods><class-id>OSkSubStream</class-id> <category>initialize-release</category><body package="OSkStreams" selector="onCollection:absoluteStartPosition:absoluteEndPosition:">onCollection: aCollection absoluteStartPosition: startPosition absoluteEndPosition: endPosition 	"^selfI initialize myself to represent a sub-stream on aCollection from startPosition to endPosition."	endPosition &lt; startPosition 		ifTrue: [SpError raiseSignal: 'Negative range'].	collection := aCollection.	absoluteStartPosition := startPosition.	absoluteEndPosition := endPosition.	^self</body></methods><methods><class-id>OSkSubStream</class-id> <category>death row</category><body package="OSkStreams" selector="relativePosition">relativePosition	"^an IntegerI return my position as an relative offset in my collection.  The relative position after a reset it 0."	^SpEnvironment madeObsoleteBy: [self position]</body><body package="OSkStreams" selector="startIndex">startIndex	^SpEnvironment madeObsoleteBy: [self absoluteStartPosition]</body></methods><methods><class-id>OSkSubStream class</class-id> <category>instance creation</category><body package="OSkStreams" selector="onNext:fromStream:">onNext: numberOfElements fromStream: aStream 	"^an OSkSubStreamI return a new instance of myself that represents a sub-stream on the collection of aStream from the current postion in aStream for the next.  aStream is left positioned after the last of the numberOfElements.Note that because not all Smalltalk implementations have their streams reset to zero, we need to use SpEnvironment streamStartPosition to get the reset position."	^aStream class == self 		ifTrue: 			[| startPosition |			startPosition := aStream absolutePosition.			aStream skip: numberOfElements.			self new 				onCollection: aStream collection				absoluteStartPosition: startPosition				absoluteEndPosition: startPosition + numberOfElements]		ifFalse: 			[| startPosition |			startPosition := SpEnvironment streamStartPosition.			self new 				onCollection: (aStream next: numberOfElements)				absoluteStartPosition: startPosition				absoluteEndPosition: startPosition + numberOfElements 						- SpEnvironment streamStartPosition]</body><body package="OSkStreams" selector="onStream:upTo:">onStream: aStream upTo: anObject 	"^an OSkSubStreamI return a new instance of myself on aStream from it's current position up to the element before the first occurance of anObject."	^self onStream: aStream upToAll: (Array with: anObject)</body><body package="OSkStreams" selector="onStream:upToAll:">onStream: aStream upToAll: aCollection 	"^an OSkSubStreamI return a new instance of myself on aStream from it's current position up to the element before the first occurance of aCollection."	"OSkSubStream onStream: (ReadStream on: 'From the start to &lt; there') upToAll: '&lt; ther' "	^(aStream respondsTo: #position:) 		ifTrue: 			[| startPosition subStreamLength |			startPosition := aStream position.			aStream upToAll: aCollection.			subStreamLength := aStream position - startPosition.			aStream position: startPosition.			self onNext: subStreamLength fromStream: aStream]		ifFalse: 			[| subCollection |			subCollection := aStream upToAll: aCollection.			self onNext: subCollection size fromStream: (ReadStream on: subCollection)]</body></methods><methods><class-id>OSkSubStream class</class-id> <category>examples</category><body package="OSkStreams" selector="example01">example01	"Create a substream on a part of a read stream on a string"	"OSkSubStream example01"	| subStream |	subStream := OSkSubStream onStream: (ReadStream on: 'a=1&amp;do=Go') upTo: $$.	subStream reset position == SpEnvironment streamStartPosition 		ifFalse: [1 halt: 'oops'].	(subStream upTo: $=) = 'a' ifFalse: [1 halt: 'oops'].	^self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>