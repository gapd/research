<?xml version="1.0"?><st-source><!-- Name: TextHighlightingComment: The highlighting controller supports multiple highlighters, each will get a chance to do its highlighting on the editor text. The highlighters should be written so that they do their best to not trash any other highlighting that's already present in the text. The order in which the highlighters will be invoked is determined by highlighter ordering (see Highlighter>>order).There is a dedicated Highlighter class to simplify global highlighter management when loading and unloading highlighting packages. It provides class side #install and #uninstall methods that can be invoked from package postLoad/preUnload actions for example.A highlighter can be attached to a TextEditorController as follows:	SpellingHighlighter on: aTextEditorController.This is usually done in the #postBuildWith: method of the associated application model. However this not sufficient to resolve code conflicts between multiple independent highlighters, they would still have to fight over the postBuildWith: method. Therefore this package also adds a pragma based mechanism to avoid these kinds of code conflicts. This mechanism is invoked through ApplicationModel>>addHighlighters which will collect all methods with <highlighter> pragma in the application model class and execute them all, expecting they each add their own respective highlighter. So for example to add spell checking to the BrowserCommentTool, we make sure that its postBuildWith: calls 'self addHighlighters'. Then we add an extension method to the tool class along these lines:	addSpellingHighlighter		<highlighter>		SpellingHighlighter on: self textControllerThis way another highlighting package can also add similar kind of extension method and it will be picked up automatically (as long as #addHighlighters is invoked once somehow).In general new highlighting capability is added by creating a new Highlighter subclass. See HyperlinkHighlighting or SpellcheckerHighlighting for examples. There's also a DelegatingHighlighter which can be used when the actual highlighting logic needs to be done by some other object. The RBCodeHighlighting package uses a DelegatingHighlighter.DbIdentifier: bear73DbTrace: 305621DevelopmentPrerequisites: #(#(#any 'Browser-BrowserUI' '') #(#any 'Tools-Workspace' '') #(#any 'Tools-Settings-VW' ''))PackageName: TextHighlightingParcel: #('TextHighlighting')ParcelName: TextHighlightingPrerequisiteParcels: #(#('Browser-BrowserUI' '') #('Tools-Workspace' '') #('Tools-Settings-VW' ''))PrintStringCache: (7.8 - 1001,smichael)Version: 7.8 - 1001Post-Load Block: 	[:package | UI.Highlighter install]Pre-Unload Block: 	[:package | Highlighter uninstall]Date: 12:09:17 PM October 15, 2010 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (oct10.3) of October 15, 2010 on October 15, 2010 at 12:09:17 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Highlighter</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller order active </inst-vars><class-inst-vars>highlight </class-inst-vars><imports></imports><category></category><attributes><package>TextHighlighting</package></attributes></class><comment><class-id>UI.Highlighter</class-id><body>Anything that responds to #highlight: returning a highlighted text can be a high-lighter.  General instances of this class, however, make it easier to clean up before unload.  See SpellingHighlighter in SpellcheckerHighlighting.  The highlight flag of the Highlighter class is a master switch - it enables or disables /all/ highlighting.  Each subclass uses this variable locally for all instances of itself independently of other peer high-lighters.Subclass Responsibility:Subclasses must implement the following messages:	highlighting		highlight:	Performs the highlighting requiredInstance Variables	active		&lt;ValueModel&gt;						Whether the highlighter is active	controller	&lt;HighlightingTextEditorController&gt;	The target controller of the receiver	order		&lt;Number&gt;							Relative order of applying highlightersClass Instance Variables	highlight	&lt;Boolean&gt;							Whether this class of highlighter is enabled</body></comment><class><name>DelegateHighlighter</name><environment>UI</environment><super>UI.Highlighter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>TextHighlighting</package></attributes></class><comment><class-id>UI.DelegateHighlighter</class-id><body>DelegateHighlighter is a high-lighter that delegates the actual highlighting action to a subordinate object, usually to provide specialized context.  Delegates are useful to make unloading easier.  The delegated tool must support the "highlight:from:" and "unhighlight:from:" methods.Instance Variables:	tool		&lt;Object&gt;	The object that will do the highlighting.</body></comment><class><name>HighlightingTextEditorController</name><environment>UI</environment><super>UI.TextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>highlightingProcess highlighters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBCodeHighlighting</category><attributes><package>TextHighlighting</package></attributes></class><comment><class-id>UI.HighlightingTextEditorController</class-id><body>I am a normal TextEditor, but with a background process which applies highlighting to the contents of the editor after any edit.  If there are any highlighters subscribed to the controller, they are applied in order, according to the highlighters order property.Instance Variables	highlightingProcess	&lt;Process&gt; 				Process used to annotate the text	highlighters			&lt;IdentitySet of: Object&gt;	Highlighters that will each get a turn to highlight the editor textClass Variables	IgnoreErrors		&lt;Boolean&gt;	suppress exceptions raised in the highlighting process	RefreshDelay	&lt;Integer&gt;	the delay from any editing activity in a highlighting text widget to when the text is re-highlighted</body></comment><shared-variable><name>RefreshDelay</name><environment>UI.HighlightingTextEditorController</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>500</initializer><attributes><package>TextHighlighting</package></attributes></shared-variable><shared-variable><name>IgnoreErrors</name><environment>UI.HighlightingTextEditorController</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>true</initializer><attributes><package>TextHighlighting</package></attributes></shared-variable><methods><class-id>UI.Highlighter</class-id> <category>testing</category><body package="TextHighlighting" selector="isActive">isActive	"Answer whether the receiver is active."	^active value</body></methods><methods><class-id>UI.Highlighter</class-id> <category>accessing</category><body package="TextHighlighting" selector="controller">controller	^controller</body><body package="TextHighlighting" selector="controller:">controller: anObject	controller := anObject</body><body package="TextHighlighting" selector="identity">identity	"Answer the identity of the receiver, to prevent duplicates."	^self class</body><body package="TextHighlighting" selector="order">order	^order ifNil: [order := self defaultOrder]</body><body package="TextHighlighting" selector="order:">order: anObject	order := anObject</body></methods><methods><class-id>UI.Highlighter</class-id> <category>defaults</category><body package="TextHighlighting" selector="defaultActivation">defaultActivation	"Answer the default activation value."	active := false</body><body package="TextHighlighting" selector="defaultOrder">defaultOrder	"Answer the default order for the receiver's class."	^self class defaultOrder</body></methods><methods><class-id>UI.Highlighter</class-id> <category>installation</category><body package="TextHighlighting" selector="install">install	"Install the receiver into it's controller.  If there is another instance of the	 receiver's class already defined, the receiver will replace it."	controller addHighlighter: self.</body><body package="TextHighlighting" selector="uninstall">uninstall	"Remove the receiver from the controller's set of highlighters.  This does not	 ensure that highlighting is visibly remove from any displayed text, as actual	 highlighting modifies the emphasis and there is no way to back it out."	controller removeHighlighter: self.</body></methods><methods><class-id>UI.Highlighter</class-id> <category>configuring</category><body package="TextHighlighting" selector="beActive">beActive	"Assign whether the receiver is active."	active := true</body><body package="TextHighlighting" selector="beInactive">beInactive	"Assign whether the receiver is active."	active := false</body></methods><methods><class-id>UI.Highlighter</class-id> <category>comparing</category><body package="TextHighlighting" selector="&lt;">&lt; aHighlighter	"Order the receiver and the argument."	^self order &lt; aHighlighter order</body><body package="TextHighlighting" selector="&lt;=">&lt;= aHighlighter	"Order the receiver and the argument."	^self order &lt;= aHighlighter order</body></methods><methods><class-id>UI.Highlighter</class-id> <category>highlighting</category><body package="TextHighlighting" selector="highlight:">highlight: aText	^self subclassResponsibility</body></methods><methods><class-id>UI.Highlighter</class-id> <category>initialize-release</category><body package="TextHighlighting" selector="initialize">initialize	"Initialize the receiver by setting it active.  When highlighters are constructed,	 they probably will be conditionalized in some way, which will replace a static	 boolean with a block."	self defaultActivation</body></methods><methods><class-id>UI.Highlighter class</class-id> <category>startup</category><body package="TextHighlighting" selector="shutdown">shutdown	"The receiver is being deactivated.  Remove instances of the receiver from all	 appropriate places.  Note that this will not remove emphasis from open views."	self allGeneralInstances do: [:hl | hl uninstall]</body><body package="TextHighlighting" selector="startup">startup	"The receiver is being activated.  Apply instances of the receiver to all	 appropriate places."</body></methods><methods><class-id>UI.Highlighter class</class-id> <category>installation</category><body package="TextHighlighting" selector="install">install	"Install the receiver or a subclass.  This case requires that subclasses be	 reinstalled because the shadow loader will unload an existing package if	 it is being reloaded, causing all controllers to be reverted.  A test case for	 this is to have a browser open on a tool that's showing a hyperlink.  The	 active link will be refreshed to plain text without this descent."	self startup.	self subclasses do: [:hlc | hlc install].	HighlightingTextEditorController refreshAllControllers</body><body package="TextHighlighting" selector="uninstall">uninstall	self shutdown.	self == Highlighter		ifTrue: [HighlightingTextEditorController revertAllControllers]</body></methods><methods><class-id>UI.Highlighter class</class-id> <category>accessing</category><body package="TextHighlighting" selector="highlight">highlight	^highlight ifNil: [highlight := true]</body><body package="TextHighlighting" selector="highlight:">highlight: anObject	highlight := anObject</body></methods><methods><class-id>UI.Highlighter class</class-id> <category>instance creation</category><body package="TextHighlighting" selector="on:">on: aHighlightingController	"Add a highlighter to the argument controller."	^aHighlightingController notNil		ifTrue:			[(self new)				controller: aHighlightingController;				initialize;				install;				yourself]</body></methods><methods><class-id>UI.Highlighter class</class-id> <category>defaults</category><body package="TextHighlighting" selector="defaultOrder">defaultOrder	"Answer the default order for the receiver's class."	^100</body></methods><methods><class-id>UI.Highlighter class</class-id> <category>testing</category><body package="TextHighlighting" selector="isHighlighting">isHighlighting	"Answer whether the receiver is highlighting, which takes into account the master	 highlighting flag."	^self highlight and: [Highlighter highlight]</body></methods><methods><class-id>UI.DelegateHighlighter</class-id> <category>accessing</category><body package="TextHighlighting" selector="tool">tool	^tool</body><body package="TextHighlighting" selector="tool:">tool: anObject	tool := anObject</body></methods><methods><class-id>UI.DelegateHighlighter</class-id> <category>highlighting</category><body package="TextHighlighting" selector="highlight:">highlight: aText	"Tool must check activation in order to remove highlighting."	^self isActive		ifTrue: [tool highlight: aText from: self]		ifFalse: [tool unhighlight: aText from: self]</body></methods><methods><class-id>UI.DelegateHighlighter class</class-id> <category>instance creation</category><body package="TextHighlighting" selector="on:for:">on: controller for: tool	^controller notNil		ifTrue:			[(super on: controller)				tool: tool;				yourself]</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>private</category><body package="TextHighlighting" selector="displayWithHighlightedText:">displayWithHighlightedText: localText 	| interval oldBounds newBounds selectionShowing start stop |	(selectionShowing := view selectionShowing) 		ifTrue: 			["if something is selected, remember what and deselect"			"NOTE! if no deselect happens, then the selection is displayed at a wrong offset,			so when the selection is drawn again at the end of the method, there may be some			strange text-fragment next to the new selection, which looks ugly"			start := self selectionStartIndex copy.			stop := self selectionStopIndex copy.			view deselect].	interval := self getIntervalForUpdateFromOriginal: self text				withNew: localText.	oldBounds := view boundsOfInterval: interval.	self text setString: self text string setRuns: localText runs.	newBounds := view boundsOfInterval: interval.	view invalidateRectangle: (oldBounds merge: newBounds) repairNow: true.	selectionShowing 		ifTrue: 			["if something has been selected, select it again and show that"			view selectFrom: start to: stop.			view selectAndScroll]		ifFalse: [view selectAt: self selectionStartIndex]</body><body package="TextHighlighting" selector="getIntervalForUpdateFromOriginal:withNew:">getIntervalForUpdateFromOriginal: oldText withNew: newText 	| start stop |	oldText size ~= newText size 		ifTrue: 			["this should not happen"			^1 to: oldText size].	start := 1.	stop := oldText size.	"get the first difference in the runs and select the previous word"	[start &lt;= stop and: [(oldText runs at: start) == (newText runs at: start)]] 		whileTrue: [start := start + 1].	start := self move: start homeWithCtrl: false.	"get the first difference from the end in the runs and select the following word"	[stop &gt; start and: [(oldText runs at: stop) == (newText runs at: stop)]] 		whileTrue: [stop := stop - 1].	stop := self move: stop endWithCtrl: false.	^start to: stop</body><body package="TextHighlighting" selector="replaceFrom:to:with:">replaceFrom: start to: stop with: aText 	self stopHighlighting.	super 		replaceFrom: start		to: stop		with: aText.	self startHighlighting: self class refreshDelay</body><body package="TextHighlighting" selector="startHighlighting:">startHighlighting: delay 	| uiPriority |	self stopHighlighting.	uiPriority := Processor activePriority.	highlightingProcess := 			[| win event localText |			(Delay forMilliseconds: delay) wait.			"Forked process highlights copied text.  Highlighting is placed			 in an error wrapper to avoid throwing exceptions."			localText := self highlighters asSortedCollection inject: self text into:							[:highlightedText :textHighlighter |							[textHighlighter highlight: highlightedText copy]								on:	Error								do:	[:ex |									self class ignoreErrors ifFalse: [ex pass].									Transcript show: (#HighlighterException1p2p &lt;&lt; #browser &gt;&gt; 'Highlighter Exception:  highlighter=&lt;1p&gt;, error=&lt;2p&gt;.&lt;n&gt;'															expandMacrosWith: textHighlighter with: ex messageText).									ex return: highlightedText]].			"WindowManager process moves result to UI"			event := 					[localText string = self text string 						ifTrue: 							[self displayWithHighlightedText: localText							"self text setString: self text string setRuns: localText runs.							self view resetSelections.							self view invalidateRectangle: self view bounds repairNow: true"]].						[win := view ifNotNil: [:v | v topComponent].			(win notNil and: [win isInvalid not and: [win isOpen and:[win windowManager notNil]]]) 				ifTrue: [event uiEventFor: win]] 					valueAtPriority: uiPriority	"so window cannot be closed during this block"] 					forkAt: uiPriority - 1</body><body package="TextHighlighting" selector="stopHighlighting">stopHighlighting	highlightingProcess notNil		ifTrue:			[highlightingProcess terminate.			highlightingProcess := nil]</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>selecting</category><body package="TextHighlighting" selector="selectAndScroll">selectAndScroll	"Our thread may invoke this after our view is no longer open, so be safe about updating the view."	self resetTypein.	view isOpen ifTrue: [view selectAndScroll]</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>initialize-release</category><body package="TextHighlighting" selector="highlighters">highlighters	^highlighters ifNil: [ highlighters := IdentityDictionary new ].</body><body package="TextHighlighting" selector="resetState">resetState	self stopHighlighting.	super resetState.	self startHighlighting: 0</body></methods><methods><class-id>UI.HighlightingTextEditorController</class-id> <category>accessing</category><body package="TextHighlighting" selector="addHighlighter:">addHighlighter: aHighlighter	^self highlighters at: aHighlighter identity put: aHighlighter</body><body package="TextHighlighting" selector="removeHighlighter:">removeHighlighter: aHighlighter	"Remove the argument from the set of highlighters.  Note that this will not	 correctly refresh the view, because highlighting applied by the removed	 highlighter cannot be stripped.  The text must be refreshed."	| result |	result := self highlighters removeKey: aHighlighter identity ifAbsent: [].	self highlighters isEmpty ifTrue: [self class revertController: self].	^result</body></methods><methods><class-id>UI.HighlightingTextEditorController class</class-id> <category>installation</category><body package="TextHighlighting" selector="refreshAllControllers">refreshAllControllers	self allInstances do:		[:editor |		editor view topComponent notNil			ifTrue:				[[editor startHighlighting: 0.				editor view invalidate]					uiEventFor: editor view topComponent]]</body><body package="TextHighlighting" selector="revertAllControllers">revertAllControllers	self allInstances do: [:each | self revertController: each]</body><body package="TextHighlighting" selector="revertController:">revertController: aController 	| new |	aController class = self ifFalse: [^aController].	new := superclass new.	1 to: superclass instSize		do: [:i | new instVarAt: i put: (aController instVarAt: i)].	new become: aController</body></methods><methods><class-id>UI.HighlightingTextEditorController class</class-id> <category>accessing</category><body package="TextHighlighting" selector="ignoreErrors">ignoreErrors	^IgnoreErrors ifNil: [IgnoreErrors := true]</body><body package="TextHighlighting" selector="ignoreErrors:">ignoreErrors: anObject	IgnoreErrors := anObject</body><body package="TextHighlighting" selector="refreshDelay">refreshDelay	^RefreshDelay ifNil: [RefreshDelay := 250]</body><body package="TextHighlighting" selector="refreshDelay:">refreshDelay: anObject	RefreshDelay := anObject</body></methods><methods><class-id>UI.HighlightingTextEditorController class</class-id> <category>instance creation</category><body package="TextHighlighting" selector="replaceController:with:">replaceController: aController with: aHighlighter	| new |	aController class = superclass ifFalse: [^aController].	new := self new.	1 to: superclass instSize do: [:i | new instVarAt: i put: (aController instVarAt: i)].	new addHighlighter: aHighlighter.	new become: aController.	aController startHighlighting: 0.	^aController</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>accessing</category><body package="TextHighlighting" selector="addHighlighter:">addHighlighter: aHighlighter	HighlightingTextEditorController replaceController: self with: aHighlighter</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>initialize-release</category><body package="TextHighlighting" selector="highlighters">highlighters	^IdentitySet new</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>accessing</category><body package="TextHighlighting" selector="removeHighlighter:">removeHighlighter: aHighlighter</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>private</category><body package="TextHighlighting" selector="startHighlighting:">startHighlighting: delay 	"Do nothing - prevents exceptions in case a particular text pane does	 not have any highlighters (so has not had its controller converted)."</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>privileged evaluation</category><body package="TextHighlighting" selector="valueAtPriority:">valueAtPriority: priority	| activeProcess oldPriority |	activeProcess := Processor activeProcess.	oldPriority := activeProcess priority.	activeProcess priority: priority.	^self ensure: [activeProcess priority: oldPriority]</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>interface opening</category><body package="TextHighlighting" selector="postBuildWith:">postBuildWith: aBuilder 	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Complete page build actions, including enabling highlighting if appropriate."	super postBuildWith: aBuilder.	(self textEditor)		initializeMenuForCodeWithFileItIn;		doNotHandleLocally: #explain;		autoAccept: false.	(self textEditor respondsTo: #augmentEditorCodeMenu) 		ifTrue: [self textEditor augmentEditorCodeMenu].	self addHighlighters</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>interface opening</category><body package="TextHighlighting" selector="addHighlighters">addHighlighters	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Look for all defined highlighters of the receiver and add them to the text controller,	 which is defined by the receiver."	(Pragma allNamed: #highlighter from: self class to: ApplicationModel) do:		[:pragma | self perform: pragma selector]</body></methods><methods><class-id>Refactory.Browser.BrowserCommentTool class</class-id> <category>installation</category><body package="TextHighlighting" selector="refreshAllInstances">refreshAllInstances	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Highlighting options have changed, so refresh all instances to reformat the contents."	(self allInstances reject: [:tool | tool builder isNil]) do:		[:tool | | view |		view := tool textController view.		view topComponent notNil			ifTrue:				[[tool updateContents.				view invalidate]					uiEventFor: view topComponent]]</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>displaying</category><body package="TextHighlighting" selector="boundsOfInterval:">boundsOfInterval: interval 	| rect |	rect := self characterBlockForIndex: interval first.	interval 		do: [:each | rect := rect merge: (self characterBlockForIndex: each)].	^rect</body></methods><methods><class-id>Refactory.Browser.BrowserTextTool</class-id> <category>interface opening</category><body package="TextHighlighting" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self textController)		autoAccept: false;		continuousAccept: false;		readOnly: self isReadOnly;		selectable: true.	self addHighlighters</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-highlighter</category><body package="TextHighlighting" selector="toolsHighlightEnable">toolsHighlightEnable	"(Highlighter Extension - private - not for general use - may be removed at any time)"	&lt;setting: #(tools highlighter enable)&gt;	^(BooleanSetting 			on: Highlighter			aspect: #highlight)		default: true;		label: #ToolsHighlightEnable &lt;&lt; #browser &gt;&gt; 'Enable all highlighting (master enable)';		helpText: #ToolsHighlightEnableHelpText &lt;&lt; #browser &gt;&gt; 'Indicates whether highlighting should be enabled.  When true, highlighting is enabled as allowed by individual highlighter controls.  When false, all highlighting everywhere is disabled.'</body><body package="TextHighlighting" selector="toolsHighlightIgnoreErrors">toolsHighlightIgnoreErrors	"(Highlighter Extension - private - not for general use - may be removed at any time)"	&lt;setting: #(tools highlighter ignore)&gt;	^(BooleanSetting 			on: HighlightingTextEditorController			aspect: #ignoreErrors)		default: true;		label: #ToolsHighlightIgnoreErrors &lt;&lt; #browser &gt;&gt; 'Ignore exceptions during highlighting';		helpText: #ToolsHighlightIgnoreErrorsHelpText &lt;&lt; #browser &gt;&gt; 'Indicates whether exceptions should be ignored during highlighting.  When true, any exceptions that occur during highlighting are reported to the transcript, and the offending highlighter''s actions are ignored.  When false, exceptions throw a notification window, which permits debugging of the problem.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="TextHighlighting" selector="toolsHighlightPage">toolsHighlightPage	"(Highlighter Extension - private - not for general use - may be removed at any time)"	&lt;settingsPage: #(tools highlighter)&gt;	^ModularSettingsPage new		label: #ToolsHighlighter &lt;&lt; #labels &gt;&gt; 'Highlighter';		icon: (ListIconLibrary visualFor: #formatterSettings);		settings: (self settingsWithPrefix: #(tools highlighter))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-highlighter</category><body package="TextHighlighting" selector="toolsHighlightRefreshDelay">toolsHighlightRefreshDelay	"(Highlighter Extension - private - not for general use - may be removed at any time)"	&lt;setting: #(tools highlighter refreshDelay) position: 80&gt;	^(IntegerSetting 			on: HighlightingTextEditorController 			aspect: #refreshDelay)		default: 250;		label: #ToolsHighlightRefreshDelay &lt;&lt; #browser &gt;&gt; 'Editing refresh delay (ms)';		helpText: #ToolsHighlightRefreshDelayHelpText &lt;&lt; #browser &gt;&gt; 'Specifies the delay from any editing activity in a highlighting text window to when the text is rehighlighted.  The value is specified in milliseconds.  Further activity within the delay resets the delay.  Values less than 250ms are pretty annoying, especially for fast typists and long methods.  Usually, 750-1500ms is the most useful without being overly long.'</body></methods><methods><class-id>UI.ApplicationModel class</class-id> <category>compiling</category><body package="TextHighlighting" selector="highlighterPragmas">highlighterPragmas	&lt;pragmas: #instance&gt;	^#(#highlighter)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ComposedTextView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayContents startBlock stopBlock selectionShowing displaySelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>BrowserTextTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>savedText changed textHolder originalText menuBarMenu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>WorkspacePage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workspace label verboseLabel filename fileTimestamp textModel unacceptedText savedSelection savedFileTimestamp textModelOverride </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ParagraphEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher selectable maxChars </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class></st-source>