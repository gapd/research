<?xml version="1.0"?><st-source><!-- Name: HighlightingStylesComment: StyleDescriptions is a basic but fairly comprehensive implementation of styles.  A style description (or style) is a named and categorized set of emphases applied selectively to text by a highlighter.  The style description editor provides a convenient way to edit these through the settings browser.  The name of the style is treated as an emphasis name, similar to #bold or #color, but no arguments are required (like #color) since the style contains all appropriate values.  The style description implementation only handles six basic capabilities:  bold, italic, underline, jagged edge [underline], strike-out, and font/foreground color.  This is not the full list of capabilities added by the ExtraEmphases packages, so some work needs to be done to expand this.  See the comment for StyleDescriptionEditor for ideas.There are a couple of things lacking.  (1) Style sheets, or collections of styles, are managed as a whole.  No conceptual subsets are supported to group styles into logical sets that are manipulated together.  It's currently all or nothing.  (2) Emphases are still tracked by name.  There's nothing inherently wrong with that, since they need to be tracked somehow.  Byte styles are applied like emphases, and maybe that's how they should.  What is missing is tying them together, so that a style has knowledge of all possible emphases and any of them can be set for any style.DbIdentifier: bear73DbTrace: 275860DevelopmentPrerequisites: #(#(#any 'ExtraEmphases' '') #(#any 'TextHighlighting' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #()PackageName: HighlightingStylesParcel: #('HighlightingStyles')ParcelName: HighlightingStylesPrerequisiteParcels: #(#('ExtraEmphases' '') #('TextHighlighting' ''))PrintStringCache: (7.7 - 17,mkobetic)Version: 7.7 - 17Pre-Load Block: 	[:package | #{UI.StyleDescription} ifDefinedDo: [:sdc | sdc uninstall]]Post-Load Block: 	[:package | UI.StyleDescription install]Pre-Unload Block: 	[:package | UI.StyleDescription uninstall]Date: 11:28:51 AM April 26, 2010 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.8 (apr10.2) of April 26, 2010 on April 26, 2010 at 11:28:51 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StyleEditorEmphasisTab</name><environment>Tools</environment><super>Core.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>HighlightingStyles</package></attributes></class><comment><class-id>Tools.StyleEditorEmphasisTab</class-id><body>StyleEditorEmphasisTab is a specification of a tab control widget tab.  In this case, the key is the graphic or visual that is to be used as an icon;  it is not the accessor method to the graphic.  The value is the label string shown on the tab.  Either can be nil.  The spec is the window spec to be shown when this tab is selected.Instance Variables	spec	&lt;Symbol&gt;	The window spec method to supply the content to be displayed.</body></comment><class><name>StyleDescriptionEditor</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>categoryHolder emphasisTabs filterMenu styleHolder styleList styles subbuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>HighlightingStyles</package></attributes></class><comment><class-id>Tools.StyleDescriptionEditor</class-id><body>StyleDescriptionEditor is a "pluggable" emphasis editor.  It allows the user to select various emphasis options and apply them as a unified whole.  Emphases are applied to a single style at a time, and the editor manages a collection of styles as a style sheet.  Support is provided to set or update styles from an external control.StyleDescriptionEditor is not all that flexible, and does not support the full range of emphasis capabilities added with ExtraEmphases.  The is no "simple" solution to the problem, as the UI presented depends on a number of characteristics, not all of which are easily expressed.  The set of possible emphases would need to be dynamic, which means the options on the settings page would not be of a fixed or predictable size.  This defeats the whole purpose of making the settings page straightforward.An alternative would be to augment the existing design slightly by adding a button and marker.  The marker would display if a style contained any "advanced" setting - that is, something other than the current characteristics (bold, italic, etc.).  The button provides access to an advanced emphasis editor that would allow the user to set any of the various attributes available.  This could be defined by pragma, with sufficient extra information to know whether the value is part of a group (underlines), whether the attribute is a color (font/foreground, background), and so on.In future, the full range of extra emphases should be available through pragma declarations and dynamic construction of the highlighting options.Instance Variables	categoryHolder		&lt;ValueModel&gt;		The current filter category	filterMenu			&lt;Menu&gt;			The menu for filtering the styles list	styleHolder			&lt;ValueModel&gt;		The current style, taken from the style list	styleList			&lt;SelectionInList&gt;	The set of style displayed to the user (filtered)	styles				&lt;Array&gt;				The set of all possible styles	subbuilder			&lt;UIBuilder&gt;				Subbuilder for the tab control canvas</body></comment><class><name>StyleDescription</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>category description emphasis name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>HighlightingStyles</package></attributes></class><comment><class-id>Tools.StyleDescription</class-id><body>StyleEmphasis is an encapsulation of a style.  Styles are named, which provides an identification key, and have a description, which is what is displayed in a list.  The emphasis is an emphasis that will be applied to appropriate text, and will either be a symbol, an association whose key is a symbol (for colors), or an array of those for multiple emphases.Instance Variables	description	&lt;String&gt;						Description of the style	category	&lt;String&gt;						Category for grouping styles	emphasis	&lt;Symbol | Association | Array&gt;	The emphasis characteristic(s) to be used	name		&lt;Symbol&gt;						Name or identifier of the styleClass Variables	CurrentStyles		&lt;Array of: StyleDescription&gt;	The current list of all styles that are used for highlighting	StylesToRemove	&lt;Array of: Symbol&gt;			The list of all style names that are or should be removedInstance Method Tags	attribute:			Identifies an accessing method for a highlighting emphasis identified as an XML attribute and supplies its type (#boolean, #string, etc.)	element:			Identifies an accessing method for a highlighting emphasis identified as a subordinate XML element and supplies its content classClass Method Tags	default				Identifies a method that defines a style sheet supplying default settings for one or more styles	style				Identifies a method that defines an individual style description with normal (usual) emphasis	stylesheet:order:	Identifies a method that defines a style sheet (a collection of style emphases) and provides its menu name and display order</body></comment><class><name>StyleDescriptionSetting</name><environment>Tools</environment><super>Tools.SettingType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>HighlightingStyles</package></attributes></class><comment><class-id>Tools.StyleDescriptionSetting</class-id><body>StyleDescriptionSetting is a special setting type for StyleDescriptions.</body></comment><class><name>StylesheetSettingsPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>emphasisEditor enabledClasses sampleHolder samplesMenu stylesHolder stylesMenu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>HighlightingStyles</package></attributes></class><comment><class-id>Tools.StylesheetSettingsPage</class-id><body>CodeHighlightingSettingsPage is a specialized settings page for specifying code highlighting emphases.  If contains a style description editor for manipulating individual styles, and a text editor for showing the highlighted text.Instance Variables	emphasisEditor		&lt;StyleEmphasisEditor&gt;	The style editor object (supports subcanvas)	sampleHolder		&lt;ValueHolder&gt;			Holder for currently selected sample text	sampleMenu		&lt;Menu&gt;				Available sample selection menu	styleHolder			&lt;BufferedValueHolder&gt;	Holder for edited styles	styleMenu			&lt;Menu&gt;				Style load/save menuInstance Method Tags	action:			Identifies a method that should be invoked, with its execution order, when style changes are applied	sample:order:	Identifies methods that provide sample strings or text that will be emphasized appropriately</body></comment><class><name>NullHighlighter</name><environment>UI</environment><super>UI.Highlighter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>HighlightingStyles</package></attributes></class><comment><class-id>UI.NullHighlighter</class-id><body>NullHighlighter does absolutely nothing except force the controller to be a highlighting text controller.</body></comment><shared-variable><name>CurrentStyles</name><environment>Tools.StyleDescription</environment><private>false</private><constant>false</constant><category>variables</category><initializer>nil</initializer><attributes><package>HighlightingStyles</package></attributes></shared-variable><shared-variable><name>StylesToRemove</name><environment>Tools.StyleDescription</environment><private>false</private><constant>false</constant><category>variables</category><initializer>nil</initializer><attributes><package>HighlightingStyles</package></attributes></shared-variable><methods><class-id>Tools.StyleEditorEmphasisTab</class-id> <category>printing</category><body package="HighlightingStyles" selector="printOn:">printOn: aStream 	"Append to the argument, aStream, the two elements of the 	Association separated by a right arrow."	aStream								print: self class;		nextPutAll: ' key: ';		print: self key;		nextPutAll: ' value: ';		print: self value;		nextPutAll: ' spec: ';		print: self spec</body></methods><methods><class-id>Tools.StyleEditorEmphasisTab</class-id> <category>accessing</category><body package="HighlightingStyles" selector="spec">spec	^spec</body><body package="HighlightingStyles" selector="spec:">spec: anObject	spec := anObject</body></methods><methods><class-id>Tools.StyleEditorEmphasisTab class</class-id> <category>instance creation</category><body package="HighlightingStyles" selector="key:value:spec:">key: newKey value: newValue spec: windowSpec	"Answer a new instance of the receiver with the arguments as the key and	value of the association."	^(self new key: newKey value: newValue) spec: windowSpec</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>updating</category><body package="HighlightingStyles" selector="getColor:do:">getColor: initialColor do: setBlock	"Select a color from the user."		"Use ICC extension if loaded."	#{ICC.ICCColorPicker}		ifDefinedDo:			[:pickerClass | | newColor |			(newColor := pickerClass openOn: initialColor) notNil				ifTrue:					[setBlock value: newColor.					self updateStyle]]		elseDo:			[| dialog |			dialog := ColorSelectionDialog new.			dialog selection: initialColor.			dialog open.			dialog accept value				ifTrue:					[setBlock value: dialog selection.					self updateStyle]].	self updateColorWidgets</body><body package="HighlightingStyles" selector="updateBasicWidgets">updateBasicWidgets	self styleHolder value isNil 		ifTrue: [self disableAll: self styleWidgets]		ifFalse:			[self enableAll: self styleWidgets.			self styleHolder value hasLineColor				ifTrue: [self disable: #underline]].</body><body package="HighlightingStyles" selector="updateColorWidgets">updateColorWidgets	| bgtype style |	style := self styleHolder value.	style isNil ifTrue: [^self hideAll: #(#fontColorButton #fontColorPatch #lineColorButton #lineColorPatch #backColorButton #backColorPatch)].	(self wrapperAt: #lineColorToggle) ifNotNil: [:wrap | wrap isEnabled: style hasUnderline].	style hasColor		ifTrue: 			[(self widgetAt: #fontColorPatch) ifNotNil: [:w | w insideColor: style color].			self showAll: #(#fontColorButton #fontColorPatch)]		ifFalse: [self hideAll: #(#fontColorButton #fontColorPatch)].	style hasLineColor		ifTrue: 			[(self widgetAt: #lineColorPatch) ifNotNil: [:w | w insideColor: style lineColor].			self showAll: #(#lineColorButton #lineColorPatch)]		ifFalse: [self hideAll: #(#lineColorButton #lineColorPatch)].	(bgtype := style backgroundType) == #none		ifTrue: [self hideAll: #(#backColorButton #backColorPatch)]		ifFalse: 			[(self widgetAt: #backColorPatch) ifNotNil:				[:w | w insideColor: (bgtype == #solid ifTrue: [style backColor] ifFalse: [style shadow])].			self showAll: #(#backColorButton #backColorPatch)].</body><body package="HighlightingStyles" selector="updateStyle">updateStyle	self changed: #styleSheet</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>initialize-release</category><body package="HighlightingStyles" selector="initialize">initialize	super initialize.	styles := Array new.	self emphasisTabs selectionIndex: 1.	self styleList selectionIndexHolder onChangeSend: #changedStyle to: self.	self emphasisTabs selectionIndexHolder onChangeSend: #changedTab to: self.</body><body package="HighlightingStyles" selector="setStyles:">setStyles: anArray	styles := anArray.	self buildFilterMenu</body><body package="HighlightingStyles" selector="updateStyles:">updateStyles: styleArray 	"Simple 'newStyles := styleArray is not enough. Make sure that the new styles	 to be loaded update (but not will replace) existing styles.  Items in the new list	 but not in the old are ignored."	| rebuild |	rebuild := false.	styleArray do: 		[:replace | | original |		original := self styles detect: [:item | item name = replace name] ifNone: [].		original isNil			ifTrue: [styles := self styles copyWith: replace. rebuild := true]			ifFalse: [original emphasis: replace emphasis]].	rebuild ifTrue: [self buildFilterMenu].	self		changedStyle;		updateStyle</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>widgets</category><body package="HighlightingStyles" selector="disable:">disable: aSymbol 	(self wrapperAt: aSymbol) ifNotNil: [:w | w disable]</body><body package="HighlightingStyles" selector="disableAll:">disableAll: aCollection	aCollection do: [:each | self disable: each]</body><body package="HighlightingStyles" selector="enable:">enable: aSymbol 	(self wrapperAt: aSymbol) ifNotNil: [:w | w enable]</body><body package="HighlightingStyles" selector="enableAll:">enableAll: aCollection	aCollection do: [:each | self enable: each]</body><body package="HighlightingStyles" selector="hide:">hide: aSymbol 	(self wrapperAt: aSymbol) ifNotNil: [:w | w beInvisible]</body><body package="HighlightingStyles" selector="hideAll:">hideAll: aCollection	aCollection do: [:each | self hide: each]</body><body package="HighlightingStyles" selector="show:">show: aSymbol 	(self wrapperAt: aSymbol) ifNotNil: [:w | w beVisible]</body><body package="HighlightingStyles" selector="showAll:">showAll: aCollection	aCollection do: [:each | self show: each]</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>accessing</category><body package="HighlightingStyles" selector="styleWidgets">styleWidgets	^#(#bold #italic #jaggedEdge #overline #strikeout #underline #fontColorToggle #underlineLabel #lineNoneToggle #lineSingleToggle #lineDoubleToggle #lineColorToggle #backgroundLabel #backNoneToggle #backSolidToggle #backShadowToggle)</body><body package="HighlightingStyles" selector="styles">styles	^styles</body><body package="HighlightingStyles" selector="tabSelections">tabSelections	"Answer a list of tab selections."	^(OrderedCollection new		add:	(StyleEditorEmphasisTab key: nil value: (#Basic		&lt;&lt; #labels &gt;&gt; 'Basic')		spec: #basicSpec);		add:	(StyleEditorEmphasisTab key: nil value: (#Advanced	&lt;&lt; #labels &gt;&gt; 'Advanced')	spec: #advancedSpec);		yourself) asList</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>aspects</category><body package="HighlightingStyles" selector="categoryHolder">categoryHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^categoryHolder isNil		ifTrue:			[categoryHolder := '' asValue]		ifFalse:			[categoryHolder]</body><body package="HighlightingStyles" selector="emphasisTabs">emphasisTabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^emphasisTabs isNil		ifTrue:			[emphasisTabs := SelectionInList with: self tabSelections]		ifFalse:			[emphasisTabs]</body><body package="HighlightingStyles" selector="filterMenu">filterMenu	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^filterMenu isNil		ifTrue:			[filterMenu := Menu new asValue]		ifFalse:			[filterMenu]</body><body package="HighlightingStyles" selector="styleHolder">styleHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^styleHolder isNil		ifTrue:			[styleHolder := nil asValue]		ifFalse:			[styleHolder]</body><body package="HighlightingStyles" selector="styleList">styleList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^styleList isNil		ifTrue:			[styleList := SelectionInList new]		ifFalse:			[styleList]</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>changing</category><body package="HighlightingStyles" selector="changedCategory">changedCategory	"Reset the category list based on filters."	| category menu |	menu := self filterMenu value.	category := self categoryHolder value.	menu menuItems do: [:item | item indicator: (item label = category)].	self filterStyles</body><body package="HighlightingStyles" selector="changedHasColor">changedHasColor	self updateColorWidgets.	self updateStyle</body><body package="HighlightingStyles" selector="changedStyle">changedStyle	self styleHolder value: self styleList selection.	self updateBasicWidgets; updateColorWidgets</body><body package="HighlightingStyles" selector="changedTab">changedTab	"Reset the category list based on filters."	| wrapper |	(builder isNil or: [(wrapper := builder componentAt: #emphasisTabs) isNil]) ifTrue: [^self].	subbuilder release.	subbuilder := builder newSubBuilder.	wrapper widget client: self spec: self emphasisTabs selection spec builder: subbuilder.	self updateBasicWidgets; updateColorWidgets</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>actions</category><body package="HighlightingStyles" selector="filterStyles">filterStyles	"Reset the category list based on filters."		| category label list selection |	category := self categoryHolder value.	label := (self filterMenu value labelAtValue: category) ifNotNil: [:l | l asString].	(label isNil or: [label = 'All'])		ifTrue: [list := self styles]		ifFalse: [list := self styles select: [:s | s category = label]].	selection := self styleList selection.	self styleList list: (list asSortedCollection: StyleDescription filterSortBlock) asList.	selection notNil		ifTrue:			[self styleList selection:					(list detect: [:each | each name = selection name] ifNone: [])]</body><body package="HighlightingStyles" selector="getBackColor">getBackColor	"Select back color from the user."	self styleHolder value backgroundType == #solid		ifTrue:			[self				getColor: self styleHolder value backColor				do: [:new | self styleHolder value backColor: new]]		ifFalse:			[self				getColor: self styleHolder value shadow				do: [:new | self styleHolder value shadow: new]]</body><body package="HighlightingStyles" selector="getFontColor">getFontColor	"Select font color from the user."		"Use ICC extension if loaded."	self		getColor: self styleHolder value color		do: [:new | self styleHolder value color: new]</body><body package="HighlightingStyles" selector="getLineColor">getLineColor	"Select underline color from the user."	self		getColor: self styleHolder value lineColor		do: [:new | self styleHolder value lineColor: new]</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>interface opening</category><body package="HighlightingStyles" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	builder == aBuilder ifTrue: [self changedTab].</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>view accessing</category><body package="HighlightingStyles" selector="wrapperAt:">wrapperAt: aSymbol 	"Answer the value of the named component at aSymbol. 	Typically gets a SpecWrapper or nil. 	In the case of a ToolBar, it instead gets the actual ToolBar instance. 	This method is the ApplicationModel direct replacement for messages of 	the form: 'self builder componentAt: &lt;aSymbol&gt;'"	^(super wrapperAt: aSymbol)		ifNil: [subbuilder ifNotNil: [subbuilder componentAt: aSymbol]]</body></methods><methods><class-id>Tools.StyleDescriptionEditor</class-id> <category>menus</category><body package="HighlightingStyles" selector="buildFilterMenu">buildFilterMenu	"Build the filter menu for selecting subsets of the styles."	| categories items |	categories := Set new.	self styles do: [:s | categories add: s category].	(items := categories asSortedCollection asOrderedCollection) addFirst: 'All'.	self filterMenu value: (Menu labelArray: items lines: (Array with: 1 with: items size) values: items).	(items includes: self categoryHolder value)		ifFalse: [self categoryHolder value: items last].	self changedCategory</body></methods><methods><class-id>Tools.StyleDescriptionEditor class</class-id> <category>resources</category><body package="HighlightingStyles" selector="imageIcon">imageIcon	^ListIconLibrary visualFor: #image</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>accessing</category><body package="HighlightingStyles" selector="backgroundType">backgroundType	"Determine the underline type."	self hasBackColor ifTrue: [^#solid].	self hasShadow ifTrue: [^#shadow].	^#none</body><body package="HighlightingStyles" selector="backgroundType:">backgroundType: newType	"Set the underline type."	newType == #solid		ifTrue:			[self hasBackColor ifFalse: [self hasBackColor: true].			self hasShadow: false.			^self].	newType == #shadow		ifTrue:			[self hasShadow ifFalse: [self hasShadow: true].			self hasBackColor: false.			^self].	self hasBackColor: false.	self hasShadow: false</body><body package="HighlightingStyles" selector="category:">category: anObject	category := anObject</body><body package="HighlightingStyles" selector="description:">description: anObject	description := anObject</body><body package="HighlightingStyles" selector="emphasis">emphasis	^emphasis</body><body package="HighlightingStyles" selector="emphasis:">emphasis: anObject	emphasis := anObject</body><body package="HighlightingStyles" selector="name">name	^name</body><body package="HighlightingStyles" selector="name:">name: anObject	name := anObject ifNotNil: [anObject asSymbol]</body><body package="HighlightingStyles" selector="underlineType">underlineType	"Determine the underline type."	self doubleUnderline ifTrue: [^#double].	self underline ifTrue: [^#single].	^#none</body><body package="HighlightingStyles" selector="underlineType:">underlineType: newType	"Set the underline type."	newType == #single		ifTrue: [self underline: true]		ifFalse:			[newType == #double				ifTrue: [self doubleUnderline: true]				ifFalse: [self underline: false]]</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>emphasis</category><body package="HighlightingStyles" selector="backColor:">backColor: aColorValue	"Set the backColor assigned to the emphasis."	aColorValue isNil		ifTrue: [self removeAttribute: #backColor]		ifFalse: [self setAttribute: #backColor -&gt; aColorValue]</body><body package="HighlightingStyles" selector="bold:">bold: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue: [self setAttribute: #bold]		ifFalse: [self removeAttribute: #bold]</body><body package="HighlightingStyles" selector="color:">color: aColorValue	"Set the color assigned to the emphasis."	aColorValue isNil		ifTrue: [self removeAttribute: #color]		ifFalse: [self setAttribute: #color -&gt; aColorValue]</body><body package="HighlightingStyles" selector="doubleUnderline:">doubleUnderline: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue:			[(self hasAttribute: #coloredUnderline)				ifTrue:					[| color |					color := self lineColor.					self removeAttributes: #(#underline #doubleUnderline #coloredUnderline); setAttribute: #coloredDoubleUnderline -&gt; color]				ifFalse:					[(self hasAttribute: #coloredDoubleUnderline)						ifTrue: [self removeAttributes: #(#underline #doubleUnderline #coloredUnderline)]						ifFalse: [self removeAttributes: #(#underline #coloredUnderline #coloredDoubleUnderline); setAttribute: #doubleUnderline]]]		ifFalse: [self removeAttributes: #(#underline #doubleUnderline #coloredUnderline #coloredDoubleUnderline)]</body><body package="HighlightingStyles" selector="hasBackColor">hasBackColor	"Answer whether the indicated emphasis is applied."	^self hasAttribute: #backColor</body><body package="HighlightingStyles" selector="hasBackColor:">hasBackColor: aBoolean	"Set whether the indicated emphasis should be applied."	self backColor: (aBoolean ifTrue: [ColorValue yellow])</body><body package="HighlightingStyles" selector="hasColor">hasColor	"Answer whether the indicated emphasis is applied."	^self hasAttribute: #color</body><body package="HighlightingStyles" selector="hasColor:">hasColor: aBoolean	"Set whether the indicated emphasis should be applied."	self color: (aBoolean ifTrue: [ColorValue black])</body><body package="HighlightingStyles" selector="hasLineColor">hasLineColor	"Answer whether the indicated emphasis is applied."	^(self hasAttribute: #coloredUnderline) or: [self hasAttribute: #coloredDoubleUnderline]</body><body package="HighlightingStyles" selector="hasLineColor:">hasLineColor: aBoolean	"Set whether the indicated emphasis should be applied."	self lineColor: (aBoolean ifTrue: [ColorValue black])</body><body package="HighlightingStyles" selector="hasShadow">hasShadow	"Answer whether the indicated emphasis is applied."	^self hasAttribute: #shadowed</body><body package="HighlightingStyles" selector="hasShadow:">hasShadow: aBoolean	"Set whether the indicated emphasis should be applied."	self shadow: (aBoolean ifTrue: [ColorValue lightGray])</body><body package="HighlightingStyles" selector="hasUnderline">hasUnderline	"Answer whether the indicated emphasis is applied."	^#(#underline #doubleUnderline #coloredUnderline #coloredDoubleUnderline) anySatisfy: [:attribute | self hasAttribute: attribute]</body><body package="HighlightingStyles" selector="hasUnderline:">hasUnderline: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue:			[(#(#underline #doubleUnderline #coloredUnderline #coloredDoubleUnderline) anySatisfy: [:attribute | self hasAttribute: attribute])				ifFalse: [self setAttribute: #underline]]		ifFalse: [self removeAttributes: #(#underline #doubleUnderline #coloredUnderline #coloredDoubleUnderline)]</body><body package="HighlightingStyles" selector="italic:">italic: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue: [self setAttribute: #italic]		ifFalse: [self removeAttribute: #italic]</body><body package="HighlightingStyles" selector="jaggedEdge:">jaggedEdge: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue: [self setAttribute: #jaggedEdge]		ifFalse: [self removeAttribute: #jaggedEdge]</body><body package="HighlightingStyles" selector="lineColor:">lineColor: aColorValue	"Set the underline color assigned to the emphasis."	aColorValue isNil		ifTrue:			[(self hasAttribute: #coloredDoubleUnderline)				ifTrue: [self removeAttributes: #(#underline #coloredUnderline #coloredDoubleUnderline); setAttribute: #doubleUnderline]				ifFalse:					[(self hasAttribute: #coloredUnderline)						ifTrue: [self removeAttributes: #(#doubleUnderline #coloredUnderline #coloredDoubleUnderline); setAttribute: #underline]						ifFalse: [(self hasAttribute: #doubleUnderline) ifTrue: [self removeAttribute: #underline]]]]		ifFalse:			[((self hasAttribute: #doubleUnderline) or: [self hasAttribute: #coloredDoubleUnderline])				ifTrue: [self removeAttributes: #(#underline #doubleUnderline #coloredUnderline); setAttribute: #coloredDoubleUnderline -&gt; aColorValue]				ifFalse: [self removeAttributes: #(#underline #doubleUnderline #coloredDoubleUnderline); setAttribute: #coloredUnderline -&gt; aColorValue]]</body><body package="HighlightingStyles" selector="overline:">overline: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue: [self setAttribute: #overline]		ifFalse: [self removeAttribute: #overline]</body><body package="HighlightingStyles" selector="shadow:">shadow: aColorValue	"Set whether the indicated emphasis should be applied."	aColorValue isNil		ifTrue: [self removeAttribute: #shadowed]		ifFalse: [self setAttribute: #shadowed -&gt; aColorValue]</body><body package="HighlightingStyles" selector="strikeout:">strikeout: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue: [self setAttribute: #strikeout]		ifFalse: [self removeAttribute: #strikeout]</body><body package="HighlightingStyles" selector="underline:">underline: aBoolean	"Set whether the indicated emphasis should be applied."	aBoolean		ifTrue:			[(self hasAttribute: #coloredDoubleUnderline)				ifTrue:					[| color |					color := self lineColor.					self removeAttributes: #(#underline #doubleUnderline #coloredDoubleUnderline); setAttribute: #coloredUnderline -&gt; color]				ifFalse:					[(self hasAttribute: #coloredUnderline)						ifTrue: [self removeAttributes: #(#underline #doubleUnderline #coloredDoubleUnderline)]						ifFalse: [self removeAttributes: #(#doubleUnderline #coloredUnderline #coloredDoubleUnderline); setAttribute: #underline]]]		ifFalse: [self removeAttributes: #(#underline #doubleUnderline #coloredUnderline #coloredDoubleUnderline)]</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>styles</category><body package="HighlightingStyles" selector="removeAttribute:">removeAttribute: attribute	"Make sure that the indicated attribute is part of the emphasis."	emphasis := emphasis asEmphasisWithout: attribute</body><body package="HighlightingStyles" selector="removeAttributes:">removeAttributes: aList	"Make sure that the indicated attribute is part of the emphasis."	emphasis := aList inject: emphasis into: [:emph :attribute | emph asEmphasisWithout: attribute]</body><body package="HighlightingStyles" selector="setAttribute:">setAttribute: attribute	"Make sure that the indicated attribute is part of the emphasis."	emphasis := emphasis asEmphasisWith: attribute</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>testing</category><body package="HighlightingStyles" selector="hasAttribute:">hasAttribute: attribute	"Answer whether the receiver contains the argument attribute."	^emphasis includesEmphasis: attribute</body><body package="HighlightingStyles" selector="hasEmphasis">hasEmphasis	"Answer whether the receiver actually has an emphasis."	^emphasis notNil</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>converting</category><body package="HighlightingStyles" selector="asStylesheetItem">asStylesheetItem	"Answer an array that forms an abbreviated literal encoding for the receiver.	 Category and description will be set from the standard style descriptions."	^self hasEmphasis		ifTrue: [Array with: name literalArrayEncoding with: emphasis asEmphasisArray literalArrayEncoding]		ifFalse: [Array with: name literalArrayEncoding]</body><body package="HighlightingStyles" selector="literalArrayEncoding">literalArrayEncoding	"Answer an array that forms a literal encoding for the receiver.  Include category	 and description, which overrides any style description tagged method."	^(self hasEmphasis		ifTrue:			[(Array new: 5)				at: 5 put: self emphasis asEmphasisArray literalArrayEncoding;				yourself]		ifFalse: [(Array new: 4)])			at: 1 put: self class fullyQualifiedReference;			at: 2 put: self name literalArrayEncoding;			at: 3 put: self category literalArrayEncoding;			at: 4 put: self description literalArrayEncoding;			yourself</body><body package="HighlightingStyles" selector="queryBlock">queryBlock	"Answer a query block that converts the emphasis to a series of	 characteristics applied to a character attributes."	^[:query | self value: query]</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>printing</category><body package="HighlightingStyles" selector="displayString">displayString		"Answer a display string for the receiver."	^description isNil		ifTrue: [name]		ifFalse: [description]</body><body package="HighlightingStyles" selector="printOn:">printOn: aStream	"Place a printable representation of the receiver on the stream."	aStream nextPutAll: self class name; space; nextPutAll: name; nextPut: $(.	emphasis notNil		ifTrue:			[emphasis asEmphasisArray				do: [:each | aStream print: each]				separatedBy: [aStream nextPutAll: ', ']].	aStream nextPut: $)</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>evaluating</category><body package="HighlightingStyles" selector="value:">value: query	"The argument is a font query.  Adjust it with the settings of the receiver."	emphasis asEmphasisArray do: 		[:style |		style isSymbol 			ifTrue: [query perform: (style , ':') asSymbol with: true]			ifFalse: [query perform: (style key , ':') asSymbol with: style value]].	^query</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>copying</category><body package="HighlightingStyles" selector="postCopy">postCopy	"Finish copying the receiver.  A shallow copy works fine for everything	 except the emphasis, which effectively must be a deep copy.  This is	 because we must make sure embedded associations are copied.  In	 the normal course of things, the emphasis array itself doesn't matter,	 but rather the contents."	self breakDependents.	emphasis class == Array		ifTrue: [emphasis := emphasis collect: [:e | e copy]]		ifFalse: [emphasis := emphasis copy]</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>settings</category><body package="HighlightingStyles" selector="styles">styles		^CurrentStyles ifNil: [CurrentStyles := self decodeStyles: self defaultStyles]</body><body package="HighlightingStyles" selector="styles:">styles: aCollection 	CurrentStyles := aCollection asArray.	SequenceableCollectionSorter sort: CurrentStyles using: StyleDescription nameSortBlock.	self initializeCharacterAttributesFromStyles</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>sorting</category><body package="HighlightingStyles" selector="displaySortBlock">displaySortBlock	"Answer the standard sort block (sorts by categories, then by names)."	^[:a :b |	a category &lt; b category		or: [a category = b category			and: [a description &lt;= b description]]]</body><body package="HighlightingStyles" selector="filterSortBlock">filterSortBlock	"Answer the standard sort block (sorts by categories, then by names)."	^[:a :b | a description &lt;= b description]</body><body package="HighlightingStyles" selector="nameSortBlock">nameSortBlock	"Answer the standard sort block (sorts by categories, then by names)."	^[:a :b | a name &lt;= b name]</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>compiling</category><body package="HighlightingStyles" selector="classMethodsChanged">classMethodsChanged	"Respond to a change in the class methods with pragmas."	#{UI.StyleDescription}		ifDefinedDo:			[:c | ((c includesBehavior: self) and: [CurrentStyles notNil])				ifTrue: [self install "self styles: (self mergeStyles: self styles)"]]</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>instance creation</category><body package="HighlightingStyles" selector="decodeEmphasisArray:">decodeEmphasisArray: anArray	"Create an instance of the receiver based on argument."	^anArray inject: nil into:		[:prev :each | | code item |		each class == Array			ifTrue:				[(each first isSymbol and: [each first isKeyword])					ifTrue:						[item := each first.						code := (item copyFrom: 1 to: item size - 1) asSymbol.						prev asEmphasisWith: (code -&gt; each last decodeAsLiteralArray)]					ifFalse: [prev asEmphasisWith: each decodeAsLiteralArray]]			ifFalse: [prev asEmphasisWith: each]]</body><body package="HighlightingStyles" selector="decodeFromLiteralArray:">decodeFromLiteralArray: anArray	"Create an instance of the receiver based on argument."	^self		name: (anArray at: 2)		category: (anArray at: 3)		description: (anArray at: 4)		emphasis: (anArray size &gt; 4 ifTrue: [self decodeEmphasisArray: (anArray at: 5)])</body><body package="HighlightingStyles" selector="name:category:description:emphasis:">name: nameSymbol category: categoryString description: aboutString emphasis: attributes	"Create a new instance of the receiver."	^self new		name: nameSymbol;		category: categoryString;		description: aboutString;		emphasis: attributes;		yourself</body><body package="HighlightingStyles" selector="name:description:emphasis:">name: nameSymbol description: aboutString emphasis: attributes	"Create a new instance of the receiver."	^self		name: nameSymbol		category: aboutString		description: aboutString		emphasis: attributes</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>style sheets</category><body package="HighlightingStyles" selector="defaultStyles">defaultStyles	"self styles: (self decodeStyles: self defaultStyles)"	^(Pragma allNamed: #default in: self class)		inject: #() into: [:list :pragma | list , (self perform: pragma selector)]</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>accessing</category><body package="HighlightingStyles" selector="styleDescriptions">styleDescriptions	"self styleDescriptions"	| list |	list := (Pragma allNamed: #style in: self class) collect: [:pragma | self perform: pragma selector].	SequenceableCollectionSorter sort: list using: self nameSortBlock.	^list</body><body package="HighlightingStyles" selector="styleNamed:">styleNamed: aSymbol	"Answer the named style."	^self styles detect: [:s | s name == aSymbol] ifNone: []</body><body package="HighlightingStyles" selector="styleNames">styleNames	"self styleNames"	^self styles collect: [:s | s name]</body><body package="HighlightingStyles" selector="stylesDictionary">stylesDictionary	| styleDictionary |	styleDictionary := Dictionary new.	self styles do: [:each | styleDictionary at: each name put: each queryBlock].	^styleDictionary</body><body package="HighlightingStyles" selector="stylesToRemove">stylesToRemove	^StylesToRemove		ifNil:			[StylesToRemove :=					(OrderedCollection new)						addAll: self stylesDictionary keys;						add: #bold;						add: #italic;						add: #underline;						asArray.			(SequenceableCollectionSorter sort: StylesToRemove) collection]</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>installation</category><body package="HighlightingStyles" selector="install">install	"Install the receiver.  It's nice to save the current styles, but that's actually unsafe.	 However, unused styles don't do anything, and new styles will take precedence."	self styles: (self mergeStyles: self styles)</body><body package="HighlightingStyles" selector="uninstall">uninstall	"self uninstall"	self removeStyleBasedCharacterAttributes.</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>private</category><body package="HighlightingStyles" selector="convertStyles:">convertStyles: selector	"Convert the styles of the argument selector to use StyleEmphasis objects."		^self describeStyles: (self perform: selector)</body><body package="HighlightingStyles" selector="decodeStyles:">decodeStyles: array	"Decode the argument array into the constituent emphasis styles.	 Convert the array if it's in old format."		| fixed |	array isEmpty ifTrue: [^array].	array first first isSymbol		ifTrue: [fixed := self describeStyles: array]		ifFalse: [fixed := array collect: [:each | each decodeAsLiteralArray]].	SequenceableCollectionSorter sort: fixed using: StyleDescription nameSortBlock.	^fixed</body><body package="HighlightingStyles" selector="describeStyles:">describeStyles: array	"Convert the styles of the argument selector to use StyleEmphasis objects."	| result |	result := IdentityDictionary new.	StyleDescription styleDescriptions do: [:each | result at: each name put: each].	array do:		[:each | | desc |		desc := result			at: each first			ifAbsentPut:				[| item |				(item := each first asString) at: 1 put: each first first asUppercase.				StyleDescription name: each first description: item emphasis: nil].		(each size = 2 and: [each last class = Array and: [each last first isSymbol not or: [each last first isKeyword not]]])			ifTrue: [desc emphasis: (StyleDescription decodeEmphasisArray: each last)]			ifFalse: [desc emphasis: (StyleDescription decodeEmphasisArray: (each copyFrom: 2 to: each size))]].	^result values asArray</body><body package="HighlightingStyles" selector="generateStyles:forMethod:">generateStyles: array forMethod: selector	"Convert the styles of the argument selector to use StyleEmphasis objects."	"self generateStyles: (self decodeStyles: self defaultStyles) forMethod: #defaultStyles"	| output |	output := (String new: 1024) writeStream.	selector notNil		ifTrue:			[output				nextPutAll: selector; crtab;				nextPutAll: '"self styles: (self decodeStyles: self '; nextPutAll: selector; nextPutAll: ')"'; crtab;				nextPutAll: '&lt;stylesheet: '; store: ((selector asString) at: 1 put: selector first asUppercase; yourself); nextPutAll: ' order: 10&gt;'; cr; crtab].	output nextPutAll: '^#('.	(array asSortedCollection: StyleDescription displaySortBlock) do:		[:style | output crtab: 2; store: style asStylesheetItem].	^output crtab; nextPutAll: ')'; contents</body><body package="HighlightingStyles" selector="mergeStyles:">mergeStyles: array	"Convert the styles of the argument selector to use StyleEmphasis objects."		| result |	result := IdentityDictionary new.	StyleDescription styleDescriptions do: [:each | result at: each name put: each].	array do: [:desc | result at: desc name put: desc].	^result values asArray</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>class initialization</category><body package="HighlightingStyles" selector="initializeCharacterAttributesFromStyles">initializeCharacterAttributesFromStyles	"self initializeCharacterAttributeFromStyles"	| dict removals |	StylesToRemove := nil.	dict := self stylesDictionary.	removals := dict keys select: [:each | (dict at: each) isNil].	removals do: [:each | dict removeKey: each].	CharacterAttributes removeDefaultKeys: removals.	CharacterAttributes defaultsAddAll: dict</body><body package="HighlightingStyles" selector="purgeObsoleteCharacterAttributeStyles">purgeObsoleteCharacterAttributeStyles	"A package has been unloaded that defines a style.  Examine the styles and	 purge from the set any style for which the receiver does not have a pragma	 defining that style."	"self purgeObsoleteCharacterAttributeStyles"	| dict |	dict := IdentityDictionary new.	self styles do: [:style | dict at: style name put: style].	self styleDescriptions do: [:desc | dict removeKey: desc name ifAbsent: []].	CurrentStyles := self styles asOrderedCollection removeAll: dict values; asArray.	CharacterAttributes removeDefaultKeys: dict keys.	StylesToRemove := nil.</body><body package="HighlightingStyles" selector="removeStyleBasedCharacterAttributes">removeStyleBasedCharacterAttributes	"Remove all currently defined styles.  Don't use the defaults, as we want	 to reflect current settings, which should be more thorough."	"self removeStyleBasedCharacterAttributes"	CharacterAttributes removeDefaultKeys: self stylesDictionary keys</body></methods><methods><class-id>Tools.StyleDescriptionSetting</class-id> <category>parameters</category><body package="HighlightingStyles" selector="xmlTag">xmlTag	"Answer a string used as a tag of XML elements representing values of this type."	^'style'</body></methods><methods><class-id>Tools.StyleDescriptionSetting</class-id> <category>accessing</category><body package="HighlightingStyles" selector="fromXML:">fromXML: aNode	"Parse an instance of a style description from the argument node."	| complain name style |	self verifyStoredDataTag: aNode.	complain := [self reportInvalidStoredData: aNode].	name := (aNode valueOfAttribute: 'name' ifAbsent: complain) asSymbol.	style := [self class perform: name]				on:	MessageNotUnderstood				do:	[:ex | ex return: (StyleDescription new name: name)].	(Pragma allNamed: #attribute: from: style class to: StyleDescription) do:		[:pragma |		(aNode valueOfAttribute: pragma selector asString ifAbsent: [])			ifNotNil:				[:value |				pragma arguments first == #string					ifTrue: [style perform: (pragma selector , ':') asSymbol with: value]					ifFalse: [style perform: (pragma selector , ':') asSymbol with: value = 'true']]].	(Pragma allNamed: #element: from: style class to: StyleDescription) do:		[:pragma | | converter select |		select := pragma selector asString.		converter := pragma arguments first value new.		(aNode anyElementsNamed: converter xmlTag) do:			[:child | | item |			item := child valueOfAttribute: 'name' ifAbsent: complain.			item = select				ifTrue: [style perform: (item , ':') asSymbol with: (converter fromXML: child)]]].	^style</body><body package="HighlightingStyles" selector="isValueValid:">isValueValid: anObject	"Subclasses must redefine this to check if the passed object is acceptable	for this type of setting, and answer a boolean."	^anObject isKindOf: StyleDescription</body><body package="HighlightingStyles" selector="toXML:">toXML: aStyle	"Convert the argument style to an XML node."	| attributes elements |	self validate: aStyle.	elements := OrderedCollection new.	attributes := OrderedCollection with: (Attribute name: 'name' value: aStyle name).	(Pragma allNamed: #attribute: from: aStyle class to: StyleDescription) do:		[:pragma | | value |		value := aStyle perform: pragma selector.		pragma arguments first == #boolean			ifTrue: [value ifTrue: [attributes add: (Attribute name: pragma selector asString value: 'true')]]			ifFalse: [value notNil ifTrue: [attributes add: (Attribute name: pragma selector asString value: value)]]].	(Pragma allNamed: #element: from: aStyle class to: StyleDescription) do:		[:pragma |		(aStyle perform: pragma selector)			ifNotNil:				[:value | | converter |				converter := pragma arguments first value new.				elements add: (self setName: pragma selector asString for: (converter toXML: aStyle color))]].	^Element tag: self xmlTag attributes: attributes asArray elements: elements asArray</body></methods><methods><class-id>Tools.StyleDescriptionSetting</class-id> <category>private</category><body package="HighlightingStyles" selector="setName:for:">setName: name for: aNode	"Set the name attribute for the argument node."	aNode addAttribute: (Attribute name: 'name' value: name).	^aNode</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>actions</category><body package="HighlightingStyles" selector="importSnapshots:">importSnapshots: aCollection	"This message is sent when the user imports settings from a settings file	into this specific page. A page should reimplement this method properly	to apply the saved state *to the widgets*."	self emphasisEditor updateStyles: (self stylesSetting type fromSnapshot: aCollection first)</body><body package="HighlightingStyles" selector="loadStyles">loadStyles	| name |	name := Dialog		requestFileName: (#LoadStylesFromC &lt;&lt; #browser &gt;&gt; 'Load styles from:')		default: self defaultFilename		for: self builder window.	name isEmpty ifTrue: [^self].	self loadStylesFrom: name</body><body package="HighlightingStyles" selector="loadStylesFrom:">loadStylesFrom: name 	| styleArray styleText input |	name asFilename exists			ifFalse: [^Dialog warn: #NoSuchStyleSheetFile &lt;&lt; #browser &gt;&gt; 'Highlighting style sheet file does not exist.'].	input := name asFilename readStream.	styleText := [input upToEnd] ensure: [input close].	(styleText isNil or: [styleText isEmpty]) 		ifTrue: [^Dialog warn: #EmptyStyleSheetFile &lt;&lt; #browser &gt;&gt; 'Highlighting style sheet file has no contents.'].	styleArray := Compiler evaluate: styleText.	styleArray class == Array		ifFalse: [^Dialog warn: #BadStyleSheetFile &lt;&lt; #browser &gt;&gt; 'Highlighting style sheet file has incorrect contents, array was expected.'].	self emphasisEditor updateStyles: (StyleDescription decodeStyles: styleArray)</body><body package="HighlightingStyles" selector="saveStyles">saveStyles	| name output |	name := Dialog				requestNewFileName: (#SaveStylesAsC &lt;&lt; #browser &gt;&gt; 'Save styles as:')				default: self defaultFilename				for: self builder window.	name isEmpty ifTrue: [^self].	output := name asFilename writeStream.	[output nextPutAll: '#('.	(self stylesHolder value asSortedCollection: StyleDescription nameSortBlock) do:		[:style | output crtab; store: style asStylesheetItem].	output cr; nextPutAll: ')'; cr] 		ensure: [output close]</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>aspects</category><body package="HighlightingStyles" selector="emphasisEditor">emphasisEditor	^emphasisEditor ifNil: [emphasisEditor := StyleDescriptionEditor new]</body><body package="HighlightingStyles" selector="sampleHolder">sampleHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sampleHolder isNil		ifTrue:			[sampleHolder := String new asValue]		ifFalse:			[sampleHolder]</body><body package="HighlightingStyles" selector="samplesMenu">samplesMenu	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	samplesMenu		ifNil:			[samplesMenu := Menu new asValue.			self buildSamplesMenu].	^samplesMenu</body><body package="HighlightingStyles" selector="stylesHolder">stylesHolder	"Create the buffered value holder for the set of styles."	^stylesHolder		ifNil:			[| setting |			setting := self stylesSetting.			(stylesHolder := BufferedValueHolder new subject: setting)				triggerChannel: manager triggerChannel;				onChangeSend: #tickle to: self;				yourself]</body><body package="HighlightingStyles" selector="stylesMenu">stylesMenu	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	stylesMenu		ifNil:			[stylesMenu := Menu new asValue.			self buildStylesMenu].	^stylesMenu</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>menus</category><body package="HighlightingStyles" selector="addPresetsTo:">addPresetsTo: menu	| pragmas |	(pragmas := self presetsPragmas) notEmpty		ifTrue:			[menu addLine.			pragmas inject: nil into: [:previous :pragma |				(previous notNil and: [previous arguments last &lt; pragma arguments last]) ifTrue: [menu addLine].				menu addItem:					((MenuItem labeled: pragma arguments first)						value: [self emphasisEditor updateStyles: (StyleDescription decodeStyles: (StyleDescription perform: pragma selector))]).				pragma]].</body><body package="HighlightingStyles" selector="buildSamplesMenu">buildSamplesMenu	"Answer the style menu, computed from the basic menu plus a submenu	 of all defined style sheets."	| menu pragmas |	(pragmas := self samplesPragmas) notEmpty		ifTrue:			[menu := Menu new.			1 to: pragmas size do:				[:index | | pragma |				pragma := pragmas at: index.				menu addItem:					((MenuItem labeled: pragma arguments first)						value: [self setSampleText: pragma selector index: index])]].	self samplesMenu value: menu</body><body package="HighlightingStyles" selector="buildStylesMenu">buildStylesMenu	"Answer the style menu, computed from the basic menu plus a submenu	 of all defined style sheets."	| menu |	menu := self class basicStyleMenu.	(menu atNameKey: #loadStyles) value: [self loadStyles].	(menu atNameKey: #saveStyles) value: [self saveStyles].	self addPresetsTo: menu.	self stylesMenu value: menu</body><body package="HighlightingStyles" selector="presetsPragmas">presetsPragmas	"Answer the list of preset pragmas."	^Pragma allNamed: #stylesheet:order: in: StyleDescription class sortedUsing:		[:a :b |		(a arguments last &lt; b arguments last)			or: [a arguments last = b arguments last				and: [a arguments first &lt;= b arguments first]]]</body><body package="HighlightingStyles" selector="presetsSubMenu">presetsSubMenu	"Answer the style menu, computed from the basic menu plus a submenu	 of all defined style sheets."	| break labels lines pragmas values |	(pragmas := self presetsPragmas) isEmpty ifTrue: [^nil].	lines := OrderedCollection new.	labels := OrderedCollection new.	values := OrderedCollection new.	break := (2 to: pragmas size) detect: [:x | (pragmas at: x) arguments last &gt; pragmas first arguments last] ifNone: [0].	break = 0 ifFalse: [lines add: break - 1].	pragmas do:		[:p |		labels add: p arguments first.		values add: [self emphasisEditor updateStyles: (StyleDescription decodeStyles: (StyleDescription perform: p selector))]].	^Menu labelArray: labels lines: lines values: values</body><body package="HighlightingStyles" selector="samplesPragmas">samplesPragmas	"Answer the list of preset pragmas."	^Pragma allNamed: #sample:order: in: self class sortedByArgument: 2</body><body package="HighlightingStyles" selector="setSampleText:index:">setSampleText: selector index: itemIndex	"The item with the indicated index has been requested for display.  Load	 that text, then mark the indication of which is loaded in the menu items.	 Enable highlighters by class in case the text is selective."	| items menu method |	menu := self samplesMenu value.	items := menu menuItems.	1 to: items size do: [:index | (items at: index) indicator: index = itemIndex].	method := self class compiledMethodAt: selector.	enabledClasses := OrderedCollection new.	((Pragma allInMethod: method) select: [:pragma | pragma keyword == #uses:])		do: [:pragma | pragma arguments first ifDefinedDo: [:cl | enabledClasses add: cl]].	self sampleHolder value: (self perform: selector).</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>interface opening</category><body package="HighlightingStyles" selector="postBuildWith:">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self samplesMenu value notNil ifTrue: [self samplesMenu value menuItems first value value].	self emphasisEditor setStyles: (self stylesHolder value collect: [:s | s copy]).	self addHighlighters.	self applyStyles.</body><body package="HighlightingStyles" selector="preBuildWith:">preBuildWith: aBuilder 	emphasisEditor release.	emphasisEditor := nil.	self emphasisEditor expressInterestIn: #styleSheet for: self sendBack: #changedStyle</body><body package="HighlightingStyles" selector="textController">textController	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer the receiver's text widget's controller."	^builder notNil ifTrue: [(builder componentAt: #sample) widget controller]</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>changing</category><body package="HighlightingStyles" selector="applyStyles">applyStyles	"Initialize styles into the receiver's method so that the changes display immediately."	| attrs |	attrs := self textController view textStyle characterAttributes.	self stylesHolder value do: [:style | attrs at: style name put: style queryBlock].	self textController startHighlighting: 0.	self textController view invalidate</body><body package="HighlightingStyles" selector="changedStyle">changedStyle	"Respond to a change in the emphasis editor."	self stylesHolder isBuffering		ifFalse:			[| attrs style |			self stylesHolder value: self emphasisEditor styles.			style := self textController view textStyle copy.			attrs := style characterAttributes copy.			attrs attributes: CharacterAttributes extraDefaults copy.			style setCharacterAttributes: attrs.			self textController view textStyle: style].	self applyStyles</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>accessing</category><body package="HighlightingStyles" selector="settings">settings	"Subclasses should redefine this to answer a collection of the settings	the page contains, when it does contain any settings, in the sense object	that support the GenericSettingDescriptor interface."	^VisualWorksSettings settingsWithPrefix: #(tools highlighter stylesheet)</body><body package="HighlightingStyles" selector="stylesSetting">stylesSetting	"Subclasses should redefine this to answer a collection of the settings	the page contains, when it does contain any settings, in the sense object	that support the GenericSettingDescriptor interface."	^VisualWorksSettings settingWithId: #(tools highlighter stylesheet styles)</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>event evaluating</category><body package="HighlightingStyles" selector="accepted">accepted	"Everything was accepted. Force refresh of all highlighting text views.  Make	 a copy of the styles so further editing will not change reinstalled originals."	(Pragma allNamed: #action: in: self class sortedByArgument: 1) do:		[:pragma | self perform: pragma selector]</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>constants</category><body package="HighlightingStyles" selector="defaultFilename">defaultFilename	"Answer the default filename for accessing style sheets."	^'stylesheet.txt'</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>testing</category><body package="HighlightingStyles" selector="isEnabled:">isEnabled: aHighlighter	"Answer whether the argument highlighter is enabled."	^enabledClasses includes: aHighlighter class</body></methods><methods><class-id>UI.NullHighlighter</class-id> <category>highlighting</category><body package="HighlightingStyles" selector="highlight:">highlight: aText	"Highlight the text - does nothing."	^aText</body></methods><methods><class-id>Tools.SettingsManagerPage</class-id> <category>event evaluating</category><body package="HighlightingStyles" selector="accepted">accepted	"(Highlighter Extension - private - not for general use - may be removed at any time)	 This method is an exact duplicate of equivalent code found in the GemStone GBS	 implementation.  It notifies each page that the value of the page was accepted.  In	 our case, the default behavior is to do nothing.  Subclasses should override to do	 something special (which GemStone does)."</body></methods><methods><class-id>Core.Array</class-id> <category>converting</category><body package="HighlightingStyles" selector="asEmphasisArray">asEmphasisArray	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis with the receiver as the first element	 and the argument as the second element.  If they have the same key, then	 answer the object in case it is an updated association for the receiver."	^self</body><body package="HighlightingStyles" selector="asEmphasisWith:">asEmphasisWith: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis with the receiver as the first element	 and the argument as the second element.  If they have the same key, then	 answer the object in case it is an updated association for the receiver."	| current |	current := self.	anEmphasis asEmphasisArray do:		[:emphasis | | index key |		key := emphasis emphasisKey.		index := (1 to: current size) detect: [:i | (current at: i) emphasisKey == key] ifNone: [0].		index = 0			ifTrue: [current := current copyWith: emphasis]			ifFalse: [current at: index put: emphasis]].	^current size = 1		ifTrue: [current first]		ifFalse: [current notEmpty ifTrue: [current]]</body><body package="HighlightingStyles" selector="asEmphasisWithout:">asEmphasisWithout: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis without the argument.  The argument may be	 any emphasis, singular or array."	| current |	current := self.	anEmphasis asEmphasisArray do:		[:emphasis | | index key |		key := emphasis emphasisKey.		index := (1 to: current size) detect: [:i | (current at: i) emphasisKey == key] ifNone: [0].		index = 0 ifFalse: [current := (current copyFrom: 1 to: index - 1) , (current copyFrom: index + 1 to: current size)]].	^current size = 1		ifTrue: [current first]		ifFalse: [current notEmpty ifTrue: [current]]</body></methods><methods><class-id>Core.Array</class-id> <category>accessing</category><body package="HighlightingStyles" selector="emphasisFor:">emphasisFor: anObject	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer the emphasis object having the same key as the argument."	| key |	key := anObject emphasisKey.	^self detect: [:item | item emphasisKey == key] ifNone: []</body></methods><methods><class-id>Core.Array</class-id> <category>testing</category><body package="HighlightingStyles" selector="includesEmphasis:">includesEmphasis: anObject	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer whether the receiver includes an emphasis of the same type as the argument."	| key |	key := anObject emphasisKey.	^self anySatisfy: [:each | each emphasisKey == key]</body></methods><methods><class-id>Core.Association class</class-id> <category>instance creation</category><body package="HighlightingStyles" selector="decodeFromLiteralArray:">decodeFromLiteralArray: anArray	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Return an instance based on the information encoded in anArray."	^self key: (anArray at: 2) value: (anArray at: 3) decodeAsLiteralArray</body></methods><methods><class-id>Core.Association</class-id> <category>private</category><body package="HighlightingStyles" selector="emphasisKey">emphasisKey	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer the emphasis key of the receiver, used to identify characteristics."	^self key</body><body package="HighlightingStyles" selector="literalArrayEncoding">literalArrayEncoding	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Return a literal suitable for reconstituting the receiver."	^Array		with: self class fullyQualifiedReference		with: self key literalArrayEncoding		with: self value literalArrayEncoding</body></methods><methods><class-id>Tools.SettingsManager</class-id> <category>private</category><body package="HighlightingStyles" selector="acceptAllPages">acceptAllPages	"(Highlighter Extension - private - not for general use - may be removed at any time)	 This method is an exact duplicate of equivalent code found in the GemStone GBS	 implementation.  It notifies each page that the value of the page was accepted.  In	 our case, this allows us to refresh views so that highlighting is immediately visible.	 Since this is a duplicate (except for this comment), load order does not matter."	[triggerChannel value: true] on: InvalidSettingValueError		do: [:ex | ex resume].	pageListHolder list do: [:wrapper | wrapper value accepted].	self showAcceptedStateUI</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="HighlightingStyles" selector="asEmphasisArray">asEmphasisArray	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis with the receiver as the first element	 and the argument as the second element.  If they have the same key, then	 answer the object in case it is an updated association for the receiver."	^Array new</body><body package="HighlightingStyles" selector="asEmphasisWith:">asEmphasisWith: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis with the receiver as the first element	 and the argument as the second element.  If they have the same key, then	 answer the object in case it is an updated association for the receiver."	^anEmphasis</body><body package="HighlightingStyles" selector="asEmphasisWithout:">asEmphasisWithout: anObject	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis without the argument.  The argument may be	 any emphasis, singular or array."	^self</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="HighlightingStyles" selector="includesEmphasis:">includesEmphasis: anObject	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer whether the receiver includes an emphasis of the same type as the argument."	^false</body></methods><methods><class-id>UI.Highlighter</class-id> <category>configuring</category><body package="HighlightingStyles" selector="forSettingsIn:">forSettingsIn: settingsPage	"Assign whether the receiver is active;  always true for settings."	active := [settingsPage isEnabled: self]</body></methods><methods><class-id>Graphics.PostScriptFontBody</class-id> <category>accessing</category><body package="HighlightingStyles" selector="bold">bold	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Indicate whether the receiver is bold - probably not the best solution."	^self boldness &gt; 0.5</body><body package="HighlightingStyles" selector="bold:">bold: aBoolean	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Set whether the receiver is bold - probably not the best solution."	^self boldness: (aBoolean ifTrue: [0.7] ifFalse: [0.5])</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>accessing</category><body package="HighlightingStyles" selector="bold">bold	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Indicate whether the receiver is bold - probably not the best solution."	^self boldness &gt; 0.5</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>modifying</category><body package="HighlightingStyles" selector="bold:">bold: aBoolean	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Set whether the receiver is bold - probably not the best solution."	^self boldness: (aBoolean ifTrue: [0.7] ifFalse: [0.5])</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="HighlightingStyles" selector="asEmphasisArray">asEmphasisArray	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis with the receiver as the first element	 and the argument as the second element.  If they have the same key, then	 answer the object in case it is an updated association for the receiver."	^Array with: self</body><body package="HighlightingStyles" selector="asEmphasisWith:">asEmphasisWith: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis merging with the argument.  If any part of	 the argument has the same emphasis key as the receiver, replace the receiver	 with the emphasis in the argument in case it is an updated association for the	 receiver.  The argument may be any emphasis, singular or array."	^self asEmphasisArray asEmphasisWith: anEmphasis</body><body package="HighlightingStyles" selector="asEmphasisWithout:">asEmphasisWithout: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Convert the receiver into an emphasis without the argument.  The argument may be	 any emphasis, singular or array."	anEmphasis asEmphasisArray do:		[:emphasis | (self includesEmphasis: emphasis) ifTrue: [^nil]].	^self</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="HighlightingStyles" selector="emphasisFor:">emphasisFor: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer the emphasis object having the same key as the argument.  The argument	 /must/ be a singular emphasis, not an array."	^(self includesEmphasis: anEmphasis) ifTrue: [self]</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="HighlightingStyles" selector="emphasisKey">emphasisKey	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer the emphasis key of the receiver, used to identify characteristics."	^self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="HighlightingStyles" selector="includesAnyEmphasis:">includesAnyEmphasis: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer whether the receiver includes an emphasis of the same type as the argument.	 The argument may be any emphasis or emphasis array."	^anEmphasis asEmphasisArray anySatisfy: [:emphasis | self includesEmphasis: emphasis]</body><body package="HighlightingStyles" selector="includesEmphasis:">includesEmphasis: anEmphasis	"(Highlighter Extension - private - not for general use - may be removed at any time)	 Answer whether the receiver includes an emphasis of the same type as the argument.	 The argument /must/ be a singular emphasis, not an emphasis array."	^self emphasisKey == anEmphasis emphasisKey</body></methods><methods><class-id>Tools.StyleDescriptionEditor class</class-id> <category>interface specs</category><body package="HighlightingStyles" selector="advancedSpec">advancedSpec	"Tools.UIPainter new openOnClass: self andSelector: #advancedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Style Description Settings' 			#min: #(#{Core.Point} 160 128 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1286 513 1446 641 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 0 ) 					#name: #underlineLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #UnderlineC 						#defaultString: 'Underline:' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 4 20 ) 					#name: #lineNoneToggle 					#model: #'styleHolder underlineType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #None 						#defaultString: 'None' 						#catalogID: #labels ) 					#style: #small 					#select: #none ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 4 40 ) 					#name: #lineSingleToggle 					#model: #'styleHolder underlineType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Single 						#defaultString: 'Single' 						#catalogID: #labelss ) 					#style: #small 					#select: #single ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 4 60 ) 					#name: #lineDoubleToggle 					#model: #'styleHolder underlineType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Double 						#defaultString: 'Double' 						#catalogID: #labelss ) 					#style: #small 					#select: #double ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 80 ) 					#name: #lineColorToggle 					#model: #'styleHolder hasLineColor' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #LineColor 						#defaultString: 'Line Color' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 26 102 44 120 ) 					#name: #lineColorButton 					#flags: 24 					#model: #getLineColor 					#label: #imageIcon 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 48 102 66 120 ) 					#name: #lineColorPatch 					#flags: 16 					#lineWidth: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 84 0 ) 					#name: #backgroundLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #BackgroundC 						#defaultString: 'Background:' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 84 20 ) 					#name: #backNoneToggle 					#model: #'styleHolder backgroundType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #None 						#defaultString: 'None' 						#catalogID: #labels ) 					#style: #small 					#select: #none ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 84 40 ) 					#name: #backSolidToggle 					#model: #'styleHolder backgroundType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Solid 						#defaultString: 'Solid' 						#catalogID: #labelss ) 					#style: #small 					#select: #solid ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 84 60 ) 					#name: #backShadowToggle 					#model: #'styleHolder backgroundType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Shadow 						#defaultString: 'Shadow' 						#catalogID: #labels ) 					#style: #small 					#select: #shadow ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 106 82 124 100 ) 					#name: #backColorButton 					#flags: 24 					#model: #getBackColor 					#label: #imageIcon 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 128 82 146 100 ) 					#name: #backColorPatch 					#flags: 16 					#lineWidth: 1 ) ) ) )</body><body package="HighlightingStyles" selector="basicSpec">basicSpec	"Tools.UIPainter new openOnClass: self andSelector: #basicSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Basic' 			#min: #(#{Core.Point} 160 128 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1298 525 1458 653 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 4 ) 					#name: #bold 					#model: #'styleHolder bold' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateStyle ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Bold 						#defaultString: 'Bold' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 24 ) 					#name: #italic 					#model: #'styleHolder italic' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateStyle ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Italic 						#defaultString: 'Italic' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 44 ) 					#name: #jaggedEdge 					#model: #'styleHolder jaggedEdge' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateStyle ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Jagged 						#defaultString: 'Jagged' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 64 ) 					#name: #overline 					#model: #'styleHolder overline' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateStyle ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Overline 						#defaultString: 'Overline' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 84 ) 					#name: #strikeout 					#model: #'styleHolder strikeout' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateStyle ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Strikeout 						#defaultString: 'Strikeout' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 84 4 ) 					#name: #fontColorToggle 					#model: #'styleHolder hasColor' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedHasColor ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #FontColor 						#defaultString: 'Font Color' 						#catalogID: #labels ) 					#style: #small ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 106 26 124 44 ) 					#name: #fontColorButton 					#flags: 24 					#model: #getFontColor 					#label: #imageIcon 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 128 26 146 44 ) 					#name: #fontColorPatch 					#flags: 16 					#lineWidth: 1 ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 4 104 ) 					#name: #underline 					#model: #'styleHolder underline' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateStyle ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Underline 						#defaultString: 'Underline' 						#catalogID: #labels ) 					#style: #small ) ) ) )</body><body package="HighlightingStyles" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Style Description Settings' 			#min: #(#{Core.Point} 300 192 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1465 518 1785 710 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 8 ) 					#name: #StyleFormats 					#label: 					#(#{Kernel.UserMessage} 						#key: #StyleFormatsC 						#defaultString: 'Style Formats:' 						#catalogID: #labels ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 28 0 -180 1 -32 1 ) 					#name: #types 					#model: #styleList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedStyle ) 					#style: #small 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 4 0 -28 1 ) 					#name: #Filter 					#label: 					#(#{Kernel.UserMessage} 						#key: #FilterC 						#defaultString: 'Filter:' 						#catalogID: #labels ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 -28 1 -180 1 -4 1 ) 					#name: #filterMenu 					#model: #categoryHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedCategory ) 					#menu: #filterMenu ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} -172 1 24 0 -4 1 -4 1 ) 					#name: #emphasisGroup 					#label: 					#(#{Kernel.UserMessage} 						#key: #EmphasisSettings 						#defaultString: 'Emphasis Settings' 						#catalogID: #labels ) ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} -166 1 44 0 -10 1 -10 1 ) 					#name: #emphasisTabs 					#model: #emphasisTabs 					#style: #small 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>accessing</category><body package="HighlightingStyles" selector="category">category	&lt;attribute: #string&gt;	^category</body><body package="HighlightingStyles" selector="description">description	&lt;attribute: #string&gt;	^description</body></methods><methods><class-id>Tools.StyleDescription</class-id> <category>emphasis</category><body package="HighlightingStyles" selector="backColor">backColor	"Answer the color assigned, or black if none."	&lt;element: #{Tools.ColorValueSetting}&gt;	^(emphasis emphasisFor: #backColor) value</body><body package="HighlightingStyles" selector="bold">bold	"Answer whether the indicated emphasis is applied."	&lt;attribute: #boolean&gt;	^self hasAttribute: #bold</body><body package="HighlightingStyles" selector="color">color	"Answer the color assigned, or black if none."	&lt;element: #{Tools.ColorValueSetting}&gt;	^(emphasis emphasisFor: #color) value</body><body package="HighlightingStyles" selector="doubleUnderline">doubleUnderline	"Answer whether the indicated emphasis is applied."	&lt;attribute: #boolean&gt;	^(self hasAttribute: #doubleUnderline) or: [self hasAttribute: #coloredDoubleUnderline]</body><body package="HighlightingStyles" selector="italic">italic	"Answer whether the indicated emphasis is applied."	&lt;attribute: #boolean&gt;	^self hasAttribute: #italic</body><body package="HighlightingStyles" selector="jaggedEdge">jaggedEdge	"Answer whether the indicated emphasis is applied."	&lt;attribute: #boolean&gt;	^self hasAttribute: #jaggedEdge</body><body package="HighlightingStyles" selector="lineColor">lineColor	"Answer the color assigned, or black if none."	&lt;element: #{Tools.ColorValueSetting}&gt;	^(emphasis emphasisFor: #coloredUnderline) value		ifNil: [(emphasis emphasisFor: #coloredDoubleUnderline) value]</body><body package="HighlightingStyles" selector="overline">overline	"Answer whether the indicated emphasis is applied."	&lt;attribute: #boolean&gt;	^self hasAttribute: #overline</body><body package="HighlightingStyles" selector="shadow">shadow	"Answer whether the indicated emphasis is applied."	&lt;element: #{Tools.ColorValueSetting}&gt;	^(emphasis emphasisFor: #shadowed) value</body><body package="HighlightingStyles" selector="strikeout">strikeout	"Answer whether the indicated emphasis is applied."	&lt;attribute: #boolean&gt;	^self hasAttribute: #strikeout</body><body package="HighlightingStyles" selector="underline">underline	"Answer whether the indicated emphasis is applied."	&lt;attribute: #boolean&gt;	^(self hasAttribute: #underline) or: [self hasAttribute: #coloredUnderline]</body></methods><methods><class-id>Tools.StyleDescription class</class-id> <category>compiling</category><body package="HighlightingStyles" selector="attributePragmas">attributePragmas	&lt;pragmas: #instance&gt;	^#(#attribute: #element:)</body><body package="HighlightingStyles" selector="codePragmas">codePragmas	&lt;pragmas: #class&gt;	^#(#code)</body><body package="HighlightingStyles" selector="stylePragmas">stylePragmas	&lt;pragmas: #class&gt;	^#(#default #style #stylesheet:order:)</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>actions</category><body package="HighlightingStyles" selector="acceptComment">acceptComment	"Perform an acceptance action."	&lt;action: 10&gt;	Refactory.Browser.BrowserCommentTool refreshAllInstances.</body><body package="HighlightingStyles" selector="acceptRefresh">acceptRefresh	"Perform an acceptance action."	&lt;action: 0&gt;	self emphasisEditor setStyles: (self stylesHolder value collect: [:s | s copy])</body></methods><methods><class-id>Tools.StylesheetSettingsPage</class-id> <category>interface opening</category><body package="HighlightingStyles" selector="addNullHighlighter">addNullHighlighter	"If highlighting is enabled for the receiver, add a spell check highlighter."	&lt;highlighter&gt;	(UI.NullHighlighter on: self textController) ifNotNil: [:hl | hl forSettingsIn: self]</body></methods><methods><class-id>Tools.StylesheetSettingsPage class</class-id> <category>class initialization</category><body package="HighlightingStyles" selector="acceptancePragmas">acceptancePragmas	&lt;pragmas: #instance&gt;	^#(#action:)</body><body package="HighlightingStyles" selector="samplePragmas">samplePragmas	&lt;pragmas: #instance&gt;	^#(#sample:order: #uses:)</body></methods><methods><class-id>Tools.StylesheetSettingsPage class</class-id> <category>resources</category><body package="HighlightingStyles" selector="basicStyleMenu">basicStyleMenu	"Tools.MenuEditor new openOnClass: self andSelector: #basicStyleMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_LoadStylesDots 					#defaultString: '&amp;Load styles...' 					#catalogID: #browser ) 				#nameKey: #loadStyles 				#value: #loadStyles ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_SaveStylesDots 					#defaultString: '&amp;Save styles...' 					#catalogID: #browser ) 				#nameKey: #saveStyles 				#value: #saveStyles ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.StylesheetSettingsPage class</class-id> <category>interface specs</category><body package="HighlightingStyles" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Code Highlighter Settings' 			#min: #(#{Core.Point} 240 240 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1280 512 1640 872 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -168 1 0 0 0 1 24 0 ) 					#name: #stylesMenu 					#label: 					#(#{Kernel.UserMessage} 						#key: #StyleSheetDots 						#defaultString: 'Style Sheet...' 						#catalogID: #browser ) 					#menu: #stylesMenu ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} -4 0 0 0 4 1 212 0 ) 					#name: #emphasisEditor 					#flags: 0 					#majorKey: #{Tools.StyleDescriptionEditor} 					#minorKey: #windowSpec 					#clientKey: #emphasisEditor ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 0 220 ) 					#name: #sampleHighlightingLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #SampleHighlightingC 						#defaultString: 'Sample Highlighting:' 						#catalogID: #browser ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -168 1 212 0 0 1.0 236 0 ) 					#name: #samplesMenu 					#label: 					#(#{Kernel.UserMessage} 						#key: #SampleTextDots 						#defaultString: 'Sample Text...' 						#catalogID: #browser ) 					#menu: #samplesMenu ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 240 0 0 1 0 1 ) 					#name: #sample 					#model: #sampleHolder 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="HighlightingStyles" selector="toolsHighlightStylesheetPage">toolsHighlightStylesheetPage		&lt;settingsPage: #(#tools #highlighter #stylesheet)&gt;	^(StylesheetSettingsPage new)		label: #CodeHighlighterStyles &lt;&lt; #browser &gt;&gt; 'Styles';		icon: (ListIconLibrary visualFor: #image)</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-highlighter</category><body package="HighlightingStyles" selector="toolsHighlightStylesheetStyles">toolsHighlightStylesheetStyles	"(Highlighter Extension - private - not for general use - may be removed at any time)"	&lt;setting: #(tools highlighter stylesheet styles)&gt;	^((SequenceSetting of: StyleDescriptionSetting)			on: StyleDescription			aspect: #styles)		label: #ToolsHighlightStylesheetStyles &lt;&lt; #browser &gt;&gt; 'Styles';		helpText: #ToolsHighlightStylesheetStylesHelpText &lt;&lt; #browser &gt;&gt; 'Specifies the list of styles that will be applied.  Styles are defined as part of the package and are not extensible, although their values are individually editable.  The style emphasis editor, a subcanvas to the code highlighting settings page, permits editing of individual styles from a filtered list of available styles.'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>FontDescription</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name family manufacturer pixelSize flags masks color encoding encodings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>SettingType</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setting </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>Highlighter</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller order active </inst-vars><class-inst-vars>highlight </class-inst-vars><imports></imports><category></category><attributes><package>TextHighlighting</package></attributes></class><class><name>PostScriptFontBody</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName family boldness italic serif fixedWidth setWidth widths simpleWidths defaultWidth encoder ascent descent underlinePosition underlineThickness fontSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Printing-PostScript</category><attributes><package>Graphics-Printing-PostScript</package></attributes></class><class><name>SettingsManager</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>triggerChannel pageListHolder domainHolder rootPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class></st-source>