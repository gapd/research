<?xml version="1.0"?><st-source><!-- Name: NetSecureConnectionNotice: Copyright © 2010-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: Provides the core classes extending the various protocol implementations in the Internet Connectivity Toolkit with SSL capabilities, allowing to secure connections using the SSL protocol.DbIdentifier: bear73DbTrace: 306777DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'SSL' ''))PackageName: NetSecureConnectionParcel: #('NetSecureConnection')PrerequisiteParcels: #(#('NetClientBase' '') #('SSL' ''))PrintStringCache: (7.8 - 1004,tkogan)Version: 7.8 - 1004Date: 11:58:34 AM December 21, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (dec10.3) of December 21, 2010 on December 21, 2010 at 11:58:34 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SSLConnection</name><environment>Net</environment><super>Net.NetConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sslContext sslConnection validationBlock hostName </inst-vars><class-inst-vars>defaultValidationBlockFactory </class-inst-vars><imports>			Security.*			</imports><category>Net-SecureConnection-Support</category><attributes><package>NetSecureConnection</package></attributes></class><comment><class-id>Net.SSLConnection</class-id><body>This is an abstract superclass for client connections using a communication channel secured with SSL protocol. Some connections start out as plain, unprotected connection of the specific protocol and are eventually upgraded to an SSL protected connection later on (e.g. SMTPSTARTTTLSConnection) based on some protocol specific extension (e.g. STARTTLS). How the upgrade happens is protocol specific. Other types of connections switch to SSL immediately and there is no communication that goes over unprotected channel (e.g. SMTPSSLConnection).If the connection can be upgraded on the fly, it is usually used on the standard port of the protocol, there's no need for dedicated "secure" port. Connections that start out in SSL immediately normally require dedicated "secure" port (e.g. SMTPS 465).For detailed explanation of various SSL related aspect, please, refer to the comments in the SSL package.Instance Variables	sslContext	&lt;SSLContext&gt; environment for SSL communication	sslConnection	&lt;Security.SSLConnection&gt; SSL connection between two parties	validationBlock	&lt;BlockClosure&gt; subject validation block for server certificate	hostName	&lt;String&gt; host nameClass Instance Variables	defaultValidationBlockFactory &lt;BlockClosure&gt;   the block is an optional argument that will be the connection requesting its validation block. The block will be evaluated (with the connection and should return another block, that will be passed to the SSL layer as a certificate validation block.Here's an example of the factory block:	[ :connection | [ :subject | subject commonName match: connection hostName ] ]</body></comment><methods><class-id>Net.SSLConnection</class-id> <category>accessing</category><body package="NetSecureConnection" selector="hostName">hostName	^hostName</body><body package="NetSecureConnection" selector="sslContext">sslContext	^sslContext ifNil: [ sslContext := SSLContext newWithSecureCipherSuites ].</body><body package="NetSecureConnection" selector="sslContext:">sslContext: anSSLContext	sslContext := anSSLContext</body><body package="NetSecureConnection" selector="validationBlock">validationBlock	^validationBlock isNil		ifTrue: [ self class defaultValidationBlockFactory cull: self ]		ifFalse: [ validationBlock ]</body><body package="NetSecureConnection" selector="validationBlock:">validationBlock: aBlock	validationBlock := aBlock</body></methods><methods><class-id>Net.SSLConnection</class-id> <category>private</category><body package="NetSecureConnection" selector="setupLogging">setupLogging	sslConnection 		when: #receivingSignedBytes:size: 		do: [ :bytes :size | 			self class log: '****************Receiving Signed Bytes****************' level: #SSLConnection.			self class log: (bytes copyFrom: 1 to: size) asString level: #SSLConnection ].	sslConnection 		when: #sendingSignedBytes:size: 		do: [ :bytes :size | 			self class log: '****************Sending Signed Bytes******************' level: #SSLConnection.			self class log: (bytes copyFrom: 1 to: size) asString level: #SSLConnection].</body><body package="NetSecureConnection" selector="sslConnection">sslConnection	^sslConnection</body></methods><methods><class-id>Net.SSLConnection</class-id> <category>initialize-release</category><body package="NetSecureConnection" selector="openSocketStreamFor:port:timeout:encoding:">openSocketStreamFor: aHost port: aPortNumber timeout: tmNumber encoding: anEncoding	hostName := aHost.	^super openSocketStreamFor: aHost port: aPortNumber timeout: tmNumber encoding: anEncoding</body><body package="NetSecureConnection" selector="sslContext:validationBlock:">sslContext: aSSLContext validationBlock: aBlock	sslContext := aSSLContext.	validationBlock := aBlock</body><body package="NetSecureConnection" selector="startSSL">startSSL	sslConnection ifNotNil: [ ^NetClientError raiseErrorString: 'SSL already started!' ].	stream binary.	sslConnection := self sslContext connectionFor: stream.	[	sslConnection connectSubject: self validationBlock.	] ifCurtailed: [ sslConnection shutdown. ].	self setupLogging.	stream := (sslConnection withEncoding: self defaultEncoding)				readAppendStream				lineEndConvention: self defaultLineEndConvention.	^stream</body></methods><methods><class-id>Net.SSLConnection</class-id> <category>testing</category><body package="NetSecureConnection" selector="isSSLActive">isSSLActive	^sslConnection notNil</body><body package="NetSecureConnection" selector="isSecure">isSecure	^true</body></methods><methods><class-id>Net.SSLConnection</class-id> <category>stream</category><body package="NetSecureConnection" selector="disconnect">disconnect	sslConnection ifNotNil: [ [sslConnection close] ensure: [sslConnection := nil ]].	hostName := nil.	super disconnect.</body></methods><methods><class-id>Net.SSLConnection class</class-id> <category>instance creation</category><body package="NetSecureConnection" selector="sslContext:">sslContext: aSSLContext	^self new 		sslContext: aSSLContext;		yourself</body><body package="NetSecureConnection" selector="sslContext:validationBlock:">sslContext: aSSLContext validationBlock: aBlock	^self new 		sslContext: aSSLContext validationBlock: aBlock;		yourself</body><body package="NetSecureConnection" selector="validationBlock:">validationBlock: aBlock	^self new 		validationBlock: aBlock;		yourself</body></methods><methods><class-id>Net.SSLConnection class</class-id> <category>debugging</category><body package="NetSecureConnection" selector="debugLabelsAndValues">debugLabelsAndValues	^OrderedCollection new		add: ((#SSLConnection &lt;&lt; #net &gt;&gt; 'SSL Connection')-&gt;#SSLConnection);		yourself</body><body package="NetSecureConnection" selector="log:level:">log: aString level: aLevel	#{Tools.LogEnvironment} ifDefinedDo: [ :le | le  default log: aString level: aLevel ]</body><body package="NetSecureConnection" selector="menuItemName">menuItemName	^(#SSLConnectionMessages &lt;&lt; #net &gt;&gt; 'SSL Connection Messages')</body><body package="NetSecureConnection" selector="registerToDebug">registerToDebug	#{Tools.LogEnvironment} ifDefinedDo: [ :le | le  default addToDebug: self ]</body></methods><methods><class-id>Net.SSLConnection class</class-id> <category>class initialization</category><body package="NetSecureConnection" selector="initialize">initialize	"self initialize."	self registerToDebug.</body></methods><methods><class-id>Net.SSLConnection class</class-id> <category>accessing</category><body package="NetSecureConnection" selector="defaultValidationBlockFactory">defaultValidationBlockFactory	^defaultValidationBlockFactory ifNil: [ self defaultValidationBlockFactoryValue ]</body><body package="NetSecureConnection" selector="defaultValidationBlockFactory:">defaultValidationBlockFactory: aBlock"aBlock takes an optional argument that will be the connection requesting its validation block.aBlock will be evaluated (with the connection and should return another block, that will be passed to the SSL layer as a certificate validation block.Here's an example of the factory block:	[ :connection | [ :subject | subject commonName match: connection hostName ] ]"	defaultValidationBlockFactory := aBlock</body><body package="NetSecureConnection" selector="defaultValidationBlockFactoryValue">defaultValidationBlockFactoryValue	"Let's emulate web browser validation as default"	^[ :connection | [ :subject | subject commonName match: connection hostName ] ]</body></methods><methods><class-id>Net.NetClient</class-id> <category>secure connection</category><body package="NetSecureConnection" selector="sslContext">sslContext	^self clientPI sslContext</body><body package="NetSecureConnection" selector="sslContext:">sslContext: anSSLContext	self clientPI sslContext: anSSLContext</body><body package="NetSecureConnection" selector="useSecureConnection">useSecureConnection	self clientPI useSecureConnection</body><body package="NetSecureConnection" selector="useSecureConnectionIfAvailable">useSecureConnectionIfAvailable	self clientPI useSecureConnectionIfAvailable</body><body package="NetSecureConnection" selector="validationBlock">validationBlock	^self clientPI validationBlock</body><body package="NetSecureConnection" selector="validationBlock:">validationBlock:  aBlock	self clientPI validationBlock:  aBlock</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>secure connection</category><body package="NetSecureConnection" selector="sslContext">sslContext	^(connection notNil and: [ connection isSecure ])		ifTrue: [connection sslContext ]		ifFalse: [ nil ]</body><body package="NetSecureConnection" selector="sslContext:">sslContext: anSSLContext	(connection isNil or: [ connection isSecure not ]) ifTrue: [		^NetClientError  raiseSignal:  (#SecureConnectionRequired &lt;&lt; #net &gt;&gt; 'Secure connection is required for this action!') ].	connection sslContext: anSSLContext</body><body package="NetSecureConnection" selector="useSecureConnection">useSecureConnection	self error: #NotAvailableWithThisProtocol &lt;&lt; #net &gt;&gt; 'This capability is not available with this protocol!'</body><body package="NetSecureConnection" selector="useSecureConnectionIfAvailable">useSecureConnectionIfAvailable	self error: #NotAvailableWithThisProtocol &lt;&lt; #net &gt;&gt; 'This capability is not available with this protocol!'</body><body package="NetSecureConnection" selector="validationBlock">validationBlock	^(connection notNil and: [ connection isSecure ])		ifTrue: [connection validationBlock ]		ifFalse: [ nil ]</body><body package="NetSecureConnection" selector="validationBlock:">validationBlock:  aBlock	(connection isNil or: [ connection isSecure not ]) ifTrue: [		^NetClientError  raiseSignal:  (#SecureConnectionRequired &lt;&lt; #net &gt;&gt; 'Secure connection is required for this action!') ].	connection validationBlock:  aBlock</body></methods><initialize><class-id>Net.SSLConnection</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>encoding </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class></st-source>