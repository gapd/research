<?xml version="1.0"?><st-source><!-- Name: ASN1-ConstraintsNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This packages maintains classes representing various kinds of ASN.1 constraints. Constraints are used to derive ASN.1 Types from other ASN.1 Types. Note that not all Constraint classes apply to all Type classes. It supports many of the standard ASN.1 constraint as well as non-standard however very useful BlockConstraint. The BlockConstraint is used to define permissible values for some of the basic ASN.1 types.Primary responsibility of a Constraint is to distinguish permissible values via the #permits: message.LIMITATIONS:	- Regular Expression constraint is not supported	- the WITH COMPONENTS constrait for SET/SEQUENCE/CHOICE is not supported	- the OCTET STRING constraints ENCODED BY and CONTAINING ENCODED BY are not supported	- constraint extensibility is not supported	- user defined, CONSTRAINED BY, constraints are not supportedDbIdentifier: bear73DbTrace: 280321DevelopmentPrerequisites: #(#(#package 'ASN1-Support' ''))PackageName: ASN1-ConstraintsParcel: #('ASN1-Constraints')PrerequisiteParcels: #(#('ASN1-Support' ''))PrintStringCache: (7.7.1 - 0,BaseSystem)Version: 7.7.1 - 0Date: 3:25:34 AM May 3, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.7.1 (apr10.4) of May 3, 2010 on May 3, 2010 at 3:25:34 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Constraint</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.Constraint</class-id><body>Asn1Constraint is the abstract superclass of those classes that represent concrete constraints upon ASN.1's fundamental types.Subclasses must implement the following messages:	private		privatePermits:</body></comment><class><name>ValueUnionConstraint</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.ValueUnionConstraint</class-id><body>An Asn1ConstraintValueUnion is satisfied by any value that is equal to any of its 'values'.Instance Variables:	values	&lt;Collection&gt;	a collection of values</body></comment><class><name>SingleConstraintCombination</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.SingleConstraintCombination</class-id><body>Asn1ConstraintSub1 is an abstract class.  It is the superclass of those constraints that 'spin' a single, more basic, subconstraint.Instance Variables:	constraint	&lt;Asn1Constraint&gt;	the contained subconstraint</body></comment><class><name>ExceptConstraint</name><environment>ASN1</environment><super>ASN1.SingleConstraintCombination</super><private>false</private><indexed-type>none</indexed-type><inst-vars>except </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.ExceptConstraint</class-id><body>An Asn1ConstraintExcept represents a constraint that is satisfied by any value that satisfies the 'constraint' and fails to satisfy the 'except'.Instance Variables:	except	&lt;Asn1Constraint&gt;	the 'except' constraint</body></comment><class><name>SizeConstraint</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lower upper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.SizeConstraint</class-id><body>An Asn1ConstraintSize is satisfied by any object with a size &gt;= 'lower' and &lt;= 'upper'.Instance Variables:	lower	&lt;Integer&gt;	the lower bound	upper	&lt;Integer&gt;	the upper bound</body></comment><class><name>AlphabetConstraint</name><environment>ASN1</environment><super>ASN1.SingleConstraintCombination</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.AlphabetConstraint</class-id><body>An Asn1ConstraintAlphabet represents a constraint on the alphabet used within a string type.  Its enclosed subconstraint is usually a union of character values.  The constraint is satisfied by strings in which all characters are members of the union.</body></comment><class><name>BlockConstraint</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockClosure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.BlockConstraint</class-id><body>An Asn1ConstraintBlockClosure is used to represent arbitrary constraints that are best implemented in VisualWorks as BlockClosures.  ASN.1 itself has no notion of a block constraint.  Most of the default constraints on ASN.1 universal types are implemented using Asn1ConstraintBlockClosure.Instance Variables:	blockClosure	&lt;BlockClosure&gt;		a block that expresses a constraint</body></comment><class><name>MultipleConstraintCombination</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.MultipleConstraintCombination</class-id><body>Asn1ConstraintSubN is an abstract class.  It is the superclass of those constraints that 'spin' a collection of more basic subconstraints.Instance Variables:	constraints	&lt;(Collection of: Asn1Constraint)&gt;	da collection of subconstraints</body></comment><class><name>ConstraintIntersection</name><environment>ASN1</environment><super>ASN1.MultipleConstraintCombination</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.ConstraintIntersection</class-id><body>An Asn1ConstraintIntersection is fulfilled by any value that satisfies all of the 'contraints'.</body></comment><class><name>SingleValueConstraint</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.SingleValueConstraint</class-id><body>An Asn1ConstraintSingleValue is satisfied by any object that is equal to or permitted by the 'value'.Instance Variables:	value	&lt;Object | Asn1Constraint | Asn1Element | Asn1Type &gt;	an Object or an implementor of 'permits:'</body></comment><class><name>ConstraintUnion</name><environment>ASN1</environment><super>ASN1.MultipleConstraintCombination</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.ConstraintUnion</class-id><body>An Asn1ConstraintUnion is fulfilled by any value that satisfies any of the 'contraints'.</body></comment><class><name>TypeInclusionConstraint</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.TypeInclusionConstraint</class-id><body>A Asn1ConstraintOfType is satisfied by any value that satisfies the constraints of the 'type'.Instance Variables:	type	&lt;Asn1Type&gt; the type used to express the constraint</body></comment><class><name>ValueRangeConstraint</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lower lowerOpen upper upperOpen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.ValueRangeConstraint</class-id><body>An Asn1ConstraintValueRange is satisfied by objects that satisfy the range.Instance Variables:	lower		&lt;Magnitude&gt;	the lower bound	lowerOpen	&lt;Boolean&gt;		'true' if the range is 'open' at the lower bound	upper		&lt;Magnitude&gt;	the upper bound	upperOpen	&lt;Boolean&gt;		'true' if the range is 'open' at the upper bound</body></comment><class><name>WithComponentConstraint</name><environment>ASN1</environment><super>ASN1.SingleConstraintCombination</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.WithComponentConstraint</class-id><body>Asn1ConstraintWithComponent is a constraint for the SET OF and SEQUENCE OF types.  It is satisfied if each element of the set or sequence satisfies the 'constraint'.</body></comment><class><name>AllExceptConstraint</name><environment>ASN1</environment><super>ASN1.SingleConstraintCombination</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.AllExceptConstraint</class-id><body>An Asn1ConstraintAllExcept is fulfilled by all objects that fail to satisfy its enclosed subconstraint.</body></comment><class><name>NullConstraint</name><environment>ASN1</environment><super>ASN1.Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Constraints</package></attributes></class><comment><class-id>ASN1.NullConstraint</class-id><body>An Asn1ConstraintNull represents an empty constraint, one satisfied by all values.  There should be only one in existence.Class Instance Variables:	default	&lt;Asn1ConstraintNull&gt;	the sole instance of the class</body></comment><methods><class-id>ASN1.Constraint</class-id> <category>construction</category><body package="ASN1-Constraints" selector="&amp;">&amp; aConstraint	^ConstraintIntersection with: self with: aConstraint</body><body package="ASN1-Constraints" selector="-">- aConstraint	^ExceptConstraint with: self except: aConstraint</body><body package="ASN1-Constraints" selector="not">not	^AllExceptConstraint with: self</body><body package="ASN1-Constraints" selector="|">| aConstraint	^ConstraintUnion with: self with: aConstraint</body></methods><methods><class-id>ASN1.Constraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	self subclassResponsibility</body></methods><methods><class-id>ASN1.Constraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="printOn:">printOn: aStream	self shortPrintOn: aStream</body><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	aStream nextPutAll: self class printString</body></methods><methods><class-id>ASN1.Constraint</class-id> <category>initialize-release</category><body package="ASN1-Constraints" selector="initialize">initialize	"... intentionally null."</body></methods><methods><class-id>ASN1.Constraint</class-id> <category>operational api</category><body package="ASN1-Constraints" selector="permits:">permits: anObject	"Answers whether the constraint permits anObject."	^[ self privatePermits: anObject ]		on:	Error		do:	[ :ex | ^false ]</body></methods><methods><class-id>ASN1.Constraint</class-id> <category>testing</category><body package="ASN1-Constraints" selector="isNull">isNull	^false</body></methods><methods><class-id>ASN1.Constraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^anObject class == self class</body></methods><methods><class-id>ASN1.Constraint class</class-id> <category>construction</category><body package="ASN1-Constraints" selector="block:">block: aBlock	^BlockConstraint with: aBlock</body><body package="ASN1-Constraints" selector="from:to:">from: bottom to: top	^ValueRangeConstraint lower: bottom upper: top</body><body package="ASN1-Constraints" selector="null">null	^NullConstraint default</body><body package="ASN1-Constraints" selector="size:">size: anInteger	^SizeConstraint size: anInteger</body><body package="ASN1-Constraints" selector="type:">type: aType	^TypeInclusionConstraint with: aType</body><body package="ASN1-Constraints" selector="value:">value: anObject	^SingleValueConstraint with: anObject</body><body package="ASN1-Constraints" selector="values:">values: aCollection	^ValueUnionConstraint withAll: aCollection</body></methods><methods><class-id>ASN1.Constraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="new">new	^super new initialize</body></methods><methods><class-id>ASN1.ValueUnionConstraint</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="values">values	^values</body><body package="ASN1-Constraints" selector="values:">values: aCollection	values := aCollection</body></methods><methods><class-id>ASN1.ValueUnionConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^values includes: anObject</body></methods><methods><class-id>ASN1.ValueUnionConstraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="printValue:on:">printValue: anObject on: aStream	anObject class = Character ifTrue: [	^aStream nextPut: anObject ].	anObject printOn: aStream</body><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	self values isCharacters ifTrue: [		^aStream nextPut: $";			nextPutAll: self values;			nextPut: $" ].	self values		do: [ :v |			aStream nextPut: $".			self printValue: v on: aStream.			aStream nextPut: $" ]		separatedBy: [ aStream nextPut: $| ]</body></methods><methods><class-id>ASN1.ValueUnionConstraint</class-id> <category>initialize-release</category><body package="ASN1-Constraints" selector="initialize">initialize	values := Set new: 7</body></methods><methods><class-id>ASN1.ValueUnionConstraint</class-id> <category>configuration api</category><body package="ASN1-Constraints" selector="addValue:">addValue: anObject	values add: anObject</body></methods><methods><class-id>ASN1.ValueUnionConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ anObject values = self values ]</body></methods><methods><class-id>ASN1.ValueUnionConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="with:">with: aValue	^( self new )		addValue: aValue;		yourself</body><body package="ASN1-Constraints" selector="with:with:">with: aValue1 with: aValue2	^( self new )		addValue: aValue1;		addValue: aValue2;		yourself</body><body package="ASN1-Constraints" selector="with:with:with:">with: aValue1 with: aValue2 with: aValue3	^( self new )		addValue: aValue1;		addValue: aValue2;		addValue: aValue3;		yourself</body><body package="ASN1-Constraints" selector="with:with:with:with:">with: aValue1 with: aValue2 with: aValue3 with: aValue4	^( self new )		addValue: aValue1;		addValue: aValue2;		addValue: aValue3;		addValue: aValue4;		yourself</body><body package="ASN1-Constraints" selector="withAll:">withAll: aCollection	| n |	n := self new.	n values addAll: aCollection.	^n</body></methods><methods><class-id>ASN1.SingleConstraintCombination</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="constraint">constraint	^constraint</body><body package="ASN1-Constraints" selector="constraint:">constraint: anAsn1Constraint	constraint := anAsn1Constraint</body></methods><methods><class-id>ASN1.SingleConstraintCombination</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ anObject constraint equals: self constraint ] ]</body></methods><methods><class-id>ASN1.SingleConstraintCombination class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="with:">with: anAsn1Constraint	^( self new )		constraint: anAsn1Constraint;		yourself</body></methods><methods><class-id>ASN1.ExceptConstraint</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="except">except	^except</body><body package="ASN1-Constraints" selector="except:">except: anAsn1Constraint	except := anAsn1Constraint</body></methods><methods><class-id>ASN1.ExceptConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^( constraint privatePermits: anObject ) and: [ ( except privatePermits: anObject ) not ]</body></methods><methods><class-id>ASN1.ExceptConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ anObject except equals: self except ] ]</body></methods><methods><class-id>ASN1.ExceptConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="with:except:">with: anAsn1Constraint1 except: anAsn1Constraint2	^( self new )		constraint: anAsn1Constraint1;		except: anAsn1Constraint2;		yourself</body></methods><methods><class-id>ASN1.SizeConstraint</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="lower">lower	^lower</body><body package="ASN1-Constraints" selector="lower:">lower: anInteger	lower := anInteger</body><body package="ASN1-Constraints" selector="upper">upper	^upper</body><body package="ASN1-Constraints" selector="upper:">upper: anInteger	upper := anInteger</body></methods><methods><class-id>ASN1.SizeConstraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	aStream nextPutAll: 'SIZE (';		print: self lower.	self upper = self lower ifFalse: [		aStream nextPutAll: '..';			print: self upper ].	aStream nextPut: $)</body></methods><methods><class-id>ASN1.SizeConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	| s |	s := anObject size.	^( s &gt;= lower ) and: [ s &lt;= upper ]</body></methods><methods><class-id>ASN1.SizeConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ ( anObject lower = self lower )			and: [ anObject upper = self upper ] ]</body></methods><methods><class-id>ASN1.SizeConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="lower:upper:">lower: anInteger1 upper: anInteger2	^( super new )		lower: anInteger1;		upper: anInteger2;		yourself</body><body package="ASN1-Constraints" selector="size:">size: anInteger	^( super new )		lower: anInteger;		upper: anInteger;		yourself</body></methods><methods><class-id>ASN1.AlphabetConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	( anObject isKindOf: CharacterArray )		ifFalse: [ ^false ].	anObject do: [ :character | ( constraint privatePermits: character ) ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>ASN1.AlphabetConstraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	aStream nextPutAll: 'FROM ('.	self constraint shortPrintOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>ASN1.BlockConstraint</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="blockClosure">blockClosure	^blockClosure</body><body package="ASN1-Constraints" selector="blockClosure:">blockClosure: aBlockClosure	blockClosure := aBlockClosure</body></methods><methods><class-id>ASN1.BlockConstraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	blockClosure printOn: aStream</body></methods><methods><class-id>ASN1.BlockConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^blockClosure value: anObject</body></methods><methods><class-id>ASN1.BlockConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ anObject blockClosure = self blockClosure ]</body></methods><methods><class-id>ASN1.BlockConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="with:">with: aBlockClosure	^( self new )		blockClosure: aBlockClosure;		yourself</body></methods><methods><class-id>ASN1.MultipleConstraintCombination</class-id> <category>initialize-release</category><body package="ASN1-Constraints" selector="initialize">initialize	constraints := OrderedCollection new</body></methods><methods><class-id>ASN1.MultipleConstraintCombination</class-id> <category>printing</category><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	self constraints		do: [ :c |			aStream nextPut: $(.			c 	ifNil: [ aStream nextPutAll: 'nil' ]				ifNotNil: [ c shortPrintOn: aStream ].			aStream nextPut: $) ]		separatedBy: [			aStream space;				nextPut: self operatorCharacter;				space ]</body></methods><methods><class-id>ASN1.MultipleConstraintCombination</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="constraints">constraints	^constraints</body><body package="ASN1-Constraints" selector="constraints:">constraints: aCollection	constraints := aCollection</body></methods><methods><class-id>ASN1.MultipleConstraintCombination</class-id> <category>configuration api</category><body package="ASN1-Constraints" selector="addConstraint:">addConstraint: anAsn1Constraint	constraints add: anAsn1Constraint</body></methods><methods><class-id>ASN1.MultipleConstraintCombination</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ anObject constraints allSatisfy: [ :c1 |					self constraints anySatisfy: [ :c2 | c2 equals: c1 ] ] ] ]</body></methods><methods><class-id>ASN1.MultipleConstraintCombination class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="with:">with: anAsn1Constraint	^( self new )		addConstraint: anAsn1Constraint;		yourself</body><body package="ASN1-Constraints" selector="with:with:">with: anAsn1Constraint1 with: anAsn1Constraint2	^( self new )		addConstraint: anAsn1Constraint1;		addConstraint: anAsn1Constraint2;		yourself</body><body package="ASN1-Constraints" selector="with:with:with:">with: anAsn1Constraint1 with: anAsn1Constraint2 with: anAsn1Constraint3	^( self new )		addConstraint: anAsn1Constraint1;		addConstraint: anAsn1Constraint2;		addConstraint: anAsn1Constraint3;		yourself</body><body package="ASN1-Constraints" selector="with:with:with:with:">with: anAsn1Constraint1 with: anAsn1Constraint2 with: anAsn1Constraint3 with: anAsn1Constraint4	^( self new )		addConstraint: anAsn1Constraint1;		addConstraint: anAsn1Constraint2;		addConstraint: anAsn1Constraint3;		addConstraint: anAsn1Constraint4;		yourself</body><body package="ASN1-Constraints" selector="withAll:">withAll: aSequenceableCollection	"... to ensure ordering, go out of the way to ensure aSequenceableCollection is one."	| n |	n := self new.	1 to: aSequenceableCollection size do:		[ :x | n addConstraint: ( aSequenceableCollection at: x ) ].	^n</body></methods><methods><class-id>ASN1.ConstraintIntersection</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	constraints do: [ :c | ( c privatePermits: anObject ) ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>ASN1.ConstraintIntersection</class-id> <category>printing</category><body package="ASN1-Constraints" selector="operatorCharacter">operatorCharacter	^$^</body></methods><methods><class-id>ASN1.ConstraintIntersection</class-id> <category>construction</category><body package="ASN1-Constraints" selector="&amp;">&amp; aConstraint	^self addConstraint: aConstraint</body></methods><methods><class-id>ASN1.SingleValueConstraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	aStream print: self value</body></methods><methods><class-id>ASN1.SingleValueConstraint</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="value">value	^value</body><body package="ASN1-Constraints" selector="value:">value: aLiteralOrAsn1Constraint	value := aLiteralOrAsn1Constraint</body></methods><methods><class-id>ASN1.SingleValueConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^[ ( value = anObject )		or: [ anObject permits: anObject ] ]			on:	Error			do:	[ :ex | false ]</body></methods><methods><class-id>ASN1.SingleValueConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ anObject value = self value ]</body></methods><methods><class-id>ASN1.SingleValueConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="with:">with: anObject	^( self new )		value: anObject;		yourself</body></methods><methods><class-id>ASN1.ConstraintUnion</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	constraints do: [ :c | ( c privatePermits: anObject ) ifTrue: [ ^true ] ].	^false</body></methods><methods><class-id>ASN1.ConstraintUnion</class-id> <category>printing</category><body package="ASN1-Constraints" selector="operatorCharacter">operatorCharacter	^$|</body></methods><methods><class-id>ASN1.ConstraintUnion</class-id> <category>construction</category><body package="ASN1-Constraints" selector="|">| aConstraint	^self addConstraint: aConstraint</body></methods><methods><class-id>ASN1.TypeInclusionConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^type permits: anObject</body></methods><methods><class-id>ASN1.TypeInclusionConstraint</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="type">type	^type</body><body package="ASN1-Constraints" selector="type:">type: anAsn1Type	type := anAsn1Type</body></methods><methods><class-id>ASN1.TypeInclusionConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ anObject type equals: self type ] ]</body></methods><methods><class-id>ASN1.TypeInclusionConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="with:">with: anAsn1Type	^( self new )		type: anAsn1Type;		yourself</body></methods><methods><class-id>ASN1.ValueRangeConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^( lowerOpen			ifTrue: [ lower &lt; anObject ]			ifFalse: [ lower &lt;= anObject ] )				and:	[	upperOpen								ifTrue:	[ anObject &lt; upper ]								ifFalse: [ anObject &lt;= upper ] ]</body></methods><methods><class-id>ASN1.ValueRangeConstraint</class-id> <category>accessing</category><body package="ASN1-Constraints" selector="lower">lower	^lower</body><body package="ASN1-Constraints" selector="lower:">lower: anObject	lower := anObject</body><body package="ASN1-Constraints" selector="lowerOpen">lowerOpen	^lowerOpen</body><body package="ASN1-Constraints" selector="lowerOpen:">lowerOpen: aBoolean	lowerOpen := aBoolean</body><body package="ASN1-Constraints" selector="upper">upper	^upper</body><body package="ASN1-Constraints" selector="upper:">upper: anObject	upper := anObject</body><body package="ASN1-Constraints" selector="upperOpen">upperOpen	^upperOpen</body><body package="ASN1-Constraints" selector="upperOpen:">upperOpen: aBoolean	upperOpen := aBoolean</body></methods><methods><class-id>ASN1.ValueRangeConstraint</class-id> <category>initialize-release</category><body package="ASN1-Constraints" selector="initialize">initialize	lowerOpen := upperOpen := false</body></methods><methods><class-id>ASN1.ValueRangeConstraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	aStream print: self lower.	self lowerOpen ifTrue: [ aStream nextPut: $&lt; ].	aStream nextPutAll: '..'.	self upperOpen ifTrue: [ aStream nextPut: $&lt; ].	aStream print: self upper</body></methods><methods><class-id>ASN1.ValueRangeConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ ( anObject lower = self lower )			and: [ ( anObject upper = self upper )				and: [ ( anObject lowerOpen = self lowerOpen )					and: [ anObject upperOpen = self upperOpen ] ] ] ]</body></methods><methods><class-id>ASN1.ValueRangeConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="lower:lowerOpen:upper:upperOpen:">lower: anObject1 lowerOpen: aBoolean1 upper: anObject2 upperOpen: aBoolean2	^( self new )		lower: anObject1;		lowerOpen: aBoolean1;		upper: anObject2;		upperOpen: aBoolean2;		yourself</body><body package="ASN1-Constraints" selector="lower:upper:">lower: anObject1 upper: anObject2	^( self new )		lower: anObject1;		upper: anObject2;		yourself</body></methods><methods><class-id>ASN1.WithComponentConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	anObject do: [ :e | ( constraint privatePermits: e ) ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>ASN1.AllExceptConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^( constraint privatePermits: anObject ) not</body></methods><methods><class-id>ASN1.NullConstraint</class-id> <category>private</category><body package="ASN1-Constraints" selector="privatePermits:">privatePermits: anObject	^true</body></methods><methods><class-id>ASN1.NullConstraint</class-id> <category>printing</category><body package="ASN1-Constraints" selector="shortPrintOn:">shortPrintOn: aStream	aStream nextPutAll: 'Null'</body></methods><methods><class-id>ASN1.NullConstraint</class-id> <category>testing</category><body package="ASN1-Constraints" selector="isNull">isNull	^true</body></methods><methods><class-id>ASN1.NullConstraint</class-id> <category>comparing</category><body package="ASN1-Constraints" selector="equals:">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^anObject == self</body></methods><methods><class-id>ASN1.NullConstraint class</class-id> <category>instance creation</category><body package="ASN1-Constraints" selector="default">default	^self new</body><body package="ASN1-Constraints" selector="new">new	^( default isNil )		ifTrue:	[ default := super new ]		ifFalse:	[ default ]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>