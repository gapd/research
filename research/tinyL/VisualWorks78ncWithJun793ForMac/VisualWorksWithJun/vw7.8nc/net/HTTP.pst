<?xml version="1.0"?><st-source><!-- Name: HTTPNotice: Copyright © 2010-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: HTTP support provides the ability to make connections to servers in order to request resources via the HTTP protocol, which is a superset of MIME.	Attachment filenamesIt seems to be a widespread practice to encode filenames directly into the 'filename' parameter of the corresponding HTTP header field (e.g. many web browsers do that with filenames of uploaded files). This is technically a violation of the HTTP protocol, however in order to deal with the reality it is possible to suppress strict compliance by setting #defaultParameterValueEncoding on ValueWithParam class. If set, the specified encoding (e.g. #utf8) will be automatically applied to any parameter value in which we encounter raw non-ascii characters. Note that this is different from properly quoted, non-ascii values as in =?iso-8859-2?Q?Bo=BEidar=20?=. Here's an example with raw, utf8 encoded filename in cyrilics:	source := (ByteArray new withEncoding:  #iso8859_1) readWriteStream lineEndCRLF.	source nextPutAll: 'Content-Disposition: form-data; name="43"; filename= "'.	filename := 'F:\текст1.текст'.	source binary; nextPutAll: (filename asByteArrayEncoding: #utf8).	source text; nextPut: $".	source reset.	setting := ValueWithParams defaultParameterValueEncoding.	ValueWithParams defaultParameterValueEncoding: #utf8.		[	(Net.HeaderField 			readFrom: source			acceptNonAsciiCharacters: true		) fileName  	] ensure: [ ValueWithParams defaultParameterValueEncoding: setting ].DbIdentifier: bear73DbTrace: 313914DevelopmentPrerequisites: #(#(#any 'Compression-ZLib' '') #(#any 'DES' '') #(#any 'MD5' '') #(#any 'MIME' '') #(#package 'Protocols-Common' '') #(#package 'NetClientBase' '') #(#package 'HashesBase' ''))PackageName: HTTPParcel: #('HTTP')ParcelName: HTTPPrerequisiteParcels: #(#('Compression-ZLib' '') #('DES' '') #('MD5' '') #('MIME' '') #('Protocols-Common' '') #('NetClientBase' '') #('HashesBase' ''))PrintStringCache: (7.8 - 1006,tkogan)Version: 7.8 - 1006Date: 11:58:36 AM December 21, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (dec10.3) of December 21, 2010 on December 21, 2010 at 11:58:36 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AuthenticateField</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scheme </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticateField</class-id><body>This class represents the structure of the www-authenticate/proxy-authenticate field as it described in RFC2616. This is a parametrized field with a single value followed by parameters, but it does not follow the usual practise of separating the paramters by semicolons. Instead it uses commas, and does not require a comma before the first (realm) parameter.Instance Variables:	scheme	&lt;String&gt;	name of authentication scheme</body></comment><class><name>AuthenticationInfoField</name><environment>Net</environment><super>Net.AuthenticateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticationInfoField</class-id><body>AuthenticationInfoField represents "Authentication-Info" header field as it described in RFC2617. The Authentication-Info header is used by the server to communicate some information regarding the successful digest authentication in the  response.</body></comment><class><name>AuthenticationPolicy</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user rejected authentication authOrder </inst-vars><class-inst-vars>authOrder </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticationPolicy</class-id><body>AuthenticationPolicy handles different types of authentication for Http messages. The policy will select supported authentication scheme from the server challenge, create an instance of the specific authentication and add an authorization field to a request.The policy will try to handle the server challenge if 	- a user name and password is provided	- the server challenge includes supported authentication schemeCurrently supported authentication schemes: Basic, Digest and NTLM. The client side preferences for authetication mechanism are controlled by the authentication order (#authOrder), which can be specified either at the global level (class side) or at the individual instance level.Instance Variables	authOrder	&lt;OrderedCollection of HttpAuthentication&gt;	authOrder defines supported authentication schemes and order to select a scheme to authorize a message. 	authentication	&lt;HttpAuthentication&gt;	authentication instance to authorize a message	rejected	&lt;Collection of HttpAuthentication&gt;	collection of schemes a server rejected to accept. The authentication policy will make an attempt to use another auth scheme from the server  challenge list if the first one failed. If the rejected list and the same as the challenge list the auth policy passes the exception.	user	&lt;HttpUser&gt;	the user that holds user name, password and collection of realms where this authentication token is validClass Instance Variables	authOrder	&lt;OrderedCollection of HttpAuthentication&gt;	authOrder. Default order is #(NTLMAuthentication DigestAuthentication BasicAuthentication)Samples how to use AuthenticationPolicy. More samples can be found in HttpAuthPolicyTest class (HTTPTests package). To run tests see the NetClientsSupportInternal bundle comments.1.request := HttpRequest readFrom: 'GET http://www.cincomx.com/en/index.asp HTTP/1.1Host: www.cincom.com:4545Connection: Keep-Alive' readStream.reply := HttpResponse readFrom: 'HTTP/1.1 401 UnauthorizedWWW-Authenticate: NegotiateWWW-Authenticate: NTLMWWW-Authenticate: Basic realm="testrealm@host.com"' readStream.polBuilder := AuthenticationPolicy new.polBuilder policiesOrder: (Array 		with: BasicAuthentication		with: DigestAuthentication 		with: NTLMAuthentication).polBuilder username: 'aUser' password:  'password'.polBuilder acceptChallenge: reply request: request.polBuilder addAuthorizationTo: request.2.cl := HttpClient new.cl username: 'winUsername' password: 'winPass'.reply := cl get: html.3.cl := HttpClient new.cl username: 'winUsername' password: 'winPass'.cl useBasicAuth.reply := cl get: html4. cl := HttpClient new.[reply := cl get: html.] on: Net.HttpUnauthorizedErrordo: [ :ex | 	cl username: 'winUsername' password: 'winPass'.	ex retry]5.proxy := (HostSpec new					name: 'ntlmAuthProxyServer';					type: 'http';					yourself).proxy netUser: (NetUser username: 'winUsername' password: 'winPass').cl := HttpClient new.cl 	proxyHost: proxy;	useProxy: true.reply := cl get: 'http://www.yahoo.com/'.</body></comment><class><name>ProxyAuthenticationPolicy</name><environment>Net</environment><super>Net.AuthenticationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>ChunkedStream</name><environment>Net</environment><super>Net.MessageStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ChunkedStream</class-id><body>ChunkedStream is an abstract class for read write chunked streams. Instance Variables:	buffer		&lt;ByteArray&gt;	buffer holds a chunk of bytes	lineEnd		&lt;ByteArray&gt; 	stream line end conventionFrom RFC2616:The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing entity-header fields. This allows dynamically produced content to be transferred along with the information necessary for the recipient to verify that it has received the full message.       Chunked-Body   = *chunk                        last-chunk                        trailer                        CRLF       chunk          = chunk-size [ chunk-extension ] CRLF                        chunk-data CRLF       chunk-size     = 1*HEX       last-chunk     = 1*("0") [ chunk-extension ] CRLF       chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )       chunk-ext-name = token       chunk-ext-val  = token | quoted-string       chunk-data     = chunk-size(OCTET)       trailer        = *(entity-header CRLF)   The chunk-size field is a string of hex digits indicating the size of   the chunk. The chunked encoding is ended by any chunk whose size is   zero, followed by the trailer, which is terminated by an empty line.</body></comment><class><name>UnknownCookieParameter</name><environment>Net</environment><super>Net.InvalidHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.UnknownCookieParameter</class-id><body>UnknownCookieParameter the exception is raised when unknown parameter is detected while parsing cookie fields.</body></comment><class><name>QuotedPrintRequired</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.QuotedPrintRequired</class-id><body>QuotedPrintRequired exception is raised to notify about printing ports for cookie header fields. The syntax requires quotes around the optional port list even if there is only one port number in the port list</body></comment><class><name>HttpURL</name><environment>Net</environment><super>OS.URLwithAuthority</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user decompressContents decodeContents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpURL</class-id><body>This URL describes resources accessed using the HTTP protocol.Instance Variables:	user	&lt;NetUser&gt;	an user ID authorized to access the proxy server	decompressContents 	&lt;Boolean&gt; defines whether or not to decompess the reponse contents	decodeContents &lt;Boolean&gt; defines whether or not to decode the response contents</body></comment><class><name>HttpException</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpException</class-id><body>This class reports errors which are reported by the HTTP server being accessed.Shared Class Variables:	Preferences	&lt;OrderedCollection of Association &gt; list of Http errors with description</body></comment><class><name>HttpNotExtendedError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpNotExtendedError</class-id><body>HttpNotExtendedError reports 510 errors. The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource</body></comment><class><name>HttpAuthentication</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authChallenge state pathString authPolicy authValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpAuthentication</class-id><body>HttpAuthentication is an abstract class for different authentication schemes. The subclasses must provided implementation for the authorization field value.Subclasses must implement the following messages:	authorization		setNewAuthorizationValueInstance Variables:	authChallenge	&lt;AuthenticationValue&gt;	the server challenge (authentication field value)	authValue	&lt;AuthenticationValue&gt;	the authorization field value	authPolicy	&lt;AuthenticationPolicy&gt;	authentication policy	pathString	&lt;String&gt;	the request url 	state	&lt;ByteSymbol&gt;	the authetication state. Depending on a scheme it can have values:  #authorized #isNotAuthorized #authorizationInProgress. 	user	&lt;HttpUser&gt;	the http user that is used to authorize the message</body></comment><class><name>BasicAuthentication</name><environment>Net</environment><super>Net.HttpAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.BasicAuthentication</class-id><body>BasicAuthentication creates user credentials based on Basic Authentication Scheme (RFC2617). The "basic" authentication scheme is based on the model that the client must authenticate itself with a user-ID and a password for each realm. The Basic authentication scheme is not a secure method of user authentication, nor does it in any way protect the entity, which is transmitted in cleartext across the physical network used as the carrier.</body></comment><class><name>BodyWriteStream</name><environment>Net</environment><super>Net.MessageStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer onFinishDo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.BodyWriteStream</class-id><body>The purpose of this stream is to replace the chunked write stream in the case the user wants to avoid chunking (see #doNotChunk). We still need to buffer the contents to compute the correct Content-Length value.Instance Variables	buffer	&lt;ReadWriteStream on: ByteArray&gt; internal stream to buffer the contents	onFinishDo	&lt;BlockClosure&gt; a callback exectuted when the stream is being #finished; will receive buffer position as argument</body></comment><class><name>HttpWriteHandler</name><environment>Net</environment><super>Net.MimeWriteHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpWriteHandler</class-id><body>This is the writer for HTTP messages. It allows to use compression for message transfer (#useGZipTransfer flag, false by default). It also allows to write messages in a simple continious form with content-length header field specifying the actual message body size in bytes, or in a "chunked" form splitting the body in a number of pieces which doesn't require knowing the full body size upfront (and therefore doesn't include the content-length header). In chunked form the message body is terminated with an "empty" chunk instead. Messages are chunked by default, but this behavior can be controlled using the #shouldChunk option in the following way: If #shouldChunk is true (default)	- if message body size exceeds the size specified by the #chunkSize option (#defaultChunkSize is set to 4K), the message will be chunked	- if message body size has fewer bytes than the specified #chunkSize, the messages will not be chunked and will use the content-length header insteadIf #shouldChunk is false	- the message will not be chunked regardless of body size and will use the content-length header instead.Note that, when #shouldChunk is false, the writer needs to be able to determine the exact, *final* byte size of the message body (i.e. if the body is to be compressed it has to be the compressed size). The size has to be known before it starts writing the body, so that it can inject the correct content-length field into the header. In general in this mode the body is first written into an internal stream to determine the correct byte count, then the header is finished with the right content-length and finally the body bytes are copied from the internal stream. As an optimization, if the body is simple (i.e. not multi-part) and the size of the body is known upfront, the writer will use that body size for the content-length field and then write the body bytes to the outging stream directly. This doesn't change the behavior in any way, it just may be useful to know that this particular case is handled in more efficient manner than the other non-chunked cases.Instance VariablesClass Instance Variables	Examples:1. 	Writing a message with contens-length field. Message body size doesn't exceeds the default #chunkSize 	(request := HttpRequest post: 'http://localhost:4461/')		contents: HttpWriteHandler xmlDefinition.	stream := ((ByteArray new: 100) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler write: request on: stream.	stream reset; contents. 2. Writing a message in chunked format. 	contents := (Filename fromComponents: ('$(VISUALWORKS)/net/HTTP.pcl' tokensBasedOn: $/)) asFilename contentsOfEntireFile.	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler write: request on: stream.	stream reset; contents. 3. Writing a message with "Content-length:" field. 	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		doNotChunk;		writeMessage: request on: stream.	stream reset; contents. 4. Writing a message in gzipped and chunked format	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		useGZipTransfer: true;		writeMessage: request on: stream.	stream reset; contents. 5. Writing a message with specified chunked size	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		chunkSize: 10;		writeMessage: request on: stream.	stream reset; contents. 6. Writing a message in gzipped format with "Contents-length"	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		doNotChunk;		useGZipTransfer: true;		writeMessage: request on: stream.	stream reset; contents. </body></comment><class><name>HttpRequestLine</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method url version prefix path useProxy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRequestLine</class-id><body>Represents the requst line of Http message.	Request-Line   = Method SP Request-URI SP HTTP-Version CRLFInstance Variables:	method	&lt;String&gt; the method to be applied to the resource	url	&lt;URI&gt; the resorce locator	version	&lt;String&gt; HTTP protocol version to use	prefix	&lt;String&gt; the request line prefix	path	&lt;URI&gt; the request line path	useProxy	&lt;Boolean&gt; defines whether or not the server is proxy</body></comment><class><name>HttpInformationalError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpInformationalError</class-id><body>This class reports http informational errors which are reported by the HTTP server being accessed.1xx: Informational - Request received, continuing processInstance Variables:</body></comment><class><name>HttpParser</name><environment>Net</environment><super>Net.MimeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpParser</class-id><body>This class is parser for HTTP messages. It's knows how to parse chunked HTTP message bodies, the first line of the Http message and messages with gzipped contents.To be able to read a message and parse it at the same time the parser creates a few layers of streams that wrap an underlaying stream.A possible stack of streams can include the layers in the following order:- to parse an internal stream it is wrapped in to DecodedStream- a chunked message stream is wrapped in to ChunkedStream- then the message stream is wrapped in to BodyStream which reads the number of bytes as it is specified by the message contents length- if the message transfer encoding indicates that compression (gzip) was applied the stream is wrapped in to OS.ZLib.GZipReadStream- the multipart message stream is wrapped in to BoundedStreamInstance Variables:	readBoundary &lt;String&gt;  a multipart message boundary	atEnd &lt; Boolean&gt;  indicates whether or not the last part of a multipart message has being parsed</body></comment><class><name>HttpClientError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpClientError</class-id><body>This class reports http client errors which are reported by the HTTP server being accessed.4xx: Client Error - The request contains bad syntax or cannot be        fulfilledInstance Variables:</body></comment><class><name>HttpUnauthorizedError</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpUnauthorizedError</class-id><body>This class reports 401 error which are reported by the HTTP server being accessed."401"   ; UnauthorizedInstance Variables:</body></comment><class><name>HttpProxyAuthenticationError</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpProxyAuthenticationError</class-id><body>This class reports 407 error which are reported by the HTTP server being accessed."407"   ; Proxy Authentication RequiredInstance Variables:</body></comment><class><name>RegistryLimitationExc</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.RegistryLimitationExc</class-id><body>RegistryLimitationExc exception is raised when one of the registry limits was exceeded</body></comment><class><name>HttpRedirectionError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRedirectionError</class-id><body>This class reports redirection errors which are reported by the HTTP server being accessed.3xx: Redirection - Further action must be taken in order to        complete the requestInstance Variables:</body></comment><class><name>HttpMovedError</name><environment>Net</environment><super>Net.HttpRedirectionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpMovedError</class-id><body>This class reports 301/302 errors which are reported by the HTTP server being accessed."301"   ; Moved Permanently"302"   ; Moved TemporarilyInstance Variables:</body></comment><class><name>AcceptHeaderFields</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptHeaderFields</class-id><body>AcceptHeaderFields is abstract class for "Accept.." header fields.</body></comment><class><name>AcceptCharsetField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptCharsetField</class-id><body>AcceptCharsetField represents "Accept-Charset" header field as it described in RFC2616. The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. </body></comment><class><name>CookieFields</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieFields</class-id><body>CookieFields is super class for 'Cookie', 'Set-Cookie' and 'Set-Cookie2' header fields. </body></comment><class><name>SetCookieField</name><environment>Net</environment><super>Net.CookieFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookieField</class-id><body>SetCookieField represents 'Set-Cookie' field. Implementation is based on RFC2109 and Netscape specification. The field value is collection of SetCookieValue. http://www.faqs.org/rfcs/rfc2109.htmlThe syntax for the Set-Cookie response  header is   set-cookie      =       "Set-Cookie:" cookies   cookies         =       1#cookieSupports httponly cookie attribute:Set-Cookie: &lt;name&gt;=&lt;value&gt;[; &lt;name&gt;=&lt;value&gt;][; expires=&lt;date&gt;][; domain=&lt;domain_name&gt;][; path=&lt;some_path&gt;][; secure][; HttpOnly]http://msdn.microsoft.com/en-us/library/ms533046.aspxIf the HttpOnly attribute is included in the response header, the cookie is still sent when the user browses to a Web site in the valid domain. The cookie cannot be accessed through script in Internet Explorer 6 SP1, even by the Web site that set the cookie in the first place. This means that even if a cross-site scripting bug exists, and the user is tricked into clicking a link that exploits this bug, Windows Internet Explorer does not send the cookie to a third party. The information is safe.Note  The use of HTTP-only cookies is one of several techniques that, when used together, can mitigate the risk of cross-site scripting. Used alone, it cannot completely eliminate the danger of cross-site scripting.How to create the field:	header := SetCookieField new.	(header addName: 'Customer' value: 'WILE_E_COYOTE')		secure: true;		domain: 'cincom.com';		maxAge: 0;		comment: 'some comments'.</body></comment><class><name>NTLMAuthentication</name><environment>Net</environment><super>Net.HttpAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>domain decodedData flags workstation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.NTLMAuthentication</class-id><body>NTLMAuthentication creates user credentials based on NTLM Authentication Scheme. See http://davenport.sourceforge.net/ntlm.htmlNTLM is an authentication protocol used in various Microsoft network protocol implementations and supported by the NTLM Security Support Provider ("NTLMSSP"). Limitations: Doesn't support NTLMv2. Instance Variables:	domain	&lt;String&gt; domain	decodedData	&lt;ByteArray&gt; decodedData - NTLM challenge from type 2 message	flags	&lt;ByteArray&gt; list of features supported by the server and client.	workstation	&lt;String&gt; workstation</body></comment><class><name>HttpConnection</name><environment>Net</environment><super>Net.NetConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpConnection</class-id><body>HttpConnection is the HTTP connection stream wrapper</body></comment><class><name>CookieValueWithParams</name><environment>Net</environment><super>Net.ValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setSelectors printSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieValueWithParams</class-id><body>CookieValueWithParams is super class for cookie value. Implements cookie field parsing and printing.Instance Variables:	printSelectors	&lt;Dictionary&gt;	print selectors for cookie field parameters	setSelectors	&lt;Dictionary&gt;	set selectors for cookie field parameters</body></comment><class><name>SetCookieValue</name><environment>Net</environment><super>Net.CookieValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>policy </class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookieValue</class-id><body>SetCookieValue represents value of 'Set-Cookie2' header field. Implementation supports RFC2109 and Netscape specificationhttp://www.faqs.org/rfcs/rfc2109.htmlThe Netscape syntax isSet-Cookie: NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure;httponlyThe syntax for the Set-Cookie response  header is   set-cookie      =       "Set-Cookie:" cookies   cookies         =       1#cookie   cookie          =       NAME "=" VALUE *(";" set-cookie-av)   NAME            =       attr   VALUE           =       value   set-cookie-av   =       "Comment" "=" value                   |       "Discard"                   |       "Domain" "=" value                   |       "Max-Age" "=" value                   |       "Path" "=" value                   |       "Secure"			 |	   "Httponly"                   |       "Version" "=" 1*DIGIT</body></comment><class><name>SetCookie2Value</name><environment>Net</environment><super>Net.SetCookieValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookie2Value</class-id><body>SetCookie2Value represents value of 'Set-Cookie2' header field.http://www.faqs.org/rfcs/rfc2965.htmlThe syntax for the Set-Cookie2 response   header is   set-cookie      =       "Set-Cookie2:" cookies   cookies         =       1#cookie   cookie          =       NAME "=" VALUE *(";" set-cookie-av)   NAME            =       attr   VALUE           =       value   set-cookie-av   =       "Comment" "=" value                   |       "CommentURL" "=" &lt;"&gt; http_URL &lt;"&gt;                   |       "Discard"                   |       "Domain" "=" value                   |       "Max-Age" "=" value                   |       "Path" "=" value                   |       "Port" [ "=" &lt;"&gt; portlist &lt;"&gt; ]                   |       "Secure"                   |       "Version" "=" 1*DIGIT   portlist        =       1#portnum   portnum         =       1*DIGIT</body></comment><class><name>HttpResponseStatusLine</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code message protocol version </inst-vars><class-inst-vars>messages </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpResponseStatusLine</class-id><body>Represents the first line of an HttpResponse message that consists of the protocol, version followed by a numeric status code and its associated textual phrase.	Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLFInstance Variables:	code	&lt;String&gt; the response code	message	&lt;String&gt; the code phrase part of the line	protocol	&lt;String&gt; the protocol part of the line	version	&lt;String&gt; the version part of the lineClass Instance Variables:	messages	&lt;Dictionary key: String value: String&gt; maps codes to status line messages#code method returns element is a 3-digit integer result code of the  attempt to understand and satisfy the request. (Status-Code)#message method is return a short textual description of the code (Reason-Phrase)</body></comment><class><name>ChunkedReadStream</name><environment>Net</environment><super>Net.ChunkedStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ChunkedReadStream</class-id><body>ChunkedReadStream helps to read chunked messages. Instance Variables:</body></comment><class><name>AuthenticationValue</name><environment>Net</environment><super>Net.HeaderFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data realm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticationValue</class-id><body>AuthenticationValue parses, composes and holds values for Basic and NTLM authorization and authenication header fieldsInstance Variables:	data	&lt;String&gt; authetication data	realm	&lt;Object&gt; realm identifier (for Basic Authentication)</body></comment><class><name>HttpBadRequest</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpBadRequest</class-id><body>HttpBadRequest reports 400 Http errors. The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications</body></comment><class><name>DigestAuthenticationValue</name><environment>Net</environment><super>Net.ValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.DigestAuthenticationValue</class-id><body>DigestAuthenticationValue parses, composes and holds values for Digest authorization and authenication header fields </body></comment><class><name>Cookie2Field</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.Cookie2Field</class-id><body>Cookie2Field represents 'cookie2' Http header field. The field is described in RFC2965 and facilitate interoperation between clients and servers that understand different versions of the cookie specification.	"Cookie2:" cookie-version</body></comment><class><name>HttpObjectNotFound</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpObjectNotFound</class-id><body>HttpObjectNotFound reports 404 errors. The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent.</body></comment><class><name>HttpTimeout</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpTimeout</class-id><body>Timeout exception is raised after the time we wait while reading a buffer in HttpSockedAccessor is expired.  Instance Variables:</body></comment><class><name>AuthorizationField</name><environment>Net</environment><super>Net.AuthenticateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthorizationField</class-id><body>AuthorizationField represents 'authorization'  header field as it described in RFC2616. The client is expected to retry the request, passing an Authorization  header line, which is defined according to the server authentication challenge</body></comment><class><name>AcceptLanguageField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptLanguageField</class-id><body>AcceptLanguageField represents Accept-Language header field as it described in RFC2616. The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. </body></comment><class><name>CacheControl</name><environment>Net</environment><super>Net.CollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CacheControl</class-id><body>CacheControl represents 'cache-control' Http header field. The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. Cache-Control   = "Cache-Control" ":" 1#cache-directive	cache-directive = cache-request-directive  | cache-response-directive	cache-request-directive =                            "no-cache" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-store"                          | "max-age" "=" delta-seconds                          | "max-stale" [ "=" delta-seconds ]                          | "min-fresh" "=" delta-seconds                          | "only-if-cached"                          | cache-extension	cache-response-directive =                            "public"                          | "private" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-cache" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-store"                          | "no-transform"                          | "must-revalidate"                          | "proxy-revalidate"                          | "max-age" "=" delta-seconds                          | cache-extensionno-cache  Indicates that all or part of the response message MUST NOT be cached  anywhere. This allows an origin server to prevent caching even by  caches that have been configured to return stale responses to client  requestsNote: Most HTTP/1.0 caches will not recognize or obey this  directive.</body></comment><class><name>CookieAgent</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry cacheCookies useCachedCookies enableLimits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieAgent</class-id><body>CookieAgent provides cookie management during a session with Http requests and responses. Implementation based on RFC2965 and Netscape preliminary specification (http://wp.netscape.com/newsref/std/cookie_spec.html).Instance Variables:	cacheCookies	&lt;Boolean&gt;	specifies whether or not to cache cookies	enableLimits	&lt;Boolean&gt;	specifies whether or not to check registry limits	registry	&lt;Dictionary&gt; cookie registry	useCachedCookies	&lt;Boolean&gt;	specifies whether or not to use cached cookie when a session startsShared variable Registry &lt;Dictionary &gt;  holds cached cookies.How to create cookie fields:"Creating Cookies using Netscape style"header := SetCookieValue netscapeStyleName: 'Customer' value: 'WILE_E_COYOTE'.header 		secure: true;		expires: Timestamp now;		path: '/smalltalk';		domain: 'cincom.com'.'Customer=WILE_E_COYOTE;expires=Mon, 31 Jan 2005 19:36:35 GMT;path=/smalltalk;secure;domain=cincom.com'cookie := CookieField newNetscape.cookie 		addValue: (CookieValue name: 'Customer' value: 'WILE_E_COYOTE');		addValue: ( CookieValue name: 'Part_Number' value: 'Rocket_Launcher_0001');		addValue: ( CookieValue name: 'Shipping' value: 'FedEx'). 'Cookie: Customer=WILE_E_COYOTE;Part_Number=Rocket_Launcher_0001;Shipping=FedEx'"Creating RFC style cookies"cookie := CookieField new.val := cookie addName: 'Customer' value: 'WILE_E_COYOTE'.val 	path: '\acme';	domain: 'foo.com';	port: 8085.val := cookie addName: 'Part_Number' value: 'Rocket_Launcher_0001'.val 	path: '\info';	domain: 'foo1.com'.'Cookie: $version=1;	Customer=WILE_E_COYOTE;$path=\acme;$port="8085";$domain=foo.com;	Part_Number=Rocket_Launcher_0001;$path=\info;$domain=foo1.com'header := SetCookieValue name: 'Customer' value: 'WILE_E_COYOTE'.header 		secure: true;		domain: 'cincom.com';		maxAge: 0;		comment: 'some comments'.'Customer=WILE_E_COYOTE;max-age=0;comment="some comments";domain=cincom.com;version=1;secure'header := SetCookie2Value name: 'Customer' value: 'WILE_E_COYOTE'.header 		secure: true;		domain: 'cincom.com';		maxAge: 0;		comment: 'some comments';		port: (OrderedCollection with: 8080 with: 80).'Customer=WILE_E_COYOTE;secure;comment="some comments";max-age=0;domain=cincom.com;port="8080,80";version=1'</body></comment><class><name>HttpWritingOptions</name><environment>Net</environment><super>Net.MimeWritingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useGZipTransfer chunkSize shouldChunk logAsPrintString </inst-vars><class-inst-vars>useGZipTransfer shouldChunk logAsPrintString </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpWritingOptions</class-id><body>HttpWritingOptions is holding the HttpWriteHandler/HttpPrintHandler options and knows how to create an instance of HttpWriteHandler/HttpPrintHandler.Instance Variables	chunkSize	&lt;Number&gt; specifies at what body size to start chunking the message	logAsPrintString	&lt;Boolean&gt; defines how a request is printed in the Logging Tool. If the option is set to true the message is using #printString for log. If the option is false the message will be written to the log as it send to a socket stream.	shouldChunk &lt;Boolean&gt; to switch the automatic body chunking on and off. See HttpWriteHandler for more details about the chunking option	useGZipTransfer	&lt;Boolean&gt; defines whether to transfer a message in gzip format. Adds gzip to the transfer-encoding fieldClass Instance Variables	useGZipTransfer	&lt;Boolean&gt; default value for message transfer compression	shouldChunk &lt;Boolean&gt; default value for a message chunking	logAsPrintString	&lt;Boolean&gt; default for logging messages</body></comment><class><name>HttpReadingOptions</name><environment>Net</environment><super>Net.MimeReadingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decompressContents decodeContents </inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpReadingOptions</class-id><body>HttpReadingOptions holds HttpBuildHandler optrions and knows how create an instance of HttpBuildHandlerInstance Variables	decompressContents	&lt;Boolean&gt; should we decompress message contents if it is compressed	decodeContents	&lt;Boolean&gt; should we decode message contents into charactersClass Instance Variables	decompressContents	&lt;Boolean&gt; should we decompress message contents if it is compressed	decodeContents &lt;Boolean&gt; should we decode message contents into characters</body></comment><class><name>HttpUser</name><environment>Net</environment><super>Net.NetUser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realms </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpUser</class-id><body>HttpUser holds a Http client authentication informationInstance Variables:	realms	&lt;OrderedCollection of String&gt;	 realms where the user token is accepted. The realm value in combination with the canonical root URL of the server being accessed, defines the protection space.</body></comment><class><name>HttpAuthenticationExc</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpAuthenticationExc</class-id><body>HttpAuthenticationExc will be raise if there is no support the challenge scheme received from a server</body></comment><class><name>HttpSocketAccessor</name><environment>Net</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpSocketAccessor</class-id><body>This class overrides its superclass to allow timeouts on reads, and also to choose a different kind of IOBuffer (indirectly through its choice of ExternalConnection class).Instance Variables:	time	&lt;Integer&gt;	time of the last successful read, in milliseconds	timeout	&lt;Integer&gt;	how long we should wait while reading a buffer, before assuming the connection died.</body></comment><class><name>HttpEntityError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpEntityError</class-id><body>This exception is raised if the error was detected while parsing the http entity. </body></comment><class><name>DigestAuthentication</name><environment>Net</environment><super>Net.HttpAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nonceCount md5SessData defaultAlgorithm </inst-vars><class-inst-vars>defaultAlgorithm </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.DigestAuthentication</class-id><body>DigestAuthentication creates user credentials based on Digest Authentication Scheme (RFC2617). The Digest scheme challenges using a nonce value. A valid response contains a checksum (by default, the MD5 checksum) of the username, the password, the given  nonce value, the HTTP method, and the requested URI.Limitations: &lt;qop=auth-int&gt; - option has not been implemented.  If the option is used the hash of the entity body has to be calculated.Instance Variables:	md5SessData	&lt;String&gt;	MD5 checksum	nonceCount	&lt;SmallInteger&gt;	description of nonceCount	defaultAlgorithm &lt;String&gt;  the value can be 'MD5' or 'MD5-sess'.Class Instance Variables:	defaultAlgorithm &lt;String&gt;  default algorithm  (MD5)</body></comment><class><name>HttpEntity</name><environment>Net</environment><super>Net.MimeEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextNamespaceId </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpEntity</class-id><body>Represents HttpEntity super class. Supports protocol to parse and compose chunked http entity.API to handle message contens: #byteContents - returns row bytes as ByteArray#contents - retuns decoded message contents based on the message charset as ByteString. If the message was not decompresssed returns row bytes as string.#decompressedContents - returns decompress row bytes if the message includes "Content-Encoding: gzip" header field. The header fields will not be removed and the message contents will not be changed. It will still contain row bytes.#decodedContents - returns decoded message contents based on the message charset encoding. The message contents will not be changed.Options to write message contens: #useGZipTransfer#chunkSize#shouldChunkThe 'mandatory extension' category represents implementation of RFC2774 			An HTTP Extention FrameworkInstance Variables	nextNamespaceId	&lt;Number&gt; represents two-digit header prefix for extention declaration</body></comment><class><name>HttpRequest</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRequest</class-id><body>Represent Http request message from client to a server. A request message from a client to a server includes, within the first line of that message, the method to be applied to the resource,  the identifier of the resource, and the protocol version in use. The rest of the message is standard MIME entity.  The methods in low-level command interface protocol allow to execute the request and get a response.Instance Variables:	requestLine	&lt;HttpRequstLine&gt;	an instance of HttpRequestLineSamples:	"To decompress contents of a response with compressed transfer encoding"	url := 'http://www.fark.com' asURI.	req := HttpRequest get: url.	req fieldValueAt: 'Accept-Encoding' put: 'gzip'.	req decompressContents: true.	resp := req execute.	"To send a binary file as a post request, compressed and not chunked"	file := (Filename fromComponents: ('$(VISUALWORKS)/net/HTTP.pcl' tokensBasedOn: $/)) asFilename readStream binary.	(request := HttpRequest post: 'http://localhost:4461/')		byteSource: file.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		doNotChunk;		useGZipTransfer: true;		writeMessage: request on: stream.	stream reset; contents</body></comment><class><name>SetCookie2Field</name><environment>Net</environment><super>Net.SetCookieField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookie2Field</class-id><body>SetCookie2Field represents 'Set-Cookie2' field. Implementation is based on RFC2965. The field value is collection of SetCookie2Value. http://www.faqs.org/rfcs/rfc2965.htmlThe syntax for the Set-Cookie2 response   header is   set-cookie      =       "Set-Cookie2:" cookies   cookies         =       1#cookie</body></comment><class><name>AcceptField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptField</class-id><body>AcceptField represents "Accept" header field as it described in RFC2616. The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.</body></comment><class><name>ManOptField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ManOptField</class-id><body>ManOptField represents a mandatory field. For example:Man: http://www.copyright.org/rights-management; ns=16</body></comment><class><name>TransferEncoding</name><environment>Net</environment><super>Net.CollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.TransferEncoding</class-id><body>TransferEncoding represents transfer encoding field as defines in RFC2616. Value of the field is an ordered collection of string tokens.14.41 Transfer-Encoding   The Transfer-Encoding general-header field indicates what (if any)   type of transformation has been applied to the message body in order   to safely transfer it between the sender and the recipient. This   differs from the content-coding in that the transfer-coding is a   property of the message, not of the entity.     Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding   Transfer-codings are defined in section 3.6. An example is:     Transfer-Encoding: chunked   If multiple encodings have been applied to an entity, the transfer-   codings MUST be listed in the order in which they were applied.   Additional information about the encoding parameters MAY be provided   by other entity-header fields not defined by this specification.   Many older HTTP/1.0 applications do not understand the Transfer-   Encoding header.</body></comment><class><name>ChunkedWriteStream</name><environment>Net</environment><super>Net.ChunkedStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>writeLimit useChunks bufferNumber onFinishWithOneBufferDo onReadyToWriteFirstBufferDo </inst-vars><class-inst-vars>defaultWriteLimit </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ChunkedWriteStream</class-id><body>ChunkedWriteStream helps to read and write chunked messages. The ChunkedStream collects the message body bytes in a buffer until the buffer is filled. The buffer size is settable and the default size is 4K. If the message body fits entirely into a single buffer the message won't be chunked, it will be sent as is and the message header will include the "Content-length" field with corresponding byte size value. If the body is longer than the buffer then when the ChunkedStream is about to write the first chunk into the underlying stream it notifies the higher levels of the framework (using callback #onReadyToWriteFirstBufferDo) which will add a "transfer-encoding: chunked" header field instead and the body will be written out in the chunked format. Instance Variables	writeLimit &lt;Number&gt; chunk size	useChunks &lt;Boolean&gt; defines whether or not use chunks to write in to the underlying stream. 	bufferNumber &lt;Number&gt; if the fist buffer is ready to be flushed in to the underlying stream the ChuckedWriteStream raises an exception. The exception is used by the HttpPrinter to add "Transfer-encoding" field to the message	onFinishWithOneBufferDo	&lt;BlockClosure&gt; callback executed when the entire message fits into one buffer and I'm being #finished; called with buffer position as an argument	onReadyToWriteFirstBufferDo	&lt;BlockClosure&gt; callback executed when the first buffer is full, and we're about to write the first chunk</body></comment><class><name>HttpBuildHandler</name><environment>Net</environment><super>Net.MimeParserHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpBuildHandler</class-id><body>This class builds Http messages.  Depending on parsing option the builder writes raw socket bytes in to the message body or decompressed and decoded string. See the option description in the HttpClient class comments. The builder allows to deal with large attachments by saving them directly into files.Instance VariablesClass Instance VariablesSamples1. Creating a request or response entity	httpEntity :=  HttpBuildHandler readFrom: stream.2. Creating an http entity with header parsed only	builder  := HttpBuildHandler on: stream. 	request := builder readHeader.	"Parsing the message body"	builder readBody.3. Saving an attachment with the specified file name	filename := HttpBuildHandler defaultAttachmentDirectory, 'temp.txt'.	client := HttpClient new.	[[response2 := client executeRequest: request.] 		on: AttachmentFilename 		do: [ :ex | ex resume: filename ].	] ensure: [ client close ] ].4. Writing a message with specified chunk size	response := HttpResponse code: '200'. 	response contents: 'sometext'.	response addFileAttachment: someAttachmentFile.	response newWriter			chunkSize: 25;			writeMessage: response on: stream.5. Writing a message in GZip format.		response := HttpResponse code: '200'. 	response contents: 'sometext'.	response newWriter			useGZipTransfer: true;			writeMessage: response on: stream.</body></comment><class><name>HttpDispatcher</name><environment>Net</environment><super>Net.MimeDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpDispatcher</class-id><body>HttpDispatcher is controlling Http message printing/writing</body></comment><class><name>UnspecifiedBodySize</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.UnspecifiedBodySize</class-id><body>The notification is raised if HttpBuildHandler is not able to determine where does a message body end. The resumption value of the notification is a Boolean. If the notification resumes with false (the default, unhandled behavior), the message is assumed to not have a body, and so the handler will stop parsing the message right after the end of the header. If the notification resumes with true, the handler will assume that the body ends at the end of the input stream and attempt to parse the rest of the stream as such.</body></comment><class><name>HttpStatusLineError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpStatusLineError</class-id><body>HttpStatusLineError is raised if the Http parser read an empty response status line</body></comment><class><name>HttpClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request keepAlive protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpClient</class-id><body>This client makes http/https connections to servers in order to request resources via HTTP protocol, which is a superset of MIME. The HttpClient creates connection based on URL protocol which can be http or https.  Supports cookie state management.If the Http client receives the https URL protocol and detects that the HTTPS support is not loaded, the client does the following:1. if the URL Settings allows to auto load the HTTPS parcel, the parcel will be loaded and and created SSL connection2. if the URL Settings Https auto load is turned off (default behavior), the HttpClient raises the ComponentNotLoaded exception. The exception is resumable and resuming the exception by default loads the HTTPS parcel.How to send authorized messages see samples in the AuthenticationPolicy class.Instance Variables:	request	&lt;HttpRequest&gt;	the HttpRequest object	keepAlive	&lt;aBoolean&gt;	 the variable allows to set persistent connection.	protocol &lt;String&gt; 'http' or 'https' based on the protocol will be created an instance of HttpStreamHandlerShared Variables:	Protocol &lt;String&gt; 'http' or 'https'	Connectionconnection stream  is persistent		if  #keepAlive method for the HttpClient instance or request returns  trueconnection stream  is closed after each request		if  #keepAlive method for the HttpClient instance and request returns  falseIf server sends a response with closed connection the HttpClient closes the connection stream but doesn't change the #keepAlive variable.	Error handlingIf user application doesn't provide error handling for HttpClient the HttpClient is going to try handle some exceptions by itself. The exceptions that client can handle are located in the HttpProtocolInterpreter processing category.Sample how to create cookie fields see in CookieAgent commentsThe client will turn on the cookie processing if a server response require authentication. 	</body></comment><class><name>HttpPrintHandler</name><environment>Net</environment><super>Net.MimePrintHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpPrintHandler</class-id><body>This class implements printing of HTTP messages on a stream in a shortened (digest) mode to enhance readability of the output.</body></comment><class><name>HttpProtocolInterpreter</name><environment>Net</environment><super>Net.NetProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authPolicy proxyAuthPolicy cookieAgent enableCookies request hostName portNumber timeout useProxy proxyHost readingOptions writingOptions </inst-vars><class-inst-vars>enableCookieProcessing </class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpProtocolInterpreter</class-id><body>HttpProtocolInterpreter communicates with the Http/Https server via the HttpStreamHandler or HttpsStreamHandler. The HttpProtocolInterpreter creates connection based on URL protocol which can be http or https.  Supports cookie state management and authorization. HttpProtocolInterpreter receives server replies or client requests, parses them into the HttpResponse or HttpRequest and handles them where appropriate. Instance Variables	authPolicy	&lt;AuthenticationPolicy&gt; will handle the authentication challenge from a server and add user credentials to requests. The client enables cookie managment as soon as it receives the 401 exceptions. To validate authorized requests some servers require authorization field and reply cookies.	proxyAuthPolicy	&lt;ProxyAuthenticationPolicy&gt; will handle the authentication challenge from a proxy server and add user credentials to requests. 	cookieAgent	&lt;CookieAgent&gt; provides cookie management	enableCookies	&lt;Boolean&gt; defines whether or not to enable cookie processing	request	&lt;HttpRequest&gt; the HttpRequest object	hostName	&lt;String&gt; the host to connect to	portNumber	&lt;Number&gt; the host port number	timeout	&lt;Number&gt; number millisecond to timeout	useProxy	&lt;Boolean&gt; defines whether or not use proxy connection	proxyHost	&lt;HostSpec&gt; the proxy serverClass Instance Variables	enableCookieProcessing	&lt;Boolean&gt; default for cookie processing</body></comment><class><name>HttpServerError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpServerError</class-id><body>This class reports server errors which are reported by the HTTP server being accessed.5xx: Server Error - The server failed to fulfill an apparently        valid requestInstance Variables:</body></comment><class><name>HttpResponse</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statusLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpResponse</class-id><body>Represents the responce that a server replies after receiving and interpreting a request message. The first line of a HttpResponse message is the status line.Instance Variables:	statusLine	&lt;HttpStatusLine&gt;	an instance of HttpStatusLine</body></comment><class><name>CookieValue</name><environment>Net</environment><super>Net.CookieValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieValue</class-id><body>CookieValue represents value for CookieField class. Supports two specifications RFC2965 and Netscape preliminary specification.   The RFC2965 syntax for the header is:cookie          =  "Cookie:" cookie-version 1*((";" | ",") cookie-value)cookie-value    =  NAME "=" VALUE [";" path] [";" domain] [";" port]cookie-version  =  "$Version" "=" valueNAME            =  attrVALUE           =  valuepath            =  "$Path" "=" valuedomain          =  "$Domain" "=" valueport            =  "$Port" [ "=" &lt;"&gt; value &lt;"&gt; ]The Netscape syntax is:Cookie: NAME1=OPAQUE_SRTING1; NAME2=OPAQUE_STRING2...Sample how to create cookie fields see in CookieAgent comments</body></comment><class><name>CookieField</name><environment>Net</environment><super>Net.CookieFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieField</class-id><body>CookieField represents 'Cookie' field. Instance Variables:	version	&lt;Number&gt;	cookie version	value &lt;Collection&gt; collection of CookieValueSample how to create cookie fields see in CookieAgent comments</body></comment><shared-variable><name>Protocol</name><environment>Net.HttpClient</environment><private>false</private><constant>false</constant><category>protocol</category><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>CookieStyle</name><environment>Net.CookieValueWithParams</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>Preferences</name><environment>Net.HttpException</environment><private>false</private><constant>false</constant><category>preferences</category><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>DefaultVersion</name><environment>Net.CookieFields</environment><private>false</private><constant>false</constant><category>style</category><initializer>nil</initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>EnableLimits</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>CacheCookies</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>UseCachedCookies</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>ServersCacheCookiesFrom</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberEntries</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberBytesPerCookie</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberEntriesPerServer</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><methods><class-id>Net.AuthenticateField</class-id> <category>adding </category><body package="HTTP" selector="addBasic">addBasic	^self addScheme: 'Basic'</body><body package="HTTP" selector="addBasicRealm:">addBasicRealm: rString	^self addBasic realm: rString</body><body package="HTTP" selector="addDigest">addDigest	^self addScheme: 'Digest'</body><body package="HTTP" selector="addDigestRealm:">addDigestRealm: aString	^self addDigest realm: aString</body><body package="HTTP" selector="addNTLM">addNTLM	^self addScheme: 'NTLM'</body><body package="HTTP" selector="addNegotiate">addNegotiate	^self addScheme: 'Negotiate'</body><body package="HTTP" selector="addScheme:">addScheme: aString	| valWithParams newVal |	valWithParams := self valueWithParamsClass newWithSeparators: self separators.	valWithParams value: aString.	self value add: (newVal := self privateNewValueFrom:  valWithParams).	^newVal</body><body package="HTTP" selector="addScheme:realm:">addScheme: vString realm: rString	| valWithParams |	valWithParams := self addScheme: vString.	rString ifNotNil: [ valWithParams realm: rString].	^valWithParams</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>accessing</category><body package="HTTP" selector="basicScheme">basicScheme	^self value select: [ :each | each isBasic ]</body><body package="HTTP" selector="detectRealm">detectRealm	| coll val |	coll := self basicScheme.	coll addAll: self digestScheme.	val := coll detect: [ :each | each realm notNil ] ifNone: [ nil ].	^val realm</body><body package="HTTP" selector="digestScheme">digestScheme	^self value select: [ :each | each isDigest ]</body><body package="HTTP" selector="ntlmScheme">ntlmScheme	^self value select: [ :each | each isNTLM ]</body><body package="HTTP" selector="scheme">scheme	^self schemes first</body><body package="HTTP" selector="schemes">schemes	| coll |	coll := OrderedCollection new.	self value do: [ :each | ('negotiate' match: each scheme asLowercase) ifFalse: [coll add: each scheme] ].	^coll</body><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^AuthenticationValue</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>obsolete</category><body package="HTTP" selector="addBasic:">addBasic: vString	^self addScheme: vString</body><body package="HTTP" selector="addBasic:realm:">addBasic: vString realm: rString	^self addScheme: vString realm: rString</body><body package="HTTP" selector="realm">realm	^self detectRealm</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>testing</category><body package="HTTP" selector="canNegotiate">canNegotiate	^'negotiate' match: self first scheme asLowercase</body><body package="HTTP" selector="hasBasicAuth">hasBasicAuth	^self basicScheme notEmpty</body><body package="HTTP" selector="hasDigestAuth">hasDigestAuth	^self digestScheme notEmpty</body><body package="HTTP" selector="hasNTLMAuth">hasNTLMAuth	^self ntlmScheme notNil</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>parsing</category><body package="HTTP" selector="newValueFrom:">newValueFrom: scanner	| authVal | 	authVal := self valueWithParamsClass newWithSeparators: self separators.	authVal parseValue: scanner.	^self privateNewValueFrom: authVal</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>private parsing</category><body package="HTTP" selector="privateNewValueFrom:">privateNewValueFrom: authValue	authValue isDigest		ifTrue: 			[ ^DigestAuthenticationValue new					separators: authValue separators;					yourself ].	^authValue</body></methods><methods><class-id>Net.AuthenticateField class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($  $, $  )</body></methods><methods><class-id>Net.AuthenticateField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('www-authenticate' 'proxy-authenticate')</body></methods><methods><class-id>Net.AuthenticationInfoField</class-id> <category>accessing</category><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^DigestAuthenticationValue</body></methods><methods><class-id>Net.AuthenticationInfoField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('authentication-info' )</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>accept challenge</category><body package="HTTP" selector="acceptAuthInfoFrom:">acceptAuthInfoFrom: aHttpResponse	self resetRejected.	self authentication ifNotNil: [ self authentication acceptAuthInfoFrom: aHttpResponse ]</body><body package="HTTP" selector="acceptChallenge:">acceptChallenge: aHttpResponse	^self acceptChallenge: aHttpResponse request: nil</body><body package="HTTP" selector="acceptChallenge:request:">acceptChallenge: aHttpResponse request: aHttpRequest"1. no user/pass ----  pass exc2. no authenticate field -----  pass exc3. authorization is provided but not accepted. 	a. wrong user/pass	b. wrong scheme 	c. different realm- try another scheme if there is a choice- there is no scheme that accepts the challenge - pass exc- retry for diff. realm if the scheme auth depends on it"	| authenticate |	"if there is a user name and password provided or challenge in the response"	(self canBeAuthorized not		or: [(authenticate := self authenticateFieldFrom: aHttpResponse) isNil])			 ifTrue: [ ^false].	"some scheme's (NTLM) may require additional replies to complete authorization "	(self isAuthorizationInProgress and: [self authentication proceedWith: authenticate ])		ifTrue: [^true].	"the request has being authorized "	self isAuthorized 		ifTrue: [	"check if there is a different realm in the challenge"				(self authentication canAccept: authenticate) ifTrue: [ ^true].				"try another scheme if any"				^self tryAnotherAuthFrom: authenticate].	"it has not being authorized yet "	^(authentication := self newPolicyFrom: authenticate) notNil</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>accessing</category><body package="HTTP" selector="authOrder">authOrder	^authOrder ifNil: [ authOrder := self class authOrder ]</body><body package="HTTP" selector="authOrder:">authOrder: aCollectionOfHttpAuth	authOrder := aCollectionOfHttpAuth</body><body package="HTTP" selector="authentication">authentication	^authentication</body><body package="HTTP" selector="authentication:">authentication: anHttpAuthentication	authentication := anHttpAuthentication</body><body package="HTTP" selector="header">header	^'authorization'</body><body package="HTTP" selector="password">password	^self user password</body><body package="HTTP" selector="realm">realm	^self user realm</body><body package="HTTP" selector="realm:">realm: aString	self user addRealm: aString.</body><body package="HTTP" selector="rejected">rejected	rejected ifNil: [ self resetRejected ].	^rejected</body><body package="HTTP" selector="resetRejected">resetRejected	rejected := OrderedCollection new</body><body package="HTTP" selector="user">user	^user ifNil: [ user := HttpUser new]</body><body package="HTTP" selector="username">username	^self user username</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>testing</category><body package="HTTP" selector="canBeAuthorized">canBeAuthorized	^self username notNil and: [ self password notNil]</body><body package="HTTP" selector="isAuthorizationInProgress">isAuthorizationInProgress	^self authentication notNil  and: [ self authentication isAuthorizationInProgress]</body><body package="HTTP" selector="isAuthorized">isAuthorized	^self authentication notNil and: [self authentication isAuthorized]</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>initialize-release</category><body package="HTTP" selector="setNotAuthorizedState">setNotAuthorizedState	self authentication ifNotNil: [ self authentication setNotAuthorizedState ].	self resetRejected</body><body package="HTTP" selector="useBasicAuth">useBasicAuth	authentication := BasicAuthentication policy: self</body><body package="HTTP" selector="useNTLMAuth">useNTLMAuth	authentication := NTLMAuthentication policy: self.	authentication authChallenge: AuthenticateField new addNTLM.</body><body package="HTTP" selector="user:">user: aHttpUser	aHttpUser ifNil: [^nil].	self username: aHttpUser username password: aHttpUser password realm:nil</body><body package="HTTP" selector="username:password:">username: aString password: pString	self username: aString password: pString realm: nil</body><body package="HTTP" selector="username:password:realm:">username: aString password: pString realm: rString	(self username = aString and: [self password = pString]) ifTrue: [^nil].	self setNotAuthorizedState.	user := HttpUser username: aString password: pString.	user addRealm: rString.</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>private</category><body package="HTTP" selector="authenticateFieldFrom:">authenticateFieldFrom: aHttpResponse	| field |	^(field := aHttpResponse wwwAuthenticate) isEmpty 		ifTrue: [nil]		ifFalse: [ field first  ].</body><body package="HTTP" selector="detectSupportedPolicy:">detectSupportedPolicy: anAuthentication	|  polCl challenge |	polCl := self authOrder 		detect: 			[ :scheme | 				(challenge := anAuthentication value 					select: [ :val | scheme acceptScheme: val scheme]) notEmpty ] 		ifNone: [HttpAuthenticationExc 				raiseRequestWith: anAuthentication				errorString: (#ThereIsNoSupportedAuthentication &lt;&lt; #net &gt;&gt; 'There is no supported authentication detected in: &lt;1s&gt;' expandMacrosWith:  anAuthentication printString)].	^polCl-&gt;challenge</body><body package="HTTP" selector="newPolicyFrom:">newPolicyFrom: anAuthenticate	|  policyChallenge |	anAuthenticate  ifNil: [ ^nil ].	policyChallenge := self detectSupportedPolicy: anAuthenticate.	(authentication := policyChallenge key policy: self )		setAuthChallengeFrom: policyChallenge value.	^authentication</body><body package="HTTP" selector="tryAnotherAuthFrom:">tryAnotherAuthFrom: anAuthentication		| challenge polClass |	self rejected add: self authentication class.	self authOrder size = self rejected size ifTrue: [^false].	polClass := self authOrder 		detect: 			[ :scheme | 			(self rejected includes: scheme) not 				and: [(challenge := anAuthentication value 						select: [ :val | scheme acceptScheme: val scheme]) notEmpty ]] 		ifNone: [nil].	polClass isNil ifTrue: [ ^false].	(authentication := polClass policy: self ) setAuthChallengeFrom: challenge.	^authentication notNil</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>add authorization</category><body package="HTTP" selector="addAuthorizationTo:">addAuthorizationTo: aHttpRequest	(self canBeAuthorized not or: [self authentication isNil]) ifTrue: [ ^nil].	aHttpRequest removeFieldAt: self header.	self authentication addAuthorizationTo: aHttpRequest for: self header.</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>deprecation</category><body package="HTTP" selector="username:password:realm:useProxy:">username: aString password: pString realm: rString useProxy: aBoolean	self deprecated: #(#version '7.7' #sunset '8.0' #use #username:password:realm:).	self username: aString password: pString realm: rString</body><body package="HTTP" selector="username:password:useProxy:">username: aString password: pString useProxy: aBoolean	self deprecated: #(#version '7.7' #sunset '8.0' #use #username:password:realm:).	self username: aString password: pString realm: nil</body></methods><methods><class-id>Net.AuthenticationPolicy class</class-id> <category>accessing</category><body package="HTTP" selector="authOrder">authOrder	^authOrder ifNil: [ authOrder := self defaultAuthOrder ]</body><body package="HTTP" selector="authOrder:">authOrder: aCollection	authOrder := aCollection</body></methods><methods><class-id>Net.AuthenticationPolicy class</class-id> <category>default values</category><body package="HTTP" selector="defaultAuthOrder">defaultAuthOrder	^Array 		with: NTLMAuthentication		with: DigestAuthentication 		with: BasicAuthentication</body></methods><methods><class-id>Net.AuthenticationPolicy class</class-id> <category>instance creation</category><body package="HTTP" selector="username:password:">username: aString password: pString	^self new		username: aString password: pString;		yourself</body></methods><methods><class-id>Net.AuthenticationPolicy class</class-id> <category>deprecation</category><body package="HTTP" selector="username:password:useProxy:">username: aString password: pString useProxy: aBoolean	self deprecated: #(#version '7.7' #sunset '8.0' #use #username:password).	^self  new 			username: aString password: pString;			yourself</body></methods><methods><class-id>Net.ProxyAuthenticationPolicy</class-id> <category>accessing</category><body package="HTTP" selector="header">header	^'proxy-authorization'</body></methods><methods><class-id>Net.ProxyAuthenticationPolicy</class-id> <category>private</category><body package="HTTP" selector="authenticateFieldFrom:">authenticateFieldFrom: aHttpResponse	| field |	^(field := aHttpResponse proxyAuthenticate) isEmpty		ifTrue: [ nil]		ifFalse: [ field first].</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>accessing</category><body package="HTTP" selector="binary">binary</body><body package="HTTP" selector="text">text</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>initialize-release</category><body package="HTTP" selector="initializeOn:">initializeOn: aStream	stream := aStream.	stream binary.</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>testing</category><body package="HTTP" selector="isReadable">isReadable	^self subclassResponsibility</body><body package="HTTP" selector="isWritable">isWritable	^self subclassResponsibility</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>private</category><body package="HTTP" selector="contentsSpecies">contentsSpecies	^ByteArray</body><body package="HTTP" selector="signalError:">signalError: aString	HttpException raiseSignal: aString</body></methods><methods><class-id>Net.HttpURL</class-id> <category>stream -- guarded</category><body package="HTTP" selector="envelopeReadStreamDo:">envelopeReadStreamDo: aBlock	^self safelyExecuteBlock: 			[self clientDo: [ :client | 				client 					readStreamCmd: 'GET' 					url: self 					do: [ :connection |  aBlock value: connection ]]]</body><body package="HTTP" selector="envelopeWriteStreamDo:">envelopeWriteStreamDo: aBlock	^self shouldNotImplement</body><body package="HTTP" selector="readByteStreamDo:">readByteStreamDo: aBlock"Returns not decoded byte array stream and the response header fields "	| message dictionary  |	self safelyExecuteBlock: 		[message := self clientDo: [ :client |						client 							decodeContents: false; 							get: self ]].	self checkMultipart: message.	dictionary := Dictionary new.	message fields 		do: [:fld | dictionary at: fld name put: fld ].	^aBlock 		value: message byteSource reset		value: dictionary</body><body package="HTTP" selector="readStreamDo:">readStreamDo: aBlock"Returns the response contents stream and the response header fields."	| message dictionary |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message.	dictionary := Dictionary new.	message fields 		do: [:fld | dictionary at: fld name put: fld ].	^aBlock 		value: message contents readStream 		value: dictionary</body><body package="HTTP" selector="writeStreamDo:">writeStreamDo: aBlock	^self shouldNotImplement</body></methods><methods><class-id>Net.HttpURL</class-id> <category>stream -- unguarded</category><body package="HTTP" selector="binaryReadStream">binaryReadStream"Returns stream on ByteArray"	| message |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message. 	^message contents asByteArray readStream</body><body package="HTTP" selector="binaryWriteStream">binaryWriteStream	^self shouldNotImplement</body><body package="HTTP" selector="envelopeReadStream">envelopeReadStream		^self safelyExecuteBlock: 		[self client readStreamCmd: 'GET' url: self]</body><body package="HTTP" selector="envelopeWriteStream">envelopeWriteStream	^self shouldNotImplement</body><body package="HTTP" selector="readStream">readStream"Returns stream on ByteString"	| message |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message.	^message contents readStream.</body><body package="HTTP" selector="writeStream">writeStream	^self shouldNotImplement</body></methods><methods><class-id>Net.HttpURL</class-id> <category>private</category><body package="HTTP" selector="checkMultipart:">checkMultipart: aHttpEntity	aHttpEntity isMultipart		ifTrue: 			[self error: (#MultipartBodiesAreNotYetSupported &lt;&lt; #net &gt;&gt; 'Multipart bodies are not yet supported')].</body><body package="HTTP" selector="client">client	| client |	client := HttpClient new.	self user ifNotNil: [ client user: self user ].	client 		decodeContents: self decodeContents;		decompressContents: self decompressContents.	^client</body><body package="HTTP" selector="newClient">newClient"Obsolete"	^self client</body><body package="HTTP" selector="protocolSignals">protocolSignals	^HttpException</body><body package="HTTP" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock	^aBlock on: HttpUnauthorizedError		do: [ :ex |  			self user notNil				ifTrue: [ ex pass]				ifFalse: 					[Settings httpUser notNil						ifTrue: 							[ self user: Settings httpUser.							ex retry ]						ifFalse: [ ex pass]]]</body></methods><methods><class-id>Net.HttpURL</class-id> <category>accessing</category><body package="HTTP" selector="clientDo:">clientDo: aBlock	| client |	client := self client.	^[ aBlock value: client  ] 		ensure: [ client ifNotNil: [ client  close]]</body><body package="HTTP" selector="decodeContents">decodeContents	^decodeContents ifNil: [decodeContents := HttpBuildHandler decodeContents]</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	decodeContents := aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^decompressContents ifNil: [decompressContents := HttpBuildHandler decompressContents]</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	decompressContents := aBoolean</body><body package="HTTP" selector="hostAddress">hostAddress	^self socketAddress hostAddress</body><body package="HTTP" selector="hostAndPort">hostAndPort	^port = self defaultPortNumber		ifTrue: [host]		ifFalse: [host, ':', port printString]</body><body package="HTTP" selector="pathString">pathString	| stream str |	stream := (String new: 32) writeStream.	path do: [:s | stream nextPutAll: '/', s].	str := stream contents.	str isEmpty ifTrue: [str := '/'].	query notNil ifTrue: [str := str, '?', query].	^str</body><body package="HTTP" selector="resource">resource	| message  data |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message. 	data := message body source notNil 			ifTrue: [message charset asSymbol = #'utf-8'					ifTrue: [message body source]					ifFalse: [message body source encoder: (StreamEncoder new: #UTF_8)]]			ifFalse: [ (EncodedStream 						on: message body byteSource						encodedBy: (StreamEncoder new: #UTF_8))					lineEndConvention: LineEndTransparent].	data reset.	^XML.InputSource		uri: self		encoding: nil		stream:  data</body><body package="HTTP" selector="socketAddress">socketAddress	^IPSocketAddress hostName: self host port: self port</body><body package="HTTP" selector="user">user	^user</body><body package="HTTP" selector="user:">user: aNetUser	user := aNetUser</body><body package="HTTP" selector="username:password:">username: nameString password: passString	user := HttpUser username: nameString password: passString</body></methods><methods><class-id>Net.HttpURL</class-id> <category>commands</category><body package="HTTP" selector="get">get	^self clientDo: [ :client | client  get: self ]</body></methods><methods><class-id>Net.HttpURL class</class-id> <category>accessing</category><body package="HTTP" selector="protocol">protocol	^'http'</body></methods><methods><class-id>Net.HttpURL class</class-id> <category>defaults</category><body package="HTTP" selector="defaultPortNumber">defaultPortNumber	^SocketAccessor IPPORT_HTTP</body></methods><methods><class-id>Net.HttpException</class-id> <category>printing</category><body package="HTTP" selector="defaultMessageText">defaultMessageText	^super defaultMessageText, '\(' withCRs, parameter printStatusLineMessage, ')'</body></methods><methods><class-id>Net.HttpException class</class-id> <category>handling http responses</category><body package="HTTP" selector="handleResponse:">handleResponse: resp	"trigger exceptions for all responses but 2xx (success) "	| exp |	resp isSuccess 		ifFalse: 			[ exp := (self preferences detect: [ :ea | ea key match: resp code ]) value.			exp signalWith: resp].	^resp</body><body package="HTTP" selector="initializePreferences">initializePreferences	"self initializePreferences "	Preferences := (OrderedCollection new: 13)		add: '400' -&gt; HttpBadRequest;		add: '401' -&gt; HttpUnauthorizedError;		add: '404' -&gt; HttpObjectNotFound;		add: '407' -&gt; HttpProxyAuthenticationError;		add: '301' -&gt;  HttpMovedError;		add: '302' -&gt;  HttpMovedError;		add: '510' -&gt; HttpNotExtendedError;		add: '1*' -&gt; HttpInformationalError;		add: '3*' -&gt;  HttpRedirectionError;		add: '4*' -&gt; HttpClientError;		add: '5*' -&gt; HttpServerError;		add: '*' -&gt; HttpException;		yourself.</body><body package="HTTP" selector="preferences">preferences	Preferences isNil ifTrue: [ self initializePreferences].	^Preferences</body></methods><methods><class-id>Net.HttpException class</class-id> <category>testing</category><body package="HTTP" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>accessing</category><body package="HTTP" selector="authChallenge">authChallenge	^authChallenge</body><body package="HTTP" selector="authChallenge:">authChallenge: anAuthenticateChallenge	authChallenge := anAuthenticateChallenge.</body><body package="HTTP" selector="authPolicy">authPolicy	^authPolicy</body><body package="HTTP" selector="authValue">authValue	^authValue</body><body package="HTTP" selector="authValue:">authValue: anAuthenticationValue	authValue := anAuthenticationValue</body><body package="HTTP" selector="password">password	^self user password</body><body package="HTTP" selector="pathString">pathString	 ^pathString</body><body package="HTTP" selector="realm">realm	^self user realm</body><body package="HTTP" selector="scheme">scheme	^self class scheme</body><body package="HTTP" selector="user">user			^authPolicy user</body><body package="HTTP" selector="username">username	^self user username</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>authorization</category><body package="HTTP" selector="acceptAuthInfoFrom:">acceptAuthInfoFrom: anAuthInfo</body><body package="HTTP" selector="addAuthorizationTo:for:">addAuthorizationTo: aHttpRequest for: headerString	| header |	self setPathStringFrom: aHttpRequest.	header := aHttpRequest getFieldAt: headerString.  	(self isAuthorized or: [self isAuthorizationInProgress])		ifTrue: [ self setNextAuthorizationValueFor: header ]		ifFalse: 			[self authValue: (header addScheme: self scheme).			self setNewAuthorizationValue.]</body><body package="HTTP" selector="setNewAuthorizationValue">setNewAuthorizationValue	self subclassResponsibility</body><body package="HTTP" selector="setNextAuthorizationValueFor:">setNextAuthorizationValueFor: header	header value add: self authValue.</body><body package="HTTP" selector="setPathStringFrom:">setPathStringFrom: aHttpRequest	pathString := aHttpRequest requestLine pathString</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>state</category><body package="HTTP" selector="setAuthorizationInProgressState">setAuthorizationInProgressState	state := #authorizationInProgress</body><body package="HTTP" selector="setAuthorizedState">setAuthorizedState	state := #authorized</body><body package="HTTP" selector="setNotAuthorizedState">setNotAuthorizedState	authValue := nil.	state := #notAuthorized</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>testing</category><body package="HTTP" selector="canAccept:">canAccept: anAuthorizationField	^false</body><body package="HTTP" selector="canProceedWith:">canProceedWith: anAuthorizationField	^anAuthorizationField isNil		or: [ self username ~= self authPolicy username and: [self password ~= self authPolicy password]]</body><body package="HTTP" selector="isAuthorizationInProgress">isAuthorizationInProgress	^state = #authorizationInProgress</body><body package="HTTP" selector="isAuthorized">isAuthorized	^state = #authorized</body><body package="HTTP" selector="isNotAuthorized">isNotAuthorized	^state = #isNotAuthorized</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	self setNotAuthorizedState</body><body package="HTTP" selector="setAuthPolicy:">setAuthPolicy: anAuthPolicyHolder	authPolicy := anAuthPolicyHolder.</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>select challenge</category><body package="HTTP" selector="proceedWith:">proceedWith: authenticate	| challenges |	challenges := authenticate value select: [ :val | self class acceptScheme: val scheme].	self setAuthChallengeFrom: challenges. 	^challenges notEmpty</body><body package="HTTP" selector="selectAuthChallenge:">selectAuthChallenge: aCollOfAuthenticateChallenge	^self realm isNil		ifTrue: [ aCollOfAuthenticateChallenge first ]		ifFalse: [ aCollOfAuthenticateChallenge 					detect: [ :chall | self user acceptsRealm: chall realm ] 					ifNone: [ HttpAuthenticationExc 								raiseRequestWith: aCollOfAuthenticateChallenge								errorString: (#CannotFindRealm &lt;&lt; #net &gt;&gt; 'Can not find realm &lt;1s&gt; in &lt;2s&gt;' expandMacrosWith:  self realm with: aCollOfAuthenticateChallenge printString) ]]</body><body package="HTTP" selector="setAuthChallenge:">setAuthChallenge: anAuthenticateChallenge	self authChallenge: anAuthenticateChallenge.	self setNotAuthorizedState.</body><body package="HTTP" selector="setAuthChallengeFrom:">setAuthChallengeFrom: anAuthenticateChallengeOrCollection	| ch |	anAuthenticateChallengeOrCollection isEmpty ifTrue: [ ^nil].	(ch := self selectAuthChallenge: anAuthenticateChallengeOrCollection) isNil		ifTrue: 			[ HttpAuthenticationExc 				raiseRequestWith: anAuthenticateChallengeOrCollection				errorString: (#CanNotProcessAuthChallenge &lt;&lt; #net &gt;&gt; 'Can not process authentication challege: &lt;1s&gt;' expandMacrosWith:  anAuthenticateChallengeOrCollection printString) ].	self setAuthChallenge:  ch.</body></methods><methods><class-id>Net.HttpAuthentication class</class-id> <category>accessing</category><body package="HTTP" selector="acceptScheme:">acceptScheme: aString	^aString match: self scheme</body><body package="HTTP" selector="scheme">scheme	^self subclassResponsibility</body></methods><methods><class-id>Net.HttpAuthentication class</class-id> <category>instance creation</category><body package="HTTP" selector="new">new	^super new initialize</body><body package="HTTP" selector="policy:">policy: anAuthPolicy	^self new		setAuthPolicy: anAuthPolicy;		yourself</body></methods><methods><class-id>Net.BasicAuthentication</class-id> <category>authorization</category><body package="HTTP" selector="setNewAuthorizationValue">setNewAuthorizationValue	self authValue basicValue: 		 (self class encodeUser: self username password: self password).	self setAuthorizedState</body></methods><methods><class-id>Net.BasicAuthentication class</class-id> <category>defaults</category><body package="HTTP" selector="scheme">scheme	^'Basic'</body></methods><methods><class-id>Net.BasicAuthentication class</class-id> <category>utilities</category><body package="HTTP" selector="encodeUser:password:">encodeUser: username password: password	| uncodedValue result |	uncodedValue := (username, ':', password) asByteArrayEncoding: #ISO8859_1.	result := (String new: 32) writeStream.	MimeScanner encode: uncodedValue readStream asBase64To: result.	^result contents</body></methods><methods><class-id>Net.BodyWriteStream</class-id> <category>accessing</category><body package="HTTP" selector="buffer">buffer		^buffer</body><body package="HTTP" selector="flush">flush</body><body package="HTTP" selector="nextPut:">nextPut: anObject 		buffer nextPut: anObject</body><body package="HTTP" selector="onFinishDo">onFinishDo	^onFinishDo</body><body package="HTTP" selector="onFinishDo:">onFinishDo: aBlock	onFinishDo := aBlock</body></methods><methods><class-id>Net.BodyWriteStream</class-id> <category>initialize-release</category><body package="HTTP" selector="initializeOn:">initializeOn: aStream	stream := aStream.	buffer := (ByteArray new: 1024) readWriteStream</body></methods><methods><class-id>Net.BodyWriteStream</class-id> <category>status</category><body package="HTTP" selector="finish">finish	self onFinishDo ifNotNil: [ :block | block value: buffer position ].	stream binary.	buffer reset. 	stream nextPutAll: buffer contents.	stream flush</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>action callbacks</category><body package="HTTP" selector="endHeader:">endHeader: aMessageHeader	aMessageHeader parent isHttpEntity ifFalse: [ self stream cr ].	^aMessageHeader parent</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>defaults</category><body package="HTTP" selector="defaultEncoding">defaultEncoding		^HttpConnection defaultEncoding</body><body package="HTTP" selector="dispatcherClass">dispatcherClass	^HttpDispatcher</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>printing utilities</category><body package="HTTP" selector="printHeader:">printHeader: aMessageHeader	aMessageHeader removeKey: 'content-length'.	super printHeader: aMessageHeader</body><body package="HTTP" selector="printPreambule:">printPreambule: aMessageBody	^true</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>private</category><body package="HTTP" selector="addContentLength:entity:">addContentLength: aNumber entity: anEntity	| f |	[ originalStream text.	(Settings httpSetContentLength		and: [ anEntity isMultipartByteranges not ])		ifTrue: [(f := HeaderField name: 'Content-length') value:aNumber.				f writeOn: originalStream.].	originalStream cr.		] ensure: [ originalStream binary]</body><body package="HTTP" selector="addTransferChunked">addTransferChunked	| f |	f := Net.TransferEncoding chunkedTransfer.	originalStream text. 	[ f writeOn: originalStream.	originalStream  cr.	] ensure: [ originalStream binary].</body><body package="HTTP" selector="finishEmptyBodyMessage:">finishEmptyBodyMessage: anEntity		self addContentLength: 0 entity: anEntity</body><body package="HTTP" selector="selectFieldsFrom:">selectFieldsFrom: aMessageHeader	^(super selectFieldsFrom: aMessageHeader) 		addAll: ( self setTransferContext: aMessageHeader parent);		yourself.</body><body package="HTTP" selector="setTransferContext:">setTransferContext: aMimeEntity 	"The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens. Initially, the registry contains the following tokens: 'chunked',  'identity', 'gzip', 'compress', and 'deflate'Transfer-Encoding: gzipTransfer-Encoding: chunkedIf the printer is set to send a message in gzip format, we will send the message as gzipped and chunked.Multipart messages and big messages are sent as chunked ones "	| coll |	coll := OrderedCollection new.	aMimeEntity isHttpEntity ifFalse: [^coll].	self useGZipTransfer ifTrue: [coll add: TransferEncoding gzipTransfer].	^coll</body><body package="HTTP" selector="startSimpleBody:">startSimpleBody: aSimpleBody	aSimpleBody writeOn: self stream</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>private prepare streams</category><body package="HTTP" selector="newBodyWriteStreamOn:for:">newBodyWriteStreamOn: aStream for: aMessage	^(Net.BodyWriteStream on: aStream)		onFinishDo: [ :position | self addContentLength: position entity: aMessage.];		yourself</body><body package="HTTP" selector="newChunkedWriteStreamOn:for:">newChunkedWriteStreamOn: aStream for: aMessage	^(Net.ChunkedWriteStream on: aStream) 		onFinishWithOneBufferDo: [ :position | self addContentLength: position entity: aMessage ];		onReadyToWriteFirstBufferDo: [ self addTransferChunked ];		chunkSize: self chunkSize; 		yourself</body><body package="HTTP" selector="prepareStream:forMessageBody:">prepareStream: aStream forMessageBody: aMessage	| streamx |	streamx := self shouldChunk 			ifTrue: [ self newChunkedWriteStreamOn: aStream for: aMessage]			ifFalse: [ (aMessage body isSimple and: [aMessage body size &gt; 0 and: [self useGZipTransfer not]])					ifTrue: [	"If we know the size of a simple body upfront we can avoid the cost of buffering the body in the BodyWriteStream"							self addContentLength: aMessage body size entity: aMessage.							^aStream lineEndCRLF ]					ifFalse: [self newBodyWriteStreamOn: aStream for: aMessage ]].	self useGZipTransfer ifTrue: [streamx := OS.ZLib.GZipWriteStream bestCompressionOn: streamx].	streamx := EncodedStream on: streamx encodedBy: (StreamEncoder new: self defaultEncoding).	streamx lineEndCRLF.	aMessage isBinaryContentType ifTrue: [ streamx binary ].	^streamx</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>accessing</category><body package="HTTP" selector="chunkSize">chunkSize	^self options chunkSize</body><body package="HTTP" selector="chunkSize:">chunkSize: aNumber	self options chunkSize: aNumber.</body><body package="HTTP" selector="doChunk">doChunk	self options doChunk</body><body package="HTTP" selector="doNotChunk">doNotChunk	self options doNotChunk</body><body package="HTTP" selector="shouldChunk">shouldChunk	^self options shouldChunk</body><body package="HTTP" selector="shouldChunk:">shouldChunk: aBoolean	self options shouldChunk: aBoolean</body><body package="HTTP" selector="useGZipTransfer">useGZipTransfer	^self options useGZipTransfer</body><body package="HTTP" selector="useGZipTransfer:">useGZipTransfer: aBoolean	self options useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpWriteHandler class</class-id> <category>default values</category><body package="HTTP" selector="shouldChunkValue">shouldChunkValue	^true</body><body package="HTTP" selector="useGZipTransferValue">useGZipTransferValue	^false</body></methods><methods><class-id>Net.HttpWriteHandler class</class-id> <category>defaults</category><body package="HTTP" selector="defaultChunkSize">defaultChunkSize	^ChunkedWriteStream defaultWriteLimit</body><body package="HTTP" selector="defaultOptionsType">defaultOptionsType	^HttpWritingOptions</body><body package="HTTP" selector="shouldChunk">shouldChunk	^self defaultOptionsType shouldChunk</body><body package="HTTP" selector="shouldChunk:">shouldChunk: aBoolean	self defaultOptionsType shouldChunk: aBoolean</body><body package="HTTP" selector="useGZipTransfer">useGZipTransfer	^self defaultOptionsType useGZipTransfer</body><body package="HTTP" selector="useGZipTransfer:">useGZipTransfer: aBoolean	^self defaultOptionsType useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>visiting</category><body package="HTTP" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptRequestLine: self with: argument</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>accessing</category><body package="HTTP" selector="entityType">entityType	^HttpRequest</body><body package="HTTP" selector="extendedMethod">extendedMethod	^self prefix notNil		ifTrue: [ self prefix, self method]		ifFalse: [self method]</body><body package="HTTP" selector="headerOnly">headerOnly	^self method asSymbol == #HEAD		or: [ self method asSymbol == #CONNECT ]</body><body package="HTTP" selector="host">host	^self url ~~ nil 		ifTrue: [ self url host ]		ifFalse: [ nil ]</body><body package="HTTP" selector="hostAndPort">hostAndPort	^self url ~~ nil		ifTrue: [self url hostAndPort ]		ifFalse: [ nil ]</body><body package="HTTP" selector="method">method	^method</body><body package="HTTP" selector="method:">method: aString	method := aString</body><body package="HTTP" selector="parent">parent	^nil</body><body package="HTTP" selector="path">path	^path</body><body package="HTTP" selector="pathString">pathString	^url isNil		ifTrue: [ path]		ifFalse: 			[self useProxy				ifTrue: [self url asString]				ifFalse: [self url pathString]].</body><body package="HTTP" selector="port">port	^self url ~~ nil 		ifTrue: [ self url port ]		ifFalse: [ nil ]</body><body package="HTTP" selector="prefix">prefix	^prefix</body><body package="HTTP" selector="prefix:">prefix: aString	prefix := aString</body><body package="HTTP" selector="protocol">protocol	^self url ~~ nil		ifTrue: [ self url protocol asLowercase ]		ifFalse: 			[self version ~~ nil				ifTrue: [ (self version copyFrom: 1 to: (self version indexOf: $/ ) - 1) asLowercase ]				ifFalse: ['http']]</body><body package="HTTP" selector="url">url	^url</body><body package="HTTP" selector="url:">url: anURL	url := anURL asURI</body><body package="HTTP" selector="useProxy">useProxy	useProxy ifNil: [ useProxy := Settings httpUseProxy ].	^useProxy</body><body package="HTTP" selector="useProxy:">useProxy: aBoolean	useProxy := aBoolean</body><body package="HTTP" selector="version">version	(version isNil or: [ version isEmpty])		ifTrue: [ version := self class defaultVersion].	^version</body><body package="HTTP" selector="version:">version: aString	version := aString</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>composing</category><body package="HTTP" selector="writeOn:">writeOn: aStream	self printOn: aStream</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>testing</category><body package="HTTP" selector="hasAbsoluteURI">hasAbsoluteURI	^self url ~~ nil</body><body package="HTTP" selector="isHttp10">isHttp10	^'*1.0*' match: self version</body><body package="HTTP" selector="isValid">isValid	^((#( 'POST' 'PUT' 'OPTIONS' 'GET' 'HEAD' 'DELETE' 'TRACE' 'CONNECT' ) includes: self method)		and: [ 'HTTP*' match: self version])</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>parsing</category><body package="HTTP" selector="readFrom:">readFrom: stream	| scanner index strUrl |	scanner := MimeScanner on: stream.	method := scanner nextToken.	(index := method indexOf: $-) &gt; 0		ifTrue: 			[prefix := method copyFrom: 1 to: index.			method := method copyFrom: index + 1 to: method size].	scanner skipWhiteSpace.	strUrl  := scanner upTo: Character space.	('http*' match: strUrl)		ifTrue: [url := strUrl asURI ]		ifFalse: [path := strUrl].	version := scanner scanText.</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>printing</category><body package="HTTP" selector="printOn:">printOn: aStream	method = 'CONNECT'		ifTrue: [	aStream 					nextPutAll: self extendedMethod;					space;					nextPutAll: url host, ':', url port printString ; 					space;					nextPutAll: self version. ]		ifFalse: [aStream nextPutAll: self extendedMethod;					space;					nextPutAll: self pathString;					space;					nextPutAll: self version ]</body></methods><methods><class-id>Net.HttpRequestLine class</class-id> <category>instance creation</category><body package="HTTP" selector="method:url:">method: aMethodString url: requestURI	^self new 		method: aMethodString;		url: requestURI;		yourself</body><body package="HTTP" selector="readFrom:">readFrom: stream	^self new readFrom: stream</body></methods><methods><class-id>Net.HttpRequestLine class</class-id> <category>defaults</category><body package="HTTP" selector="defaultVersion">defaultVersion	^'HTTP/1.1'</body></methods><methods><class-id>Net.HttpParser</class-id> <category>parsing</category><body package="HTTP" selector="endMessageBody:from:">endMessageBody:  aBody from:  aStream	"Apparently when chunking it is allowed to append additional header fields after the chunked body, referred to as a 'trailer'.	Go figure, I wonder how many HTTP stacks can handle that. In any case we will handle it too."	aBody parent isChunked ifTrue: [		aStream text.		"Read an optional trailer containing additional entity-header for chunked messages.				There must be at least the terminating CRLF of the chunked body still left on aStream.			       Chunked-Body   = *chunk                  		      last-chunk		                        trailer            		            CRLF		"		self privateParseHeader: aBody parent header from: aStream ].	super endMessageBody: aBody from:  aStream</body><body package="HTTP" selector="startMessageFrom:">startMessageFrom: aStream	| fLine aString |	aStream text.	aString := aStream nextLine.	aString isEmpty 		ifTrue: [^HttpStatusLineError new				messageText: (#EmptyHttpResponseStatusLine &lt;&lt; #net &gt;&gt; 'Can not read external stream, returns empty the Http response status line') asString;				raiseSignal].	fLine := ('http' = (aString copyFrom: 1 to: 4) asLowercase)		ifTrue: [HttpResponseStatusLine readFrom: aString readStream]		ifFalse: [HttpRequestLine readFrom: aString readStream ].	(fLine isNil or: [ fLine isValid not ])		ifTrue: [ ^HttpEntityError new messageText: ((#WrongResponseStatusLine &lt;&lt; #net &gt;&gt; 'Wrong response status line: &lt;1s&gt;')			expandMacrosWith: fLine printString); raiseSignal ].	^self handler startMessage: fLine.</body></methods><methods><class-id>Net.HttpParser class</class-id> <category>defaults</category><body package="HTTP" selector="encoder">encoder	^HttpConnection defaultEncoding</body></methods><methods><class-id>Net.RegistryLimitationExc</class-id> <category>printing</category><body package="HTTP" selector="defaultMessageText">defaultMessageText	^'Cookie implementation limits'</body></methods><methods><class-id>Net.HttpMovedError</class-id> <category>accessing</category><body package="HTTP" selector="location">location	^self parameter location</body></methods><methods><class-id>Net.AcceptHeaderFields</class-id> <category>accessing</category><body package="HTTP" selector="qValueAt:">qValueAt: index	^(self value at: index) paramAt: 'q'</body></methods><methods><class-id>Net.AcceptHeaderFields</class-id> <category>adding  range</category><body package="HTTP" selector="addValue:qValue:">addValue: vString qValue: qString	| valWithParams |	valWithParams := ValueWithParams newWithSeparators: self separators.	valWithParams value: vString.	qString notNil ifTrue: [ valWithParams paramAt: 'q' put: qString].	self value add: valWithParams.	^valWithParams</body></methods><methods><class-id>Net.AcceptHeaderFields class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($; $; $,  )</body></methods><methods><class-id>Net.AcceptCharsetField</class-id> <category>adding charset</category><body package="HTTP" selector="addCharset:">addCharset: cString	self addCharset: cString qValue: nil</body><body package="HTTP" selector="addCharset:qValue:">addCharset: cString qValue: qString 	self addValue: cString qValue: qString.</body></methods><methods><class-id>Net.AcceptCharsetField</class-id> <category>accessing</category><body package="HTTP" selector="charsetAt:">charsetAt: index	^self value at: index</body><body package="HTTP" selector="charsetTypeAt:">charsetTypeAt: index	^(self charsetAt: index) value</body></methods><methods><class-id>Net.AcceptCharsetField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('accept-charset')</body></methods><methods><class-id>Net.AcceptCharsetField class</class-id> <category>instant creation</category><body package="HTTP" selector="charset:">charset: cString	^self charset: cString qValue: nil</body><body package="HTTP" selector="charset:qValue:">charset: cString qValue: qString	^(self name: 'accept-charset') 		addCharset: cString qValue: qString;		yourself</body></methods><methods><class-id>Net.CookieFields</class-id> <category>initialize-release</category><body package="HTTP" selector="addName:value:">addName: nameString value: valString	| cookie |	cookie := self valueWithParamsClass name: nameString value: valString.	self value add: cookie.	^cookie</body><body package="HTTP" selector="initialize">initialize	name := self class fieldNames first</body></methods><methods><class-id>Net.CookieFields</class-id> <category>adding</category><body package="HTTP" selector="add:">add: aCookieField	self value addAll: aCookieField value</body><body package="HTTP" selector="addValue:">addValue: aCookieValueWithParams	self value add: aCookieValueWithParams</body></methods><methods><class-id>Net.CookieFields class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($; $; $,  )</body><body package="HTTP" selector="defaultVersion">defaultVersion	^DefaultVersion isNil		ifTrue: [ 1 ]		ifFalse: [ DefaultVersion ]</body><body package="HTTP" selector="defaultVersion:">defaultVersion: aNumber	DefaultVersion := aNumber</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>accessing</category><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^SetCookieValue</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>testing</category><body package="HTTP" selector="shouldTerminateSession">shouldTerminateSession	^(self value detect: [ :vx | vx maxAge = 0 ] ifNone: [nil]) notNil</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>printing</category><body package="HTTP" selector="printOn:indent:">printOn: aStream indent: level	[self writeOn: aStream encoding: nil]		on: Error		do: [ :ex | aStream nextPutAll: (#PrintingError &lt;&lt; #net &gt;&gt; '[printing error]') asString.			ex return ]</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>composing</category><body package="HTTP" selector="writeOn:encoding:">writeOn: aStream encoding: aString	self value 		do: [ :vx | 			self writeNameOn: aStream.			vx writeOn: aStream]		separatedBy: [ aStream cr ]</body></methods><methods><class-id>Net.SetCookieField class</class-id> <category>instance creation</category><body package="HTTP" selector="add:">add: aSetCookieValue	^self new		add:  aSetCookieValue;		yourself</body><body package="HTTP" selector="addName:value:">addName: nameString value: valString	^self new		addName: nameString value: valString;		yourself</body><body package="HTTP" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.SetCookieField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('set-cookie' )</body></methods><methods><class-id>Net.NTLMAuthentication</class-id> <category>select challenge</category><body package="HTTP" selector="selectAuthChallenge:">selectAuthChallenge: aCollOfAuthenticateChallenge	^aCollOfAuthenticateChallenge first</body><body package="HTTP" selector="setAuthChallenge:">setAuthChallenge: anAuthenticateChallenge	self authChallenge: anAuthenticateChallenge.	authChallenge ntlmValue ifNotNil: 		[decodedData := self decodeValueFrom: self authChallenge ntlmValue asByteArray readStream.		self setType2Flags].</body></methods><methods><class-id>Net.NTLMAuthentication</class-id> <category>accessing</category><body package="HTTP" selector="challenge">challenge	^self isType2		ifTrue: [ decodedData copyFrom: 25 to: 32 ]		ifFalse: [ nil]</body><body package="HTTP" selector="domain">domain	domain ifNil: 		[ (domain := Settings httpDomain) ifNil:			[self error: (#HttpDomainIsNotSpecified &lt;&lt; #net &gt;&gt; 'Net.Settings class&gt;&gt;httpDomain is not specified. Can not create NTLM Authentication message') asString ]].	^domain</body><body package="HTTP" selector="workstation">workstation	^workstation ifNil: [ workstation := SocketAccessor getHostname ]</body><body package="HTTP" selector="workstation:">workstation: aString	workstation := aString</body></methods><methods><class-id>Net.NTLMAuthentication</class-id> <category>authorization</category><body package="HTTP" selector="acceptAuthInfoFrom:">acceptAuthInfoFrom: aHttpResponse"Reset to unauthorized state. The server doesn't accept old authorization anyway "	self isAuthorized ifTrue: [ self setNotAuthorizedState ]</body><body package="HTTP" selector="setNewAuthorizationValue">setNewAuthorizationValue	self authValue ntlmValue: self type1Value.	self setAuthorizationInProgressState</body><body package="HTTP" selector="setNextAuthorizationValueFor:">setNextAuthorizationValueFor: header	self authValue ntlmValue: self type3Value.	header value add: self authValue.	self setAuthorizedState.</body><body package="HTTP" selector="setPathStringFrom:">setPathStringFrom: aHttpRequest	aHttpRequest requestLine pathString ~= self pathString		ifTrue: 			[pathString := aHttpRequest requestLine pathString.			self setNotAuthorizedState  ].</body><body package="HTTP" selector="type1Value">type1Value	| str stream output   |	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: Base64StreamEncoder asEncoder.	stream nextPutAll: 'NTLMSSP'.	stream nextPutAll: (#[ 0 ] asStringEncoding: #'iso-8859-1')."8 NTLM Message Type "	stream nextPutAll: (#[ 1 0 0 0 ] asStringEncoding: #'iso-8859-1')."12 Flags "	stream nextPutAll: (#[7 32 0 0] asStringEncoding: #'iso-8859-1')." (16) Supplied Domain (Optional) security buffer "	stream nextPutAll: (#[  0 0 0 0 0 0 0 0 ] asStringEncoding: #'iso-8859-1')."(24) Supplied Workstation (Optional) security buffer "	stream nextPutAll: (#[  0 0 0 0 0 0 0 0 ]  asStringEncoding: #'iso-8859-1').	stream close. 	str := (stream encodedContents withEncoding: #'iso-8859-1') readStream contents. 	^str.</body><body package="HTTP" selector="type3Value">type3Value	| str stream output offset struct|	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: Base64StreamEncoder asEncoder.	offset := 52.	struct := Struct new.	struct domain: (self getStringFrom: self domain asUppercase)-&gt;offset.	offset := offset + struct domain key size.	struct username: (self getStringFrom: self username asUppercase)-&gt;offset.	offset := offset + struct username key size.	struct workstation: (self getStringFrom: self workstation asUppercase)-&gt;offset.	offset := offset + struct workstation key size.	struct lmBuffer: ((self lmResponseFrom: self password) asStringEncoding: #'iso-8859-1')-&gt;offset.	offset := offset + struct lmBuffer key size.	stream nextPutAll: 'NTLMSSP'.	stream nextPutAll: (#[ 0 ] asStringEncoding: #'iso-8859-1')."8 NTLM Message Type "	stream nextPutAll: (#[ 3 0 0 0 ] asStringEncoding: #'iso-8859-1')."12 LM/LMv2 Response security buffer "	self putOn: stream data: struct lmBuffer."20 NTLM/NTLMv2 Response security buffer. Not supported "	stream nextPutAll: (#[ 0 0 0 0 0 0 0 0 ]  asStringEncoding: #'iso-8859-1')."28 Domain Name security buffer "	self putOn: stream data: struct domain.		"36 User Name security buffer "	self putOn: stream data: struct username."44 Workstation Name security buffer "	self putOn: stream data: struct workstation."(52) start of data block "	struct associations do: [ :assoc | stream nextPutAll: assoc value key  ].	stream close.	str := (stream encodedContents withEncoding: #'iso-8859-1') readStream contents.	^str.</body></methods><methods><class-id>Net.NTLMAuthentication</class-id> <category>testing</category><body package="HTTP" selector="canProceedWith:">canProceedWith: anAuthorizationField	(anAuthorizationField value select: [ :val | self class acceptScheme: val scheme]) notEmpty 		and: [(super canProceedWith: anAuthorizationField) 			or: [self isType2 not]]</body><body package="HTTP" selector="isType2">isType2	^decodedData notNil and: [(decodedData at: 9) = 2]</body><body package="HTTP" selector="useUnicode">useUnicode"Negotiate Unicode (0x00000001) The server sets this flag to indicate that it will be using Unicode strings "	^flags notNil and: [ flags anyMask: 16r1 ]</body></methods><methods><class-id>Net.NTLMAuthentication</class-id> <category>private</category><body package="HTTP" selector="decodeValueFrom:">decodeValueFrom: aStream	| stream output char |	stream := EncodedStream on: aStream encodedBy: Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ]. 	^output contents.</body><body package="HTTP" selector="expand:">expand: keyBytes"Expand 7 bytes of DES key into 8 bytes with parity, i.e. add parity bit to each 7 bit block of the key.Note: our DES doesn't care about the parity bit so it's left to be whatever it is, other DES implementations may not tolerate that."	| remainder key |	key := (ByteArray new: 8) writeStream.	remainder := (ByteArray new: 9) writeStream.	"add 0 byte to shift into, add 0x1 byte at the MSB end to make sure we're working with a valid 8 byte large int"	remainder nextPut: 0; nextPutAll: keyBytes reverse; nextPut: 1.	remainder := remainder contents changeClassTo: LargePositiveInteger.	8 to: 1 by: -1 do: [ :i |		key nextPut: (remainder digitAt: i).		remainder := remainder bitShift: -1 ].	^key contents</body><body package="HTTP" selector="getStringFrom:">getStringFrom: aString	| output input ucode |	^self useUnicode		ifTrue: 			[output := (ByteArray new: 64) writeStream.			input := aString readStream.			[ input atEnd ]				whileFalse:					[ ucode := input next asInteger.					output 						nextPut: (ucode bitAnd: 16rFF);						nextPut: (ucode bitShift: -8) ].					output contents asStringEncoding: #'iso-8859-1'.]		ifFalse: [ aString ]</body><body package="HTTP" selector="hash:message:count:">hash: in message: msg count: count"Produce the LM hash of 'msg' using 'count' keys from 'in'"	| out des |	out := (ByteArray new: 24) readWriteStream. 	des := Security.DES new.	count timesRepeat: [		des setKey: (self expand: (in next: 7)).		out nextPutAll: (des encrypt: msg) ].	^out</body><body package="HTTP" selector="lmResponseFrom:">lmResponseFrom: password	|  keys |	keys := ((ByteArray new: 14) withEncoding: #ASCII) readWriteStream.	keys nextPutAll: password asUppercase; binary.	(14 - keys position) timesRepeat: [ keys nextPut: 0 ]. keys reset.	keys := self hash: keys message: 'KGS!@#$%' asByteArray count: 2.	keys nextPutAll: #[0 0 0 0 0]; reset.	keys := self hash: keys message: self challenge count: 3.	^keys contents</body><body package="HTTP" selector="putOn:data:">putOn: aStream data: anAssoc	| arr aString offset |	aString := anAssoc key.	offset := anAssoc value.	arr := ByteArray new: 8.	arr 		at: 1 put: aString size;		at: 2 put: 0;		at: 3 put: aString size;		at: 4 put: 0;		at: 5 put: offset;		at: 6 put: 0;		at: 7 put: 0;		at: 8 put: 0.	aStream nextPutAll: (arr asStringEncoding: #'iso-8859-1').</body><body package="HTTP" selector="setType2Flags">setType2Flags	| arr |	(self isType2		and: [(arr := decodedData copyFrom: 21 to: 24) notNil ])		ifTrue: [flags := arr changeClassTo: LargePositiveInteger ]</body><body package="HTTP" selector="type1Flags">type1Flags	| n a |	n := 0.	n := n maskSet: 1. " Negotiate Unicode (0x00000001) "	n := n maskSet: 2.  "Negotiate OEM (0x00000002) "	n := n maskSet: 4. "Request Target (0x00000004)"	n := n maskSet: 512. "Negotiate NTLM (0x00000200) "	n := n maskSet: 4096. "Negotiate Domain Supplied (0x00001000) "	n := n maskSet: 8192. "Negotiate Workstation Supplied (0x00002000)" 	a := ByteArray new: 5.	a at: 1 put: 0.	1 to: 4 do: [ :ind | a at: (ind + 1) put: (n digitAt: ind)].	^a copyFrom: 1 to: a size - 1</body></methods><methods><class-id>Net.NTLMAuthentication class</class-id> <category>defaults</category><body package="HTTP" selector="scheme">scheme	^'NTLM'</body></methods><methods><class-id>Net.HttpConnection</class-id> <category>testing</category><body package="HTTP" selector="accepts:">accepts: url	^url protocol = 'http'</body></methods><methods><class-id>Net.HttpConnection</class-id> <category>private</category><body package="HTTP" selector="createSocketTimeout:">createSocketTimeout: aNumber	| s |	s := self class defaultSocketAccessor			family: (SocketAddress domainCodeFromName: #afInet)			type: SocketAccessor sockStream.	s timeout: aNumber.	^s</body></methods><methods><class-id>Net.HttpConnection class</class-id> <category>default values</category><body package="HTTP" selector="defaultPortNumber">defaultPortNumber	^SocketAccessor IPPORT_HTTP</body><body package="HTTP" selector="defaultSocketAccessor">defaultSocketAccessor	^HttpSocketAccessor</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>accessing</category><body package="HTTP" selector="addPort:">addPort: aNumber	^self port: aNumber</body><body package="HTTP" selector="domain">domain	^self params at: #domain ifAbsent: [nil]</body><body package="HTTP" selector="domain:">domain: aString	self params at: #domain put: aString</body><body package="HTTP" selector="name">name	^self value key</body><body package="HTTP" selector="nameValue">nameValue	^self value value</body><body package="HTTP" selector="path">path	^self params at: #path ifAbsent: [nil]</body><body package="HTTP" selector="path:">path: aString	self params at: #path put: aString</body><body package="HTTP" selector="port">port	^self params at: #port ifAbsent: [ nil ]</body><body package="HTTP" selector="port:">port: aCollOfNumbersOrNumber	| coll |	(aCollOfNumbersOrNumber isKindOf: Boolean)		ifTrue: [^self params at: #port put: aCollOfNumbersOrNumber].	coll := (aCollOfNumbersOrNumber isKindOf: Collection)			ifTrue: [aCollOfNumbersOrNumber]			ifFalse: 	[OrderedCollection with: aCollOfNumbersOrNumber].	^self params at: #port put: coll</body><body package="HTTP" selector="separators">separators	separators isNil 	ifTrue: [separators := SetCookieField defaultSeparators ].	^separators</body><body package="HTTP" selector="version">version	^self params at: #version ifAbsent: [nil ]</body><body package="HTTP" selector="version:">version: aNumber	self params 	at: #version 	put:  aNumber</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>parsing-printing params</category><body package="HTTP" selector="portPrintString">portPrintString"The syntax requires quotes around the portlist even if there is only one port in the list "	| aStream |	^(self port isKindOf: Boolean) 		ifTrue: [ nil ]		ifFalse:			[self port isEmpty ifTrue: [ ^nil].			aStream := String new writeStream.			self port				do: [ :px | aStream nextPutAll: px printString ]				separatedBy: [ aStream nextPut: $, ].			QuotedPrintRequired raiseFrom: aStream contents ]</body><body package="HTTP" selector="setPort:">setPort: aStringOrBoolean	| scanner coll |	aStringOrBoolean isString		ifTrue:			[coll := OrderedCollection new.			scanner := self scannerOn: aStringOrBoolean readStream.			scanner				tokenizeList: [coll add:  scanner nextToken asNumber ]				separatedBy: [ scanner token = $, ].			self params at: #port put: coll ]		ifFalse: [ self params at: #port put: aStringOrBoolean ]</body><body package="HTTP" selector="setVersion:">setVersion: aString	| n |	n := aString asNumber.	n ~= self defaultVersionNumber		ifTrue: [^self error: (#DetectedUnrecognizedCookieVersion &lt;&lt; #net &gt;&gt; 'Detected unrecognized cookie version: &lt;1s&gt;' expandMacrosWith:  aString ) asString].	self version: n.</body><body package="HTTP" selector="versionPrintString">versionPrintString"The syntax requires quotes around the portlist even if there is only one port in the list "	| aStream |	aStream := String new writeStream.	aStream nextPutAll: self version printString.	^aStream contents</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	super initialize.	setSelectors := Dictionary new.	setSelectors		at: #version put: #setVersion:;		at: #path put: #path:;		at: #domain put: #domain:;		at: #port put: #setPort:.	printSelectors := Dictionary new.	printSelectors 		at: #version put: #versionPrintString;		at: #path put: #path;		at: #domain put: #domain;		at: #port put: #portPrintString.</body><body package="HTTP" selector="name:value:">name: aString value: vString	self setValueName: aString value: vString.	self setRFCStyle</body><body package="HTTP" selector="netscapeStyleName:value:">netscapeStyleName: aString value: vString	self setValueName: aString value: vString.	self setNetscapeStyle</body><body package="HTTP" selector="setValueName:value:">setValueName: aString value: vString	value := Association key: aString value: vString.</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>parsing</category><body package="HTTP" selector="addParameterNamed:value:">addParameterNamed: valString value: parString	| sel |	(sel := setSelectors at: valString asLowercase asSymbol ifAbsent: [nil]) notNil		ifTrue: 			[[self params 				at: valString asSymbol				ifAbsent: [self perform: sel with: parString]			] on:Error do: [ :ex | InvalidHeaderField 								raiseRequestWith: parString								errorString: ((#InvalidParameterValue &lt;&lt; #net &gt;&gt; 'Invalid parameter value &lt;1s&gt; for: &lt;2s&gt;') expandMacrosWith: parString with: valString) ].			]		ifFalse: [UnknownCookieParameter 					raiseRequestWith: valString					errorString:  (#DetectedUnrecognizedCookieAttribute &lt;&lt; #net &gt;&gt; 'Detected unrecognized cookie attribute: &lt;1s&gt;' expandMacrosWith:  valString ) asString]</body><body package="HTTP" selector="finishParse">finishParse	(self params at: #version ifAbsent: [nil ]) isNil		ifTrue: [self setNetscapeStyle]		ifFalse: [self setRFCStyle]</body><body package="HTTP" selector="parseParamValueFrom:">parseParamValueFrom: scanner 	^(scanner hereChar == $; or: [scanner hereChar isNil ])		ifTrue: 			["no value param (secure/discard)" 			 true ]		ifFalse: 			[scanner peek == $"				ifTrue: 					["RFC style"					MimeEncodedWordCoDec decodeText: scanner nextToken]				ifFalse: 					["possible Netscape style"					scanner scanWhile: [ scanner hereChar ~= self parametersSeparator]]]</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>cookie style</category><body package="HTTP" selector="isNetscapeStyle">isNetscapeStyle	^self isRFCStyle not</body><body package="HTTP" selector="isRFCStyle">isRFCStyle	^self version notNil</body><body package="HTTP" selector="setNetscapeStyle">setNetscapeStyle	self removeParamAt: #version.</body><body package="HTTP" selector="setRFCStyle">setRFCStyle	self version: self defaultVersionNumber.</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>defaults</category><body package="HTTP" selector="defaultVersionNumber">defaultVersionNumber"RFC2965: Version=value REQUIRED.  The value of the Version attribute, a decimal integer, identifies the version of the state management specification to which the cookie conforms.  For this specification, Version=1   applies."	^CookieFields defaultVersion</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>comparing</category><body package="HTTP" selector="=">= aCookieValue	| d dv p pv |	d := self domain isNil		ifTrue: [ nil]		ifFalse: [ self domain asLowercase ].	dv := aCookieValue domain isNil		ifTrue: [ nil]		ifFalse: [ aCookieValue domain asLowercase ].	p := self path isNil		ifTrue: [ nil]		ifFalse: [ self path asLowercase ].	pv := aCookieValue path isNil		ifTrue: [ nil]		ifFalse: [ aCookieValue path asLowercase ].			^self name = aCookieValue name 		and: [ d = dv and:  [ p = pv ] ]</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>private-utility</category><body package="HTTP" selector="tokenizedValueFrom:">tokenizedValueFrom: rfc822Stream "The Name=Value is required and must be the first pair in Set-Cookie field"	| nx vx |	nx := rfc822Stream upTo: $=. 	rfc822Stream hereChar = $=		ifFalse:			[InvalidHeaderField 				raiseRequestWith: rfc822Stream contents				errorString: (#WrongNameValueParameter &lt;&lt; #net &gt;&gt; 'Wrong required NAME=VALUE parameter ').			^nx-&gt;nil].	vx := rfc822Stream peek = $"		ifTrue: [rfc822Stream nextToken]		ifFalse: [rfc822Stream upToEnd].	^nx -&gt; vx</body><body package="HTTP" selector="validateNextToken:for:">validateNextToken: scanner for: parName	| tok |	tok := scanner peek. 	^tok == $=		ifTrue: [ scanner next. true]		ifFalse: 	[tok = $; or: [tok isNil ]]</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>composing</category><body package="HTTP" selector="writeParameter:on:encoding:">writeParameter: assoc on: aStream encoding: aString	self class scannerType printWord: assoc key on: aStream.	self writeParameter: assoc key value: assoc value on: aStream.</body><body package="HTTP" selector="writeParameter:value:on:">writeParameter: name value:  anObject on: aStream	| printSel printValue |	(printSel  := printSelectors at: name asSymbol ifAbsent: [nil]) notNil		ifTrue: 			[[printValue := self perform:  printSel. 			self isRFCStyle				ifTrue: [super writeParameter: name value:  printValue on: aStream ]				ifFalse: 					[printValue notNil ifTrue: [aStream nextPutAll: '=', printValue ]]			] on: QuotedPrintRequired 			do: [ :ex | self writeParameterAsQuotedText: name value: ex parameter on: aStream ]			]</body><body package="HTTP" selector="writeParameterAsQuotedText:value:on:">writeParameterAsQuotedText: name value: anObject on: aStream	self class scannerType print: $= on: aStream.	[self class scannerType printQuotedText: anObject on: aStream	] 	on: NonASCIICharacter 		do: [ :ex | aStream nextPut: $"; nextPutAll: anObject; nextPut: $"]</body><body package="HTTP" selector="writeValueOn:">writeValueOn: aStream	value ~~ nil		ifTrue: 		[self isRFCStyle			ifTrue: 				[aStream nextPutAll: self value key,'='. 				self class scannerType printWord: self value value on: aStream]			ifFalse: [aStream nextPutAll: self value key,'=',self value value]]</body></methods><methods><class-id>Net.CookieValueWithParams class</class-id> <category>instance creation</category><body package="HTTP" selector="name:value:">name: nString value: vString"Create cookie value field in default RFC style"	^self new		name: nString value: vString;		yourself</body><body package="HTTP" selector="netscapeStyleName:value:">netscapeStyleName: nString value: vString"Create cookie value field in Netscape style"	^self new		netscapeStyleName: nString value: vString;		yourself</body><body package="HTTP" selector="rfcStyleName:value:">rfcStyleName: nString value: vString"Create cookie value field in RFC style"	^self name: nString value: vString</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>accessing</category><body package="HTTP" selector="comment">comment	^self params at: #comment ifAbsent: [nil]</body><body package="HTTP" selector="comment:">comment: aString	self params at: #comment put: aString</body><body package="HTTP" selector="expires">expires	^self params at: #expires ifAbsent: [nil]</body><body package="HTTP" selector="expires:">expires: aTimestamp	self params at: #expires put: aTimestamp</body><body package="HTTP" selector="httponly">httponly	^self params at: #httponly ifAbsent: [false]</body><body package="HTTP" selector="httponly:">httponly: aBoolean	aBoolean 		ifTrue: [self params  at: #httponly put: aBoolean]		ifFalse: [self params removeKey: #httponly ifAbsent: [nil]].</body><body package="HTTP" selector="maxAge">maxAge	^self params at: #'max-age' ifAbsent: [ nil ]</body><body package="HTTP" selector="maxAge:">maxAge: aNumber	self params 	at: #'max-age' put: aNumber</body><body package="HTTP" selector="secure">secure	^self params at: #secure ifAbsent: [false]</body><body package="HTTP" selector="secure:">secure: aBoolean	aBoolean 		ifTrue: [self params  at: #secure put: aBoolean]		ifFalse: [self params removeKey: #secure ifAbsent: [nil]].</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>converting</category><body package="HTTP" selector="acceptDomain:">acceptDomain: aString	^'*', self domain asLowercase match: aString asLowercase</body><body package="HTTP" selector="acceptPath:">acceptPath: aString	^'*', self path match: aString</body><body package="HTTP" selector="acceptPort:">acceptPort: aNumber	^true</body><body package="HTTP" selector="asCookie">asCookie	| c |	c := CookieValue name: self name value: self nameValue.	self isNetscapeStyle ifTrue: [^c].	self path notNil		ifTrue: [c path: self path].	self domain notNil		ifTrue: [ c domain: self domain].	self port notNil 		ifTrue: [ c port: self port].	^c</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>testing</category><body package="HTTP" selector="isExpired">isExpired	^(self isRFCStyle 		and: [self maxAge notNil 			and: [Timestamp now &gt; (Timestamp fromSeconds: self maxAge)]])	or: [self isNetscapeStyle 		and: [self expires notNil 			and: [Timestamp now &gt; self expires]]]</body><body package="HTTP" selector="isNotExpired">isNotExpired	^self isExpired not</body><body package="HTTP" selector="shouldBeDiscard">shouldBeDiscard	^false</body><body package="HTTP" selector="shouldNotBeDiscard">shouldNotBeDiscard	^self shouldBeDiscard not</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>parsing-printing params</category><body package="HTTP" selector="commentPrintString">commentPrintString	^(self comment asByteArrayEncoding:  #utf8 ) asString</body><body package="HTTP" selector="expiresPrintString">expiresPrintString	"Return a properly formatted date string using GMT."    | gMTSeconds policy |      gMTSeconds := Timestamp fromSeconds: (TimeZone reference convertLocalSecondsToGMT: self expires asSeconds).	policy := TimestampPrintPolicy formatTokensFor: 'ddd, dd-mmm-yyyy hh:mm:ss GMT'.	^(Locale named: #C) timePolicy print: gMTSeconds policy: policy</body><body package="HTTP" selector="httponlyPrintString">httponlyPrintString	^nil</body><body package="HTTP" selector="maxAgePrintString">maxAgePrintString	^self maxAge printString</body><body package="HTTP" selector="securePrintString">securePrintString	^nil</body><body package="HTTP" selector="setComment:">setComment: aString	self comment: (aString asByteArray withEncoding: #utf8 ) readStream contents</body><body package="HTTP" selector="setExpires:">setExpires: aString	self expires: (RFC822Scanner readDateAndTimeFrom: aString readStream)</body><body package="HTTP" selector="setHttponly:">setHttponly: aBoolean	self httponly: aBoolean</body><body package="HTTP" selector="setMaxAge:">setMaxAge: aString	self maxAge:  aString asNumber</body><body package="HTTP" selector="setSecure:">setSecure: aBoolean	self secure: aBoolean</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>private-utility</category><body package="HTTP" selector="expireAfterDays:">expireAfterDays: aNumber	"Mark this cookie for expiration after aNumber of days from now."	| now |	now := Time dateAndTimeNow.	self expires:		(Timestamp			fromDate: ((now at: 1) addDays: aNumber)			andTime: (now at: 2))</body><body package="HTTP" selector="expireAfterHours:">expireAfterHours: aNumber	"Mark this cookie for expiration after aNumber of hours from now."	| now increment |	now := Time dateAndTimeNow.	increment := Time new hours: aNumber minutes: 0 seconds: 0.	self expires:		(Timestamp			fromDate: (now at: 1)			andTime: ((now at: 2) addTime: increment))</body><body package="HTTP" selector="expireImmediately">expireImmediately	"Mark this cookie for immediate expiration."	| now |	now := Time dateAndTimeNow.	self expires:		(Timestamp			fromDate: ((now at: 1) addDays: -1)			andTime: (now at: 2))</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	super initialize.	setSelectors		at: #secure put: #setSecure:;		at: #httponly put: #setHttponly:;		at: #'max-age'  put: #setMaxAge:;		at: #comment put: #setComment:;		at: #expires put: #setExpires:.	printSelectors 		at: #'max-age' put: #maxAgePrintString;		at: #comment put: #commentPrintString;		at: #expires put: #expiresPrintString;		at: #secure put: #securePrintString;				at: #httponly put: #httponlyPrintString.</body></methods><methods><class-id>Net.SetCookieValue class</class-id> <category>defaults</category><body package="HTTP" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^SetCookieField readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Net.SetCookieValue class</class-id> <category>accessing</category><body package="HTTP" selector="policy">policy	^policy ifNil: [policy := TimestampPrintPolicy formatTokensFor: 'ddd, dd-mmm-yyyy hh:mm:ss GMT'.]</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>parsing-printing params</category><body package="HTTP" selector="commentURLPrintString">commentURLPrintString	^self commentURL asString</body><body package="HTTP" selector="discardPrintString">discardPrintString	^nil</body><body package="HTTP" selector="setCommentURL:">setCommentURL: aString	^self commentURL: aString asURI</body><body package="HTTP" selector="setDiscard:">setDiscard: aBoolean	self discard:  aBoolean</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>accessing</category><body package="HTTP" selector="commentURL">commentURL	^self params at: #commenturl ifAbsent: [nil ]</body><body package="HTTP" selector="commentURL:">commentURL: anURL	^self params at: #commenturl put: anURL</body><body package="HTTP" selector="discard">discard	^self params at: #discard ifAbsent: [ false ]</body><body package="HTTP" selector="discard:">discard: aBoolean	aBoolean 		ifTrue: [self params  at: #discard put: aBoolean]		ifFalse: [self params removeKey: #discard ifAbsent: [nil]].</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>converting</category><body package="HTTP" selector="acceptPort:">acceptPort: aNumber	^self port notEmpty</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	super initialize.	setSelectors		at: #commenturl put: #setCommentURL:;		at: #discard  put: #setDiscard:.	printSelectors 		at: #commenturl put: #commentURLPrintString;		at: #discard put: #discardPrintString.	self setRFCStyle.</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>testing</category><body package="HTTP" selector="shouldBeDiscard">shouldBeDiscard	^(self isRFCStyle and: [self discard ])</body></methods><methods><class-id>Net.SetCookie2Value class</class-id> <category>defaults</category><body package="HTTP" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^(SetCookie2Field readFrom: ( 'Set-Cookie2: ', anXMLElement elements first text ) readStream) value first</body></methods><methods><class-id>Net.SetCookie2Value class</class-id> <category>instance creation</category><body package="HTTP" selector="netscapeStyleName:value:">netscapeStyleName: nString value: vString	^self name: nString value: vString</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>testing</category><body package="HTTP" selector="headerOnly">headerOnly		^(self code notNil 	and: [self code isEmpty not 	and: [self isInformationalReply or: [#('204' '304') includes: self code]]])		ifTrue: [true]		ifFalse: [false]</body><body package="HTTP" selector="isChallenge">isChallenge	^self isProxyAuthorizedRequired or: [ self isUnauthorized ]</body><body package="HTTP" selector="isClientError">isClientError	"Informational- Request received, continuing the process"	^self responseTypeIs: $4</body><body package="HTTP" selector="isError">isError	"Informational- Request received, continuing the process"	^(self isClientError or: [ self isServerError])</body><body package="HTTP" selector="isHttp10">isHttp10	^self version = '1.0'</body><body package="HTTP" selector="isInformationalReply">isInformationalReply	"Informational - Request received, continuing the process"	^self responseTypeIs: $1</body><body package="HTTP" selector="isMoved">isMoved	"Moved permanently/temporarily"		^(self responseEquals: '301') or: [ self responseEquals: '302']</body><body package="HTTP" selector="isProxyAuthorizedRequired">isProxyAuthorizedRequired	"Proxy Authorized Required"	^self responseEquals: '407'</body><body package="HTTP" selector="isRedirectionReply">isRedirectionReply	"Informational- Request received, continuing the process"	^self responseTypeIs: $3</body><body package="HTTP" selector="isServerError">isServerError	"Informational- Request received, continuing the process"	^self responseTypeIs: $5</body><body package="HTTP" selector="isSuccess">isSuccess	"Success - The action was received, understood and accepted"	^self responseTypeIs: $2</body><body package="HTTP" selector="isUnauthorized">isUnauthorized	"unauthorized"	^self responseEquals: '401'</body><body package="HTTP" selector="isValid">isValid	^(( 'HTTP*' match: self protocol) and: [ self status &gt; 99 and: [ self status &lt; 600 ]])</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>accessing</category><body package="HTTP" selector="code">code	^code</body><body package="HTTP" selector="code:">code: anObject	code := anObject</body><body package="HTTP" selector="entityType">entityType	^HttpResponse</body><body package="HTTP" selector="message">message	^message</body><body package="HTTP" selector="message:">message: anObject	message := anObject</body><body package="HTTP" selector="parent">parent	^nil</body><body package="HTTP" selector="protocol">protocol	(protocol isNil or: [ protocol isEmpty])		ifTrue: [ protocol := self class defaultProtocol].	^protocol</body><body package="HTTP" selector="protocol:">protocol: anObject	protocol := anObject</body><body package="HTTP" selector="version">version	(version isNil or: [ version isEmpty])		ifTrue: [ version := self class defaultVersion].	^version</body><body package="HTTP" selector="version:">version: anObject	version := anObject</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>printing</category><body package="HTTP" selector="printMessageOn:">printMessageOn: aStream	self code isNil ifTrue: [ ^super printOn: aStream ].	aStream nextPutAll: self code; space.	self message notNil 		ifTrue: [aStream nextPutAll: self message].	aStream cr.</body><body package="HTTP" selector="printOn:">printOn: aStream	self code isNil ifTrue: [ ^super printOn: aStream ].	aStream 		nextPutAll: self protocol, '/', self version; space;		nextPutAll: self code; space.	self message ifNotNil: [aStream nextPutAll: self message].</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>private</category><body package="HTTP" selector="responseEquals:">responseEquals: threeDigitString 	^code asNumber =  threeDigitString asNumber</body><body package="HTTP" selector="responseTypeIs:">responseTypeIs: char 	^code isEmpty not		ifTrue: [ code first == char ]</body><body package="HTTP" selector="setCode:">setCode: aString	code := aString.		message := self class messages at: code ifAbsent: [''].</body><body package="HTTP" selector="status">status" Answer code as a number " 	^code notNil		ifTrue: [ Integer readFrom: code readStream]		ifFalse: [ 0 ]</body><body package="HTTP" selector="supportedVersions">supportedVersions	^#('1.0' '1.1')</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>parsing</category><body package="HTTP" selector="readFrom:">readFrom: stream	| scanner |	scanner := MimeScanner on: stream. 	protocol := scanner nextToken.	scanner nextToken.	version := scanner nextToken.	(self supportedVersions includes: version)		ifFalse: [HttpEntityError new				messageText: ((#UnexpectedHTTPVersion &lt;&lt; #net &gt;&gt; 'Unexpected HTTP version (&lt;1s&gt;)')						expandMacrosWith: version);				raiseSignal].	code := scanner nextToken.	scanner skipWhiteSpace.	message := scanner scanText.</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>visiting</category><body package="HTTP" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptResponseLine: self with: argument</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>defaults</category><body package="HTTP" selector="defaultMessages">defaultMessages	^Dictionary new		add: '100'-&gt;'Continue';		add: '101'-&gt;'Switching Protocols';		add: '200'-&gt;'OK';		add: '201'-&gt;'Created';		add: '202'-&gt;'Accepted';		add: '203'-&gt;'Non-Authoritative Information';		add: '204'-&gt;'No Content';		add: '205'-&gt;'Reset Content';		add: '206'-&gt;'Partial Content';		add: '300'-&gt;'Multiple Choices';		add: '301'-&gt;'Moved Permanently';		add: '302'-&gt;'Found';		add: '303'-&gt;'See Other';		add: '304'-&gt;'Not Modified';		add: '305'-&gt;'Use Proxy';		add: '307'-&gt;'Temporary Redirect';		add: '400'-&gt;'Bad Request';		add: '401'-&gt;'Unauthorized';		add: '402'-&gt;'Payment Required';		add: '403'-&gt;'Forbidden';		add: '404'-&gt;'Not Found';		add: '405'-&gt;'Method Not Allowed';		add: '406'-&gt;'Not Acceptable';		add: '407'-&gt;'Proxy Authentication Required';		add: '408'-&gt;'Request Time-out';		add: '409'-&gt;'Conflict';		add: '410'-&gt;'Gone';		add: '411'-&gt;'Length Required';		add: '412'-&gt;'Precondition Failed';		add: '413'-&gt;'Request Entity Too Large';		add: '414'-&gt;'Request-URI Too Large';		add: '415'-&gt;'Unsupported Media Type';		add: '416'-&gt;'Requested range not satisfiable';		add: '417'-&gt;'Expectation Failed';		add: '500'-&gt;'Internal Server Error';		add: '501'-&gt;'Not Implemented';		add: '502'-&gt;'Bad Gateway';		add: '503'-&gt;'Service Unavailable';		add: '504'-&gt;'Gateway Time-out';		add: '505'-&gt;'HTTP Version not supported';		yourself</body><body package="HTTP" selector="defaultProtocol">defaultProtocol	^'HTTP'</body><body package="HTTP" selector="defaultVersion">defaultVersion	^'1.1'</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>instance creation</category><body package="HTTP" selector="code:">code: aString	^self new		setCode: aString;		yourself</body><body package="HTTP" selector="readFrom:">readFrom: stream	^self new readFrom: stream</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>accessing</category><body package="HTTP" selector="messages">messages	messages ifNil: [ messages := self defaultMessages].	^messages</body><body package="HTTP" selector="messages:">messages: aDictionary	messages := aDictionary</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>status</category><body package="HTTP" selector="close">close	stream close.</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>initialize-release</category><body package="HTTP" selector="reset">reset	buffer := nil.	position := nil.</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>testing</category><body package="HTTP" selector="atEnd">atEnd	position = readLimit  ifTrue: [ self nextChunk ].	^readLimit = 0</body><body package="HTTP" selector="isReadable">isReadable	^true</body><body package="HTTP" selector="isWritable">isWritable	"Answer whether the stream implements #nextPut:."	^false</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>private</category><body package="HTTP" selector="nextChunk">nextChunk	self nextChunkSize &gt; 0		ifTrue: 			[position := 0.			[buffer := stream next: readLimit ] 				on: Stream incompleteNextCountSignal				do: [:ex | 					self signalError: (#IncompleteChunkCount &lt;&lt;#net &gt;&gt; 'Incomplete chunk count').					^ex return ].			(stream next = self lineEnd first ) ifFalse: [ self signalError: (#WrongChunkFormat &lt;&lt;#net &gt;&gt; 'Wrong chunk format')].			stream peekFor: self lineEnd last]</body><body package="HTTP" selector="nextChunkSize">nextChunkSize	readLimit := Integer readFrom: (stream upTo: self lineEnd first ) asString readStream radix: 16.	self lineEnd size &gt; 1 ifTrue: [stream peekFor: self lineEnd last ].	readLimit = 0 ifTrue: [self reset].	^readLimit</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>accessing</category><body package="HTTP" selector="next">next	buffer ifNil: [ self nextChunk].	self atEnd ifTrue: [^self pastEnd].	position := position + 1.	^buffer at: position</body><body package="HTTP" selector="next:">next: aNumber	| line |	self atEnd ifTrue: [^self pastEnd].	line := self contentsSpecies new: aNumber.	1 to: aNumber do: [ :ind | line at: ind put: self next].	^line</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>accessing</category><body package="HTTP" selector="basicValue">basicValue	^self data</body><body package="HTTP" selector="basicValue:">basicValue: aString	^self data: aString</body><body package="HTTP" selector="ntlmValue">ntlmValue	^self data</body><body package="HTTP" selector="ntlmValue:">ntlmValue: aString	^self data: aString</body><body package="HTTP" selector="realm">realm	^realm</body><body package="HTTP" selector="realm:">realm: aString	^realm := aString</body><body package="HTTP" selector="scheme">scheme	^self value</body><body package="HTTP" selector="scheme:">scheme: aString	^self value: aString</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>testing</category><body package="HTTP" selector="isBasic">isBasic	^self scheme asLowercase = 'basic'</body><body package="HTTP" selector="isDigest">isDigest	^self scheme asLowercase = 'digest'</body><body package="HTTP" selector="isNTLM">isNTLM	^self scheme asLowercase = 'ntlm'</body><body package="HTTP" selector="isNTLMType2">isNTLMType2	^self isNTLM and: [ self ntlmValue notNil]</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>private</category><body package="HTTP" selector="data">data	^data</body><body package="HTTP" selector="data:">data: aString	data := aString</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>parsing</category><body package="HTTP" selector="parse:">parse: scanner	scanner atEnd ifTrue: [ ^self]. 	scanner hereChar ~~ self valueSeparator		ifTrue: [ scanner stepBack. ^self ].	self parseDataFrom: scanner</body><body package="HTTP" selector="parseDataFrom:">parseDataFrom: scanner 	| pos str |	pos := scanner position.	str := scanner nextToken.	"Basic auth response has realm parameter.	#nextToken  will stop at $= char. If it's not 'real' parameter we need all characters "	^('realm' match: str )		ifTrue: [			scanner skipWhiteSpace.			( scanner nextToken = $=) ifFalse: [				InvalidHeaderField signalWith: scanner contents. 				^self ].  			realm := scanner nextToken  ]		ifFalse: [			scanner position: pos.			data := scanner upToEnd ]</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>composing</category><body package="HTTP" selector="writeDataOn:">writeDataOn: aStream	aStream nextPut: self valueSeparator.	realm isNil		ifTrue: [aStream nextPutAll: self data]		ifFalse: 	[aStream nextPutAll: 'realm="', self realm, '"']</body><body package="HTTP" selector="writeValueOn:">writeValueOn: aStream	super writeValueOn: aStream.	(self realm notNil  or: [self data notNil])		ifTrue: [	self writeDataOn: aStream ]</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>accessing</category><body package="HTTP" selector="algorithm">algorithm 	^self paramAt:  'algorithm'</body><body package="HTTP" selector="algorithm:">algorithm: aString	^self paramAt:  'algorithm' put: aString</body><body package="HTTP" selector="authParam">authParam"This directive allows for future extensions."	^self paramAt:  'auth-param'</body><body package="HTTP" selector="authParam:">authParam: aString	^self paramAt:  'auth-param' put: aString</body><body package="HTTP" selector="cnonce">cnonce"This MUST be specified if a qop directive is sent "	^self paramAt:  'cnonce'</body><body package="HTTP" selector="cnonce:">cnonce: aString	^self paramAt:  'cnonce' put: aString</body><body package="HTTP" selector="digestUri">digestUri"The URI from Request-URI of the Request-Line; duplicated here because proxies are allowed to change the Request-Line in transit."	^self paramAt:  'digest-uri'</body><body package="HTTP" selector="digestUri:">digestUri: aString	^self paramAt:  'digest-uri' put: aString</body><body package="HTTP" selector="nc">nc	^self paramAt:  'nc'</body><body package="HTTP" selector="nc:">nc: aNumber	^self paramAt:  'nc' put: aNumber</body><body package="HTTP" selector="nonce">nonce	^self paramAt:  'nonce'</body><body package="HTTP" selector="nonce:">nonce: aString	self paramAt:  'nonce' put: aString</body><body package="HTTP" selector="opaque">opaque"A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data."	^self paramAt:  'opaque'</body><body package="HTTP" selector="opaque:">opaque: aString	^self paramAt:  'opaque' put: aString</body><body package="HTTP" selector="qop">qop"Indicates what 'quality of protection' the client has applied to the message"	^self paramAt:  'qop'</body><body package="HTTP" selector="qop:">qop: aCollection"      qop-options       = qop = &lt;''&gt; 1#qop-value &lt;''&gt;      qop-value         = auth | auth-int | token"	self paramAt:  'qop' put: aCollection</body><body package="HTTP" selector="realm">realm	^self paramAt:  'realm'</body><body package="HTTP" selector="realm:">realm: aString	^self paramAt:  'realm' put: aString</body><body package="HTTP" selector="response">response" A string of 32 hex digits, which proves  that the user knows a password"	^self paramAt:  'response'</body><body package="HTTP" selector="response:">response: aString	^self paramAt:  'response' put: aString</body><body package="HTTP" selector="scheme">scheme	^self value</body><body package="HTTP" selector="stale">stale"A flag, indicating that the previous request from the client was rejected because the nonce value was stale. If stale is TRUE (case-insensitive), the client may wish to simply retry the request  with a new encrypted response, without reprompting the user for a new username and password. "	^self paramAt:  'stale'</body><body package="HTTP" selector="stale:">stale: aBoolean	^self paramAt:  'stale' put: aBoolean</body><body package="HTTP" selector="uri">uri	^self paramAt:  'uri'</body><body package="HTTP" selector="uri:">uri: aString	^self paramAt:  'uri' put: aString</body><body package="HTTP" selector="username">username"The user's name in the specified realm"	^self paramAt:  'username'</body><body package="HTTP" selector="username:">username: aString	^self paramAt:  'username' put: aString</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>accessing auth-info</category><body package="HTTP" selector="nextNonce">nextNonce 	^self paramAt:  'nextnonce'</body><body package="HTTP" selector="nextNonce:">nextNonce: aString 	self paramAt:  'nextnonce' put: aString</body><body package="HTTP" selector="responseAuth">responseAuth       	^self paramAt:  'rspauth'</body><body package="HTTP" selector="responseAuth:">responseAuth: aString       	^self paramAt:  'rspauth' put: aString</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>testing</category><body package="HTTP" selector="isBasic">isBasic	^false</body><body package="HTTP" selector="isDigest">isDigest	^true</body><body package="HTTP" selector="isNTLM">isNTLM	^false</body><body package="HTTP" selector="isNTLMType2">isNTLMType2	^false</body><body package="HTTP" selector="isStaleTrue">isStaleTrue	^self stale = true</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>parsing</category><body package="HTTP" selector="finishParse">finishParse	| coll sc val |	coll := OrderedCollection new.	(val := self qop) ifNotNil:		[sc := self scannerOn: val readStream.		sc 			tokenizeList: [ coll add: sc nextToken ]			separatedBy: [sc token == $, or: [sc token == Character space ]].		self qop: coll.		 ].	(val := self stale) ifNotNil: [self stale: (Boolean readFrom: val readStream) ].	(val := self nc) ifNotNil: [self nc: (Number readFrom: val readStream) ].</body><body package="HTTP" selector="parse:">parse: scanner	scanner atEnd ifTrue: [ ^self]. 	scanner hereChar ~~ self valueSeparator		ifTrue: [ scanner stepBack. ^self ].	self parseParameters: scanner.	self finishParse.</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	value := 'Digest'</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>composing</category><body package="HTTP" selector="writeNonceCount:on:">writeNonceCount: aNumber on: aStream	aNumber printOn: aStream paddedWith: $0 to: 8 base: 10.</body><body package="HTTP" selector="writeNonceCountOn:">writeNonceCountOn: aStream	| number |	(number := self nc) ifNotNil: 		[ self writeNonceCount: number on: aStream]</body><body package="HTTP" selector="writeParameter:on:encoding:">writeParameter: assoc on: aStream encoding: aString	self printParameter: assoc on: aStream</body><body package="HTTP" selector="writeParameter:value:on:">writeParameter: name value: anObject on: aStream	anObject isNil ifTrue: [^nil].	self class scannerType print: $= on: aStream.	name = 'qop' ifTrue: [^self writeQop: anObject on: aStream].	name = 'nc' ifTrue: [^self writeNonceCount: anObject on: aStream].	name = 'stale' ifTrue: [ ^self writeQuotedValue: anObject printString on: aStream ].	self writeQuotedValue: anObject on: aStream.</body><body package="HTTP" selector="writeParametersSeparatorOn:">writeParametersSeparatorOn: aStream	aStream nextPut: self parametersSeparator; crtab</body><body package="HTTP" selector="writeQop:on:">writeQop: anObject on: aStream	anObject isString		ifTrue: [aStream nextPutAll: anObject]		ifFalse: 			[ aStream nextPut: $".			anObject 				do: [ :each | aStream nextPutAll: each]				separatedBy: [aStream nextPut: $,].			aStream nextPut: $".].</body><body package="HTTP" selector="writeQuotedValue:on:">writeQuotedValue: anObject on: aStream	aStream 		nextPut: $"; 		nextPutAll: anObject; 		nextPut: $"</body></methods><methods><class-id>Net.Cookie2Field</class-id> <category>accessing</category><body package="HTTP" selector="version">version	^self value</body><body package="HTTP" selector="version:">version: aNumber	self value: aNumber</body></methods><methods><class-id>Net.Cookie2Field</class-id> <category>parsing</category><body package="HTTP" selector="doParse:">doParse: scanner	| vname next |	vname := scanner nextToken. 	vname asLowercase = '$version'		ifFalse: 	[ self notifyErrorCookie: vname. ^nil].	^(next := scanner nextToken) = $=		ifTrue: [next := scanner nextToken.				next do: [ :ch | ch isDigit ifFalse: [ self notifyErrorCookie: next. ^nil]].				 next asNumber ]		ifFalse: [self notifyErrorCookie: next. nil ]</body><body package="HTTP" selector="notifyErrorCookie:">notifyErrorCookie: anObject	^InvalidHeaderField 		raiseRequestWith: anObject		errorString: ((#DetectedInvalidCookie2Field &lt;&lt; #net &gt;&gt; 'Detected invalid Cookie2 field: &lt;1s&gt;') expandMacrosWith: name).</body></methods><methods><class-id>Net.Cookie2Field</class-id> <category>printing</category><body package="HTTP" selector="printValueOn:">printValueOn: aStream	[self writeValueOn: aStream encoding: nil ] on: Error do: [ :ex | ex return ]</body></methods><methods><class-id>Net.Cookie2Field</class-id> <category>composing</category><body package="HTTP" selector="writeValueOn:encoding:">writeValueOn: aStream encoding: aString	self version ifNil: [self error: #NilCookie2Version &lt;&lt; #net &gt;&gt; 'Cookie2 field has nil version'.].	aStream nextPutAll: '$version=', self version printString</body></methods><methods><class-id>Net.Cookie2Field class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('cookie2' )</body></methods><methods><class-id>Net.Cookie2Field class</class-id> <category>instance creation</category><body package="HTTP" selector="version:">version: aNumber	^self new		name: self fieldNames first;		version: aNumber;		yourself</body></methods><methods><class-id>Net.HttpTimeout</class-id> <category>private</category><body package="HTTP" selector="defaultMessageText">defaultMessageText	^(#TimeoutConnectionNotResponding &lt;&lt; #net &gt;&gt; 'Timeout   Connection is not responding') asString</body></methods><methods><class-id>Net.AuthorizationField</class-id> <category>accessing</category><body package="HTTP" selector="basicValue">basicValue	| s |	^(s := self basicScheme) notEmpty 		ifTrue: [ s first basicValue ]		ifFalse: [ nil ]</body><body package="HTTP" selector="digestValue">digestValue	| s |	^(s := self digestScheme) notEmpty 		ifTrue: [ s first params ]		ifFalse: [ nil ]</body><body package="HTTP" selector="ntlmValue">ntlmValue	| s |	^(s := self ntlmScheme) notEmpty 		ifTrue: [ s first ntlmValue ]		ifFalse: [ nil ]</body></methods><methods><class-id>Net.AuthorizationField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('authorization' 'proxy-authorization')</body></methods><methods><class-id>Net.AcceptLanguageField</class-id> <category>adding language</category><body package="HTTP" selector="addLanguage:">addLanguage: cString  	self addValue: cString qValue: nil</body><body package="HTTP" selector="addLanguage:qValue:">addLanguage: cString qValue: qString 	self addValue: cString qValue: qString.</body></methods><methods><class-id>Net.AcceptLanguageField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('accept-language')</body></methods><methods><class-id>Net.AcceptLanguageField class</class-id> <category>instant creation</category><body package="HTTP" selector="language:">language: cString 	^self language: cString qValue: nil</body><body package="HTTP" selector="language:qValue:">language: cString qValue: qString	^(self name: 'accept-language') 		addLanguage: cString qValue: qString;		yourself</body></methods><methods><class-id>Net.CacheControl</class-id> <category>accessing</category><body package="HTTP" selector="addMustRevalidate">addMustRevalidate"must-revalidate"	self addDirective:  'must-revalidate'-&gt;nil</body><body package="HTTP" selector="addNoCache">addNoCache" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	self addDirective: 'no-cache'-&gt;nil</body><body package="HTTP" selector="addNoStore">addNoStore"no-store"	self addDirective: 'no-store'-&gt;nil</body><body package="HTTP" selector="addNoTransform">addNoTransform"no-transform"	self addDirective:  'no-transform'-&gt;nil</body><body package="HTTP" selector="addOnlyIfCached">addOnlyIfCached"only-if-cached "	self addDirective: 'only-if-cached'-&gt;nil</body><body package="HTTP" selector="addPrivate">addPrivate"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	self addDirective: 'private'-&gt;nil</body><body package="HTTP" selector="addProxyRevalidate">addProxyRevalidate"proxy-revalidate"	self addDirective: 'proxy-revalidate'-&gt;nil</body><body package="HTTP" selector="addPublic">addPublic"public "	self addDirective: 'public'-&gt;nil</body><body package="HTTP" selector="maxAge">maxAge"'max-age' ''='' delta-seconds "	^self detectValueFor: 'max-age'</body><body package="HTTP" selector="maxAge:">maxAge: aNumber"'max-age' ''='' delta-seconds "	self addDirective: 'max-age'-&gt;aNumber</body><body package="HTTP" selector="maxStale">maxStale"'max-stale' ''='' delta-seconds "	^self detectValueFor: 'max-stale'</body><body package="HTTP" selector="maxStale:">maxStale: aNumber"'max-stale' ''='' delta-seconds "	self addDirective:  'max-stale'-&gt;aNumber</body><body package="HTTP" selector="minFresh">minFresh"'min-fresh' ''='' delta-seconds "	^self detectValueFor: 'min-fresh'</body><body package="HTTP" selector="minFresh:">minFresh: aNumber"'min-fresh' ''='' delta-seconds "	self addDirective: 'min-fresh'-&gt;aNumber</body><body package="HTTP" selector="mustRevalidate">mustRevalidate"must-revalidate"	^self anySatisfy: 'must-revalidate'</body><body package="HTTP" selector="noCache">noCache" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	^self detectValueFor: 'no-cache'</body><body package="HTTP" selector="noCache:">noCache: aCollOfStringsOrNil" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	self addDirective: 'no-cache'-&gt;aCollOfStringsOrNil</body><body package="HTTP" selector="noStore">noStore"no-store"	^self anySatisfy: 'no-store'</body><body package="HTTP" selector="noTransform">noTransform"no-transform"	^self anySatisfy:  'no-transform'</body><body package="HTTP" selector="onlyIfCached">onlyIfCached"only-if-cached "	^self anySatisfy:  'only-if-cached'</body><body package="HTTP" selector="private">private"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	^self detectValueFor: 'private'</body><body package="HTTP" selector="private:">private: aCollOfStringsOrNil"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	self addDirective: 'private'-&gt;aCollOfStringsOrNil</body><body package="HTTP" selector="proxyRevalidate">proxyRevalidate"proxy-revalidate"	^self anySatisfy: 'proxy-revalidate'</body><body package="HTTP" selector="public">public"public "	^self anySatisfy: 'public'</body><body package="HTTP" selector="values">values	^value isNil		ifTrue: [ value := OrderedCollection new]		ifFalse: [ value ]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>private</category><body package="HTTP" selector="anySatisfy:">anySatisfy: aString	^self values anySatisfy: [ :val | val key asLowercase = aString ]</body><body package="HTTP" selector="detectValueFor:">detectValueFor: aString 	| v |	^(v := self value detect: [ :val | val key asLowercase = aString ] ifNone: [nil]) notNil		ifTrue: 			[ v value notNil				ifTrue: [ v value]				ifFalse: [true]]		ifFalse: [false]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>parsing</category><body package="HTTP" selector="parseItem:">parseItem: aString	| scanner token |	scanner := self scannerOn: aString readStream. 	token := scanner nextToken.	^(scanner hereChar == $= )		ifTrue: [token -&gt;(self parseParameters: scanner key: token asLowercase)]		ifFalse: [token-&gt;nil]</body><body package="HTTP" selector="parseParameters:key:">parseParameters: scanner key: aString	| paramColl newScanner t |	paramColl := OrderedCollection new.	scanner next.	scanner nextToken. 	^scanner tokenType == #quotedText 			ifTrue: 			[newScanner := scanner 							newSize: scanner token size 							startingAt: (scanner position - scanner token size - 1).			newScanner tokenizeList: [ t := newScanner nextToken. paramColl add: t]						separatedBy: [ newScanner token == self separator ].			scanner next.			paramColl]		ifFalse: 			[(scanner tokenType == #token and: [ self isDeltaSeconds: aString])				ifTrue: [ scanner token asNumber]				ifFalse: [scanner token]]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>directives</category><body package="HTTP" selector="addDirective:">addDirective: anAssocOrString	| val |	val := (anAssocOrString isString				ifTrue: [ anAssocOrString-&gt;nil]				ifFalse: 	[anAssocOrString]).	self removeDirective: val key.	self values add: val</body><body package="HTTP" selector="directiveAt:">directiveAt: aString	^self detectValueFor: aString</body><body package="HTTP" selector="removeDirective:">removeDirective: aString	self values removeAllSuchThat: [ :v | v key = aString ].</body></methods><methods><class-id>Net.CacheControl</class-id> <category>testing</category><body package="HTTP" selector="isDeltaSeconds:">isDeltaSeconds: aString	^#( 'max-age' 'max-stale' 'min-fresh' ) includes: aString</body></methods><methods><class-id>Net.CacheControl</class-id> <category>composing</category><body package="HTTP" selector="writeParameters:on:">writeParameters: anObject on: aStream 		aStream nextPut: $=.	(anObject isKindOf: OrderedCollection)		ifTrue:			[aStream nextPut: $".			anObject 				do: [ :param |  aStream nextPutAll: param]				separatedBy: [aStream nextPut: $, ].			aStream nextPut: $"  ]		ifFalse: 			[anObject respondsToArithmetic 				ifTrue: [anObject printOn: aStream]				ifFalse: [ aStream nextPutAll: anObject]]</body><body package="HTTP" selector="writeValueOn:encoding:">writeValueOn: aStream encoding: aString		self values		do: 	[ :val |			aStream nextPutAll: val key.			val value notNil				ifTrue:					[self writeParameters: val value on: aStream]]		separatedBy: [aStream nextPut: self separator].	aStream cr.</body></methods><methods><class-id>Net.CacheControl class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('cache-control')</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>utilities</category><body package="HTTP" selector="cookiesAt:">cookiesAt: anUrl	^self registry 			at: (self keyFrom: anUrl)			ifAbsentPut: [ OrderedCollection new ].</body><body package="HTTP" selector="setCookieFieldForRequest:">setCookieFieldForRequest: aHttpRequest	| f |	(f := self cookieFieldForUrl: aHttpRequest url ) notNil		ifTrue:  [aHttpRequest cookie: f ].	^f</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>testing limits</category><body package="HTTP" selector="exceedNumberBytesPerCookie:">exceedNumberBytesPerCookie: aSetCookieValue	aSetCookieValue printString size &gt; self class numberBytesPerCookie		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberBytesPerCookie &lt;&lt; #net &gt;&gt; 'Exceed number bytes per cookie &lt;1s&gt;' expandMacrosWith: aSetCookieValue printString)  ].	^false</body><body package="HTTP" selector="exceedNumberEntries">exceedNumberEntries	self exceedNumberEntries: self registry</body><body package="HTTP" selector="exceedNumberEntries:">exceedNumberEntries: aRegistry	| size |	size := 0.	aRegistry values do: [ :vx | size := size + vx size ].	size &gt; self class numberEntries		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberEntries &lt;&lt; #net &gt;&gt; 'Exceed  total cookie number') ].	^false</body><body package="HTTP" selector="exceedNumberEntriesPerServer:">exceedNumberEntriesPerServer: aString	self exceedNumberEntriesPerServer: aString registry: self registry</body><body package="HTTP" selector="exceedNumberEntriesPerServer:registry:">exceedNumberEntriesPerServer: aString registry: aRegistry	| coll |	coll := aRegistry at: aString ifAbsent: [ ^false ].	coll size &gt; self class numberEntriesPerServer		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberEntriesPerServer &lt;&lt; #net &gt;&gt; 'Exceed number entries per server &lt;1s&gt;' expandMacrosWith: aString)  ].	^false</body><body package="HTTP" selector="shouldUpdateServer:">shouldUpdateServer: aString	^(self class serversCacheCookiesFrom isEmpty		or: [ self class serversCacheCookiesFrom notEmpty 			and: [ self class serversCacheCookiesFrom includes: aString ]]).</body><body package="HTTP" selector="testCookieBytesLimit:">testCookieBytesLimit: aSetCookieValue	self enableLimits		ifTrue: [ self exceedNumberBytesPerCookie: aSetCookieValue]</body><body package="HTTP" selector="testRegistryAndServerLimits:">testRegistryAndServerLimits: aString	self enableLimits		ifTrue: 			[ self exceedNumberEntriesPerServer: aString.			self exceedNumberEntries ].</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>managing cookies</category><body package="HTTP" selector="getValidCookieValuesFrom:requestUrl:">getValidCookieValuesFrom: aCookieCollection requestUrl: anUrl	| coll |	coll := OrderedCollection new.	aCookieCollection do: 		[ :cx | 		cx value 			do: [ :vx | 				(self rejectCookieValue: vx requestUrl: anUrl) 					ifFalse: 						[self testCookieBytesLimit: vx.						coll add: vx]]].	^coll</body><body package="HTTP" selector="registryAdd:forUrl:">registryAdd: aCollection forUrl: anUrl	| setCookiesColl cookie k |	aCollection isEmpty ifTrue: [^nil].	setCookiesColl := self  registry 						at: (k := self keyFrom: anUrl)						ifAbsentPut: [ OrderedCollection new ].	aCollection 		do: [ :newCookie |			(cookie := setCookiesColl detect: [ :cx | cx = newCookie ] ifNone: [ nil]) notNil				ifTrue: [ setCookiesColl remove: cookie]].	setCookiesColl addAll: aCollection.	self testRegistryAndServerLimits: k.	^setCookiesColl</body><body package="HTTP" selector="rejectCookieValue:requestUrl:">rejectCookieValue: aSetCookieValue requestUrl: anUrl	aSetCookieValue isExpired 		ifTrue: [self removeExpiredCookieValue: aSetCookieValue requestUrl: anUrl. ^true].	^(self validateDomain: aSetCookieValue domain host: anUrl host) not		or: [ (self validatePathFrom: aSetCookieValue path  path: anUrl pathString ) not			or: [(self validatePort: aSetCookieValue port port: anUrl port ) not ]]</body><body package="HTTP" selector="removeExpiredCookieValue:requestUrl:">removeExpiredCookieValue: aSetCookieValue requestUrl: anUrl	| vx coll |	coll := self registry at: ( self keyFrom:anUrl) ifAbsent: [^nil ].	vx := coll  detect: [ :cx | cx value key = aSetCookieValue value key] ifNone: [ nil].	vx ifNotNil: [coll remove: vx ].</body><body package="HTTP" selector="validateDomain:host:">validateDomain: aCookieDomain host: aHostString	| reqHost cookieDomain ind |	reqHost := aHostString asLowercase.	aCookieDomain notNil		ifTrue: 			[cookieDomain := aCookieDomain asLowercase.			(cookieDomain at: 1) ~= $. ifTrue: [ cookieDomain := '.', cookieDomain].			"The request-host has the form HD, where D is value of the domain attribute"			(( '*', cookieDomain) match: reqHost) ifFalse: [ ^false ].			ind := reqHost indexOfSubCollection:  cookieDomain startingAt: 1.			"The request-host contains embedded dots or  the domain attribute contains no embedded dots"			(((reqHost copyFrom: 1 to: ind - 1 ) includes: $.) 				or: [ ('.*.*' match: cookieDomain) not					and: [ ('.local' match: cookieDomain) not ]])				ifTrue: [^false].			].	^true.</body><body package="HTTP" selector="validatePathFrom:path:">validatePathFrom: aCookiePath path: requestPath	aCookiePath notNil		ifTrue: 			["the value for the path attribute has to be a prefix of the request url "			(( aCookiePath, '*' ) match: requestPath )				ifFalse: [ ^false ]].	^true</body><body package="HTTP" selector="validatePort:port:">validatePort: aCookiePort port: portNumber	"the request-port is not in the port attribute"	^(aCookiePort isNil or: [aCookiePort isKindOf: Boolean])		or: [	aCookiePort notNil			and: [ (aCookiePort isKindOf: Collection)				and: [(aCookiePort includes: portNumber) ]]]</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>converting</category><body package="HTTP" selector="accept:for:key:">accept: anUrl for: aSetCookieValue key: keyUrl	^(aSetCookieValue isNotExpired		and: [ (self cookieDomain: aSetCookieValue domain accept: anUrl host)			and: [(self cookiePath: aSetCookieValue path accept: anUrl pathString)				and: [self cookiePort: aSetCookieValue port accept: anUrl port from: keyUrl ]]])</body><body package="HTTP" selector="cookieDomain:accept:">cookieDomain: aSetCookieDomain accept: aString	^aSetCookieDomain isNil		or: [ aSetCookieDomain notNil 				and: ['*', aSetCookieDomain asLowercase match: aString asLowercase]]</body><body package="HTTP" selector="cookieFieldForUrl:">cookieFieldForUrl: anUrl	"Creates 'Cookie' field for the specified url from registered 'Set-Cookie' or 'Set-Cookie2' fields "	| coll sc xInd yInd f |	coll := OrderedCollection new.	self registry		keysAndValuesDo:			[ :key :value | 			value 				do: [ :vx |				(self accept: anUrl for: vx key: key) ifTrue: [coll add: vx ]]].	coll isEmpty ifTrue: [ ^nil ].	sc := SortedCollection 			withAll: coll			sortBlock: [ :x : y |						xInd := x path notNil							ifTrue: [x path occurrencesOf: $/ ]							ifFalse: [0].						yInd := y path notNil							ifTrue: [y path occurrencesOf: $/ ]							ifFalse: [0].						xInd &gt;= yInd ].	f := sc first isRFCStyle		ifTrue: [CookieField newRfc ]		ifFalse: [ CookieField newNetscape ].	f value: (sc collect: [ :cx | cx asCookie ]).	^f</body><body package="HTTP" selector="cookiePath:accept:">cookiePath: aCookiePath accept: requestPath	^aCookiePath isNil 		or: [aCookiePath notNil 				and: [( aCookiePath, '*' ) match: requestPath ]]</body><body package="HTTP" selector="cookiePort:accept:from:">cookiePort: aSetCookiePort accept: aNumber from: hostPort	aSetCookiePort isNil ifTrue: [^true].	^(aSetCookiePort isKindOf: Boolean)		ifTrue: [(hostPort tokensBasedOn: $: ) last asNumber = aNumber]		ifFalse: 			[aSetCookiePort isEmpty 				ifTrue: [ true ]				ifFalse: [aSetCookiePort includes: aNumber ]]</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>accessing</category><body package="HTTP" selector="cacheCookies">cacheCookies	^cacheCookies isNil		ifTrue: [cacheCookies := self class cacheCookies]		ifFalse: [ cacheCookies ]</body><body package="HTTP" selector="cacheCookies:">cacheCookies: aBoolean	cacheCookies := aBoolean</body><body package="HTTP" selector="classRegistry">classRegistry	^self class registry</body><body package="HTTP" selector="classRegistryAt:put:">classRegistryAt: aServerString put: aCollection	self classRegistry at: aServerString put: aCollection.	self enableLimits		ifTrue: 			[ self exceedNumberEntriesPerServer: aServerString registry: self classRegistry.			self exceedNumberEntries: self classRegistry ].</body><body package="HTTP" selector="enableLimits">enableLimits	^enableLimits isNil		ifTrue: [ enableLimits := self class enableLimits]		ifFalse: [ enableLimits ]</body><body package="HTTP" selector="enableLimits:">enableLimits: aBoolean	enableLimits := aBoolean</body><body package="HTTP" selector="keyFrom:">keyFrom: anUrl	^self class keyFrom: anUrl</body><body package="HTTP" selector="registry">registry	^registry</body><body package="HTTP" selector="useCachedCookies">useCachedCookies	^useCachedCookies isNil		ifTrue: [ useCachedCookies := self class useCachedCookies]		ifFalse: [ useCachedCookies ]</body><body package="HTTP" selector="useCachedCookies:">useCachedCookies: anObject	useCachedCookies := anObject</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>initialize-release</category><body package="HTTP" selector="addCookiesFrom:requestUrl:">addCookiesFrom: aHttpResponse requestUrl: anUrl	self setCacheCookieFrom: aHttpResponse.	^self 		registryAdd: (self getValidCookieValuesFrom: aHttpResponse setCookieFields requestUrl: anUrl) 		forUrl: anUrl.</body><body package="HTTP" selector="initialize">initialize	registry := Dictionary  new.	self start.</body><body package="HTTP" selector="start">start	"Starts cookie session"	| vColl |	self class useCachedCookies		ifTrue: 			[ self classRegistry keysAndValuesDo:				[ :key :values | 				vColl := values select: [ :vx | vx isNotExpired ].				self registry at: key put: vColl copy ]].</body><body package="HTTP" selector="terminate">terminate	"Terminates cookie session. Saves session cookies to the class registry"	| coll vColl newColl |	self cacheCookies		ifTrue:			[ self registry keysAndValuesDo:				[ :key :values | 				(self shouldUpdateServer: key)					ifTrue: 						[vColl := values select: [ :vx | vx shouldNotBeDiscard and: [ vx isNotExpired ] ].						(coll := self classRegistry at: key ifAbsent: [ nil ]) isNil							ifTrue: [ self classRegistryAt: key put: vColl ]							ifFalse: 								[ newColl := OrderedCollection new: ( coll size + vColl size).								coll do: [ :vclass |  vColl detect: [ :vx | vx = vclass ] ifNone: [ newColl add: vclass]].								newColl addAll: vColl.								self classRegistryAt: key put: newColl ]]]].</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>caching</category><body package="HTTP" selector="setCacheCookieFrom:">setCacheCookieFrom: aHttpResponse	| noCache |	aHttpResponse cacheControl notNil		ifTrue: 			[noCache := aHttpResponse cacheControl noCache.			(noCache isKindOf: Boolean) ifTrue: [ ^nil ].			('set-cookie2' match: noCache first )				ifTrue: [ self cacheCookies: false ]].</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>accessing</category><body package="HTTP" selector="cookiesAt:">cookiesAt: anUrl	^self registry 			at: (self keyFrom: anUrl)			ifAbsentPut: [ OrderedCollection new ].</body><body package="HTTP" selector="keyFrom:">keyFrom: anUrl	^anUrl host, ':', anUrl port printString</body><body package="HTTP" selector="registry">registry	Registry ifNil: [ self resetRegistry ].	^Registry</body><body package="HTTP" selector="resetRegistry">resetRegistry	Registry := Dictionary new</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>instance creation</category><body package="HTTP" selector="addCookiesFrom:requestUrl:">addCookiesFrom: aHttpEntity requestUrl: anUrl	^self new		addCookiesFrom: aHttpEntity requestUrl: anUrl;		yourself</body><body package="HTTP" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>defaults</category><body package="HTTP" selector="defaultCacheCookies">defaultCacheCookies	^false</body><body package="HTTP" selector="defaultEnableLimits">defaultEnableLimits	^false</body><body package="HTTP" selector="defaultNumberBytesPerCookie">defaultNumberBytesPerCookie	^4096</body><body package="HTTP" selector="defaultNumberEntries">defaultNumberEntries	^300</body><body package="HTTP" selector="defaultNumberEntriesPerServer">defaultNumberEntriesPerServer	^20</body><body package="HTTP" selector="defaultServersCacheCookiesFrom">defaultServersCacheCookiesFrom	^OrderedCollection new</body><body package="HTTP" selector="defaultUseCachedCookies">defaultUseCachedCookies	^false</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>accessing settings</category><body package="HTTP" selector="cacheCookies">cacheCookies	^CacheCookies isNil		ifTrue: [self defaultCacheCookies]		ifFalse: [CacheCookies]</body><body package="HTTP" selector="cacheCookies:">cacheCookies: aBoolean	CacheCookies := aBoolean</body><body package="HTTP" selector="enableLimits">enableLimits	^EnableLimits isNil		ifTrue: [self defaultEnableLimits]		ifFalse: [EnableLimits]</body><body package="HTTP" selector="enableLimits:">enableLimits: aBoolean	EnableLimits := aBoolean</body><body package="HTTP" selector="numberBytesPerCookie">numberBytesPerCookie	^NumberBytesPerCookie isNil		ifTrue: [NumberBytesPerCookie := self defaultNumberBytesPerCookie ]		ifFalse: [NumberBytesPerCookie]</body><body package="HTTP" selector="numberBytesPerCookie:">numberBytesPerCookie: aNumber	NumberBytesPerCookie := aNumber</body><body package="HTTP" selector="numberEntries">numberEntries	^NumberEntries isNil		ifTrue: [NumberEntries := self defaultNumberEntries]		ifFalse: [NumberEntries]</body><body package="HTTP" selector="numberEntries:">numberEntries: aNumber	NumberEntries := aNumber</body><body package="HTTP" selector="numberEntriesPerServer">numberEntriesPerServer	^NumberEntriesPerServer isNil		ifTrue: [NumberEntriesPerServer := self defaultNumberEntriesPerServer]		ifFalse: [NumberEntriesPerServer]</body><body package="HTTP" selector="numberEntriesPerServer:">numberEntriesPerServer: aNumber	NumberEntriesPerServer := aNumber</body><body package="HTTP" selector="serversCacheCookiesFrom">serversCacheCookiesFrom	^ServersCacheCookiesFrom isNil		ifTrue: [ServersCacheCookiesFrom := self defaultServersCacheCookiesFrom]		ifFalse: [ServersCacheCookiesFrom]</body><body package="HTTP" selector="serversCacheCookiesFrom:">serversCacheCookiesFrom: aCollection	ServersCacheCookiesFrom := aCollection</body><body package="HTTP" selector="useCachedCookies">useCachedCookies	^UseCachedCookies isNil		ifTrue: [self defaultUseCachedCookies]		ifFalse: [UseCachedCookies]</body><body package="HTTP" selector="useCachedCookies:">useCachedCookies: aBoolean	UseCachedCookies := aBoolean</body></methods><methods><class-id>Net.HttpWritingOptions</class-id> <category>accessing</category><body package="HTTP" selector="chunkSize">chunkSize	^chunkSize</body><body package="HTTP" selector="chunkSize:">chunkSize: aNumber	chunkSize := aNumber.	"a nil is a valid input and means use default settings for chunking"	aNumber ifNotNil: [ self doChunk ]</body><body package="HTTP" selector="doChunk">doChunk	self shouldChunk: true</body><body package="HTTP" selector="doNotChunk">doNotChunk	self shouldChunk: false</body><body package="HTTP" selector="logAsPrintString">logAsPrintString	^logAsPrintString  ifNil: [logAsPrintString := self class logAsPrintString]</body><body package="HTTP" selector="logAsPrintString:">logAsPrintString: aBoolean	logAsPrintString := aBoolean</body><body package="HTTP" selector="shouldChunk">shouldChunk	^shouldChunk ifNil: [shouldChunk := self class shouldChunk]</body><body package="HTTP" selector="shouldChunk:">shouldChunk: aBoolean	shouldChunk := aBoolean</body><body package="HTTP" selector="useGZipTransfer">useGZipTransfer	^useGZipTransfer ifNil: [useGZipTransfer := self class useGZipTransfer]</body><body package="HTTP" selector="useGZipTransfer:">useGZipTransfer: aBoolean	useGZipTransfer := aBoolean</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>printing options</category><body package="HTTP" selector="shouldChunk">shouldChunk	^shouldChunk ifNil: [shouldChunk := self shouldChunkValue]</body><body package="HTTP" selector="shouldChunk:">shouldChunk: aBoolean	shouldChunk := aBoolean</body><body package="HTTP" selector="useGZipTransfer">useGZipTransfer	^useGZipTransfer ifNil: [useGZipTransfer := self useGZipTransferValue]</body><body package="HTTP" selector="useGZipTransfer:">useGZipTransfer: aBoolean	useGZipTransfer := aBoolean</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>defaults</category><body package="HTTP" selector="defaultPrinterType">defaultPrinterType	^HttpPrintHandler</body><body package="HTTP" selector="defaultWriterType">defaultWriterType	^HttpWriteHandler</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>default values</category><body package="HTTP" selector="defaultChunkSize">defaultChunkSize	^ChunkedWriteStream defaultWriteLimit</body><body package="HTTP" selector="defaultLogAsPrintString">defaultLogAsPrintString	^false</body><body package="HTTP" selector="shouldChunkValue">shouldChunkValue	^true</body><body package="HTTP" selector="useGZipTransferValue">useGZipTransferValue	^false</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>debugging</category><body package="HTTP" selector="logAsPrintString">logAsPrintString	^logAsPrintString ifNil: [logAsPrintString := self defaultLogAsPrintString]</body><body package="HTTP" selector="logAsPrintString:">logAsPrintString: aBoolean	logAsPrintString := aBoolean</body></methods><methods><class-id>Net.HttpReadingOptions</class-id> <category>accessing</category><body package="HTTP" selector="decodeContents">decodeContents	^decodeContents ifNil: [ self class decodeContents ]</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	decodeContents := aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^decompressContents ifNil: [ self class decompressContents ]</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	decompressContents := aBoolean</body></methods><methods><class-id>Net.HttpReadingOptions</class-id> <category>defaults</category><body package="HTTP" selector="defaultRootEntityType">defaultRootEntityType	^HttpEntity</body></methods><methods><class-id>Net.HttpReadingOptions class</class-id> <category>defaults</category><body package="HTTP" selector="decodeContents">decodeContents	^decodeContents isNil		ifTrue: [decodeContents := self decodeContentsValue]		ifFalse: [decodeContents]</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	decodeContents := aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^decompressContents isNil		ifTrue: [decompressContents := self defaultDecompressContents ]		ifFalse: [decompressContents]</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	decompressContents := aBoolean</body><body package="HTTP" selector="defaultBuilderType">defaultBuilderType	^HttpBuildHandler</body></methods><methods><class-id>Net.HttpReadingOptions class</class-id> <category>default values</category><body package="HTTP" selector="decodeContentsValue">decodeContentsValue	^true</body><body package="HTTP" selector="defaultAttachmentDirectoryValue">defaultAttachmentDirectoryValue	^'http-temp-files'</body><body package="HTTP" selector="defaultDecompressContents">defaultDecompressContents	^true</body><body package="HTTP" selector="saveAttachmentsAsFilesValue">saveAttachmentsAsFilesValue	^true</body></methods><methods><class-id>Net.HttpUser</class-id> <category>testing</category><body package="HTTP" selector="acceptsRealm:">acceptsRealm: aString	^self realms isEmpty		or: [self realms anySatisfy: [ :each | each = aString ]]</body><body package="HTTP" selector="isHttpUser">isHttpUser	^false</body></methods><methods><class-id>Net.HttpUser</class-id> <category>accessing</category><body package="HTTP" selector="realm">realm	^self realms notEmpty		ifTrue: [ self realms  first ]		ifFalse: [ nil ]</body><body package="HTTP" selector="realms">realms	^realms ifNil: [ realms := OrderedCollection new].</body><body package="HTTP" selector="realms:">realms: aCollection	realms := aCollection</body></methods><methods><class-id>Net.HttpUser</class-id> <category>adding</category><body package="HTTP" selector="addRealm:">addRealm: aString	aString ifNotNil: [ self realms add: aString]</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>private</category><body package="HTTP" selector="primReadInto:startingAt:for:">primReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	time := Time millisecondClockValue.	^super primReadInto: buffer startingAt: index for: count</body><body package="HTTP" selector="privateReadInto:startingAt:for:">privateReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	&lt;primitive: 679 errorCode: _ec&gt;	| newTime |	(self class restartableError: _ec)		ifTrue: 			[self readWaitWithTimeoutMs: self timeout.			newTime := Time millisecondClockValue. 			newTime - time &gt; self timeout ifTrue: [ HttpTimeout raiseRequest. time := Time millisecondClockValue ].			^OSErrorHolder needRetrySignal raise].	^self reportError: _ec</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>accessing</category><body package="HTTP" selector="timeout">timeout	timeout == nil ifTrue: [timeout := 6000].	^timeout</body><body package="HTTP" selector="timeout:">timeout: numberOfMilliseconds	timeout := numberOfMilliseconds</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>defaults</category><body package="HTTP" selector="connectionClass">connectionClass	"Answer a default connection class for the receiver."	^ExternalConnection</body></methods><methods><class-id>Net.HttpEntityError</class-id> <category>printing</category><body package="HTTP" selector="description">description	^self messageText</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>accessing</category><body package="HTTP" selector="defaultAlgorithm">defaultAlgorithm	^defaultAlgorithm ifNil: [defaultAlgorithm := self class defaultAlgorithm]</body><body package="HTTP" selector="defaultAlgorithm:">defaultAlgorithm: aString	defaultAlgorithm :=  aString</body><body package="HTTP" selector="nextNonceCount">nextNonceCount	self nonceCount: self nonceCount + 1.	^self nonceCount</body><body package="HTTP" selector="nonceCount">nonceCount	^nonceCount ifNil: [ self resetNonceCount]</body><body package="HTTP" selector="nonceCount:">nonceCount: aNumber	nonceCount := aNumber</body><body package="HTTP" selector="resetNonceCount">resetNonceCount	nonceCount := 0.</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>private authorization</category><body package="HTTP" selector="H:">H: data"Apply the H function (hash) to the argument as defined in section 3.2.1 The WWW-Authenticate Response Header.	data &lt;String&gt; ascii string of data to hash	^&lt;String&gt;	the hash value converted to a hex string [0-9a-f]"	^self LHEX: (Security.MD5 hash: data asByteArray)</body><body package="HTTP" selector="LHEX:">LHEX: bytes"Convert bytes to the LHEX format as specified in RFC 2617, section 3.1.3 Representation of digest values	bytes &lt;ByteArray&gt; binary value	^&lt;String&gt;	the binery value converted into a hex string [0-9a-f]"	| lookup s ws |	lookup := '0123456789abcdef'.	s := String new: bytes size * 2.	ws := s writeStream.	bytes do: [ :b |		ws nextPut: (lookup at: (b bitShift: -4) + 1).		ws nextPut: (lookup at: (b bitAnd: 15) + 1) ].	^s</body><body package="HTTP" selector="a1Value">a1Value	^self authValue algorithm = 'MD5-sess' 		ifTrue: [self md5SessData]		ifFalse: [self md5Data].</body><body package="HTTP" selector="a2Value">a2Value"If the 'qop' directive's value is 'auth' or is unspecified, then A2  is:A2   = Method ':' digest-uri-valueIf the 'qop' value is 'auth-int', then A2 is:A2   = Method ':' digest-uri-value ':' H(entity-body) "	| string |	string := 'GET:', self pathString.	^self H: (		self authValue qop = 'auth'			ifTrue: [string]			ifFalse: [string, ':', self entityHash])</body><body package="HTTP" selector="cnonce:">cnonce: aString	self authValue cnonce:  aString</body><body package="HTTP" selector="entityHash">entityHash"Also note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the message body -   it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient. Note that this includes multipart boundaries and embedded headers in each part of any multipart content-type. ""	authorizationHeader parent  "	^self error: (#AuthIntNotImplemented &lt;&lt; #net &gt;&gt; '&lt;qop=auth-int&gt; option has not been implemented in this release.')</body><body package="HTTP" selector="md5Data">md5Data"   If the 'algorithm' directive's value is MD5 or is unspecified, then A1 is: A1       = unq(username-value) ':' unq(realm-value) ':' passwd   where passwd   = &lt; user's password &gt; "	| stream |	stream := WriteStream on: String new.	stream nextPutAll: self username, ':', self authValue realm, ':', self password.	^self H: stream contents</body><body package="HTTP" selector="md5SessData">md5SessData" If the 'algorithm' directive's value is 'MD5-sess',   then A1 is calculated only once - on the first request by the client following   receipt of a WWW-Authenticate challenge from the server.  It uses the server nonce from that challenge, and the first client nonce value to construct A1 as follows:   A1  = H( unq(username-value) ':' unq(realm-value) ':' passwd ) ':' unq(nonce-value) ':' unq(cnonce-value) "	| stream |	md5SessData ifNil:		[stream := WriteStream on: String new.		stream nextPutAll: self username, ':', self authValue realm, ':', self password.		md5SessData := ((self H: stream contents), 							':', self authValue nonce, 							':', self authValue cnonce) ].	^md5SessData</body><body package="HTTP" selector="setDigestResponse">setDigestResponse"If the 'qop' value is 'auth' or 'auth-int'         KD(secret, data) = H(concat(secret, ':', data))      request-digest  = &lt;''&gt; &lt; KD ( H(A1),  			unq(nonce-value) ':' nc-value ':' unq(cnonce-value) ':' unq(qop-value) ':' H(A2)  ) &lt;''&gt;  If the 'qop' directive is not present (this construction is for compatibility with RFC 2069):     request-digest  = &lt;''&gt; &lt; KD ( H(A1), unq(nonce-value) ':' H(A2) ) &gt; &lt;''&gt;"	| hashStream data |	hashStream := WriteStream on: String new.	hashStream nextPutAll: self authValue nonce.	self authValue qop ifNotNil:		[hashStream nextPut: $:.		self authValue writeNonceCountOn: hashStream.		hashStream nextPut: $:.		hashStream nextPutAll: self authValue cnonce.		hashStream nextPut: $:.		hashStream nextPutAll: self authValue qop].	hashStream nextPut: $:.	hashStream nextPutAll: self a2Value.	data := hashStream contents.	^self H: (self a1Value, ':', data)</body><body package="HTTP" selector="setQopValue">setQopValue" 'auth'- authentication; 'auth-int' - authentication with integrity protection. Unrecognized options MUST be ignored."	| qop |	self authValue nc: self nextNonceCount.	self authValue cnonce ifNil:		[ self authValue cnonce: (self H: Timestamp now asSeconds printString) ].	(qop := self authChallenge qop detect: [ :each | each  = 'auth' ] ifNone: [nil]) notNil			ifTrue: [^self authValue qop: qop].	(self authValue qop detect: [ :each | each  = 'auth-int' ] ifNone: [nil]) notNil		ifTrue: [ " raise not implemented exception " self entityHash ]</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>select challenge</category><body package="HTTP" selector="selectAuthChallenge:">selectAuthChallenge: aCollOfAuthenticateChallenge	^aCollOfAuthenticateChallenge 		detect: [ :auth | 				(self user acceptsRealm: auth realm )					and: [auth algorithm isNil							or: [( 'MD5' match: auth algorithm) 								or: [( 'MD5-sess' match: auth algorithm)]]]] 		ifNone: [nil]</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>authorization</category><body package="HTTP" selector="acceptAuthInfoFrom:">acceptAuthInfoFrom: aHttpResponse	| anAuthInfo v next |	anAuthInfo := aHttpResponse fieldAt: 'authentication-info' ifAbsent: [^nil].	((v := anAuthInfo value) notEmpty and: [(next :=  v  first nextNonce) notNil ]) 		ifTrue: 			[self authValue nonce: next.			self resetNonceCount ].</body><body package="HTTP" selector="setNewAuthorizationValue">setNewAuthorizationValue	self resetNonceCount.	self authValue 		username: self username;		realm: self authChallenge realm;		nonce: self authChallenge nonce;		uri: self pathString.	self authChallenge opaque 		ifNotNil: [ self authValue opaque: self authChallenge opaque].	self authValue algorithm 		ifNil: [ self authValue algorithm: self defaultAlgorithm ]. 	self authChallenge qop ifNotNil: [self setQopValue ]. 	self authValue response: self setDigestResponse.	self setAuthorizedState</body><body package="HTTP" selector="setNextAuthorizationValueFor:">setNextAuthorizationValueFor: header	self authValue qop ifNotNil: [		"increase the nonce count"		self authValue			nc: self nextNonceCount;			response: self setDigestResponse ].	super setNextAuthorizationValueFor: header</body><body package="HTTP" selector="setPathStringFrom:">setPathStringFrom: aHttpRequest	aHttpRequest requestLine pathString ~= self pathString		ifTrue: 			[pathString := aHttpRequest requestLine pathString.			self setNotAuthorizedState  ].</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>testing</category><body package="HTTP" selector="canAccept:">canAccept: anAuthentication	| ch challenge |	((challenge := anAuthentication value 					select: [ :val | self class acceptScheme: val scheme]) notEmpty 		and: [(ch := self selectAuthChallenge: challenge ) notNil			and: [ch realm ~= authValue realm or: [ch isStaleTrue] ]])		ifTrue: [self setAuthChallenge:  ch. ^true].	^false</body></methods><methods><class-id>Net.DigestAuthentication class</class-id> <category>defaults</category><body package="HTTP" selector="defaultAlgorithm">defaultAlgorithm	^defaultAlgorithm ifNil: [ defaultAlgorithm := self defaultAlgorithmValue ]</body><body package="HTTP" selector="defaultAlgorithm:">defaultAlgorithm: aString	defaultAlgorithm := aString</body><body package="HTTP" selector="defaultAlgorithmValue">defaultAlgorithmValue	^'MD5'</body><body package="HTTP" selector="scheme">scheme	^'Digest'</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>testing</category><body package="HTTP" selector="canBeDecoded">canBeDecoded	^(self transferEncoding isNil and: [ self contentEncoding isNil ])</body><body package="HTTP" selector="hasConnectionClose">hasConnectionClose"Does the receiver have a Connection: close header field ?	^&lt;Boolean&gt;"	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val | 'close' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP" selector="hasConnectionKeepAlive">hasConnectionKeepAlive"Does the receiver have a Connection: keep-alive header field ?	^&lt;Boolean&gt;"	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val |'keep-alive' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP" selector="hasTransferEncoding">hasTransferEncoding	^self transferEncoding ~~ nil</body><body package="HTTP" selector="isChunked">isChunked	| coll |	^(coll := self transferEncoding) notNil 		and: [coll anySatisfy: [:vx | 'chunked' match: vx]]</body><body package="HTTP" selector="isCompressed">isCompressed		^self isContentEncodingGZip or: [ self isTransferEncodingGZip ]</body><body package="HTTP" selector="isConnectionPersistent">isConnectionPersistent"Does the receiver indicate a persistent connection.	^&lt;Boolean&gt;"	^self isConnectionTransient not</body><body package="HTTP" selector="isConnectionTransient">isConnectionTransient"Does the receiver indicate a transient connection.	^&lt;Boolean&gt;"	^self isHttp10		ifTrue: [ self hasConnectionKeepAlive not ]		ifFalse: [ self hasConnectionClose ].</body><body package="HTTP" selector="isExtended">isExtended	^(self fields detect: [ :field | self extendedFieldNames includes: field name] ifNone: [ nil] ) notNil</body><body package="HTTP" selector="isHttp10">isHttp10	^self subclassResponsibility</body><body package="HTTP" selector="isHttpEntity">isHttpEntity	^true</body><body package="HTTP" selector="isMandatory">isMandatory	^self isExtended</body><body package="HTTP" selector="isMimeEntity">isMimeEntity	^false</body><body package="HTTP" selector="isMultipartByteranges">isMultipartByteranges	| v |	^(v := self contentType ) ~~ nil		and: ['multipart/byteranges' match: v ]</body><body package="HTTP" selector="isResponse">isResponse	^false</body><body package="HTTP" selector="isTransferEncodingGZip">isTransferEncodingGZip	| coll |	^(coll := self transferEncoding) notNil 		and: [coll anySatisfy: [:vx | 'gzip' match: vx]]</body><body package="HTTP" selector="isValid">isValid	^self subclassResponsibility</body><body package="HTTP" selector="keepAlive">keepAlive"Persistent connections are the default for HTTP/1.1 messages; HTTP/1.1 spec introduce a new keyword (Connection: close) for declaring non-persistence. HTTP/1.1 defines the 'close' connection option  for the sender to signal that the connection will be closed after completion of the response. Persistent connections in HTTP/1.0 must be explicitly negotiated as they are not the default behavior. When it connects to an origin server, an HTTP/1.0 client MAY send the Keep-Alive connection-token : Connection: Keep-Alive  An HTTP/1.0 server would then respond with the Keep-Alive connection token and the client may proceed with an HTTP/1.0 (or Keep-Alive) persistent connection.A client MUST NOT send the Keep-Alive connection token to a proxy server as HTTP/1.0 proxy servers do not obey the rules of HTTP/1.1 for parsing the Connection header field."	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val |'keep-alive' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP" selector="needsContentTransferEncoding">needsContentTransferEncoding	^false</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>mandatory extensions</category><body package="HTTP" selector="addFor:namespace:">addFor: fieldName namespace: nsString"Add new mandatory field  - man		with specified namespace - http://www.copyright.org/rights-managementnamespace id is generated dynamically""Man: http://www.copyright.org/rights-management; ns= xx"	| id |	id := self assignNextNamespaceId.	self addFor: fieldName namespace: nsString id: id.	^id</body><body package="HTTP" selector="addFor:namespace:id:">addFor: fieldName namespace: nsString id: idString"Add new mandatory field  - man		with specified namespace - http://www.copyright.org/rights-management		and id -  16""Man: http://www.copyright.org/rights-management; ns=16"	self addField: ( ManOptField field: fieldName namespace: nsString id: idString).	^idString</body><body package="HTTP" selector="allExtendedFieldsForNamespace:">allExtendedFieldsForNamespace: nsString"Returns collection of extended fields for the specified namespace""Man: http://www.copyright.org/rights-management; ns=16C-Opt: http://www.copyright.org/rights-management; ns=15"	| list list1 |	list := OrderedCollection new: 10.	(list1 :=  self allMandatoryFieldsForNamespace:  nsString) isEmpty not		ifTrue: [ list addAll: list1 ].	(list1 :=  self allOptionalFieldsForNamespace: nsString) isEmpty not		ifTrue: [ list addAll: list1 ].	^list</body><body package="HTTP" selector="allFieldsFor:namespace:">allFieldsFor: fieldName namespace:  nsString"Returns collection of specified extended fields for the specified namespace""Man: http://www.copyright.org/rights-management; ns=16Man: http://www.copyright.org/rights-management; ns=15"	^(self fieldsAt: fieldName)		select: [ :field | (field namespaceMapAt: nsString) notNil ]</body><body package="HTTP" selector="allFieldsWithId:">allFieldsWithId: idString"Returns collection of fields with the same header prefix ( namespace id)""16-copyright: http:/www.org/copyright.html16-contributions: http:/www.org/patches.html"	^self fields select: [ :field | (idString, '-*') match: field name]</body><body package="HTTP" selector="allIdsForNamespace:">allIdsForNamespace: nsString"Returns collection of namespace id's for all extended fields""Man: http://www.copyright.org/rights-management; ns=16Opt:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list |	list := OrderedCollection new: 10.	self extendedFieldNames 		do: [ :fname | 			(self namespaceMapFor: fname) 				keysAndValuesDo: 					[ :k :v | 					(k equivalentTo: nsString ignoreCase: true) 						ifTrue: [ list add: v]]].	^list</body><body package="HTTP" selector="allMandatoryFieldsForNamespace:">allMandatoryFieldsForNamespace:  nsString"Returns collection of namespace id's for mandatory fields""Man: http://www.copyright.org/rights-management; ns=16C-Man:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list1 list |	list := OrderedCollection new: 10.	self mandatoryFieldNames 		do: [ :fieldName |			(list1 := (self fieldsAt: fieldName)				select: [ :field | (field namespaceMapAt: nsString) notNil ]) isEmpty not		ifTrue: [ list addAll: list1]].	^list</body><body package="HTTP" selector="allOptionalFieldsForNamespace:">allOptionalFieldsForNamespace:  nsString"Returns collection of namespace id's for optional fields""Opt: http://www.copyright.org/rights-management; ns=16C-Opt:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list1 list |	list := OrderedCollection new: 10.	self optionalFieldNames		do: [ :fieldName |				(list1 := (self fields at: fieldName) select: [ :field | (field namespaceMapAt: nsString) notNil ]) isEmpty not					ifTrue: [ list addAll: list1]].	^list</body><body package="HTTP" selector="assignNextNamespaceId">assignNextNamespaceId"Dynamically creates next namespace id and returns it as a string" 	self nextNamespaceId: self nextNamespaceId + 1.	^self nextNamespaceId printString</body><body package="HTTP" selector="extendedFieldForId:">extendedFieldForId: idString"Returns an extended field with the specified namespace id""Man: http://www.copyright.org/rights-management; ns=16"	| field |	(field :=  self mandatoryFieldForId: idString) notNil		ifTrue: [ ^field ].	(field :=  self optionalFieldForId: idString) notNil		ifTrue: [ ^field ].	^nil</body><body package="HTTP" selector="extendedFieldNames">extendedFieldNames	^#('man' 'c-man' 'opt' 'c-opt')</body><body package="HTTP" selector="fieldAt:id:">fieldAt: fieldName id: idString"Returns field with the specified namespace id (prefix)if this field is absent creates new header field ""16-copyright: http:/www.org/copyright.html"	^self getFieldAt: ( idString, '-', fieldName)</body><body package="HTTP" selector="fieldAt:put:id:">fieldAt: fieldName put: aValue id: idString"Set value (http:/www.org/copyright.html) 	for the specified field name (copyright)  	with namespace id (16)""16-copyright: http:/www.org/copyright.html"	(self getFieldAt: ( idString, '-', fieldName)) value: aValue</body><body package="HTTP" selector="fieldValueAt:id:">fieldValueAt: fieldName id: idString"Returns value (http:/www.org/copyright.html) for the specified field (16-copyright)""16-copyright: http:/www.org/copyright.html"	^self getValueFor: ( idString, '-', fieldName)</body><body package="HTTP" selector="idFor:namespace:">idFor: fieldName namespace: nsString"Returns namespace id for the specified mandatory(optional) field name and namespace""Man: http://www.copyright.org/rights-management; ns=16"" self idFor: 'man' namespace: 'http://www.copyright.org/rights-management' 	returns 16 "	^(self namespaceMapFor: fieldName) at: nsString</body><body package="HTTP" selector="mandatoryFieldForId:">mandatoryFieldForId:  idString"Returns mandatory field for the specified id""Man: http://www.copyright.org/rights-management; ns=16""C-Man: http://www.copyright.org/rt; ns=15"	| field |	self mandatoryFieldNames do:		[ :fieldName |		(field := (self fieldsAt: fieldName)					detect: [ :fd | (fd namespaceMapKeyAtValue: idString) notNil ] ifNone: [nil]) notNil			ifTrue: [ ^field ]].	^nil</body><body package="HTTP" selector="mandatoryFieldNames">mandatoryFieldNames	^#('man' 'c-man')</body><body package="HTTP" selector="namespaceFor:id:">namespaceFor: fieldName id:  idString"Returns namespace for the specified mandatory field and id""Man: http://www.copyright.org/rights-management; ns=16"" self namespaceFor: 'man' id: '16'	returns 'http://www.copyright.org/rights-management'  "	(self namespaceMapFor: fieldName)		keysAndValuesDo: 			[:aKey :aValue | aValue = idString ifTrue: [^aKey]].	^nil</body><body package="HTTP" selector="namespaceForId:">namespaceForId:  idString"Returns namespace for the specified id""Man: http://www.copyright.org/rights-management; ns=16"" self namespaceForId: '16'  returns: 'http://www.copyright.org/rights-management'  "	self namespaceMap		keysAndValuesDo: 			[:aKey :aValue | aValue = idString ifTrue: [^aKey]].	^nil</body><body package="HTTP" selector="namespaceMap">namespaceMap"Returns a dictionary all namespaces and id'snamespace is a keynamespace id is a value"	| dict |	dict := Dictionary new.	self extendedFieldNames do: [ :fname |		(self namespaceMapFor: fname) associations do: [ :ea | dict add: ea] ].	^dict</body><body package="HTTP" selector="namespaceMapFor:">namespaceMapFor: fnString"Returns a dictionary namespaces and id's for the specified field name ('man' 'opt' ...)namespace is a keynamespace id is a value"	| dict |	dict := Dictionary new.	(self fieldsAt: fnString) 		do: [ :field |   field namespaceMap associations do: [ :ea | dict add: ea] ].	^dict</body><body package="HTTP" selector="nextNamespaceId">nextNamespaceId"Returns namespace id (header-prefix)"	^nextNamespaceId isNil		ifTrue: [ nextNamespaceId := 10]		ifFalse: [ nextNamespaceId ]</body><body package="HTTP" selector="nextNamespaceId:">nextNamespaceId: aNumber"Sets namespace id (header-prefix)"		nextNamespaceId := aNumber</body><body package="HTTP" selector="optionalFieldForId:">optionalFieldForId:  idString"Returns optional field for the specified id""Opt: http://www.copyright.org/rights-management; ns=16""C-Opt: http://www.copyright.org/rt; ns=15"	| field |	self optionalFieldNames do:		[ :fieldName |		(field := (self fieldsAt: fieldName)					detect: [ :fd | (fd namespaceMapKeyAtValue: idString) notNil ] ifNone: [nil]) notNil			ifTrue: [ ^field ]].	^nil</body><body package="HTTP" selector="optionalFieldNames">optionalFieldNames	^#('opt' 'c-opt')</body><body package="HTTP" selector="removeNamespace:">removeNamespace: nsString"Removes all fields for the specified namespace"	(self allIdsForNamespace: nsString)		do: [ :id | self removeNamespaceId: id ].</body><body package="HTTP" selector="removeNamespaceId:">removeNamespaceId: idString"Removes all fields for the specified namespace id""Man: 'http://www.copyright.org/rights-management'; ns=14Man: 'http://www.copyright.org/rights-mgt'; ns=15, 'http://www.copyright.org/rt13'; ns=1314-Credentials: 'g5gj262jdw@4df'13-Credentials: 'QQQQ'  self removeNamespaceId: '13'.Result:Man: http://www.copyright.org/rights-management; ns=14Man: 'http://www.copyright.org/rights-mgt'; ns=1514-Credentials: 'g5gj262jdw@4df'  "	| field |	(self allFieldsWithId: idString)		do: [ :fd |  self removeFieldAt: fd name].	field := self extendedFieldForId: idString.	field removeId: idString.	field value isEmpty ifTrue: [ self removeField: field ].</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing fields</category><body package="HTTP" selector="allow">allow	^self fieldValueAt: 'allow'</body><body package="HTTP" selector="allow:">allow: stringOrCollection	(self getFieldAt: 'allow') value: stringOrCollection</body><body package="HTTP" selector="cacheControl">cacheControl	^self fieldAt: 'cache-control'</body><body package="HTTP" selector="cacheControl:">cacheControl: aStringOrAssociationOrCacheControl	(aStringOrAssociationOrCacheControl isKindOf: CacheControl) 		ifTrue: 			[self removeFieldAt: 'cache-control'.			self addField: aStringOrAssociationOrCacheControl]		ifFalse: [(self getFieldAt: 'cache-control') addDirective: aStringOrAssociationOrCacheControl]</body><body package="HTTP" selector="connection">connection	^self fieldValueAt: 'connection'</body><body package="HTTP" selector="connection:">connection: aString	(self getFieldAt: 'connection') value: aString</body><body package="HTTP" selector="contentBase">contentBase	^self fieldValueAt: 'content-base'</body><body package="HTTP" selector="contentBase:">contentBase: aString	(self getFieldAt: 'content-base') value: aString</body><body package="HTTP" selector="contentEncoding">contentEncoding	^self fieldValueAt: 'content-encoding'</body><body package="HTTP" selector="contentEncoding:">contentEncoding: aCollectionField	(self getFieldAt: 'content-encoding') value: aCollectionField</body><body package="HTTP" selector="contentLanguage">contentLanguage	^self fieldValueAt: 'content-language'</body><body package="HTTP" selector="contentLanguage:">contentLanguage: aString	(self getFieldAt: 'content-language') value: aString</body><body package="HTTP" selector="contentLocation">contentLocation	^self fieldValueAt: 'content-location'</body><body package="HTTP" selector="contentLocation:">contentLocation: aString	(self getFieldAt: 'content-location') value: aString</body><body package="HTTP" selector="contentMD5">contentMD5	^self fieldValueAt: 'content-md5'</body><body package="HTTP" selector="contentMD5:">contentMD5: aString	(self getFieldAt: 'content-md5') value: aString</body><body package="HTTP" selector="contentRange">contentRange	^self fieldValueAt: 'content-range'</body><body package="HTTP" selector="contentRange:">contentRange: aString	(self getFieldAt: 'content-range') value: aString</body><body package="HTTP" selector="cookie">cookie	^self fieldAt: 'cookie'</body><body package="HTTP" selector="cookie2">cookie2	^self fieldAt: 'cookie2'</body><body package="HTTP" selector="cookie2:">cookie2: aCookie2Field 	(self getFieldAt: 'cookie2') value: aCookie2Field</body><body package="HTTP" selector="cookie:">cookie: aCookieField 	self fieldAt: 'cookie' put: aCookieField</body><body package="HTTP" selector="date">date	^self fieldValueAt: 'date'</body><body package="HTTP" selector="date:">date: aTimestampOrStringOrArray	(self getFieldAt: 'date') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="etag">etag	^self fieldValueAt: 'etag'</body><body package="HTTP" selector="etag:">etag: aString	(self getFieldAt: 'etag') value: aString</body><body package="HTTP" selector="expires">expires	^self fieldValueAt: 'expires'</body><body package="HTTP" selector="expires:">expires: aTimestampOrStringOrArray	(self getFieldAt: 'expires') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="from">from	^self fieldValueAt: 'from'</body><body package="HTTP" selector="from:">from: aString	(self getFieldAt: 'from') value: aString</body><body package="HTTP" selector="lastModified">lastModified	^self fieldValueAt: 'last-modified'</body><body package="HTTP" selector="lastModified:">lastModified: aTimestampOrStringOrArray	(self getFieldAt: 'last-modified') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="pragma">pragma	^self fieldValueAt: 'pragma'</body><body package="HTTP" selector="pragma:">pragma: aString	(self getFieldAt: 'pragma') value: aString</body><body package="HTTP" selector="removeFromCacheControl:">removeFromCacheControl: aString	(self getFieldAt: 'cache-control') removeDirective: aString</body><body package="HTTP" selector="setCookie">setCookie	^self fieldAt: 'set-cookie'</body><body package="HTTP" selector="setCookie2">setCookie2	^self fieldAt: 'set-cookie2'</body><body package="HTTP" selector="setCookie2:">setCookie2: aSetCookie2Field 	(self getFieldAt: 'set-cookie2') value: aSetCookie2Field</body><body package="HTTP" selector="setCookie:">setCookie: aSetCookieField 	(self getFieldAt: 'set-cookie') value: aSetCookieField</body><body package="HTTP" selector="setCookieFields">setCookieFields	| coll sc |	coll := OrderedCollection new.	(sc := self fieldAt: 'set-cookie') notNil ifTrue: [ coll add: sc ].	(sc := self fieldAt: 'set-cookie2') notNil ifTrue: [ coll add: sc ].	^coll</body><body package="HTTP" selector="transferCoding">transferCoding	^self fieldValueAt: 'transfer-coding'</body><body package="HTTP" selector="transferCoding:">transferCoding: aString	^self fieldValueAt: 'transfer-coding' put: aString</body><body package="HTTP" selector="transferEncoding">transferEncoding	^self fieldValueAt: 'transfer-encoding'</body><body package="HTTP" selector="transferEncoding:">transferEncoding: aStringOrColl	| val |	val := aStringOrColl isString 			ifTrue: [ OrderedCollection with: aStringOrColl]			ifFalse: [ aStringOrColl ].			^self fieldValueAt: 'transfer-encoding' put: val</body><body package="HTTP" selector="via">via	^self fieldValueAt: 'via'</body><body package="HTTP" selector="via:">via: aString	(self getFieldAt: 'via') value: aString</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing</category><body package="HTTP" selector="keepAlive:">keepAlive: aBoolean	| val  token |	token := aBoolean ifTrue: ['Keep-Alive'] ifFalse: ['close'].	val := (self getFieldAt: 'connection') value.	#('Keep-Alive' 'close') do: [ :t | val removeAllSuchThat:[ :elem | t match:  elem ]].	val add: token.</body><body package="HTTP" selector="messageLine">messageLine	^self subclassResponsibility</body><body package="HTTP" selector="messageLine:">messageLine: anObject	self subclassResponsibility</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing body parts</category><body package="HTTP" selector="byteContents">byteContents	| s |	^(s := self byteSource)  isNil		ifTrue: [ nil ]		ifFalse: [ s reset; contents ]</body><body package="HTTP" selector="byteSource">byteSource	^self body byteSource</body><body package="HTTP" selector="byteSource:">byteSource: aByteArrayStream	self body byteSource: aByteArrayStream</body><body package="HTTP" selector="contents">contents"Returns the message body contents. If the entity still has compressed body contents the method returns the compressed bytes  "	| v ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [self byteContents]		ifFalse: [(v := self body value) ifNotNil: [ v asString ]]</body><body package="HTTP" selector="decodedContents">decodedContents"Returns decoded body contents. If the entity still has compressed body contents the method decompresses the body and returns decoded body contents  "	| ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [(self body decompressedContents withEncoding: self charset ) readStream contents]		ifFalse: 	[self decodedContentsWith: self charset ]</body><body package="HTTP" selector="decompressedContents">decompressedContents"Returns decompressed body contents. The body contents won't be changed "	| ce |	ce := self contentEncoding.	^(ce notNil and: ['gzip' match: ce ])		ifTrue: [self body decompressedContents]		ifFalse: 	[self decodedContents]</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>private</category><body package="HTTP" selector="decodedByteContentsStream">decodedByteContentsStream	| ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [(self body decompressedContents withEncoding: self charset ) readStream ]		ifFalse: 	[super decodedByteContentsStream]</body><body package="HTTP" selector="hasByteSource">hasByteSource	^self byteSource notNil</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>visiting</category><body package="HTTP" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptMessage: self with: argument</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>printing options</category><body package="HTTP" selector="chunkSize">chunkSize	^self writingOptions chunkSize</body><body package="HTTP" selector="chunkSize:">chunkSize: aNumber	self writingOptions chunkSize: aNumber</body><body package="HTTP" selector="doChunk">doChunk	self shouldChunk: true</body><body package="HTTP" selector="doNotChunk">doNotChunk	self shouldChunk: false</body><body package="HTTP" selector="shouldChunk">shouldChunk	^self writingOptions shouldChunk</body><body package="HTTP" selector="shouldChunk:">shouldChunk: aBoolean	self writingOptions shouldChunk: aBoolean</body><body package="HTTP" selector="useGZipTransfer">useGZipTransfer	^self writingOptions useGZipTransfer</body><body package="HTTP" selector="useGZipTransfer:">useGZipTransfer: aBoolean	self writingOptions useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>parsing options</category><body package="HTTP" selector="decodeContents">decodeContents	^self readingOptions decodeContents</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self readingOptions decodeContents: aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^self readingOptions decompressContents</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self readingOptions decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>writing</category><body package="HTTP" selector="newWriter">newWriter	^self writingOptions newWriter</body></methods><methods><class-id>Net.HttpEntity class</class-id> <category>defaults</category><body package="HTTP" selector="defaultReadingOptionsType">defaultReadingOptionsType	^HttpBuildHandler defaultOptionsType</body><body package="HTTP" selector="defaultWritingOptionsType">defaultWritingOptionsType	^HttpWriteHandler defaultOptionsType</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing</category><body package="HTTP" selector="headerOnly">headerOnly	^self requestLine ifNil: [false] ifNotNil: [ :line | line headerOnly ]</body><body package="HTTP" selector="hostName">hostName	^self hostPortToConnect first</body><body package="HTTP" selector="messageLine">messageLine	^self requestLine</body><body package="HTTP" selector="messageLine:">messageLine: aRequestLine	self requestLine: aRequestLine</body><body package="HTTP" selector="method">method	^self requestLine method</body><body package="HTTP" selector="port">port	^self hostPortToConnect last</body><body package="HTTP" selector="protocol">protocol	^self requestLine protocol</body><body package="HTTP" selector="requestLine">requestLine	^requestLine</body><body package="HTTP" selector="requestLine:">requestLine: aRequestLine	requestLine := aRequestLine.</body><body package="HTTP" selector="url">url	| path |	^self requestLine hasAbsoluteURI		ifTrue: [self requestLine url ]		ifFalse: 	[ path := self requestLine path.				path first =$/  ifTrue: [path := path copyFrom: 2 to: path size].				HttpURL host: self host pathString: path ]</body><body package="HTTP" selector="url:">url: aURI	self requestLine url: aURI.	(self fieldAt: 'host') ifNotNil: [ :field | self removeField: field ].</body><body package="HTTP" selector="useProxy">useProxy	^self requestLine useProxy</body><body package="HTTP" selector="useProxy:">useProxy: aBoolean	self requestLine useProxy: aBoolean</body><body package="HTTP" selector="version">version	^self requestLine version</body><body package="HTTP" selector="version:">version: aString	^self requestLine version: aString</body><body package="HTTP" selector="writingOptions">writingOptions	^writingOptions ifNil: [ (writingOptions := HttpWritingOptions new) headerOnly: self headerOnly ]</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>private</category><body package="HTTP" selector="hostPortToConnect">hostPortToConnect"1.If Request-URI is an absoluteURI, the host is part of the        Request-URI. Any Host header field value in the request MUST be        ignored.2. If the Request-URI is not an absoluteURI, and the request        includes a Host header field, the host is determined by the Host        header field value.3. If the host as determined by rule 1 or 2 is not a valid host on        the server, the response MUST be a 400 (Bad Request) error        message."	| host str port |	self requestLine hasAbsoluteURI		ifTrue: 			[ ^Array with: self requestLine host with: self requestLine port]		ifFalse:			[ (host := self host) ~~ nil				ifTrue: 					[ str := host readStream.					host := str upTo: $:.					(port := Number readFrom: str) = 0 ifTrue: [ port := nil].					^Array with: host with: port]].		HttpBadRequest new messageText: (#HostIsNotSpecified &lt;&lt; #net &gt;&gt; 'Host is not specified'); raiseSignal</body><body package="HTTP" selector="method:url:">method: aMethodString url: requestURI	requestLine := HttpRequestLine new					method: aMethodString; 					url: requestURI asURI;					yourself</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>mandatory extensions</category><body package="HTTP" selector="extendedMethod">extendedMethod	^self requestLine extendedMethod</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing fields</category><body package="HTTP" selector="accept">accept	" Returns all AcceptFields "	^self fieldsAt: 'accept'</body><body package="HTTP" selector="accept:">accept: aStringOrAcceptField"Sets a value the parameter can be a string or instance of AcceptField"		aStringOrAcceptField isString		ifTrue:  [ (self getFieldAt: 'accept') addMedia: aStringOrAcceptField]		ifFalse: 	[ self removeFieldAt: 'accept'.				self addField: aStringOrAcceptField]</body><body package="HTTP" selector="acceptCharset">acceptCharset"Returns collection of AcceptCharsetFields"	^self fieldsAt: 'accept-charset'</body><body package="HTTP" selector="acceptCharset:">acceptCharset: aStringOrAcceptCharsetField"Sets a value the parameter can be a string or instance of AcceptCharsetField"		aStringOrAcceptCharsetField isString		ifTrue: [ (self getFieldAt: 'accept-charset') addCharset: aStringOrAcceptCharsetField]		ifFalse:			[ self removeFieldAt: 'accept-charset'.			self addField: aStringOrAcceptCharsetField]</body><body package="HTTP" selector="acceptEncoding">acceptEncoding	^self fieldValueAt: 'accept-encoding'</body><body package="HTTP" selector="acceptEncoding:">acceptEncoding: aStringOrCollection	(self getFieldAt: 'accept-encoding') value: aStringOrCollection</body><body package="HTTP" selector="acceptLanguage">acceptLanguage" Returns all AcceptLanguageFields "	^self fieldsAt: 'accept-language'</body><body package="HTTP" selector="acceptLanguage:">acceptLanguage: aStringOrAcceptLanguageField"Sets a value the parameter can be a string or instance of AcceptLanguage"		aStringOrAcceptLanguageField isString		ifTrue: 			[ (self getFieldAt: 'accept-language') 			addLanguage: aStringOrAcceptLanguageField]		ifFalse:			[ self removeFieldAt: 'accept-language'.			self addField: aStringOrAcceptLanguageField]</body><body package="HTTP" selector="authorization">authorization	^self fieldAt: 'authorization'</body><body package="HTTP" selector="authorization:">authorization: aStringOrAuthorizationField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		aStringOrAuthorizationField isString		ifTrue: [ (self getFieldAt: 'authorization') addScheme: aStringOrAuthorizationField]		ifFalse:			[ self removeFieldAt: 'authorization'.			self addField: aStringOrAuthorizationField]</body><body package="HTTP" selector="host">host	^self fieldValueAt: 'host'</body><body package="HTTP" selector="host:">host: aString	(self getFieldAt: 'host') value: aString</body><body package="HTTP" selector="ifMatch">ifMatch	^self fieldValueAt: 'if-match'</body><body package="HTTP" selector="ifMatch:">ifMatch: aStringOrCollection	(self getFieldAt: 'if-match') value: aStringOrCollection</body><body package="HTTP" selector="ifModifiedSince">ifModifiedSince	^self fieldValueAt: 'if-modified-since'</body><body package="HTTP" selector="ifModifiedSince:">ifModifiedSince: aString	(self getFieldAt: 'if-modified-since') value: aString</body><body package="HTTP" selector="ifNoneMatch">ifNoneMatch	^self fieldValueAt: 'if-none-match'</body><body package="HTTP" selector="ifNoneMatch:">ifNoneMatch: aStringOrCollection	(self getFieldAt: 'if-none-match') value: aStringOrCollection</body><body package="HTTP" selector="ifRange">ifRange	^self fieldValueAt: 'if-range'</body><body package="HTTP" selector="ifRange:">ifRange: aString	(self getFieldAt:'if-range') value: aString</body><body package="HTTP" selector="ifUnModifiedSince">ifUnModifiedSince	^self fieldValueAt: 'if-unmodified-since'</body><body package="HTTP" selector="ifUnModifiedSince:">ifUnModifiedSince: aString	(self getFieldAt: 'if-unmodified-since') value: aString</body><body package="HTTP" selector="maxForwards">maxForwards	^self fieldValueAt: 'max-forwards'</body><body package="HTTP" selector="maxForwards:">maxForwards: aString	(self getFieldAt:  'max-forwards') value: aString</body><body package="HTTP" selector="proxyAuthorization">proxyAuthorization	^self fieldValueAt: 'proxy-authorization'</body><body package="HTTP" selector="proxyAuthorization:">proxyAuthorization: aString	(self getFieldAt:  'proxy-authorization' ) value: aString</body><body package="HTTP" selector="referer">referer	^self fieldValueAt: 'referer'</body><body package="HTTP" selector="referer:">referer: aString	(self getFieldAt: 'referer') value: aString</body><body package="HTTP" selector="userAgent">userAgent	^self fieldValueAt: 'user-agent'</body><body package="HTTP" selector="userAgent:">userAgent: aString	(self getFieldAt: 'user-agent') value: aString</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>testing</category><body package="HTTP" selector="hasHostField">hasHostField	^self host notNil</body><body package="HTTP" selector="isHttp10">isHttp10	^self requestLine isHttp10</body><body package="HTTP" selector="isValid">isValid	^(self requestLine isValid and: [ self host notNil])</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>transfer encodings</category><body package="HTTP" selector="transferFieldOrder">transferFieldOrder" HTTP request  recommends field order (if present) to be as follows. Order for remaining fiedls does not matter "	^#('host')</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>low-level command interface</category><body package="HTTP" selector="execute">execute" Create http client, connect, send request and answer HttpResponse "	| client |	client := self newClient.	^[client executeRequest: self]		ensure: [ client ifNotNil: [ client close]]</body><body package="HTTP" selector="executeDo:">executeDo: aBlock" Create http client, connect, send request and pass http connection stream to the specified block "	^self newClient		executeRequest: self		do: aBlock.</body><body package="HTTP" selector="newClient">newClient	^HttpClient new		readingOptions: self readingOptions;		writingOptions: self writingOptions;		yourself</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>obsolete</category><body package="HTTP" selector="addAuthorizationCode:">addAuthorizationCode: code"obsolete"	self authorization: code</body><body package="HTTP" selector="addProxyAuthorizationCode:">addProxyAuthorizationCode: code"obsolete"	self proxyAuthorization: code</body><body package="HTTP" selector="proxyRealm:username:password:">proxyRealm: rString username: unString password: pString"obsolete"	| code |	^(code := BasicAuthentication encodeUser: unString password: pString) notNil		ifTrue:[ self addProxyAuthorizationCode: rString, ' ', code ]		ifFalse: [ nil]</body><body package="HTTP" selector="realm:username:password:">realm: rString username: unString password: pString"obsolete"	| code |	^(code := BasicAuthentication encodeUser: unString password: pString) notNil		ifTrue:[ self addAuthorizationCode: rString, ' ', code ]		ifFalse: [ nil]</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>Http commands</category><body package="HTTP" selector="connect:">connect: urlString	^self method: 'CONNECT' url: urlString</body><body package="HTTP" selector="delete:">delete: urlString	^self method: 'DELETE' url: urlString</body><body package="HTTP" selector="get:">get: urlString	^self method: 'GET' url: urlString</body><body package="HTTP" selector="headers:">headers: urlString	^self method: 'HEAD' url: urlString</body><body package="HTTP" selector="post:">post: urlString	^self method: 'POST' url: urlString</body><body package="HTTP" selector="put:">put: urlString	^self method: 'PUT' url: urlString</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>defaults</category><body package="HTTP" selector="defaultContentType">defaultContentType	^MimeTypeDescriptor contentTypeHtml</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>instance creation</category><body package="HTTP" selector="method:url:">method: aMethodString url: requestURI	^self new 		method: aMethodString url: requestURI;		yourself</body></methods><methods><class-id>Net.SetCookie2Field</class-id> <category>accessing</category><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^SetCookie2Value</body></methods><methods><class-id>Net.SetCookie2Field class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('set-cookie2' )</body></methods><methods><class-id>Net.AcceptField</class-id> <category>accessing</category><body package="HTTP" selector="levelAt:">levelAt: index	^(self mediaRangeAt: index) paramAt: 'level'</body><body package="HTTP" selector="mediaRangeAt:">mediaRangeAt: index	^self value at: index</body><body package="HTTP" selector="mediaTypeAt:">mediaTypeAt: index	^(self mediaRangeAt: index) value</body></methods><methods><class-id>Net.AcceptField</class-id> <category>adding media range</category><body package="HTTP" selector="addMedia:">addMedia: vString	self addMedia: vString qValue: nil</body><body package="HTTP" selector="addMedia:level:">addMedia: vString level: lString	self addMedia: vString qValue: nil level: lString</body><body package="HTTP" selector="addMedia:qValue:">addMedia: vString qValue: qString	self addMedia: vString qValue: qString level: nil</body><body package="HTTP" selector="addMedia:qValue:level:">addMedia: vString qValue: qString level: lString	| valWithParams |	valWithParams := self addValue: vString qValue: qString.	lString notNil ifTrue: [ valWithParams paramAt: 'level' put: lString].</body></methods><methods><class-id>Net.AcceptField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('accept')</body></methods><methods><class-id>Net.AcceptField class</class-id> <category>instant creation</category><body package="HTTP" selector="media:">media: vString	^self media: vString qValue: nil level: nil</body><body package="HTTP" selector="media:level:">media: mString level: lString	^self media: mString qValue: nil level: lString</body><body package="HTTP" selector="media:qValue:">media: vString qValue: qString	^self media: vString qValue: qString level: nil</body><body package="HTTP" selector="media:qValue:level:">media: mString qValue: qString level: lString" Answer an instance of this field representing media range"	^(self name: 'accept') 		addMedia: mString qValue: qString level: lString;		yourself</body></methods><methods><class-id>Net.ManOptField</class-id> <category>accessing</category><body package="HTTP" selector="addNamespace:id:">addNamespace: urlString id: idNumber		| valWithParams |	valWithParams := ValueWithParams newWithSeparators: self separators.	valWithParams value: urlString.	idNumber notNil ifTrue: [valWithParams paramAt: 'ns' put: idNumber].	self value add: valWithParams.	^valWithParams</body><body package="HTTP" selector="id">id	^self element paramAt: 'ns'</body><body package="HTTP" selector="id:">id: idNumber		self element paramAt: 'ns' put: idNumber</body><body package="HTTP" selector="namespace">namespace	^self element value</body><body package="HTTP" selector="namespace:">namespace: urlString		self element value: urlString</body><body package="HTTP" selector="namespace:id:">namespace: urlString id: idNumber		self 		namespace: urlString;		id: idNumber</body></methods><methods><class-id>Net.ManOptField</class-id> <category>queries</category><body package="HTTP" selector="idForNamespace:">idForNamespace: urlString	^self idForNamespace: urlString ifAbsent: [nil]</body><body package="HTTP" selector="idForNamespace:ifAbsent:">idForNamespace: urlString ifAbsent: aBlock	| param |	param := self value detect: [ :ea | ea value = urlString] ifNone: [ nil].	^param notNil 		ifTrue: [ param paramAt: 'ns']		ifFalse: [ aBlock value]</body><body package="HTTP" selector="namespaceForId:">namespaceForId: idNumber	^self namespaceForId: idNumber ifAbsent: [nil]</body><body package="HTTP" selector="namespaceForId:ifAbsent:">namespaceForId: idNumber ifAbsent: aBlock	| param |	param := self value detect: [ :ea | (ea paramAt: 'ns') = idNumber] ifNone: [ nil].	^param notNil 		ifTrue: [ param value ]		ifFalse: [ aBlock value ]</body><body package="HTTP" selector="namespaceMap">namespaceMap	|dict|	dict := Dictionary new.	self value do: [ :ea | dict at: ea value put: (ea paramAt: 'ns')].	^dict</body><body package="HTTP" selector="namespaceMapAt:">namespaceMapAt: nsString	^self namespaceMapAt: nsString ifAbsent: nil</body><body package="HTTP" selector="namespaceMapAt:ifAbsent:">namespaceMapAt: nsString ifAbsent: aBlock	^self namespaceMap at: nsString ifAbsent: [aBlock].</body><body package="HTTP" selector="namespaceMapKeyAtValue:">namespaceMapKeyAtValue: idString	^self namespaceMapKeyAtValue: idString ifAbsent: nil</body><body package="HTTP" selector="namespaceMapKeyAtValue:ifAbsent:">namespaceMapKeyAtValue: idString ifAbsent: aBlock	self namespaceMap keysAndValuesDo: 		[:aKey :aValue |  idString = aValue ifTrue: [^aKey]].	^aBlock value</body><body package="HTTP" selector="removeId:">removeId: idString	self value removeAllSuchThat: 		 [ :valWithParams |			(valWithParams paramAt: 'ns')  = idString ]</body></methods><methods><class-id>Net.ManOptField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('man' 'opt' 'c-man' 'c-opt' )</body></methods><methods><class-id>Net.ManOptField class</class-id> <category>instant creation</category><body package="HTTP" selector="field:namespace:id:">field: aFieldName namespace: nsString id: idString	^(self name: aFieldName) 		addNamespace: nsString id: idString;		yourself</body></methods><methods><class-id>Net.TransferEncoding</class-id> <category>accessing</category><body package="HTTP" selector="add:">add: aTransferEncoding	self value addAll: aTransferEncoding value</body><body package="HTTP" selector="canMerge">canMerge	^true</body></methods><methods><class-id>Net.TransferEncoding</class-id> <category>testing</category><body package="HTTP" selector="isChunked">isChunked	^self value anySatisfy: [ :vx | 'chunked' match: vx ]</body><body package="HTTP" selector="isGZipped">isGZipped	^self value anySatisfy: [ :vx | 'gzip' match: vx ]</body></methods><methods><class-id>Net.TransferEncoding class</class-id> <category>instant creation</category><body package="HTTP" selector="chunkedTransfer">chunkedTransfer" Answer an instance of this field representing chunked transfer encoding for Http mesagesTransfer-Encoding: chunked "	^(self name: 'transfer-encoding') value:  'chunked'</body><body package="HTTP" selector="gzipTransfer">gzipTransfer" Answer an instance of this field representing compressed transfer encoding for Http messagesTransfer-encoding: gzip "	^(self name: 'transfer-encoding') value:  'gzip'</body></methods><methods><class-id>Net.TransferEncoding class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#( 'transfer-encoding'  )</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>accessing</category><body package="HTTP" selector="bufferNumber">bufferNumber	^bufferNumber</body><body package="HTTP" selector="chunkSize:">chunkSize: aNumber	self writeLimit: aNumber</body><body package="HTTP" selector="flush">flush	"Write any unwritten information  "	useChunks := true.	buffer ifNotNil: [		self signalReadyToWrite.		self writeChunkUnconditionally ].	stream flush</body><body package="HTTP" selector="nextPut:">nextPut: anObject 	"Put the argument, anObject, at the next position in the receiver.	Answer anObject."	position = self writeLimit ifTrue: [ self writeChunk ].	buffer ifNil: [self initializeWriteBuffer ].	position := position + 1.	buffer at: position put: anObject asInteger.	^anObject</body><body package="HTTP" selector="onFinishWithOneBufferDo">onFinishWithOneBufferDo	^onFinishWithOneBufferDo</body><body package="HTTP" selector="onFinishWithOneBufferDo:">onFinishWithOneBufferDo: aBlock	onFinishWithOneBufferDo := aBlock</body><body package="HTTP" selector="onReadyToWriteFirstBufferDo">onReadyToWriteFirstBufferDo	^onReadyToWriteFirstBufferDo</body><body package="HTTP" selector="onReadyToWriteFirstBufferDo:">onReadyToWriteFirstBufferDo: aBlock	onReadyToWriteFirstBufferDo := aBlock</body><body package="HTTP" selector="useChunks">useChunks	^useChunks ifNil: [ true]</body><body package="HTTP" selector="useChunks:">useChunks: aBoolean	useChunks := aBoolean</body><body package="HTTP" selector="writeLimit">writeLimit	^writeLimit ifNil: [writeLimit := self class defaultWriteLimit ]</body><body package="HTTP" selector="writeLimit:">writeLimit: aNumber	writeLimit := aNumber</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>status</category><body package="HTTP" selector="close">close	self finish.	stream close.</body><body package="HTTP" selector="finish">finish	"Write any unwritten information and last chunk       last-chunk     = 1*('0') [ chunk-extension ] CRLF       chunk-extension= *( ';' chunk-ext-name [ '=' chunk-ext-val ] )       chunk-ext-name = token       chunk-ext-val  = token | quoted-string       chunk-data     = chunk-size(OCTET)       trailer        = *(entity-header CRLF) "	buffer ifNotNil: 		[bufferNumber == 0			ifTrue: [self onFinishWithOneBufferDo 						ifNotNil: [ :block | 								block value: position.								self useChunks: false.								bufferNumber := 1.]]].		self useChunks			ifTrue: [self writeChunk.					self writeLastChunk]			ifFalse: [ self writeBuffer ].	stream finish.</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>private</category><body package="HTTP" selector="beginWriteChunk">beginWriteChunk	self useChunks 		ifTrue:			[| s | 			s := EncodedStream 					on: (ByteArray new: 100) writeStream 					encodedBy: (StreamEncoder new: #ascii).			position printOn: s  base: 16. 			stream 				nextPutAll: s encodedContents;				nextPutAll: self lineEnd].</body><body package="HTTP" selector="endWriteChunk">endWriteChunk	self useChunks ifTrue: [stream nextPutAll: self lineEnd].</body><body package="HTTP" selector="initializeWriteBuffer">initializeWriteBuffer	buffer :=  self contentsSpecies new: self writeLimit. 	position := 0</body><body package="HTTP" selector="signalReadyToWrite">signalReadyToWrite"We signal the first chunck is ready to write and parent has to add the header: Transfer-Encoding: chunked HttpWriteHandler: onReadyToWriteFirstBufferDo: [ self addTransferChunked ] "	bufferNumber == 0 		ifTrue: [	self onReadyToWriteFirstBufferDo ifNotNil: [ :block | block value]. 				 self useChunks: true]</body><body package="HTTP" selector="writeBuffer">writeBuffer	position &gt; 0 ifTrue: [		stream next: position putAll: buffer startingAt: 1.		position := 0.		bufferNumber := bufferNumber + 1.		buffer := nil ]</body><body package="HTTP" selector="writeChunk">writeChunk	buffer ifNotNil: [		self signalReadyToWrite.		self writeChunkUnconditionally ]</body><body package="HTTP" selector="writeChunkUnconditionally">writeChunkUnconditionally	stream binary.	self beginWriteChunk.	self writeBuffer.	self endWriteChunk.</body><body package="HTTP" selector="writeLastChunk">writeLastChunk	self useChunks		ifTrue:			[stream nextPut: $0 asInteger.			stream nextPutAll: self lineEnd.			stream nextPutAll: self lineEnd ].</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>testing</category><body package="HTTP" selector="isReadable">isReadable	^false</body><body package="HTTP" selector="isWritable">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>initialize-release</category><body package="HTTP" selector="initializeOn:">initializeOn: aStream	super initializeOn: aStream.	bufferNumber := 0.</body></methods><methods><class-id>Net.ChunkedWriteStream class</class-id> <category>defaults</category><body package="HTTP" selector="defaultWriteLimit">defaultWriteLimit	^defaultWriteLimit ifNil: [defaultWriteLimit := self defaultWriteLimitValue]</body><body package="HTTP" selector="defaultWriteLimit:">defaultWriteLimit: aNumber	defaultWriteLimit := aNumber</body><body package="HTTP" selector="defaultWriteLimitValue">defaultWriteLimitValue	^4096</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>private prepare streams</category><body package="HTTP" selector="prepareStream:forMessageBody:">prepareStream: aStream forMessageBody: anEntity	stream := aStream.	 anEntity isChunked ifTrue: [ stream := ChunkedReadStream on:  stream ].	stream := BodyStream on: stream length: anEntity contentLength.	anEntity isTransferEncodingGZip 		ifTrue: [ stream := OS.ZLib.GZipReadStream on:  stream ].	^stream</body><body package="HTTP" selector="prepareStream:forSimpleBody:">prepareStream: aStream forSimpleBody: aBody	^(self shouldBeDecompressed: aBody parent)		ifTrue: [ OS.ZLib.GZipReadStream on:  aStream ]		ifFalse: [aStream]</body><body package="HTTP" selector="setAttachmentSource:to:">setAttachmentSource: aBody to: aStream	aBody byteSource: aStream</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>private</category><body package="HTTP" selector="decodeBody:">decodeBody: aBody	| ce |	(aBody isMultipart 		or: [ aBody isBinary			or: [aBody byteSource isNil ]]) ifTrue: [^aBody].	(((ce := aBody parent contentEncoding) notNil 			and: [ce notEmpty]) 				or: [self decodeContents not])		ifFalse: [self setBodySource: aBody]</body><body package="HTTP" selector="handleStartBody:exception:">handleStartBody: aBody exception: exception	(HttpTimeout handles: exception)		ifTrue: 			[exception parameter: aBody parent.			exception pass]		ifFalse: [ super handleStartBody: aBody exception: exception ]</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>testing</category><body package="HTTP" selector="shouldBeDecompressed:">shouldBeDecompressed: anEntity	^(self decompressContents 		and: [anEntity isContentEncodingGZip ])</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>action callbacks</category><body package="HTTP" selector="endBody:">endBody: aBody	(self shouldBeDecompressed: aBody parent)		ifTrue: [aBody parent removeFieldAt: 'content-encoding'].		aBody parent isContentEncodingGZip 		ifFalse: [ self decodeBody: aBody].	^super endBody: aBody</body><body package="HTTP" selector="endMessageBody:">endMessageBody: aBody	| message |	message := aBody parent.	(message isChunked		or: [message isTransferEncodingGZip])			ifTrue: [ message removeFieldAt: 'transfer-encoding']. 		^message</body><body package="HTTP" selector="shouldStartMessageBody:">shouldStartMessageBody: aMessageBody 	| message |	message := aMessageBody parent.	message isMimeEntity  ifTrue: [^true].	(self headerOnly or: [message headerOnly]) ifTrue: [ ^false ]." In particular, the convention has been established that the GET and   HEAD methods SHOULD NOT have the significance of taking an action   other than retrieval."	(message isResponse not and: [ message method asSymbol == #GET]) ifTrue: [^false].	^message contentLength		ifNil: [	message isChunked or: [				message isConnectionTransient  or: [				UnspecifiedBodySize new parameter: message; raiseRequest ] ] ]		ifNotNil: [ :length | length &gt; 0 ]</body><body package="HTTP" selector="startMessage:">startMessage: aLineObject	initialEntity isNil ifTrue: [ initialEntity := aLineObject entityType new].	initialEntity messageLine: aLineObject.	^initialEntity</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>accessing</category><body package="HTTP" selector="decodeContents">decodeContents	^self options decodeContents</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self options decodeContents: aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^self options decompressContents</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self options decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>defaults</category><body package="HTTP" selector="parserClass">parserClass	^HttpParser</body></methods><methods><class-id>Net.HttpBuildHandler class</class-id> <category>defaults</category><body package="HTTP" selector="decodeContents">decodeContents	^self defaultOptionsType decodeContents</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self defaultOptionsType decodeContents: aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^self defaultOptionsType decompressContents</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self defaultOptionsType decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpBuildHandler class</class-id> <category>default values</category><body package="HTTP" selector="decodeContentsValue">decodeContentsValue	^self defaultOptionsType decodeContentsValue</body><body package="HTTP" selector="defaultAttachmentDirectoryValue">defaultAttachmentDirectoryValue	^self defaultOptionsType defaultAttachmentDirectoryValue</body><body package="HTTP" selector="defaultDecompressContents">defaultDecompressContents	^self defaultOptionsType defaultDecompressContents</body><body package="HTTP" selector="defaultOptionsType">defaultOptionsType	^HttpReadingOptions</body><body package="HTTP" selector="saveAttachmentsAsFilesValue">saveAttachmentsAsFilesValue	^self defaultOptionsType saveAttachmentsAsFilesValue</body></methods><methods><class-id>Net.HttpDispatcher</class-id> <category>visiting -- double dispatching</category><body package="HTTP" selector="acceptMessage:with:">acceptMessage: aHttpEntity  with: argument	aHttpEntity messageLine ifNotNil: [ :line | line acceptVisit: self  with: aHttpEntity].	super acceptMessage: aHttpEntity  with: argument.	^aHttpEntity</body><body package="HTTP" selector="acceptRequestLine:with:">acceptRequestLine: aRequestLine with: aHttpEntity	self handler startRequestLine: aRequestLine with: aHttpEntity.	^aRequestLine</body><body package="HTTP" selector="acceptResponseLine:with:">acceptResponseLine: aResponseStatusLine with: aHttpEntity	self handler startResponseStatusLine:  aResponseStatusLine with: aHttpEntity.	^aResponseStatusLine</body></methods><methods><class-id>Net.UnspecifiedBodySize</class-id> <category>constants</category><body package="HTTP" selector="defaultResumeValue">defaultResumeValue	"Answer the default value to resume with."	^false</body></methods><methods><class-id>Net.UnspecifiedBodySize</class-id> <category>printing</category><body package="HTTP" selector="defaultMessageText">defaultMessageText	^(#MessageBodySizeIsNotSpecified &lt;&lt; #net &gt;&gt; 'The message body size is not specified &lt;n&gt; &lt;1s&gt;' ) expandMacrosWith: parameter printStatusLineMessage</body></methods><methods><class-id>Net.HttpClient</class-id> <category>accessing</category><body package="HTTP" selector="hostName">hostName	^self clientPI hostName</body><body package="HTTP" selector="hostName:">hostName: aString	self clientPI hostName: aString</body><body package="HTTP" selector="logAsPrintString:">logAsPrintString: aBoolean	self clientPI logAsPrintString: aBoolean</body><body package="HTTP" selector="portNumber">portNumber	^self clientPI portNumber</body><body package="HTTP" selector="portNumber:">portNumber: aNumber	self clientPI portNumber: aNumber</body><body package="HTTP" selector="protocol">protocol	^protocol ifNil: 		[protocol := request notNil						ifTrue: [ self request protocol ]						ifFalse: [self class protocol ]		]</body><body package="HTTP" selector="protocol:">protocol: aString	protocol := aString</body><body package="HTTP" selector="proxyHost">proxyHost	^self clientPI proxyHost</body><body package="HTTP" selector="proxyHost:">proxyHost: aHostSpec	self clientPI proxyHost: aHostSpec</body><body package="HTTP" selector="proxyHostName">proxyHostName	^self clientPI proxyHostName</body><body package="HTTP" selector="proxyHostPort">proxyHostPort	^self clientPI proxyHostPort</body><body package="HTTP" selector="readingOptions">readingOptions	^self clientPI readingOptions</body><body package="HTTP" selector="readingOptions:">readingOptions: anHttpReadingOptions	self clientPI readingOptions: anHttpReadingOptions</body><body package="HTTP" selector="request">request	^request</body><body package="HTTP" selector="requestClass">requestClass	^HttpRequest</body><body package="HTTP" selector="timeout">timeout	^self clientPI timeout</body><body package="HTTP" selector="timeout:">timeout: numberOfMilliseconds	self clientPI timeout: numberOfMilliseconds</body><body package="HTTP" selector="useProxy">useProxy	^self clientPI useProxy</body><body package="HTTP" selector="useProxy:">useProxy: aBoolean	self clientPI useProxy: aBoolean.</body><body package="HTTP" selector="writingOptions">writingOptions	^self clientPI writingOptions</body><body package="HTTP" selector="writingOptions:">writingOptions: anHttpWritingOptions	self clientPI writingOptions: anHttpWritingOptions</body></methods><methods><class-id>Net.HttpClient</class-id> <category>authorization</category><body package="HTTP" selector="authPolicy">authPolicy	^self clientPI authPolicy</body><body package="HTTP" selector="authPolicy:">authPolicy: aHttpAuthPolicy	self clientPI authPolicy: aHttpAuthPolicy</body><body package="HTTP" selector="proxyPassword">proxyPassword	^self clientPI proxyPassword</body><body package="HTTP" selector="proxyUser">proxyUser	^self clientPI proxyUser</body><body package="HTTP" selector="proxyUser:">proxyUser: aNetUser	self clientPI proxyUser: aNetUser</body><body package="HTTP" selector="proxyUsername">proxyUsername	^self clientPI proxyUsername</body><body package="HTTP" selector="realm:">realm: rString	self authPolicy realm: rString</body><body package="HTTP" selector="useBasicAuth">useBasicAuth	self clientPI useBasicAuth.</body><body package="HTTP" selector="useNTLMAuth">useNTLMAuth	self clientPI useNTLMAuth.</body><body package="HTTP" selector="user">user	^self authPolicy user</body><body package="HTTP" selector="user:">user: aNetUser	self authPolicy user: aNetUser</body><body package="HTTP" selector="username:password:">username: unString password: pString	self authPolicy username: unString password: pString</body><body package="HTTP" selector="username:password:realm:">username: aString password: pString realm: rString	self authPolicy username: aString password: pString realm: rString</body></methods><methods><class-id>Net.HttpClient</class-id> <category>cookie management</category><body package="HTTP" selector="addCookieToRequest">addCookieToRequest	^self clientPI addCookieTo: self request.</body><body package="HTTP" selector="cookieAgent">cookieAgent	^self clientPI cookieAgent</body><body package="HTTP" selector="enableCookies">enableCookies	^self clientPI enableCookies</body><body package="HTTP" selector="enableCookies:">enableCookies: aBoolean 	self clientPI enableCookies: aBoolean</body><body package="HTTP" selector="registerCookiesFromResponse:">registerCookiesFromResponse: aHttpResponse	^self clientPI registerCookiesFromResponse: aHttpResponse</body><body package="HTTP" selector="terminateCookieAgent">terminateCookieAgent	self clientPI terminateCookieAgent</body></methods><methods><class-id>Net.HttpClient</class-id> <category>commands</category><body package="HTTP" selector="delete:">delete: urlString	request := (self requestClass delete: urlString ).	^self  executeAndGetResponse</body><body package="HTTP" selector="get:">get: urlString"The GET method means retrieve whatever information (in the form of an entity ) is identified by the urlString""Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass get: urlString ). 	^self  executeAndGetResponse</body><body package="HTTP" selector="headers:">headers: urlString"The HEAD method is identical to GET except that the server must not return a message body in the response""Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass headers: urlString ).	^self  executeAndGetResponse</body><body package="HTTP" selector="post:contents:">post: urlString contents: aString " The POST method is used to request that the destination server accept the specified aString as a new subordinate of the resource identified by the urlStringReturns an instance of HttpResponse if succeed or exception"	request := (self requestClass post: urlString ).	request contents: aString. 	^self  executeAndGetResponse</body><body package="HTTP" selector="put:contents:">put: urlString contents: aString"The PUT method requests that the specified aString be stored under the supplied urlString.Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass put: urlString ).	request contents: aString.	^self  executeAndGetResponse</body></methods><methods><class-id>Net.HttpClient</class-id> <category>connection management</category><body package="HTTP" selector="close">close	self clientPI close</body><body package="HTTP" selector="connect">connect	self clientPI 	streamHandlerClassFor: self protocol.	^self clientPI connect</body><body package="HTTP" selector="disconnect">disconnect	super disconnect.	protocol := nil</body><body package="HTTP" selector="keepAlive">keepAlive	keepAlive isNil ifTrue: [ keepAlive := self class keepAlive].	^keepAlive</body><body package="HTTP" selector="keepAlive:">keepAlive: aBoolean	keepAlive := aBoolean</body></methods><methods><class-id>Net.HttpClient</class-id> <category>streams -- guarded</category><body package="HTTP" selector="readStreamCmd:url:do:">readStreamCmd:  commandString url: url do: aBlock" Connect, evaluate block, ensure disconnect, answer block evaluation result "	^self 		executeRequest: (self requestClass method: commandString url: url asURI)		do: aBlock</body></methods><methods><class-id>Net.HttpClient</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	super initialize.	self clientPI timeout: self defaultTimeout.</body></methods><methods><class-id>Net.HttpClient</class-id> <category>low-level command interface</category><body package="HTTP" selector="executeAndGetResponse">executeAndGetResponse" Connect, send request, parse response and answer instance of HttpResponse class "	self request ifNil: [^nil].	self executeRequestDo: nil.	^self getResponse</body><body package="HTTP" selector="executeRequest:">executeRequest: aRequest" Connect, send request and answer HttpResponse "	request := aRequest.	^self executeAndGetResponse</body><body package="HTTP" selector="executeRequest:do:">executeRequest: aRequest do: aBlock" Connect, send request and pass connection to specified block "	request := aRequest.	^self executeRequestDo: aBlock</body><body package="HTTP" selector="executeRequestDo:">executeRequestDo: aBlock" Connect, send request and pass connection to specified block "	| streamx |	streamx := self privateExecuteRequest.	^aBlock ifNotNil: [ aBlock  value: streamx ]</body><body package="HTTP" selector="getResponse">getResponse	^self clientPI readResponse</body></methods><methods><class-id>Net.HttpClient</class-id> <category>private -- command interface</category><body package="HTTP" selector="executeWithConnection:">executeWithConnection: aConnectionStream"the method is used for debugging "	self prepareRequestToSend.	self clientPI request: self request.	^self clientPI executeWithConnection: aConnectionStream</body><body package="HTTP" selector="prepareRequestToSend">prepareRequestToSend	self keepAlive notNil		ifTrue: 			[self keepAlive ifTrue: [ self request keepAlive: true].			(self keepAlive not and: [ self request keepAlive not ]) 				ifTrue: [ self request keepAlive: false]				ifFalse: [ self request keepAlive: true ]].</body><body package="HTTP" selector="privateExecuteRequest">privateExecuteRequest	self prepareRequestToSend.	^self clientPI executeRequest: self request</body><body package="HTTP" selector="request:">request: aReq	request := aReq.	self clientPI request: aReq</body></methods><methods><class-id>Net.HttpClient</class-id> <category>utilities</category><body package="HTTP" selector="getUserAndPasswordDialogFor:">getUserAndPasswordDialogFor: response	| dialog spec result msg userx passwordx|	dialog := SimpleDialog new.	spec := (dialog class interfaceSpecFor: #emptySpec).	dialog initializeBuilderFor: nil.	dialog builder add: spec window.	dialog builder add: spec component.	dialog initializeWindowFor: nil.	msg := response descriptionString isNil				ifTrue: [(#TheServerRequiresUserPassword &lt;&lt; #net &gt;&gt; 'The server requires a user and password to see this resource.')]				ifFalse: [response descriptionString].	dialog setInitialGap.	dialog addMessage: msg centered: false.	dialog addGap: 8.	dialog addMessage: (#UserNameC &lt;&lt; #net &gt;&gt; 'User Name:') centered: false.	dialog addGap: 4.	dialog addTextLine: (userx := String new asValue).	dialog addGap: 8.	dialog addMessage: (#PasswordC &lt;&lt; #net &gt;&gt; 'Password:') centered: false.	dialog addGap: 4.	dialog addTextLine: (passwordx :=  String new asValue) type: #password.	dialog addGap: 8.	dialog addOK: [true].	dialog addGap: 6.	dialog preOpen.	dialog builder window maximumSize: Screen default bounds width @ dialog builder window displayBox height.	dialog builder window minimumSize: 150 @ dialog builder window displayBox height.	dialog builder openDialogWithExtent: dialog builder window displayBox extent.	result := dialog accept value		ifTrue: [self class encodeUser: userx value password: passwordx value]		ifFalse: [nil].	^result</body></methods><methods><class-id>Net.HttpClient</class-id> <category>streams -- unguarded</category><body package="HTTP" selector="readStreamCmd:url:">readStreamCmd:  commandString url: url" Connect, send request and answer http connection stream "	request := self requestClass method: commandString url: url asURI.	^self privateExecuteRequest</body></methods><methods><class-id>Net.HttpClient</class-id> <category>printing options</category><body package="HTTP" selector="chunkSize">chunkSize	^self clientPI chunkSize</body><body package="HTTP" selector="chunkSize:">chunkSize: aNumber	^self clientPI chunkSize: aNumber</body><body package="HTTP" selector="doChunk">doChunk	self clientPI shouldChunk: true</body><body package="HTTP" selector="doNotChunk">doNotChunk	self clientPI shouldChunk: false</body><body package="HTTP" selector="useGZipTransfer">useGZipTransfer	^self clientPI useGZipTransfer</body><body package="HTTP" selector="useGZipTransfer:">useGZipTransfer: aBoolean	self clientPI useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpClient</class-id> <category>parsing options</category><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self clientPI decodeContents: aBoolean</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self clientPI decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>constants</category><body package="HTTP" selector="description">description	^(#HTTPServer &lt;&lt; #net &gt;&gt; 'HTTP server') asString</body><body package="HTTP" selector="serverType">serverType	^#HTTP</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>accessing</category><body package="HTTP" selector="autoloadHttps">autoloadHttps	^Settings httpsAutoload</body><body package="HTTP" selector="autoloadHttps:">autoloadHttps: aBoolean	Settings httpsAutoload: aBoolean</body><body package="HTTP" selector="keepAlive">keepAlive	^Settings httpKeepAlive</body><body package="HTTP" selector="protocol">protocol	^Protocol ifNil: [ Protocol := self defaultProtocolValue ]</body><body package="HTTP" selector="protocol:">protocol: aString	Protocol := aString.</body><body package="HTTP" selector="proxyExceptions">proxyExceptions	^Settings httpProxyExceptions</body><body package="HTTP" selector="proxyHost">proxyHost	^Settings httpProxyHost</body><body package="HTTP" selector="useProxy">useProxy	^Settings httpUseProxy</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>utilities</category><body package="HTTP" selector="disableProxy">disableProxy	^self netSettings httpUseProxy: false</body><body package="HTTP" selector="enableProxy">enableProxy	^self netSettings httpUseProxy: true</body><body package="HTTP" selector="httpUsername:password:">httpUsername: username password: password	(username notNil and: [ password notNil])		ifTrue: 			[ Settings httpUser: (NetUser username: username password: password) ].</body><body package="HTTP" selector="proxyHost:port:">proxyHost: host port: port	self proxyHost: host port: port userid: nil password: nil</body><body package="HTTP" selector="proxyHost:port:userid:password:">proxyHost: host port: port userid: username password: password	| intPort hostSpec |	host isString ifFalse: [self error: (#ProxyHostNameMustBeString &lt;&lt; #net &gt;&gt; 'Proxy host name must be a string')].	intPort := port isCharacters 		ifTrue: [Integer readFrom: port readStream]		ifFalse: [port].	intPort isInteger 		ifFalse: [self error: (#ProxyPortMustBeAnInteger &lt;&lt; #net &gt;&gt; 'Proxy port must be an integer')].	hostSpec := (HostSpec new					name: host;					port:  intPort;					type: 'http';					yourself).	(username notNil and: [ password notNil])		ifTrue: [	hostSpec netUser: (NetUser username: username password: password)].	" set http proxy Settings "	Settings httpProxyHost: hostSpec.</body><body package="HTTP" selector="setKeepAlive">setKeepAlive	Settings httpKeepAlive: true</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>instance creation</category><body package="HTTP" selector="loginToHost:asUser:withPassword:">loginToHost: aHostName asUser: userString withPassword: passwdString 	self shouldNotImplement</body><body package="HTTP" selector="loginToHost:port:asUser:withPassword:">loginToHost: aHostName port: aNumber asUser: userString withPassword: passwdString	self shouldNotImplement</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>default values</category><body package="HTTP" selector="defaultProtocolInterpreterClassValue">defaultProtocolInterpreterClassValue	^HttpProtocolInterpreter</body><body package="HTTP" selector="defaultProtocolValue">defaultProtocolValue	^'http'</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>cookie management</category><body package="HTTP" selector="enableCookieProcessing">enableCookieProcessing	^self defaultProtocolInterpreterClass enableCookieProcessing</body><body package="HTTP" selector="enableCookieProcessing:">enableCookieProcessing: aBoolean	self defaultProtocolInterpreterClass enableCookieProcessing: aBoolean</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>commands</category><body package="HTTP" selector="get:">get: urlString	^self clientDo: [ :client | client  get: urlString]</body><body package="HTTP" selector="headers:">headers: urlString	^self clientDo: [ :client | client  headers: urlString]</body><body package="HTTP" selector="post:contents:">post: urlString contents: aString	^self clientDo: [ :client | client  post: urlString contents: aString]</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>private</category><body package="HTTP" selector="clientDo:">clientDo: aBlock	| client |	client := self new.	^[ aBlock value: client  ] 		ensure: [ client ifNotNil: [ client  close]]</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>class initialization</category><body package="HTTP" selector="initialize">initialize	"self initialize"	super initialize.	HeaderField resetRegistry.</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>printing utilities</category><body package="HTTP" selector="printPreambule:">printPreambule: aMessageBody	^true</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>defaults</category><body package="HTTP" selector="dispatcherClass">dispatcherClass	^HttpDispatcher</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>private</category><body package="HTTP" selector="isBinaryContent:entity:">isBinaryContent: aStream entity: anEntity	^(super isBinaryContent: aStream entity: anEntity)		or: [anEntity isContentEncodingGZip ]</body></methods><methods><class-id>Net.HttpPrintHandler class</class-id> <category>defaults</category><body package="HTTP" selector="defaultOptionsType">defaultOptionsType	^HttpWritingOptions</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>cookie management</category><body package="HTTP" selector="addCookieTo:">addCookieTo: aRequest	self getCookieAgent isNil ifTrue: [ ^nil ].	^self cookieAgent setCookieFieldForRequest: aRequest.</body><body package="HTTP" selector="cookieAgent">cookieAgent	^cookieAgent</body><body package="HTTP" selector="enableCookies">enableCookies	enableCookies isNil		ifTrue: [ enableCookies := self class enableCookieProcessing].	^enableCookies</body><body package="HTTP" selector="enableCookies:">enableCookies: aBoolean 	enableCookies := aBoolean</body><body package="HTTP" selector="getCookieAgent">getCookieAgent	self enableCookies ifFalse: [^nil].	cookieAgent isNil ifTrue: [cookieAgent := CookieAgent new].	^cookieAgent</body><body package="HTTP" selector="registerCookiesFromResponse:">registerCookiesFromResponse: aHttpResponse 	self getCookieAgent isNil ifTrue: [ ^nil ]. 	(aHttpResponse setCookieFields detect: [ :f | f shouldTerminateSession ] ifNone: [nil]) notNil		ifTrue: [self terminateCookieAgent. ^nil ].	^self cookieAgent addCookiesFrom: aHttpResponse requestUrl: self request url</body><body package="HTTP" selector="terminateCookieAgent">terminateCookieAgent	cookieAgent notNil		ifTrue: 			[ cookieAgent terminate.			cookieAgent := nil].</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>connection management</category><body package="HTTP" selector="close">close	self terminateCookieAgent.	self disconnect.</body><body package="HTTP" selector="connect">connect	self setHostPort.	self setConnection.	^(self useProxyForCurrentHost and: [ connection isSecure])		ifTrue: [self establishSSLConnectionViaProxy ]		ifFalse: [super connectToHost: hostName port: portNumber timeout: timeout ]</body><body package="HTTP" selector="connectToHost:port:timeout:">connectToHost: aHostName port: aNumber timeout: tmNumber	hostName := aHostName.	portNumber := aNumber.	timeout := tmNumber.	^self connect.</body><body package="HTTP" selector="establishSSLConnectionViaProxy">establishSSLConnectionViaProxy	| originalRequest |	originalRequest := request.	request := HttpRequest connect: request url.	request useProxy: true.	self openSocketStreamForProxy.	self executeWithConnection: self stream.	self readResponse isSuccess		ifTrue: [self connection hostName: originalRequest hostName; startSSL. 				request := originalRequest].	^self connection stream</body><body package="HTTP" selector="openSocketStreamForProxy">openSocketStreamForProxy	self connection 		openSocketStreamFor: hostName		port: (self proxyHost port ifNil: [HttpConnection defaultPortNumber])		timeout: timeout		encoding: self connection defaultEncoding.</body><body package="HTTP" selector="setConnection">setConnection	(self request notNil and: [connection isNil])		ifTrue: [^self streamHandlerClassFor: self request url protocol].	self request isNil ifTrue: [ ^self connection].	(self request notNil and: [connection notNil and: [(connection accepts: self request url ) not]])		ifTrue: 			[self disconnect.			^self streamHandlerClassFor: self request url protocol].</body><body package="HTTP" selector="setHostPort">setHostPort	self useProxyForCurrentHost ifTrue: [		self proxyHost ifNil: [ HttpException  raiseSignal: (#ProxyHostIsNotDefined &lt;&lt; #net &gt;&gt; 'Proxy host is not defined in Settings')].		hostName := self proxyHost name. 		portNumber :=  self proxyHost port ].	hostName ifNil: [ | arr |		arr := self request hostPortToConnect.		hostName := arr first.		portNumber := arr last].</body><body package="HTTP" selector="streamHandlerClassFor:">streamHandlerClassFor: aString	('http' match: aString)		ifTrue: [ ^connection := self netConnectionClass new ].	('https' match: aString)		ifFalse: 			[^HttpException  raiseSignal:  ((#UnsupportedProtocol1s &lt;&lt; #net &gt;&gt; 'Unsupported protocol: &lt;1s&gt;')			expandMacrosWith: aString)].	#{Net.HttpsConnection} valueOrDo: [URI tryToLoad: 'HTTPS'].	^self useSecureConnection</body><body package="HTTP" selector="useProxyForCurrentHost">useProxyForCurrentHost	^self useProxy and: [	(self proxyExceptions anySatisfy: [ :addr | addr match: self request hostName ]) not ]</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>authorization</category><body package="HTTP" selector="acceptAuthInfoFrom:">acceptAuthInfoFrom: aHttpResponse	self authPolicy acceptAuthInfoFrom:  aHttpResponse</body><body package="HTTP" selector="authPolicy">authPolicy	^authPolicy ifNil: [ authPolicy := AuthenticationPolicy new ]</body><body package="HTTP" selector="authPolicy:">authPolicy: aHttpAuthPolicy	authPolicy := aHttpAuthPolicy</body><body package="HTTP" selector="proxyAuthPolicy">proxyAuthPolicy	^proxyAuthPolicy ifNil: [ proxyAuthPolicy := ProxyAuthenticationPolicy new ]</body><body package="HTTP" selector="proxyPassword">proxyPassword	^self proxyUser notNil		ifTrue: [ self proxyUser password]		ifFalse: [nil]</body><body package="HTTP" selector="proxyUser">proxyUser	^self proxyHost notNil		ifTrue: [ self proxyHost netUser]		ifFalse: [nil]</body><body package="HTTP" selector="proxyUser:">proxyUser: aNetUser	self proxyAuthPolicy user: aNetUser.	self proxyHost user: aNetUser</body><body package="HTTP" selector="proxyUsername">proxyUsername		^self proxyUser notNil		ifTrue: [ self proxyUser username]		ifFalse: [nil]</body><body package="HTTP" selector="realm:">realm: rString	self authPolicy realm: rString</body><body package="HTTP" selector="useBasicAuth">useBasicAuth	self authPolicy useBasicAuth.	self useProxy ifTrue: [self proxyAuthPolicy username: self proxyUsername password: self proxyPassword]</body><body package="HTTP" selector="useNTLMAuth">useNTLMAuth	self authPolicy useNTLMAuth.	self useProxy ifTrue: [self proxyAuthPolicy username: self proxyUsername password: self proxyPassword]</body><body package="HTTP" selector="user">user	^self authPolicy user</body><body package="HTTP" selector="user:">user: aNetUser	self authPolicy user: aNetUser</body><body package="HTTP" selector="username:password:">username: unString password: pString	self authPolicy username: unString password: pString</body><body package="HTTP" selector="username:password:realm:">username: aString password: pString realm: rString	self authPolicy username: aString password: pString realm: rString</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>accessing</category><body package="HTTP" selector="hostName">hostName	^hostName</body><body package="HTTP" selector="hostName:">hostName: aString	hostName := aString</body><body package="HTTP" selector="logAsPrintString">logAsPrintString	^self writingOptions logAsPrintString</body><body package="HTTP" selector="logAsPrintString:">logAsPrintString: aBoolean	self writingOptions logAsPrintString: aBoolean</body><body package="HTTP" selector="portNumber">portNumber	^portNumber</body><body package="HTTP" selector="portNumber:">portNumber: aNumber	portNumber := aNumber</body><body package="HTTP" selector="proxyExceptions">proxyExceptions	^self class proxyExceptions</body><body package="HTTP" selector="proxyHost">proxyHost	proxyHost ifNil: [ proxyHost := self class proxyHost].	^proxyHost</body><body package="HTTP" selector="proxyHost:">proxyHost: aHostSpec	proxyHost := aHostSpec.	self proxyAuthPolicy user: aHostSpec user</body><body package="HTTP" selector="proxyHostName">proxyHostName	^self proxyHost notNil		ifTrue: [ self proxyHost  name]		ifFalse: [ nil ]</body><body package="HTTP" selector="proxyHostPort">proxyHostPort	^(self proxyHost isNil or: [self proxyHost port isNil ]) 		ifTrue: [ nil ]		ifFalse: [ self proxyHost port ]</body><body package="HTTP" selector="readingOptions">readingOptions	^readingOptions ifNil: [readingOptions := self class defaultReadingOptionsType new]</body><body package="HTTP" selector="readingOptions:">readingOptions: anHttpReadingOptions	readingOptions := anHttpReadingOptions</body><body package="HTTP" selector="redirectRequest">redirectRequest	^Settings httpRedirectRequest</body><body package="HTTP" selector="request">request	^request</body><body package="HTTP" selector="request:">request: anHttpRequst	request := anHttpRequst</body><body package="HTTP" selector="shouldChunk">shouldChunk	^self writingOptions shouldChunk</body><body package="HTTP" selector="shouldChunk:">shouldChunk: aBoolean	self writingOptions shouldChunk: aBoolean</body><body package="HTTP" selector="timeout">timeout	^timeout</body><body package="HTTP" selector="timeout:">timeout: numberOfMilliseconds	timeout := numberOfMilliseconds</body><body package="HTTP" selector="useProxy">useProxy	^useProxy ifNil: [ useProxy := self class useProxy]</body><body package="HTTP" selector="useProxy:">useProxy: aBoolean	useProxy := aBoolean.</body><body package="HTTP" selector="writingOptions">writingOptions	^writingOptions ifNil: [ writingOptions := self class defaultWritingOptionsType new]</body><body package="HTTP" selector="writingOptions:">writingOptions: anHttpWritingOptions	writingOptions := anHttpWritingOptions</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>exception processing</category><body package="HTTP" selector="handleResponseException:">handleResponseException: ex	| selector response |	^(response := ex parameter ) notNil		ifTrue: 			[ selector := (('process', response code ), ':') asSymbol .			^(self respondsTo: selector)				ifTrue: [self perform: selector with: ex ]				ifFalse: [nil]]		ifFalse: [nil]</body><body package="HTTP" selector="policy:acceptChallengeFrom:">policy: aAuthPolicy acceptChallengeFrom: exception 	exception parameter setCookie ifNotNil: [self registerCookiesFromResponse: exception parameter].	^(aAuthPolicy acceptChallenge: exception parameter request: self request )		ifTrue: [aAuthPolicy addAuthorizationTo: self request.				self addCookieTo: self request.				self isConnected ifFalse: [ self connect ].				self execute: self  request withConnection: self stream.				self readResponse]		ifFalse: [nil]</body><body package="HTTP" selector="process100:">process100: ex	^ex retry</body><body package="HTTP" selector="process301:">process301: ex	| newUrl |	self redirectRequest ifFalse: [^nil].	ex parameter setCookie ifNotNil: [self registerCookiesFromResponse: ex parameter].	(#('GET' 'HEAD') includes: self request method )		ifFalse: [^nil].	newUrl := self request url resolvePath: ex location.	^self request url = newUrl 		ifTrue: [ ex parameter ]		ifFalse: 			[( hostName ~= newUrl host 				or: [portNumber ~= newUrl port ])				ifTrue: 					[ hostName := newUrl host.					portNumber := newUrl port.					self disconnect].			self request url: newUrl.			self authPolicy setNotAuthorizedState.			self executeAndGetResponse]</body><body package="HTTP" selector="process302:">process302: ex	^self process301: ex</body><body package="HTTP" selector="process401:">process401: exception	"Authorization required"	^self policy: self authPolicy acceptChallengeFrom: exception</body><body package="HTTP" selector="process407:">process407: exception	"Proxy Authentication required"	exception parameter hasConnectionClose ifTrue: [self close; openSocketStreamForProxy ].	^self policy: self proxyAuthPolicy acceptChallengeFrom: exception</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>response</category><body package="HTTP" selector="readResponse">readResponse	^self readFrom: self responseStream</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>execute request</category><body package="HTTP" selector="executeAndGetResponse">executeAndGetResponse" Connect, send request, parse response and answer instance of HttpResponse class "	self request isNil		ifTrue: [^nil]		ifFalse: [ self request useProxy: self useProxy ].	self isConnected ifFalse: [ self connect ].	self executeWithConnection: self stream.	^self readResponse</body><body package="HTTP" selector="executeRequest:">executeRequest: aRequest	request := aRequest.	self isConnected ifFalse: [ self connect ].	^self executeWithConnection: self stream</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>initialize-release</category><body package="HTTP" selector="readEntityFrom:">readEntityFrom: stream	^self newBuilder readFrom: stream.</body><body package="HTTP" selector="readFrom:">readFrom: stream	^self 		readFrom: stream 		onError:  [ :ex | (HttpStatusLineError handles: ex)  ifTrue: [ self  close ]]</body><body package="HTTP" selector="readFrom:onError:">readFrom: stream onError: aBlock	| message |	^[ message := self  readEntityFrom: stream.	message log.	message isResponse 		ifTrue: 			["Keep the connection always alive  for 1.0 proxy and CONNECT method"			(message isHttp10 and: [request method = 'CONNECT' ])				ifFalse: [ (message isConnectionTransient or: [self request isConnectionTransient]) 							ifTrue: [ self close ]]. 			HttpException handleResponse: message.			"response is success "			self registerCookiesFromResponse: message.			self acceptAuthInfoFrom: message. ]		ifFalse: [ request := message ].	message	] on: HttpException	 do:  [ :ex | 		aBlock value: ex. 		(message := self handleResponseException: ex ) isNil 			ifTrue: [ ex pass]			ifFalse: [ message ]].</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>private</category><body package="HTTP" selector="execute:withConnection:">execute: aRequest withConnection: aConnectionStream	self log: aRequest.	self newWriter writeMessage: aRequest on: aConnectionStream.	aConnectionStream flush.	^aConnectionStream</body><body package="HTTP" selector="executeWithConnection:">executeWithConnection: aConnectionStream	self prepareRequestToSend.	^self execute: self  request withConnection: aConnectionStream</body><body package="HTTP" selector="log:">log: message	self log: 		[self logAsPrintString			ifTrue: [message printString]			ifFalse: [ | s |					s := ((ByteArray new: 1024) withEncoding: #ISO8859_1) writeStream lineEndCRLF. 					message newWriter						useGZipTransfer: self useGZipTransfer;						chunkSize: self chunkSize;						writeMessage: message on: s.					s encodedContents asString]		]		level: #HTTPClientRequest.</body><body package="HTTP" selector="prepareRequestToSend">prepareRequestToSend	self useProxyForCurrentHost 		ifTrue: [ 	self proxyAuthPolicy user:  self proxyUser.				self request useProxy: self useProxy.				 self proxyAuthPolicy addAuthorizationTo: self request  ].	self authPolicy addAuthorizationTo: self request.	self addCookieTo: self request.</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>printing options</category><body package="HTTP" selector="chunkSize">chunkSize	^self writingOptions chunkSize</body><body package="HTTP" selector="chunkSize:">chunkSize: aNumber	self writingOptions chunkSize: aNumber</body><body package="HTTP" selector="newPrinter">newPrinter	^self writingOptions  newPrinter</body><body package="HTTP" selector="newWriter">newWriter	^self writingOptions  newWriter</body><body package="HTTP" selector="useGZipTransfer">useGZipTransfer	^self writingOptions useGZipTransfer</body><body package="HTTP" selector="useGZipTransfer:">useGZipTransfer: aBoolean	self writingOptions useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>parsing options</category><body package="HTTP" selector="decodeContents">decodeContents	^self readingOptions decodeContents</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self readingOptions decodeContents: aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^self readingOptions decompressContents</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self readingOptions decompressContents: aBoolean</body><body package="HTTP" selector="newBuilder">newBuilder	^self readingOptions newBuilder 			headerOnly: self request headerOnly; 			yourself</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>deprecation</category><body package="HTTP" selector="addAuthorizationTo:">addAuthorizationTo: aRequest	self deprecated: #(#version '7.7' #sunset '8.0' ).	self authPolicy addAuthorizationTo: aRequest</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>debugging</category><body package="HTTP" selector="debugLabelsAndValues">debugLabelsAndValues	^OrderedCollection new		add: ((#HTTPClientRequest &lt;&lt; #net &gt;&gt; 'HTTP Client Request')-&gt;#HTTPClientRequest);		add: (#HTTPServerHeader &lt;&lt; #net &gt;&gt; 'HTTP Server Header')-&gt;#HTTPServerHeader;		add: (#HTTPServerMessage &lt;&lt; #net &gt;&gt; 'HTTP Server Message')-&gt;#HTTPServerMessage;		yourself</body><body package="HTTP" selector="menuItemName">menuItemName	^(#HTTPClientMessages &lt;&lt; #net &gt;&gt; 'HTTP Client Messages')</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>cookie management</category><body package="HTTP" selector="enableCookieProcessing">enableCookieProcessing	^enableCookieProcessing isNil		ifTrue: [self defaultEnableCookieProcessing]		ifFalse: [enableCookieProcessing]</body><body package="HTTP" selector="enableCookieProcessing:">enableCookieProcessing: aBoolean	enableCookieProcessing := aBoolean</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>accessing</category><body package="HTTP" selector="keepAlive">keepAlive	^Settings httpKeepAlive</body><body package="HTTP" selector="proxyExceptions">proxyExceptions	^Settings httpProxyExceptions</body><body package="HTTP" selector="proxyHost">proxyHost	^Settings httpProxyHost</body><body package="HTTP" selector="redirectRequest">redirectRequest	^Settings httpRedirectRequest</body><body package="HTTP" selector="useProxy">useProxy	^Settings httpUseProxy</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>instance creation</category><body package="HTTP" selector="readFrom:">readFrom: aStream	^self new		readFrom: aStream</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>class initialization</category><body package="HTTP" selector="initialize">initialize	"self initialize."	self registerToDebug.</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>default values</category><body package="HTTP" selector="defaultEnableCookieProcessing">defaultEnableCookieProcessing	^true</body><body package="HTTP" selector="defaultNetConnectionValue">defaultNetConnectionValue	^HttpConnection</body><body package="HTTP" selector="defaultReadingOptionsType">defaultReadingOptionsType	^HttpBuildHandler defaultOptionsType</body><body package="HTTP" selector="defaultWritingOptionsType">defaultWritingOptionsType	^HttpWriteHandler defaultOptionsType</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>testing</category><body package="HTTP" selector="authenticateNTLMType2">authenticateNTLMType2	| f |	(f := self proxyAuthenticate detect: [:hdr | hdr isType2 ] ifNone: [nil]) isNil		ifTrue: [ f := self wwwAuthenticate detect: [:hdr | hdr isType2 ] ifNone: [nil]].	^f</body><body package="HTTP" selector="canBeNTLMAuthorized">canBeNTLMAuthorized	^(self proxyAuthenticate anySatisfy: [:hdr | hdr canBeNTLMAuthorized ])		or: [self wwwAuthenticate anySatisfy: [:hdr | hdr canBeNTLMAuthorized ]]</body><body package="HTTP" selector="failed">failed	^self isSuccess not</body><body package="HTTP" selector="headerOnly">headerOnly	^self statusLine headerOnly</body><body package="HTTP" selector="isClientError">isClientError	"Informational- Request received, continuing the process"	^self statusLine isClientError</body><body package="HTTP" selector="isError">isError	"Informational- Request received, continuing the process"	^self statusLine isError</body><body package="HTTP" selector="isHttp10">isHttp10	^self statusLine isHttp10</body><body package="HTTP" selector="isInformationalReply">isInformationalReply	"Informational - Request received, continuing the process"	^self statusLine isInformationalReply</body><body package="HTTP" selector="isMoved">isMoved	"Moved permanently/temporarily"		^self statusLine isMoved</body><body package="HTTP" selector="isNTLMType2">isNTLMType2	^(self proxyAuthenticate anySatisfy: [:hdr | hdr isType2 ])		or: [self wwwAuthenticate anySatisfy: [:hdr | hdr isType2 ]]</body><body package="HTTP" selector="isProxyAuthorizedRequired">isProxyAuthorizedRequired	"Proxy Authorized Required"	^self statusLine isProxyAuthorizedRequired</body><body package="HTTP" selector="isRedirectionReply">isRedirectionReply	"Informational- Request received, continuing the process"	^self statusLine isRedirectionReply</body><body package="HTTP" selector="isResponse">isResponse	^true</body><body package="HTTP" selector="isServerError">isServerError	"Informational- Request received, continuing the process"	^self statusLine isServerError</body><body package="HTTP" selector="isSuccess">isSuccess	^self statusLine isSuccess</body><body package="HTTP" selector="isUnauthorized">isUnauthorized	"unauthorized"	^self statusLine isUnauthorized</body><body package="HTTP" selector="isValid">isValid	^self statusLine isValid</body><body package="HTTP" selector="successful">successful	^self isSuccess</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>accessing</category><body package="HTTP" selector="basicProxyAuthenticationHeader">basicProxyAuthenticationHeader	^(self fieldsAt: 'proxy-authenticate') detect: [:hdr | hdr scheme = 'basic'] ifNone: [nil]</body><body package="HTTP" selector="basicWwwAuthenticationHeader">basicWwwAuthenticationHeader	^(self fieldsAt: 'www-authenticate') detect: [:hdr | hdr scheme = 'basic'] ifNone: [nil]</body><body package="HTTP" selector="code">code	^self statusLine code</body><body package="HTTP" selector="descriptionString">descriptionString	^self printStatusLineMessage</body><body package="HTTP" selector="messageLine">messageLine	^self statusLine</body><body package="HTTP" selector="messageLine:">messageLine: aHttpResponseStatusLine	self statusLine: aHttpResponseStatusLine</body><body package="HTTP" selector="protocol">protocol	^self statusLine protocol</body><body package="HTTP" selector="statusLine">statusLine	^statusLine</body><body package="HTTP" selector="statusLine:">statusLine: aHttpResponseStatusLine	statusLine := aHttpResponseStatusLine</body><body package="HTTP" selector="version">version	^self statusLine version</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>accessing fields</category><body package="HTTP" selector="acceptRanges">acceptRanges	^self fieldValueAt: 'accept-ranges'</body><body package="HTTP" selector="acceptRanges:">acceptRanges: aStringOrCollection	(self getFieldAt: 'accept-ranges') value: aStringOrCollection</body><body package="HTTP" selector="age">age	^self fieldValueAt: 'age'</body><body package="HTTP" selector="age:">age: aString	(self getFieldAt: 'age') value: aString</body><body package="HTTP" selector="location">location	^self fieldValueAt: 'location'</body><body package="HTTP" selector="location:">location: aString	(self getFieldAt: 'location') value: aString</body><body package="HTTP" selector="proxyAuthenticate">proxyAuthenticate	^self fieldsAt: 'proxy-authenticate'</body><body package="HTTP" selector="proxyAuthenticate:">proxyAuthenticate: aStringOrAuthenticateChallengeField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		aStringOrAuthenticateChallengeField isString		ifTrue: [ (self getFieldAt: 'proxy-authenticate') 				addScheme: aStringOrAuthenticateChallengeField]		ifFalse:			[ self removeFieldAt: 'proxy-authenticate'.			self addField: aStringOrAuthenticateChallengeField]</body><body package="HTTP" selector="public">public	^self fieldValueAt: 'public'</body><body package="HTTP" selector="public:">public: aValue	(self getFieldAt:  'public') value: aValue</body><body package="HTTP" selector="retryAfter">retryAfter	^self fieldValueAt: 'retry-after'</body><body package="HTTP" selector="retryAfter:">retryAfter: aTimestampOrStringOrArray	(self getFieldAt:  'retry-after') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="wwwAuthenticate">wwwAuthenticate"Returns all AuthenticateChallengeField"	^self fieldsAt:  'www-authenticate'</body><body package="HTTP" selector="wwwAuthenticate:">wwwAuthenticate: aStringOrAuthenticateChallengeField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		aStringOrAuthenticateChallengeField isString		ifTrue: [ (self getFieldAt: 'authenticate') 				addScheme: aStringOrAuthenticateChallengeField]		ifFalse:			[ self removeFieldAt: 'authenticate'.			self addField: aStringOrAuthenticateChallengeField]</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>private</category><body package="HTTP" selector="log">log	HttpProtocolInterpreter log: 			[| s |			s := (String new: 128) writeStream.			self printHeaderOn: s.			s contents] 		level: #HTTPServerHeader.	HttpProtocolInterpreter log: [self printString]  level: #HTTPServerMessage.</body><body package="HTTP" selector="statusCode:">statusCode: aString	statusLine := HttpResponseStatusLine code: aString</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>printing</category><body package="HTTP" selector="printHeaderOn:">printHeaderOn: aStream	self newPrinter printMessageElement: self statusLine on: aStream.		self newPrinter printMessageElement: self header on: aStream.</body><body package="HTTP" selector="printStatusLineMessage">printStatusLineMessage	| stream |	stream := (String new: 32) writeStream.	self statusLine printMessageOn: stream.	^stream contents</body></methods><methods><class-id>Net.HttpResponse class</class-id> <category>instance creation</category><body package="HTTP" selector="code:">code: aString	^self new		statusCode: aString;		yourself</body></methods><methods><class-id>Net.CookieValue</class-id> <category>initialize-release</category><body package="HTTP" selector="name:value:">name: aString value: vString	self setValueName: aString value: vString.</body></methods><methods><class-id>Net.CookieValue</class-id> <category>accessing</category><body package="HTTP" selector="name">name	^self value key</body><body package="HTTP" selector="nameValue">nameValue	^self value value</body></methods><methods><class-id>Net.CookieValue</class-id> <category>parsing</category><body package="HTTP" selector="addParameterNamed:value:">addParameterNamed: valString value: parString	| nm |	nm := valString first = $$ 		ifTrue: [valString copyFrom: 2 to: valString size ]		ifFalse: [ valString].	super addParameterNamed: nm value: parString</body><body package="HTTP" selector="parseParameters:">parseParameters: scanner	| paramName pos nm |	pos := scanner position.	scanner atEnd ifFalse: [		scanner 			tokenizeList: [				(paramName := scanner nextToken) notNil ifTrue: [						nm := paramName first = $$ 							ifTrue: [paramName copyFrom: 2 to: paramName size ]							ifFalse: [ paramName].						"if there is no $ it could be next Netscape value "						 paramName first = $$ 							ifFalse: [setSelectors at: nm asLowercase asSymbol ifAbsent: [scanner position: pos. ^self]].						scanner skipWhiteSpace.						(self validateNextToken: scanner for: paramName) ifFalse: [							InvalidHeaderField signalWith: scanner contents. 							^self ].  						self 							addParameterNamed: paramName asLowercase 							value: (self parseParamValueFrom: scanner). ]]			separatedBy: [				pos := scanner position. 				scanner token == self parametersSeparator					or: [scanner token == $,] ]]</body></methods><methods><class-id>Net.CookieValue</class-id> <category>composing</category><body package="HTTP" selector="writeParameter:on:encoding:">writeParameter: assoc on: aStream encoding: aString	self class scannerType printWord: '$', assoc key on: aStream.	self writeParameter: assoc key value: assoc value on: aStream.</body></methods><methods><class-id>Net.CookieField</class-id> <category>accessing</category><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^CookieValue</body><body package="HTTP" selector="version">version	^version</body><body package="HTTP" selector="version:">version: aNumber	version := aNumber</body></methods><methods><class-id>Net.CookieField</class-id> <category>private</category><body package="HTTP" selector="doPrivateParse:">doPrivateParse: scanner	| str  |	str := scanner scanUntil: 			[ scanner hereChar == self valueSeparator 				or: [ scanner hereChar == self groupSeparator] ].	^self tokenize: (self scannerOn: str readStream).</body></methods><methods><class-id>Net.CookieField</class-id> <category>composing</category><body package="HTTP" selector="writeValueOn:encoding:">writeValueOn: aStream encoding: aString	version notNil		ifTrue: 			[aStream nextPutAll: '$version=', self version printString.			aStream nextPut: self valueSeparator].	self value notNil		ifTrue: 			[version notNil ifTrue: [ aStream crtab].			self value  				do: [ :param |  param writeOn: aStream]				separatedBy: 					[aStream nextPut: self groupSeparator.					version notNil ifTrue: [ aStream crtab ]]]		ifFalse: [ aStream nextPutAll: '' ].	aStream cr.</body></methods><methods><class-id>Net.CookieField</class-id> <category>parsing</category><body package="HTTP" selector="doParse:">doParse: scanner	| tokens position list valx |	position := scanner position.	tokens := self doPrivateParse: scanner.	(tokens first asLowercase = '$version' and: [ (tokens at: 2) = $= ])		ifTrue: 			["RFC2965 style: the first attribute has to be $version "			tokens last do: [ :ch | 				ch isDigit ifFalse: [ InvalidHeaderField 										raiseRequestWith: source contents										errorString: (#WrongCookieFieldVersion &lt;&lt; #net &gt;&gt; 'Wrong cookie field version').									version := tokens last.									^self ]].			version := tokens last asNumber]		ifFalse: 			["Netscape"  			scanner position: position.			version := nil ].	list := OrderedCollection new: 5.	[scanner atEnd ]		whileFalse: 			[valx := self valueWithParamsClass newWithSeparators: self separators.			valx readFrom: scanner.			list add: valx ].	^list</body></methods><methods><class-id>Net.CookieField</class-id> <category>printing</category><body package="HTTP" selector="printValueOn:">printValueOn: aStream 	[self writeValueOn: aStream encoding: nil ] on: Error do: [ :ex |  ]</body></methods><methods><class-id>Net.CookieField class</class-id> <category>instance creation</category><body package="HTTP" selector="new">new	^self newWithVersion: self defaultVersion</body><body package="HTTP" selector="newNetscape">newNetscape	^super new initialize</body><body package="HTTP" selector="newRfc">newRfc	^self new</body><body package="HTTP" selector="newWithVersion:">newWithVersion: aNumber	^super new		initialize;		version: aNumber;		yourself</body></methods><methods><class-id>Net.CookieField class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($; $; $;  )</body></methods><methods><class-id>Net.CookieField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('cookie' )</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>status</category><body package="HTTP" selector="finish">finish	"Write any unwritten information."	self finishBuffer.	self finishOutput.	destinationStream finish</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>private-auth</category><body package="HTTP" selector="md5Hash">md5Hash	^self</body></methods><methods><class-id>Core.String</class-id> <category>private-auth</category><body package="HTTP" selector="md5Hash">md5Hash	"answer a hexadecimal encoded hash"	| stream |	stream := WriteStream on: String new.	self asByteArray md5Value printOn: stream base: 16.	^stream contents</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>action callbacks</category><body package="HTTP" selector="startRequestLine:with:">startRequestLine: aRequestLine with: aHttpEntity 	aHttpEntity isExtended 		ifTrue: [aRequestLine prefix: 'm-']		ifFalse: [aRequestLine prefix: nil].	self printLine: aRequestLine printString.	aHttpEntity hasHostField 		ifFalse: [aHttpEntity host: aRequestLine hostAndPort]</body><body package="HTTP" selector="startResponseStatusLine:with:">startResponseStatusLine: aResponseStatusLine with: aHttpEntity	self printLine: aResponseStatusLine printString.</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>instance creation</category><body package="HTTP" selector="http:user:">http: host user: user	^self protocol: #HTTP host:  host user: user</body><body package="HTTP" selector="http:username:password:">http: host username: username password: password	^self protocol: #HTTP host: host username: username password: password</body></methods><initialize><class-id>Net.HttpClient</class-id></initialize><initialize><class-id>Net.HttpProtocolInterpreter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MimeEntity</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header headerCharset readingOptions writingOptions </inst-vars><class-inst-vars>defaultTextCharset defaultTextType </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>StructuredHeaderField</name><environment>Net</environment><super>Net.HeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>CollectionField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>encoding </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>HeaderFieldValue</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>ValueWithParams</name><environment>Net</environment><super>Net.HeaderFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>params </inst-vars><class-inst-vars>defaultParameterValueEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>MessageStream</name><environment>Net</environment><super>Core.Stream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>stream position readLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>TwoByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>DeflateStream</name><environment>OS.ZLib</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputBuffer interface destinationStream compressionLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><class><name>URLwithAuthority</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>MimeParser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>MimeParserHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream lineEndConvention initialEntity parser binaryMode options </inst-vars><class-inst-vars>saveAttachmentsAsFiles defaultAttachmentDirectory </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimeOutputHandler</name><environment>Net</environment><super>Net.MimeDispatcherHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streams fieldStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimeWriteHandler</name><environment>Net</environment><super>Net.MimeOutputHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalStream binaryMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MimeDispatcher</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetNotification</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>InvalidHeaderField</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account savePassword mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>ValueWithParametersField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MimeReadingOptions</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldFactory messageHeaderClass scannerType saveAttachmentsAsFiles headerOnly acceptNonAsciiCharacters attachmentDirectory builderClass removeContentTransferEncoding </inst-vars><class-inst-vars>saveAttachmentsAsFiles defaultAttachmentDirectory removeContentTransferEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimeWritingOptions</name><environment>Net</environment><super>Net.MimeDispatcherWritingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preferFieldSource applyTransferEncoding </inst-vars><class-inst-vars>applyTransferEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimePrintHandler</name><environment>Net</environment><super>Net.MimeOutputHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indentation indentLines </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class></st-source>