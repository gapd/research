<?xml version="1.0"?><st-source><!-- Name: POP3Notice: Copyright © 2010-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: POP3Support provides support for communication with a POP3 Server to retreive internet mail messages.DbIdentifier: bear73DbTrace: 302820DevelopmentPrerequisites: #(#(#any 'Mail' '') #(#package 'MIME' '') #(#package 'NetClientBase' ''))PackageName: POP3Parcel: #('POP3')ParcelName: POP3PrerequisiteParcels: #(#('Mail' '') #('MIME' '') #('NetClientBase' ''))PrintStringCache: (7.8 - 1002,mkobetic)Version: 7.8 - 1002Date: 11:58:38 AM December 21, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (dec10.3) of December 21, 2010 on December 21, 2010 at 11:58:38 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>POP3State</name><environment>Net</environment><super>Net.NetClientState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3State</class-id><body>Superclass for all POP3 states. Publishes command signatures, implements them all as invalid for the state</body></comment><class><name>POP3UpdateState</name><environment>Net</environment><super>Net.POP3State</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3UpdateState</class-id><body>POP3UpdateState implements the POP3 client Update state. The client issues the QUIT command and the POP3 session enters the UPDATE state</body></comment><class><name>POP3ProtocolInterpreter</name><environment>Net</environment><super>Net.NetProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>POP3</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3ProtocolInterpreter</class-id><body>POP3ProtocolInterpreter manages POP3 server connection and provides interface for sending POP3 commands and handling POP3 responses. </body></comment><class><name>POP3Mailbox</name><environment>Net</environment><super>Net.Mailbox</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3Mailbox</class-id><body>POP3Mailbox provides POP3 mail box support</body></comment><class><name>Pop3Mailbox</name><environment>Net</environment><super>Net.POP3Mailbox</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3Mailbox</class-id><body>Pop3Mailbox is obsolete. Use POP3Mailbox class</body></comment><class><name>POP3TransactionState</name><environment>Net</environment><super>Net.POP3State</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3TransactionState</class-id><body>Transaction state is when the user has logged in and authorized himself to POP3 server. Actual message retrieval/manipulations are valid now</body></comment><class><name>POP3NotConnectedState</name><environment>Net</environment><super>Net.POP3State</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3NotConnectedState</class-id><body>POP3NotConnectedState is set when the client is not connected to a server</body></comment><class><name>POP3Status</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages octets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3Status</class-id><body>POP3 command status. In order to simplify parsing, all POP3 servers are required to use a certain format for scan listings. A can listing consists of the message-number of the message, followed by a single space and the exact size of the message in octets. Instance Variables:	messages	&lt;Number&gt;  message number	octets	&lt;Number&gt;  the exact size of the message in octets</body></comment><class><name>FailedToDeleteId</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.FailedToDeleteId</class-id><body>FailedToDeleteId is raise if the client was not able to delete id's</body></comment><class><name>POP3Connection</name><environment>Net</environment><super>Net.NetConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-SMTP-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3Connection</class-id><body>Pop3Connection is the POP3 connection stream wrapper</body></comment><class><name>POP3Client</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverResponse </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3Client</class-id><body>The POP3Client implements RFC 1939. Because most commands are only valid in certain states, the state variable holds and instance of (subclass of) POP3State. All commands are delegated to the state which either rejects them as inappropriate in the given state, or calls client back to send the command to a POP3 server.Instance Variables:	serverResponse	&lt;String&gt;  server responseShared Variables:	LastServer	&lt;type&gt;  Last server -- if we don't care	TerminationOctet	&lt;Character&gt;  comment	TerminationSequence	&lt;String&gt;  comment</body></comment><class><name>Pop3Client</name><environment>Net</environment><super>Net.POP3Client</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3Client</class-id><body>Pop3Client is obsolete. Use POP3Client class</body></comment><class><name>POP3AuthorizationState</name><environment>Net</environment><super>Net.POP3State</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3AuthorizationState</class-id><body>Pop3 Authorization state is used when the user has to be authorized to Pop3 server. Only autorization commands are valid</body></comment><class><name>POP3StateError</name><environment>Net</environment><super>Net.NetClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.POP3StateError</class-id><body>Signal to be raised for commands taht are invalid in the current state</body></comment><shared-variable><name>MinTransferRate</name><environment>Net.POP3Mailbox</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>Core.Dictionary new</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>MaxTransferRate</name><environment>Net.POP3Mailbox</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>Core.Dictionary new</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>LastServer</name><environment>Net.POP3Mailbox</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>TerminationOctet</name><environment>Net.POP3Client</environment><private>false</private><constant>true</constant><category>local globals</category><initializer>Core.Character value: 46</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>TerminationSequence</name><environment>Net.POP3Client</environment><private>false</private><constant>true</constant><category>local globals</category><initializer>Core.String with: (Core.Character value: 46) with: Core.Character cr with: Core.Character lf</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>LastServer</name><environment>Net.POP3Client</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>POP3</package></attributes></shared-variable><methods><class-id>Net.POP3State</class-id> <category>commands</category><body package="POP3" selector="apopName:digest:for:">apopName: aStringName digest: aStringDigest for: aClient	self signalError</body><body package="POP3" selector="delete:for:">delete: message for: aClient	self signalError</body><body package="POP3" selector="deleteMessageIds:for:">deleteMessageIds: aSequenceOfUniqueIDs for: aClient	self signalError</body><body package="POP3" selector="list:for:">list: number for: aClient 	self signalError</body><body package="POP3" selector="listMessage:for:">listMessage: number for: aClient 	self signalError</body><body package="POP3" selector="noop:">noop: aClient	self signalError</body><body package="POP3" selector="pass:">pass: aClient 	self signalError</body><body package="POP3" selector="quit:">quit: aClient 	self signalError</body><body package="POP3" selector="reset:">reset: aClient	self signalError</body><body package="POP3" selector="retrieveMessage:for:">retrieveMessage: number for: aClient 	self signalError</body><body package="POP3" selector="retrieveMessageID:for:">retrieveMessageID: number for: aClient	self signalError</body><body package="POP3" selector="retrieveMessageLines:for:">retrieveMessageLines: number for: aClient 	self signalError</body><body package="POP3" selector="stat:">stat: aClient 	self signalError</body><body package="POP3" selector="top:of:for:">top: lines of: msg for: aClient	self signalError</body><body package="POP3" selector="user:">user: aClient 	self signalError</body></methods><methods><class-id>Net.POP3State</class-id> <category>accessing</category><body package="POP3" selector="stateErrorClass">stateErrorClass	^POP3StateError</body></methods><methods><class-id>Net.POP3ProtocolInterpreter</class-id> <category>public</category><body package="POP3" selector="executeCommand:">executeCommand: aString	self sendCommand: aString.	^self waitForResponses.</body><body package="POP3" selector="sendCommand:">sendCommand: aString 	self isConnected ifFalse:		[^NetClientError signalWith: #POP3Client message: (#Pop3ClientConnectionIsClosed &lt;&lt; #net &gt;&gt;'Pop3Client: Connection is closed') asString.].		self log: ['C: &lt;1s&gt; ' expandMacrosWith: aString ] level: #POP3Client. 	self stream 		nextPutAll: aString;		nextPutAll: CRLF;		flush.</body></methods><methods><class-id>Net.POP3ProtocolInterpreter</class-id> <category>responses</category><body package="POP3" selector="getNextLine">getNextLine	| line |	line := self connection getResponseStream throughAll: CRLF. 	self log: ['S: &lt;1s&gt; ' expandMacrosWith: line ] level: #POP3Server.	^line</body><body package="POP3" selector="waitForResponses">waitForResponses	| result  |	result := self connection getResponseStream throughAll: CRLF.	self log: ['S: &lt;1s&gt; ' expandMacrosWith: result ] level: #POP3Server.	^result</body></methods><methods><class-id>Net.POP3ProtocolInterpreter class</class-id> <category>debugging</category><body package="POP3" selector="debugLabelsAndValues">debugLabelsAndValues	^(OrderedCollection new)		add: ((#Pop3ClientMessages &lt;&lt; #net &gt;&gt; 'Pop3 Client Messages')-&gt;#POP3Client);		add: (#Pop3ServerMessages &lt;&lt; #net &gt;&gt; 'Pop3 Server Messages')-&gt;#POP3Server;		yourself</body><body package="POP3" selector="menuItemName">menuItemName	^(#POP3ClientMessages &lt;&lt; #net &gt;&gt; 'POP3 Client Messages') asString</body></methods><methods><class-id>Net.POP3ProtocolInterpreter class</class-id> <category>class initialization</category><body package="POP3" selector="initialize">initialize	"self initialize."	self registerToDebug.</body></methods><methods><class-id>Net.POP3ProtocolInterpreter class</class-id> <category>default values</category><body package="POP3" selector="defaultNetConnectionValue">defaultNetConnectionValue	^POP3Connection</body></methods><methods><class-id>Net.POP3Mailbox</class-id> <category>commands</category><body package="POP3" selector="allHeaders">allHeaders	| messageCount |	^self connectedDo: 		[messageCount := connection status messages.		(1 to: messageCount)			collect: 				[:i | 				MailIncrementNotification raiseSignal.				MimeEntity readHeaderFrom: (connection top: 10 of: i) readStream]]</body><body package="POP3" selector="anyNewMail">anyNewMail	"Any new mail to get?"	^self messageCount &gt; self lastMessage</body><body package="POP3" selector="getMessage:">getMessage: number 	"Get the &lt;number&gt; message from the Pop3server"	^self safelyExecute: 	[self getMessageNumber: number]</body><body package="POP3" selector="messageCount">messageCount	"How many messages are on the server?"		^self safelyExecute:				[connection status messages].</body></methods><methods><class-id>Net.POP3Mailbox</class-id> <category>private</category><body package="POP3" selector="clientSpecies">clientSpecies	^POP3Client</body><body package="POP3" selector="deleteMessageNumbers:">deleteMessageNumbers: aSequenceOfUids 	"Delete all messages which have unique ids in the argument.	 Answer the number of messages remaining on the server."	^self connectedDo: 			[| remaining |			remaining := connection deleteMessageIds: aSequenceOfUids.			self lastMessage: remaining.			remaining]</body><body package="POP3" selector="deliverFrom:to:">deliverFrom: startCount to: messageCount		self log: [(#DownloadingMessages &lt;&lt; #net &gt;&gt; 'Downloading &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: messageCount with: server] level: #IPOP3Download.	messageCount timesRepeat: 		[ | message n milliseconds |		 milliseconds := Time millisecondsToRun: [message := self getMessageNumber: (n := self lastMessage + 1)].		 self lastMessage: n.		 n - startCount \\ 10 = 0 			ifTrue: 				[self log: [(#DownloadedMessages &lt;&lt; #net &gt;&gt; 'Downloaded &lt;1p&gt; messages from &lt;2s&gt;')expandMacrosWith: n - startCount with: server] 					level: #POP3Download].			self deliver: message.			self debug: [self class processTransferRate: milliseconds ofSize: message size fromServer: server] 				level: #POP3TransferRate.			Processor yield "be nice to other mail polling processes" ]</body><body package="POP3" selector="getMessageNumber:">getMessageNumber: number 	"Get the &lt;number&gt; message from a Pop3 server on connection and return the message as a string."	| lines id  stream |	IncrementNotification raiseSignal. 	lines := connection retrieveMessageLines: number.	id := connection retrieveMessageID: number.	stream := (String new: 512) writeStream.	lines do: [ :each |  stream nextPutAll: (each copyFrom: 1 to: ( each size - 1)) ].	^LetterInTransit new		letterText: stream contents;		uid: id;		server: self serverName;		serverType: self serverType;		deliveryAction: [self saveSettings: number];		yourself</body></methods><methods><class-id>Net.POP3Mailbox</class-id> <category>mail delivery</category><body package="POP3" selector="deliverAllMail">deliverAllMail	"Queue up all new messages onto the queue. Clients of this 	method should be aware that the state should be such that there 	is new mail to download."	self safelyExecute:		[|  messageCount |		messageCount := connection status messages.		self deliverFrom: 1 to: messageCount.		self log: [(#DoneDownloaded &lt;&lt; #net &gt;&gt; 'Done; downloaded &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: messageCount with: server]			level: #POP3Download		]</body><body package="POP3" selector="deliverMail">deliverMail	"Queue up a message onto the queue."	| n |	self deliver: (self getMessage: (n := self lastMessage + 1)).	self lastMessage: n.</body><body package="POP3" selector="deliverNewMail">deliverNewMail	"Queue up all new messages onto the queue. Clients of this 	method should be aware that the state should be such that there 	is new mail to download."	self safelyExecute:		[|   startCount messageCount |		messageCount := connection status messages - (startCount := self lastMessage).		self deliverFrom: startCount to: messageCount.		self log: [(#DoneDownloaded &lt;&lt; #net &gt;&gt; 'Done; downloaded &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: (self lastMessage - startCount) with: server]			level: #POP3Download		]</body></methods><methods><class-id>Net.POP3Mailbox</class-id> <category>accessing</category><body package="POP3" selector="logout">logout	connection notNil		ifTrue: 			[connection close.			connection := nil]</body><body package="POP3" selector="serverType">serverType	^'POP3'</body></methods><methods><class-id>Net.POP3Mailbox class</class-id> <category>utilities</category><body package="POP3" selector="processTransferRate:ofSize:fromServer:">processTransferRate: milliseconds ofSize: size fromServer: server 	"self processTransferRate: 32 ofSize: 1836 fromServer: 'sulu.cincom.com' "	| bytesPerSecond kiloBytesPerSecond maxTransferRate minTransferRate |	bytesPerSecond := (size / milliseconds) * 1000.	kiloBytesPerSecond := (bytesPerSecond / 1024) asFloat.	maxTransferRate := (MaxTransferRate at: server ifAbsentPut: [0]) max: kiloBytesPerSecond.	maxTransferRate = kiloBytesPerSecond ifTrue: 		[MaxTransferRate at: server put: kiloBytesPerSecond].	minTransferRate := (MinTransferRate at: server ifAbsentPut: [1024*1024]) min: kiloBytesPerSecond.	minTransferRate = kiloBytesPerSecond ifTrue: 		[MinTransferRate at: server put: kiloBytesPerSecond].	self log: [(#TransferRateOfKbps &lt;&lt; #net &gt;&gt; 'Transfer Rate of &lt;1p&gt; Kbps from &lt;2s&gt;. Max: &lt;3p&gt; Min: &lt;4p&gt;') 					expandMacrosWith: kiloBytesPerSecond					with: server					with: maxTransferRate					with: minTransferRate]		level: #POP3TransferRate.</body><body package="POP3" selector="promptForConnection">promptForConnection	"Pop3Mailbox promptForConnection"	| connection user  host |	user := NetUser request.	user isNil ifTrue: [^self].	host := Dialog 		request: (#PopServerOn &lt;&lt; #net &gt;&gt; 'Pop server on:') 		initialAnswer: (LastServer isNil ifTrue: [(#postofficepacbellnet &lt;&lt; #net &gt;&gt; 'xxxx.com')] ifFalse: [LastServer]) 		onCancel: [^nil].	LastServer := host.	connection := POP3Client host: host.	connection user: user.	^connection</body><body package="POP3" selector="request">request	"Pop3Mailbox request"	| username password  host cancel |	username := (NetUser lastUser isNil					ifTrue: ['']					ifFalse: [NetUser lastUser]) asValue.	password := '' asValue.	host := (LastServer isNil 				ifTrue: [(#postofficepacbellnet &lt;&lt; #net &gt;&gt; 'xxxx.com')] 				ifFalse: [LastServer]) asValue.	cancel := (SimpleDialog initializedFor: nil)				setInitialGap;				addMessage: (#WhatPOP3ServerAndLogin &lt;&lt; #net &gt;&gt; 'What POP3 Server and login?') centered: true;				addGap;				addMessage: (#UsernameC &lt;&lt; #net &gt;&gt; 'Username:') textLine: username boundary: 0.4;				addGap;				addMessage: (#PasswordC &lt;&lt; #net &gt;&gt; 'Password:') textLine: password type: #password boundary: 0.4;				addGap;				addMessage: (#POP3Server &lt;&lt; #net &gt;&gt; 'POP3 Server:') textLine: host boundary: 0.4;				addGap;				addOK: [true];				openDialog;				cancel.	cancel value ifTrue: [^nil].	^self		user:  (NetUser username: username value password: password value)		server: host value</body></methods><methods><class-id>Net.POP3Mailbox class</class-id> <category>debugging</category><body package="POP3" selector="debugLabelsAndValues">debugLabelsAndValues	^OrderedCollection new		add: ((#Pop3MailboxDownloads &lt;&lt; #net &gt;&gt; 'Pop3Mailbox Downloads')-&gt;#POP3Download);		add: ((#Pop3MailboxServerChecking &lt;&lt; #net &gt;&gt; 'Pop3Mailbox Server Checking')-&gt;#POP3Check);		add: ((#Pop3MailboxTransferRate &lt;&lt; #net &gt;&gt; 'Pop3Mailbox Transfer Rate')-&gt;#POP3TransferRate);		yourself</body><body package="POP3" selector="initialize">initialize	self registerToDebug</body><body package="POP3" selector="menuItemName">menuItemName	^(#POP3MailboxMessages &lt;&lt; #net &gt;&gt; 'POP3 Mailbox Messages')</body></methods><methods><class-id>Net.POP3TransactionState</class-id> <category>commands</category><body package="POP3" selector="delete:for:">delete: message for: aClient	^aClient sendDeleteMessage: message</body><body package="POP3" selector="deleteMessageIds:for:">deleteMessageIds: aSequenceOfUniqueIDs for: aClient	^aClient sendDeleteMessageIds: aSequenceOfUniqueIDs</body><body package="POP3" selector="list:">list: aClient	^aClient sendList</body><body package="POP3" selector="list:for:">list: number for: aClient 	^aClient sendList: number</body><body package="POP3" selector="listMessage:for:">listMessage: number for: aClient 	^aClient sendList: number</body><body package="POP3" selector="noop:">noop: aClient	^aClient sendNoop</body><body package="POP3" selector="quit:">quit: aClient 	aClient sendQuit.	aClient state: POP3UpdateState new.</body><body package="POP3" selector="reset:">reset: aClient 	^aClient sendReset</body><body package="POP3" selector="retrieveMessage:for:">retrieveMessage: number for: aClient 	^aClient sendRetrieveMessage: number</body><body package="POP3" selector="retrieveMessageID:for:">retrieveMessageID: number for: aClient 	^aClient sendRetrieveMessageID: number</body><body package="POP3" selector="retrieveMessageLines:for:">retrieveMessageLines: number for: aClient 	^aClient sendRetrieveMessageLines: number</body><body package="POP3" selector="stat:">stat: aClient	^aClient sendStat</body><body package="POP3" selector="top:of:for:">top: lines of: msg for: aClient	^aClient sendTop: lines of: msg</body></methods><methods><class-id>Net.POP3Status</class-id> <category>accessing</category><body package="POP3" selector="messages">messages	^messages isNil		ifTrue: [messages := 0]		ifFalse: [messages]</body><body package="POP3" selector="messages:">messages: count 	messages := count</body><body package="POP3" selector="octets">octets	^octets isNil		ifTrue: [octets := 0]		ifFalse: [octets]</body><body package="POP3" selector="octets:">octets: count 	octets := count</body></methods><methods><class-id>Net.FailedToDeleteId</class-id> <category>private</category><body package="POP3" selector="defaultResumeValue">defaultResumeValue	^self parameter asString</body></methods><methods><class-id>Net.POP3Connection class</class-id> <category>default values</category><body package="POP3" selector="defaultLineEndConvention">defaultLineEndConvention	^LineEndTransparent</body><body package="POP3" selector="defaultPortNumber">defaultPortNumber	^SocketAccessor IPPORT_POP3</body></methods><methods><class-id>Net.POP3Client</class-id> <category>private</category><body package="POP3" selector="sendApopName:digest:">sendApopName: aStringName digest: aStringDigest	self 		executeCommand: ('APOP ', aStringName, ' ', aStringDigest)		onError: [NetClientError signalWith: #APOP message: self serverResponse].</body><body package="POP3" selector="sendDeleteMessage:">sendDeleteMessage: number 	self 		executeCommand: ('DELE &lt;1p&gt;' expandMacrosWith: number)		onError: [NetClientError signalWith: #DELE message: self serverResponse]</body><body package="POP3" selector="sendDeleteMessageIds:">sendDeleteMessageIds: aSequenceOfUniqueIDs	"Delete all messages whose unique ids appear in aSequenceOfUniqueIDs.	 Do so by doing a UIDL list, computing matching message numbers, and	 deleting by message number."	| count map |	count := self sendStat messages.	map := Dictionary new: count * 2.	self 		executeCommand:  'UIDL'		onError: [NetClientError signalWith: #UIDL message: self serverResponse].	self retrieveMultiLineResponseDo: 			[:line | | msgnum |			msgnum := Integer readFrom: (ReadStream on: line).			map at: (line copyFrom: (line lastIndexOf: Character space) + 1 to: line size - 2) put: msgnum].	aSequenceOfUniqueIDs do:		[ :uid | | msgnum |		(msgnum := map at: uid ifAbsent: []) notNil		and: [self 				executeCommand: ('DELE &lt;1p&gt;' expandMacrosWith: msgnum)				onError: [FailedToDeleteId signalWith: (#failedToDeleteId &lt;&lt; #net &gt;&gt; 'failed to delete id '), uid ]]].	^self sendStat messages</body><body package="POP3" selector="sendList">sendList	| messageStatuses |	self 		executeCommand: 'LIST'		onError: [^self].	messageStatuses := OrderedCollection new: 30.	self 		retrieveMultiLineResponseInto: (String new: 256) writeStream 		process: 			[:line | |result|			IncrementNotification signalWith: line size.			result := line tokensBasedOn: Character space.			messageStatuses add: (POP3Status new				messages: (Number readFrom: (result at: 1) readStream);				octets: (Number readFrom: (result at: 2) readStream);				yourself).			line].	^messageStatuses</body><body package="POP3" selector="sendList:">sendList: messageNumber 	| result |	self 		executeCommand: ('LIST &lt;1p&gt;' expandMacrosWith: messageNumber)		onError: [NetClientError signalWith: #LIST message: self serverResponse].	result := self serverResponse tokensBasedOn: Character space.	^POP3Status new		messages: (Number readFrom: (result at: 2) readStream);		octets: (Number readFrom: (result at: 3) readStream);		yourself</body><body package="POP3" selector="sendNoop">sendNoop	"It should always be positive"	self executeCommand: 'NOOP' onError: [^self].</body><body package="POP3" selector="sendPassword">sendPassword	self 		executeCommand: ('PASS &lt;1s&gt;' expandMacrosWith: self user password)		onError: [^NetClientError signalWith: #login message: self serverResponse ].</body><body package="POP3" selector="sendQuit">sendQuit	self 		executeCommand: 'QUIT'		onError: [^NetClientError signalWith: #QUIT message: self serverResponse ].</body><body package="POP3" selector="sendReset">sendReset	"Should never be false"	self 		executeCommand: 'RSET'		onError: [^NetClientError signalWith: #RSET message: self serverResponse ].</body><body package="POP3" selector="sendRetrieveMessage:">sendRetrieveMessage: number 	| lines size result resultStream |	self 		executeCommand: ('RETR &lt;1p&gt;' expandMacrosWith: number)		onError: [^NetClientError signalWith: #RETR message: self serverResponse ].	lines := LinkedList new.	size := 0.	self retrieveMultiLineResponseDo: 			[:line | | lineSize |			lineSize := line size.			size := size + lineSize - 1.			IncrementNotification signalWith: lineSize.			lines addLast: (LinkValue value: line)].	result := String new: size.	resultStream := result writeStream.	lines do: [:lv| | line | line := lv value. resultStream next: line size - 1 putAll: line startingAt: 1].	(result size ~= size	or: [resultStream position ~= size]) ifTrue:		[self error: (#WrongNumberOfElementsWritten &lt;&lt; #net &gt;&gt; 'wrong number of elements written to resultStream')].	^result</body><body package="POP3" selector="sendRetrieveMessageID:">sendRetrieveMessageID: number	"Return a message's unique id as a String, or nil if the server does not support the UIDL command."	| response |	self 		executeCommand: ('UIDL &lt;1p&gt;' expandMacrosWith: number)		onError: [^nil ].	^(response := self serverResponse) notEmpty 		ifTrue:			[response copyFrom: (response lastIndexOf: Character space) + 1 to: response size - 2]		ifFalse: [nil]</body><body package="POP3" selector="sendRetrieveMessageLines:">sendRetrieveMessageLines: number	"Return a message as an OrderedCollection of lines with CRLF termination."	| lines count result |	self 		executeCommand: ('RETR &lt;1p&gt;' expandMacrosWith: number)		onError: [^NetClientError signalWith: #RETR message: self serverResponse ].	lines := LinkedList new.	count := 0.	self retrieveMultiLineResponseDo: 		[:line | 		count := count + 1.		IncrementNotification signalWith: line size.		lines addLast: (LinkValue value: line)].	result := OrderedCollection new: count + 10.	lines do: [:lv| result addLast: lv value].	^result</body><body package="POP3" selector="sendStat">sendStat	| result |	"It should always be positive"	self 		executeCommand: 'STAT'		onError: [^NetClientError signalWith: #STAT message: self serverResponse ].	result := (self serverResponse tokensBasedOn: Character space).	^POP3Status new		messages: (Number readFrom: (result at: 2) readStream);		octets: (Number readFrom: (result at: 3) readStream);		yourself</body><body package="POP3" selector="sendTop:of:">sendTop: number of: msg	| lines size result resultStream |	self 		executeCommand: ('TOP &lt;1p&gt; &lt;2p&gt;' expandMacrosWith: msg with: number)		onError: [^NetClientError signalWith: #TOP message: self serverResponse ].	lines := LinkedList new.	size := 0.	self retrieveMultiLineResponseDo: 			[:line | | lineSize |			lineSize := line size.			size := size + lineSize - 1.			IncrementNotification signalWith: lineSize.			lines addLast: (LinkValue value: line)].	result := String new: size.	resultStream := result writeStream.	lines do: [:lv| | line | line := lv value. resultStream next: line size - 1 putAll: line startingAt: 1].	(result size ~= size	or: [resultStream position ~= size]) ifTrue:		[self error: (#WrongNumberOfElementsWritten &lt;&lt; #net &gt;&gt; 'wrong number of elements written to resultStream')].	^result</body><body package="POP3" selector="sendUser">sendUser	self 		executeCommand: ('USER &lt;1s&gt;' expandMacrosWith: self user username)		onError: [^NetClientError signalWith: #login message: self serverResponse ].</body></methods><methods><class-id>Net.POP3Client</class-id> <category>connection management</category><body package="POP3" selector="close">close	self quit; disconnect.</body><body package="POP3" selector="connect">connect	| retriesx |	retriesx := self retries.	"Just in case our server is busy, prepare for an error."	[super connect.	self state: POP3AuthorizationState new.	serverResponse := self clientPI waitForResponses	] on: OSErrorHolder peerFaultSignal, OsInaccessibleError, OsNeedRetryError		do: 			[:ex | 			retriesx := retriesx - 1.			(ex getSignal = OSErrorHolder peerFaultSignal			and: [(self handlePeerFaultError: ex retries: retriesx )]) ifTrue:				[^self connectionError "Unable to connect to the server."].			ex class = OsInaccessibleError 				ifTrue: [self connectionError "Pop3Server is not accessible."]				ifFalse: [retriesx := retriesx - 1.						(self handlePeerFaultError: ex retries: retriesx )							ifTrue: [ self connectionError "Unable to connect to the server."].]]</body><body package="POP3" selector="connectionError">connectionError	^NetClientError signalWith: #connection</body><body package="POP3" selector="disconnect">disconnect	super disconnect.	self state: POP3NotConnectedState new.</body><body package="POP3" selector="handlePeerFaultError:retries:">handlePeerFaultError: exception retries: retriesx	"The Pop3Server we are connecting to might be too busy to handle our	connection request.  In this case, delay for a little while and try again.	Once we have hit our connection retry limit, return true to the client so	that it can handle the error as it sees fit."	retriesx &gt; 0 ifTrue: 		[(Delay forSeconds: self delaySeconds) wait.		self clientPI log: [(#FailedToConnectWillTryMore &lt;&lt; #net &gt;&gt; 'Failed to connect to &lt;1s&gt;. Will try &lt;2p&gt; more times.') expandMacrosWith: self hostName with: retriesx]			level: #POP3Client. 		exception retry].	^true</body></methods><methods><class-id>Net.POP3Client</class-id> <category>commands</category><body package="POP3" selector="apop:digest:">apop: aStringName digest: aStringDigest	self state apopName: aStringName digest: aStringDigest for: self.	self state: POP3TransactionState new.	^true</body><body package="POP3" selector="delete:">delete: message	^self state delete: message for: self</body><body package="POP3" selector="deleteMessageIds:">deleteMessageIds: aCollectionOfUniqueIDs	"Delete all messages which have unique ids in the argument.	 Answer the number of messages remaining on the server."	^self state deleteMessageIds: aCollectionOfUniqueIDs for: self</body><body package="POP3" selector="list">list	^self state list: self</body><body package="POP3" selector="list:">list: messageNumber 	^self state list: messageNumber for: self</body><body package="POP3" selector="login">login	self state user: self.	self state pass: self.	self state: POP3TransactionState new. 	^true</body><body package="POP3" selector="noop">noop	^self state noop: self</body><body package="POP3" selector="quit">quit  " When the client issues the QUIT command from the TRANSACTION state,  the POP3 session enters the UPDATE state. There is no disconnect from the server "	self state quit: self</body><body package="POP3" selector="reset">reset	^self state reset: self</body><body package="POP3" selector="retrieveMessage:">retrieveMessage: number	^self state retrieveMessage: number for: self</body><body package="POP3" selector="retrieveMessageID:">retrieveMessageID: number	^self state retrieveMessageID: number for: self</body><body package="POP3" selector="retrieveMessageLines:">retrieveMessageLines: number	^self state retrieveMessageLines: number for: self</body><body package="POP3" selector="status">status	^self state stat: self</body><body package="POP3" selector="top:of:">top: lines of: messageID	^self state top: lines of: messageID for: self</body><body package="POP3" selector="uidl:">uidl: aNumber	^self retrieveMessageID: aNumber</body></methods><methods><class-id>Net.POP3Client</class-id> <category>testing</category><body package="POP3" selector="hasNegativeResponse">hasNegativeResponse	^(self serverResponse indexOfSubCollection: '-ERR' startingAt: 1) &gt; 0</body><body package="POP3" selector="hasPositiveResponse">hasPositiveResponse	^(self serverResponse indexOfSubCollection: '+OK' startingAt: 1) &gt; 0</body><body package="POP3" selector="successful">successful	^self hasPositiveResponse</body></methods><methods><class-id>Net.POP3Client</class-id> <category>low-level command interface</category><body package="POP3" selector="executeCommand:onError:">executeCommand: aString onError: aBlock	serverResponse := self clientPI executeCommand: aString.	self hasPositiveResponse ifFalse: [ aBlock value]</body><body package="POP3" selector="retrieveMultiLineResponseDo:">retrieveMultiLineResponseDo: block 	| result |	[result := self clientPI getNextLine.	 result isEmpty or: [result = TerminationSequence]] whileFalse: 		[result first = TerminationOctet ifTrue:			[result := result copyFrom: 2 to: result size].		serverResponse := result.		block value: result]</body><body package="POP3" selector="retrieveMultiLineResponseInto:process:">retrieveMultiLineResponseInto: aStream process: block 	| result |	result := self clientPI getNextLine.	[result isEmpty or: [result = TerminationSequence]]		whileFalse: 			[result := result first = TerminationOctet						ifTrue: [result copyFrom: 2 to: result size]						ifFalse: [result].			serverResponse := result.			aStream nextPutAll: (block value: result).			result := self clientPI getNextLine]</body></methods><methods><class-id>Net.POP3Client</class-id> <category>accessing</category><body package="POP3" selector="serverResponse">serverResponse	^serverResponse isNil		ifTrue: [serverResponse := String new]		ifFalse: [serverResponse]</body></methods><methods><class-id>Net.POP3Client</class-id> <category>initialize-release</category><body package="POP3" selector="initialize">initialize	super initialize.	self state: POP3NotConnectedState new</body></methods><methods><class-id>Net.POP3Client class</class-id> <category>testing</category><body package="POP3" selector="isIncomingMailClient">isIncomingMailClient	^true</body><body package="POP3" selector="isMailClient">isMailClient	^true</body><body package="POP3" selector="isOutgoingMailClient">isOutgoingMailClient	^false</body></methods><methods><class-id>Net.POP3Client class</class-id> <category>utilities</category><body package="POP3" selector="messageCount">messageCount	"How many messages are on the server?"	"self messageCount"	| connection |	connection := self promptForConnection.	^[connection status messages]		ensure: [connection disconnect]</body><body package="POP3" selector="promptForConnection">promptForConnection	"Pop3Connection promptForConnection"	| connection user  host |	user := NetUser request.	user isNil ifTrue: [^self].	host := Dialog 		request: 'Pop server on:' 		initialAnswer: (LastServer isNil ifTrue: ['xxxx.com'] ifFalse: [LastServer]) 		onCancel: [^nil].	LastServer := host.	connection := self host: host.	connection user: user.	connection 		connect; 		login.	^connection</body><body package="POP3" selector="showProgress:complete:while:">showProgress: aString complete: anInteger while: aBlock 	"Show a progress indicator window while executing a block of code.	anInteger is the completeness count (ie = 100%).	IncrementNotification is raised to denote progress."	"self  showProgress: 'X' complete: 10000 while: 		[ 10000 timesRepeat: [ IncrementNotification raiseSignal ] ]"	| increment progress pw res |	increment := 1.0 / anInteger. 	progress := 0.0 asValue.	pw := ProgressWidgetView progressOpenOn: progress label: aString asText allBold.	[ [ Cursor wait showWhile: [ res := aBlock value ] ] on: IncrementNotification do:		[ :not | 		progress value: ( progress value + ( not ticks * increment ) ).		not resume.		 ]	] ensure: [ pw closeAndUnschedule ].	^res</body><body package="POP3" selector="timestampFormat">timestampFormat	"This is simply moronic."	|policy|	policy := (OrderedCollection new: 10)		add: #ddd;		add: Character space;		add: #mmm;		add: Character space;		add: #d;		add: Character space;		add: #h;		add: $: ;		add: #mm;		add: Character space;		add: #yyyy;		yourself.	^policy asArray</body></methods><methods><class-id>Net.POP3Client class</class-id> <category>instance creation</category><body package="POP3" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.POP3Client class</class-id> <category>constants</category><body package="POP3" selector="description">description	^(#incomingMailServer &lt;&lt; #net &gt;&gt; 'incoming mail server') asString</body><body package="POP3" selector="serverType">serverType	^#POP3</body></methods><methods><class-id>Net.POP3Client class</class-id> <category>private</category><body package="POP3" selector="update:with:from:">update: anAspect with: arguments from: anObject</body></methods><methods><class-id>Net.POP3Client class</class-id> <category>class initialization</category><body package="POP3" selector="initialize">initialize"We're just calling super so that this class gets initialized on load (only classes that define initialize get called)	self initialize."	super initialize.</body><body package="POP3" selector="registerClass">registerClass	self mailRegistry at: self serverType put: self name</body></methods><methods><class-id>Net.POP3Client class</class-id> <category>default values</category><body package="POP3" selector="defaultProtocolInterpreterClassValue">defaultProtocolInterpreterClassValue	^POP3ProtocolInterpreter</body></methods><methods><class-id>Net.POP3AuthorizationState</class-id> <category>commands</category><body package="POP3" selector="apopName:digest:for:">apopName: aStringName digest: aStringDigest for: aClient	^aClient sendApopName: aStringName digest: aStringDigest</body><body package="POP3" selector="pass:">pass: aClient 	aClient sendPassword</body><body package="POP3" selector="quit:">quit: aClient 	aClient sendQuit.	aClient disconnect.</body><body package="POP3" selector="user:">user: aClient 	aClient sendUser</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>instance creation</category><body package="POP3" selector="pop3:user:">pop3: host user: user	^self protocol: #POP3 host:  host user: user</body><body package="POP3" selector="pop3:username:password:">pop3: host username: username password: password	^self protocol: #POP3 host: host username: username password: password</body></methods><initialize><class-id>Net.POP3ProtocolInterpreter</class-id></initialize><initialize><class-id>Net.POP3Mailbox</class-id></initialize><initialize><class-id>Net.POP3Client</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetClientState</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetClientError</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>Mailbox</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user server lastMessage keepMail deleteMail deliveryQueue pollingProcess delaySemaphore sync settingsSync connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Mail</category><attributes><package>Mail</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>encoding </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetNotification</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class></st-source>