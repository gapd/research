<?xml version="1.0"?><st-source><!-- Name: URISupportNotice: Copyright © 2010-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: URISupport includes a framework for working with URIs (Uniform Resource Identifiers) and URLs (Universal Resource Locators). The framework provides an easy-to-use mechanism to create URL objects from a String, as well as a simple interface for performing some operations on the URL, such as reading and writing, if permitted by the resource.A URI is a string that represents the address of a piece of information on the Internet. A URL is a type of URI that specifies the protocol type, such as FTP, HTTP, and MailTo. Additional packages may need to be loaded other URL types beyond FILE, for example, FTP, HTTP, HTTPS.Creating a URI:In VisualWorks, a URI is an object that is created by parsing a String specifying the URI. To parse the String, send it an asURI message:'ftp://download.cincom.com/documents/public/some.doc' asURIThe result in this case is an FtpURL object, which was determined from the protocol prefix. If the prefix had been 'http:' the result would be an HttpURL. If the protocol were an unknown type, such as 'MailTo:', the result would be an UnknownURLType.The protocol is determined by reading from the beginning of the string to the colon (FTP). The host is read immediately following the double slash (//) up to the first single slash (download.cincom.com). Everything else is the path, query and fragment.For local files, you can generate a URI from a Filename:	'visual.im' asFilename asURILikewise, file URLs can be turned in to Filenames:	'file:///./visual.im' asURI asFilenameA URI object can be turned back into a String by sending #asString to it.HideSource: falsePackageName: URISupportParcel: #('URI')SaveSource: trueVersion: 7.7.1 - 2Date: 7:19:11 AM March 30, 2011 --><time-stamp>From VisualWorks®, 7.8 of March 30, 2011 on March 30, 2011 at 7:19:11 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>URLEncoder</name><environment>OS</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>urlSpecials </inst-vars><class-inst-vars>urlSpecials </class-inst-vars><imports></imports><category>URISupport</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URLEncoder</class-id><body>This encodes and decodes strings using the W3C url-encoded format. Examples of use are    URLEncoder new encode: 'fee fie ** foe	fum'    (URLEncoder new charset: #'utf-16') encode: 'fee fie ** foe	fum'    URLEncoder new decode: 'fee+fie+%2A%2A+foe%09fum'    (URLEncoder new charset: #'utf-16') decode: 'fee+fie+%2A%00%2A%00+foe%09%00fum'The implementation is quite complicated.</body></comment><class><name>URI</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URI</class-id><body>URI represents a Uniform Resource Identifier, which is a standardized string representation of the address of data on the net. These can be broken down into URLs and URNs. In general, an URL specifies an address which specifically names the computer which supplies the resource, and an URN specifies an abstract name which must be resolved to a specific computer name by the client at runtime, but this distinction is not necessarily followed in detail by the various URI types in use.In this framework, only URLs have been implemented, since currently the design and implementation of URNs is in flux, and the infrastructure is not fully developed.Subclasses must implement the following messages:	accessing		asString		resource	stream creation		binaryReadStream		binaryWriteStream		readStreamDo:		writeStreamDo:Subclasses must implement the following class side messages:	accessing		protocol</body></comment><class><name>URL</name><environment>OS</environment><super>OS.URI</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URL</class-id><body>URL is a class which represents those URIs that, usually, explicitly or implicitly identify the host computer which supplies the named resource, as opposed to URNs which require the host computer to be resolved at runtime via an unspecified mechanism. However, there have been some URLs developed which do not explicitly identify the server, so that this distinction is not rigid. However, URNs begin with "urn:" and usually use : as the separator between fields, and URLs may or may not begin with "url:", and usually use / to separate fields.</body></comment><class><name>UnknownURLType</name><environment>OS</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.UnknownURLType</class-id><body>UnknownURLType is created when there is no URL class matching the protocol of a URI string. It can be manipulated to limited extents but cannot retrieve any data.Instance Variables:	data	&lt;String&gt;	 everything in the URL after the protocol	protocol	&lt;String&gt;	the data transfer protocol name requested</body></comment><class><name>ComponentNotLoaded</name><environment>OS</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultValueBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.ComponentNotLoaded</class-id><body>ComponentNotLoaded exception will be raised when the Http or Ftp url is created and one of the component HTTP or FTP is not loaded.Instance Variables:	defaultValueBlock	&lt;aBlock&gt;	default value block</body></comment><class><name>URLwithPath</name><environment>OS</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path query fragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URLwithPath</class-id><body>URLwithPath uses the general syntax "protocol://host/path", where path may be composed of multiple segments separated by /, and where the host is usually the DNS name of a computer, but in subclasses such as FtpURL, the host may be more complex.Subclasses must implement the following messages:	initialize		parseHost:Instance Variables:	fragment	&lt;String&gt;	When the URL contains #, what follows is an address to a specific location within the resource. The interpretation of the address depends on the MIME type of the resource.	path	&lt;Array of: String&gt;	The components of the path which tells the server where to find the resource	query	&lt;String&gt;	If the URL contains a ?, what follows is the argument for the resource. In this case, the assumption is that the resource is a program of some type, such as a CGI or a database query, and the query part of the URL specifies the arguments.</body></comment><class><name>PartialURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RelativeURL</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.PartialURL</class-id><body>Represents a URL without a protocol part, eg: '/path/file.ext' asURI or 'relativepath/file.ext?query#fragment' asURI. These partial URLs can be combined with other partial URLs or full URLs so long as the URL scheme includes a path (ie: subclasses from URLwithPath).Examples:'http://localhost/' asURI, 'images/example.jpg''http://localhost/subdirectory/' asURI, 'myfile.ext'</body></comment><class><name>URLwithAuthority</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URLwithAuthority</class-id><body>URLwithAuthority is super class for URL subclasses that are supporting host and port protocol	server        = [ [ userinfo "@" ] hostport ]Subclasses must implement the following messages:	accessing		clientInstance Variables:	host	&lt;String&gt;	 host name	port		&lt;Number&gt;	 port number</body></comment><class><name>UriEncodedStreamConstructor</name><environment>OS</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.UriEncodedStreamConstructor</class-id><body>This class supports composing the description of a stream (which is named by a URI) with its encoding and any other interesting attributes, then creating the stream.</body></comment><class><name>FileURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>missingSlashes host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.FileURL</class-id><body>FileURL represents an URL with the protocol 'file:', representing a file on the local hard disk or, rarely, on another computer on the LAN. Accessing the resource is done by converting the URL to a Filename and opening the file.Instance Variables:	host	&lt;String | nil&gt;	File URL syntax ideally is file://host/path. Usually, the host is empty, and the file name starts with three / characters, but (especially on Windows) we support a non-empty host, which translates to file names of the form "\\host\path".	missingSlashes	&lt;Boolean&gt;	true if, when the URL was created, the syntax used was host file syntax, and false if the URL used the portable, platform independent syntax that uses / as the separator.</body></comment><shared-variable><name>AutoloadHttps</name><environment>OS.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>ProtocolToClassCache</name><environment>OS.URI</environment><private>false</private><constant>true</constant><category>Optimization</category><initializer>Dictionary new: 5</initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>AutoloadHttp</name><environment>OS.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>AutoloadFtp</name><environment>OS.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><methods><class-id>OS.URLEncoder</class-id> <category>utility</category><body package="URISupport" selector="decode:">decode: aString	"This is frightening. We want to advance the inner stream unless we see %, in which case we go to the outer stream. And for state-changing encoders, we need to know that nil character doesn't necessarily indicate an error"	| result  |	result := WriteStream on: (String new: aString size).	self decode: aString onto: result.	^result contents.</body><body package="URISupport" selector="decode:onto:">decode: aString onto: resultStream	"This is frightening. We want to advance the inner stream unless we see %, in which case we go to the outer stream. And for state-changing encoders, we need to know that nil character doesn't necessarily indicate an error"	| outermostDecoder urlDecoder realCharacterStream |	outermostDecoder := self decodingStreamOn: aString.	urlDecoder := outermostDecoder stream.	realCharacterStream := urlDecoder stream.	[urlDecoder atEnd]		whileFalse:			[| nextThing mode |			mode := outermostDecoder encoder readMode.			nextThing := realCharacterStream peek = $%				ifTrue: [outermostDecoder next]				ifFalse: [urlDecoder next].				(outermostDecoder encoder readMode == mode)				ifTrue:					[nextThing isNil 	ifTrue: [						nextThing := (UnsupportedCharacterError new)							messageText: #errNoCharacter &lt;&lt; #dialogs &gt;&gt; 'No character available';							raise]].			nextThing isNil ifFalse: [resultStream nextPut: nextThing asCharacter]].</body><body package="URISupport" selector="encode:">encode: aString	^(self encodingStream) nextPutAll: aString; close; encodedContents.</body><body package="URISupport" selector="encode:onto:">encode: aString onto: aStream	^(self encodingStreamOn: aStream) nextPutAll: aString; close.</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>querying</category><body package="URISupport" selector="characterSize:">characterSize: char	"Return the size in bytes of &lt;char&gt;."	^(self isValidURLCharacter: char) ifTrue: [1] ifFalse: [3].</body><body package="URISupport" selector="isValidURLCharacter:">isValidURLCharacter: aCharacter	"Return true if this character is one we can expect to see in a URL when decoding it. Note that this excludes the escapes, because we expect them to have been translated away before this is asked. See http://www.w3.org/Addressing/URL/5_BNF.html"	| char |	char := aCharacter asCharacter.	char isAlphaNumeric ifTrue: [^true].	(self urlSpecials includes: aCharacter) ifTrue: [^true].	^false.</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>accessing</category><body package="URISupport" selector="charset">charset	"Return a symbol indicating the encoding we will use."	^encoder encoding.</body><body package="URISupport" selector="charset:">charset: aCharsetName	self setEncoder: (StreamEncoder new: aCharsetName).</body><body package="URISupport" selector="decodeHexNumberFrom:">decodeHexNumberFrom: aStream	^Number readIntegerFrom: (aStream next: 2) readStream radix: 16.</body><body package="URISupport" selector="encodingStream">encodingStream	^self encodingStreamOn: (WriteStream on: String new).</body><body package="URISupport" selector="encodingStreamOn:">encodingStreamOn: innerStream	| outerStream |	outerStream := EncodedStream on: innerStream encodedBy: self.	^outerStream.</body><body package="URISupport" selector="nextFrom:">nextFrom: aStream	"Decode the next byte(s) in the stream and answer the character."	| c |	c := aStream next.	c = $+ ifTrue: [^Character space asInteger].	c = $% ifTrue: [^self decodeHexNumberFrom: aStream].	^c isNil ifTrue: [c] ifFalse: [c asInteger].</body><body package="URISupport" selector="nextPut:on:">nextPut: aCharacterOrByte on: aStream	"Encode the character according to the encoding, and if necessary URL encode it"	| digits digits2 aCharacter |	aCharacter := aCharacterOrByte asCharacter.	(aCharacter = Character space and: [ self urlSpecials includes: aCharacter ]) ifTrue: [^aStream nextPut: $+].	"The doubling up is needing for encodings that switch character interpretations in the middle, using escape sequences. Specifically, JIS. Rather than hard-coding knowledge of these encodings, encode twice and if it's different, that means there's a prelude"	digits := self bytesFor: aCharacter.	digits2 := self bytesFor: aCharacter.	digits size = digits2 size		ifTrue:			[(self isValidURLCharacter: aCharacter)				ifTrue: [aStream nextPut: aCharacter]				ifFalse: [digits do: [:each | self printHex: each on: aStream]]]		ifFalse:			[self				printDigits: aCharacter				withPreludeFor: digits				and: digits2				on: aStream].</body><body package="URISupport" selector="setEncoder:">setEncoder: aCharacterEncoder	encoder := aCharacterEncoder.	"For encodings with Big-Endian and Little-Endian variations, network order is specified as Big-Endian, so force that to be used."	encoder bigEndian: true.</body><body package="URISupport" selector="urlSpecials">urlSpecials	urlSpecials == nil ifTrue: [urlSpecials := self class urlSpecials].	^urlSpecials.</body><body package="URISupport" selector="urlSpecials:">urlSpecials: aString	urlSpecials:= aString</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>private</category><body package="URISupport" selector="bytesFor:">bytesFor: aCharacter	| bitStream |	bitStream := (ByteArray new: 8) writeStream.	encoder nextPut: aCharacter on: bitStream.	^bitStream contents.</body><body package="URISupport" selector="decodingStreamOn:">decodingStreamOn: aString	| innerStream outerStream |	innerStream := EncodedStream on: (ReadStream on: aString) encodedBy: self.	outerStream := EncodedStream on: innerStream encodedBy: (self encoder ifNil: [UTF8StreamEncoder new]).	^outerStream.</body><body package="URISupport" selector="printDigits:withPreludeFor:and:on:">printDigits: aCharacter withPreludeFor: bytesWithPrelude and: basicBytes on: aStream	"This is used for encodings that switch character interpretations in the middle, using escape sequences. Specifically, JIS. Rather than hard-coding knowledge of these encodings, encode twice and if it's different, that means there's a prelude. Figure out what the prelude is and print it differently"	| prelude preludeSize |	preludeSize := bytesWithPrelude size - basicBytes size.	prelude := bytesWithPrelude copyFrom: 1 to: preludeSize.	prelude do: [:each | 		(self isValidURLCharacter: each asCharacter)			ifTrue: [aStream nextPut: each asCharacter]			ifFalse: [self printHex: each on: aStream]].	(self isValidURLCharacter: aCharacter) 		ifTrue: [	aStream nextPut: aCharacter]		ifFalse: [basicBytes do: [:each | self printHex: each on: aStream]].</body><body package="URISupport" selector="printDigitsNoPrelude:on:">printDigitsNoPrelude: aCharacterOrDigit on: aStream	| aCharacter |	aCharacter := aCharacterOrDigit asCharacter.	(self isValidURLCharacter: aCharacter) 		ifTrue: [	aStream nextPut: aCharacter]		ifFalse: [self printHex: aCharacter asInteger on: aStream].</body><body package="URISupport" selector="printHex:on:">printHex: each on: aStream	aStream nextPut: $%.	^each		printOn: aStream		base: 16		digitsToPad: 2		highDigit: 2.</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>status</category><body package="URISupport" selector="prepareToClose:">prepareToClose: aStream	"This is truly horrible. We need to make a new stream, because we don't have the old one."	| newStream |	newStream := (ByteArray new: 5) writeStream.	encoder prepareToClose: newStream.	newStream contents do: [:each | self printDigitsNoPrelude: each on: aStream].	super prepareToClose: aStream.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>defaults</category><body package="URISupport" selector="defaultCharacterEncoder">defaultCharacterEncoder	^UTF8StreamEncoder new</body><body package="URISupport" selector="urlSpecials">urlSpecials	urlSpecials isNil ifTrue: [urlSpecials := ' _'].	^urlSpecials.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>encoding</category><body package="URISupport" selector="decode:">decode: aString	^self new decode: aString.</body><body package="URISupport" selector="encode:">encode: aString	^self new encode: aString.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>instance creation</category><body package="URISupport" selector="new">new	^super new initialize.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>accessing</category><body package="URISupport" selector="streamEncodingType">streamEncodingType	^#URL</body></methods><methods><class-id>OS.URI</class-id> <category>comparing</category><body package="URISupport" selector="=">= aURI"Current implementation considers that two URLs:  '&lt;schema&gt;://example.com/pub'  and  '&lt;schema&gt;://example.com/pub/'  are not equivalent  as they behave differently with respect to: #resolvePath:"	^self class = aURI class		and: [self stringRepresentationPartsMatch: aURI]</body><body package="URISupport" selector="hash">hash	^self asString hash</body><body package="URISupport" selector="sameAs:">sameAs:  aURI	^self = aURI</body><body package="URISupport" selector="stringRepresentationPartsMatch:">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^self asString = aURI asString</body></methods><methods><class-id>OS.URI</class-id> <category>accessing</category><body package="URISupport" selector="asString">asString	^self subclassResponsibility</body><body package="URISupport" selector="asURI">asURI	^self</body><body package="URISupport" selector="protocol">protocol	^self class protocol</body><body package="URISupport" selector="protocol:">protocol: p	"Ignored by those protocols that only go by one name."	^self</body><body package="URISupport" selector="resource">resource	^self subclassResponsibility</body></methods><methods><class-id>OS.URI</class-id> <category>stream creation</category><body package="URISupport" selector="binaryReadStream">binaryReadStream	"Create a binary readStream on the data that the URI accesses.	Some URIs such as MailTo will not support this."	^self subclassResponsibility</body><body package="URISupport" selector="binaryWriteStream">binaryWriteStream	"Create a binary readStream on the data that the URI accesses.	Some URIs such as MailTo will not support this."	^self subclassResponsibility</body><body package="URISupport" selector="readStream">readStream	^(self withEncoding: #default) readStream</body><body package="URISupport" selector="readStreamDo:">readStreamDo: aBlock	"Create a binary readStream on the data that the URI accesses.	Evaluate the block with the stream as the first argument, and with	a Dictionary as the second argument. The Dictionary will describe	any additional information that the protocol can supply about the	resource, such as its file extension (using the key #extension) or	its MIME type (using the key #MIME). This method is responsible	for closing the stream after the block ends, as well as any other	cleanup.	Some URIs such as MailTo will not support this."	^self subclassResponsibility</body><body package="URISupport" selector="withEncoding:">withEncoding: aStreamEncoderName	^UriEncodedStreamConstructor		on: self		encoding: aStreamEncoderName</body><body package="URISupport" selector="writeStream">writeStream	^(self withEncoding: #default) writeStream</body><body package="URISupport" selector="writeStreamDo:">writeStreamDo: aBlock	"Create a binary writeStream on the data that the URI accesses.	Evaluate the block with the stream as the argument. This method	is responsible for closing the stream after the block ends, as well	as any other cleanup.	Some URIs such as Http or News may not support this."	^self subclassResponsibility</body></methods><methods><class-id>OS.URI</class-id> <category>private</category><body package="URISupport" selector="copyFromFTP:">copyFromFTP: aURI	self copyFromURI: aURI</body><body package="URISupport" selector="copyFromURI:">copyFromURI: aURI	self writeStreamDo: [:dest |		aURI readStreamDo: [:src :parms |			[src atEnd] whileFalse:				[dest nextPutAll: (src nextAvailable: 1024)]]]</body><body package="URISupport" selector="escaped:">escaped: aString	^self class encode: aString</body><body package="URISupport" selector="relativePathNotSupportedError">relativePathNotSupportedError	self error: ((#RelativePathsAreNotSupported &lt;&lt; #net &gt;&gt; 'Relative paths are not supported for the "&lt;1s&gt;" protocol') expandMacrosWith: self protocol)</body></methods><methods><class-id>OS.URI</class-id> <category>utilities</category><body package="URISupport" selector="copyTo:">copyTo: aURI	aURI asURI copyFromURI: self</body></methods><methods><class-id>OS.URI</class-id> <category>resolution</category><body package="URISupport" selector="resolvePath:">resolvePath: path	^(path includes: $:)		ifTrue: [URI fromString: path]		ifFalse: [self relativePathNotSupportedError]</body></methods><methods><class-id>OS.URI</class-id> <category>printing</category><body package="URISupport" selector="printOn:">printOn: aStream	| str |	str := [self asString] on: Error do: [:ex | ex return: nil].	str == nil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: '&lt;', str, '&gt;'].</body><body package="URISupport" selector="printProtocolOn:">printProtocolOn: aStream	aStream nextPutAll: self protocol, '://'.</body></methods><methods><class-id>OS.URI</class-id> <category>testing</category><body package="URISupport" selector="isPartial">isPartial	^false</body></methods><methods><class-id>OS.URI</class-id> <category>deprecated</category><body package="URISupport" selector="resolveRelativePath:">resolveRelativePath: path"	This method is now deprecated. pathString can be a PartialURL or a string and it will be judged as to whether it is relative or not by a leading /, eg:'/example.ext' asURI is absolute, while:'example.ext' asURI is relative"	self relativePathNotSupportedError</body></methods><methods><class-id>OS.URI class</class-id> <category>accessing</category><body package="URISupport" selector="allowedChar">allowedChar	^self unreservedChar, ';?:@&amp;=+$,'</body><body package="URISupport" selector="autoloadFtp">autoloadFtp	^AutoloadFtp isNil		ifTrue: [AutoloadFtp := false]		ifFalse: [ AutoloadFtp ]</body><body package="URISupport" selector="autoloadFtp:">autoloadFtp: aBoolean	AutoloadFtp := aBoolean</body><body package="URISupport" selector="autoloadHttp">autoloadHttp	^AutoloadHttp isNil		ifTrue: [AutoloadHttp := false]		ifFalse: [ AutoloadHttp ]</body><body package="URISupport" selector="autoloadHttp:">autoloadHttp: aBoolean	AutoloadHttp := aBoolean</body><body package="URISupport" selector="autoloadHttps">autoloadHttps	^AutoloadHttps isNil		ifTrue: [AutoloadHttps := false]		ifFalse: [ AutoloadHttps ]</body><body package="URISupport" selector="autoloadHttps:">autoloadHttps: aBoolean	AutoloadHttps := aBoolean</body><body package="URISupport" selector="classForProtocol:">classForProtocol: aProtocol	| prot class res | 	prot := aProtocol asLowercase. 	class := ProtocolToClassCache at: prot ifAbsent: [].	(class ~~ nil and: [class protocol = prot]) ifTrue:		[^class].	self allSubclasses do:		[:cls |		cls protocol = prot ifTrue: [^ProtocolToClassCache at: prot put: cls]].	^(res := self tryToLoad: aProtocol) isNil		ifTrue: [ UnknownURLType ]		ifFalse: [ res ]</body><body package="URISupport" selector="obsolete">obsolete	self resetProtocolToClassCache.	super obsolete.</body><body package="URISupport" selector="pathAllowedChars">pathAllowedChars	^self unreservedChar, ':@&amp;=+$,'</body><body package="URISupport" selector="protocol">protocol	^self subclassResponsibility</body><body package="URISupport" selector="reservedChar">reservedChar	^';/?:@&amp;=+$,'</body><body package="URISupport" selector="resetProtocolToClassCache">resetProtocolToClassCache	"(self resetProtocolToClassCache)"	ProtocolToClassCache keys do: [ :k | ProtocolToClassCache removeKey: k].</body><body package="URISupport" selector="unreservedChar">unreservedChar	^'-_.!~*''()'</body><body package="URISupport" selector="userAllowedChars">userAllowedChars	^self unreservedChar, ';:&amp;=+$,'</body></methods><methods><class-id>OS.URI class</class-id> <category>instance creation</category><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	| index protocol data |	(aString includes: $:) ifFalse: [^PartialURL fromString: aString].	index := aString indexOf: $:.	protocol := aString copyFrom: 1 to: index-1.	data := aString copyFrom: index+1 to: aString size.	^((self classForProtocol: protocol)		fromString: data)			protocol: protocol</body></methods><methods><class-id>OS.URI class</class-id> <category>testing</category><body package="URISupport" selector="hasUnsafeChars:allowed:">hasUnsafeChars: aString allowed: allowed	| cCode |	aString do: [:c |		cCode := c asInteger.		(cCode &gt;= 32 and: [cCode &lt;= 126 or: [allowed includes: c]])			ifFalse: [^true]].	^false</body><body package="URISupport" selector="shouldEncode:allowed:">shouldEncode: character allowed: allowed	^(allowed includes: character) not		and: [character isAlphaNumeric not ]</body></methods><methods><class-id>OS.URI class</class-id> <category>encoding/decoding</category><body package="URISupport" selector="decode:">decode: aString 	|str |	str := (String new: aString size) writeStream.	self decode: aString on: str.	^str contents</body><body package="URISupport" selector="decode:errorMessage:allowed:">decode: aString errorMessage: message allowed: allowed	^(self hasUnsafeChars: aString allowed: allowed)		ifTrue: [ self error: message ]		ifFalse: [self decode: aString]</body><body package="URISupport" selector="decode:on:">decode: aString on: stream	| oldStr ch |	oldStr := aString readStream.	[oldStr atEnd] whileFalse:		[ch := oldStr next.		self decodeChar: ch from: oldStr to: stream].	^stream contents</body><body package="URISupport" selector="decodeChar:from:to:">decodeChar: character from: stream to: outputStream	| n c1 |	n := 0.  	character = $%		ifTrue: 			[2 timesRepeat:				[c1 := stream next.				c1 == nil					ifTrue: [self error: (#IncompleteEscapeSequence &lt;&lt; #net &gt;&gt; 'Incomplete escape sequence')]					ifFalse:						[c1 := c1 digitValue.						(c1 between: 0 and: 15)							ifFalse: [self error: (#DidntFindHexadecimalDigit &lt;&lt; #net &gt;&gt; 'Didn''t find a hexadecimal digit')].						n := n * 16 + c1]].			outputStream nextPut: (Character value: n)]		ifFalse: [ outputStream nextPut: character]</body><body package="URISupport" selector="encode:">encode: aString	^self encode: aString  allowed: self allowedChar.</body><body package="URISupport" selector="encode:allowed:">encode: aString  allowed: allowed	| stream |	stream := (String new: aString size) writeStream.	self encode: aString on: stream allowed: allowed.	^stream contents</body><body package="URISupport" selector="encode:on:">encode: aString on: stream	self encode: aString  on: stream allowed: self allowedChar</body><body package="URISupport" selector="encode:on:allowed:">encode: aString  on: stream allowed: allowed	| hex ch |	hex := '01234567890abcdefABCDEF'.	1 to: aString size	  do: [:ind |		ch := aString at: ind.		((self shouldEncode: ch allowed: allowed)			and: [ (ch =$% and: [ ind + 2 &gt; aString size])				or: [	(ch = $% and: [(hex includes: (aString at: ind + 1))						and: [(hex includes: (aString at: ind + 2))]]) not]])			ifTrue: 				[stream nextPut: $%.				ch asInteger printOn: stream paddedWith: $0 to: 2 base: 16]			ifFalse: [stream nextPut: ch]].</body></methods><methods><class-id>OS.URI class</class-id> <category>private</category><body package="URISupport" selector="loadNetParcel:autoload:">loadNetParcel: aString autoload: aBoolean"FTP, HTTP and HTTPS parcels have to be in the ..\net directory"	(LogicalFilename fromComponents: (Array		with: '$(VISUALWORKS)'		with: 'net'		with: aString, '.pcl')) exists		ifFalse: [^nil ].	^aBoolean		ifTrue: [ self loadParcel: aString ]		ifFalse: 				[ComponentNotLoaded newException					parameter: aString;					defaultValueBlock: [ self loadParcel: aString ];					makeSureResumable;					raiseSignal]</body><body package="URISupport" selector="loadParcel:">loadParcel: aString	^[	Parcel ensureLoadedParcel: aString  withVersion:  nil.      	self classForProtocol: aString	] on: Error	do: [ :ex |  ex return: nil ]</body><body package="URISupport" selector="tryToLoad:">tryToLoad: protocolString	( 'http' match: protocolString)		ifTrue: [ ^self loadNetParcel: 'HTTP' autoload: self autoloadHttp].	( 'https' match: protocolString)		ifTrue: [	^self loadNetParcel: 'HTTPS' autoload: self autoloadHttps].	( 'ftp' match: protocolString)		ifTrue: [ 	^self loadNetParcel: 'FTP' autoload: self autoloadFtp ].	^nil</body></methods><methods><class-id>OS.URL</class-id> <category>printing</category><body package="URISupport" selector="printOn:">printOn: aStream	| str |	str := [self asString] on: Error do: [:ex | ex return: nil].	str == nil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: '&lt;URL:', str, '&gt;'].</body></methods><methods><class-id>OS.URL class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^'url'</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>accessing</category><body package="URISupport" selector="asString">asString	^protocol, ':', data</body><body package="URISupport" selector="extraData:">extraData: extraData	data := extraData</body><body package="URISupport" selector="protocol">protocol	^protocol</body><body package="URISupport" selector="protocol:">protocol: p	protocol := p</body><body package="URISupport" selector="resource">resource	^self error: (#UnrecognizedTransferProtocol &lt;&lt; #net &gt;&gt; 'Unrecognized transfer protocol')</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>comparing</category><body package="URISupport" selector="hash">hash	^self protocol hash bitXor: self data hash</body><body package="URISupport" selector="stringRepresentationPartsMatch:">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^self protocol = aURI protocol		and: [self data = aURI data]</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>private</category><body package="URISupport" selector="data">data	^data</body></methods><methods><class-id>OS.UnknownURLType class</class-id> <category>instance creation</category><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	^self new extraData: aString</body></methods><methods><class-id>OS.UnknownURLType class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^nil</body></methods><methods><class-id>OS.ComponentNotLoaded</class-id> <category>constants</category><body package="URISupport" selector="defaultResumeValue">defaultResumeValue	"Answer the default value to resume with."	^defaultValueBlock value</body></methods><methods><class-id>OS.ComponentNotLoaded</class-id> <category>accessing</category><body package="URISupport" selector="defaultValueBlock:">defaultValueBlock: aBlock	defaultValueBlock := aBlock</body></methods><methods><class-id>OS.ComponentNotLoaded</class-id> <category>printing</category><body package="URISupport" selector="defaultMessageText">defaultMessageText	^(#CannotCreateURL &lt;&lt; #net &gt;&gt; 'Can not create URL, &lt;1s&gt; parcel is not loaded') expandMacrosWith: self parameter</body></methods><methods><class-id>OS.ComponentNotLoaded class</class-id> <category>testing</category><body package="URISupport" selector="mayResume">mayResume	^true</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="addComponent:">addComponent: aFileComponent	aFileComponent = '..' 		ifTrue:			[path isEmpty 				ifFalse: 					[path first ~= '..'						ifTrue: [path := path copyFrom: 1 to: (path size-1 max: 0)]						ifFalse: 	[self privateAddComponent: aFileComponent]]]		ifFalse: 	[self privateAddComponent: aFileComponent]</body><body package="URISupport" selector="construct:">construct:  aFileComponent	^self copy 		addComponent: aFileComponent;		yourself</body><body package="URISupport" selector="removeLastComponent">removeLastComponent	path := path copyFrom: 1 to: path size-1</body><body package="URISupport" selector="resolvePath:">resolvePath: aPath	| aURI |	aURI := aPath asURI.	aURI isPartial ifFalse: [^aURI copy].	^self copy		mergePartial: aURI;		yourself</body><body package="URISupport" selector="withComponent:">withComponent: component	"Create a new URL with the argument component appended.	The new component is assumed to be already URL-encoded."	| p |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	^self copy		query: nil;		fragment: nil;		path: p;		addComponent: component</body><body package="URISupport" selector="withComponents:">withComponents: comps	"Create a new URL with the argument components appended.	The new components are assumed to be already URL-encoded."	| p uri |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	uri := self copy		query: nil;		fragment: nil;		path: p.	comps do: [:s | uri addComponent: s].	^uri</body><body package="URISupport" selector="withSimpleComponent:">withSimpleComponent: comp	"Create a new URL with the argument component appended.	The new component has not yet been URL-encoded, and this	will be done before it is appended."	^self withComponent:  comp</body><body package="URISupport" selector="withSimpleComponents:">withSimpleComponents: comps	"Create a new URL with the argument component appended.	The new components have not yet been URL-encoded, and this	will be done before they are appended."	^self withComponents: comps</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>utilities</category><body package="URISupport" selector="directory">directory	^self withComponent: '..'</body><body package="URISupport" selector="tail">tail	| index |	path isEmpty ifTrue: [^''].	index := path last = ''		ifTrue: [path size-1]		ifFalse: [path size].	index = 0 ifTrue: [^''].	^self pathAt: index</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>accessing</category><body package="URISupport" selector="fragment">fragment	^fragment</body><body package="URISupport" selector="fragment:">fragment: f	fragment := f</body><body package="URISupport" selector="path">path	^path</body><body package="URISupport" selector="path:">path: aPath	path := aPath</body><body package="URISupport" selector="pathAt:">pathAt: index	| p |	p := path at: index.	^self simpleValidate: p		errorMessage: ((#InvalidPathComponent1s &lt;&lt; #net &gt;&gt; 'Invalid path component: &lt;1s&gt;') expandMacrosWith: p)		allowed: self class pathAllowedChars</body><body package="URISupport" selector="query">query	^query</body><body package="URISupport" selector="query:">query: q	query := q</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>private</category><body package="URISupport" selector="guessMimeType">guessMimeType	"To do move Net.MimeTypeDescriptor to base classes and return:  		 Net.MimeTypeDescriptor contentType: mimeType"	^#{Net.MimeTypeDescriptor} 		ifDefinedDo: [ :mimeTypeDescriptor | mimeTypeDescriptor guessFromExtension: self tail asFilename extension]		elseDo: ['text/plain']</body><body package="URISupport" selector="mergeAbsolutePath:">mergeAbsolutePath: aPath	self path: (aPath allButFirst: 1)</body><body package="URISupport" selector="mergePartial:">mergePartial: aPartialURL	self fragment: aPartialURL fragment.	aPartialURL hasNoPath ifTrue: [^aPartialURL query ifNotNil: [self query: aPartialURL query]].	self query: aPartialURL query.	aPartialURL isAbsolute		ifTrue:	[self mergeAbsolutePath: aPartialURL path copy]		ifFalse:	[self mergeRelativePath: aPartialURL path copy]</body><body package="URISupport" selector="mergeRelativePath:">mergeRelativePath: relativePath	path isEmpty ifTrue: [^path := relativePath].	path := (path allButLast: 1), relativePath</body><body package="URISupport" selector="privateAddComponent:">privateAddComponent: aFileComponent	path := path copyWith: 				(self class encode: aFileComponent  					allowed: self class pathAllowedChars)</body><body package="URISupport" selector="protocolSignals">protocolSignals</body><body package="URISupport" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock	^aBlock value</body><body package="URISupport" selector="simpleValidate:errorMessage:allowed:">simpleValidate: aString errorMessage: message allowed: allowed	^self class decode: aString errorMessage: message allowed: allowed</body><body package="URISupport" selector="storeExtrasOn:">storeExtrasOn: aStream	query == nil ifFalse: [aStream nextPutAll: '?', query].	fragment == nil ifFalse: [aStream nextPutAll: '#', fragment].</body><body package="URISupport" selector="validateHost:">validateHost: aString	| str parts |	str := self simpleValidate: aString		errorMessage: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)		allowed: ''.	str do: [:ch |		(ch isAlphaNumeric or: ['.-_' includes: ch])			ifFalse: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)]].	parts := str tokensBasedOn: $..	parts do: [:str1 |		str1 isEmpty			ifTrue: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)].		(str1 first = $- or: [str1 last = $-])			ifTrue: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)]].	^str</body><body package="URISupport" selector="validatePassword:">validatePassword: aString	| str |	str := self simpleValidate: aString		errorMessage: ((#InvalidPassword1s &lt;&lt; #net &gt;&gt; 'Invalid password: &lt;1s&gt;') expandMacrosWith: aString)		allowed: self class userAllowedChars.	^str</body><body package="URISupport" selector="validatePort:">validatePort: aString	| str port |	str := self simpleValidate: aString		errorMessage: ((#InvalidPort1s &lt;&lt; #net &gt;&gt; 'Invalid port: &lt;1s&gt;') expandMacrosWith: aString)		allowed: ''.	port := 0.	str do: [:c |		(c between: $0 and: $9)			ifTrue: [port := port * 10 + c digitValue]			ifFalse: [self error: ((#InvalidPort1s &lt;&lt; #net &gt;&gt; 'Invalid port: &lt;1s&gt;') expandMacrosWith: aString).]].	^port</body><body package="URISupport" selector="validateUser:">validateUser: aString	| str |	str := self simpleValidate: aString		errorMessage: ((#InvalidUser1s &lt;&lt; #net &gt;&gt; 'Invalid user: &lt;1s&gt;') expandMacrosWith: aString)		allowed: self class userAllowedChars.	^str</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>comparing</category><body package="URISupport" selector="hash">hash	^self path hash bitXor:		(self query hash bitXor: self fragment hash)</body><body package="URISupport" selector="sameAs:">sameAs:  aURI"Current implementation considers that two URLs are equivalent only when their path size is equal and therefore the method returns false for URLs: '&lt;schema&gt;://example.com/pub'  and  '&lt;schema&gt;://example.com/pub/' "	self path size = aURI path size ifFalse: [^false].	1 to: self path size 		do: [ :ind |			(self pathAt: ind) = (aURI pathAt: ind ) ifFalse: [ ^false ]].	^true</body><body package="URISupport" selector="stringRepresentationPartsMatch:">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^self path = aURI path		and: [self query = aURI query			and: [self fragment = aURI fragment]]</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>printing</category><body package="URISupport" selector="printPathOn:">printPathOn: aStream 	self path size = 0		ifTrue: [aStream nextPutAll: '/']		ifFalse: 			[1 to: self path size  do: [ :ind | aStream nextPutAll: '/', (self pathAt: ind)]].</body><body package="URISupport" selector="printPathStringOn:">printPathStringOn: aStream 	path size = 0		ifTrue: [aStream nextPutAll: '/']		ifFalse: [path do: [:s | aStream nextPutAll: '/', s]].</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>converting</category><body package="URISupport" selector=",">, aURI	^self resolvePath: aURI</body><body package="URISupport" selector="asPartial">asPartial	| stream |	stream := String new writeStream.	self printPathStringOn: stream.	self storeExtrasOn: stream.	^PartialURL fromString: stream contents</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>copying</category><body package="URISupport" selector="postCopy">postCopy	super postCopy.	path := path copy.	query := query copy</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>deprecated</category><body package="URISupport" selector="resolveRelativePath:">resolveRelativePath: pathString"	This method is now deprecated. pathString can be a PartialURL or a string and it will be judged as to whether it is relative or not by a leading /, eg:'/example.ext' asURI is absolute, while:'example.ext' asURI is relative"	^self resolvePath: pathString</body></methods><methods><class-id>OS.URLwithPath class</class-id> <category>instance creation</category><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	| index host path |	('//*' match: aString)		ifFalse: [self error: (#URLDoesNotBeginWithProtocol &lt;&lt; #net &gt;&gt; 'URL does not begin with "protocol://"')].	index := (3 to: aString size) detect: [:i | '/?#' includes: (aString at: i)] ifNone: [].	index = nil		ifTrue:			[host := aString copyFrom: 3 to: aString size.			path := '']		ifFalse:			[host := aString copyFrom: 3 to: index-1.			(aString at: index ) = $/				ifTrue: [path := aString copyFrom: index+1 to: aString size]				ifFalse: [path := aString copyFrom: index to: aString size]].	^self host: host pathString: path</body><body package="URISupport" selector="host:path:">host: aHost path: aPath	^(self newWithPath: aPath)		parseHost: aHost;		yourself</body><body package="URISupport" selector="host:pathString:">host: aHost pathString: aPath	^self 		resolvePath: aPath 		do: [:pList :qString :fString |			(self host: aHost path: pList)				query: qString;				fragment: fString;				yourself]</body><body package="URISupport" selector="newWithPath:">newWithPath: aCollection	^(self new 		path: (self encodePath: aCollection);		yourself)</body></methods><methods><class-id>OS.URLwithPath class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^String new</body></methods><methods><class-id>OS.URLwithPath class</class-id> <category>encoding/decoding</category><body package="URISupport" selector="encodePath:">encodePath: aCollection	^aCollection collect: 		[ :component | 	self encode: component  allowed: self pathAllowedChars ]</body></methods><methods><class-id>OS.URLwithPath class</class-id> <category>private</category><body package="URISupport" selector="resolvePath:do:">resolvePath: string do: aBlock	| pString idx frag query list |	pString := string.	(pString includes: $#)		ifTrue:			[idx := pString indexOf: $#.			frag := pString copyFrom: idx+1 to: pString size.			pString := pString copyFrom: 1 to: idx-1]		ifFalse: [frag := nil].	(pString includes: $?)		ifTrue:			[idx := pString indexOf: $?.			query := pString copyFrom: idx+1 to: pString size.			pString := pString copyFrom: 1 to: idx-1]		ifFalse: [query := nil].	list := pString tokensBasedOn: $/.	^aBlock value: list value: query value: frag.</body></methods><methods><class-id>OS.PartialURL</class-id> <category>testing</category><body package="URISupport" selector="hasNoPath">hasNoPath	^path size = 1 and: [path first isEmpty]</body><body package="URISupport" selector="isAbsolute">isAbsolute	^path size &gt; 1 and: [path first isEmpty]</body><body package="URISupport" selector="isPartial">isPartial	^true</body></methods><methods><class-id>OS.PartialURL</class-id> <category>private</category><body package="URISupport" selector="mergeAbsolutePath:">mergeAbsolutePath: aPath	self path: aPath</body></methods><methods><class-id>OS.PartialURL</class-id> <category>printing</category><body package="URISupport" selector="printPathOn:">printPathOn: aStream 	self path isEmpty ifTrue: [^self].	1 to: self path size do: [ :ind | aStream nextPutAll: (self pathAt: ind); nextPutAll: '/'].	aStream skip: -1</body><body package="URISupport" selector="printPathStringOn:">printPathStringOn: aStream 	self printPathOn: aStream</body></methods><methods><class-id>OS.PartialURL</class-id> <category>accessing</category><body package="URISupport" selector="asString">asString	| stream |	stream := String new writeStream.	self printPathStringOn: stream.	self storeExtrasOn: stream.	^stream contents</body></methods><methods><class-id>OS.PartialURL class</class-id> <category>instance creation</category><body package="URISupport" selector="fromString:">fromString: aString	^self 		resolvePath: aString 		do: [:pList :qString :fString |			(self newWithPath: pList)				query: qString;				fragment: fString;				yourself]</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>accessing</category><body package="URISupport" selector="asString">asString	| str |	str := (String new: 64) writeStream.	self printProtocolOn: str.	self printAuthorityOn: str.	^str contents</body><body package="URISupport" selector="client">client	^self subclassResponsibility</body><body package="URISupport" selector="defaultPortNumber">defaultPortNumber	^self class defaultPortNumber</body><body package="URISupport" selector="host">host	^host</body><body package="URISupport" selector="port">port	^port isNil 		ifTrue: [ port := self defaultPortNumber]		ifFalse: [ port ]</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>comparing</category><body package="URISupport" selector="hash">hash	^super hash bitXor: (self host hash bitXor: self port hash)</body><body package="URISupport" selector="sameAs:">sameAs: aURI	^(super sameAs: aURI)		and: [ ( host match: aURI host )			and: [ self port = aURI port ]]</body><body package="URISupport" selector="stringRepresentationPartsMatch:">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^(super stringRepresentationPartsMatch: aURI)		and: [self host = aURI host			and: [self port = aURI port]]</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>initialize</category><body package="URISupport" selector="host:port:">host: aString port: aNumber	host := aString.	port := aNumber.</body><body package="URISupport" selector="parseHost:">parseHost: aHostSpecification	self parseHostPort: aHostSpecification</body><body package="URISupport" selector="parseHostPort:">parseHostPort: fullHost	| idx pString |	(fullHost includes: $:)		ifTrue:			[idx := fullHost indexOf: $:.			host := self validateHost: (fullHost copyFrom: 1 to: idx-1).			(pString := fullHost copyFrom: idx+1 to: fullHost size) isEmpty				ifTrue: [ port := self defaultPortNumber ]				ifFalse: [ port := self validatePort: pString ]]		ifFalse:			[host := self validateHost: fullHost.			port := self defaultPortNumber]</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>printing</category><body package="URISupport" selector="printAuthorityOn:">printAuthorityOn: aStream	aStream nextPutAll: host.	self port ~= self defaultPortNumber ifTrue: [aStream nextPutAll: ':'; print: self port].	self printPathStringOn: aStream.	self storeExtrasOn: aStream.</body></methods><methods><class-id>OS.URLwithAuthority class</class-id> <category>defaults</category><body package="URISupport" selector="defaultPortNumber">defaultPortNumber	^80</body></methods><methods><class-id>OS.UriEncodedStreamConstructor</class-id> <category>streams</category><body package="URISupport" selector="appendStream">appendStream	"Answer a write stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="newReadAppendStream">newReadAppendStream	"Answer a new readAppend stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="newReadWriteStream">newReadWriteStream	"Answer a new readWrite stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="readAppendStream">readAppendStream	"Answer a readAppend stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="readStream">readStream	"Answer a read stream connected to the file represented by	the receiver."	^self addEncodingTo: dataRepository binaryReadStream</body><body package="URISupport" selector="readWriteStream">readWriteStream	"Answer a readWrite stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="writeStream">writeStream	"Answer a write stream connected to the file represented by	the receiver."	^self addEncodingTo: dataRepository binaryWriteStream</body></methods><methods><class-id>OS.FileURL</class-id> <category>resolution</category><body package="URISupport" selector="addComponent:">addComponent: aFileComponent	self privateAddComponent: aFileComponent.	self normalize</body></methods><methods><class-id>OS.FileURL</class-id> <category>accessing</category><body package="URISupport" selector="asFilename">asFilename	| path2 fn |	^missingSlashes		ifTrue: [self path asFilename]		ifFalse:			[path2 := (1 to: path size) collect: [:i | self pathAt: i].			host == nil				ifTrue: [Filename rootComponents: path2]				ifFalse:					[fn := (Filename pathForRemoteHost: host) asFilename.					path2 do: [:s | fn := fn construct: (fn class decodePortableComponent: s)].					fn]]</body><body package="URISupport" selector="asFilename:">asFilename: filenameClass	"Useful for doing testing"	| path2 fn |	^missingSlashes		ifTrue: [filenameClass named: self path]		ifFalse:			[path2 := (1 to: path size) collect: [:i | self pathAt: i].			host == nil				ifTrue: [filenameClass rootComponents: path2]				ifFalse:					[fn := filenameClass named: (filenameClass pathForRemoteHost: host).					path2 do: [:s | fn := fn construct: (fn class decodePortableComponent: s)].					fn]]</body><body package="URISupport" selector="asString">asString	| str |	str := (String new: 64) writeStream.	^missingSlashes		ifTrue: [str nextPutAll: 'file:'; nextPutAll: self path asString.			self storeExtrasOn: str.			str contents]		ifFalse:			[str nextPutAll: 'file://'.			host == nil ifFalse: [str nextPutAll: host].			str nextPutAll: '/'.			path do: [:i | str nextPutAll: i] separatedBy: [str nextPutAll: '/'].			self storeExtrasOn: str.			str contents]</body><body package="URISupport" selector="host:">host: aHost	host := aHost</body><body package="URISupport" selector="missingSlashes:">missingSlashes: aBoolean	missingSlashes := aBoolean</body><body package="URISupport" selector="path:">path: aPath	super path: aPath.	missingSlashes := false</body><body package="URISupport" selector="resource">resource	^XML.InputSource		uri: self		encoding: nil		stream: (self asFilename withEncoding: #UTF_8) readStream lineEndTransparent</body></methods><methods><class-id>OS.FileURL</class-id> <category>stream creation</category><body package="URISupport" selector="binaryReadStream">binaryReadStream	^(self asFilename withEncoding: #binary) readStream</body><body package="URISupport" selector="binaryWriteStream">binaryWriteStream	^(self asFilename withEncoding: #binary) writeStream</body><body package="URISupport" selector="readStreamDo:">readStreamDo: aBlock	| stream params | 	stream := (self asFilename withEncoding: #binary) readStream.	params := Dictionary new.	params at: #MIME put: self guessMimeType.	^[aBlock value: stream value: params] ensure: [stream close]</body><body package="URISupport" selector="writeStreamDo:">writeStreamDo: aBlock	| stream  |	stream := (self asFilename withEncoding: #binary) writeStream.	^[aBlock value: stream] ensure: [stream close]</body></methods><methods><class-id>OS.FileURL</class-id> <category>utilities</category><body package="URISupport" selector="delete">delete	self asFilename delete</body><body package="URISupport" selector="fileSize">fileSize	^self asFilename fileSize</body><body package="URISupport" selector="makeDirectory">makeDirectory	self asFilename makeDirectory</body><body package="URISupport" selector="tail">tail	^self asFilename tail</body></methods><methods><class-id>OS.FileURL</class-id> <category>file utilities</category><body package="URISupport" selector="directoryContents">directoryContents	^self asFilename directoryContents		collect: [:s | self withSimpleComponent: s]</body></methods><methods><class-id>OS.FileURL</class-id> <category>testing</category><body package="URISupport" selector="exists">exists	^self asFilename exists</body><body package="URISupport" selector="isDirectory">isDirectory	^self asFilename isDirectory</body></methods><methods><class-id>OS.FileURL</class-id> <category>private</category><body package="URISupport" selector="host">host	^host</body><body package="URISupport" selector="normalize">normalize	2 to: path size do: [:i |		((path at: i) = '..' and: [(path at: i-1) ~= '.' and: [(path at: i-1) ~= '..']])			ifTrue:				[path := (path copyFrom: 1 to: i-2), (path copyFrom: i+1 to: path size).				^self normalize].		(path at: i) = '.'			ifTrue:				[path := (path copyFrom: 1 to: i-1), (path copyFrom: i+1 to: path size).				^self normalize]].</body></methods><methods><class-id>OS.FileURL</class-id> <category>comparing</category><body package="URISupport" selector="hash">hash	^super hash bitXor: self host hash</body><body package="URISupport" selector="stringRepresentationPartsMatch:">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^(super stringRepresentationPartsMatch: aURI)		and: [self host = aURI host]</body></methods><methods><class-id>OS.FileURL class</class-id> <category>instance creation</category><body package="URISupport" selector="fromFilename:">fromFilename: aFilename	| p |	p := aFilename uriComponents.	^(p respondsTo: #key)		ifTrue: 			[ (self newWithPath: p value)					host: p key; 					yourself]		ifFalse:[self newWithPath: p]</body><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	"Lame override of the superclass because tests	supplied by Sun to OASIS use wierd syntax with	file: protocol."	"This approach puts a String in the path, which	should only be a Filename. This is required to	avoid canonicalizing the file name, but results in	an URL that can do nothing other than answer	the string which created it."	('//*' match: aString)		ifFalse: [^self new path: aString; missingSlashes: true].	^super fromString: aString</body><body package="URISupport" selector="host:path:">host: aHost path: aPath	^(#('' 'localhost') includes: aHost)		ifTrue: [ self newWithPath: aPath]		ifFalse: [ (self newWithPath: aPath) host: aHost; yourself ]</body></methods><methods><class-id>OS.FileURL class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^'file'</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="URISupport" selector="asURI">asURI	"Answer a URI named the receiver."	^URI fromString: self string</body></methods><methods><class-id>OS.Filename</class-id> <category>converting</category><body package="URISupport" selector="asURI">asURI	^FileURL fromFilename: self</body></methods><methods><class-id>OS.Filename</class-id> <category>private</category><body package="URISupport" selector="uriComponents">uriComponents	| list |	list := (self class components: self asString) asArray.	self isRelative		ifTrue: [list := #('.'), list].	^list</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>private</category><body package="URISupport" selector="uriComponents">uriComponents	"#('/' '/a/b/c' 'a/b/c' '../a/b')		collect: [:i || f |			f := (UnixFilename named: i).			f asString = (f asURI asFilename: UnixFilename) asString]"	| list |	list := super uriComponents.	list size = 0		ifFalse: [list first = '/'			ifTrue: [list := list copyFrom: 2 to: list size]].	^list</body></methods><methods><class-id>OS.Filename class</class-id> <category>instance creation</category><body package="URISupport" selector="rootComponents:">rootComponents: path	"Answer a new Filename with the supplied path.	Unless the first element of the path explicitly specifies	the local directory as the starting point of the path, the	resulting name should be modified to be an absolute	path name. For portability, '.' will be used to specify	the local directory as the starting point, even though on	Mac OS and possibly others a different convention is	used. Using '.' allows the path to refer to relative path	names in a platform independent way."	| stream filename |	path isEmpty ifTrue: [^self concreteClass fromRootComponent: ''].	stream := path readStream.	filename := self concreteClass fromRootComponent: stream next.	[stream atEnd] whileFalse:		[filename := filename construct:				(self concreteClass decodePortableComponent: stream next)].	^filename</body></methods><methods><class-id>OS.Filename class</class-id> <category>private</category><body package="URISupport" selector="decodePortableComponent:">decodePortableComponent: aString	"Translate portable path notation (which for example uses '..'	to represent the parent directory) into the host equivalent"	^aString</body></methods><methods><class-id>OS.PCFilename</class-id> <category>private</category><body package="URISupport" selector="uriComponents">uriComponents	"#('\' '\a\b\c' 'a\b\c' 'c:\a\b' '\\romulan' '\\romulan\'			'\\romulan\disk' '\\romulan\disk\' '\\romulan\disk\a' '..\a\b')		collect: [:i || f |			f := (PCFilename named: i).			f asString = (f asURI asFilename: PCFilename) asString]"	| list idx host |	list := super uriComponents.	list size = 0		ifFalse: [list first = '\'			ifTrue: [list := list copyFrom: 2 to: list size]			ifFalse: [('#:\' match: list first)				ifTrue: [list at: 1 put: (list first copyWithout: $\)]				ifFalse: [('\\*\*\' match: list first)					ifTrue:						[idx := list first nextIndexOf: $\ from: 3 to: list first size.						host := list first copyFrom: 3 to: idx-1.						list at: 1 put: (list first copyFrom: idx+1 to: list first size-1).						list := host -&gt; list]					ifFalse: [('\\*\' match: list first)					ifTrue:						[host := list first copyFrom: 3 to: list first size-1.						list := host -&gt; (list copyFrom: 2 to: list size)]]]]].	^list</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>EncodedStreamConstructor</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataRepository encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>UnixFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>PCFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class></st-source>