<?xml version="1.0"?><st-source><!-- Name: StoreBaseNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.BundleName: StoreBaseBundleStructure: a Store.BundleForParcelComment: Store adds team development and version control tools and facilities to the VisualWorks development environment. To load this parcel, you should instead load one (or several) of the following parcels:	StoreForOracle8, StoreForSQLServer, StoreForPostgreSQLwhich will then load this parcel as a prerequisite.Further information on Store can be found in the "Source Code Management Guide" (located in the /doc subdirectory of the VisualWorks installation).DevelopmentPrerequisites: #(#(#any 'BOSS' '') #(#any 'LDM-Framework' '') #(#any 'LoggingTool' '') #(#any 'Database' '') #(#any 'Glorp' '') #(#any 'GlorpVWPort' ''))IsLoadOrderWarningSuppressed: truePackageName: StoreBaseParcel: nilParcelName: StoreBasePrerequisiteDescriptions: #(#(#name 'BOSS') #(#name 'LDM-Framework') #(#name 'LoggingTool') #(#name 'Database') #(#name 'Glorp' #componentType #bundle) #(#name 'GlorpVWPort' #componentType #package))PrerequisiteParcels: #(#('BOSS' '') #('LDM-Framework' '') #('LoggingTool' '') #('Database' '') #('Glorp' '') #('GlorpVWPort' ''))Version: 7.8 - 1192Pre-Load Block: 	[ :pkg |  ]Post-Load Block: 	[ :pkg |  Store.PundleAccess postLoadActionFor: pkg.]Pre-Unload Block: 	[ :pkg |  Store.PundleAccess preUnloadActionFor: pkg.]Post-Unload Block: 	[]Date: 9:14:21 AM March 11, 2011 --><time-stamp>From VisualWorks®, 7.8 of March 4, 2011 on March 11, 2011 at 9:14:21 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Glorp</name><environment>Store</environment><private>false</private><imports>			private Glorp.*			private Smalltalk.*			</imports><category></category><attributes><package>Store-Base</package></attributes></name-space><comment><name-space-id>Store.Glorp</name-space-id><body>Store.Glorp namespace for all Store Database classes. </body></comment><name-space><name>UI</name><environment>Glorp</environment><private>false</private><imports>			private Glorp.*			private Store.*			private Smalltalk.*			</imports><category>StoreForGlorpVWUI</category><attributes><package>StoreForGlorpBrowserUI</package></attributes></name-space><comment><name-space-id>Glorp.UI</name-space-id><body>This is a namespace for Glorp tools and UI work.</body></comment><class><name>BasicOwnershipPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.BasicOwnershipPolicy</class-id><body>BasicOwnershipPolicy is a blessing policy which allows full access to the system (in effect, a "no ownership" policy)</body></comment><class><name>OwnerOwnershipPolicy</name><environment>Store</environment><super>Store.BasicOwnershipPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.OwnerOwnershipPolicy</class-id><body>OwnerOwnershipPolicy is a basic ownership policy which confirms publish, owner and read rights to packages and bundles for users and groups</body></comment><class><name>AbstractTool</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.AbstractTool</class-id><body>This was once the superclass of all Store browsers. Slowly, but surely, this guy is going obsolete.Subclasses must implement the following messages:	selection		pundles		pundleVersionsClass Variables:	DbBundleImage	&lt;CachedImage&gt;  comment	DbNonCodePackageImage	&lt;CachedImage&gt;  comment	DbPackageImage	&lt;CachedImage&gt;  comment	IsMonocrome	&lt;Boolean&gt;  comment	ModifiedBundleImage	&lt;OpaqueImage&gt;  comment	ModifiedNonCodePackageImage	&lt;OpaqueImage&gt;  comment	ModifiedPackageImage	&lt;OpaqueImage&gt;  comment	UnmodifiedBundleImage	&lt;CachedImage&gt;  comment	UnmodifiedNonCodePackageImage	&lt;CachedImage&gt;  comment	UnmodifiedPackageImage	&lt;CachedImage&gt;  comment</body></comment><class><name>TextDifferenceBrowser</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text2 text1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI-Comparitors</package></attributes></class><comment><class-id>Store.TextDifferenceBrowser</class-id><body>TextDifferenceBrowser is a simple view of two texts (passed in as strings) with their differences highlightedInstance Variables	text1	&lt;ValueModel&gt;	One string as text	text2	&lt;ValueModel&gt;	Another string as text</body></comment><class><name>MethodDifferenceBrowser</name><environment>Store</environment><super>Store.TextDifferenceBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol1 protocol2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI-Comparitors</package></attributes></class><comment><class-id>Store.MethodDifferenceBrowser</class-id><body>MethodDifferenceBrowser is used to display the differences between two methods showing their protcol.Instance Variables	protocol1	&lt;ValueHolder&gt;	the text of the left hand side protocol	protocol2	&lt;ValueHolder&gt;	the text of the right hand side protocol</body></comment><class><name>LoadOrSaveActionError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveActionError</class-id><body>LoadOrSaveActionError is an abstract error for several load/save action problems</body></comment><class><name>LoadOrSaveEvaluationError</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveEvaluationError</class-id><body>LoadOrSaveEvaluationError is raised if the action can not be evaluated</body></comment><class><name>GraphTool</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.GraphTool</class-id><body>GraphTool is the abstract superclass of the VersionGraph tool, used to graph versions of objects in storeInstance Variables	graphView	&lt;LensGraphView&gt;	description of graphView</body></comment><class><name>VersionGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.VersionGraph</class-id><body>VersionGraph is the tool that displays the graphed version of store objectsInstance Variables	pundle	&lt;CodeComponent | FileModel | PseudoPackage | Pundle | StorePundle&gt;	description of pundle</body></comment><class><name>AbstractComparisonRollupView</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expandedFraction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.AbstractComparisonRollupView</class-id><body>All of the views in the comparison tools that have a triangular disclosure button to expand or collapse, are a subclass of this abstract class.UsageI implement a number of the basic behaviors of the expandable/collapsable rows used in the comparison tools. All of the actual expansion/collapsing is handled by me. Subc;lasses may use the #expansionChangeBeginning and #expansionChangeFinished methods as hooks to react changes in expansion.Nominally, I break myself down into two parts. The "header" refers to the main row that is always visible, whether expanded or not. The part that shows more when expanded is called the detailsPanel. Most of this is constructed by myself in the view construction method category.The header is populated with the disclosure triangle by me, subclasses override the method #populateHeader (with a call to the super version) to further populate the header. Some subclasses like to place an '...' graphic at the end of the header to show further details via a popup. This can be accessed be sending #moreIntoTooltipHandle. Subclasses return lines to go in the tooltip by answering an array of methods to send with #tooltipTextChunks method. The header may have a pop up menu. The menu is generated from methods tagged with the &lt;menu: aNumber&gt; tag. A subclass that potentiall has a menu should respond true to the message #hasMenu. Some common menu action methods shared amongst some subclasses exist in the menu-methods category.The detailsPanel is populated lazily, the first time it is opened. Subclasses return an array of rows to go in the details section by adding a subclass implementation of #computeDetailRows. Usually, the rows that are returned, are further created by sending #newRow to self, and then add:'ing the desired parts to it.I also support a mechanism for providing some memory for me and my children that were expanded. This is used when throwing a whole tree of these, and creating a new tree, but wanting similiar views to have the same expanded state. The methods that support this are found in the 'private-expansion memory' method category.Instance Variables	expandedFraction	&lt;Number&gt;	at rest, a value of 0 (collapsed) or 1 (expanded), is values in between to animate the "rollup/rolldown" of the view</body></comment><class><name>BindingBlueprintComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightBlueprint leftBlueprint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.BindingBlueprintComparisonView</class-id><body>I am the abstract class for comparison of any of the system structuring "objects", namely classes, shared variables, and namespaces.Usage	Aspects that are common between the comparison rollups for classes, shares, and namespaces are found in me. I further specialize my parent in the following ways:	1) I always have a left and right blueprint, but one may be nil, indicating that the particular object being shown is either either added (if left is nil) or removed (if right is nil). I add + or x overlays to various icons when it is a removal or addition.	2) I will populate the header with the name of the object, and an icon, either pulled from the live system associated object, or with the result of #defaultIcon method, which subclasses must provide.	3) When collapsed and not a remove or add (indicating a change), I show a set of icons (with counts if approprirate) after the object name in parentheses. Subclasses return these by returning the appropriate icons for the rows that will be shown when expanded; they do so by overriding the #detailHintGraphics method.	4) Which changes are shown is worked out by the #bindingDetailSelectors and the #enumerateBindingDetailChanges: methods. Subclasses are responsible to return rows in either singular mode (when this object is added or removed) or comparison mode (when this object is changed), for these specific details. I provide methods for the two details that are common to all subclass types: package information, and isPrivate information.	5) To locate the image counterpart or a blueprint (if there is one), subclasses must implement the #bindingTest method which is a test method that can be sent against the binding referennce of the object (e.g. #isForGeneral, #isForClass, #isForNamespace), this aids in interpreting the the binding refence of the blueprints.	6) There are no setters for leftBlueprint or rightBlueprint, instead subclasses provide specifically named setters for these (e.g. leftNamespace:, etc).Instance Variables	leftBlueprint	&lt;BindingBlueprint&gt;	the original class, shared, or namespace blueprint	rightBlueprint	&lt;BindingBluprint&gt;	the changed or evolved class, shared, or namespace blueprintSubclass Responsibility	private		bindingTest	utility-menu		versionListPaneClass	view construction		defaultIcon</body></comment><class><name>SharedVariableBlueprintComparisonView</name><environment>Tools</environment><super>Tools.BindingBlueprintComparisonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.SharedVariableBlueprintComparisonView</class-id><body>SharedVariable specific variant for showing shared variable changes.ImplementationMost of my behavior is derived from my super class, I just provide the required queries: bindingTest, defaultIcon, and detail rows for initializer, isConstant, and category. My leftBlueprint and rightBlueprint objects should be nil or SharedVariableBlueprints.One specialization I do, is rather than just show the name of the share in the header, I show the Namspace.ShareName.</body></comment><class><name>StoreCodeComponentInspectorField</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentInspectorField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentInspectorField</class-id><body>StoreCodeComponentInspectorField is used when browsing Store/Glorp database objects</body></comment><class><name>LostConnectionError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.LostConnectionError</class-id><body>LostConnectionError is signalled when we unexpectedly have no database connection.</body></comment><class><name>InstallUserManagementPolicies</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.InstallUserManagementPolicies</class-id><body>InstallUserManagementPolicies asks the user if they want to install user management policies.default value is true</body></comment><class><name>StoreObject</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreObject</class-id><body>This is an abstract superclass for Store domain objects. These serve several possible purposes. First, they provide a set of domain objects represent the data in the store database, which can be examined and manipulated more easily than tables. Second, they can be used to stand in for the corresponding image objects (for those that have corresponding image objects). So we can take a StorePackage and give it to the browser, which might think it is browsing a PackageModel with references to actual classes and methods, but will actually be browsing the database. Third, they can be used to stand in for Store database objects. So we can have Store believe it is manipulating a Package object with a collection of records, but actually have it be manipulating our domain objects. This lets us take advantage of some more efficient querying and other mechanisms without needing to rewrite all of the Store infrastructure.Instance Variables:	primaryKey	&lt;Integer&gt;	The primary key of the corresponding row in the database.</body></comment><class><name>StoreSourceObject</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trace username timestamp name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSourceObject</class-id><body>This is an abstract superclass for for most of the Store entities, representing the common structure among them. Most of these (but not all) are the entities that would exist in Smalltalk source code.Instance Variables:	name	&lt;String&gt;	The name of the entity.	timestamp	&lt;Timestamp&gt;	The timestamp of when it was published.	trace	&lt;self class&gt;	The previous version of ourselves.	username	&lt;String&gt;	The name of the user who published this.</body></comment><class><name>StoreParcelRecord</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blob source filename </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreParcelRecord</class-id><body>StoreParcelRecord represents a parcel record in the database, part of a binary publish. It just holds onto blobs for the source and the binary representation.Instance Variables:	blob	&lt;StoreBlob&gt;	The parcel bits.	filename	&lt;String&gt;	The parcel file name.	source	&lt;StoreBlob&gt;	The source code for the parcel.</body></comment><class><name>AtomicCompilationManager</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results root pundle failedInitializations installedEarly </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AtomicCompilationManager</class-id><body>AtomicCompilationManager is the master manager for all compilation and loading. It calls other managers (or code reader for Parcl) as needed for loading and compiling packages and bundles.Instance Variables	pundle	&lt;Pundle | StorePundle&gt;	The current Pundle that is being loaded	results	&lt;(Collection of: (CodeReader | AtomicCompilationResult | BundleCompilationResult | PackageCompilationResult))&gt;		root	&lt;NameSpace&gt;	The root shadow namespace.	failedInitializations &lt;(Collection of: (Class initializations or something)&gt;	installedEarly	&lt;Boolean&gt; True if because of compiler/scanner reasons, we installed early. False if a fully atomic load is possible</body></comment><class><name>DBObject</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>table nextIndex SequenceGeneratorSession </class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.DBObject</class-id><body>DBObject is an abstract superclass for all of the store database objects. It provides the basic functionallity for objects being stored in the database as well as class methods for class/table installation.Common methods for subclasses to redefine:	prime  	"Fill slots that do not map to table columns with instances of Object"	unprime "Nil out the slots that do not map to table columns"	preDatabaseInstall "prep work to perform before creating record."	postDatabaseInstall</body></comment><class><name>DBRecord</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey name timeStamp version userName trace dbIdentifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.DBRecord</class-id><body>DBRecord is the generic superclass for firstclass db records. Instance Variables:	dbIdentifier	&lt;Symbol&gt;	identity of the database this record lives in	name	&lt;String&gt;  the object's name 	primaryKey	&lt;Integer&gt; the object's primaryKey in the database	timeStamp	&lt;Integer&gt; publication time in miliseconds minus a #timeOffset	trace	&lt;Integer&gt; primaryKey of the objects parent	userName	&lt;String&gt; user who published this record	version	&lt;String&gt; version string</body></comment><class><name>Record</name><environment>Store</environment><super>Store.DBRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>PrimaryKeySession </class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.Record</class-id><body>The only immediate subclass of DBRecord whose reason de existance is not apparent.</body></comment><class><name>ViewRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.ViewRecord</class-id><body>ViewRecords represent database views that define a logical view of  joined tables.</body></comment><class><name>DataView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef definitionID commentID environmentString protocolName typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.DataView</class-id><body>DataView has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	commentID	&lt;Integer&gt;  link to blob table pointing to the comment	definitionID	&lt;Integer&gt;  link to blob table pointing to shared's definition	environmentString	&lt;String&gt; environment strng of class or namespace that owns the shared	packageRef	&lt;Integer&gt;  link to package	protocolName	&lt;string&gt; data protocol	typeString	&lt;String&gt;	saved as Char. appears obsolete</body></comment><class><name>DataAndSourcesView</name><environment>Store</environment><super>Store.DataView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.DataAndSourcesView</class-id><body>Extends DataView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	DataWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>StorePundleWriter</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle newPundle previousVersionInTargetDatabase targetSession preWriteAction splitPundles notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePundleWriter</class-id><body>This writes an individual bundle or package version.Instance Variables	pundle							&lt;StorePundle&gt;	The thing we're writing.	newPundle						&lt;StorePundle&gt;	The new pundle we've created, ready to be written to the database.	previousVersionInTargetDatabase	&lt;StorePundle&gt;	The previous version, if there is one.	targetSession 					&lt;GlorpSession&gt;	The target database.	notificationQueue				&lt;SharedQueue | nil&gt;	The shared queue for progress indications	preWriteAction					&lt;Block | nil&gt; An assignable one parameter block that will be executed before the write takes place.	splitPundles						&lt;Boolean&gt;	True if sub-bundles should be written in separate sub-publishes	targetDatabaseIdentifier			&lt;Symbol&gt;	The id of the target database	targetSession					&lt;GlorpSession&gt;	The glorp session which does the transaction writing</body></comment><class><name>FileOutClassDoesntExistError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.FileOutClassDoesntExistError</class-id><body>FileOutClassDoesntExist is raised when filing out a Class from an XChangeShet and it no longer exists in the image</body></comment><class><name>StoreProgressOverlay</name><environment>Store</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalDisplayPolicy background dropdownGradient </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StoreProgressOverlay</class-id><body>This is used to 'subsume' a Window with a topmost view which shows StoreWorkActivity feedback, and locks out any other user interaction.ImplementationThis view grabs the current component of the Window it is about to subsume, and then places itself in between the original top view and the Window. It then adds a StoreProgressView to show an StoreWorkActivity during its life cycle.On restoration, it removes itself form the view tree, and reattaches the 'regularView' as the window's top component.To keep things looking smooth, during it's life cycle, it installs a DoubleBufferingDisplayPolicy on the Window, but remembers the original so that it can restore that during restoration.Instance Variables	background	&lt;Image&gt;	A canned picture of the 'regularView', which is then "grayed" out to make the window contents look disabled. It is lazily managed.	originalDisplayPolicy	&lt;WindowDisplayPolicy&gt;	the damageRepairPolicy noticed at subsumption time and restored at restoreOriginal time</body></comment><class><name>AbstractModification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.AbstractModification</class-id><body>AbstractModification is the superclass for Modification and TextModificationSubclasses must implement the following messages:	accessing		description		existsInPackage		source		timeStampString	actions		apply	change list support		sameAsSystem	comparing		=	testing		notOriginallyInImageInstance Variables:	package	&lt;PundleModel&gt;	The current package or bundle being modified	tag	&lt;MethodTag&gt;	The method</body></comment><class><name>InvalidStorePundleError</name><environment>Store.Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpReplication</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.InvalidStorePundleError</class-id><body>We raise this exception when we are attempting to write out a pundle, either directly or by replication, and detect an error in its structure (e.g. duplicate methods). Instance Variables:	pundle	&lt;StorePundle&gt;	The pundle we had a problem with.</body></comment><class><name>PundleChangeList</name><environment>Store</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>pundle conflictPundle dbIdentifier conflictCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PundleChangeList</class-id><body>Each BundleModel or PackageModel that has been published to a database is aware of its modifications with respect to its parent in that database.  One way to obtain these modifications is to send #modifications or #modificationsFor: to an instance of one of these models.  PundleChangeList displays these changes in the conventional ChangeList format that one might see when opening up a ChangeList on a file.  To help cache database queries, the conflictCache instance variable is used to provide a map between these modification instances and their respective record in the database.  Instance Variables:	conflictCache	&lt;IdentityDictionary&gt;	Described above	conflictPundle	&lt;Package | Bundle&gt;	The parent record for pundle	dbIdentifier	&lt;Symbol&gt;	The unique database ID that identifies which database the modifications are recorded against	pundle	&lt;PackageModel | BundleModel &gt; The pundle that is in the image</body></comment><class><name>StoreDescriptorSystem</name><environment>Store.Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDescriptorSystem</class-id><body>This is a descriptor system for a set of domain objects representing Store database entities. It also has subclasses representing the different evolutionary stages of the schema.</body></comment><class><name>Store73DescriptorSystem</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.Store73DescriptorSystem</class-id><body>This is a subclass which includes the changes made for version 7.3. This specifically means - adding a commentId field to Method - add PropertiesRecord and the Properties link table - add FileRecord and the Files link table</body></comment><class><name>ContainsUndeclaredError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.ContainsUndeclaredError</class-id><body>ContainsUndeclaredError is raised whe trying to publish a Package which has undeclared items</body></comment><class><name>ShadowPackageCompileManager</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root package shadowObjects shadowCompiler unloadableDefinitions packageComparitor isAtomicallyLoadable overrides notificationQueue compilationManager externalClassesNeedingRecompile methodsMovedFromOriginalBinding needsEarlyInstall </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowPackageCompileManager</class-id><body>ShadowPackageCompileManager compiles and then loads a StorePackage. When done, it answers an AtomicLoadResultInstance Variables	shadowCompiler	&lt;ShadowCompiler&gt;	This is the object that actually executes any compilation, which we collect	packageDifferences	&lt;PackageDifferences&gt;	When loading an update, this contains the difference between what is in the image and the StorePackage	isAtomicallyLoadable	&lt;Boolean&gt;	Figures out if after we are compiled, we are loadable	overrides	&lt;Collection&gt;	 Collection of Override objects we need to install	package	&lt;StorePackage&gt;	This is the StorePackage we are compiling and loading	root	&lt;Namespace&gt;	The shadow copy of the root namespace we are doing our compiling in	shadowObjects	&lt;(OrderedCollection of: (CompiledMethod))&gt;	Once an object is compiled in the shadow namespace, these are the objects that have successfully been created, ready to be atomically loaded	unloadableDefinitions	&lt;Collection&gt;	This is a collection of any things I can't compile	compilerManager	&lt;AtomicCompilationManager&gt; The manager that manages the world	externalClassesNeedingRecompile	&lt;Collection of: ExternalInterface&gt;	These are classes that need to be recompiled after installing	methodsMovedFromOriginalBinding &lt;Collection of: CompiledMethod&gt;	If a definition was on a Class but that class is now a Shared that points to a different class, we collect up those methods here	needsEarlyInstall	&lt;Boolean&gt; False (default) if an early install condition is not seen</body></comment><class><name>StoreBrowserCodeTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserCodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserCodeTool</class-id><body>StoreBrowserCodeTool is used when browsing Store/Glorp database objects</body></comment><class><name>DBUserGroup</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>groupName userName type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.DBUserGroup</class-id><body>DBUserGroup is obsolete in 7.8 and beyond</body></comment><class><name>PrerequisiteUnableToLoadConfirmation</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.PrerequisiteUnableToLoadConfirmation</class-id><body>PrerequisiteUnableToLoadConfirmation is raised when a prerequisite is unable to be satisfied.</body></comment><class><name>StoreForGlorpNavigator</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreForGlorpNavigator</class-id><body>I manage the classes and methods for the Store Browser.</body></comment><class><name>AbstractTag</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol isMeta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.AbstractTag</class-id><body>This abstract class provides the information needed to reference code objects (that are class based) apart from any version information.  A (tag,package/version) pair should reference any code object.  This class is intended to provide a uniform way of referencing class names.Subclasses must implement the following messages:	accessing		containingPackage		description		sourceTextForImage	actions		compileText:from:		moveToPackage:ifNotLoaded:	change list support		browseSystemVersion		fileOutOn:		fileOutOn:from:		fileOutRemovalOn:	converting		recordForPackage:	private-loading		applyDefinitionFrom:		removeFromSystemTolerant:fromPackage:	testing		existsInImageInstance Variables:	classSym	&lt;Symbol&gt;	The name of the class or the name of the sole instance if a meta class.	isMeta		&lt;Boolean&gt;	Is this a meta class.</body></comment><class><name>AbstractComponentTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>PropertyTag</name><environment>Store</environment><super>Store.AbstractComponentTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>AtomicLoader</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageModel classesToInitialize bindingsToInitialize classesToNotify overrides notificationQueue workingResult doNotMarkClean overriddenClassesInPackage </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>AtomicLoader</class-id><body>Once all of the definitions have been compiled into a shadow namespace (shadowed objects), they need to then be installed into the system proper.  AtomicCompilationResult use this class to to install those definitions.  Ultimately installation starts with the instance side method #installCompilationResult:, and the argument is the compliation result.This class requires that the shadowed objects are arranged in the proper order for installation.  Each shadowed object definition is sent redirectTo: with the instance of this class as the argument.  This way each definition in the system (Class, Method, Namespace, Shareds) calls back to the shadow installer with either #installClass:, #installMethod:, #installNameSpace: or #installSharedBinding:.   See those four methods for how the definitions are installed in the system.When installing a class, or a method, this class keeps track of whether it needs to send #initialize of #postLoad: once the installation is complete.   The same is done for BindingReferences (Shared Variables).Instance Variables	packageModel	&lt;PackageModel&gt; - the package into which the objects are being installed.	classesToInitialize	&lt;OrderedCollection of: Class&gt; The classes that need to be sent #postLoad: once the installation is complete.	bindingsToInitialize	&lt;OrderedCollection of: BindingReference&gt; The bindingreferences for shared variables that need to be told to initialize once the installation is complete.	classesToNotify	&lt;IdentitySet of: Class&gt; The classes that need to be sent #instanceMethodsChange once the installation is complete and after classes have been sent #postLoad:	overrides	&lt;OrderedCollection of: override definitions&gt;	workingResult &lt;AtomicCompilationResult&gt;	The result object I am current installing from.	doNotMarkClean &lt;Boolean&gt; if an initializer fails, we flag this to true, allowing a later republish</body></comment><class><name>StoreBundleSubBundleRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleID subbundleID expressionID sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundleSubBundleRelationship</class-id><body>StoreBundleSubBundleRelationship represents the "TW_Bundles" table and is used by the Garbage CollectorInstance Variables	bundleID		&lt;Integer&gt;	This is the bundleRef column value	expressionID	&lt;Integer&gt;	This is the expressionID column value	sequence		&lt;Integer&gt;	This is the seqNumber column value	subbundleID	&lt;Integer&gt;	This is the subbundleRef column value</body></comment><class><name>Modification</name><environment>Store</environment><super>Store.AbstractModification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>record originallyInImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MergeToolMods</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.Modification</class-id><body>A record plus a flag for whether it started out in the image or not.Instance Variables:	originallyInImage	&lt;Boolean&gt;	flag of originallyInImage	record	&lt;Method&gt;	description of record</body></comment><class><name>BlessingLevel</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name level type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BlessingLevel</class-id><body>BlessingLevel are the various blessing names and values for blessingsInstance Variables	level	&lt;Integer&gt;	The level number for the blessing	name	&lt;String&gt;		Name of the blessing	type	&lt;ByteSymbol | nil&gt;	The type as used by the ownershop system (#qa, #owner, #admin)</body></comment><class><name>FileRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileID fileData fileSize components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.FileRecord</class-id><body>FileRecord represents the specification of a file (associated with a bundle) that is stored in the database.  To capture the filename in a platform portable way, FileRecord stores the components (#componentStrings) that make up the file. When being stored into the database, the components are first converted into the BOSS format (#convertBinaryData), then reverted back to the OrderedCollection of component strings after installation in the database.Instance Variables:	fileID	&lt;Integer&gt; description of fileID	fileData	&lt;ByteArray&gt; The data of the file	fileSize	&lt;Integer&gt; The size of the file	components	&lt;OrderedCollection of: String&gt; 	The components of the filename, i.e. the Portable filename.</body></comment><class><name>GeneralResolution</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.GeneralResolution</class-id><body>GeneralResolution is the abstract resolution for all resolutionsInstance Variables	package	&lt;PundleModel | StorePundle&gt;		This is the pundle object where this user input resolution was cloned from.</body></comment><class><name>BindingTextualDetailComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftText rightText name icon </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.BindingTextualDetailComparisonView</class-id><body>I'm a parameterizable side by side comparison view for two text attributes of a BindingBlueprint.ImplementationThe majority of my display work is done by my SideBySideTextComparisonView. I just wrap it with the disclosure button and the header.Instance Variables	icon	&lt;VisualComponent&gt;	the icon to place in the header (meant to correlate with the detailHintGraphics)	leftText	&lt;CharacterArray&gt;	text to show on the left side	name	&lt;CharacterArray&gt;	string label that shows up in the header	reference &lt;BindingReference&gt; identifies the object that the detail belongs to	rightText	&lt;CharacterArray&gt;	text to show on the left side</body></comment><class><name>DBPundlePrivileges</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleName pundleType userName userType privilege </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.DBPundlePrivileges</class-id><body>DBPundlePrivileges is obsolete in 7.8 and beyond</body></comment><class><name>StoreLogin</name><environment>Store.Glorp</environment><super>Glorp.Login</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driverClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreLogin</class-id><body>StoreLogin specializes the standard Glorp.Login object, by containing the driverClassName when converted from a store connection profile. This way, a StoreLogin can get the exact driver class associated with the converted connection and not try to guess. This can be a problem for Thapi based connections, where Glorp guesses at the connection, but StoreLogin can knowInstance Variables	driverClassName	&lt;String&gt;	description of driverClassName</body></comment><class><name>BasicVersionPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicVersionPolicy</class-id><body>This is the most basic versioning policy. It simply takes the current version string, looks to see if the last character is a digit, and if so, tries to increment that value.</body></comment><class><name>StoreVersionlessPundle</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name versions comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreVersionlessPundle</class-id><body>This is an abstract superclass for versionless pundles. That is, a StorePackage or StoreBundle represents one particular version of a thing. This represents the abstract thing by itself, and has a collection of its versions. We also define a precedence which is used when we sort these to put bundles before packages.Subclasses must implement the following messages:	comparing		precedenceInstance Variables:	comment	&lt;SequenceableCollection&gt;	The comment for this pundle. Since this can change by version, we get the comment for the most recent version (but note that we get it directly from the database via the mapping for this variable).	name	&lt;String&gt;	The name of the pundle	versions	&lt;SequenceableCollection of: StorePundle)&gt;	The versions of this pundle.</body></comment><class><name>StoreVersionlessBundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreVersionlessPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreVersionlessBundle</class-id><body>This represents a particular versionless bundle.</body></comment><class><name>LoadOrSaveInvalidArgumentsError</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveInvalidArgumentsError</class-id><body>LoadOrSaveInvalidArgumentsError if the action has the wrong number of arguments</body></comment><class><name>ShadowedObject</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package storeObject shadowCompiledDefinition override </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedObject</class-id><body>ShadowedObjects are used with the Quark analysis installer to gather up objects from packages which will be queried for if they need early install, and later sorted and installed.Instance Variables	package	&lt;StorePackage&gt;	The containing package for the defintion	shadowCompiledDefinition	&lt;Object&gt;	This is the object compiled into the shadow environment	storeObject	&lt;StoreObjectInPackage&gt;	The actual definition in package object</body></comment><class><name>ShadowedNamespaceObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longName ownerName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedNamespaceObject</class-id><body>ShadowedNamespaceObject is a specialization of ShadowedObject for NamesSpacesInstance Variables	longName	&lt;String&gt;	The long name (from Root) of this Namespace	ownerName	&lt;String&gt;	The long name (from Root) of the owning environment</body></comment><class><name>PkgClassesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass definitionID environmentString commentID packageRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgClassesView</class-id><body>Maps Packages to Classes.Instance Variables:	superclass	&lt;String&gt;  fully qualified superclass name. 	definitionID	&lt;Integer&gt;  link to blob table pointing to class definition	environmentString	&lt;String&gt; environment strng of class	commentID	&lt;Integer&gt;  link to blob table pointing to class comment	packageRef	&lt;Integer&gt;  link to package	definitionOrder	&lt;Integer&gt;  class orderShared Variables:	ClassesSession	&lt;ExternalDatabaseSession&gt;  cached session for all classes in a package.</body></comment><class><name>PkgMetaclassesView</name><environment>Store</environment><super>Store.PkgClassesView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgMetaclassesView</class-id><body>Maps Packages to Metaclasses.</body></comment><class><name>Association</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.Association</class-id><body>Abstract superclass to model the many to many relationship tables.</body></comment><class><name>BundlePart</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleRef expressionID seqNumber expressionStr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.BundlePart</class-id><body>Abstract superclass for the bundle contents. These are interface tables that contain bundle to sub-bundle/package refs.Instance Variables:	bundleRef	      &lt;Integer&gt;	primaryKey of owning bundle.	expressionID	&lt;Integer&gt;	key for expression string	seqNumber	      &lt;Integer&gt;	for ordering of bundle contents.	expressionStr	&lt;String&gt;	I have no idea.</body></comment><class><name>Bundles</name><environment>Store</environment><super>Store.BundlePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subBundleRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Bundles</class-id><body>Bundle to sub-bundle.Instance Variables:	subBundleRef	&lt;Integer&gt;	sub-bundle's primaryKey</body></comment><class><name>ClassVersionsNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpBrowserUI</category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.ClassVersionsNavigatorPart</class-id><body>This really just distinguishes a type of navigation, in which have a list of class versions of the same class, rather than a bunch of different classes, visible in the browser.</body></comment><class><name>ClassTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>DefinitionsForListPane</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itemsInList tool title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.DefinitionsForListPane</class-id><body>DefinitionsForListPane is an abstract pane for use as the top subcanvas in a DefiintionsForListTool.This pane always has a MultiSelection list.Subclasses must implement the following messages:	accessing		fillInFor:		listTitle	aspects		itemsInListInstance Variables	itemsInList	&lt;MultiSelectionInList&gt;	This is the list that the pane manages	tool	&lt;DefinitionForListTool&gt;	This is the host DefiintionsForListTool instance that uses me</body></comment><class><name>SharedVariableListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.SharedVariableListPane</class-id><body>SharedVariableListPane is used to list versions of a StoreSharedVariableInPackage in a DefinitionsForListTool</body></comment><class><name>DBAccess</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentString connection sequenceConnection connectedProfileHolder recentProfile isOnline tablePrefix debug log logFile databaseIdentifier storeBroker installScript debugger cachedNames highestPrimaryKeyChecked subscriptionRegistry currentDatabaseAccessor storeDescriptorSystems </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Database</category><attributes><package>Store-Database</package></attributes></class><comment><class-id>Store.DBAccess</class-id><body>DBAccess has a singleton instance (Store.DbRegistry) that provides an access point for Store queries and some basic database utilities.self someInstanceInstance Variables	connectedProfileHolder	&lt;ValueModel&gt;	contains a ConnectionProfile of the current login.	connection	&lt;ExternalDatabaseConnection&gt;	current database connection	currentDatabaseAccessor	&lt;DatabaseAccessor&gt; the Glorp DatabaseAccessor associated with the current connection/connectionProfile	databaseIdentifier	&lt;Symbol&gt;	identifies the current database	debug	&lt;Boolean&gt;	if true, logs sql statements.	debugger	&lt;LogEnvironment&gt;	where sql statements are logged if debug is true	environmentString	&lt;unknown&gt;	unused	installScript	&lt;Boolean&gt;	if true, will create an install script instead of actually installing the tables	isOnline	&lt;Boolean&gt;	true if we believe we have a valid connection to a db	log	&lt;Boolean&gt;	if true keep log	logFile	&lt;Stream&gt;	description of logFile	recentProfile	&lt;ConnectionProfile&gt;	last succesful login profile	sequenceConnection	&lt;unknown&gt;	unused	storeDescriptorSystems &lt;Dictionary of: (aString -&gt; StoreDescriptorSystem)&gt; A simple way of not having to look up in the database what tables exist for what connection every time I get a new connection (aString is the connectionString of the login).	storeBroker	&lt;SQLBroker&gt;	an instance of a sqlbroker for the current database.	tablePrefix	&lt;String&gt;	used in creating the database tables. the default is BERN.	cachedNames &lt;IdentityDictionary of: Record-&gt;String&gt; A cache of database record classes and their names, cleared when the session is reset.  For example, after sending #allNames to Package, one would find an entry in cachedNames where the key is Package and the value is an Array of all the known names in the database.	highestPrimaryKeyChecked &lt;IdentityDictionary of: Record-&gt;Number&gt; A cache of database record classes to the highest known primary key for that class in the database.  Used to speed-up searches for database records.	subscriptionRegistry	&lt;SubscriptionRegistry&gt; Registry of panes that listen to my announcement (StoreConnect and StoreDisconnect)</body></comment><class><name>MiniRepositoryManager</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>labelHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.MiniRepositoryManager</class-id><body>MiniRepositoryManager is the application model of the tiny one-line application intended for the launcher's status bar. It displays information about the current Store connection, allows to connect and disconnect, and do basic connection information management.Instance Variables:	labelHolder	&lt;ValueHolder with: String&gt;	ValueHolder with the current text displayed by the application.</body></comment><class><name>PseudoDifference</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainPackage otherPackage mainObject otherObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoDifference</class-id><body>PseudoDifference is the abstract class for all Pseudo Difference objects. It holds the "main" (from if you will) Package, which will be an PackageModel or StorePackage, and the "other" (to of you will) Package, which will always be a StorePackge.The objects they hold (mainObject otherObject) depends on what kind of difference they are. Classes, Namespaces, Comment, Shareds, Properties and Methods may be in each, depending on the subclass type.Instance Variables	mainObject	&lt;Object&gt;	description of mainObject	mainPackage	&lt;PackageModel | StorePackage&gt;	description of mainPackage	otherObject	&lt;Object&gt;	description of otherObject	otherPackage	&lt;StorePackage&gt;	description of otherPackage</body></comment><class><name>PseudoPropertyDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoPropertyDifference</class-id><body>PseudoPropertyDifference is used by the ComparePackages UI to show a single property difference</body></comment><class><name>BasicPublishPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allowBinaryLoading allowOverridesWithinBundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicPublishPolicy</class-id><body> When Store is publishing or loading pundles from the database it consults the instance of this maintained in the global Policies, which is a singleton of instance of Access.When publishing a pundle, this class will defer to the current BlessingPolicy to determine if the blessing level being published is appropriate.Despite the name of this class, this class allows some customization of how published pundles are loaded from a database.  When Store is loading pundles from the database it consults the instance of this maintained in the global Policies, which is a singleton of instance of Access.When a package has been published, one can optionally choose to published it as binary.  If a package is published as binary, then in addition to storing the sources for the package, a parcel file is serialized into the database.  This is useful for future loading of those packages that might be difficult to load, such as packages that contain hand crafted parsers.  Also, in the past, clients used binary publishing to help speed up loading from Store (this is no longer necessary, source loading can be in most cases faster than binary loading).  When loading packages from the database, it sometimes is useful to suppress the ability to load these packages as binary and instead simply use the source.  An example of when this might be useful is when bytecode sets have change and the source must be reompiled.  The allowsBinaryLoading instance variable toggles whether loading binary is allowed when loading from a database.If a bundle has overrides within itself and is being published the client is warned about these overrides.  However, a client can choose to ignore this warning and still publish the bundle.  When loading this bundle, two things can happen.  One, these overrides are treated as simple movement across packages within the bundle.  Or, these overrrides can be treated as overrides within the bundle being loaded.The allowsOverridesWithinBundles instance variable controls which behavior is seen.Instance Variables:	allowBinaryLoading	&lt;Boolean&gt; Boolean flag to determine if packages should load their pcl file if published binary.	allowOverridesWithinBundles	&lt;Boolean&gt;	When loading bundles, respect overrides or treat them as definition movements between packages.</body></comment><class><name>ReconcileWarning</name><environment>Core</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpVWUI</package></attributes></class><comment><class-id>Core.ReconcileWarning</class-id><body>ReconcileWarning is raised when one is loading a package from a database which had not previously been reconciled to.This is a resumable exception:	["code that loads packages or bundles"]		on: ReconcileWarning		do: [:exception | exception resume: true] "or false"</body></comment><class><name>MethodComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftMethod rightMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.MethodComparisonView</class-id><body>I'm a side by side comparison view for two methods.ImplementationThe majority of my display work is done by my SideBySideTextComparisonView. I do set up the header, and provide menu options for the method.Instance Variables	leftMethod	&lt;MethodBlueprint&gt;	method to show on the left side	rightMethod	&lt;MethodBlueprint&gt;	method to show on the right side</body></comment><class><name>StorePundleEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.PundleEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StorePundleEnvironment</class-id><body>StorePundleEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>ResolutionPackageItem</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package base image proposed applied alternative </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionPackageItem</class-id><body>ResolutionPackageItem is used to display Packages in the upper right hand pane of the Merge toolInstance Variables	applied	&lt;Boolean&gt;	true if this resolution has been applied	base	&lt;Boolean&gt;	true if this resolution represents the package that is the 'base'	image	&lt;Boolean&gt;	true if this resolution represents the package that is the image	package	&lt;PundleModel  | StorePundle&gt;	The PundleModel or StorePundle where the resolution is to be applied	proposed	&lt;Boolean&gt;	true if the item is the proposed item	alternative &lt;anAssociation | RemovalResolution | UserInputResolution | NoOpResolution&gt; The current resolution that this item is representing</body></comment><class><name>LoadAnalysisError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadAnalysisError</class-id><body>LoadAnalysisError is raised the LoadAnalyzer determines that a load of a definition can not proceed</body></comment><class><name>StoreObjectInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreObjectInPackage</class-id><body>This represents an object in the context of a particular package version. This corresponds most closely to the way we'd talk about the object in regular Smalltalk. So, for example, a StoreMethodInPackage is like a Smalltalk method. One thing it can do is answer the question "what package am I in? A StoreMethod can't do that because it represents a method version which can be part of many different package versions.Instance Variables:	package	&lt;StorePackage&gt;	The containing package.	definition	&lt;StoreObject&gt;	The full definition of the thing we represent.</body></comment><class><name>StoreNamespaceInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreNamespaceInPackage</class-id><body>This represents a namespace definition in a particular package. Like the other inPackage entities, it corresponds more to what we'd think of as a method in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.</body></comment><class><name>PundleChanges</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle1 pundle2 changeSet1 changeSet2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PundleChanges</class-id><body>A PackageChanges converts and holds the changes between two database package versions. Instance Variables:	pundle1	&lt;Pundle&gt;	First pundle	pundle2	&lt;Pundle&gt;	Second pundle.	changeSet1	&lt;XChangeSet&gt;	ChangeSet for converting pundle2 into pundle1	changeSet2	&lt;XChangeSet&gt;	ChangeSet for converting pundle1 into pundle2</body></comment><class><name>BundleChanges</name><environment>Store</environment><super>Store.PundleChanges</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>NoTrunkToMergeError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.NoTrunkToMergeError</class-id><body>NoTrunkToMergeError is raised during merge if the trunk version is nil</body></comment><class><name>StoreWorkActivity</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject isFinished </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StoreWorkActivity</class-id><body>Abstract activity announcement.UsageActivity announcements are announced at strategic edge points in Store code, allowing tools to be aware of activity. Using announcements allows the architecture to be one that carries rich state, and can have zero, one, or many interested tools paying attention.Tools become aware of their occurrence by subscribing (see Object 'announcements-configuring' method category) to the StoreLoadActivity notifications. Care should be token to unsubscribe tools when they are no longer active.StoreLoadActivity announcements come (usually) in pairs. A 'started' instance, and a 'finished' instance. They usually have a 'subject' that they represent activity for. The usual pattern is to have a sequence that looks like:(Loading for: aCodeComponent) started....work code...(Loading for: aCodeComponent) finished.Instances of me can be asked if they are the compliment of another, useful for finding the paired value in a transaction.Instance Variables	subject	&lt;Object&gt; subject is the object we're doing the work for. It's type and interpretation is defined by subclases. For many, it is a CodeComponent, so we provide an implementation of #componentName that assume it is that. If it is not a CodeComponent, said methods should be adjusted appropriately	isFinished &lt;Boolean&gt;</body></comment><class><name>Analyzing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Analyzing</class-id><body>Analyzing is annouced during analysis phase of the Quark analysis loader</body></comment><class><name>StorePundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment properties propertiesBlob propertiesRecordDictionary version blessings currentBlessingLevel storeModel session versionless </inst-vars><class-inst-vars>cache </class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePundle</class-id><body>This is an abstract superclass for Store packages and bundles. Each instance represents a particular version of a particular package or bundle.Subclasses must implement the following messages:	accessing		namespaces		nameSpaces	constants		componentType		defaultCompileManager	enumerating		allComponentsDo:	full classes		fullClasses	store faking		asStoreRecord		descriptionClassInstance Variables	blessings	&lt;(Collection of: StoreBlessing)&gt;	The blessings this version has	comment	&lt;StoreBlob&gt;	Our comment.	currentBlessingLevel	&lt;Integer&gt;	The current blessing level of this pundle. Should correspond to the level of the most recent blessing.	properties	&lt;Dictionary from: Symbol to: Object&gt;	Our properties, in the Smalltalk domain form, as a dictionary of symbol keys and object values. This will be created from either the propertiesBlob or propertiesRecordDictionary representation, automatically.	propertiesBlob	&lt;StoreBlob&gt;	The pre-7.3 representation of properties, with the entire dictionary in a single blob.	propertiesRecordDictionary	&lt;Dictionary from: String to: StoreBlob&gt;	The 7.3 or after representation of properties, as individual records, containing each property as a BOSSed out object.	session	&lt;GlorpSession&gt;	The session in which we were constructed. We hold on to this because it is often useful to know.	storeModel	&lt;PundleModel | nil&gt;	The corresponding Store BundleModel or PackageModel. This may be nil if there isn't one. This is computed lazily if required.	version	&lt;String&gt;	Our version name	versionless	&lt;StoreVersionlessPundle&gt;	A link to our corresponding versionless pundle. That is, if we're version 2.4.3 of package Foo, then the corresponding versionless thing is just Foo.</body></comment><class><name>StoreBundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundles packages files </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundle</class-id><body>This represents a version of a particular Store Bundle.Instance Variables:	bundles	&lt;Dictionary from: Integer to: StoreBundle&gt;	The sub-bundles we contain, keyed by their position in the ordering of sub-components. That is, if we contain sub-bundle A, sub-package B, and sub-bundle C, then we will hold 1-&gt;A, 3-&gt;C.	files	&lt;(OrderedCollection of: StoreFile)&gt;	The external files associated with this bundle.	packages	&lt;Dictionary from: Integer to: StorePackage&gt;	The sub-bundles we contain, keyed by their position in the ordering of sub-components. In the example above, we would hold 2-&gt;B.</body></comment><class><name>StoreMethodDefinitionEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.MethodDefinitionEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id><body>StoreMethodDefinitionEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>FileModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dbtrace bundle portableFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.FileModel</class-id><body>A FileModel is the in image model that represents a file that which is associated with a bundle.  A FileModel is stored in the database a portable filename.Instance Variables:	name		&lt;Object&gt; undocumented	dbtrace	&lt;Object&gt; undocumented	bundle		&lt;BundleModel&gt; The bundle that is associated with this model	portableFilename    &lt;PortableFilename&gt;  The portable filename</body></comment><class><name>ShadowedSharedVariableObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longName ownerName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedSharedVariableObject</class-id><body>ShadowedSharedVariableObject is a specialization of ShadowedObject for SharedVariablesInstance Variables	longName	&lt;String&gt;	The long name (from Root) of this SharedVariable	ownerName	&lt;String&gt;	The long name (from Root) of the owning Namespace or Class</body></comment><class><name>StoreDatabaseTable</name><environment>Store.Glorp</environment><super>Glorp.DatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDatabaseTable</class-id><body>StoreDatabaseTable is used exclusively by Store in order to "store" properties needed by Store, but which are not used by all database engines we support.Instance Variables	properties	&lt;Dictionary&gt;	A properties dictionary</body></comment><class><name>DefinedRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString definitionStr commentStr package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.DefinedRecord</class-id><body>DefinedRecord has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Subclasses must implement the following messages:	comparing		objectIsForSelf:	- answer true if the argment is can be compared to the receveiver	private		convertFromXML:		convertToXML:		move:to:Instance Variables:	commentID	&lt;Integer&gt;	primaryKey of the comment	commentStr	&lt;String&gt;	the comment	definitionID	&lt;Integer&gt;	primaryKey of the definition	definitionStr	&lt;String&gt;	the receiver's definition	environmentString	&lt;String&gt;	the absolute name of the enviornment to install into	package	&lt;Package&gt;	the package we are in (one of)</body></comment><class><name>DataElement</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocolName typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.DataElement</class-id><body>DataElement represents a shared variable definition that exists either in a name space or a class (formerly called class variables).   Unlike class and name space definitions, shared variables do not have a comment.The typeString instance variable is used to determine the owner (environment) for the shared variable.  If typeString is nil or 'N' then the shared variable will belong in a name space.  If the typeString is 'C', then the shared variable belongs to a class.  The owner's name is stored in the environmentString instance variable and can be accessed by #absoluteOwnerName.Instance Variables:	protocolName	&lt;String&gt;	The protocol to organize this variable under	typeString	&lt;String | nil&gt;		Either, 'C', 'N' or nil - described ablve</body></comment><class><name>AtomicCompilationResult</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package shadowedObjects unloadableDefinitions packageDifferences isAtomicallyLoadable overrides notificationQueue overridden installed externalClassesNeedingRecompile methodsMovedFromOriginalBinding needsEarlyInstall </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>AtomicCompilationResult</class-id><body>AtomicCompilationResult tracks a unit of objects (ie. package) that have or have not been successfully compiled into shadowland. Order is maintained so that installation from shadow into the standard enviornment will follow actual load dependancies.Instance Variables	package	&lt;StorePackage&gt;	The store package to which these defintions belong.	shadowedObjects	&lt;OrderedCollection&gt;	successfully compiled objects in shadow	unloadableDefinitions	&lt;OrderedCollection&gt;  definitions which failed compilation	packageDifferences 	&lt;PackageDifferences|nil&gt;  If not nil (not loading a new package), the PackageDifferences instance to consult for loading	isAtomicallyLoadable		&lt;Boolean&gt; False if the compiliation failed atomic compiling	overrides	&lt;OrderedCollection&gt; Overrides that were accumulated during compiling	overridden	&lt;Collection&gt; Overrides that others created	installed &lt;Booelan&gt; Is this result installed	externalClassesNeedingRecompile	&lt;Collection of: ExternalInterface&gt;	These are classes that need to be recompiled after installing	needsEarlyInstall	&lt;Boolean&gt; False (default) if an early install condition is not seen</body></comment><class><name>ConnectionProfile</name><environment>Store</environment><super>Database.ConnectionProfile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableOwner </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.Element			private XML.Attribute			</imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.ConnectionProfile</class-id><body>Extends the base ConnectionProfile to include the Store database owner.Instance Variables:	tableOwner	&lt;String&gt;	the Store installation db owner name.</body></comment><class><name>RepositoryPropertiesDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileHolder acceptTrigger databaseListHolder databaseHolder environmentHolder userNameHolder passwordHolder tableOwnerHolder nameHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepositoryPropertiesDialog</class-id><body>RepositoryPropertiesDialog is used by RepositoryManager and MiniRepositoryManager to edit properties of individual Store connections.Most of the instance variables hold aspects of the dialog's widgets. The aspects are buffered value holders on aspect adaptors on the contents of 'profileHolder' variable.Instance Variables:	acceptTrigger	&lt;ValueHolder with: Boolean&gt;	Trigger channel of the buffered value	databaseHolder	&lt;BufferedValueHolder&gt;	databaseListHolder	&lt;List&gt;	environmentHolder	&lt;BufferedValueHolder&gt;	nameHolder	&lt;BufferedValueHolder&gt;	passwordHolder	&lt;BufferedValueHolder&gt;	profileHolder	&lt;ValueHolder&gt; Holds the profile whose properties are being edited.	tableOwnerHolder	&lt;BufferedValueHolder&gt;	userNameHolder	&lt;BufferedValueHolder&gt;</body></comment><class><name>StoreRepositoryListPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setting repositoryListHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.RepositoryPropertiesDialog			private Store.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Tools.StoreRepositoryListPage</class-id><body>StoreRepositoryListPage is a page that displays (and allows for the creation of) Store.ConnectionProfiles to control which repositories the image can connect to.  The list of repositories is obtained from an instance of StoreRepositoryListSetting.self someInstanceInstance Variables:	repositoryListHolder	&lt;SelectionInListSortAware on: List of: Store.ConnectionProfile&gt;	The list of repositories	setting	&lt;StoreRepositoryListSetting&gt;	The setting used for obtaining (and modifying) the list of repositories</body></comment><class><name>Pundle</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingLevel commentID propertiesID properties propertyRecords commentStr </inst-vars><class-inst-vars>cache </class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Pundle</class-id><body>Pundle is the superclass for Package and Bundle.Subclasses must implement the following messages:	accessing		asDBDescription		pundleChangesClass	private-accessing		recordForTag:	shadow loading		compileIntoShadow:		itemCount		preShadowCompile		preShadowLoadInstance Variables:	blessingLevel &lt;Integer&gt;	this version's blessing level	commentID	&lt;Integer&gt; primaryKey of the this version's comment	commentStr	&lt;String&gt;	the pundle comment	properties	&lt;Dictionary&gt;	the pundle property dictionary	propertiesID	&lt;Integer&gt;	primaryKey of the propertyDictionary (for old style properties)	propertyRecords	&lt;(Collection of: ProptertyRecord)&gt; the property records (for new style properties)Class Instance Variables:	cache &lt;WeakDictionary&gt; A temporary cache of bundle or package instances for efficiency during database operations.Shared Variables:	ComponentNotFoundSignal &lt;Signal&gt; The exception to be raised when we don't find a component.	LegalPublishingProperties &lt;Collection of: Symbol&gt; The possible values for PropertiesPublishingPolicy.	PropertiesPublishingPolicy &lt;Symbol&gt; How do we publish properties. As individual records, as a BOSSed out blob of all properties, or both.</body></comment><class><name>Bundle</name><environment>Store</environment><super>Store.Pundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vanguardID rearguardID vanguardStr rearguardStr contents files </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Bundle</class-id><body>Manages the contents of a bundle.Description:Code components in the repository are represented as instances of Package or Bundle. Components in the local image are represented as instances of PackageModel or BundleModel. Usage:Use the global Store.Registry to obtain PackageModel and BundleModel objects. For details, see the class comment for PundleAccess.To query the database for a particular version of a named bundle:    Store.Bundle pundleWithName: nameString version: versionStringThis returns the bundle, or nil. For example:   Store.Bundle pundleWithName: 'BottomFeeder' version: '1.1.14'If you evaluate this code while connected to the repository you'll get back that version of the BottomFeeder bundle.Instance Variables:	contents	&lt;ByteFieldDescriptor | CCompoundType | (Collection of: (Bundles | Files | Packages)) | MC_FileBTree | RBProgramNode | Stream&gt;	description of contents	files	&lt;Collection | RBProgramNode&gt;	description of files	rearguardID	&lt;Object&gt;	description of rearguardID	rearguardStr	&lt;Object&gt;	description of rearguardStr	vanguardID	&lt;Object&gt;	description of vanguardID	vanguardStr	&lt;Object&gt;	description of vanguardStr</body></comment><class><name>StorePundleNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.PundleNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StorePundleNavigatorPart</class-id><body>StorePundleNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>StoreClassEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreClassEnvironment</class-id><body>StoreClassEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>ParcelRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleID blobID sourceID filename blobData sourceData pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.ParcelRecord</class-id><body>ParcelRecord is used to store a parcel into the database.Instance Variables:	blobData	&lt;ByeArray&gt;	 the parcel contents	blobID	&lt;Integer&gt;	primaryKey of the BinaryBlob that contains blobData	filename	&lt;String&gt; not used	pundle	&lt;aPundle&gt;  the pundle that this parcel is equivilent to	pundleID	&lt;Integer&gt; primaryKey of the pundle that this parcel is equivilent to	sourceData	&lt;ByeArray&gt;	 the parcel source code	sourceID	&lt;Integer&gt;	primaryKey of the BinaryBlob that contains the sourceCode</body></comment><class><name>IgnorePossibleOverrideNotice</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.IgnorePossibleOverrideNotice</class-id><body>IgnorePossibleOverrideNotice is raised whenever a dialoge for override notice is about to be opened.If there are multiple applies going on, the system will resume with trueIf there is only one apply going on, the system will default to false, and the dialog will open</body></comment><class><name>RepositoryManager</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repositoryListHolder connectedIcon </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.XMLParser			private XML.SAXWriter			private XML.Document			private XML.Element			</imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepositoryManager</class-id><body>RepositoryManager is the standalone application for managing Store connections. It uses a dataset to list the known connections and allows one to manage connections, including saving to and loading from files.Instance Variables:	connectedIcon	&lt;Image&gt;	The image used by the dataset to mark the currenly connected repository, if any.	repositoryListHolder	&lt;SelectionInList&gt;	The model of the repository list.</body></comment><class><name>PundleLoadedChange</name><environment>Store</environment><super>Kernel.ComponentLoadedChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseId primaryKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PundleLoadedChange</class-id><body>Represents a package or bundle loaded event. Instance Variables:	databaseId  &lt;String&gt; - The database from which the pundle was loaded	primaryKey &lt;Integer&gt; - The primary key in the database that identifies the exact version.</body></comment><class><name>PundleSavedChange</name><environment>Store</environment><super>Store.PundleLoadedChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Store-Change Management</package></attributes></class><class><name>StoreBrowserDefinitionTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserDefinitionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id><body>StoreBrowserDefinitionTool is used when browsing Store/Glorp database objects</body></comment><class><name>StoreNewVersionWarning</name><environment>Store</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-IMG-Pundles</package></attributes></class><comment><class-id>Store.StoreNewVersionWarning</class-id><body>StoreNewVersionWarning is raised if there is a new version of a package already published</body></comment><class><name>StoreBrowserCommentTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserCommentTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserCommentTool</class-id><body>StoreBrowserCommentTool is used when browsing Store/Glorp database objects</body></comment><class><name>Merging</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Merging</class-id><body>Merging is a generic I'm Doing Something announcement that happens during a merge</body></comment><class><name>ShadowCompiler</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shadowRoot </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowCompiler</class-id><body>ShadowCompilationManager is used to compile and evaluate definition messages in the context of a shadowed namespace.Instance Variables:	shadowRoot	&lt;NameSpace&gt;	The root of the shadowed namespace.</body></comment><class><name>StoreBlob</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type data result next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBlob</class-id><body>This holds the text, or bytes, for the various large strings (where large means &gt; 255 characters) associated with Store entities. Method definitions, class definitions, comments, properties, and so on, are all stored in StoreBlob entities. The really clean way to represent this would just be to have it as a string or array of bytes/words, but the database representation is complicated enough to make that difficult. So instead they are represented asStoreBlob objects, which can answer their #source or #object. #object means that we expect the blob to contain an array of bytes which is BOSS data. There is also a blob chaining scheme in the database, to accomodate blobs larger than the biggest size we can handle in the database (which varies by database). Instance Variables:	data	&lt;ByteArray | nil&gt;	our raw binary data	next	&lt;StoreBlob&gt;	If we have are part of a chain of blobs, this points to the next entry. Otherwise it is nil.	result	&lt;String | Object&gt;	Our contents. This is cached, so that if we access it repeatedly we don't have to recompute it. If we are a string type, this will be a string. If we are BOSS data, it will be an arbitrary object. Trying to mix and match is not a good idea.	type	&lt;Magnitude | nil&gt;	If we are part of a chain, this is nil. If we are not, then it will be          1 for an Object (i.e. a bytearray of BOSS data).         2 for a String         3 for a double byte string         4 for a byte array, not interpreted</body></comment><class><name>StoreBinaryBlob</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreBlob</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBinaryBlob</class-id><body>This is exactly the same as a blob. I guess on same databases the blobData field may need to be of a different type in order to accomodate binary data.</body></comment><class><name>RecordVersionsViewer</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionModule text </inst-vars><class-inst-vars>specPreference </class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>Store-UI-Browser</package></attributes></class><comment><class-id>Store.RecordVersionsViewer</class-id><body>This viewer displays a list of versions for concrete subclasses of DefinedRecord.  When a version is selected, the viewer will display the definition for that record.   A utility method on the class side will open (#openOnVersionsOf:) can be used to open up the viewer when a client has a specific concrete subclass instance of a DefinedRecord that they want to display.  For example:	|record |	record := (ClassRecord allVersionsNamed: 'Root.Core.Object') first.	self openOnVersionsOf: record.Otherwise, the instance side method, #versions:, is used to set the list of versions to display for a DefinedRecord.   For example:	|record viewer |	record := (ClassRecord allVersionsNamed: 'Root.Core.Object') first.	viewer := self new.	viewer open.	viewer versions: record versionsInstance Variables:	selectionModule	&lt;ListSelectionModule&gt;	A module that holds the list of version records	text		&lt;ValueHolder on: String|Text&gt;	The definition string for the currently selected definitionClass Instance Variables:	specPreference &lt;Symbol&gt; The desired window specification to use for viewing.  Currently, there are two choices, which control whether the sequence view is displayed above (#horizontalWindowSpec) or to the left (#verticalWindowSpec) of the text view.  Note, that it is assumed that this class understands the message represented by this variable.	</body></comment><class><name>BasicFilePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>downloadPreference downloadDirectory useDownloadDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicFilePolicy</class-id><body>When loading a bundle from the database that has files, this class provides a policy for how these files are to be downloaded.  The possible choices for a user for this policy object are 		Download Preference		#never 	Never download files for bundles, this also implies that the user is shown the dialog		#prompt 	Prompt the user with a dialog asking which files to download, if any		#always 	Always download the files	Download Directory		The directory (LogicalFileName) to store the downloaded files.   If the files being download use a SystemVariable, the download directory takes precedence.  The same holds true for absolute filenamesInstance Variables	downloadPreference	 &lt;Symbol&gt;	See above	downloadDirectory  &lt;Symbol&gt;  See above	useDownloadDirectory &lt;Boolean&gt;  See above</body></comment><class><name>NoOpResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applied </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NoOpResolution</class-id><body>NoOpResolution is a special resolution choice that represents a "Don't Apply This Resolver" resolutionInstance Variables	applied	&lt;Boolean&gt;	when true, this resolution has been applied (in fact, these kind of resolutions don't do any work)</body></comment><class><name>LoadingError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.LoadingError</class-id><body>Generic superclass for Errors raised during loading.Instance Variables	package	&lt;PundleModel or Pundle&gt;	Package being loaded when the error occured.</body></comment><class><name>AtomicLoadingError</name><environment>Store</environment><super>Store.LoadingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AtomicLoadingError</class-id><body>AtomicLoadingError is thown if a stand alone package is not able to be loaded atomically. In interactive mode, the user is notified that a problem occurred.If because of missing subclasses, shared or namespaces, the Atomic Loader determines a Package can not be loaded atomically, this error is thrown, and a dialog will open reading:	&lt;somepackage&gt; is unable to be atomically loaded.If you are using hand code to load stuff and you don't want to have a dialog pop up, you can wrap your code in an	on: AtomicLoadingError	do: []There are two helper methods you can use in your do:, you can :	[:exception | exception abortLoad]Which will simply abort the load cleanly.</body></comment><class><name>MethodTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>Data</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef dataRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.Data</class-id><body>Package to DataElement talbe.Instance Variables:	packageRef	&lt;Integer&gt;	Package primaryKey	dataRef	&lt;Integer&gt;		DataElement primaryKey</body></comment><class><name>StoreDatabaseIdentifier</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDatabaseIdentifier</class-id><body>This is a very very simple object that holds onto the unique name of the store database. There's only ever one of these, but it's still useful to have it mapped, if only so the object gets cached.Instance Variables:	name	&lt;String&gt;	The identifier name.</body></comment><class><name>Preloading</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.Preloading</class-id><body>Preloading is called during prerequisite and preload of a pundle</body></comment><class><name>BasicBlessingPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessings defaultBlessing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicBlessingPolicy</class-id><body>Defines the available blessing levels and the default blessing level. Provides a menu of blessings ease of use in dialogs.Instance Variables:	blessings	&lt;IdentityDictionary&gt;	maps symbol to BlessingLevel	defaultBlessing	&lt;BlessingLevel&gt; the default blessing for dialogs</body></comment><class><name>BasicMergePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>integratedBlessingChangePolicy mergeToolMinInitialTreeSize includeBranchBlessingCommentHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicMergePolicy</class-id><body>This class provides a basic merging policy.   When merging two (or more) pundles together, the default instance of this class (found in the Policies global) is consulted to decide:	1) What blessing level to set branches when merged together	2) Whether to include the entire merging blessing comment history in the blessing comment of the merged pundle	3) What is the minimum initial size of the viewable merge tree in the Merge Tool.This class will also help Store decide which pundles might be read for merging by the answer it gives to #versionsReadyForIntegration:Instance Variables:	includeBranchBlessingCommentHistory	&lt;nil|Boolean&gt;	A boolean indiciating whether to include the entire blessing comment history of the merged branches in the merged blessing comment.	integratedBlessingChangePolicy	&lt;nil|Symbol&gt;	#change or #dontChange, or if nil, then the answer to defaultIntegratedBlessingChangePolicy	mergeToolMinInitialTreeSize	&lt;nil|Number&gt;	A number that limits the size of the expanded tree view in the MergeTool.  If nil, then the answer to #defaultMergeToolMaxInitialTreeSize</body></comment><class><name>BranchingVersionPolicy</name><environment>Store</environment><super>Store.BasicVersionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BranchingVersionPolicy</class-id><body>BranchingVersionPolicy is a version policy that knows how to create branched version numbers :If there is a 1.0 and a 1.1 and a person attempts to publish a version based on 1.0, that version will be given the value 1.0.1</body></comment><class><name>StoreSettings</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StoreSettings</class-id><body>This class holds the Store specific settings</body></comment><class><name>MergeToolHelp</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>helpTextHolder helpIconList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MergeToolMods</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.MergeToolHelp</class-id><body>MergeToolHelp is the application responsible for displaying the help windows for the Merge Tool.Instance Variables:	helpIconList	&lt;SelectionInList on: (List of: LabelAndIcon)&gt;	The list of icons and their descriptions.	helpTextHolder	&lt;ValueHolder on: Text&gt;	The help text.</body></comment><class><name>Blob</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey blobType blobData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.Blob</class-id><body>Class for storing potentially large objects such as comments and properties.Instance Variables:	blobData	&lt;ByteArray | String&gt;	 data is a string or Boss'ed to a bytearray for storage	blobType	&lt;Integer&gt; type of object stored	primaryKey	&lt;Integer&gt; primaryKey in the db.</body></comment><class><name>BinaryBlob</name><environment>Store</environment><super>Store.Blob</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.BinaryBlob</class-id><body>BinaryBlob has no methods .... it exists to separate binary package store for easier clean up. And to keep the main file size down.</body></comment><class><name>StoreSignatureObject</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signatureObject </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSignatureObject</class-id><body>This class wraps implementors of equalsSignatureIn: so a set can be used for duplicate detection.Instance Variables	signatureObject	&lt;implementor of equalsSignatureIn:&gt;</body></comment><class><name>Properties</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleRef propertyRef recType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.Properties</class-id><body>Properties links PropertyRecords to Pundles.Instance Variables:	propertyRef	&lt;Integer&gt;	primaryKey of the property	pundleRef		&lt;Integer&gt;	primaryKey of the pundle	recType	&lt;Integer&gt; indicates whether this is for a bundle or package</body></comment><class><name>Reconciling</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.Reconciling</class-id><body>This is announced when Reconciling packages and bundles</body></comment><class><name>NameSpaceTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>NameSpaceCommentTag</name><environment>Store</environment><super>Store.NameSpaceTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>CodeComponentPropertiesComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightProperties leftProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.CodeComponentPropertiesComparisonView</class-id><body>I am similiar in behavior to a ClassBlueprintComparisonView, but instead of methods, my detail rows are for changed/added/removed package properties.Instance Variables	leftProperties	&lt;Array of: CodeComponentPropertyBlueprint&gt;	properties of the original package	rightProperties	&lt;Array of: CodeComponentPropertyBlueprint&gt;	evolved properties of the new package</body></comment><class><name>ElementProxy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element related cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.ElementProxy</class-id><body>Wraps an an item in a graph. For the LDM graphing tools.Instance Variables:	element	&lt;Object&gt;  an element in a graph.	related	&lt;IdentityDictionary&gt; saves key-&gt;relationships.	cache	&lt;Dictionary&gt;  passed in by the client.Used to cache all the items in the graph for sharing.</body></comment><class><name>GroupElement</name><environment>Store</environment><super>Store.ElementProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.GroupElement</class-id><body>GroupElement is used in graphing group/users/privileges</body></comment><class><name>ChangeResolver</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applied original proposed base alternatives applyable ownerName </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ChangeResolver</class-id><body>ChangeResolver holds a collection of alternatives for a definition. One of those definitions, &lt;original&gt;, reflects the state of the system at the time the ChangeResolver was created. A boolean indicates whether the proposed resolution has been applied to the image, that is, it has become the current definition of the class definition, comment, method definition, shared definition, namespace definition or property in a specific package..Instance Variables	alternatives	&lt;OrderedSet of GeneralResolution&gt;	A collection of definitions which includes, the one in the image, the one in the base, and all others in other merge packages	applied		&lt;Boolean&gt;							Boolean if the "proposed" is applied to the image	applyable	&lt;Boolean&gt;							True if this resover can be applied, false if this is just a notice object	original		&lt;GeneralResolution | nil&gt;				The definition that was in the image when we started 	proposed	&lt;GeneralResolution | nil&gt;				The definition from alternatives which is on deck or applied to the image	base		&lt;GeneralResolution | nil&gt;				The "base" is the common ancestor of all merged versions.	ownerName	&lt;String&gt;								The name of the owning object being definedSubclasses must implement the following messages:	displaying		browseVersions	private		validateParse:	resolving		apply		applyAsRemove</body></comment><class><name>ClassChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>movePair </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ClassChangeResolver</class-id><body>ClassChangeResolver is a ChangeResolver for Class DefinitionsInstance Variables	movePair	&lt;ClassChangeResovler | nil&gt;	If not nil, this change (an add or remove) has a paired remove or add</body></comment><class><name>PseudoClassCommentDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoClassCommentDifference</class-id><body>PseudoClassCommentDifference is used in the ComparePackages UI to show any comment difference between two classes</body></comment><class><name>MethodListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.MethodListPane</class-id><body>MethodListPane is used to list versions of a StoreMethodInPackage in a DefinitionsForListTool</body></comment><class><name>MethodVersionsListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.MethodListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.MethodVersionsListPane</class-id><body>MethodVersionsListPane displays versions of a single method in a class</body></comment><class><name>MismatchedDatabaseError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.MismatchedDatabaseError</class-id><body>MismatchedDatabaseError is signalled when on operation is attempted cross databases or the package isn't present on the current database when it's expected to be.</body></comment><class><name>Package</name><environment>Store</environment><super>Store.Pundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaces classes metaclasses methods binFile data overrides parcelID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Package</class-id><body>Manages the contents of a package.Description:Code components in the repository are represented as instances of Package or Bundle. Components in the local image are represented as instances of PackageModel or BundleModel. Usage:Use the global Store.Registry to obtain PackageModel and BundleModel objects. For details, see the class comment for PundleAccess.To query the database for a particular version of a named package:  Store.Package pundleWithName: 'XmlRpcClient' version:  '1.0'If you evaluate this code while connected to the repository you'll get back that version of the XmlRpcClient package.Instance Variables:	binFile	&lt;Object&gt;	description of binFile	classes	&lt;(ExceptionSet of: (ClassRecord | NameSpaceRecord)) | (SequenceableCollection of: (ClassRecord | NameSpaceRecord))&gt;	description of classes	data	&lt;Collection&gt;	description of data	metaclasses	&lt;(ExceptionSet of: (ClassDescriptor | DatumDescriptor | DefinedRecord | NameSpaceDescriptor | OverridenClass | OverridenNameSpace | OverridenStatic | PseudoPseudo)) | (SequenceableCollection of: (ClassDescriptor | DatumDescriptor | DefinedRecord | NameSpaceDescriptor | OverridenClass | OverridenNameSpace | OverridenStatic | PseudoPseudo))&gt;	description of metaclasses	methods	&lt;(Collection of: Method)&gt;	description of methods	namespaces	&lt;(ExceptionSet of: (ClassRecord | NameSpaceRecord)) | (SequenceableCollection of: (ClassRecord | NameSpaceRecord))&gt;	description of namespaces	overrides	&lt;Object&gt;	description of overrides	parcelID	&lt;Object&gt;	description of parcelID</body></comment><class><name>BundlesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleComment bundleRef expression seqNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.BundlesView</class-id><body>BundlesView appears to be obsolete.Instance Variables:	bundleComment	&lt;unknown&gt;	bundleRef	&lt;Integer&gt; primaryKey of a bundle	expression	&lt;unknown&gt;	seqNumber	&lt;Integer&gt; </body></comment><class><name>PundleInstall</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle pundleModel installed needsEarlyInstall hasRunPreload hasRunPostload completedAnalysis parentInstallObject hasRunPrerequisites </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.PundleInstall</class-id><body>PundleInstall is the abstract object for BundleInstall and PackageInstall.I am the object that represents and analyzes Pundles for the Quark installer.Subclasses must implement the following messages:	analysis		analyzeUsing:Instance Variables	completedAnalysis	&lt;Boolean&gt;	Set to true once all definitions have been analyzied and had ShadowedObjects created.	hasRunPreload	&lt;Boolean&gt;	Set to true once the preLoad has been executed for this pundle	hasRunPostload	&lt;Boolean&gt;	Set to true once the postLoad has been executed for this pundle	hasRunPrerequisites	&lt;Boolean&gt;	Set to true once all prerequisites have been run for this pundle	installed	&lt;Boolean&gt;	Set to true once this pundle has been installed.	needsEarlyInstall	&lt;Boolean&gt;	Set to true if this pundle requires early installation	parentInstallObject	&lt;BundleInstall | nil&gt;	Points to the owning BundleInstall object if I am a PackageInstall	pundle	&lt;StorePackage | StoreBundle&gt;	The actual StorePundle that I represent	pundleModel	&lt;Object | ProtoObject&gt;	description of pundleModel</body></comment><class><name>PackageInstall</name><environment>Store</environment><super>Store.PundleInstall</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadingDictionary hasInstalledEarly packageComparitor needsPackageRecompile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.PackageInstall</class-id><body>PackageInstall is where all the hard work is really done. The real analysis and gathering of ShadowedObjects is done here.I hold my own local loadingDictionary, which I send off to the AtomicAnalysisLoader only after all of my definitions have been gathered and analyzed. Instance Variables	hasInstalledEarly	&lt;Boolean&gt;	Set to true if I have been installed early	loadingDictionary	&lt;Dictionary&gt;		This is the local dictionary of ShadowedObjects that I am going to have installed.	packageComparitor	&lt;PackageComparitor&gt;	If this package is a delta vs new load, then this is the comparitor used to do the delta comparison	needsPackageRecompile	&lt;Boolean&gt;	Default: false. This is set to true if the package has a Scanner or Parser subclass, and thus all classes in the package need a recompile</body></comment><class><name>StoreBlessing</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp username comment blessingLevel trace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBlessing</class-id><body>This represents a blessing attached to a package or bundle version. Each can have multiple blessings, and blessings can be added after the bundle/package has been published. At any given point one blessing will be considered current, and its blessing level will also be stored in the package/bundle record.Instance Variables:	blessingLevel	&lt;Integer&gt;	The blessing level. The correspondence between the integers and descriptions is in Store.Policies blessingPolicy.	comment	&lt;String&gt;	The comment describing this blessing. This is essentially the version comment - the comment associated with the blessing the pundle was given when published.	timestamp	&lt;Timestamp&gt;	The time this blessing was published.	trace	&lt;nothing&gt;	This would hold the parent blessing, but it's only here because all the Store tables have these fields. Blessing trace/previous are not used.	username	&lt;String&gt;	The name of the user who published this blessing.</body></comment><class><name>Comparing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.Comparing</class-id><body>Comparing is signaled when comparing packages</body></comment><class><name>Publishing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.Publishing</class-id><body>My subject is a PublishSpecification (not a CodeComponent)</body></comment><class><name>Gathering</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.Gathering</class-id><body>Gathering is a generic I'm Doing Something announcement</body></comment><class><name>RequestNilSuperClassNotification</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Tests</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.RequestNilSuperClassNotification</class-id><body>RequestNilSuperClassNotification is triggered when a class has a nil superclass so that the ShadowedCompiler has the opportunity to provide an alternative to Class.</body></comment><class><name>PseudoNamespaceCommentDifference</name><environment>Store</environment><super>Store.PseudoClassCommentDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceCommentDifference</class-id><body>PseudoNamespaceCommentDifference is used in the ComparePackages UI to show any comment difference between two NameSpaces</body></comment><class><name>ScrolledComparisonShell</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comparisonSource expansionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.ScrolledComparisonShell</class-id><body>I am the top level view for managing a set of "Rollup" comparison views.ImplementationI use my comparisonSource (currently a CodeComponentComparison) to build a set of views for the various class, namespace, sharedvariable, and component property differences. See the 'view construction' and 'initialize' category for this.I also make sure that mouse wheel events are not handled by sub editors, but instead cause me to scroll.Perhaps the most involved thing I do, is to remember the various expansion states of my children and their children. When the comparisonSource it is necessary to throw out all the children and rebuild. But if the comparison is like the previous one (possibly a subset of it), then we want the expansions to be similiar. So I build up a dictionary indicating indirectly which children are expanded, with nested dictionaries for their children. AbstractComparisonRollupView provides the service of filling in, or restoring from these dictionaries.Instance Variables	comparisonSource	&lt;CodeComponentComparison&gt;	description of comparisonSource	expansionMemory	&lt;Dictionary&gt;	description of expansionMemory</body></comment><class><name>LoadOrSaveCompilationError</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.LoadOrSaveCompilationError</class-id><body>LoadOrSaveCompilationError is raised if the action can not be compiled</body></comment><class><name>StoreDefinitionObject</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment definition environmentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreDefinitionObject</class-id><body>This is an abstract superclass for entities representing definitions in the database. Except for methods, whose structure is different enough to put them on their own.Instance Variables:	comment	&lt;StoreBlob&gt;	The comment for the entity	definition	&lt;StoreBlob&gt;	The definition (i.e. source code) string for the entity.	environmentName	&lt;String&gt;	The long name of the namespace in which the object is defined. e.g. Root.Smalltalk.Core.</body></comment><class><name>StoreClassDefinition</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassName </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreClassDefinition</class-id><body>This represents a class definition - that is to say the name, superclass, instance variables, and so forth.Instance Variables:	superclassName	&lt;String&gt;	The long name of the superclass. e.g. Root.Smalltalk.Core.Object.</body></comment><class><name>Subdef</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCodeID sourceCodeString creatorPackage creatorPackageVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.Subdef</class-id><body>Superclass for sub-definition records. Currently only methods, but we can't reorganize because of the current EXDI interface requirement of maintaing instance var order.Instance Variables:	creatorPackage	&lt;Integer&gt;	primaryKey of the package in which this defintion was first published	creatorPackageVersion	&lt;String&gt;	cache of the version string of the creatorPackage.	sourceCodeID	&lt;Integer&gt;	primaryKey of the Blob containing the source string	sourceCodeString	&lt;String&gt;	cache of the source code string.</body></comment><class><name>NameSpaceListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.NameSpaceListPane</class-id><body>NameSpaceListPane is used to list versions of a StoreNameSpace in a DefinitionsForListTool</body></comment><class><name>DeletionToolFilterTool</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingGreaterThanCheck afterDateCheck pundleName afterDate beforeDate blessingLessThan versionLikeCheck blessingLessThanCheck nameLikeCheck blessingGreaterThan beforeDateCheck versionLike filter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.DeletionToolFilterTool</class-id><body>DeletionToolFilterTool is a tool which creates a DeletionToolFilter object that is usable by the MarkPundlesForDeletionToolInstance Variables:	afterDate	&lt;ValueModel on Date&gt;	aDate entered for filtering the pundle version list(s)	afterDateCheck	&lt;ValueModel on Boolean&gt;	if true, then the afterDate value will be enabled and applied	beforeDate	&lt;ValueModel on Date&gt;	aDate entered for filtering the pundle version list(s)	beforeDateCheck	&lt;ValueModel on Boolean&gt;	if true the beforeData value will be enabled and applied	blessingGreaterThan	&lt;ValueModel on Integer&gt;	a blessing level for being equal or greater than to filter the pundle version list(s)	blessingGreaterThanCheck	&lt;ValueModel on Boolean&gt;	if true the blessing greater than level is enabled and applied	blessingLessThan	&lt;ValueModel on Integer&gt;	a blessing level for being equal or less than to filter the pundle version list(s)	blessingLessThanCheck	&lt;ValueModel on Boolean&gt;	if true the blessing less than level is enabled and applied	filter	&lt;DeletionToolFilter&gt;	The current DeletionToolFilter object being edited	nameLikeCheck	&lt;ValueModel on Boolean&gt;	if true the pundle name string is enabled and applied	pundleName	&lt;ValueModel on String&gt;	the pundle name match string to filter the pundle name list(s)	versionLike	&lt;ValueModel on String&gt;	the verion name match string to filter the pundle version list(s)	versionLikeCheck	&lt;ValueModel on Boolean&gt;	if true the version name match string is enabled and applied</body></comment><class><name>PkgNameSpacesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString packageRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgNameSpacesView</class-id><body>Maps Packages to NameSpaces.Instance Variables:	commentID	&lt;Integer&gt;  link to blob table pointing to the namespace comment	definitionID	&lt;Integer&gt;  link to blob table pointing to namespace definition	definitionOrder	&lt;Integer&gt;  load order	environmentString	&lt;String&gt; absolute environment strng of the namespace	packageRef	&lt;Integer&gt;  link to package</body></comment><class><name>LoadAnalyzer</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes nameSpaces methodDict dataDict toPackage classesAreAlien wholePackage classesWithoutSuper classesWithNoEnvironment nameSpacesWithNoEnvironment withinBundle leafItems overrides </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database</category><attributes><package>Store-Database</package></attributes></class><comment><class-id>Store.LoadAnalyzer</class-id><body>LoadAnalyzer does a pre-load analysis for obvious failure conditions such as methods in classes that aren't in the image or in the current load. It displays the errors and offers the user the choice to abort or to attempt the load.Instance Variables:	classes	&lt;Collection of: ClassRecord&gt;	Classes being loaded	classesWithNoEnvironment	&lt;Collection of: ClassRecord&gt; - Classes whose environment isn't in the image or the load	classesWithoutSuper	&lt;Collection of: ClassRecord&gt; - Classes whose superclass isn't in the image or the load	dataDict	&lt;Dictionary&gt; - Class to DataKey dictionary for verifying shared enviornments	leafItems	&lt;Collection&gt; - collection of the package names being loaded	methodDict	&lt;IdentityDictionary&gt;	Class to selector dictionary for verify the existance of classes for methods	nameSpaces &lt;Collection of: NameSpaceRecord&gt;	 NameSpaces being loaded	nameSpacesWithNoEnvironment	&lt;Collection of: NameSpaceRecord&gt; - NameSpaces whose environment isn't in the image or the load	overrides	&lt;OrderedCollection of Overrides&gt; - Overrides that this load would contain	toPackage	&lt;PackageModel&gt; - the Package we ware loading into	wholePackage	&lt;Boolean&gt;	whether we are loading the entire package or individual definitions. Defaults to true.	withinBundle &lt;Bundle &gt;	the bundle being loaded, nil if loading a package</body></comment><class><name>Method</name><environment>Store</environment><super>Store.Subdef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className meta metaString protocolName documentStr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.Method</class-id><body>The database record for methods.Instance Variables:	className	&lt;String&gt;	absolute path of the method's class	documentStr	&lt;String or XML&gt; method documentation	meta	&lt;Boolean&gt;	true if this is a class side method	metaString	&lt;String&gt; T for class side, F for instance side method	protocolName	&lt;String&gt;	the protocol</body></comment><class><name>SharedChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.SharedChangeResolver</class-id><body>SharedChangeResolver represents changes to a Shared in either a Class or Namespace</body></comment><class><name>InstallingDatabaseTables</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.InstallingDatabaseTables</class-id><body>InstallingDatabaseTables is announced when installing database tables</body></comment><class><name>OwnerBlessingPolicy</name><environment>Store</environment><super>Store.BasicBlessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.OwnerBlessingPolicy</class-id><body>A policy for blessings that has a concept of package/bundle ownership.</body></comment><class><name>EnvyStyleBlessingPolicy</name><environment>Store</environment><super>Store.OwnerBlessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.EnvyStyleBlessingPolicy</class-id><body>EnvyStyleBlessingPolicy is a simplified EnvyStyleBlessingPolicy</body></comment><class><name>StoreLoadRecord</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username pundleName type version timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreLoadRecord</class-id><body>This mirrors the LoadRecord class in Store for 7.5. It is not usedInstance Variables	pundleName	&lt;Object | ProtoObject&gt;		timestamp	&lt;Object | ProtoObject&gt;		type	&lt;Object | ProtoObject&gt;		username	&lt;Object | ProtoObject&gt;		version	&lt;Object | ProtoObject&gt;	</body></comment><class><name>PublishSpecificationList</name><environment>Store</environment><super>Core.List</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>publisher notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>Store-IMG-Configurations</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.PublishSpecificationList</class-id><body>A List of PublishSpecifications. These are for the master bundle/package and all sub-components.</body></comment><class><name>PackageChanges</name><environment>Store</environment><super>Store.PundleChanges</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PackageChanges</class-id><body>A PackageChanges computes the changes between two packages where one may be an image version..</body></comment><class><name>PackageComparisonTool</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.PackageComparisonTool</class-id><body>I am a high level view for creating a package comparison tool, which has a headerBand (PackageComparisonHeaderView), a mainArea (ScrolledComparisonShell) and a button for opening help.I also have services for opening up a window around me, and showing feedback while computing the actual CodeComponentComparison.</body></comment><class><name>LoadDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.LoadDialog</class-id><body>Validates a bundle and displays possible reasons why a user may not wish to continue the load.</body></comment><class><name>StoreRBInitializerDefinition</name><environment>Store.Glorp</environment><super>Refactory.Browser.RBInitializerDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreRBInitializerDefinition</class-id><body>StoreRBInitializerDefinition is used when browsing Store/Glorp database objects</body></comment><class><name>ResolutionsPane</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeTool nameStyle list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionsPane</class-id><body>ResolutionsPane is an abstract class. Its subclasses are used to display the modifications in either a list or a tree.Subclasses must implement the following messages:	aspects		list	name style		setShowLongNames		setShowShortNames	updating		updateResolutionsInstance Variables	list	&lt;SelectionInList&gt;	List of Resolutions	mergeTool	&lt;MergeTool&gt;	MergeTool	nameStyle	&lt;ByteSymbol&gt;	The style used to display the namespace names.</body></comment><class><name>ResolutionsListPane</name><environment>Store</environment><super>Store.ResolutionsPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionsListPane</class-id><body>ResolutionsListPane is used to display the the merge tool modification sets in a selection list.</body></comment><class><name>StoreLoginFactory</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpVWUI</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreLoginFactory</class-id><body>This is a convenience object for creating Glorp logins for Store databases out of Store's named databae identifiers. It has logic to convert the data into our login, and also knows about Store-specific things that ought to be done for specific databases, either because of the way Store uses schemas there, for performance, or whatever other reasons.</body></comment><class><name>PkgClasses</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef classRef metaclassRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgClasses</class-id><body>Package to classes mapping.Instance Variables:	packageRef	&lt;Integer&gt;	Package primaryKey	classRef	&lt;Integer&gt;	ClassRecord primaryKey	metaclassRef	&lt;Integer&gt;	meta ClassRecord primaryKey	definitionOrder	&lt;Integer&gt;	load order index</body></comment><class><name>StorePublishDialog</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars>developmentTabLabels runtimeTabLabels tabSpecsAndHelpSelectors </class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StorePublishDialog</class-id><body>StorePublishDialog is an abstract class that provides for tabbed selection and acceptance of user modifiable setting or property pages. Subclasses must implement the following messages:	class protocol:		constants			windowLabelInstance Variables	disturbed	&lt;ValueModel on: Boolean&gt;	True on page entry change.	list	&lt;SelectionInList&gt;	Selection model.	subBuilder	&lt;UIBuilder&gt;	Page subcanvas builder.Class Instance Variables	developmentTabLabels	&lt;OrderedCollection of: String&gt;  Labels of the dialog tabs shown at development time.  	runtimeTabLabels	&lt;OrderedCollection of: String&gt; Labels of the dialog tabs shown at runtime. 	tabSpecsAndHelpSelectors	&lt;OrderedCollection of: Array&gt; A collection of the same size as developmentTabLabels, with two-element arrays as entries. The first element is the spec to use for the tab, the second is the selector to send to the application to get help text for the tab.   </body></comment><class><name>PublishPundleDialog</name><environment>Store</environment><super>Store.StorePublishDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items blessingLevel blessingComment publish versionString binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelSaveSource parcelHideSource parcelPadded parcelRepublish parcelBackup parcelOverwrite parcelWarningMessage labelDict offsets callBackBlock retry files publishFile parcelVersionString pundleModel </inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			</imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishPundleDialog</class-id><body>Tabbed dialog for all publishing options.Instance Variables	items	&lt;SelectionInList&gt; a collection of user data for each pundle		blessingLevel	&lt;ValueHolder&gt;	current item's blessing level	blessingComment	&lt;ValueHolder &lt;String&gt;	current item's comment	publish	&lt;ValueHolder &lt;Boolean&gt;&gt;	indicates if current selection is to be published	versionString	&lt;ValueHolder &lt;String&gt;&gt;	current item's version string.	binarySave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish binary	parcelSave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish as a parcel	bundleStructure	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save bundle structure in parcel.	databaseLinks	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save links to current db in parcel.	parcelDirectory	&lt;ValueHolder &lt;Filename&gt;&gt;	directory for parcel	parcelSaveSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels.	parcelHideSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelPadded	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelRepublish	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelBackup	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelOverwrite	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelWarningMessage	&lt;ValueHolder &lt;String&gt;&gt;	message that explains why a parcel cannot be published.	parcelVersionString	&lt;ValueHolder &lt;String&gt;&gt; If there is a parcel to publish, this is the version string for the Parcel (which can be different than the package/bundle)	labelDict &lt;Dictionary&gt; Cache of item labels.	offsets	&lt;Array&gt;	 Cache of label offsets	callBackBlock &lt;OneArgumentBlock&gt; Block for post-processing after publish.	retry &lt;Boolean&gt; Flag that indicates wheter to close the dialog, or retry if publish was canceled</body></comment><class><name>PkgDefinedRecordView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString packageRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgDefinedRecordView</class-id><body>PkgDefinedRecordView is obsolete. It would be the superclass of the many-to-many link tables for packages to it's definitions.I think this was an attemp to refactor classes that couldn't work because the current EXDI interfaced doesn't allow instance variables to change order.  Leaving it here for when that changes.Instance Variables:	commentID	&lt;Integer&gt; - primaryKey of the definition comment	definitionID	&lt;Integer&gt; - primaryKey of the definition string	definitionOrder	&lt;Integer&gt; - if ordered, the order to load in	environmentString	&lt;String&gt; - the absolute path of the definitions load environment	packageRef	&lt;Integer&gt; - primaryKey of the containing package</body></comment><class><name>GlorpWorkbook</name><environment>Glorp.UI</environment><super>Tools.Workbook</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpVWUI</category><attributes><package>StoreForGlorpVWUI</package></attributes></class><comment><class-id>Glorp.UI.GlorpWorkbook</class-id><body>Glorp.UI.StoreWorkbook openInstance Variables:	session	&lt;GlorpSession&gt; StoreForGlorp session</body></comment><class><name>StoreWorkbook</name><environment>Glorp.UI</environment><super>Glorp.UI.GlorpWorkbook</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorpVWUI</category><attributes><package>StoreForGlorpVWUI</package></attributes></class><comment><class-id>Glorp.UI.StoreWorkbook</class-id><body>StoreWorkbook is the notebook UI that opens on a Glorp connection which shows examples of how to interact with Store.Glorp database objects</body></comment><class><name>Packages</name><environment>Store</environment><super>Store.BundlePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Packages</class-id><body>Bundle to Package.Instance Variables:	packageRef	&lt;Integer&gt;	package's primaryKey</body></comment><class><name>StoreBrowserOverviewTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.BrowserOverviewTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreBrowserOverviewTool</class-id><body>I show a terse "Overview of the Browser" style message when nothing is selected in the Store Browser.</body></comment><class><name>LoadRecord</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username pundleName pundleType pundleVersion timeStamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.LoadRecord</class-id><body>This represents a record of someone loading a package or bundle from a Store repository, and can be used for analysis purposes. In normal Store usage these are write-only.Instance Variables:	pundleName	&lt;String&gt;	The name of the package or bundle being loaded.	pundleType	&lt;String&gt;	Either B or P, for Bundle or Package.	pundleVersion	&lt;String&gt;	The version string for the thing to be loaded.	timestamp	&lt;Timestamp&gt;	The time at which the load was done.	username	&lt;String&gt;	The username of the account doing the loading.</body></comment><class><name>StoreMethod</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version source className isMetaclass protocol comment selector </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreMethod</class-id><body>This represents the definition of a method. Note that this can be shared between many package versions. See also StoreMethodInPackage.Instance Variables:	className	&lt;SequenceableCollection | TextFigure&gt;	description of className	isMetaclass	&lt;Boolean&gt;	If true, then this is a class method. Otherwise it's an instance method.	protocol	&lt;String&gt;	The protocol/method category in which this method exists.	source	&lt;StoreBlob&gt;	The blob that holds our source code.	comment	&lt;Unused | StoreBinaryBlob&gt;	Not at this point used. In place for SmalltalkDoc to be able to store non-inline method comments.	version	&lt;Unused&gt;	Presumably this is there for symmetry with the other tables, but individual methods are not given version names.</body></comment><class><name>BundleStructureTag</name><environment>Store</environment><super>Store.AbstractComponentTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>Compiling</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Compiling</class-id><body>This is annouced when Compiling during a Load</body></comment><class><name>ObsoleteBrowserContent</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session wasUsed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.ObsoleteBrowserContent</class-id><body>Stateless announcement triggered when an unhandled GlorpError is raised.</body></comment><class><name>StoreFile</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents filename fileSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreFile</class-id><body>Store bundles can be associated with arbitrary external files. This represents the definition of such a file.Instance Variables:	contents	&lt;StoreBinaryBlob&gt;	The contents of the file	filename	&lt;ByteArray&gt;	The BOSS Encoding of the filename object representing the path of this object.	fileSize	&lt;Integer&gt;	The size of the file.</body></comment><class><name>PreReadActionConfirmation</name><environment>Store</environment><super>Store.LoadOrSaveActionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.PreReadActionConfirmation</class-id><body>PreReadActionConfirmation is raised if the pre read action can not be executed</body></comment><class><name>PropertyChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertyKey </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PropertyChangeResolver</class-id><body>PropertyChangeResolver is a resolution for Package/Bundle propertiesInstance Variables:	propertyKey	&lt;Symbol&gt;	this is the "AT" part when doing the at put for a property</body></comment><class><name>StorePublishingError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StorePublishingError</class-id><body>StorePublishingError is raised when a GlorpDatabaseWriteError occurs, and provides a dialog that notifies the user of the problem</body></comment><class><name>UserCancelledPublish</name><environment>Store</environment><super>Store.StorePublishingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UserCancelledPublish</class-id><body>UserCancelledPublish is raised if the user cancels publishing when asked to enter a new version</body></comment><class><name>BasicPrerequisitePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchOrder versionSelection blessingLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicPrerequisitePolicy</class-id><body>The policies for resolving which development prerequisite to load.Instance Variables:	searchOrder			&lt;Symbol&gt; #parcelsFirst or #pundlesFirst.  Flag to determine whether to first meet the							development prerequisite with a parcel or a bundle, when the prerequisite type is #any.	versionSelection		&lt;Symbol&gt;	#ask or #latest.  Flag to determine whether to ask the user, or use the latest							version with at least a blessing level of blessingLevel.	blessingLevel		&lt;Integer&gt;	The blessing level used if #latest is the versionSelection criteria</body></comment><class><name>PseudoNamespaceDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedDifferences mainComment mainDefinition otherComment otherDefinition </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceDifference</class-id><body>PseudoNamespaceDifference holds on to a Namespace difference, along with any shared differences that the namespace my have.Instance Variables	sharedDifferences	&lt;Object | ProtoObject&gt;	description of sharedDifferences</body></comment><class><name>PseudoNamespaceExtensionDifference</name><environment>Store</environment><super>Store.PseudoNamespaceDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceExtensionDifference</class-id><body>PseudoNamespaceExtensionDifference is used when a Namespace is extended with Shareds in a Package</body></comment><class><name>AbstractResolutions</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolutions name </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.AbstractResolutions</class-id><body>AbstractResolutions is the abstract class for the non leaf items in the tree of a Merge.Subclasses must implement the following messages:	displaying		browseVersionsInstance Variables:	name	&lt;String&gt;	This is the name of the thing, such as the Package name, the Class name, Namespace name or '[Properties]'	resolutions	&lt;Dictionary&gt;	 Where each key the value to display in the tree, and the value is a Resolutions or a Resolver</body></comment><class><name>ClassResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classInImage </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ClassResolutions</class-id><body>ClassResolutions holds resolutions for Class objects (MethodChangeResolvers, ClassChangeResolvers, ClassCommentChangeResolvers, SharedChangeResolvers)</body></comment><class><name>PackageDifferences</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes1 classes2 meta1 meta2 nameSpaces1 nameSpaces2 methods1 methods2 data1 data2 pkg1 pkg2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PackageDifferences</class-id><body>This hold the set of differences between two packages.  It holds definitions of methods and classes that are different from package to package. Instances of this class are used by a difference browser.Instance Variables:	classes1	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #1 	but not in the package #2	classes2	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #2 	but not in the package #1	data1	&lt;(SequenceableCollection of: DataElement)&gt; 	definitions that are in the package #1 	but not in the package #2	data2	&lt;(SequenceableCollection of: DataElement)&gt; 	definitions that are in the package #2 	but not in the package #1	meta1	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #1 	but not in the package #2	meta2	&lt;(SequenceableCollection of: ClassRecord)&gt; 	definitions that are in the package #2 	but not in the package #1	method1	&lt;(SequenceableCollection of: Method)&gt; 	definitions that are in the package #1 	but not in the package #2	method2	&lt;(SequenceableCollection of: Method)&gt; 	definitions that are in the package #2 	but not in the package #1	data1	&lt;(SequenceableCollection of: NameSpaceRecord)&gt; 	definitions that are in the package #1 	but not in the package #2	data2	&lt;(SequenceableCollection of: NameSpaceRecord)&gt; 	definitions that are in the package #2 	but not in the package #1	pkg1	&lt;Package&gt;		package #1	pkg2	&lt;Package&gt;		package #2</body></comment><class><name>NamespaceCommentChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id><body>NamespaceCommentChangeResolver is a resolver that represents a NameSpace Comment</body></comment><class><name>WasConvertedFromParcelWithUndeclaredError</name><environment>Store</environment><super>Store.ContainsUndeclaredError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.WasConvertedFromParcelWithUndeclaredError</class-id><body>WasConvertedFromParcelWithUndeclaredError is raised if an attempt to publish a Package that was converted from a Parcel which has undeclared objects in it</body></comment><class><name>StoreMethodDefinition</name><environment>Store.Glorp</environment><super>Tools.MethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreMethodDefinition</class-id><body>StoreMethodDefinition is used when browsing Store/Glorp objects</body></comment><class><name>ReplaceModifiedPackageNotice</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.ReplaceModifiedPackageNotice</class-id><body>ReplaceModifiedPackageNotice is raised if a version of a package is being loaded over a version that is modified in the image</body></comment><class><name>PundleVersionSelector</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleVersions mergeList pundleList mergeTool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MergeToolMods</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PundleVersionSelector</class-id><body>PundleVersionSelector is used by the merge tool to display and select the various pundles to merge.Instance Variables	mergeList	&lt;MultiSelectionInList&gt;	Selected pundles to merge.	mergeTool	&lt;MergeTool&gt;	The merge tool.	pundleList	&lt;SelectionInList&gt;	List of pundles to choose from.	pundleVersions	&lt;MultiSelectionInList&gt;	List of versions of the selected pundle.</body></comment><class><name>PropertyRecord</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PropertyRecord</class-id><body>PropertyRecord holds the database information for a pundle property.As with DefinedRecord subclasses (ClassRecord, DataElement, NameSpaceRecord),PropertyRecord objects live in their own table (TW_PROPERTY), and are referencedthrough an intermediate table (TW_PROPERTIES). Using the intermediate tableallows for multiple packages to reference a single property record. In this way,a property can be defined once and carried forward to subsequent versions ofthe same package, without being duplicated. Only the "reference" is duplicated.Alternatively, a property can be redefined with every published version.Each property record has a comment along with a property value.Instance Variables:	commentID	&lt;Integer&gt;	 the blob ID for the BOSSed comment.	commentStr	&lt;ByteArray&gt;	the BOSSed comment.	package	&lt;Package&gt;	the package this property is defined for.	propertyID	&lt;Integer&gt; 	the blob ID for the BOSSed property.	propertyStr	&lt;ByteArray&gt; 	the BOSSed property.	searchString&lt;String&gt;		the 1st 255 chars of property, if property isKindOf: String.Inherrited Instance Variables:	dbIdentifier	&lt;Object&gt;	Identifies which database this record is from.	name	&lt;String&gt;	Name of this property.	primaryKey	&lt;CharacterArray | CharacterBlock | Magnitude&gt;	PrimaryKey of this property record.	timeStamp	&lt;Object&gt;	description of timeStamp	trace	&lt;ArithmeticValue&gt;	description of trace	userName	&lt;Object&gt;	description of userName	version	&lt;Dialog | Object&gt;	description of version</body></comment><class><name>StoreCodeModel</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractCodeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeModel</class-id><body>I manage the tabbed collection of CodeTools and the status bar for the Store Browser.</body></comment><class><name>StoreNotConnectedError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.StoreNotConnectedError</class-id><body>StoreNotConnectedError is unused. LostConnectionNotification is used instead.</body></comment><class><name>StoreSelectorProtocolNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SelectorProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id><body>StoreSelectorProtocolNavigatorPart is used when browsing Glorp/Store Database objects</body></comment><class><name>FileoutDifferencesDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>from to </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><class><name>DeletionToolFilter</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleName versionLike beforeDate afterDate blessingGreater blessingLess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.DeletionToolFilter</class-id><body>DeletionToolFilter is used by the DeletionToolFilterTool to edit a filter for use in the MarkPundlesForDeletionToolInstance Variables	afterDate		&lt;Date | nil&gt;		filter the versions to only items after this date	beforeDate		&lt;Date | nil&gt;		filter the versions to only items before this date	blessingGreater	&lt;Integer | nil&gt;	filter the versions to only items with blessing level greater than this	blessingLess	&lt;Integer | nil&gt;	filter the versions to only items with blessing level less than this	pundleName		&lt;String | nil&gt;		filter the package and names to only names matching this	versionLike		&lt;String | nil&gt;		filter the versions to only items with version names like this</body></comment><class><name>StoreSharedVariableProtocolNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SharedVariableProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableProtocolNavigatorPart</class-id><body>StoreSharedVariableProtocolNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>PseudoClassDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodDifferences sharedDifferences </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoClassDifference</class-id><body>PseudoClassDifference holds on to a Class difference, along with any method differences that class my have.Instance Variables	methodDifferences	&lt;(Collection of: PseudoMethodDifference)&gt;	description of methodDifferences	sharedDifferences	&lt;Collection of: PseudoMethodDifferences)&gt;	</body></comment><class><name>StoreAbstractClassExtension</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreAbstractClassExtension</class-id><body>This represents a class in the more normal Smalltalk sense, something with both variables and methods. It's called a class extension to distinguish that it may be a partial class. That is, this is the definition and/or instance methods and/or class methods associated with a particular package. Any of those pieces may be missing.Subclasses must implement the following messages:	accessing		classDefinition		instanceMethods		longName		timestampInstance Variables	organization	&lt;ClassOrganizer&gt;	The Class Organizer for this object</body></comment><class><name>StoreClassExtension</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreAbstractClassExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDefinition classMethods name longName package instanceMethods metaclass sharedVariables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreClassExtension</class-id><body>This represents a class, or a piece of a class. In the Store schema there really isn't such an entity. We just have the class definition, method definitions, but nothing that ties them together but a name. This is a thing that holds them all together. It will have to be assembled out of those pieces, either in-memory or via some sophisticated (i.e. slow) queries. This doesn't have to have any of the pieces. If we have only methods, but not the definition, then this is more like an ENVY class extension - hence the name. But it can also represent something that has the definition and may or may not have methods as well.Instance Variables:	classDefinition	&lt;StoreClassDefinitionInPackage&gt;	The definition of this class. This doesn't have to be present.	classMethods	&lt;Collection of: StoreMethodDefinitionInPackage&gt;	Our class methods.	instanceMethods	&lt;Collection of: StoreMethodDefinitionInPackage&gt;	Our instance methods.	longName	&lt;String&gt;	The long name of the class. That is Root.Smalltalk.Whatever.Whatever	metaclass	&lt;StoreMetaclassExtension&gt;	A representation of our metaclass. This doesn't have a lot of useful data, since we have our class methods here, but one of the purposes of this is to be able to use these as proxies for real classes when browsing, so the browser can be made to browse the database without really knowing it. In that usage it's likely to to want an equivalent of a metaclass for us.	name	&lt;String&gt;	Our short name.	package	&lt;StorePackage&gt;	The package that contains us.	sharedVariables	&lt;Collection of: StoreSharedVariableInPackage&gt;	Our shared variable definitions.</body></comment><class><name>DataTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey forClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>NamespaceChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>movePair </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NamespaceChangeResolver</class-id><body>NamespaceChangeResolver is a resolver that represents a NameSpace DefinitionInstance Variables	movePair	&lt;NamespaceChangeResovler | nil&gt;	If not nil, this change (an add or remove) has a paired remove or add</body></comment><class><name>Renaming</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.Renaming</class-id><body>Renaming is announced when a Package or Bundle is being renamed in a repository</body></comment><class><name>NamespaceBlueprintComparisonView</name><environment>Tools</environment><super>Tools.BindingBlueprintComparisonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.NamespaceBlueprintComparisonView</class-id><body>Namespace specific variant for showing namespace changes.ImplementationMost of my behavior is derived from my super class, I just provide the required queries: bindingTest, defaultIcon, and detail rows for comments and import strings. My leftBlueprint and rightBlueprint objects should be nil or NamespaceBlueprints.</body></comment><class><name>LoadingParcel</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.LoadingParcel</class-id><body>My subject is a String indicating the name of the parcel</body></comment><class><name>StoreCodeComponentPropertyInspector</name><environment>Store.Glorp</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertyParts </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Trippy.*			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id><body>I provide an inspector like experience for editing the properties of a code component. I was really just designed to be used in an "embedded" mode and should always be pointed at a StorePundle.I collaborate with a special Part subclass: CodeComponentProperty.From an interaction point-of-view, I'm modeled somewhat after a DictionaryInspector.</body></comment><class><name>SpinnerIcons</name><environment>Store</environment><super>AlphaBlendedIcons</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.SpinnerIcons</class-id><body>This class defines the spinner icons used in the StoreProgressView</body></comment><class><name>SubdefView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className packageRef sourceCodeID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.SubdefView</class-id><body>SubdefView is the abstract superclass for views on subdefintions (currently only methods)Instance Variables:	className	&lt;String&gt;	absolute class name of the method's class.	packageRef	&lt;Integer&gt; PrimaryKey of the containing package	sourceCodeID	&lt;Integer&gt; PrimaryKey of the source code.</body></comment><class><name>MethodsView</name><environment>Store</environment><super>Store.SubdefView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocolName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.MethodsView</class-id><body>The view for collecting methods in a package.Instance Variables:	protocolName	&lt;string&gt;	method protocol</body></comment><class><name>MethodsAndSourcesView</name><environment>Store</environment><super>Store.MethodsView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.MethodsAndSourcesView</class-id><body>Extends MethodsView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	MethodsWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>AtomicAnalysisLoader</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>installObjects pundles loadingDictionary dllccLoaded earlyInstallClassNames compilationManager shadowCompiler fullLoadClasses sortedFullClasses unloadableDefinitions pundlesNeedPostInstallReconcile classesToInitialize overrides overriddenClasses bindingsToInitialize classesToNotify lastPundleWorkedOn ignoreUnloadables </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.AtomicAnalysisLoader</class-id><body>AtomicAnalysisLoader is the managing engine for the Quark analysis loader. When the Quark feature is turned on, then this class, instead of the AtomicCompilationManager is the driving engine for compiling and loadingInstance Variables	bindingsToInitialize	&lt;OrderedCollection of: BindingReference&gt; The bindingreferences for shared variables that need to be told to initialize once the installation is complete.	classesToInitialize	&lt;OrderedCollection of: Class&gt; The classes that need to be sent #postLoad: once the installation is complete.	classesToNotify	&lt;Collecton of: Class&gt; The classes that need to be sent #instanceMethodsChange once the installation is complete and after classes have been sent #postLoad:	compilationManager	&lt;AtomicCompilationManager&gt;	The CompilationManager used when compiling	dllccLoaded	&lt;Boolean&gt;	True if (or when) the DLLCC package/parcel is loaded.	earlyInstallClassNames	&lt;Collection of: String&gt;	A collection of names of class names that are subclasses of Scanner and SmalltalkCompiler that are in the system. This is recalculated every time there is an early install.	fullLoadClasses	&lt;SequenceableCollection&gt;	A collection of all locally defined classes during the whole compilation. Used for method ordering.	ignoreUnlodables &lt;Boolean&gt; Default : false. If ever set to true, don't bother with checking about unloadables for the rest of the load	installObjects	&lt;(Collection of: (BundleInstall | PackageInstall))&gt;	A collection of Install objects that I am analyzing compiling and installing.	lastPundleWorkedOn	&lt;StorePundle&gt;	Private: Used internally to keep track of what we are working on.	loadingDictionary	&lt;Dictionary&gt;		This is the global dictionary of ShadowedObjects that I am installing.	methodsMovedFromOriginalBinding &lt;Boolean&gt;	If a definition was on a Class but that class is now a Shared that points to a different class, we set this to true	overriddenClasses	&lt;Collection&gt;	The subset of Overrides that are classes which need to be recompiled	overrides	&lt;Collection&gt;	 Collection of Override objects we need to install	pundles	&lt;(Collection of: StorePundle)&gt;	This is the collection of root pundles that I am installing	shadowCompiler	&lt;ShadowCompiler&gt;	This is an instance of the ShadowCompiler	sortedFullClasses	&lt;Collection&gt;	Private: Used internally for detecting redefined and special early install situations	unloadableDefinitions	&lt;Collection&gt;	This is a collection of any things I can't compile</body></comment><class><name>StoreUserGroup</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>groupName userName type session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreUserGroup</class-id><body>StoreUserGroup represents a user (if type = 'U') or group (if type = 'G') in the minimal privileges system, where a user/group may be limited to publishing various pundles by their entries in the TW_DBPundlePriviliges table (StoreAccessPrivileges)Instance Variables	groupName	&lt;String&gt;	The name of a Group that is associated with bundle/package privileges	session		&lt;GlorpSession&gt;	type	&lt;String&gt;		'U' = User, 'G' = Group	userName	&lt;String&gt;	The name of a User that is associated with bundle/package privileges</body></comment><class><name>InitializerFailedError</name><environment>Store</environment><super>Store.LoadingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.InitializerFailedError</class-id><body>InitializerFailedError is used when an initializer fails, to tell the package to not mark itself clean at the end of loading</body></comment><class><name>StoreClassAndMethodTabNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassAndMethodTabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart</class-id><body>StoreClassAndMethodTabNavigatorPart is used when browsing Glorp/Store objects from a Database</body></comment><class><name>NameSpaceRecord</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.NameSpaceRecord</class-id><body>A NameSpaceRecord represents a NameSpace definition that is stored in a database.</body></comment><class><name>Methods</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef methodRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.Methods</class-id><body>Package to Method talbe.Instance Variables:	packageRef	&lt;Integer&gt;	Package primaryKey	methodRef	&lt;Integer&gt;	Method primaryKey</body></comment><class><name>PackageResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PackageResolutions</class-id><body>PackageResolutions is another aggregator object which holds: PropertyResolutions, NamespaceResoltuions, ClassResolutions and PropertyResolutions</body></comment><class><name>Blessing</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey timeStamp userName commentID blessingLevel trace pkgID commentString recType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.Blessing</class-id><body>Blessing describes the status of a version in the database. See BasicBlessingPolicy&gt;&gt;initializeBlessings for the default blessing values. It also allows the user to attach a comment to the version. There can be multiple Blessing records attached to a single version.Instance Variables:	blessingLevel	&lt;Integer&gt; the blessing level	commentID	&lt;Integer&gt; primaryKey of the blessing comment	commentString	&lt;String&gt;&gt; comment string	pkgID	&lt;Integer&gt;&gt; primaryKey of the package/bundle this blessing belongs to	primaryKey	&lt;Integer&gt; primaryKey	recType	&lt;Single char String&gt; the refered object's #typeStringForBlessing	timeStamp	&lt;Integer&gt;&gt; timestamp	trace	&lt;Integer&gt; primaryKey of this records parent	userName	&lt;String&gt; the user that published this record.</body></comment><class><name>Files</name><environment>Store</environment><super>Store.BundlePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Files</class-id><body>Files links multipe FileRecords to a bundle.Instance Variables:	fileRef	&lt;Integer&gt;	primaryKey of a FileRecord</body></comment><class><name>ShadowNameSpaceHandler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shadowRoot </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>System-Name Spaces</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Kernel.ShadowNameSpaceHandler</class-id><body>ShadowNameSpaceHandler is used by the ShadowCompiler to control how bindings are resolved.  When executing compiled definitions (for example a class definition, or namespace definition) in a shadow namespace, we want to lookup any binding first in the shadow namespace to resolve the binding, and if it is not found then look in system namespace.  This class, when used with Process&gt;&gt;#scopeEnviornmentWith:, controls the lookup.   Instance Variables:	shadowRoot	&lt;NameSpace&gt;	The shadow namespace to use for resolving bindings</body></comment><class><name>TextModification</name><environment>Store</environment><super>Store.AbstractModification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.TextModification</class-id><body>TextModification is a kind of modification that is in the image but not anywhere in the database.Instance Variables:	text	&lt;String&gt;	The source code describing the modification</body></comment><class><name>StoreSharedVariable</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol isClassVariable </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariable</class-id><body>This represents the definition of a shared variable in either a class or a namespace.Instance Variables:	isClassVariable	&lt;Boolean&gt;	Is this a class variable, or does it stand alone in a namespace.	protocol	&lt;String&gt;	Shared variables, like methods, are grouped into protocols. This holds the name of the protocol containing this variable.</body></comment><class><name>RequestImageAdministatorName</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.RequestImageAdministatorName</class-id><body>RequestImageAdministatorName requests the name of a user to administrate the image.If dealt with in a resume, it will answer the userNameIf dealt with in a resume: aString it will answer aString</body></comment><class><name>AbsentResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applied </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.AbsentResolution</class-id><body>AbsentResolution is used when there is no image or base version of a change, and thus is "absent from the image"Instance Variables	applied	&lt;Boolean&gt;	True when applied</body></comment><class><name>AbstractPseudo</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.AbstractPseudo</class-id><body>This is the abstract superclass of various kinds of placeholder or pseudo definition classes.  This abstract superclass provides the common support for those placeholders.These pseudo definitions are primarily used to provide some minimal support when displaying comparisons between two different versions of a package in the old browsers.  For example, consider the case of comparing two packages where one package had a class definition removed.  An instance of PseudoClass (a subclass of this abstract superclass) would be instantiated to provide the bare minimum to display the non-existant class in the comparison browser.  When asked for its definition, it would display:	Not defined in this packageSubclasses must implement the following messages:	comparing		comparesTo:		objectIsForSelf:</body></comment><class><name>PseudoClass</name><environment>Store</environment><super>Store.AbstractPseudo</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PseudoClass</class-id><body>PseudoClass is a placeholder for a class definition that does not exist in a package, but might be needed for some display.  Consider the case where the old old browser is comparing two packages that have methods defined for a class, yet neither package contains the class definition.  This class helps provide the minimal display support so that methods can be displayed.  To create an instance of this class, use the class side #named:meta: method.</body></comment><class><name>BundleInstall</name><environment>Store</environment><super>Store.PundleInstall</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.BundleInstall</class-id><body>BundleInstall is a container object for BundleInstall and PackageInstall objects that represent the first level contents of the underlying StoreBundleInstance Variables	contents	&lt;(Collection of: (BundleInstall | PackageInstall))&gt;	The immediate contents of myself as Install objects</body></comment><class><name>MergeTool</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolutionManager packageList bundles displayText conflictText textMode show selectedResolution conflictType nameStyle resolutionListTabs currentResolutionsPane autoSelectResolution toolbarMenuHolder compareWithHolder differencesType databaseSession conflictProtocol selectionProtocol </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.MergeTool</class-id><body>MergeTool is the UserInterface that is used in performing mergesInstance Variables	autoSelectResolution	&lt;Boolean&gt;	If true (default) then a resolution is selected for you if the tool can (which you can change)	bundles	&lt;(Collection of: (Bundle))&gt;	Bundles we are working with	compareWithHolder	&lt;ValueModel&gt;	The current selection of the compare with menu	compareWithMenuHolder	&lt;ValueHolder&gt;	The menu of options for the compare with menu	conflictText	&lt;ValueModel&gt;	The text shown in the conflict pane	conflictType	&lt;ByteSymbol&gt;	#conflictsWithBase, #conflictsWithImage, #conflictsWithResolution or #none (Default is #conflictsWithBase)	differencesType	&lt;ByteSymbol&gt;	 #showCodeDifferences or #showSourceDifferences (Default is #showSourceDifferences)	displayText	&lt;ValueModel&gt;	The change	resolutionManager	&lt;ResolutionManager&gt;	An object that holds all the merge data that can be published	selectedResolution	&lt;AbstractResolutions | ChangeResolver&gt;	An object that holds all possible resolutions for the current selected modification	resolutionsPane	&lt;ResolutionsTreePane | ResolutionsListPane&gt;	The embedded UserInterface that displays the tree or list of modifications based on which tab is visible	resolutionListTabs	&lt;SelectionInList&gt;	The selection representing which ResolutionsPane is being displayed	nameStyle	&lt;ByteSymbol&gt;	#showLongNames or  #showShortNames (Default is #showShortNames)	packageList	&lt;MultiSelectionInList&gt;	The current selection of of packages in the current ResolutionsPane	show	&lt;ByteSymbol&gt;	#unresolved, #conflicts or #all (Default is #all)	textMode	&lt;ByteSymbol&gt;	#external or #internal	toolbarMenuHolder	&lt;ValueModel&gt;	The toolbar menu</body></comment><class><name>ProcessHealthView</name><environment>Store</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>observedProcess lastContext progressIndex isActive timer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.ProcessHealthView</class-id><body>A simple widget which observes a process and gives feedback that the process is proceeding (rather than stuck waiting) as long as the process makes progress.Instance Variables:	isActive	&lt;BlockClosure&gt;	any valuable which is used to query whether we should be currently updating	lastContext	&lt;MethodContext&gt;	on each checkHealth call, we remember the context of the observedProcess, which we can then compare against in the next checkHealth call to make sure the process is not stuck	observedProcess	&lt;Process&gt;	the process we are watching	progressIndex	&lt;Integer&gt;	value between 0 and 23, advanced at each checkHealth point, provided the lastContext is found to have changed	timer	&lt;Timer&gt;	used to generate the periodic ticks where we checkHealth at each point</body></comment><class><name>MethodChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.MethodChangeResolver</class-id><body>MethodChangeResolver is a resolver that represents changes available for a Method</body></comment><class><name>NullPackageCanNotBeSavedError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.NullPackageCanNotBeSavedError</class-id><body>NullPackageCanNotBeSavedError is riased when attempting to save the Null package</body></comment><class><name>GroupGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userList groupList </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.GroupGraph</class-id><body>GroupGraph is the UI used to manage User / GroupsInstance Variables	groupList	&lt;SelectionInList&gt;	list of groups	userList	&lt;SelectionInList&gt;	list of users</body></comment><class><name>CodeComponentComparison</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftCodeComponents rightCodeComponents removedSharedVariables addedSharedVariables removedNamespaces addedNamespaces removedClasses addedClasses removedMethods addedMethods removedPackageProperties addedPackageProperties addedBundleProperties removedBundleProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.CodeComponentComparison</class-id><body>I exist to compute the changed blueprints evolving from a set of packages (and bundles) inputs to another set.UsageA comparison is created by sending the #leftCodeComponents:rightCodeComponents: method to a newly created instance. The arguments represent only the initial inputs. They may evolve as the computation proceeds.The message #compute is used to actually do the computation between the two sides (see Implementation notes below).After it has been computed, the various added and removed blueprint types can be queried by dictionary keys (see Instance Variables section below).Reduced set versions can be quickly created using the #withoutComponents: conversion message.ImplementationThe basic compare algorithm makes heavy use of the Meyer's Difference algorithm (#differences: method) and the fact that Blueprint objects can be deterministically sorted and compared. The steps of comparison (found mostly, but not entirely in the #compute method) go as follows:	1) Expand all input packages/bundles to include them as well as their sub bundles and sub packages.	2) Sort them deterministically	3) Throw out any exact matches between the two.	4) Sweep all of the packages/bundles on the left side, and fetch their various types of blueprints, sorted deterministically.	5) Same for the right side	6) For each type of blueprint, compute the #differences. Deleted elements are cataloged as "removed" things, and Inserted elements are cataloged as "added" things. The method of category is some kind of Dictionary key to objects, it varies for the different types.	7) Throw out any packages for which no blueprints were logged in either the added or removed set.Instance Variables	addedBundleProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by bundle name	addedClasses			&lt;Dictionary of: ClassBlueprint&gt; keyed by binding reference	addedMethods			&lt;Dictionary of: (Array of: MethodBlueprint)&gt;	keyed by class binding reference	addedNamespaces		&lt;Dictionary of: NamespaceBlueprint&gt;	keyed by binding reference	addedPackageProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by package name	addedSharedVariables	&lt;Dictionary of: SharedVariableBlueprint&gt;	keyed by binding reference	leftCodeComponents		&lt;Array of: (CodeComponent | StorePundle)&gt;	the left side code components, or the "from" source	removedBundleProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by bundle name	removedClasses			&lt;Dictionary of: ClassBlueprint&gt; keyed by binding reference	removedMethods			&lt;Dictionary of: (Array of: MethodBlueprint)&gt;	keyed by class binding reference	removedNamespaces	&lt;Dictionary of: NamespaceBlueprint&gt;	keyed by binding reference	removedPackageProperties	&lt;Dictionary of: CodeComponentPropertyBlueprint&gt;	keyed by package name	removedSharedVariables	&lt;Dictionary of: SharedVariableBlueprint&gt;	keyed by binding reference	rightCodeComponents	&lt;Array of: (CodeComponent | StorePundle)&gt;	the right side code components, or the "to" target</body></comment><class><name>StoreSelectorNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SelectorNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSelectorNavigatorPart</class-id><body>StoreSelectorNavigatorPart is used when browsing Glorp/Store objects from a Database</body></comment><class><name>RequestInstallDatabaseTables</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.RequestInstallDatabaseTables</class-id><body>RequestInstallDatabaseTables is raised if when connecting the database tables don't seem to be installed.It opens a dialog to choose to create or cancelDefault resume/return value is true.</body></comment><class><name>ResolutionsTreePane</name><environment>Store</environment><super>Store.ResolutionsPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root oldTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.ResolutionsTreePane</class-id><body>ResolutionsTreePane is used to display the the merge tool modification sets in a tree.Instance Variables:	oldTree	&lt;Object&gt;	When switching trees, this is used to hold the old tree for a moment.	root	&lt;ResolutionManager&gt;	This is the base resolution manager</body></comment><class><name>StoreVersionlessPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreVersionlessPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreVersionlessPackage</class-id><body>This represents a particular versionless package.</body></comment><class><name>PublishMergeDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishMergeDialog</class-id><body>PublishMergeDialog is used when publishing a Merge or any generic group of publish specifications</body></comment><class><name>PropertiesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString searchString pundleRef recType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PropertiesView</class-id><body>PropertiesView joins Property and Pundle.Instance Variables:	commentID	&lt;Integer&gt;  link to blob table pointing to property comment (?)	definitionID	&lt;Integer&gt;	link to the property value	environmentString	&lt;String&gt; not used	pundleRef	&lt;Integer&gt;	link to the owning pundle	recType	&lt;Integer&gt; type of pundle (package vs bundle)	searchString &lt;string&gt; short version of the property value if possible for searching</body></comment><class><name>BundleStructureResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.BundleStructureResolver</class-id><body>BundleStructureResolver  is a ChangeResolver for Bundle Structure differences</body></comment><class><name>UnloadableDefinitionsViewer</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>viewerListHolder text selectionModule </inst-vars><class-inst-vars>specPreference </class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><comment><class-id>Store.UnloadableDefinitionsViewer</class-id><body>Sometimes when loading a package from the database certain definitions may not be loadable.  This could occur because there might be a missing superclass, or missing namespace or missing class for an extension method or extension shared variable.  This viewer is used to present the list of unloadable definitions.  A user can then file-out the definitions, load the definitions (assuming the user has full-filled those artifacts that are needed to load the definition) or remove the definitions from the package.When creating an instance of this viewer, it is important to use the #definitions:package: method in the initialize-release protocol.  This is because in order to remove or load any of the unloadable definitions the desired instance of PackageModel must be known.  Note, that because of this initialization requirement this viewer can only cope with unloadable definitions that are associated with the same package.Instance Variables	selectionModule	&lt;ListSelectionModule&gt;	A module that holds the list definitions that would not load	text		&lt;ValueHolder on: String|Text&gt;	The definition string for the currently selected definition	viewerListHolder	&lt;SelectionInList on: UnloadableDefinitionsViewer|RecordVersionsViewer&gt;	The two viewers used for the tab controlClass Instance Variables	specPreference &lt;Symbol&gt; The desired window specification to use for viewing.  Currently, there are two choices, which control whether the sequence view is displayed above (#horizontalWindowSpec) or to the left (#verticalWindowSpec) of the text view.  Note, that it is assumed that this class understands the message represented by this variable.	</body></comment><class><name>PseudoClassDefinitionDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoClassDefinitionDifference</class-id><body>PseudoClassDefinitionDifference is used in the ComparePackages UI to show any definition difference between two classes</body></comment><class><name>PseudoNamespaceDefinitionDifference</name><environment>Store</environment><super>Store.PseudoClassDefinitionDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceDefinitionDifference</class-id><body>PseudoNamespaceDefinitionDifference is used in the ComparePackages UI to show any definition difference between two NameSpaces</body></comment><class><name>ElementView</name><environment>Store</environment><super>Lens.LDMElementView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.ElementView</class-id><body>ElementView is a specialization for the Store graphs</body></comment><class><name>PackageListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.PackageListPane</class-id><body>PackageListPane is used to list versions of a StorePackage in a DefinitionsForListTool</body></comment><class><name>PrivilegeGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userGroupList packageList privilegeText </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.PrivilegeGraph</class-id><body>PrivilegeGraph is used to assiging privileges of users/groups to packagesInstance Variables:	packageList	&lt;MultiSelectionInList&gt;	The list of Packages available to assign to.	privilegeText	&lt;ValueModel&gt;	This holds the current privileges for the current user	userGroupList	&lt;SelectionInList&gt;	The list of known users and groups in the current database</body></comment><class><name>BundlePrivilegeGraph</name><environment>Store</environment><super>Store.PrivilegeGraph</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.BundlePrivilegeGraph</class-id><body>BundlePrivilegeGraph allows the image administrator to grant or revoke ownership to Bundles.</body></comment><class><name>DefinitionForListTool</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition listPart status </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.DefinitionForListTool</class-id><body>DefinitionForListTool is a generic tool for listing a bunch of homogenous objects in a list in its top pane, and a text pane below that shows information about the selected object(s).Instance Variables	definition	&lt;ValueModel&gt;	This is the text holder for showing what if anything is selected.	listPart	&lt;DefinitionsForListPane&gt;	This is the list pane that is specific to the current need.</body></comment><class><name>PublishedPundleVersionsTool</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionForListTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listBlock searchModule cachedPundles titleBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id><body>PublishedPundleVersionsTool is used to display a list of pundles that are published in the database.  When one of these pundles is selected (multi-selection is allowed), the versionClientApp (an instance of VersionBrowser) will display the list of versions for those selected pundles. Instance Variables	cachedPundles	&lt;(Collection of: (StoreBundle | StorePackage)&gt; This is the current result of sending value to the listBlock	listBlock	&lt;BlockContext&gt;	This block will answer the items in the left selection pane.	searchModule	&lt;IncrementalSearchModule&gt;	This is the left pane, which is the search module for the bundles/packages list pane</body></comment><class><name>StoreProgressView</name><environment>Store</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activityStack notifications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.StoreProgressView</class-id><body>A simple widget which shows the most current  StoreWorkActivity.ImplementationI am a 3 part widget. One for a 'health' view (a spinner). And two labels, one to show the component being worked on, and the other to show the kind of work. As new notifications are received, they are updated (or rolled back to previous states when finished notifications are received).Instance Variables:	activityStack	&lt;SequenceableCollection of: StoreWorkActivity&gt;	 as started variants of announcements are received, they are added to this stack. When a finished one is received, the stack is cut back to the started compliment of the finished. The 'current' activity being shown is the top of the stack.	notifications	&lt;Announcer&gt;	this is by default set to the StoreWorkActivity notifications, which is the "global" announcer for instances of StoreWorkActivity</body></comment><class><name>ComparisonUsersManual</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.ComparisonUsersManual</class-id><body>I am a view that self populates with information describing how to use the CodeComparisonTool.ImplementationI populate myself by aggregating a series of arbitrary height "row" sub views. Methods that return said sub components have a &lt;paragraph&gt; method tag. They are sorted (and executed) in alphabetical order, thus the leading _#### pattern on most of the methods.I also have methods to open a window around myself.</body></comment><class><name>StoreBundlePackageRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleID packageID expressionID sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreBundlePackageRelationship</class-id><body>StoreBundlePackageRelationship represents the "TW_Packages" table and is used by the Garbage CollectorInstance Variables	bundleID	&lt;Integer&gt;	This is the bundleRef column value	expressionID	&lt;Integer&gt;	This is the expressionID column value	packageID	&lt;Integer&gt;	This is the packageRef column value	sequence	&lt;Integer&gt;	This is the seqNumber column value</body></comment><class><name>MethodDocs</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodRef documentRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.MethodDocs</class-id><body>Connects a method to its stDocumentationInstance Variables:	documentRef	&lt;Integer&gt;	Foreign key to the Blob table holding the documentation.	methodRef	&lt;Integer&gt;	Foreign key to the Method table.</body></comment><class><name>MergeIcons</name><environment>Store</environment><super>AlphaBlendedIcons</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.MergeIcons</class-id><body>This is a collection of icons used by the merge tool</body></comment><class><name>PundleVersionPane</name><environment>Store.Glorp</environment><super>Store.Glorp.PackageListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listFilterBlock imageVersions publishedFormatDescriptions </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.PundleVersionPane</class-id><body>PundleVersionPane is used for the new PublishedPundleVersionsTool.It is in effect the right hand panes in that toolInstance Variables	listFilterBlock	&lt;One Argument Block|nil&gt;	This block, if set, will filter the list in the top right pane. The block is used in a select: statement, and each item is a StorePundle</body></comment><class><name>StoreDisconnect</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database</package></attributes></class><comment><class-id>Store.StoreDisconnect</class-id><body>StoreDisconnect is announced when the global Store connection disconnects from a Repository</body></comment><class><name>ClassRecord</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.ClassRecord</class-id><body>A ClassRecord represents the definition of a class that is stored in the database.Instance Variables:	superclass	&lt;String&gt;	The absolute name of the superclass for the class that this record represents</body></comment><class><name>BundleHasUnpublisedChangesConfirmation</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.BundleHasUnpublisedChangesConfirmation</class-id><body>BundleHasUnpublisedChangesConfirmation is raised when a bundle has unpublished modifications and the system wants to know if it is ok to proceed to publish without database links</body></comment><class><name>ResolutionManager</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trees resolutions integratedVersions </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			private Store.*			</imports><category>Store-Merge Management</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ResolutionManager</class-id><body>ResolutionManager is the holder of all merge objects for a merge.Instance Variables	integratedVersions	&lt;Collection&gt;	description of integratedVersions	resolutions			&lt;Dictionary of (keys = packageNames values = PackageResolutions)&gt; 	trees				&lt;(OrderedCollection of: &lt;Array of: VersionNode&gt; )&gt; Each array contains two elements, the root node and the package node. The version node represents a compressed tree, meaning that versions in a single line between the root and package are eliminated.[-] SomePackage (1-n) (aPackageResoltuions)	- AClass (0-n) (ClassResolutions)		ADef - comment (0-1)		ADef - class def (0-1)		ADef - method (class or not) (0-n)		ADef - Shared (0-n)	- ANameSpace (0-n) (NamespaceResoltions)		ADef - defintion (0-1)		ADef - Shared (0-n)	- AProperty (0-n) (PropertyResolutions)ClassResolutions	resolutions - ((0-1) ClassChangeResolver, (0-1) ClassCommentChangeResolver, (0-n) SharedChangeResolver, (0-n) MethodChangeResolver).NamespaceResolutions	resolutions ((0-1) NamespaceChangeResolver, (0-n) SharedChangeResolver, (0-n) NamespaceCommentChangeResolver)PropertyResolutions	resolutions ((1-n) PropertyChangeResolver)</body></comment><class><name>BlessingDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dialog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.BlessingDialog</class-id><body>BlessingDialog is used by other Store tools to reset the blessing level for a package or a bundle.    The class side method protocol, #'interface opening' contains the protocol to invoke the dialog.    If the blessing is to be reset on a package, then BlessingDialog will instead open up a CommentPrompt dialog (see the class side method #setBlessingForPackage:).    If the blessing is to be reset on a bundle, then BlessingDialog is opened up as a SimpleDialog.Instance Variables:	dialog	&lt;SimpleDialog&gt;	The instance that provides the dialog behavior</body></comment><class><name>EarlyInstallNotice</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Compiling and Loading</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.EarlyInstallNotice</class-id><body>EarlyInstallNotice is raised during analysis when a StoreBundle or StorePackage is determined to need early install</body></comment><class><name>SingleMethodView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method isAddition parseTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.SingleMethodView</class-id><body>I show a single method view, either removed or added (but not changed).ImplementationOne additional feature I add, is keeping track of a parse tree. This is used by ClassBlueprintComparisonView to detect potential method renames. When it can find an add and remove view, for which the selectors have the same argument count and the parseTree's match, then it can annotate those two methods as a potential rename.Instance Variables	isAddition	&lt;Boolean&gt;	used to determine my header icon	method	&lt;MethodBlueprint&gt;	the method i show	parseTree	&lt;RBProgramNode&gt;	parse tree of the method source</body></comment><class><name>StoreProperty</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreProperty</class-id><body>This represents the definition of an individual property of a package or bundle. Instance Variables:	searchString	&lt;String&gt;	The actual property values are BOSSed into the definition string, and thus are opaque to database queries. But many of the properties are simple values, or even strings. So we store up to 255 characters worth of the printable representation of the property here, so it can be queried against.</body></comment><class><name>MarkPundlesForDeletionTool</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleTabs targetedPundles bundleVersions bundles packages packageVersions session previouslyMarkedPundles filter cachedNames oldFilter </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.MarkPundlesForDeletionTool</class-id><body>MarkPundlesForDeletionTool is the UI front end to the GarbageCollector. It allows the user to mark for deletion, both StorePackages and StoreBundles visually.Instance Variables	bundles	&lt;SelectionInList&gt;	The collection of filtered bundle names that can be chosen from	bundleVersions	&lt;MultiSelectionInList&gt;	When a bundle is chosen, the versions of that bundle available to be removed	cachedNames	&lt;Dictionary&gt;		At startup, this caches the list of unfiltered bundle and package names	filter	&lt;DeletionToolFilter&gt;	This is the filter used to filter the list of packages/bundles and versions	oldFilter	&lt;nil | DeletetionToolFilter&gt;	When you clear the filter, we stash the existing one here, to be reused when the filter tool is reopened	packages	&lt;SelectionInList&gt;		The collection of filtered package names that can be chosen from	packageVersions	&lt;MultiSelectionInList&gt;	When a package is chosen, the versions of that package available to be removed	previouslyMarkedPundles	&lt;(Collection of: (StorePundle))&gt;	On startup, this is the collection of pundles that are already marked for deleteion.	pundleTabs	&lt;SelectionInList&gt;		This is the Tab widget used in the UI	session	&lt;GlorpSession&gt;	The GlorpSession used throughout this tool for accessing the database.	targetedPundles	&lt;MultiSelectionInList&gt;	This is the list of marked for deletion, and proposed marked for deletion pundles</body></comment><class><name>CreateParcelDirectoryConfirmation</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.CreateParcelDirectoryConfirmation</class-id><body>CreateParcelDirectoryConfirmation is raised when attempting to save a Package as a Parcel and the target directory does not exist, and the system wants to know if you wish to create that directory</body></comment><class><name>ShadowedClassObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longName superclassName overriddenClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedClassObject</class-id><body>ShadowedClassObject is a specialization of ShadowedObject for ClasssesInstance Variables	longName	&lt;String&gt;	The long name (from Root) of the class	superclassName	&lt;String&gt;	The name of the superclass for this class</body></comment><class><name>StoreSharedVariableNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.SharedVariableNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableNavigatorPart</class-id><body>StoreSharedVariableNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>AbstractPublishSpecification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publish modified comment level version parentVersion description blessing object pundleModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.AbstractPublishSpecification</class-id><body>AbstractPublishSpecificationAbstract is generic publishing information. Specifications allow you to set up instructions for publishing to the Bundle/Package.Instance Variables	blessing	&lt;Integer&gt;	 The blessing level 	comment	&lt;String&gt;	The blessing comment 	description	&lt;String&gt;	A dexcription of the pundle for display	level	&lt;SmallInteger&gt;  indent level		modified	&lt;Boolean&gt;	indicates wheter a component was modified	object	&lt;PundleModel&gt;	the pundle being published (This object changes to a StorePundle during publish)	parentVersion	&lt;String&gt; a version string for the published parent version	publish	&lt;Boolean&gt;	true if this component to be published	version	&lt;String&gt;	The version string to use use when publishing	pundleModel	&lt;PundleModel&gt; The image object being published</body></comment><class><name>PublishFileSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Configurations</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.PublishFileSpecification</class-id><body>PublishFileSpecification is used to create a file to be published with a Bundle as follows:The BundleModel object can simply have a collection of FileModel objects in it's fileDescriptions accessor	| publishFileSpecifications |	publishFileSpecifications := aBundle fileDescriptions collect:		[:fileModel | 		(Store.PublishFileSpecification new)			file: fileModel;			publish: true;			yourself].	bundle fileDescriptions: (publishFileSpecifications collect: [:each | each file]) asList.</body></comment><class><name>PublishPackageDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			</imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishPackageDialog</class-id><body>PublishPackageDialog is used when publishing a single package (not a bundle)Instance Variables	package		&lt;PackageModel&gt;	The target package being published</body></comment><class><name>BundleTreePane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.BundleTreePane</class-id><body>BundleTreetPane is used to show the tree view of a Bundle</body></comment><class><name>ShadowNameSpaceBuilder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowNameSpaceBuilder</class-id><body>An instance of ShadowNameSpaceBuilder will create a new namespace tree that will have the same structure existing system namespaces.  This new namespace tree, which we call a shadow namespace, cannot be reached from the current root in the system.  To create the shadow namespace, ShadowNameSpaceBuilder first creates the Root and Smalltalk namespace.  This is because Root and Smalltalk have a special self-referential relationship - Root contains Smalltalk and Root, and Smalltalk contains Root and Smalltalk.  The builder then enumerates the namespaces in Smalltalk.  For each namespace it encounters, the builder creates a VariableBnding with its reserved flag set and whose value is a new NameSpace that has the same name and same import definitions.  This variable binding is added to the shadow namespace system.Users of ShadowNameSpaceBuilder would create a new instance, send #createShadowRoot to this instance and capture the return value.  The return error from #createShadowRoot will be the root NameSpace for the shadowed namespace.  Each time the receiver is sent createShadowRoot a new shadow namespace is created so the onus is on clients of ShadowNameSpaceBuilder to hold onto their shadowed NameSpace.When is trying to resolve a binding reference, whose home is a shadow namespace, ShadowNameSpaceHandler should be used to ensure the binding properly resolves if the binding does exist in the shadow namespace.Instance Variables:	root	&lt;NameSpace&gt;	The root of the NameSpace that was created</body></comment><class><name>StoreSelectorEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSelectorEnvironment</class-id><body>StoreSelectorEnvironment is used when browsing Glorp/Store objects from a Database</body></comment><class><name>Loading</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Loading</class-id><body>This is the outermost announcement during a Load</body></comment><class><name>StoreNameSpace</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreDefinitionObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreNameSpace</class-id><body>This represents the definition of a namespace.</body></comment><class><name>Privileges</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.Privileges</class-id><body>Privileges is due to be obsolete in a future release beyond 7.8</body></comment><class><name>PropertyResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.PropertyResolutions</class-id><body>PropertyResolutions holds a collection of PropertyChangeResolvers for a Package or Bundle</body></comment><class><name>Relinking</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Relinking</class-id><body>This is announced when Relinking is done during loading</body></comment><class><name>PkgClassesAndSourcesView</name><environment>Store</environment><super>Store.PkgClassesView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgClassesAndSourcesView</class-id><body>Extends PkgClassesView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	ClassesWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>StoreConnect</name><environment>Store</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database</package></attributes></class><comment><class-id>Store.StoreConnect</class-id><body>StoreConnect is announced when the global Store connection connects to a Repository</body></comment><class><name>StoreAccessPrivilege</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleName pundleType userName userType privilege session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreAccessPrivilege</class-id><body>StoreAccessPrivilege represents the relationship between a user/group (where userType 'G' = group, and userType 'U' = user) in the minimal privileges system, where a user/group may be limited to publishing various pundles by their entries in this tableInstance Variables	privilege	&lt;String&gt;	description of privilege	pundleName	&lt;String&gt;	description of pundleName	pundleType	&lt;String&gt;	description of pundleType	session		&lt;GlorpSession&gt;	userName	&lt;String&gt;	description of userName	userType	&lt;String&gt;	description of userType</body></comment><class><name>ShadowBundleCompileManager</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root bundle results notificationQueue compilationManager parentManager </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Atomic Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>ShadowBundleCompileManager</class-id><body>ShadowBundleCompiler compiles a Bundle into a ShadowSpace based on a shadowed root.Instance Variables	bundle	&lt;Bundle&gt;	The Bundle being compiled	results	&lt;ShadowedBundleCompilationResult&gt; Maintains the shadowed objects and the unloadable definitions	root	&lt;Object&gt; The Shadowed Root.	notificationQueue &lt;SharedQueue&gt; the current notificationQueue	compilerManager &lt;AtomicCompilationManager&gt; The overlord of compilation</body></comment><class><name>Store74DescriptorSystem</name><environment>Store.Glorp</environment><super>Store.Glorp.Store73DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.Store74DescriptorSystem</class-id><body>This is a system for 7.4-upgraded Store databases, which will include the methodDocs table, although it's not really used yet.</body></comment><class><name>SkipPrerequisite</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.SkipPrerequisite</class-id><body>SkipPrerequisite is raised when a prerequisite is skipped</body></comment><class><name>IndentedListBuilder</name><environment>Store</environment><super>Lens.LDMIndentedListBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.IndentedListBuilder</class-id><body>IndentedListBuilder is used for graphing versions or user/privileges</body></comment><class><name>StoreRefactoringBrowser</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractRefactoringBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreRefactoringBrowser</class-id><body>I am a special browser that manages browsing Store/Glorp objects.To isolate the Store Browser from potential RefactoringBrowser extensions, all toolbar and menu items are explicitly implemented in this class, and any menu augmentation will also terminate with this class.</body></comment><class><name>PseudoSubdef</name><environment>Store</environment><super>Store.AbstractPseudo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key isData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.PseudoSubdef</class-id><body>PseudoSubdef is a placeholder for either a shared variable definition or a method definition that does not exist in a package, but might be needed for display purposes by the comparsion browser.  Instance Variables:	isData	&lt;Boolean&gt;	Does the receiver represent a missing shared variable or a missing method.	key		&lt;Symbol&gt;	If isData is true, then key is the name of the shared variable.  Otherwise it is the selector of the method.</body></comment><class><name>StoreDevelopmentSystem</name><environment>Store</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.StoreDevelopmentSystem</class-id><body>This sets up Store to be able to run in development mode. At the moment, all it does is bring up the reconnect dialog if the image was connected to a Store database when saved.</body></comment><class><name>PackageConflicts</name><environment>Store</environment><super>Store.PackageDifferences</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PackageConflicts</class-id><body>This class differs from the superclass by holding only the set of conflicting definitions between two packages.  </body></comment><class><name>PackageComparitor</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainPackage otherPackage mainPackageMethods otherPackageMethods mainPackageShareds otherPackageShareds mainPackageNamespaces otherPackageNamespaces mainPackageClasses otherPackageClasses mainPackageProperties otherPackageProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PackageComparitor</class-id><body>PackageComparitor is used by the loading mechanism to compare a loaded version against an about to load version, to determine which defintion objects (methods, classes, shareds, namespaces) to add, remove or change during the requested loadInstance Variables	mainPackage	&lt;PackageModel | PseudoPackage | StorePackage&gt;	description of mainPackage	mainPackageClasses	&lt;(Collection of: (StoreClass | StoreClassInPackage))&gt;	description of mainPackageClasses	mainPackageMethods	&lt;(Collection of: (StoreMethod | StoreMethodInPackage))&gt;	description of mainPackageMethods	mainPackageNamespaces	&lt;(Collection of: (StoreNamespace | StorNamespaceInPackage&gt;	description of mainPackageNamespaces	mainPackageShareds	&lt;(Collection of: (StoreShared | StoreSharedInPackage))&gt;	description of mainPackageShareds	mainPackageProperties	&lt;(Collection of: Association)&gt;	otherPackage	&lt;PackageModel | PseudoPackage | StorePackage&gt;	description of otherPackage	otherPackageClasses	&lt;(Collection of: (StoreClass | StoreClassInPackage))&gt;	description of otherPackageClasses	otherPackageMethods	&lt;((Collection of: (StoreMethod | StoreMethodInPackage))) | ExpressionGroup | MappingExpression | ReadStream&gt;	description of otherPackageMethods	otherPackageNamespaces	&lt;(Collection of: (StoreNamespace | StorNamespaceInPackage))&gt;	description of otherPackageNamespaces	otherPackageShareds	&lt;(Collection of: (StoreShared | StoreSharedInPackage))&gt;	description of otherPackageShareds	otherPackageProperties	&lt;(Collection of: Association)&gt;</body></comment><class><name>RemovalResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.RemovalResolution</class-id><body>RemovalResolution is a special kind of resolver which when applied removes the defined item from the imageInstance Variables:	base	&lt;Association&gt;	This is the Resolver's alternative which represents the object to be removed	package	&lt;StorePundle | PundleModel&gt;	description of package</body></comment><class><name>StoreRepositoryListSetting</name><environment>Tools</environment><super>Tools.GenericSettingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.RepositoryManager			private Store.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Tools.StoreRepositoryListSetting</class-id><body>StoreRepositoryListSetting is the setting used by the StoreRepositoryListPage.  It is a list of Store.ConnectionProfile instances that are used for connecting to store repositories.  This list of repositories is found at:	RepositoryManager repositoriesThis does not modifiy the original list returned by #repositories, but instead operates on a copy of it.This list (profiles) is populated by the #initialize method (and #resetProfiles which can be sent by the StoreRepositoryListSettingPage).   If a new profile is created in the settings tool, then it will be installed in #installProfiles.  Instance Variables:	profiles	&lt;List of: Store.ConnectionProfile&gt;	The store connection profiles</body></comment><class><name>UserInputResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.UserInputResolution</class-id><body>UserInputResolution is a special kind of resolution that represents a user input definition which is based on a known merge resolverInstance Variables	package	&lt;PundleModel | StorePundle&gt;		This is the pundle object where this user input resolution was cloned from.	protocol	&lt;Symbol | nil&gt;	When the user input represents a Method, this is the protocol for the method.	text	&lt;Text | String&gt;	This is the string that represents the user input definition</body></comment><class><name>AlreadyConnected</name><environment>Store</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Database</package></attributes></class><comment><class-id>Store.AlreadyConnected</class-id><body>AlreadyConnected is raised in the scope of connecting to a named profile</body></comment><class><name>ChangeSetInspector</name><environment>Store</environment><super>Tools.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.ChangeSetInspector</class-id><body>A ChangeSetInspector provides a menu of operations suitable for an inspector on a set of changes.Instance Variables:	windowLabel	&lt;String&gt;	The label to use for the inspector's window</body></comment><class><name>StoreForGlorpNavigatorState</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractNavigatorState</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id><body>I hold state for the Store Browser.Instance Variables	environment	&lt;StoreForGlorpBrowserEnvironment&gt;	the browser's environment</body></comment><class><name>PackagesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longField commentSize binFile bundleRef expression seqNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.PackagesView</class-id><body>PackagesView appears to be obsolete.Instance Variables:	binFile	unused	bundleRef	&lt;Integer&gt; primaryKey of a bundle	commentSize	&lt;Integer&gt;	description of commentSize	expression	&lt;unknown&gt;	longField	&lt;unknown&gt;	seqNumber	&lt;Integer&gt;	</body></comment><class><name>NamespaceResolutions</name><environment>Store.Glorp</environment><super>Store.Glorp.AbstractResolutions</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.NamespaceResolutions</class-id><body>NamespaceResolutions is a Resolutions that holds changes for namespaces: (NamespaceChangeResolver, NamespaceCommentChangeResolver SharedChangeResolver)</body></comment><class><name>GarbageCollector</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packagesToRemove bundlesToRemove methodsToRemove sharedsToRemove blobObjectsToRemove binaryDefinitionsToRemove classesToRemove metaClassesToRemove nameSpacesToRemove parcelRecordsToRemove blessingsToRemove packagesToAdopt bundlesToAdopt methodsToAdopt sharedsToAdopt classesToAdopt nameSpacesToAdopt propertiesToRemove session </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			private Glorp.*			</imports><category>Store-Database</category><attributes><package>Store-Database</package></attributes></class><comment><class-id>Store.GarbageCollector</class-id><body>Removes packages from the database and collects the "garbage." It first analyzes and buids up the lists of things no longer referenced, then removes them.Instance Variables	binaryDefinitionsToRemove	&lt;Collection of: StoreBinaryBlob&gt;	 StoreBinaryBlobs to remove	blessingsToRemove	&lt;Collection of: StoreBlessing&gt;		StoreBlessings to remove	bundlesToAdopt	&lt;Collection of Array&gt; all the bundles who have been orphaned by the removal of their parent		bundlesToRemove	&lt;Collection of: Bundle&gt;	bundles to be removed	classesToAdopt	&lt;Collection of Array&gt; all the ClassRecords who have been orphaned by the removal of their parent		classesToRemove	&lt;Collection of: ClassRecords&gt;	classes to remove	dataToAdopt	&lt;Collection of Array&gt; all the shareds who have been orphaned by the removal of their parent		dataToRemove	&lt;Collection of: DataElement&gt; all the shareds to be removed	definitionsToRemove	&lt;Collection of: Integer&gt;	primaryKeys of all the definitions to be removed (i.e. Blobs)	methodsToAdopt	&lt;Collection of Array&gt; all the methods who have been orphaned by the removal of their parent		methodsToRemove	&lt;(Collection of: (Subdef | SubdefView))&gt;	description of methodsToRemove	nameSpacesToAdopt	&lt;Collection of Array&gt; all the NameSpaceRecords who have been orphaned by the removal of their parent		nameSpacesToRemove	&lt;Collection of: NameSpaceRecord&gt;	the namespaces to remove	packagesToAdopt	&lt;Collection of Array&gt; all the packages who have been orphaned by the removal of their parent		packagesToRemove	&lt;(Collection of: Package)&gt;	all the packages to remove	parcelRecordsToRemove	&lt;Collection or ParcelRecord&gt; all the binary versions of pundles to be removed</body></comment><class><name>Installing</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.Installing</class-id><body>This is announced when Installing during a Load</body></comment><class><name>PkgNameSpacesAndSourcesView</name><environment>Store</environment><super>Store.PkgNameSpacesView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgNameSpacesAndSourcesView</class-id><body>Extends PkgNameSpacesView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	NameSpacesWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>StoreNameSpaceItemTabNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.NameSpaceItemTabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart</class-id><body>StoreNameSpaceItemTabNavigatorPart is used when browsing Glorp/Store objects from a Database</body></comment><class><name>ReconcilingComparitor</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleModel storePundle workingChangeSet notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.ReconcilingComparitor</class-id><body>ReconcilingComparitor is used when reconciling a packageModel or bundleModel against a StorePackage or StoreBundle from the a database.It does not produce anything per se, but along the way, it sets the pundleModel objects' change set to reflect the difference between the pundleModel and the StorePundle objects.	Instance Variables	pundleModel		&lt;PundleModel&gt;		Image model that will receive an updated change set	storePundle			&lt;StorePundle&gt;		Database model that is compared to the image	workingChangeSet 	&lt;XChangeSet&gt;		The accumulated changes between the image and database model	notificationQueue	&lt;SharedQueue&gt;		User feedback notifications</body></comment><class><name>PublishSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeData binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelRepublish parcelBackup parcelOverwrite parcelSaveSource parcelHideSource parcelPadded publisher parcelVersionString </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.PublishSpecification</class-id><body>PublishSpecification contains all the options used when publishing. #parcelX options are only used when a parcel is also being produced.Instance Variables	binarySave	&lt;Boolean&gt;	Indicates whether to publish the pundle as binary	bundleStructure	&lt;Boolean&gt;	Indicates if bundle structure should be stored when producing a parcel. 	databaseLinks	&lt;Boolean&gt;	Indicates if trace links to the current database should be stored in the parcel. 	mergeData	&lt;MergeData&gt;	Information collected in the MergeTool	parcelBackup	&lt;Boolean&gt;	Indicates if the parcel (it it exists and we are overwriting it) should be backed up.	parcelDirectory	&lt;String&gt;	The directory to store the parcel in. 	parcelHideSource &lt;Boolean&gt; Indicates if the parcel should have its source hidden. 	parcelOverwrite	&lt;Boolean&gt;	Indicates if the parcel (if it already exists) should be overwritten. 	parcelPadded	&lt;Boolean&gt;	Indicates if the parcel's source file should be padded.  See the class comment for SourceFileManager for futher information on padding source files.	parcelRepublish	&lt;Boolean&gt;	Indicates if the parcel should be republished.  	parcelSave	&lt;Boolean&gt;	Indicates if a parcel should also be created when publishing	parcelSaveSource &lt;Boolean&gt; Indicates if the parcel should have its source file saved	parcelVersionString	&lt;String&gt;	If parcelSave is true, then this is the version string to use in the parcel, which can be differnt than the package/bundle	publisher &lt;StorePundleWriter&gt; holds the pundle writer  </body></comment><class><name>SharedNeedsShadowRoot</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Compiling and Loading</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.SharedNeedsShadowRoot</class-id><body>When defining a shared for a class that may have its namespace already in sunshine, we need some way of getting the shadow environment over to the definition mechanism. This is the way</body></comment><class><name>PrerequisiteSelector</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PrerequisiteSelector</class-id><body>PrerequisiteSelector this provides a list of packages to satisfy a prerequisiteInstance Variables	selections	&lt;SelectionInList&gt;	Package versions to choose from</body></comment><class><name>SinglePropertyView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property isAddition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.SinglePropertyView</class-id><body>I show a single package property, either removed or added (but not changed).Instance Variables	isAddition	&lt;Boolean&gt;	used to determine the header icon	property	&lt;CodeComponentPropertyBlueprint&gt;	property we're displaying</body></comment><class><name>ClassListPane</name><environment>Store.Glorp</environment><super>Store.Glorp.DefinitionsForListPane</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.ClassListPane</class-id><body>ClassListPane is used to list versions of a StoreClass in a DefinitionsForListTool</body></comment><class><name>LoadCanceled</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.LoadCanceled</class-id><body>LoadCanceled is raised if a load is canceled. This is possibly raised if a prereq selection is asked of the user and the user says to cancel load.Instance Variables	package	&lt;PundleModel or Pundle&gt;	Package being loaded when the error occured.</body></comment><class><name>UnloadableDefinitionError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package originalError </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.UnloadableDefinitionError</class-id><body>Raised when a db definition cannot be loaded into the image. Common problems covered here are methods and shared extensions with no class; class and namepsace defs with no enfivornment.Instance Variables:	package	&lt;PackageModel&gt;	The package this definition should load into.	originalError	&lt;Error | nil&gt;	The error that caused this to happen</body></comment><class><name>StoreClassNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.ClassNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreClassNavigatorPart</class-id><body>StoreClassNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>ClassCommentChangeResolver</name><environment>Store.Glorp</environment><super>Store.Glorp.ChangeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.ClassCommentChangeResolver</class-id><body>ClassCommentChangeResolver is a ChangeResolver for Class Comments</body></comment><class><name>SQLBroker</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><comment><class-id>Store.SQLBroker</class-id><body>Abstract superclass responsible for processing database queries and error handling. The subclasses interface to a specific backend.Subclasses must implement the following messages:	Class protocol:		drop objects			dropDatabaseFor:			dropIndexForClass:			dropIndexForClass:index:			dropSequenceForClass:			dropTableForClass:			dropUser:			dropViewForClass:		grant statements			grant:on:columnList:to:			processGrantStatement:		private-accessing			dismissSession:		connection class			connectionClass		error handling			alreadyExistErrors			cannotCloseCursorErrorCode			doesNotExistErrors			invalidObjectErrorNumber			objectAlreadyExistisErrorNumber			objectAlreadyGoneErrorNumber			serverDiedErrorCodes		accessing			fullTableName:			getBlobData:			indexNameFor:			needsSequenceFor:		private			typeToStringMap		sql processing			safelyExecuteBlock:		create objects			allocateSpaceForObjectsIn:			createDatabaseSequence:			createDatabaseTable:			createPhysicalSpaces			createTablePrimaryKeySectionFor:keys:			createViewForClass:		queries			newSQLFor:			nextIDQuery:			sqlAssistClass</body></comment><class><name>FilingOut</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.FilingOut</class-id><body>FilingOut is an annoucer used when filing out Store/Glorp objects</body></comment><class><name>Reading</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Store.Reading</class-id><body>Announced when reading packages from a database.</body></comment><class><name>StoreMetaclassExtension</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreAbstractClassExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreMetaclassExtension</class-id><body>This is a fake metaclass, used for browsing.Instance Variables	mainClass	&lt;StoreClass&gt;	The actual class this is extending</body></comment><class><name>SQLAssist</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName tableClass sqlStream alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><comment><class-id>Store.SQLAssist</class-id><body>Abstract superclass for sql statment generators. Subclasses support specfic backends.Instance Variables:	tableName	&lt;String&gt;  name of table being queried.	sqlStream	&lt;ReadWriteStream&gt;  used to build the query.	tableClass &lt;Class&gt; the class that represents the table being queried	alias &lt;String&gt; optional alias used for doing joins. Allows subclasses to optimize for specific backends.</body></comment><class><name>BindingTextualDetailSingularView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text icon name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.BindingTextualDetailSingularView</class-id><body>I'm a parameterizable view for a BindingBlueprint detail, for when the attribute is either added or removed (thus singular in display) rather than changed.Instance Variables	icon	&lt;VisualComponent&gt;	the icon to place in the header (meant to correlate with the detailHintGraphics)	text	&lt;CharacterArray&gt;	text that further describes the item (e.g. souce code of a share initializer, or text of a class comment)	name	&lt;CharacterArray&gt;	string label that shows up in the header	reference &lt;BindingReference&gt; identifies the object that the detail belongs to	</body></comment><class><name>StoreProtocolEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.ProtocolEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreProtocolEnvironment</class-id><body>StoreProtocolEnvironment is used when browsing Store/Glorp database objects</body></comment><class><name>PseudoPropertiesDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoPropertiesDifference</class-id><body>PseudoPropertyDifference  is used by the ComparePackages UI to show package property differences</body></comment><class><name>PseudoSharedDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoSharedDifference</class-id><body>PseudoSharedDifference is used by the ComparePackages UI to show shared variable object differences</body></comment><class><name>StoreSharedVariableInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id><body>This represents a shared variable definition in a particular package. Like the other inPackage entities, it corresponds more to what we'd think of as a method in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.</body></comment><class><name>PseudoClassForSharedDifference</name><environment>Store</environment><super>Store.PseudoClassDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.PseudoClassForSharedDifference</class-id><body>PseudoClassForSharedDifference is used only in merging to create a Difference object that holds a SharedVariable for a Class that by itself does not have any other changes, and thus wouldn't show up in the tree</body></comment><class><name>StoreSharedVariableCodeTool</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreBrowserDefinitionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreSharedVariableCodeTool</class-id><body>StoreSharedVariableCodeTool is used when browsing Store/Glorp database objects</body></comment><class><name>UninstallingDatabaseTables</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UninstallingDatabaseTables</class-id><body>UninstallingDatabaseTables is announced when uninstalling database tables</body></comment><class><name>StorePundlePropertyRelationship</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleID propertyID recordType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database Model</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePundlePropertyRelationship</class-id><body>StorePundlePropertyRelationship represents the "TW_Properties" table and is used by the Garbage CollectorInstance Variables	propertyID	&lt;Integer&gt;	This is the propertyRef column value	pundleID	&lt;Integer&gt;	This is the pundleRef column value	recordType	&lt;Integer&gt;	This is the recType column value</body></comment><class><name>ShadowedMethodObject</name><environment>Store</environment><super>Store.ShadowedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className extension ctype selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.ShadowedMethodObject</class-id><body>ShadowedMethodObject is a specialization of ShadowedObject for MethodsInstance Variables	className	&lt;String&gt;	The long name for the class owning this method	ctype	&lt;Boolean&gt;	True if the object is a CTYPE method	extension	&lt;Boolean&gt;	True if the object is an extension in the owning package	selector	&lt;Symbol&gt;	The, well, selector, ok?</body></comment><class><name>StorePackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StorePundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods classDefinitions fullClasses nameSpaces sharedVariables parcel binFile </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StorePackage</class-id><body>This represents a Store package, with its associated components.Instance Variables	binFile	&lt;String&gt;	As far as I can tell, an empty string if this is published binary, and otherwise null	classDefinitions	&lt;(OrderedCollection of: StoreClassDefinition)&gt; The basic class definitions	fullClasses 	&lt;OrderedCollection of: StoreClassExtension&gt;	The full classes, that is, class entities that have their own methods, definitions, and shared variables, rather than a separate collection of the different pieces. Note that this isn't read directly from the database, but is assembled out of the pieces as required. It's possible to map it directly to the database, but prohbitively slow with the current schema.	methods	&lt;(Collection of: (StoreMethod))&gt; All the methods associated with this package.	nameSpaces	&lt;(Collection of: (StoreNameSpace))&gt;	The namespace definitions.	parcel	&lt;StoreBlob&gt;	The parcel, if any	sharedVariables	&lt;(Collection of: (StoreSharedVariable))&gt;	The shared variable definitions</body></comment><class><name>ConnectionDialog</name><environment>Store</environment><super>Database.ConnectionDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableOwnerHolder tableOwnerListHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			Store.Glorp.StoreLoginFactory			</imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.ConnectionDialog</class-id><body>Store extension to the Datbase.ConnectionDialog.  Adds support for owner names.Instance Variables:	tableOwnerHolder	  &lt;ValueHolder&gt;	 Holds the current owner string.	tableOwnerListHolder &lt;ValueHolder&gt;	 Holds the list of existing owners.</body></comment><class><name>BundleCompilationResult</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundle results notificationQueue hasRunPostLoad installed </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>BundleCompilationResult</class-id><body>Maintains the results of the bundle components compilations. The component results are kept in the order they are passed in, which should be by their successful compilation order, not the component declared load order. Instance Variables	bundle	&lt;Pundle&gt;	The Bundle being loaded.	results	&lt;(OrderedCollection of: (ShadowedBundleCompilationResult | ShadowedCompilationResult))&gt;			the list of sub-compilation results. 	notificationQueue &lt;SharedQueue&gt;	Used to update any controlling UI	hasRunPostLoad &lt;Booelan&gt; Has this bundle been sent postLoad yet?	installed &lt;Boolean&gt; Has this bundle been installed yet</body></comment><class><name>StandardResolution</name><environment>Store.Glorp</environment><super>Store.Glorp.GeneralResolution</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.StandardResolution</class-id><body>StandardResolution is the most common kind of resolution holder. This is for standard add or modify resolutions, but not for removal, no-op or user input resolutionsInstance Variables	resolver	&lt;Object&gt;	A definition string or Store object or other object representing a resolution</body></comment><class><name>StoreLoggingTool</name><environment>Store</environment><super>Tools.LoggingTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StoreLoggingTool</class-id><body>Store extensions to LoggingTool used to view sql statements that would have been executed. For debugging and building installtation script.</body></comment><class><name>DatabaseIdentifier</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identityName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.DatabaseIdentifier</class-id><body>Used to store the name of this Store database.Instance Variables:	identityName	&lt;string&gt;  a name that uniquely identifies this database within an organzation.</body></comment><class><name>StoreCodeComponentInspectPropertiesTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentInspectPropertiesTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentInspectPropertiesTool</class-id><body>StoreCodeComponentInspectPropertiesTool is used when browsing Store/Glorp database objects</body></comment><class><name>PseudoMethodDifference</name><environment>Store</environment><super>Store.PseudoDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.PseudoMethodDifference</class-id><body>PseudoMethodDifference is used by the ComparePackages UI to show method object differences</body></comment><class><name>UserManagementPoliciesNotInstalledNotice</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.UserManagementPoliciesNotInstalledNotice</class-id><body>UserManagementPoliciesNotInstalledNotice is raised to notify the user that the user management policies have not been installed.Default value is nil</body></comment><class><name>ComparePackages</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comparedDifferences comparedPackages rawDifferences classesAndProperties methodsOrProperties selectionType fromProtocol toDefinition fromDefinition toProtocol definitionMenu storeSession </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			private Refactory.Browser.*			private Glorp.*			</imports><category></category><attributes><package>Store-Difference Management</package></attributes></class><comment><class-id>Store.ComparePackages</class-id><body>ComparePackages is a new UI to compare multiple Packages against other versions of each packageInstance Variables	comparedDifferences	&lt;Collection&gt;	description of comparedDifferences	comparedPackages	&lt;SelectionInList&gt;	description of comparedPackages	rawDifferences	&lt;Object | ProtoObject&gt;	description of rawDifferences	classesAndProperties	&lt;SelectionInList&gt;	description of classesAndProperties	methodsOrProperties	&lt;SelectionInList&gt;	description of methodsOrProperties	selectionType	&lt;ValueModel&gt;	description of selectionType</body></comment><class><name>PseudoPackage</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Pundles</category><attributes><package>Store-IMG-Pundles</package></attributes></class><comment><class-id>Store.PseudoPackage</class-id><body>PseudoPackage is used in comparing bundlesInstance Variables:	realPackage	&lt;BundleModel | PackageModel | PseudoPackage | Pundle&gt;	the real package being compared</body></comment><class><name>PseudoNamespaceForSharedDifference</name><environment>Store</environment><super>Store.PseudoNamespaceDifference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.PseudoNamespaceForSharedDifference</class-id><body>PseudoNamespaceForSharedDifference  is used only in merging to create a Difference object that holds a SharedVariable for a NameSpace that by itself does not have any other changes, and thus wouldn't show up in the tree</body></comment><class><name>PkgNameSpaces</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef nameSpaceRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgNameSpaces</class-id><body>Package to namespaces mapping.Instance Variables:	packageRef	&lt;Integer&gt;		Package primaryKey	nameSpaceRef	&lt;Integer&gt;	NameSpaceRecord primaryKey	definitionOrder	&lt;Integer&gt;	load order index</body></comment><class><name>ClassBlueprintComparisonView</name><environment>Tools</environment><super>Tools.NamespaceBlueprintComparisonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rightMethods leftMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.ClassBlueprintComparisonView</class-id><body>Class specific variant for showing class changes.ImplementationI am a significant specialization of the super abstract behaviors. I'm a subclass of the Namespace variant, because I can pick up comment and imports details rows from their. I provide a number of other detail rows for classes. In addition to class detail rows, I also add detail rows for all of the methods I know about.Unlike the super classes, I can actually have both leftBlueprint and rightBlueprint be nil. This is because in addition to the class blueprints, I also hold lists of methods associated with both sides. When one or the other is nil, it will then infer the class information from any of the methods classReference.Instance Variables	leftMethods	&lt;(Array of: (MethodBlueprint))&gt;	description of leftMethods	rightMethods	&lt;(Array of: (MethodBlueprint))&gt;	description of rightMethods</body></comment><class><name>LoadingActionError</name><environment>Store</environment><super>Store.LoadingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Shadowed Compiling</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Store.LoadingActionError</class-id><body>Triggered when an error occurs evaluating a components action blocks during loading.Instance Variables:	action	&lt;Symbol&gt;	indicates what failed: #preLoad #postLoad or #preRead</body></comment><class><name>StoreCodeComponentTabNavigatorPart</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentTabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentTabNavigatorPart</class-id><body>StoreCodeComponentTabNavigatorPart is used when browsing Store/Glorp database objects</body></comment><class><name>PseudoNameSpace</name><environment>Store</environment><super>Store.AbstractPseudo</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PseudoNameSpace</class-id><body>PseudoNameSpace is a placeholder for a Namespace definition that does not exist in a package, but might be needed for some display.  Consider the case where the old old browser is comparing two packages that have shared variables in a Namespace, yet neither package contains the definition.  This class helps provide the minimal display support so that shared variables can be displayed.</body></comment><class><name>StoreMethodInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreMethodInPackage</class-id><body>This represents a method defined in a particular package. Like the other inPackage entities, it corresponds more to what we'd think of as a method in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.</body></comment><class><name>RequestUniqueDatabaseIdentifierString</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.RequestUniqueDatabaseIdentifierString</class-id><body>RequestUniqueDatabaseIdentifierString requests a unique name for the databaseIf dealt with in a resume, it will answer 'store_database'If dealt with in a resume: aString it will answer aString</body></comment><class><name>StoreForGlorpBrowserEnvironment</name><environment>Store.Glorp</environment><super>Refactory.Browser.AbstractBrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id><body>I represent the classes/methods in the Store Browser.Instance Variables	pundles	&lt;(SequenceableCollection of: StoreBundle)&gt;	cached collection of all packages and bundles in the browser environment</body></comment><class><name>PseudoBundle</name><environment>Store</environment><super>Store.PseudoPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreForGlorpVWUI</package></attributes></class><comment><class-id>Store.PseudoBundle</class-id><body>PseudoBundle is used when comparing bundles</body></comment><class><name>PackageComparisonHeaderView</name><environment>Tools</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expandedFraction filteredComponents menuTarget comparison </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.PackageComparisonHeaderView</class-id><body>I show the list of packages/bundles that make up the contents of CodeComponentComparison, and support the ability to enable/disable some of them for a sibling ScrolledComparisonShell.ImplementationI show dual column rows for all of the matching component names found in my comparison. When one is found on only one side, I leave the other empty. Each sub view that shows a component, is tagged with a #codeComponent property, which allows that to be later queried from a given view.I support menu actions for components. When the mouse goes down a menuTarget is set by querying the #codeComponent property of the view under the mouse.I have four distinct children: summaryPanel, detailsPanel,swapButton, and disclosureButton. They always exist for all modes, but through the layout algorithm, we control which shows up where and when.I have two view modes that I manage. One is details mode. In this mode, we show all of the rows. The rows are actually buried in a BorderDecorator with a scrollbar, but we take care with the layout algorithm, to only show the scrollbar when we need to, otherwise we shove it past the right edge of me. The user can do menu actions and interact with the enable/disable button in that case.Summary mode hides all the rows (see the layout algorithm) and instead shows a single child which shows a synopsis label of the view.When there is exactly one package to show on both sides of the same name, I am said to be in "simple mode." In this case I start out in details mode, and I remove the expansion/collapse indicator at the bottom.When changes take place in the filteredComponents set, I synthesize a new comparsion object from mine via the #withoutComponents: API it provides, and pass that to my sibling ScrolledComparisonShell.When the swap button is pressed, I do that and rebuild myself.Instance Variables	comparison	&lt;CodeComponentComparison&gt;	The original whole comparison	expandedFraction	&lt;Number&gt;	value between 0 and 1, 0 is collapsed and puts me in "summary mode", 1 is expanded and puts me in details mode	filteredComponents	&lt;Set of: (CodeComponent | StorePundle)&gt;	components in the comparison which are to be currently filtered out using the withoutComponents: API	menuTarget	&lt;nil | StorePundle | CodeComponent&gt;	nil when idle, but set to the component under the mouse (if there is one), when the mouse button goes down</body></comment><class><name>StoreCodeComponentPropertiesTool</name><environment>Store.Glorp</environment><super>Refactory.Browser.CodeComponentPropertiesTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreForGlorpBrowserUI</package></attributes></class><comment><class-id>Store.Glorp.StoreCodeComponentPropertiesTool</class-id><body>StoreCodeComponentPropertiesTool is used when browsing Store/Glorp database objects</body></comment><class><name>CommentPrompt</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text blessingLevel userName pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.CommentPrompt</class-id><body>CommentPrompt is used to ask the user for the blessing level and  comment when changing a blessing for a package or bundleInstance Variables	blessingLevel	&lt;ValueHolder&gt;	The current blessing level selected	pundle	&lt;StorePundle&gt;	The StorePundle being mnodified	text	&lt;ValueModel&gt;	The comment the user may make	userName	&lt;LensAbsentee | Object&gt;	description of userName</body></comment><class><name>NoCommonAncestor</name><environment>Store</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.NoCommonAncestor</class-id><body>I am raised when no common ancestor can be computed between a set of buckages to compute merge changes from.</body></comment><class><name>VersionNode</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent package children level </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>Store-Merge Mangement</category><attributes><package>Store-Merge Management</package></attributes></class><comment><class-id>Store.Glorp.VersionNode</class-id><body>VersionNode is used by the ResolutionManager to hold information about the tree for a package versionInstance Variables	children		&lt;(Collection of: VersionNode)&gt;	My Children (if any)	level		&lt;Integer&gt;						My level in the tree	package	&lt;StorePundle | PundleModel&gt;		The package I'm holding	parent		&lt;VersionNode&gt;					My parent (or nil if none)</body></comment><class><name>PackageOwnerElement</name><environment>Store</environment><super>Store.ElementProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.PackageOwnerElement</class-id><body>PackageOwnerElement is used for showing package ownership graphs</body></comment><class><name>StoreLogEnvironment</name><environment>Store</environment><super>Tools.LogEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.StoreLogEnvironment</class-id><body>Store extensions to LogEnvironment used to record sql statements as executed. For debugging and building installtation script.</body></comment><class><name>RedefinitionOfClass</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atomic Compiling and Loading</category><attributes><package>Atomic Compiling and Loading</package></attributes></class><comment><class-id>Core.RedefinitionOfClass</class-id><body>RedefinitionOfClass is raised when a class redefinition is raised, and the class is already in the shadow environment and in the standard environment.</body></comment><class><name>PropertyComparisonView</name><environment>Tools</environment><super>Tools.AbstractComparisonRollupView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftProperty rightProperty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-Code Comparison</package></attributes></class><comment><class-id>Tools.PropertyComparisonView</class-id><body>I show a side by side comparison of two package properties.ImplementationThe majority of my display work is done by my SideBySideTextComparisonView. I just wrap it with the disclosure button and the header.Instance Variables	leftProperty	&lt;CodeComponentPropertyBlueprint&gt;	property to show on the left side	rightProperty	&lt;CodeComponentPropertyBlueprint&gt;	property to show on the right side</body></comment><class><name>BundleStructureComparisonView</name><environment>Store.Glorp</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isPressed targetView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.Glorp.BundleStructureComparisonView</class-id><body>Provides a side by side hierarchy view of bundle structures, showing differences between the two.ImplementationI build my tree of elements as a series of annotated Panels (annotated using properties). The method for populating them is basically a recursive traversal, starting with a root left and right bundle.I place the following properties on my sub panels:	#codeComponent - The Bundle/Package (in image or not) that I'm browsing for	#codeComponentPeer - the Bundle/Package (in image or not) that is the counterpart of my codeComponent. If the bundle structure has been reordered, thse won't necessarily be on the same row	#row - index of the row it's one, used by the layout algorithm	#indent - the indent level, used by the layout algorithm	#column - 1 or 2 (left or right), used by the layout algorithmSee the menu category for examples of adding menu items.Instance Variables	isPressed	&lt;Boolean&gt;	is button2 down?	targetView	&lt;nil | Panel&gt;	 target the mouse is over</body></comment><class><name>DownloadingFiles</name><environment>Store</environment><super>Store.StoreWorkActivity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.DownloadingFiles</class-id><body>This announcement is broadcast during loading when files are downloaded as part of a Bundle load</body></comment><class><name>StoreClassDefinitionInPackage</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObjectInPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metaclass </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			</imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><comment><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id><body>This is a class definition in a package. Like the other inPackage entities, it corresponds more closely to what we'd call a class definition in Smalltalk than the strict definition does. In particular, we expect to be able to ask questions like "what package is this in". In the database, a definition is in lots of packages. Or at least lots of package versions.Instance Variables:	metaclass	&lt;StoreClassDefinition&gt;	The metaclass for our definition.</body></comment><class><name>ClassCommentTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><shared-variable><name>DataKeySession</name><environment>Store.DataView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>DataSession</name><environment>Store.DataView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>DefinitionSession</name><environment>Store.BinaryBlob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>WriteSession</name><environment>Store.BinaryBlob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>PrerequisiteRecursion</name><environment>Store.Glorp.StorePundle</environment><private>false</private><constant>false</constant><category>prerequisites</category><initializer>nil</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>LoadingPropertiesSession</name><environment>Store.PropertiesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Atomic Compiling and Loading</package></attributes></shared-variable><shared-variable><name>PropertiesSession</name><environment>Store.PropertiesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>DefaultNotifications</name><environment>Store.StoreWorkActivity</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Store-Base</package></attributes></shared-variable><shared-variable><name>CannotUnloadComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>CannotStoreComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>CannotLoadComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>DefinitionSession</name><environment>Store.Blob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>WriteSession</name><environment>Store.Blob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>ClassesWithSourcesSession</name><environment>Store.PkgClassesAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>BundleSession</name><environment>Store.BundlesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>ShowToolbar</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>true</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>DifferencesType</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>#showCodeDifferences</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>WarnBeforeAbandoningUnpublished</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>true</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>ConflictsReference</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>#conflictsWithImage</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>NameStyle</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>#showShortNames</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>AutoSelectResolution</name><environment>Store.Glorp.MergeTool</environment><private>false</private><constant>false</constant><category>soft settings</category><initializer>true</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>UseChangeSetsForCompare</name><environment>Store.PundleModel</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>true</initializer><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>Repositories</name><environment>Store.RepositoryManager</environment><private>false</private><constant>false</constant><category>repository profiles</category><initializer>List new</initializer><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>PackageSession</name><environment>Store.PackagesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>DataWithSourcesSession</name><environment>Store.DataAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>MethodsSession</name><environment>Store.MethodsView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>MethodInClassSession</name><environment>Store.MethodsView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>UseNewCompareTool</name><environment>Store.ComparePackages</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>true</initializer><attributes><package>Store-Difference Management</package></attributes></shared-variable><shared-variable><name>ComponentNotFoundSignal</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>UseShadowLoader</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Atomic Compiling and Loading</package></attributes></shared-variable><shared-variable><name>PropertiesPublishingPolicy</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>settings</category><initializer>#bossAndTable</initializer><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>LegalPublishingProperties</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>settings</category><initializer>#(#bossAndTable #tableOnly #bossOnly )</initializer><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>PrerequisiteRecursion</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>prereqs</category><initializer>nil</initializer><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>ReconnectAction</name><environment>Store.StoreDevelopmentSystem</environment><private>false</private><constant>false</constant><category>control</category><initializer>#prompt</initializer><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>Announcements</name><environment>Glorp.GlorpError</environment><private>false</private><constant>false</constant><category>announcements</category><initializer>Announcer new</initializer><attributes><package>Store-Base</package></attributes></shared-variable><shared-variable><name>EmptyInArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>FullInArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>FullOutArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>EmptyOutArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>NameSpacesSession</name><environment>Store.PkgNameSpacesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>ModifiedPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>IsMonocrome</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ModifiedBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ModifiedNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DebugStoreII</name><environment>Store.Glorp.StoreObject</environment><private>false</private><constant>false</constant><category>settings-store</category><initializer>false</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>WarnIfNewerVersionPublished</name><environment>Store.Glorp.StoreObject</environment><private>false</private><constant>false</constant><category>settings-store</category><initializer>false</initializer><attributes><package>Store-Database Model</package></attributes></shared-variable><shared-variable><name>UseAtomicLoader</name><environment>Store.DBAccess</environment><private>false</private><constant>false</constant><category>system</category><initializer>true</initializer><attributes><package>Store-Database</package></attributes></shared-variable><shared-variable><name>UseAnalysisLoader</name><environment>Store.DBAccess</environment><private>false</private><constant>false</constant><category>system</category><initializer>true</initializer><attributes><package>Store-Database</package></attributes></shared-variable><shared-variable><name>LoadFailedOption</name><environment>AtomicLoader</environment><private>false</private><constant>false</constant><category>Load Fail</category><initializer>ValueHolder with: #loadButNotify</initializer><attributes><package>Atomic Compiling and Loading</package></attributes></shared-variable><shared-variable><name>Session</name><environment>Store.DBObject</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>LastTimestamp</name><environment>Store.DBObject</environment><private>false</private><constant>false</constant><category>timestamp</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>ServerTimestamp</name><environment>Store.DBObject</environment><private>false</private><constant>false</constant><category>timestamp</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>ClassesSession</name><environment>Store.PkgClassesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>MoveOutIcon</name><environment>Store.Glorp.ChangeResolver</environment><private>false</private><constant>false</constant><category>MoveOutIcon</category><initializer>MergeIcons move copy image: (MergeIcons move image copy reflectedInX)</initializer><attributes><package>Store-Merge Management</package></attributes></shared-variable><shared-variable><name>UserPreferences</name><environment>Store.StoreSettings</environment><private>false</private><constant>false</constant><category>Settings</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbRegistry</name><environment>Store</environment><private>false</private><constant>false</constant><category>Store-Base</category><attributes><package>Store-Base</package></attributes></shared-variable><shared-variable><name>MethodsWithSourcesSession</name><environment>Store.MethodsAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>NameSpacesWithSourcesSession</name><environment>Store.PkgNameSpacesAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>MetaclassesSession</name><environment>Store.PkgMetaclassesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><methods><class-id>Store.BasicOwnershipPolicy</class-id> <category>accessing</category><body package="Store-Ownership" selector="currentUserIsOwner:">currentUserIsOwner: aPundle	"Answer true if the current user has ownership rights over a pundle."	^true		"not looking"</body><body package="Store-Ownership" selector="currentUserName">currentUserName	^DbRegistry currentUserName</body><body package="Store-Ownership" selector="isImageAdministrator">isImageAdministrator	"Returns a boolean indicating whether or not the user is the Image Administrator"	^DbRegistry isSystemAdministrator</body><body package="Store-Ownership" selector="ownerOfPundle:">ownerOfPundle: aPundle	^nil.</body></methods><methods><class-id>Store.OwnerOwnershipPolicy</class-id> <category>accessing</category><body package="Store-Ownership" selector="currentUser">currentUser	^StoreUserGroup userNamed: self currentUserName</body><body package="Store-Ownership" selector="currentUserHasOwnershipPrivilegesFor:">currentUserHasOwnershipPrivilegesFor: aPundle	"Answer true if the current user has ownership rights over a pundle."		(self ownerOfPundle: aPundle) ifNil: [^true].	^StoreAccessPrivilege user: self currentUser hasPrivilege: #owner to: aPundle</body><body package="Store-Ownership" selector="currentUserHasPublishingPrivilegesFor:">currentUserHasPublishingPrivilegesFor: aPundle	"Answer true if the current user has publishing rights over a pundle."		^StoreAccessPrivilege user: self currentUser hasPrivilege: #publish to: aPundle</body><body package="Store-Ownership" selector="currentUserIsOwner:">currentUserIsOwner: aPundle	"Answer true if the current user has ownership rights over a pundle."	^StoreAccessPrivilege user: self currentUser hasPrivilege: #owner to: aPundle.</body><body package="Store-Ownership" selector="ownerOfPundle:">ownerOfPundle: aPundle		^(#{StoreAccessPrivilege} valueOrDo: [^super ownerOfPundle: aPundle]) ownerOfPundle: aPundle</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>menu enabling</category><body package="Store-UI" selector="are2VersionsOfAPundleSelected">are2VersionsOfAPundleSelected	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size = 2 ifFalse: [^false].	pundles first isPackage = pundles last isPackage ifFalse: [^false].	pundles first name = pundles last name ifFalse: [^false].	^true</body><body package="Store-UI" selector="areBundlesSelected">areBundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isBundle ifFalse: [^false].			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areDBPundlesSelected">areDBPundlesSelected	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles do: [:pun | pun isLoaded ifTrue: [^false]].	^true</body><body package="Store-UI" selector="areDBPundlesSelectedAndSomeVersionIsLoaded">areDBPundlesSelectedAndSomeVersionIsLoaded	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isLoaded ifTrue: [^false].			((pun isPackage and: [Registry isPackageLoaded: pun name]) 					or: [pun isBundle and: [Registry isBundleLoaded: pun name]])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areLoadedBundlesSelected">areLoadedBundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isBundle ifFalse: [^false].			pun isLoaded ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areLoadedPundlesSelected">areLoadedPundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isLoaded ifFalse: [^false]].	^true</body><body package="Store-UI" selector="arePackagesSelected">arePackagesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isPackage ifFalse: [^false].			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="arePundlesSelected">arePundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areVersionableObjectsSelected">areVersionableObjectsSelected	self isDBConnected ifFalse: [^false].	^self pundles size &gt; 0</body><body package="Store-UI" selector="isDBConnected">isDBConnected	^DbRegistry isOnline</body><body package="Store-UI" selector="isImageAdministrator">isImageAdministrator	"Added by Philippe F. Monnet of Andersen Consulting"			^Policies ownershipPolicy isImageAdministrator</body><body package="Store-UI" selector="isLoadedPackageSelected">isLoadedPackageSelected	| pundles pun |	pundles := self pundleVersions.	pundles size = 1 ifFalse: [^false].	pun := pundles first.	pun isPackage ifFalse: [^false].	pun isLoaded ifFalse: [^false].	^true</body><body package="Store-UI" selector="isLoadedPundleSelected">isLoadedPundleSelected	| pundles |	pundles := self pundleVersions.	pundles size = 1 ifFalse: [ ^false ].	^pundles contains: [ :pun | pun isLoaded not ].</body><body package="Store-UI" selector="makePundleMenuDynamic:">makePundleMenuDynamic: menu 	"Add dynamic features to the menu. ALPHA ORDER" 	self makeDynamicItem: #browsePackageVersion selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #browseVersions selectionBlock: [self areVersionableObjectsSelected] inMenu: menu.	self makeDynamicItem: #createAsParcel selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #enclosingBundles selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #deletePundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #diffPundleWithImage selectionBlock: [self areDBPundlesSelectedAndSomeVersionIsLoaded] inMenu: menu.	self makeDynamicItem: #diffPundleWithParent selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #diffTwoPundles selectionBlock: [self are2VersionsOfAPundleSelected] inMenu: menu.	self makeDynamicItem: #editBundleSpecification selectionBlock: [self areLoadedBundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutChanges selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutPundle selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutTwoPundleDiff selectionBlock: [self are2VersionsOfAPundleSelected] inMenu: menu.	self makeDynamicItem: #graphPundleVersions selectionBlock: [self areVersionableObjectsSelected] inMenu: menu.	self makeDynamicItem: #inspectChangesInPundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #listBundleContents selectionBlock: [self areBundlesSelected] inMenu: menu.	self makeDynamicItem: #republish selectionBlock: [self areBundlesSelected &amp; self areLoadedBundlesSelected not ] inMenu: menu.	self makeDynamicItem: #loadPundle selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #makeCurrentPackage selectionBlock: [self isLoadedPackageSelected] inMenu: menu.	self makeDynamicItem: #mergePundleVersion selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #methodsChangesInPundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #reloadVersions selectionBlock: [self isDBConnected] inMenu: menu.	self makeDynamicItem: #renamePundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #setBlessingLevel selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #showBundleStructure selectionBlock: [self areBundlesSelected] inMenu: menu.	self makeDynamicItem: #storePundleInDB selectionBlock: [self areLoadedPundlesSelected and: [self isDBConnected]] inMenu: menu.	self makeDynamicItem: #reconcile selectionBlock: [self isLoadedPundleSelected] inMenu: menu.	^menu</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>pundle actions</category><body package="Store-UI" selector="addBlessingForPundle:">addBlessingForPundle: aDBPundle 	"Add a new record describing blessing for package."	BlessingDialog setBlessingFor: aDBPundle.</body><body package="Store-UI" selector="browseVersions">browseVersions		| session |	self doIfOnlineImage: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		[self pundles do: 			[:each | 			(Gathering for: each name) started.			Store.Glorp.DefinitionForListTool forVersionsOfPackage: (each asStorePundleIn: session).			(Gathering for: each name) finished]] withStoreFeedbackOn: self mainWindow]</body><body package="Store-UI" selector="createAsParcel">createAsParcel	self pundles do:		[ :pundle | self createAsParcel: pundle ].</body><body package="Store-UI" selector="createAsParcel:">createAsParcel: aPundle 	| name |	name := nil.	[name == nil] whileTrue: 		[name := Dialog 					request: #ParcelName &lt;&lt; #store &gt;&gt; 'Parcel name:'					initialAnswer: aPundle name					onCancel: [^self].		name isEmpty ifTrue: [^self].		(Parcel parcelNamed: name) == nil ifFalse: 			[(Dialog confirm: ((#ParcelNamed1sExistsOverwriteIt &lt;&lt; #store &gt;&gt; 'Parcel named "&lt;1s&gt;" exists - overwrite it?') expandMacrosWith: name)) 				ifTrue: [Parcel destroyParcelNamed: name]				ifFalse: [name := nil]]].	aPundle asParcel: name</body><body package="Store-UI" selector="deletePundle">deletePundle	| pundles | 	pundles := self pundles.	(Dialog confirm: 'Unload', (pundles inject: '' into: [:str :pun | str , ' ' , pun name]) , '?')		ifTrue: [pundles do: [:pun | pun unloadLogged: false ]]</body><body package="Store-UI" selector="diffPundleWithImage">diffPundleWithImage	self doIfOnlineImage: 		[self packages do: 			[:eachPackage | 			| packageModel |			packageModel := Registry packageNamed: eachPackage name.			packageModel isNil				ifTrue: [Dialog warn:( (#Package1sIsNotCuOadedIntoTheImage &lt;&lt; #store &gt;&gt; 'Package &lt;1s&gt; is not currently loaded into the image.') expandMacrosWith: eachPackage name)]				ifFalse: [self diffPundle: packageModel with: eachPackage]].		self bundles do: 			[:eachBundle | 			| bundleModel |			bundleModel := Registry bundleNamed: eachBundle name.			bundleModel isNil				ifTrue: [Dialog warn: ((#Bundle1sIsNotCurOadedIntoTheImage &lt;&lt; #store &gt;&gt; 'Bundle &lt;1s&gt; is not currently loaded into the image.')expandMacrosWith:eachBundle name)]				ifFalse: [self diffPundle: bundleModel with: eachBundle]]]</body><body package="Store-UI" selector="diffPundleWithParent">diffPundleWithParent		self packages , self bundles do:		[:eachStorePundle | 		| tracePackage |		(tracePackage := eachStorePundle tracePackage) isNil ifTrue: 			[tracePackage := eachStorePundle selectStoreVersion].		tracePackage ifNotNil: [self diffPundle: eachStorePundle with: tracePackage]]</body><body package="Store-UI" selector="diffTwoPundles">diffTwoPundles	| selectedPundles |	selectedPundles := self pundles.	selectedPundles size = 2 ifFalse: 		[^Dialog warn: #ChooseExactlyTwoVersionsToCompare &lt;&lt; #store &gt;&gt; 'Choose exactly two versions to compare'].	self doIfOnlineImage: [self diffPundle: selectedPundles first with: selectedPundles last]</body><body package="Store-UI" selector="fileOutChanges">fileOutChanges		| puns fileName strm |	puns := self pundles.	puns size = 0 ifTrue: [^self].	fileName := puns size = 1		ifTrue:			[| oldSeparator pun |			pun := puns first.			fileName := pun name asString , '.st'.			oldSeparator := (fileName includes: UnixFilename separator)				ifTrue: [UnixFilename separator]				ifFalse:					[(fileName includes: PCFilename separator)						ifTrue: [PCFilename separator]						ifFalse: [nil]].			fileName				replaceAll: oldSeparator				with: Filename separator.			fileName copyWithout: Character space]		ifFalse: ['changes.st'].	fileName := Dialog		requestNewFileName:			#FileOutAsFileNamed &lt;&lt; #store &gt;&gt; 'File out as file named'		default: fileName.	fileName isEmpty ifTrue: [^self].	strm := SourceCodeStream write: fileName.	Cursor write		showWhile:			[[strm timeStamp.			puns do: [:pun | pun fileOutChangesOn: strm]] ensure: [strm close]]</body><body package="Store-UI" selector="fileOutPundle">fileOutPundle	self pundles do: [:pun | pun fileOut]</body><body package="Store-UI" selector="fileOutTwoPundleDiff">fileOutTwoPundleDiff	| puns |	puns := self pundles.	puns size = 2 ifFalse: 		[^Dialog warn: #ChooseExactlyTwoVersionsToCompare &lt;&lt; #store &gt;&gt; 'Choose exactly two versions to compare'].	(puns first pundleChangesClass with: puns first with: puns last) 		fileOutChangesFor: 1</body><body package="Store-UI" selector="glorpLoad">glorpLoad		| session |	self doIfOnlineImage:		[session :=Store.Glorp.StoreLoginFactory currentStoreSession.		StoreProgressOverlay			subsume: builder window			while:				[| myVersions |				myVersions := self pundles collect: [:each | each glorpReconciledVersionIn: session].				myVersions do: [:each | each ifNotNil: [each loadSource]]].		self reloadVersions]</body><body package="Store-UI" selector="graphPundleVersions">graphPundleVersions	self doIfOnlineImage: [		self pundles do: [:pundle |			VersionGraph browseVersionsOfPundle: pundle]]</body><body package="Store-UI" selector="inspectChangesInPundle">inspectChangesInPundle	self pundles do: [:pun | pun inspectChangeSet]</body><body package="Store-UI" selector="loadPundle">loadPundle	^self glorpLoad</body><body package="Store-UI" selector="mergePundleVersion">mergePundleVersion	| session |	self doIfOnlineImage: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		Store.Glorp.MergeTool openOnPundles: (self pundles collect: [:each | each asStorePundleIn: session])]</body><body package="Store-UI" selector="methodsChangesInPundle">methodsChangesInPundle	"Spawn method changes list on pundle(s)."		self storeBrowseChanges: self defaultDbId</body><body package="Store-UI" selector="reconcile">reconcile	| puns dbVersion imgVersion |	puns := self pundles.	puns size == 1 ifFalse: 		[^Dialog warn: #ChooseOneVersionToReconcile &lt;&lt; #store &gt;&gt; 'Choose one version to reconcile.'].	dbVersion := puns first.	(imgVersion := dbVersion getImagePundle) == nil ifTrue: 		[^Dialog warn: #ThereIsNoImageVersionToReconcile &lt;&lt; #store &gt;&gt; 'There is no image version to reconcile.'].	imgVersion reconcileWithDbVersion: dbVersion</body><body package="Store-UI" selector="renamePundle">renamePundle"----  SOON TO BE DEFUNCT ------	self pundles		do: 			[:pundle | 			| pundleName |			pundleName := Dialog						request: 'Rename to what?'						initialAnswer: pundle name						onCancel: [nil].			pundleName size = 0 ifTrue: [^self].			[((self storageForPundle: pundle)				entryNamed: pundleName) notNil]				whileTrue: 					[pundleName := Dialog								request: pundleName , ' is already in use.\Enter another name.' withCRs								initialAnswer: pundleName								onCancel: [nil].					pundleName isEmpty ifTrue: [^self]].			pundle name: pundleName].	self updatePundleVersion-------------------------"</body><body package="Store-UI" selector="setBlessingLevel">setBlessingLevel	"Add blessing level to the selected package."	self			doIfOnlineImage: 				[self pundles do: [:pundle | self addBlessingForPundle: pundle].				self updatePundleVersion]</body><body package="Store-UI" selector="setTrace">setTrace	self pundles do: 			[:pundle | 			(Dialog confirm: ((#DoYouWantToSetTheTraceTo1s &lt;&lt; #store &gt;&gt; 'Do you want to set the trace to &lt;1s&gt;?') 						expandMacrosWith: pundle itemString)) 				ifTrue: 					[| imPun |					imPun := pundle isPackage 								ifTrue: [Registry packageNamed: pundle name]								ifFalse: [Registry bundleNamed: pundle name].					imPun isNil 						ifTrue: 							[^Dialog warn: ((#NoVersionOf1sIsLoadedInTheImage &lt;&lt; #store &gt;&gt; 'No version of &lt;1s&gt; is loaded in the image.') 										expandMacrosWith: pundle name)].					imPun dbTrace: pundle primaryKey]]</body><body package="Store-UI" selector="storePundleInDB">storePundleInDB	self doIfOnlineImage: [Cursor wait showWhile: [self pundles do: [:pundle | pundle storeInDB]]]</body><body package="Store-UI" selector="updatePundleVersion">updatePundleVersion	"No-op unless over-ridden"</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>selection</category><body package="Store-UI" selector="bundles">bundles	^self pundles select: [:aPundle | aPundle isBundle].</body><body package="Store-UI" selector="packages">packages	^self pundles select: [:aPundle | aPundle isPackage].</body><body package="Store-UI" selector="pundles">pundles	self subclassResponsibility</body><body package="Store-UI" selector="pundleVersions">pundleVersions	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>bundle actions</category><body package="Store-UI" selector="addBundle">addBundle	BundleSpecEditor open</body><body package="Store-UI" selector="editBundleSpecification">editBundleSpecification	self bundles do: [:aBundle | BundleSpecEditor openOnBundle: aBundle]</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>menus</category><body package="Store-UI" selector="menuBar">menuBar	"Add dynamic features to the menu bar."	| menu |	menu := self class menuBarSkeleton.	menu menuItems do: [:item | self makePundleMenuDynamic: item submenu].	menu augmentFrom: self class		to: AbstractTool		menuName: #menuBar		for: self.	^menu</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>private</category><body package="Store-UI" selector="diffPundle:with:">diffPundle: aPundle with: anotherPundle	"Assume they're in left-&gt;right order, then determine if we need to swap them via the timestamps that might or might not be available to us. The asStoreComparisonObjectIn: makes sure we have either StorePundle or PundleModel objects, no old Store objects."	| left right session leftTimestamp rightTimestamp |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	left := aPundle asStoreComparisonObjectIn: session.	right := anotherPundle asStoreComparisonObjectIn: session.	leftTimestamp := (left isKindOf: PundleModel)				ifTrue: [left storeTracePackage ifNotNil: #timestamp]				ifFalse: [left timestamp].	rightTimestamp := (right isKindOf: PundleModel)				ifTrue: [right storeTracePackage ifNotNil: #timestamp]				ifFalse: [right timestamp].	(leftTimestamp isNil		or: [rightTimestamp notNil and: [rightTimestamp &lt; leftTimestamp]])			ifTrue: 				[| swap |				swap := left.				left := right.				right := swap].	ComparePackages compareFrom: left to: right</body><body package="Store-UI" selector="doIfOnlineImage:">doIfOnlineImage: aBlock 	^DbRegistry doIfOnlineImage: aBlock</body><body package="Store-UI" selector="fileOutPackageDiff:with:into:">fileOutPackageDiff: pkg1 with: pkg2 into: aStream 	pkg1 isNil 		ifTrue: 			[self error: #CanNotFileOutDiffeAinstMissingPackage &lt;&lt; #store &gt;&gt; 'Can not file out differences against missing package']		ifFalse: 			[pkg2 isNil 				ifTrue: [pkg1 fileOutOn: aStream]				ifFalse: 					[Notice 						show: ((#ComparingVersionsOfPackage1s &lt;&lt; #store &gt;&gt; 'Comparing versions of package &lt;1s&gt;.') expandMacrosWith: pkg1 name)						while: 							[| pkgDiffs |							pkgDiffs := PackageDifferences with: pkg1 with: pkg2.							pkgDiffs fileDiffsOn: aStream]].			aStream cr]</body><body package="Store-UI" selector="makeDynamicItem:selectionBlock:inMenu:">makeDynamicItem: actionSymbol selectionBlock: aBlock inMenu: aMenu	| mi |	mi := aMenu menuItemWithValue: actionSymbol ifNone: [nil].	mi notNil ifTrue: [mi enabled: aBlock].</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>events</category><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	"The containing window is being closed -- release."	self release</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>package actions</category><body package="Store-UI" selector="addPackage">addPackage		SmalltalkWorkbench requestNewPackageName		ifNotNil: [:name | PackageModel named: name].</body><body package="Store-UI" selector="browsePackageVersion">browsePackageVersion		self pundles do: 		[:each | 		InputState default ctrlDown 			ifTrue: [each inspect] 			ifFalse: 				[each isPackage					ifTrue: [self browseStorePackage: each]					ifFalse: [self browseStoreBundle: each]]]</body><body package="Store-UI" selector="browseStoreBundle:">browseStoreBundle: aBundle	| storeBundle |	storeBundle := aBundle asStorePundle.		[(Gathering for: storeBundle) started.	storeBundle prefetchAllFromDatabase.	(Gathering for: storeBundle) finished]			withStoreFeedbackOn: self mainWindow.	(Store.Glorp.StoreForGlorpBrowserEnvironment on: storeBundle) openEditor</body><body package="Store-UI" selector="browseStorePackage:">browseStorePackage: aPackage	| storePackage |	storePackage := aPackage asStorePundle.		[(Gathering for: storePackage) started.	storePackage prefetchAllFromDatabase.	(Gathering for: storePackage) finished]			withStoreFeedbackOn: self mainWindow.	(Store.Glorp.StoreForGlorpBrowserEnvironment on: storePackage) openEditor</body><body package="Store-UI" selector="makeCurrentPackage">makeCurrentPackage	self packages size = 1 ifFalse: 		[^Dialog warn: #PleaseSelectExactlyOnePackage &lt;&lt; #store &gt;&gt; 'Please select exactly one package.'].	Registry currentPackage: self packages first</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>actions</category><body package="Store-UI" selector="reloadVersions">reloadVersions	self unimplemented</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>text differencing</category><body package="Store-UI" selector="differenceEmphasis">differenceEmphasis		^#bold</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>resources</category><body package="Store-UI" selector="dbNonCodePackageImage">dbNonCodePackageImage	^DbNonCodePackageImage</body><body package="Store-UI" selector="nonCodePackageImageModified">nonCodePackageImageModified	^ModifiedNonCodePackageImage</body><body package="Store-UI" selector="nonCodePackageImageUnmodified">nonCodePackageImageUnmodified	^UnmodifiedNonCodePackageImage</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>utilities</category><body package="Store-UI" selector="addPackageDialog">addPackageDialog	| pkgName newPkg |	pkgName := (Dialog				request: #EnterANameForThePackage &lt;&lt; #store &gt;&gt; 'Enter a name for the package:' 				initialAnswer: ''				onCancel: [String new]) 					trimBlanks.	pkgName isEmpty ifTrue: [^nil].	[Registry isPackageLoaded: pkgName]		whileTrue: 			[pkgName := Dialog						request:  ( (#_1sIsAlreadyInUseNameForThePackage &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is already in use.&lt;n&gt;Enter another name for the package.') expandMacrosWith: pkgName)						initialAnswer: pkgName						onCancel: [nil].			pkgName isNil ifTrue: [^nil]].	newPkg := PackageModel named: pkgName.	^newPkg</body><body package="Store-UI" selector="compareBundle:with:">compareBundle: aBundle1 with: aBundle2 	"Compare all packages that are in aBundle1 with 	packages that are contained by aBundle2. 	Answer a collection of pairs. First element of each pair 	is one of my packages or nil. Second element of each pair 	is one of packages belonging to aBundle or nil. 	Note that aBundle1 and aBundle2 may have different names"	| result |	(Gathering for: aBundle1) started.	result := self compareHomogeneousItems: aBundle1 leafItems with: aBundle2 leafItems.	(Gathering for: aBundle1) finished.	^result</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>label utilities</category><body package="Store-UI" selector="addCheckMarkToImage:">addCheckMarkToImage: anImage 	| cp |	cp := CompositePart new.	cp add: self checkMark at: 0 @ 0.	cp add: anImage at: self checkMarkWidth @ 0.	^cp</body><body package="Store-UI" selector="iconForPundle:">iconForPundle: aPundle	^aPundle toolListIcon</body><body package="Store-UI" selector="labelForPundle:reversed:inView:">labelForPundle: aPundle reversed: isReversed inView: aSelectionView 	^self		labelWithString: (aPundle stringKey: #())		icon: (self iconForPundle: aPundle)		disabled: false		reversed: isReversed		checked: false		inView: aSelectionView		offsetForCheckedView: false</body><body package="Store-UI" selector="labelWithString:icon:disabled:reversed:checked:inView:offsetForCheckedView:">labelWithString: aString icon: anImage disabled: isDisabled reversed: isReversed checked: isChecked inView: aSelectionView offsetForCheckedView: isOffset 	"If isOffset is true, the returned LabalAndIcon will be offset so that the icon 	will align with the icons of other labels preceeded by check marks."	| label disabledText |	label := LabelAndIcon with: aString attributes: aSelectionView textStyle.	isDisabled		ifTrue: 			[disabledText := aString asText.			disabledText emphasizeAllWith: #color -&gt; aSelectionView inactiveForegroundColor.			label text: disabledText].	label icon: (isChecked ifTrue: [self addCheckMarkToImage: anImage] ifFalse: [anImage]).	isOffset ifTrue: [label offset: self checkMarkWidth @ 0].	isReversed		ifTrue: 			[label := ReversingWrapper on: label.			label reverse setValue: true].	^label</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>private</category><body package="Store-UI" selector="checkMark">checkMark	^LabelAndIcon checkMark</body><body package="Store-UI" selector="checkMarkGap">checkMarkGap	^4</body><body package="Store-UI" selector="checkMarkWidth">checkMarkWidth	^self checkMark width + self checkMarkGap</body><body package="Store-UI" selector="compareHomogeneousItems:with:">compareHomogeneousItems: aCollectionOfPundles with: anotherCollectionOfPundles	"Compare two lists that contain pundles with 	Answer a collection of pairs. First element of each pair 	is one from list1 or nil. Second element of each pair 	is one from list2 or nil."		| gatheredPundles versionMatchedPundles session |	gatheredPundles := Dictionary new.	versionMatchedPundles := OrderedCollection new.	session := Store.Glorp.StoreLoginFactory currentStoreSession.	anotherCollectionOfPundles do: [:each | gatheredPundles at: each name put: (each asStoreComparisonObjectIn: session)].	aCollectionOfPundles do:		[:each | 		| other |		(Gathering for: (each asStoreComparisonObjectIn: session)) started.		other := gatheredPundles			at: each name			ifAbsent:				[versionMatchedPundles add: (Array with: (each asStoreComparisonObjectIn: session) with: nil).				nil].		other notNil ifTrue:			[(other sameVersionAs: (each asStoreComparisonObjectIn: session)) ifFalse: 				[versionMatchedPundles add: (Array 					with: (each asStoreComparisonObjectIn: session) 					with: (other asStoreComparisonObjectIn: session))].			gatheredPundles at: each name put: nil].		(Gathering for: (each asStoreComparisonObjectIn: session)) finished].	gatheredPundles do: [:each | each notNil ifTrue: [versionMatchedPundles add: (Array with: nil with: (each asStoreComparisonObjectIn: session))]].	^versionMatchedPundles</body><body package="Store-UI" selector="install">install	self updateImages.</body><body package="Store-UI" selector="obsolete">obsolete	super obsolete.	ObjectMemory removeDependent: self</body><body package="Store-UI" selector="update:with:from:">update: anAspect with: arguments from: anObject	"Check for return from snapshot to install."	anAspect == #returnFromSnapshot		ifTrue: [self install]</body><body package="Store-UI" selector="updateImages">updateImages	| mono |	mono := Screen default colorDepth == 1.	IsMonocrome = mono ifTrue: [^self].	IsMonocrome := mono.	IsMonocrome		ifTrue: 			[ModifiedBundleImage := self bundleImageModifiedBW.			ModifiedPackageImage := self packageImageModifiedBW.			ModifiedNonCodePackageImage := self nonCodePackageImageModifiedBW]		ifFalse: 			[ModifiedBundleImage := OpaqueImage figure: (CachedImage on: self bundleImageModifiedC)						shape: (CachedImage on: self bundleImageModifiedBW).			ModifiedPackageImage := OpaqueImage figure: (CachedImage on: self packageImageModifiedC)						shape: (CachedImage on: self packageImageModifiedBW).			ModifiedNonCodePackageImage := OpaqueImage figure: (CachedImage on: self nonCodePackageImageModifiedC)						shape: (CachedImage on: self nonCodePackageImageModifiedBW)].	DbBundleImage := self dbBundleImageBW.	DbNonCodePackageImage := self dbNonCodePackageImageBW.	DbPackageImage := self dbPackageImageBW.	UnmodifiedBundleImage := self bundleImageUnmodifiedBW.	UnmodifiedPackageImage := self packageImageUnmodifiedBW.	UnmodifiedNonCodePackageImage := self nonCodePackageImageUnmodifiedBW</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize"	ObjectMemory removeDependent: self.	ObjectMemory addDependent: self.	self updateImages.</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>generated resources</category><body package="Store-UI" selector="bundleImageModified">bundleImageModified	^ListIconLibrary visualFor: #modifiedBundle</body><body package="Store-UI" selector="bundleImageUnmodified">bundleImageUnmodified	^ListIconLibrary visualFor: #bundle</body><body package="Store-UI" selector="dbBundleImage">dbBundleImage	^ListIconLibrary visualFor: #bundle</body><body package="Store-UI" selector="dbPackageImage">dbPackageImage	^ListIconLibrary visualFor: #package</body><body package="Store-UI" selector="packageImageModified">packageImageModified	^ListIconLibrary visualFor: #modifiedPackage</body><body package="Store-UI" selector="packageImageUnmodified">packageImageUnmodified	^ListIconLibrary visualFor: #package</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>menu messages</category><body package="Store-UI-Comparitors" selector="findDiffs">findDiffs	| main other mainFragments otherFragments |	main := text1 value asText.	other := text2 value asText.	mainFragments := main wordAndWhitespaceFragments.	otherFragments := other wordAndWhitespaceFragments.	(mainFragments differences: otherFragments)		do: #applyAnyDifferenceTextEmphases.	(self builder componentAt: #text1Widget) widget model value: main.	(self builder componentAt: #text2Widget) widget model value: other</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>aspects</category><body package="Store-UI-Comparitors" selector="enableTextAccept">enableTextAccept	^false</body><body package="Store-UI-Comparitors" selector="postOpenWith:">postOpenWith: aBuilder 	(self text1 value isEmpty not and: [self text2 value isEmpty not])		ifTrue: [self findDiffs]</body><body package="Store-UI-Comparitors" selector="text1">text1	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^text1 isNil ifTrue: [text1 := String new asValue] ifFalse: [text1]</body><body package="Store-UI-Comparitors" selector="text2">text2	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^text2 isNil ifTrue: [text2 := String new asValue] ifFalse: [text2]</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>menus</category><body package="Store-UI-Comparitors" selector="customTextMenu">customTextMenu	"No accept from this browser."	| mb |	mb := MenuBuilder new.	mb		addFindReplaceUndo;		line;		addCopyCutPaste;		line;		add: (#cancel &lt;&lt; #store &gt;&gt; 'cancel') asString -&gt; #cancel.	^mb menu</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>text differencing</category><body package="Store-UI-Comparitors" selector="differenceEmphasis">differenceEmphasis		^Array with: #color -&gt; ColorValue red with: #bold</body></methods><methods><class-id>Store.TextDifferenceBrowser class</class-id> <category>instance creation</category><body package="Store-UI-Comparitors" selector="compare:with:">compare: text1 with: text2 		| instance |	instance := self new.	instance text1 value: text1.	instance text2 value: text2.	instance openInterface: #briefSpec</body></methods><methods><class-id>Store.MethodDifferenceBrowser</class-id> <category>aspects</category><body package="Store-UI-Comparitors" selector="protocol1">protocol1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^protocol1 isNil		ifTrue:			[protocol1 := String new asValue]		ifFalse:			[protocol1]</body><body package="Store-UI-Comparitors" selector="protocol2">protocol2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^protocol2 isNil		ifTrue:			[protocol2 := Text new asValue]		ifFalse:			[protocol2]</body></methods><methods><class-id>Store.MethodDifferenceBrowser</class-id> <category>menu messages</category><body package="Store-UI-Comparitors" selector="findDiffs">findDiffs	| firstProtocolText secondProtocolText prefix |	super findDiffs.	firstProtocolText := protocol1 value asText.	secondProtocolText := protocol2 value asText.	firstProtocolText = secondProtocolText		ifFalse: 			[firstProtocolText := firstProtocolText						emphasizeAllWith: #color -&gt; ColorValue red.			secondProtocolText := secondProtocolText						emphasizeAllWith: #color -&gt; ColorValue red].	prefix := (#ProtocolSpaceColonSpace &lt;&lt; #store &gt;&gt; 'Protocol : ') asText				allBold.	(self builder componentAt: #protocol1) widget model		value: prefix , firstProtocolText.	(self builder componentAt: #protocol2) widget model		value: prefix , secondProtocolText</body></methods><methods><class-id>Store.MethodDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="compare:with:protocol:with:">compare: text1 with: text2 protocol: text3 with: text4		| instance |	instance := self new.	instance text1 value: text1.	instance text2 value: text2.	instance protocol1 value: text3.	instance protocol2 value: text4.	instance openInterface: #briefSpec</body></methods><methods><class-id>Store.LoadOrSaveActionError class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.LoadOrSaveEvaluationError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog warn: (#_1sErrorEvaluating2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: Error evaluating &lt;2s&gt;'		expandMacrosWith: messageText first 		with: messageText last)</body></methods><methods><class-id>Store.GraphTool</class-id> <category>graph actions</category><body package="Store-UI-Graphs" selector="beGraph">beGraph	| focus |	self graphView bm visualBuilderClass: Lens.LDMGraphBuilder.	focus := self graphView focus value.	self graphView onPerspective: self perspective.	self graphView focus: focus.</body><body package="Store-UI-Graphs" selector="beIndentedList">beIndentedList	self graphView bm visualBuilderClass: IndentedListBuilder</body><body package="Store-UI-Graphs" selector="closeAllIn">closeAllIn	graphView selectionDo: [:e | graphView browserModel body closeAllFrom: e side: 2]</body><body package="Store-UI-Graphs" selector="closeAllOut">closeAllOut	graphView selectionDo: [:e | graphView browserModel body closeAllFrom: e side: 1]</body></methods><methods><class-id>Store.GraphTool</class-id> <category>menu enabling</category><body package="Store-UI-Graphs" selector="makePundleMenuDynamic:">makePundleMenuDynamic: menu  	super makePundleMenuDynamic: menu.	self makeDynamicItem: #openOneOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openOneIn selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #closeOneOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #closeOneIn selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #open4Out selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #open4In selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openAllOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openAllIn selectionBlock: [self nonEmptySelection] inMenu: menu.	^menu</body></methods><methods><class-id>Store.GraphTool</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="focus:">focus: aFocus	self graphView focus: aFocus</body><body package="Store-UI-Graphs" selector="graphView">graphView	""	^graphView isNil		ifTrue:			[graphView := LensGraphView onPerspective: self perspective]		ifFalse:			[graphView]</body></methods><methods><class-id>Store.GraphTool</class-id> <category>selection</category><body package="Store-UI-Graphs" selector="nonEmptySelection">nonEmptySelection	self graphView selectionDo: [:sel | ^true].	^false</body><body package="Store-UI-Graphs" selector="pundles">pundles	| sels |	sels := List new.	self graphView selectionDo: [:each | sels add: each element].	^sels</body><body package="Store-UI-Graphs" selector="pundleVersions">pundleVersions	| sels |	sels := List new.	self graphView selectionDo: [:each | sels add: each element].	^sels</body><body package="Store-UI-Graphs" selector="selectPundle:">selectPundle: aPundle	self needsMoreWork. "due to element proxy"	self graphView select: aPundle</body></methods><methods><class-id>Store.GraphTool</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="closeIn">closeIn	self graphView closeIn</body><body package="Store-UI-Graphs" selector="closeOut">closeOut	self graphView closeIn</body><body package="Store-UI-Graphs" selector="open4In">open4In	self graphView open4In</body><body package="Store-UI-Graphs" selector="open4Out">open4Out	self graphView open4Out</body><body package="Store-UI-Graphs" selector="openAllIn">openAllIn	self graphView openInLevels: 0</body><body package="Store-UI-Graphs" selector="openAllOut">openAllOut	self graphView openOutLevels: 0</body><body package="Store-UI-Graphs" selector="openOneIn">openOneIn	self graphView   openInLevels: 1</body><body package="Store-UI-Graphs" selector="openOneOut">openOneOut	self graphView  openOutLevels: 1</body><body package="Store-UI-Graphs" selector="updatePundleContents">updatePundleContents	"Reconstructs the entire graph"	self graphView focus: self graphView focus value</body><body package="Store-UI-Graphs" selector="updatePundleVersion">updatePundleVersion	"Updates the visual representation of each graph element, but no 	elements are added to or removed from the graph."	(self graphView bm body) releaseVisuals; rebuild</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	| focus |	pundle isNil ifFalse: 		[aBuilder window label: ((#VersionsOf1s &lt;&lt; #store &gt;&gt; 'Versions of &lt;1s&gt;') expandMacrosWith: pundle name)].	focus := self graphView focus value asArray.	focus size = 1 ifTrue: [self graphView select: focus first]</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="perspective">perspective	^#tt_derives</body><body package="Store-UI-Graphs" selector="pundle">pundle	^pundle</body><body package="Store-UI-Graphs" selector="pundle:">pundle: aPundle	pundle := aPundle</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="loadInitialVersions">loadInitialVersions	| punSet cache focus |	punSet := Set new.	(pundle isLoaded or: [pundle primaryKey notNil]) 		ifTrue: [punSet add: pundle]		ifFalse: 			[| list |			list := pundle allVersionsWithName: pundle name.			list isEmpty 				ifTrue: 					[Dialog warn: ((#ThereAreNoPublishedVersionsOf1s &lt;&lt; #store &gt;&gt; 'There are no published versions of &lt;1s&gt;.') 								expandMacrosWith: self pundle name).					^false].			punSet add: list last.			list 				do: [:each | (each dbTrace = 0 or: [each dbTrace isNil]) ifTrue: [punSet add: each]]].	cache := Dictionary new.	focus := punSet collect: [:pun | ElementProxy element: pun cache: cache].	self graphView focus: focus.	^true</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="listBundleContents">listBundleContents	[Store.Glorp.DefinitionForListTool forBundleContents: pundle] withStoreFeedbackOn: self mainWindow.</body><body package="Store-UI-Graphs" selector="reloadVersions">reloadVersions		| imagePundle |	(pundle isLoaded and: [pundle isImageModel]) ifTrue:		[imagePundle := pundle isBundle 			ifTrue: [Registry bundleNamed: pundle name] 			ifFalse: [Registry packageNamed: pundle name].		imagePundle isNil ifTrue:			[(imagePundle := imagePundle newestVersionWithName: pundle name) ifNil:				[^Dialog warn: (#_1sDoesNotExist &lt;&lt; #store &gt;&gt; '&lt;1s&gt; does not exist' expandMacrosWith: pundle name)]].		self pundle: imagePundle].	self loadInitialVersions</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>instance creation</category><body package="Store-UI-Graphs" selector="browseVersionsOfPundle:">browseVersionsOfPundle: aPundle 	DbRegistry doIfOnlineImage: 		[| preferredPresentation |		preferredPresentation := StoreSettings preferenceFor: #versionManagerView.		Cursor wait showWhile: 			[| graph |			graph := self new.			graph pundle: aPundle.			graph loadInitialVersions ifFalse: [^self].			preferredPresentation = #indentedPresentation ifTrue: [graph beIndentedList].			self openOn: graph]]</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs" selector="initializePerspectives">initializePerspectives	"TT_VersionGraph initializePerspectives"	^(List new) add: ((Array new: 9)			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: #(						#(#F1 #V1 'tt_derives' true false false false false) 						#(#V2 #F1 'tt_derives' true false false false false) 						#(#V1 #V1 'tt_derives' false false true false false)					);			at: 4 put: #arrLabelHints:;			at: 5 put: #(#blessing);			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_derives';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue blue;					at: 5 put: 1; yourself); yourself);			at: 8 put: #name:;			at: 9 put: #tt_derives; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs" selector="initializeRelationships">initializeRelationships	"self initializeRelationships"	^(List new) add: #(#LDMFirstOrderRel #name: 'tt_derives' #description: 'derives' #reverse: nil #token: #tt_derivesRel) decodeAsLiteralArray; add: #(#LDMFirstOrderRel #name: 'tt_derivesR' #description: 'derivesR' #reverse: nil #token: #tt_derivesRRel) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="collapsedIndicator">collapsedIndicator	^self indicatorNormal: ComparisonIcons collapsed		focused: ComparisonIcons focusCollapsed</body><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	^Array new</body><body package="Store-Code Comparison" selector="detailsPanel">detailsPanel	^self children last</body><body package="Store-Code Comparison" selector="disclosureButton">disclosureButton	"Manufacture a button to be used to indicate the expanded/collapsed status of the reasons."	| disclosure |	disclosure := Refactory.Browser.ClickableGraphic new.	disclosure idleGraphic: (self isExpanded				ifTrue: [self expandedIndicator]				ifFalse: [self collapsedIndicator]).	disclosure mouseDownGraphic: self transitionIndicator.	disclosure when: Refactory.Browser.Clicked send: #disclosureClicked to: self.	^disclosure</body><body package="Store-Code Comparison" selector="disclosureButtonSpace">disclosureButtonSpace	^PixelSpace width: 12</body><body package="Store-Code Comparison" selector="expandedIndicator">expandedIndicator	^self indicatorNormal: ComparisonIcons expanded		focused: ComparisonIcons focusExpanded</body><body package="Store-Code Comparison" selector="header">header	^self children first</body><body package="Store-Code Comparison" selector="indicatorNormal:focused:">indicatorNormal: aNormalGraphic focused: aFocusedGraphic	^VisualBlock block: 			[:gc :box |			(self hasFocus ifTrue: [aFocusedGraphic] ifFalse: [aNormalGraphic])				displayOn: gc				at: Point zero]		extent: aNormalGraphic image extent</body><body package="Store-Code Comparison" selector="moreInfoTooltipHandle">moreInfoTooltipHandle	| tooltipProvider |	tooltipProvider := ClickableGraphic new.	tooltipProvider idleGraphic: ComparisonIcons moreInfoHandle.	tooltipProvider tooltip: [self infoTooltipText].	^tooltipProvider</body><body package="Store-Code Comparison" selector="newRow">newRow	^Panel new beRow: 0.5 gap: 4</body><body package="Store-Code Comparison" selector="populate">populate	"This is the primary point of fleshing out the receiver, once its instance variable state has been filled out. Note that we don't bother populating the subrows unless they have set us to be expanded already."	self populateHeader.	self detailsPanel releaseAllComponents.	self isExpanded ifTrue: [self populateDetails]</body><body package="Store-Code Comparison" selector="populateDetails">populateDetails	"Called when we expand for the first time, simply concatonate the sections and throw them in the subrows."	(self detailsPanel)		releaseAllComponents;		addAll: self computeDetailRows</body><body package="Store-Code Comparison" selector="populateDetailsIfNecessary">populateDetailsIfNecessary	self detailsPanel children isEmpty ifTrue: [self populateDetails]</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	self header releaseAllComponents.	self header add: self disclosureButton</body><body package="Store-Code Comparison" selector="transitionIndicator">transitionIndicator	^self indicatorNormal: ComparisonIcons transition		focused: ComparisonIcons focusTransition</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="beExpanded">beExpanded	self expansionChangeBeginning.	expandedFraction := 1.	self expansionChangeFinished</body><body package="Store-Code Comparison" selector="initDetailsPanel">initDetailsPanel	| details |	details := Panel new.	details beFullColumn.	self add: details</body><body package="Store-Code Comparison" selector="initHeader">initHeader	"The header row is the first subpart, and is a vertically centererd row with spacing of 2."	| headerRow |	headerRow := self newRow.	self add: headerRow</body><body package="Store-Code Comparison" selector="initialize">initialize	super initialize.	expandedFraction := 0.	self initHeader.	self initDetailsPanel</body><body package="Store-Code Comparison" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	self layoutAlgorithm: 			[:rect :children |			| rolledBottom rolledLeft rolledHeight headerBox details |			headerBox := rect origin extent: children first preferredExtent.			details := children last.			rolledHeight := details preferredHeight.			rolledLeft := rect left + self indent.			rolledBottom := headerBox bottom + (expandedFraction * rolledHeight).			Array with: headerBox				with: (Rectangle						left: rolledLeft						right: rect right - 5						top: headerBox bottom						bottom: rolledBottom)]</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>private</category><body package="Store-Code Comparison" selector="anticipateNewDisclosureButtonLabel">anticipateNewDisclosureButtonLabel	| button |	button := self header children first.	button idleGraphic: (self isExpanded				ifTrue: [self collapsedIndicator]				ifFalse: [self expandedIndicator])</body><body package="Store-Code Comparison" selector="changeExpandedFractionTo:">changeExpandedFractionTo: aFraction	expandedFraction := aFraction.	self relayout.	self invalidateNow</body><body package="Store-Code Comparison" selector="collapseDetails">collapseDetails	self isExpanded ifTrue: [self toggleExpansion]</body><body package="Store-Code Comparison" selector="cycleThruChanges:">cycleThruChanges: anEvent	| target |	target := anEvent hasShift				ifTrue: 					["previous"					self previousSibling ifNil: [self parentRollup]]				ifFalse: 					["next"					self firstExpandedRollupChild						ifNil: [self nextSibling ifNil: [self parentRollup ifNotNil: #nextSibling]]].target ifNil: [^self].	target parentRollup == self ifFalse: [self collapseDetails].	self parentRollup		ifNotNil: [:nextUp | nextUp = target parentRollup ifFalse: [nextUp collapseDetails]].	target expandDetails.	target takeKeyboardFocus</body><body package="Store-Code Comparison" selector="disclosureClicked">disclosureClicked	| viewsToToggle |	viewsToToggle := InputState default shiftDown				ifTrue: 					[InputState default altDown						ifTrue: [self sameExpansionCousinRollups]						ifFalse: [self sameExpansionSiblingRollups]]				ifFalse: [Array with: self].	self toggleExpansions: viewsToToggle.	self takeKeyboardFocus</body><body package="Store-Code Comparison" selector="expandDetails">expandDetails	self isExpanded ifFalse: [self toggleExpansion]</body><body package="Store-Code Comparison" selector="expansionChangeBeginning">expansionChangeBeginning	self populateDetailsIfNecessary.	self anticipateNewDisclosureButtonLabel</body><body package="Store-Code Comparison" selector="expansionChangeFinished">expansionChangeFinished</body><body package="Store-Code Comparison" selector="firstExpandedRollupChild">firstExpandedRollupChild	self isExpanded ifFalse: [^nil].	self rollupChildrenDo: [:each | ^each].	^nil</body><body package="Store-Code Comparison" selector="focusNext">focusNext	self firstExpandedRollupChild		ifNotNil: #takeKeyboardFocus		ifNil: 			[self nextSibling				ifNotNil: #takeKeyboardFocus				ifNil: 					[(self parentRollup ifNotNil: #nextSibling) ifNotNil: #takeKeyboardFocus]]</body><body package="Store-Code Comparison" selector="focusPrevious">focusPrevious	| neighbor closer |	neighbor := self previousSibling				ifNil: [^self parentRollup ifNotNil: #takeKeyboardFocus].	[(closer := neighbor lastExpandedRollupChild) notNil]		whileTrue: [neighbor := closer].	neighbor takeKeyboardFocus</body><body package="Store-Code Comparison" selector="indent">indent		^Refactory.Browser.PrerequisiteIcons expanded width * 2</body><body package="Store-Code Comparison" selector="lastExpandedRollupChild">lastExpandedRollupChild	| last |	self isExpanded ifFalse: [^nil].	last := nil.	self rollupChildrenDo: [:each | last := each].	^last</body><body package="Store-Code Comparison" selector="makeVisible">makeVisible	| scroller scrollerBox myBox |	scroller := self findParent: [:each | each isKindOf: ScrollWrapper].	scroller ifNil: [^self].	scroller topComponent ifNotNil: #repairDamages.	scrollerBox := scroller bounds.	scrollerBox		moveTo: (scroller parent localPointToGlobal: scrollerBox origin).	"we don't want to be translated to the scroller scrolled out origin, so ask his parent to do the translation"	myBox := self bounds.	myBox moveTo: (self localPointToGlobal: myBox origin).	(myBox top &gt;= scrollerBox top and: [myBox bottom &lt;= scrollerBox bottom])		ifTrue: [^self].	myBox top &lt; scrollerBox top		ifTrue: [^scroller scrollBy: 0 @ (myBox top - scrollerBox top)].	scroller scrollBy: 0				@ (myBox bottom - scrollerBox bottom min: myBox top - scrollerBox top)</body><body package="Store-Code Comparison" selector="nextSibling">nextSibling	| found |	found := false.	self parent childrenDo: 			[:each |			(found and: [each isKindOf: AbstractComparisonRollupView]) ifTrue: [^each].			found := each == self].	^nil</body><body package="Store-Code Comparison" selector="parentRollup">parentRollup	^self		findParent: [:candidate | candidate isKindOf: AbstractComparisonRollupView]</body><body package="Store-Code Comparison" selector="previousSibling">previousSibling	| previous |	previous := nil.	self parent childrenDo: 			[:each |			each == self ifTrue: [^previous].			(each isKindOf: AbstractComparisonRollupView) ifTrue: [previous := each]].	^nil</body><body package="Store-Code Comparison" selector="rollupChildrenDo:">rollupChildrenDo: aBlock	self detailsPanel childrenDo: 			[:candidate |			(candidate isKindOf: AbstractComparisonRollupView)				ifTrue: [aBlock value: candidate]]</body><body package="Store-Code Comparison" selector="sameExpansionCousinRollups">sameExpansionCousinRollups	| visibleCousins |	visibleCousins := OrderedCollection new.	self parentRollup ifNil: [^self sameExpansionSiblingRollups].	self parentRollup siblingRollups do: 			[:uncleRollup |			uncleRollup isExpanded				ifTrue: 					[uncleRollup rollupChildrenDo: 							[:each |							each isExpanded = self isExpanded ifTrue: [visibleCousins add: each]]]].	^visibleCousins</body><body package="Store-Code Comparison" selector="sameExpansionSiblingRollups">sameExpansionSiblingRollups	^self siblingRollups select: [:each | each isExpanded = self isExpanded]</body><body package="Store-Code Comparison" selector="siblingRollups">siblingRollups	^self parent children		select: [:each | each isKindOf: AbstractComparisonRollupView]</body><body package="Store-Code Comparison" selector="toggleExpansion">toggleExpansion	self toggleExpansions: (Array with: self)</body><body package="Store-Code Comparison" selector="toggleExpansions:">toggleExpansions: aSequenceLikeSelf	"When the expandedFraction changes, move through a range of expandedFractions to arrive at the final value, this gives some animation effect to the rollup/rolldown. IF we're on a slow computer though, do at most two updates (the first and last)."	| start steps hurry limit |	start := Time microsecondClock.	aSequenceLikeSelf do: #expansionChangeBeginning.	steps := expandedFraction isZero				ifTrue: [#(0.5 0.75 0.875 0.9125 1)]				ifFalse: [#(0.5 0.25 0.125 0.0625 0)].	aSequenceLikeSelf size &gt; 3 ifTrue: [steps := steps last: 1].	limit := 50 milliseconds.	hurry := (Time microsecondClock - start) microseconds &gt; limit.	steps do: 			[:each |			(hurry not or: [each isInteger])				ifTrue: 					[aSequenceLikeSelf do: [:view | view changeExpandedFractionTo: each].					hurry := (Time microsecondClock - start) microseconds &gt; limit]].	aSequenceLikeSelf do: #expansionChangeFinished</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>testing</category><body package="Store-Code Comparison" selector="hasFocus">hasFocus	^self topComponent		ifNil: [false]		ifNotNil: 			[:window |			window hasFocus and: [window keyboardProcessor currentConsumer == self]]</body><body package="Store-Code Comparison" selector="hasMenu">hasMenu	^false</body><body package="Store-Code Comparison" selector="isExpanded">isExpanded		^expandedFraction = 1</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="preferredHeight">preferredHeight	^self header preferredHeight		+ (self detailsPanel preferredHeight * expandedFraction)</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>displaying</category><body package="Store-Code Comparison" selector="displayChild:on:">displayChild: aChild on: aGC	| drawDecoration oldPaint detailGC |	oldPaint := aGC paint.	(aChild == self header and: [self hasFocus])		ifTrue: [self displayHeaderFocusOn: aGC].	drawDecoration := self isExpanded and: [aChild == self detailsPanel].	detailGC := aGC copy.	drawDecoration ifTrue: [self drawDetailsBackroundOn: detailGC].	super displayChild: aChild on: detailGC.	drawDecoration ifTrue: [self drawDetailsBorderOn: detailGC].	aGC paint: oldPaint</body><body package="Store-Code Comparison" selector="displayHeaderFocusOn:">displayHeaderFocusOn: aGC	aGC		paint: SymbolicPaint selectionBackground;		displayPolygon: (self roundedRectangle: (self header frame origin							corner: self header frame corner - 1)).	aGC paint: SymbolicPaint selectionForeground</body><body package="Store-Code Comparison" selector="drawDetailsBackroundOn:">drawDetailsBackroundOn: aGC	| frame poly oldPaint preferences |	oldPaint := aGC paint.	preferences := LookPreferences new.	preferences		setBackgroundColor: (ColorValue red: 0.9 green: 0.9 blue: 0.93).	aGC overridePaintPreferencesWith: preferences for: self.	aGC paint: SymbolicPaint background.	self detailsPanel childrenDo: 			[:row |			frame := row frame.			frame := (frame topLeft rounded corner: frame bottomRight rounded - 1)						translatedBy: self detailsPanel frame origin.			poly := self roundedRectangle: frame.			aGC displayPolygon: poly].	aGC paint: oldPaint</body><body package="Store-Code Comparison" selector="drawDetailsBorderOn:">drawDetailsBorderOn: aGC	| frame |	self detailsPanel childrenDo: 			[:row |			frame := row frame translatedBy: self detailsPanel frame origin.			frame := frame topLeft rounded corner: frame bottomRight rounded - 1.			aGC				paint: ColorValue darkGray;				displayPolyline: (self roundedRectangle: frame)]</body><body package="Store-Code Comparison" selector="roundedRectangle:">roundedRectangle: aRectangle	| ws |	ws := Array new writeStream.	ws		nextPut: (aRectangle topLeft downBy: 3);		nextPut: (aRectangle topLeft rightBy: 3);		nextPut: (aRectangle topRight leftBy: 3);		nextPut: (aRectangle topRight downBy: 3);		nextPut: (aRectangle bottomRight upBy: 3);		nextPut: (aRectangle bottomRight leftBy: 3);		nextPut: (aRectangle bottomLeft rightBy: 3);		nextPut: (aRectangle bottomLeft upBy: 3);		nextPut: (aRectangle topLeft downBy: 3).	^ws contents</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>utility</category><body package="Store-Code Comparison" selector="italicizedText:">italicizedText: aCharacteryArray	"We add the space, because our current width measuring code computes a width that 'chops' off the top right of the last character"	^aCharacteryArray asText , ' ' emphasizeAllWith: #italic</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>event driven</category><body package="Store-Code Comparison" selector="getEventHandler">getEventHandler	^self</body><body package="Store-Code Comparison" selector="handleEvent:">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-Code Comparison" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	aMouseEvent isMouseWheelEvent ifTrue: [^nil].	(self containsMouseEvent: aMouseEvent) ifFalse: [^nil].	^(super handlerForMouseEvent: aMouseEvent)		ifNil: 			[(aMouseEvent anyButtonPressed				and: [self header containsMouseEvent: aMouseEvent])					ifTrue: [self]					ifFalse: [nil]]</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>keyboard focus protocol</category><body package="Store-Code Comparison" selector="activate">activate	self invalidate</body><body package="Store-Code Comparison" selector="controller">controller	^self</body><body package="Store-Code Comparison" selector="deactivate">deactivate	self invalidate</body><body package="Store-Code Comparison" selector="desiresFocus">desiresFocus	^true</body><body package="Store-Code Comparison" selector="hasControl">hasControl	self header invalidate</body><body package="Store-Code Comparison" selector="requestFocusIn">requestFocusIn	^true</body><body package="Store-Code Comparison" selector="requestFocusOut">requestFocusOut	^true</body><body package="Store-Code Comparison" selector="takeKeyboardFocus">takeKeyboardFocus	self keyboardProcessor		ifNotNil: [:keyboardProcessor | keyboardProcessor requestActivationFor: self].	self makeVisible</body><body package="Store-Code Comparison" selector="view">view	^self</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="menu">menu		| menu |	menu := Menu new.	menu		augmentFrom: self class		to: AbstractComparisonRollupView		menuName: #menu		for: self.	^menu</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>menu-methods</category><body package="Store-Code Comparison" selector="browseImageMethod:">browseImageMethod: aMethodDefinition	(Refactory.Browser.MethodDefinitionEnvironment		onMethods: (Array with: aMethodDefinition)) openEditor</body><body package="Store-Code Comparison" selector="browseStoreMethod:">browseStoreMethod: aStoreMethodInPackage	| storeInstanceBehavior storeClass |	storeInstanceBehavior := aStoreMethodInPackage classOrNameSpace.	storeClass := aStoreMethodInPackage definition isMetaclass				ifTrue: [storeInstanceBehavior storeMetaClass]				ifFalse: [storeInstanceBehavior].	((Store.Glorp.StoreMethodDefinitionEnvironment new)		environment: (Store.Glorp.StoreForGlorpBrowserEnvironment					on: aStoreMethodInPackage package);		addClass: storeClass selector: aStoreMethodInPackage selector) openEditor</body><body package="Store-Code Comparison" selector="imageMethodDefinitionFrom:">imageMethodDefinitionFrom: aMethodBlueprint	| classReference binding behavior |	classReference := aMethodBlueprint classReference.	classReference ifNil: [^nil].	binding := classReference bindingOrNil.	binding ifNil: [^nil].	binding isForClass ifFalse: [^nil].	behavior := binding value.	aMethodBlueprint isInstanceBehavior		ifFalse: [behavior := behavior classBehavior].	^(behavior includesSelector: aMethodBlueprint selector)		ifTrue: [MethodDefinition class: behavior selector: aMethodBlueprint selector]		ifFalse: [nil]</body><body package="Store-Code Comparison" selector="loadMethod:">loadMethod: aStoreMethodInPackage	aStoreMethodInPackage loadSource</body><body package="Store-Code Comparison" selector="openMethodVersions:">openMethodVersions: aCollectionOfStoreMethod	| tool listPart |	tool := Store.Glorp.DefinitionForListTool new.	listPart := Store.Glorp.MethodVersionsListPane new.	listPart tool: tool.	listPart fillInFor: aCollectionOfStoreMethod any.	tool listPart: listPart.	tool open.	listPart itemsInList selections: aCollectionOfStoreMethod</body><body package="Store-Code Comparison" selector="storeObjectVersionLabel:">storeObjectVersionLabel: aStoreObjectInPackage	| ws |	ws := String new writeStream.	ws policy dateAndTimePolicy		printShort: aStoreObjectInPackage definition localTimestamp		on: ws.	^'(&lt;1s&gt;, &lt;2s&gt;, &lt;3s&gt;)'		expandMacrosWith: aStoreObjectInPackage package version		with: aStoreObjectInPackage definition username		with: ws contents</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison" selector="infoTooltipText">infoTooltipText	| output notEmptyChunks |	notEmptyChunks := self tooltipTextChunks reject: #isEmpty.	notEmptyChunks isEmpty ifTrue: [^nil].	output := TextStream on: String new.	notEmptyChunks do: [:each | output nextPutAllText: each]		separatedBy: [output cr].	^output contents</body><body package="Store-Code Comparison" selector="tooltipTextChunks">tooltipTextChunks	^Array new</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="childrenExpansionMemoryKey:">childrenExpansionMemoryKey: anArray	^(Array with: #chidlrenOf) , anArray</body><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	"Return an indirect object that can be used to remember a view looking at the same sort of thing."	^nil</body><body package="Store-Code Comparison" selector="forgetIfCollapsedIn:">forgetIfCollapsedIn: aDictionary	| myKey |	myKey := self expansionMemoryKey.	self isExpanded ifFalse: [aDictionary removeKey: myKey ifAbsent: []].	aDictionary at: (self childrenExpansionMemoryKey: myKey)		ifPresent: 			[:subDictionary |			self rollupChildrenDo: [:each | each forgetIfCollapsedIn: subDictionary]]</body><body package="Store-Code Comparison" selector="rememberIfExpandedIn:">rememberIfExpandedIn: aDictionary	| myKey subDictionary |	myKey := self expansionMemoryKey.	self isExpanded ifTrue: [aDictionary at: myKey put: 0].	subDictionary := nil.	self rollupChildrenDo: 			[:each |			each rememberIfExpandedIn: (subDictionary						ifNil: [subDictionary := Dictionary new])].	(subDictionary isNil or: [subDictionary isEmpty])		ifFalse: 			[aDictionary at: (self childrenExpansionMemoryKey: myKey) put: subDictionary]</body><body package="Store-Code Comparison" selector="restoreExpandedIn:">restoreExpandedIn: aDictionary	| myKey |	myKey := self expansionMemoryKey.	(aDictionary includesKey: myKey) ifTrue: [self beExpanded].	aDictionary at: (self childrenExpansionMemoryKey: myKey)		ifPresent: 			[:subDictionary |			self populateDetailsIfNecessary.			self rollupChildrenDo: [:each | each restoreExpandedIn: subDictionary]]</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>displaying</category><body package="Store-Code Comparison" selector="drawDetailsBackroundOn:">drawDetailsBackroundOn: aGC	"not for me"</body><body package="Store-Code Comparison" selector="drawDetailsBorderOn:">drawDetailsBorderOn: aGC	"not for me"</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison" selector="bindingDetailIcon:">bindingDetailIcon: aSelector	^ComparisonIcons		perform: (#(#modifyClassAttributes #modifyBehaviorType #modifyClassInstanceVariables #modifyComment #modifyImports #modifyInstanceVariables #modifyIsPrivate #movePackage #modifySuperclass #moveCategory #modify #modifyIsConstant)				at: (#(#attributes #behaviorType #classInstanceVariables #comment #importsString #instanceVariables #isPrivate #packageName #superclassReference #category #initializer #isConstant)						indexOf: aSelector))</body><body package="Store-Code Comparison" selector="bindingDetailSelectors">bindingDetailSelectors	^self singularBlueprint bindingDetailSelectors sort</body><body package="Store-Code Comparison" selector="bindingTest">bindingTest	^self subclassResponsibility</body><body package="Store-Code Comparison" selector="enumerateBindingDetailChanges:">enumerateBindingDetailChanges: aBlock	| selector |	(leftBlueprint isNil or: [rightBlueprint isNil]) ifTrue: [^self].	self bindingDetailSelectors sorted do: 			[:name |			selector := name asSymbol.			(leftBlueprint perform: selector) = (rightBlueprint perform: selector)				ifFalse: [aBlock value: selector]]</body><body package="Store-Code Comparison" selector="expansionChangeFinished">expansionChangeFinished	super expansionChangeFinished.	self isExpanded		ifTrue: [self removeHeaderDetailHints]		ifFalse: [self addDetailHints]</body><body package="Store-Code Comparison" selector="imageReferenceFrom:">imageReferenceFrom: aBindingBlueprint	| bindingReference binding |	bindingReference := aBindingBlueprint ifNotNil: #reference.	bindingReference ifNil: [^nil].	binding := bindingReference bindingOrNil.	binding ifNil: [^nil].	^(binding perform: self bindingTest)		ifTrue: [bindingReference]		ifFalse: [nil]</body><body package="Store-Code Comparison" selector="leftImageReference">leftImageReference	^self imageReferenceFrom: leftBlueprint</body><body package="Store-Code Comparison" selector="leftStoreObject">leftStoreObject	^leftBlueprint ifNotNil: #originalStoreObject</body><body package="Store-Code Comparison" selector="liveObject">liveObject	^self objectReference		ifNotNil: [:reference | reference bindingOrNil ifNotNil: #value]</body><body package="Store-Code Comparison" selector="objectHeaderName">objectHeaderName	^self objectReference path last</body><body package="Store-Code Comparison" selector="objectHeaderText">objectHeaderText	| text |	text := self objectHeaderName asText allBold.	self isAddition		ifTrue: 			[text				addEmphasis: (Array with: #color -&gt; (ColorValue red: 0 green: 0.6 blue: 0))				removeEmphasis: #()				allowDuplicates: false				from: 1				to: text size].	self isRemoval		ifTrue: 			[text				addEmphasis: (Array with: #color -&gt; ColorValue red)				removeEmphasis: #()				allowDuplicates: false				from: 1				to: text size].	^text</body><body package="Store-Code Comparison" selector="rightImageReference">rightImageReference	^self imageReferenceFrom: rightBlueprint</body><body package="Store-Code Comparison" selector="rightStoreObject">rightStoreObject	^rightBlueprint ifNotNil: #originalStoreObject</body><body package="Store-Code Comparison" selector="singularBlueprint">singularBlueprint	^leftBlueprint ifNil: [rightBlueprint]</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>testing</category><body package="Store-Code Comparison" selector="browseInHierarchy">browseInHierarchy	^false</body><body package="Store-Code Comparison" selector="hasMenu">hasMenu	^true</body><body package="Store-Code Comparison" selector="hasSameImageObject">hasSameImageObject	^self leftImageReference		ifNil: [self rightImageReference notNil]		ifNotNil: 			[:left |			self rightImageReference ifNil: [true] ifNotNil: [:right | left = right]]</body><body package="Store-Code Comparison" selector="isAddition">isAddition	^leftBlueprint isNil and: [rightBlueprint notNil]</body><body package="Store-Code Comparison" selector="isChange">isChange	^(self isAddition or: [self isRemoval]) not</body><body package="Store-Code Comparison" selector="isRemoval">isRemoval	^rightBlueprint isNil and: [leftBlueprint notNil]</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="addDetailHints">addDetailHints	| detailsAtAGlance icons |	icons := self detailHintGraphics.	icons isEmpty ifTrue: [^self].	detailsAtAGlance := Panel new beRow: 0.5.	detailsAtAGlance propertyAt: #id put: #detailHints.	detailsAtAGlance add: '('.	icons do: [:each | detailsAtAGlance add: each]		separatedBy: [detailsAtAGlance add: ','].	detailsAtAGlance add: ')'.	self header updateFramesAfter: 			[self header children add: detailsAtAGlance				before: self header children last]</body><body package="Store-Code Comparison" selector="annotateIconWithDisposition:">annotateIconWithDisposition: aBaseGraphic	self isAddition ifTrue: [^VisualStack with: aBaseGraphic with: ComparisonIcons addedBindingOverlay].	self isRemoval ifTrue: [^VisualStack with: aBaseGraphic with: ComparisonIcons removedBindingOverlay].	^aBaseGraphic</body><body package="Store-Code Comparison" selector="changedBindingDetailRows">changedBindingDetailRows	| rows classDetailRowSelector |	rows := OrderedCollection new.	self enumerateBindingDetailChanges: 			[:selector |			classDetailRowSelector := (selector , 'ComparisonRow') asSymbol.			rows add: (self perform: classDetailRowSelector)].	^rows</body><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	^self isChange		ifTrue: [self changedBindingDetailRows]		ifFalse: [self uniqueBindingDetailRows]</body><body package="Store-Code Comparison" selector="defaultIcon">defaultIcon	^self subclassResponsibility</body><body package="Store-Code Comparison" selector="detailHintGraphics">detailHintGraphics	| icons |	icons := OrderedCollection new.	self		enumerateBindingDetailChanges: [:selector | icons add: (self bindingDetailIcon: selector)].	^icons</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| headerRow objectIcon label |	super populateHeader.	self objectReference ifNil: [^self].	headerRow := self header.	objectIcon := self liveObject				ifNotNil: #toolListIcon				ifNil: [self defaultIcon].	label := Label with: self objectHeaderText.	headerRow		add: (self annotateIconWithDisposition: objectIcon);		add: label;		add: self moreInfoTooltipHandle.	self isExpanded ifFalse: [self addDetailHints]</body><body package="Store-Code Comparison" selector="removeHeaderDetailHints">removeHeaderDetailHints	self header		removeAll: (self header children select: [:each | (each propertyAt: #id) = #detailHints])</body><body package="Store-Code Comparison" selector="uniqueBindingDetailRows">uniqueBindingDetailRows	^(self bindingDetailSelectors		collect: [:each | self perform: (each , 'SingularRow') asSymbol])			reject: #isNil</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="objectReference">objectReference	^self singularBlueprint ifNotNil: #reference</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="isPrivateComparisonRow">isPrivateComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifyIsPrivate;		add: (self italicizedText: 'Private');		add: 'changed from';		add: leftBlueprint isPrivate toolListIcon;		add: 'to';		add: rightBlueprint isPrivate toolListIcon;		yourself</body><body package="Store-Code Comparison" selector="isPrivateSingularRow">isPrivateSingularRow	^self singularBlueprint isPrivate		ifTrue: 			[(self newRow)				add: self disclosureButtonSpace;				add: (self annotateIconWithDisposition: ComparisonIcons modifyIsPrivate);				add: (self italicizedText: 'Private');				add: self singularBlueprint isPrivate toolListIcon;				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison" selector="packageNameComparisonRow">packageNameComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons movePackage;		add: (self italicizedText: 'Package');		add: 'changed from';		add: leftBlueprint packageName asText allBold;		add: 'to';		add: rightBlueprint packageName asText allBold;		yourself</body><body package="Store-Code Comparison" selector="packageNameSingularRow">packageNameSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons movePackage);		add: (self italicizedText: 'Package');		add: self singularBlueprint packageName asText allBold;		yourself</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison" selector="browseImageObject:">browseImageObject: aBindingReference	| environment state |	environment := Refactory.Browser.BrowserEnvironment new.	state := Refactory.Browser.RefactoringBrowser navigatorStateClass new.	state objectName: aBindingReference.	Refactory.Browser.RefactoringBrowser		openOnEnvironment: environment		state: state		hierarchy: self browseInHierarchy</body><body package="Store-Code Comparison" selector="browseStoreObject:">browseStoreObject: aStoreObjectInPackage	| environment state |	environment := Store.Glorp.StoreForGlorpBrowserEnvironment				on: aStoreObjectInPackage package.	state := Store.Glorp.StoreRefactoringBrowser navigatorStateClass new.	state environment: environment.	state objectName: aStoreObjectInPackage fullName.	Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: environment		state: state		hierarchy: self browseInHierarchy</body><body package="Store-Code Comparison" selector="loadObject:">loadObject: aStoreClass	aStoreClass loadSource</body><body package="Store-Code Comparison" selector="openObjectVersions">openObjectVersions	| selections tool listPart |	selections := Set new.	self rightStoreObject		ifNotNil: [:storeObjectInPackage | selections add: storeObjectInPackage definition].	self leftStoreObject		ifNotNil: [:storeObjectInPackage | selections add: storeObjectInPackage definition].	tool := Store.Glorp.DefinitionForListTool new.	listPart := self versionListPaneClass new.	listPart tool: tool.	listPart fillInFor: selections any.	tool listPart: listPart.	tool open.	listPart itemsInList selections: selections asArray</body><body package="Store-Code Comparison" selector="versionListPaneClass">versionListPaneClass	^self subclassResponsibility</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison" selector="additionalInfoTooltipText">additionalInfoTooltipText	^Text new</body><body package="Store-Code Comparison" selector="definingNamespaceReferences">definingNamespaceReferences	| references |	references := OrderedCollection new.	leftBlueprint		ifNotNil: [:blueprint | references add: (self referenceNamespace: blueprint reference)].	rightBlueprint		ifNotNil: 			[:blueprint |			| rightReference |			rightReference := self referenceNamespace: blueprint reference.			(references includes: rightReference)				ifFalse: [references add: rightReference]].	^references</body><body package="Store-Code Comparison" selector="definingPackageNames">definingPackageNames	| packages |	packages := OrderedCollection new.	leftBlueprint ifNotNil: [:blueprint | packages add: blueprint packageName].	rightBlueprint		ifNotNil: 			[:blueprint |			(packages includes: blueprint packageName)				ifFalse: [packages add: blueprint packageName]].	^packages</body><body package="Store-Code Comparison" selector="namespaceInfoTooltipText">namespaceInfoTooltipText	| output namespaces |	output := TextStream on: String new.	namespaces := self definingNamespaceReferences.	namespaces size = 1		ifTrue: [output nextPutAll: (#NamespaceC &gt;&gt; 'Namespace:' &lt;&lt; #IDE) asString].	namespaces size = 2		ifTrue: [output nextPutAll: (#NamespacesC &gt;&gt; 'Namespaces:' &lt;&lt; #IDE) asString].	namespaces isEmpty ifFalse: [output space].	namespaces do: 			[:each |			output				emphasis: #bold;				nextPutAll: each asSimplestReference asString;				emphasis: nil]		separatedBy: [output nextPut: $/].	^output contents</body><body package="Store-Code Comparison" selector="packageInfoTooltipText">packageInfoTooltipText	| output packages |	output := TextStream on: String new.	packages := self definingPackageNames.	packages size = 1		ifTrue: 			[output nextPutAll: (#DefinitionPackageC &gt;&gt; 'Package:' &lt;&lt; #IDE) asString].	packages size = 2		ifTrue: 			[output nextPutAll: (#DefinitionPackagesC &gt;&gt; 'Packages:' &lt;&lt; #IDE) asString].	packages isEmpty ifFalse: [output space].	packages do: 			[:each |			output				emphasis: #bold;				nextPutAll: each;				emphasis: nil]		separatedBy: [output nextPut: $/].	^output contents</body><body package="Store-Code Comparison" selector="referenceNamespace:">referenceNamespace: aBindingReference	^BindingReference path: (aBindingReference path allButLast: 1)</body><body package="Store-Code Comparison" selector="tooltipTextChunks">tooltipTextChunks	^Array		with: self namespaceInfoTooltipText		with: self packageInfoTooltipText		with: self additionalInfoTooltipText</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^leftBlueprint		ifNotNil: [Array with: self bindingTest with: leftBlueprint reference]		ifNil: 			[rightBlueprint				ifNotNil: [Array with: self bindingTest with: rightBlueprint reference]]</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="leftSharedVariable:rightSharedVariable:">leftSharedVariable: aSharedVariableBlueprint rightSharedVariable: bSharedVariableBlueprint	leftBlueprint := aSharedVariableBlueprint.	rightBlueprint := bSharedVariableBlueprint.	self populate</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="categoryComparisonRow">categoryComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons moveCategory;		add: (self italicizedText: 'Category');		add: 'changed from';		add: leftBlueprint category asText allBold;		add: 'to';		add: rightBlueprint category asText allBold;		yourself</body><body package="Store-Code Comparison" selector="categorySingularRow">categorySingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons moveCategory);		add: (self italicizedText: 'Category');		add: self singularBlueprint category asText allBold;		yourself</body><body package="Store-Code Comparison" selector="initializerComparisonRow">initializerComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modify		name: 'Initializer'		leftText: leftBlueprint initializer		rightText: rightBlueprint initializer</body><body package="Store-Code Comparison" selector="initializerSingularRow">initializerSingularRow	^self singularBlueprint initializer size isZero		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self isAddition						ifTrue: [ComparisonIcons add]						ifFalse: [ComparisonIcons remove])				name: 'Initializer'				text: self singularBlueprint initializer]</body><body package="Store-Code Comparison" selector="isConstantComparisonRow">isConstantComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifyIsConstant;		add: (self italicizedText: 'Constant');		add: 'changed from';		add: leftBlueprint isConstant toolListIcon;		add: 'to';		add: rightBlueprint isConstant toolListIcon;		yourself</body><body package="Store-Code Comparison" selector="isConstantSingularRow">isConstantSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons modifyIsConstant);		add: (self italicizedText: 'Constant');		add: self singularBlueprint isConstant toolListIcon;		yourself</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="defaultIcon">defaultIcon	^BehaviorIcons SharedVariableOverlay</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison" selector="bindingTest">bindingTest	^#isForGeneral</body><body package="Store-Code Comparison" selector="objectHeaderName">objectHeaderName	| parts |	parts := self objectReference path last: 2.	^parts first , '.' , parts last</body></methods><methods><class-id>Tools.SharedVariableBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison" selector="versionListPaneClass">versionListPaneClass	^Store.Glorp.SharedVariableListPane</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentInspectorField</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="isProtected">isProtected	^true</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentInspectorField</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="value:">value: anObject	Dialog warn: (#UpdatingChangingPropertiesNotAllowed &lt;&lt; #store &gt;&gt; 'Updating/Changing properties is not allowed on a Store database object')</body></methods><methods><class-id>Store.LostConnectionError class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="description">description	^(#TheDatabaseConnectionIsLost &lt;&lt; #store &gt;&gt; 'The database connection is lost') asString</body></methods><methods><class-id>Store.InstallUserManagementPolicies</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	^Dialog confirm: #InstallManagementPolicies &lt;&lt; #store &gt;&gt; 'Install management policies?'</body></methods><methods><class-id>Store.InstallUserManagementPolicies</class-id> <category>constants</category><body package="Store-Base" selector="defaultResumeValue">defaultResumeValue	^true</body><body package="Store-Base" selector="defaultReturnValue">defaultReturnValue	^true</body></methods><methods><class-id>Store.InstallUserManagementPolicies class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>copying</category><body package="Store-Database Model" selector="=">= anObject	^self == anObject yourSelf.</body><body package="Store-Database Model" selector="copy">copy	^self glorpCopyIn: IdentityDictionary new.</body><body package="Store-Database Model" selector="glorpCopyIn:">glorpCopyIn: aDictionary	| existing copy |	existing := aDictionary at: self ifAbsent: [nil].	existing isNil ifFalse: [^existing].	copy :=  self shallowCopy.	aDictionary at: self put: copy.	aDictionary at: copy put: copy.	copy postCopyIn: aDictionary.	^copy.</body><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	primaryKey := nil</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>store faking</category><body package="Store-Database Model" selector="statusLineString">statusLineString	^''</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>testing</category><body package="Store-Database Model" selector="belongsToClass">belongsToClass	^false.</body><body package="Store-Database Model" selector="isClass">isClass	^false.</body><body package="StoreForGlorpVWUI" selector="isDataModel">isDataModel	"Is this a Bernstein data model?"	^true</body><body package="Store-Database Model" selector="isForClass">isForClass	^false</body><body package="Store-Database Model" selector="isForClassOrExtension">isForClassOrExtension	^false</body><body package="StoreForGlorpVWUI" selector="isForData">isForData	^false.</body><body package="StoreForGlorpVWUI" selector="isForMethod">isForMethod	^false.</body><body package="Store-Database Model" selector="isForNameSpace">isForNameSpace	^false.</body><body package="Store-Database Model" selector="isForSharedVariable">isForSharedVariable	^false</body><body package="Store-Database Model" selector="isGlorpObject">isGlorpObject	^true</body><body package="Store-Database Model" selector="isImageObject">isImageObject	^false</body><body package="Store-Database Model" selector="isLoaded">isLoaded	^false</body><body package="StoreForGlorpVWUI" selector="isPatched">isPatched	^false</body><body package="Store-Database Model" selector="isStoreDefinitionInPackage">isStoreDefinitionInPackage	^false</body><body package="Store-Database Model" selector="needsComment">needsComment	^false.</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSourceInto:">loadSourceInto: aPackageModelOrNil	"Answer back nil if I failed"	^self loadSrcInto: aPackageModelOrNil</body><body package="Store-Database Model" selector="loadSrcInto:">loadSrcInto: aPackageModelOrNil	"Answer back nil if I failed"	^aPackageModelOrNil isNil		ifTrue: [self loadSource]		ifFalse: [Store.Policies packagePolicy forcePackage: aPackageModelOrNil while: [self loadSource]]</body><body package="Store-Database Model" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: aPackage confirm: aBoolean	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource or #loadSrcInto:).	^self loadSrcInto: aPackage</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="binding">binding	^self</body><body package="StoreForGlorpVWUI" selector="bindingOrNil">bindingOrNil	^self</body><body package="Store-Database Model" selector="currentUsername">currentUsernameself todo.	^'???'</body><body package="Store-Database Model" selector="debugStoreII">debugStoreII	^self class debugStoreII</body><body package="StoreForGlorpVWUI" selector="fullRootName">fullRootName	^self longName</body><body package="Store-Database Model" selector="id">id	^primaryKey</body><body package="Store-Database Model" selector="notifyOfReversionToStore1Object">notifyOfReversionToStore1Object	self debugStoreII ifTrue: [Dialog warn: 'About To Revert To A Store 1 Object'].</body><body package="Store-Database Model" selector="primaryKey">primaryKey	^primaryKey.</body><body package="Store-Database Model" selector="timeStamp">timeStamp	^(Dialect smalltalkAt: #EmTimeStamp) now.</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="timestampOffset">timestampOffset	"Duplicate this here because we might not have the session available"	^2922938387</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>private</category><body package="Store-Database Model" selector="convertVariableNodeToXML:">convertVariableNodeToXML: aParseNode	| environmentName |	environmentName := (aParseNode respondsTo: #name)		ifTrue: [aParseNode name asString]		ifFalse: 			[aParseNode value == nil				ifTrue: ['nil']				ifFalse: 					[aParseNode value isBindingReference						ifTrue: [aParseNode value asString]						ifFalse: [self error: #ExpectedToFindAGlobalReferenceHere &lt;&lt; #store &gt;&gt; 'Expected to find a global reference here']]].	('Smalltalk.#*' match: environmentName) ifTrue: [environmentName := environmentName copyFrom: 'Smalltalk.*' size to: environmentName size].	^environmentName</body><body package="Store-Database Model" selector="privateSetPrimaryKey:">privateSetPrimaryKey: aNumber	primaryKey := aNumber.</body><body package="Store-Database Model" selector="sax:tag:value:">sax: driver tag: tag value: value	driver startElement: tag atts: nil.	driver characters: value.	driver endElement</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>comparing</category><body package="Store-Database Model" selector="identityHash">identityHash	^super identityHash hashMultiply bitXor: self hash</body><body package="Store-Database Model" selector="sameAs:">sameAs: anObject 	^anObject notNil and: [anObject sameAsDBThing: self]</body><body package="Store-Database Model" selector="sameAsDBThing:">sameAsDBThing: anObject	"If primary key is not set then a records have to be indentical."	self primaryKey isNil ifTrue: [^anObject == self].	^anObject primaryKey =  self primaryKey</body><body package="StoreForGlorpVWUI" selector="sameAsImThing:">sameAsImThing: anObject	^self = anObject.</body></methods><methods><class-id>Store.Glorp.StoreObject</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="fullDisplayString">fullDisplayString	^self displayString</body><body package="StoreForGlorpVWUI" selector="toolListDisplayString">toolListDisplayString	^self displayString.</body><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	^self class toolListIcon.</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>accessing</category><body package="Store-Database Model" selector="currentDescriptorSystem">currentDescriptorSystem		^self currentStoreSession system</body><body package="Store-Database Model" selector="currentStoreSession">currentStoreSession		^StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="databaseIdentifier">databaseIdentifier		^self currentStoreSession 		ifNil: [nil]		ifNotNil: [self currentDescriptorSystem databaseIdentifier asString]</body><body package="Store-Database Model" selector="debugStoreII">debugStoreII	^DebugStoreII</body><body package="Store-Database Model" selector="warnIfNewerVersionPublished">warnIfNewerVersionPublished	#{Store.Glorp.StoreObject.WarnIfNewerVersionPublished} value ifNil:		[#{Store.Glorp.StoreObject.WarnIfNewerVersionPublished} binding reinitializeValue].	^WarnIfNewerVersionPublished</body><body package="Store-Database Model" selector="warnIfNewerVersionPublished:">warnIfNewerVersionPublished: aBoolean	WarnIfNewerVersionPublished := aBoolean</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>connecting</category><body package="Store-Database Model" selector="defaultLogin">defaultLogin	^(StoreLogin new)		database: AccessPlatform new;		username: 'test';		password: '';		connectString: 'accessstore'</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>installation</category><body package="Store-Database Model" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy defaultTableSpace</body></methods><methods><class-id>Store.Glorp.StoreObject class</class-id> <category>database utility</category><body package="Store-Database Model" selector="aRecordWithID:">aRecordWithID: anInteger	"The ID is the primary key, answer nil if there is no match"	^self aRecordWithID: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="aRecordWithID:in:">aRecordWithID: anInteger in: aSession	| session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	^session readOneOf: self where: [:each | each primaryKey = anInteger]</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteName">absoluteName	^self longName.</body><body package="Store-Database Model" selector="asString">asString	^self name</body><body package="Store-Database Model" selector="basicComment">basicComment	^nil</body><body package="Store-Database Model" selector="childrenIn:">childrenIn: aSession	| query session |	session := aSession.	query := Query readManyOf: self class where: [:each | each trace primaryKey = self primaryKey].	^session execute: query</body><body package="Store-Database Model" selector="comment">comment	self basicComment yourSelf isNil ifTrue: [^''].	^self basicComment source</body><body package="Store-Database Model" selector="commentOrNil">commentOrNil	self basicComment yourSelf isNil ifTrue: [^nil].	^self basicComment source</body><body package="Store-Database Model" selector="localTimestamp">localTimestamp	^TimeZone default universalToLocal: timestamp</body><body package="Store-Database Model" selector="localTimestamp:">localTimestamp: aTimestamp	timestamp := aTimestamp subtractSeconds: (Dialect timeOffsetFromGMT * 60 * 60).</body><body package="Store-Database Model" selector="name">name	^name</body><body package="Store-Database Model" selector="name:">name: aString	name := aString.</body><body package="Store-Database Model" selector="newVersion">newVersion	| copy |	copy := self copy.	copy previous: self.	^copy</body><body package="Store-Database Model" selector="package">package	"I don't have a package, but because of polymorphic reasons, I want to respond to this just like my 'InPackage' cousins"	^nil</body><body package="Store-Database Model" selector="parent">parent	^self previous.</body><body package="Store-Database Model" selector="parent:">parent: aStoreSourceObject	self previous: aStoreSourceObject.</body><body package="Store-Database Model" selector="previous">previous	^trace</body><body package="Store-Database Model" selector="previous:">previous: aStoreSourceObject 	aStoreSourceObject notNil ifTrue: [aStoreSourceObject yourSelf class = self class ifFalse: [self halt]].	trace := aStoreSourceObject yourSelf.</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	^self definition</body><body package="Store-Database Model" selector="timeStampString">timeStampString	^Locale current printAsTime: self localTimestamp policyNamed: #medium</body><body package="Store-Database Model" selector="timestamp">timestamp	^timestamp</body><body package="Store-Database Model" selector="timestamp:">timestamp: aTimestamp	timestamp := aTimestamp.</body><body package="Store-Database Model" selector="userName">userName	^self username.</body><body package="Store-Database Model" selector="username">username	^username</body><body package="Store-Database Model" selector="username:">username: aBoolean	username := aBoolean.</body><body package="Store-Database Model" selector="version">version	^''.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>printing</category><body package="Store-Database Model" selector="printOn:">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self name ifNil: ['']);		nextPut: $,;		nextPutAll: (self version ifNil: ['']);		nextPut: $)</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>comparing</category><body package="Store-Database Model" selector="sourceMatches:">sourceMatches: aStoreObject	| sourceCode |	sourceCode := aStoreObject isCharacters 		ifTrue: [aStoreObject asString] 		ifFalse: [aStoreObject source].	^self source equalsAcrossPlatforms: sourceCode.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreSourceObject	self name = aStoreSourceObject name ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="unreconcile">unreconcile	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>testing</category><body package="Store-Database Model" selector="isForClass">isForClass	^false</body><body package="Store-Database Model" selector="isPseudo">isPseudo	^false.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>fileIn/Out</category><body package="Store-Database Model" selector="fileOutSourceOn:">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="fullDisplayString">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self longNameFromSmalltalk		with: self timeStampString		with: self username</body><body package="Store-Database Model" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self longName</body><body package="Store-Database Model" selector="longNameWithMetaFromSmalltalk">longNameWithMetaFromSmalltalk	| index startingFromSmalltalk |	index := self classNameWithMeta findString: '.Smalltalk' startingAt: 1.	startingFromSmalltalk := self classNameWithMeta copyFrom: index + 1 to: self classNameWithMeta size.	index isZero ifTrue: [(self classNameWithMeta findString: 'Root' startingAt: 1) isZero ifFalse: [index := 1]].	index isZero ifFalse: [index := startingFromSmalltalk indexOf: $.].	^startingFromSmalltalk copyFrom: index + 1 to: startingFromSmalltalk size</body></methods><methods><class-id>Store.Glorp.StoreSourceObject</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="asShadowedObjectIn:">asShadowedObjectIn: aStorePackage	| instance |	instance := self shadowedObjectClass new.	instance from: self in: aStorePackage.	^instance</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>accessing</category><body package="Store-Database Model" selector="binaryData">binaryData	^self blob binaryData.</body><body package="Store-Database Model" selector="blob">blob	^blob.</body><body package="Store-Database Model" selector="defaultParcelName">defaultParcelName	"This method is used to return a name that can be used in the creation	of a temporary source file (*.pst) when loading a parcel from a Store	database.  Currently only uses [name][primaryKey].pst but will need to	also have some way of identifying the database being accessed since	two different ParcelRecords in two different databases could have the	same name and the same primary key."	self needsMoreWork.	^self name, self primaryKey printString</body><body package="Store-Database Model" selector="privateSetBlob:">privateSetBlob: aStoreBlob	blob := aStoreBlob</body><body package="Store-Database Model" selector="privateSetSource:">privateSetSource: anObject	source := anObject</body><body package="Store-Database Model" selector="source">source	^source</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>comparing</category><body package="Store-Database Model" selector="=">= aStoreParcelRecord	^self reconcilesWith: aStoreParcelRecord.</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreParcelRecord	"Return true if we appear to be the same entry, but potentially in a different database"	aStoreParcelRecord yourSelf isNil ifTrue: [^false].	self name = aStoreParcelRecord name ifFalse: [^false].	self binaryData = aStoreParcelRecord binaryData ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	blob := blob glorpCopyIn: aDictionary.	source := source glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="from:">from: aPackageModel	| instance |	instance := self new.	instance name: aPackageModel name.	^instance</body></methods><methods><class-id>Store.Glorp.StoreParcelRecord class</class-id> <category>accessing</category><body package="Store-Database Model" selector="parcelDirectory">parcelDirectory	"self parcelDirectory"		| directory |	directory := PundleAccess parcelDirectory.	DbRegistry isConnected ifFalse: [^directory].	^self databaseIdentifier		ifNil: [directory]		ifNotNil: [:value | directory := directory construct: (Filename canonicalize: value)]</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="failedInitializations">failedInitializations	^failedInitializations</body><body package="Atomic Compiling and Loading" selector="failedInitializations:">failedInitializations: aCollection	failedInitializations := aCollection</body><body package="Atomic Compiling and Loading" selector="installedEarly:">installedEarly: aBoolean	installedEarly := aBoolean</body><body package="Atomic Compiling and Loading" selector="pundle">pundle	^pundle</body><body package="Atomic Compiling and Loading" selector="pundle:">pundle: anObject	pundle := anObject</body><body package="Atomic Compiling and Loading" selector="results">results	^results</body><body package="Atomic Compiling and Loading" selector="results:">results: anObject	results := anObject</body><body package="Atomic Compiling and Loading" selector="resultsFromParent">resultsFromParent	^nil</body><body package="Atomic Compiling and Loading" selector="root">root	^root</body><body package="Atomic Compiling and Loading" selector="root:">root: anObject	root := anObject</body><body package="Atomic Compiling and Loading" selector="shadowAt:">shadowAt: aPath	^(self root		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="isAtomicallyLoadable">isAtomicallyLoadable	^results allSatisfy: [:each | each isAtomicallyLoadable]</body><body package="Atomic Compiling and Loading" selector="isCompilationResult">isCompilationResult	^true</body><body package="Atomic Compiling and Loading" selector="isFullyLoaded">isFullyLoaded	^results allSatisfy: [:each | each isFullyLoaded].</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>action</category><body package="Atomic Compiling and Loading" selector="addResult:">addResult: aCodeReaderOrBundleOrPackageCompilationResult	results ifNil: [results := OrderedCollection new].	results add: aCodeReaderOrBundleOrPackageCompilationResult</body><body package="Atomic Compiling and Loading" selector="atomicCompileAndInstallWith:">atomicCompileAndInstallWith: aCompilationManager	| pundleCompilerManger result |	pundleCompilerManger := pundle defaultCompileManager root: aCompilationManager root pundle: pundle.	pundleCompilerManger atomicCompileWith: aCompilationManager.	result := (installedEarly or: [self isAtomicallyLoadable or: [AtomicLoader loadFailOption = #load or: [self proceedToLoad]]]) 		ifTrue:			[(Relinking for: pundle) started.			SystemUtils modifySystem: [self install].			self isFullyLoaded ifFalse: [self retryUnloadables].			self retryFailedInitializations.			self pundle storeModel.			(Relinking for: pundle) finished]		ifFalse: [nil].	Registry cleanseModels.	^result</body><body package="Atomic Compiling and Loading" selector="cleanOverridesAndUnloadedParcels">cleanOverridesAndUnloadedParcels	"Why two sends of #cleanseLists? It is a bug that it needs two passes to make sure all empty overrides are cleared out"	results ifNil: [^self].	results do: [:each | each isCodeReader ifTrue: [each isLoaded ifFalse: [Parcel parcelList remove: (Parcel parcelNamed: each parcelName) ifAbsent: [nil]]]].	Override cleanseLists.	Override cleanseLists</body><body package="Atomic Compiling and Loading" selector="compileAndInstall">compileAndInstall	^	[(Loading for: pundle) started.	self atomicCompileAndInstallWith: self.	(Loading for: pundle) finished]			ensure: [self cleanOverridesAndUnloadedParcels]</body><body package="Atomic Compiling and Loading" selector="install">install	(results allSatisfy: [:each | each isAtomicallyLoadable]) ifFalse: [self notYetImplemented].	results do: [:each | 		[each installed ifFalse: [each install]]			on: LoadingActionError			do: 				[:exception | 				failedInitializations add: exception package.				exception resume: true]].	results do: [:each | each finishInstall].</body><body package="Atomic Compiling and Loading" selector="installEarlyAndReInitialize">installEarlyAndReInitialize		SystemUtils modifySystem: [self installWithoutBundlePostLoad].	results do: [:each | each isCodeReader ifFalse: [each markContentsInstalled]].	self retryFailedInitializations.	installedEarly := true.</body><body package="Atomic Compiling and Loading" selector="installEarlyIfNeeded">installEarlyIfNeeded		(self results last basicClasses		allSatisfy: [:eachClass | (eachClass includesBehavior: Scanner) not])		ifTrue: [^self].	self installEarlyAndReInitialize.	self newShadowRoot.</body><body package="Atomic Compiling and Loading" selector="installEarlyWith:">installEarlyWith: aCompilationManagerOrResult	| parentResults |	self installEarlyAndReInitialize.	(parentResults := aCompilationManagerOrResult resultsFromParent) notNil		ifTrue: 			[parentResults do:				[:each |				each installWithoutPostLoad ifNil: [AtomicLoadingError raiseWith: self pundle].				each markContentsInstalled]]		ifFalse: [aCompilationManagerOrResult markContentsInstalled].	self newShadowRoot</body><body package="Atomic Compiling and Loading" selector="installWithoutBundlePostLoad">installWithoutBundlePostLoad	(results allSatisfy: [:each | each isAtomicallyLoadable]) ifFalse: [self notYetImplemented].	results do: [:each | each installedWithoutBundlePostLoad ifFalse: [each installWithoutBundlePostLoad]].</body><body package="Atomic Compiling and Loading" selector="markContentsInstalled">markContentsInstalled	"I do nothing"</body><body package="Atomic Compiling and Loading" selector="markContentsInstalled:">markContentsInstalled: aBoolean	"I do nothing"</body><body package="Atomic Compiling and Loading" selector="mergeDeeplyFrom:">mergeDeeplyFrom: aShadowEnvironment		aShadowEnvironment keys do: 		[:each | 		(root at: each ifAbsent: [nil]) isNil 			ifTrue: [root at: each put: (aShadowEnvironment at: each)] 			ifFalse:[(root at: each) mergeDeeplyFrom: (aShadowEnvironment at: each)]]</body><body package="Atomic Compiling and Loading" selector="newShadowRoot">newShadowRoot		root := ShadowNameSpaceBuilder new createShadowRoot</body><body package="Atomic Compiling and Loading" selector="proceedToLoad">proceedToLoad	^#displayDialog = AtomicLoader loadFailOption		ifTrue: [Dialog confirm: (#LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?')]		ifFalse: [true]</body><body package="Atomic Compiling and Loading" selector="retryFailedInitializations">retryFailedInitializations	| stillFailed |	stillFailed := OrderedCollection new.	failedInitializations do:		[:each |		[each runPostLoad]			on: Error			do: [:exception | stillFailed add: each]].	failedInitializations := failedInitializations select: [:each | stillFailed includes: each]</body><body package="Atomic Compiling and Loading" selector="retryUnloadables">retryUnloadables		(self results reject: [:each | each isCodeReader]) do:		[:each | 		self retryUnloadablesFor: each]</body><body package="Atomic Compiling and Loading" selector="retryUnloadablesFor:">retryUnloadablesFor: aCompilationResult	"A bit of recursion... If the result is for bundle, we recurse in until they are for individual packages"	aCompilationResult isForBundle ifTrue: [^aCompilationResult results do: [:each | self retryUnloadablesFor: each]].	aCompilationResult unloadableDefinitions copy do:		[:each | 		| packageModel |		packageModel := each parameter package			ifNil: [aCompilationResult package storeModel]			ifNotNil: [:value | value storeModel].		([each parameter loadSourceInto: packageModel]			on: Error			do: [:exception | exception return]) ifNotNil:				[:value | 				(each parameter isForMethod and: [each parameter isMeta and: [each parameter selector = #initialize]])					ifTrue: [each parameter correspondingImageClass instanceBehavior postLoad: packageModel].				aCompilationResult unloadableDefinitions remove: each]].	aCompilationResult unloadableDefinitions isEmpty ifTrue: [aCompilationResult pundle storeModel markNotModified]</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitionsForBrowsing">unloadableDefinitionsForBrowsing	"Answer a collection of Unloadable with the package set."	^results inject: OrderedCollection new into: 		[ :collection :res | 		collection addAll: (res unloadableDefinitionsForBrowsing); yourself			].</body></methods><methods><class-id>Store.AtomicCompilationManager</class-id> <category>overrides</category><body package="Atomic Compiling and Loading" selector="setOverriddenForClass:">setOverriddenForClass: anOverridenClass	| workingResults targetResult fullResults |	workingResults := self results reject: [:each | each isCodeReader].	fullResults := OrderedCollection new.	workingResults do: [:each | fullResults addAll: each leafItems].	targetResult := fullResults detect: 		[:each | each hasShadowClassMatching: anOverridenClass actual]		ifNone: [^self].	targetResult overridden add: anOverridenClass.</body><body package="Atomic Compiling and Loading" selector="setOverriddenForMethod:">setOverriddenForMethod: anOverridenMethod 	| workingResults targetResult fullResults |	workingResults := self results reject: [:each | each isCodeReader].	fullResults := OrderedCollection new.	workingResults do: [:each | fullResults addAll: each leafItems].	targetResult := fullResults detect: 		[:each | each hasShadowMethodMatching: anOverridenMethod method]		ifNone: [^self].	targetResult overridden add: anOverridenMethod.</body></methods><methods><class-id>Store.AtomicCompilationManager class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="root:pundle:">root: aShadowNamespace pundle: aPackageOrBundle	^self new		root: aShadowNamespace;		pundle: aPackageOrBundle;		results: OrderedCollection new;		failedInitializations: OrderedCollection new;		installedEarly: false;		yourself</body></methods><methods><class-id>Store.DBObject</class-id> <category>support</category><body package="Store-DB-BaseObjects" selector="broker">broker	^ self class broker</body><body package="Store-DB-BaseObjects" selector="currentUserName">currentUserName	^ self class currentUserName</body><body package="Store-DB-BaseObjects" selector="install">install		self installInDatabase</body><body package="Store-DB-BaseObjects" selector="installInTable">installInTable	self error: #TablesAreNoLongerSupported &lt;&lt; #store &gt;&gt; 'Tables are no longer supported.'</body><body package="Store-DB-BaseObjects" selector="newSQL">newSQL		^ self class newSQL</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	"For consistency"	"Added by Philippe F. Monnet of Andersen Consulting"</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"For consistency"	"Added by Philippe F. Monnet of Andersen Consulting"</body><body package="Store-DB-BaseObjects" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"</body><body package="Store-DB-BaseObjects" selector="processFields">processFields	"Do any necessary data conversions following retrieval"</body><body package="Store-DB-BaseObjects" selector="processString:">processString: aString	^self class processString: aString</body><body package="Store-DB-BaseObjects" selector="unprime">unprime	"Nil out the slots that do not map to table columns"</body></methods><methods><class-id>Store.DBObject</class-id> <category>private-utilities</category><body package="Store-DB-BaseObjects" selector="errorSignals">errorSignals	^ self class errorSignals</body><body package="Store-DB-BaseObjects" selector="insertInDatabase:">insertInDatabase: aColumnArray	self broker process: 			( self newSQL				insertColumnsValues: aColumnArray )		bindInput: self.</body><body package="Store-DB-BaseObjects" selector="installInDatabase">installInDatabase	"Create a corresponding record in the database."	self preDatabaseInstall.	self broker process: self installSqlString bindInput: self.	self postDatabaseInstall.</body><body package="Store-DB-BaseObjects" selector="installSqlString">installSqlString	"Answer a sql command containing all columns."	^ self newSQL		insertColumnsValues: self class columnNamesForQuery.</body><body package="Store-DB-BaseObjects" selector="nextID">nextID	"Check which database and get next sequence number"	^ self broker nextIDForClass: self class</body><body package="Store-DB-BaseObjects" selector="removeFromDatabase">removeFromDatabase	self broker process: 			( self newSQL				delete;				whereSqlString )		 bindInput: self</body></methods><methods><class-id>Store.DBObject</class-id> <category>tt-private</category><body package="Store-DB-BaseObjects" selector="decode:">decode: aByteArray	"Decode anObject that was stored with #encode:"	| stream bos obj |	aByteArray == nil		ifTrue: [ ^nil ].	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	obj := bos next.	bos close.	^obj</body><body package="Store-DB-BaseObjects" selector="encode:">encode: anObject	"Encode anObject and answer a bytearray."		| stream bos |	stream := WriteStream on: ByteArray new.	bos := BinaryObjectStorage onNew: stream.	bos nextPut: anObject.	bos close.	^stream contents</body><body package="Store-DB-BaseObjects" selector="timeStampAsTimestampObject">timeStampAsTimestampObject	"Answer the receiver's timestamp as a Timestamp, rather than an integer."	| utcSeconds localSeconds |	self timeStamp isNil ifTrue: [^nil].	utcSeconds := self timeStamp + self class timeOffset.	localSeconds := TimeZone default convertGMTSecondsToLocal: utcSeconds.	^Timestamp fromSeconds: localSeconds</body><body package="Store-DB-BaseObjects" selector="timeStampString">timeStampString	"Answer the receiver's timestamp as a string.	The timeStamp is UTC, we make sure to show that"	self timeStamp isNil ifTrue: [^'***'].	^Locale current 		printAsTime: (self timeStampAsTimestampObject) 		policyNamed: #short</body></methods><methods><class-id>Store.DBObject</class-id> <category>glorp faking</category><body package="Store-DB-BaseObjects" selector="isGlorpObject">isGlorpObject	^false</body></methods><methods><class-id>Store.DBObject class</class-id> <category>private-utilities</category><body package="Store-DB-BaseObjects" selector="allRecords">allRecords	"Answer a collection of all records in the table."	^[ self processList: 		(self broker process: (self newSQL selectAll)				 bindOutput: self newPrimed).	] 	on: self  errorSignals 	do: 	[:ex |   ex outer.		OrderedCollection new		].</body><body package="Store-DB-BaseObjects" selector="answerFromQuery:bindInput:">answerFromQuery: aSQLString bindInput: anObject	^self broker process: aSQLString bindInput: anObject.</body><body package="Store-DB-BaseObjects" selector="answerSetFromQuery:bindInput:">answerSetFromQuery: aSQLString bindInput: anObject	| coll |	[coll := self broker process: aSQLString bindInput: anObject.	] 	on: self  errorSignals 	do: 	[:ex |  ex outer.		^OrderedCollection new 		].	^coll notNil 		ifTrue:			[(coll collect: [:each| each first]) asSet]		ifFalse: [OrderedCollection new]</body><body package="Store-DB-BaseObjects" selector="checkFieldsWith:">checkFieldsWith: aDict 	"Test if all keys in the dictionary are representes by column names."	| instVars |	instVars := self columnNames.	aDict keys do: [:each | (instVars includes: each)			ifFalse: 				[self error: (#ShouldBeAnInstanceVariable &lt;&lt; #store &gt;&gt; 'This should be an instance variable to field type mapping').				^false]].	^true</body><body package="Store-DB-BaseObjects" selector="deleteWhereColumn:value:">deleteWhereColumn: column value: value	self broker process: (self newSQL						delete;						where;						column: column equalTo: value)</body><body package="Store-DB-BaseObjects" selector="errorSignals">errorSignals	^DbRegistry errorSignals</body><body package="Store-DB-BaseObjects" selector="processList:">processList: aList	aList == nil		ifTrue: [ ^OrderedCollection new: 1 ].	aList do: 		[ :each | 		each unprime.		each processFields		].	^aList</body><body package="Store-DB-BaseObjects" selector="resetSequenceGeneratorSessions">resetSequenceGeneratorSessions	"Reset all the session used to generate the primary keys."	self withAllSubclasses do: [:x | x resetSequenceGeneratorSession]</body></methods><methods><class-id>Store.DBObject class</class-id> <category>installation-pkgs</category><body package="Store-DB-BaseObjects" selector="alterTablePctincrease">alterTablePctincrease		self broker alterTableFor: self  pctIncreaseBy: 1.</body><body package="Store-DB-BaseObjects" selector="tableExists">tableExists	"Sent to a class representing a database table, answer true if table has been installed."	"Blessing tableExists"	"DefinedRecord tableExists"  "should always answer false"	| query |	^[ ( query := self newSQLFor: self )			selectAll;			where;			addString: '1 = 2'.	self broker processSQL: query sqlString.	true.	] on: Error do: [ :ex | false ]</body></methods><methods><class-id>Store.DBObject class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="newPrimed">newPrimed	| anObject |	anObject := self new.	anObject prime.	^anObject</body></methods><methods><class-id>Store.DBObject class</class-id> <category>private-accessing</category><body package="Store-DB-BaseObjects" selector="blockFactor">blockFactor	^self safeBlockFactor: self defaultBlockFactor</body><body package="Store-DB-BaseObjects" selector="closeConnection">closeConnection	DbRegistry closeConnection.	self resetServerTimestamp</body><body package="Store-DB-BaseObjects" selector="connection">connection	^ DbRegistry connection</body><body package="Store-DB-BaseObjects" selector="connectionClass">connectionClass	^ DbRegistry connectionClass</body><body package="Store-DB-BaseObjects" selector="defaultBlockFactor">defaultBlockFactor	^50</body><body package="Store-DB-BaseObjects" selector="isOnline">isOnline	^ DbRegistry isOnline</body><body package="Store-DB-BaseObjects" selector="isSessionValid:">isSessionValid: aSession	^( aSession == nil or: 			[ aSession state = #new  or: [ aSession state = #paused ]  ] 	  ) not</body><body package="Store-DB-BaseObjects" selector="resetSequenceGeneratorSession">resetSequenceGeneratorSession	SequenceGeneratorSession ifNotNil: 		[self broker ifNotNil: [self broker dismissSession: SequenceGeneratorSession].		SequenceGeneratorSession := nil]</body><body package="Store-DB-BaseObjects" selector="resetSession">resetSession	Session ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: Session].		Session := nil.		self resetServerTimestamp]</body><body package="Store-DB-BaseObjects" selector="safeBlockFactor:">safeBlockFactor: anInteger	"Because of problems on the mac, keep the block factor low"	^( anInteger &gt; 50 and: [ OSHandle currentOS == #mac ] )		ifTrue: [ 50 ]		ifFalse: [ anInteger ].</body><body package="Store-DB-BaseObjects" selector="sequenceGeneratorSession">sequenceGeneratorSession"I moved it to the brokers side because it returned the invalid cursor state for SQLServer prepared session. TK"	DbRegistry isOnline not ifTrue: [ ^nil].	SequenceGeneratorSession := self broker 		sequenceGeneratorSession: SequenceGeneratorSession		forClass: self.	^ SequenceGeneratorSession.</body><body package="Store-DB-BaseObjects" selector="session">session	"Session := nil."	(self isSessionValid: Session) ifFalse: 		[Session := self broker getNewSession.		self resetServerTimestamp].	Session blockFactor: self blockFactor.	^Session</body><body package="Store-DB-BaseObjects" selector="timeStampFromDate:">timeStampFromDate: aDate	^aDate asSeconds - self timeOffset</body></methods><methods><class-id>Store.DBObject class</class-id> <category>private - db-file transfer</category><body package="Store-DB-BaseObjects" selector="collectionFrom:">collectionFrom: aStream 	"Read aStream and answer a collection of DBUserGroup instances."	| coll |	coll := OrderedCollection new.	[aStream atEnd]		whileFalse: 			[| baby |			baby := self readFrom: aStream.			coll add: baby].	^coll</body><body package="Store-DB-BaseObjects" selector="storeTableInto:">storeTableInto: aStream	| coll |	coll := self allRecords.	coll do: [:each| each storeOn: aStream].</body></methods><methods><class-id>Store.DBObject class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="broker">broker	^ DbRegistry storeBroker</body><body package="Store-DB-BaseObjects" selector="brokerOrNil">brokerOrNil	"DbRegistry is already defined when this method is loaded.  The only time that DbRegistry might be defined and still be nil is when StoreBase is being loaded into the image for the first time and I believe that also cannot be the case by the time this is called.  Certainly, no current calls experience any problems.  So the asssessment is that the older version's		on: UnhandledException 		do: [:ex | ex exit: nil]was simply ugly coding of the protected call of storeBroker, which long ago would raise that exception (but later raised a different error) when the storeBroker was nil."	^DbRegistry brokerOrNil</body><body package="Store-DB-BaseObjects" selector="columnNames">columnNames	"Answer all the instance variable names that coorespond to column names in the database table.	Default is all of them."	^self allInstVarNames</body><body package="Store-DB-BaseObjects" selector="columnNamesForQuery">columnNamesForQuery	"Answer all the instance variable names that coorespond to column names in the database table.	Default is same as instsallatoin column names."	^self columnNames</body><body package="Store-DB-BaseObjects" selector="commentFor:">commentFor:  aClass	^self processString: aClass comment</body><body package="Store-DB-BaseObjects" selector="currentUserName">currentUserName	^ DbRegistry currentUserName</body><body package="Store-DB-BaseObjects" selector="databaseName">databaseName	"SQL Server notation"	^ self tableSpaceName</body><body package="Store-DB-BaseObjects" selector="definitionFor:">definitionFor: aClass	| definitionString |	definitionString := (aClass isMeta not and: [aClass isAbsentClassImporter])		ifTrue: [aClass underlyingDefinition]		ifFalse: [aClass definition].	^self processString: definitionString</body><body package="Store-DB-BaseObjects" selector="indexColumnNames">indexColumnNames		^ Array new.</body><body package="Store-DB-BaseObjects" selector="indexName">indexName	^ nil</body><body package="Store-DB-BaseObjects" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	"Answer an array of arrays: Each array is first, index name, second an array of column names		Example : #('ST_MethodRetrievalIndex' #('name' 'classname'))	The default is an empty array, meaning no indexes"	^#()</body><body package="Store-DB-BaseObjects" selector="newList:isEqualTo:">newList: newList isEqualTo: oldList	"There is no senders to this method?"	| sortList1 sortList2 |	newList size = oldList size ifFalse: [^false].	sortList1 := newList asSortedCollection: [:x :y | x name &lt; y name].	sortList2 := oldList  asSortedCollection: [:x :y | x name &lt; y name].	sortList1 with: sortList2 do: [:each1 :each2 |		(each1 primaryKey = each2 primaryKey) ifFalse: [^false]].	^true</body><body package="Store-DB-BaseObjects" selector="newSQL">newSQL	^ self broker newSQLFor: self</body><body package="Store-DB-BaseObjects" selector="newSQLFor:">newSQLFor: aClass	^ self broker newSQLFor: aClass</body><body package="Store-DB-BaseObjects" selector="processString:">processString: aString	"Purify to &lt;cr&gt; line termination"	"self processString: (String with: Character lf with: Character cr with: (Character value: 11))" 	^IOAccessor convertStringFromPlatform: aString string.</body><body package="Store-DB-BaseObjects" selector="sourceCodeAt:forClass:">sourceCodeAt: aSelector forClass: aClass 	"ACMEObject sourceCodeAt: #sourceCodeAt:forClass: forClass: ACMEObject class"	"Get the source the way it is done by the base system but without changing the cursor	and checking InputState"	| newSource index method |	method := aClass compiledMethodAt: aSelector.	newSource := SourceFileManager default stringAt: method sourcePointer ifAbsent: [nil].	newSource == nil ifTrue: [  "no stored source"		^(aClass decompilerClass new			decompile: aSelector			in: aClass			method: method) decompiledCode].	((newSource at: newSource size) isSeparator)		ifTrue:			[index := newSource size. "tidy up for file out"			[((newSource at: index) isSeparator)				and: [index &gt; 1]]				whileTrue: [index := index - 1].			newSource := newSource copyFrom: 1 to: index].	^self processString: newSource</body><body package="Store-DB-BaseObjects" selector="timeStamp">timeStamp	"We get the server CURRENT_TIMESTAMP if it is available, 	if not, we fallback to UTC from the client side"	ServerTimestamp ifNil: [self getServerTimestamp].	ServerTimestamp == #unavailable ifTrue: [^Time secondClock - self timeOffset].	^self serverTimestampNow - self timeOffset</body><body package="Store-DB-BaseObjects" selector="timeStampAsTimestampObject">timeStampAsTimestampObject	"Answer the receiver's timestamp as a Timestamp, rather than an integer."	| |	self timeStamp isNil ifTrue: [^nil].	^Timestamp fromSeconds: (self timeStamp + self timeOffset).</body><body package="Store-DB-BaseObjects" selector="xmlDefinitionFor:">xmlDefinitionFor:  aClass	^self processString: aClass xmlDefinition</body></methods><methods><class-id>Store.DBObject class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="createDatabaseIndex">createDatabaseIndex	| indexColumnArray |	(indexColumnArray := self indexNamesAndColumnNames) isEmpty ifTrue: [^self].	1 to: indexColumnArray size do:		[:index |		self broker			createIndexForClass: self			index:  (indexColumnArray at: index) first			columns: (indexColumnArray at: index) last]</body><body package="Store-DB-BaseObjects" selector="createDatabaseSequence">createDatabaseSequence	self broker createDatabaseSequence:  self.	self broker 		grantForSeqClass: self  		permissions: self broker permissionsForSequence 		toUsers: #('PUBLIC').</body><body package="Store-DB-BaseObjects" selector="createDatabaseTable">createDatabaseTable	"Creates a corresponding database table."	self broker createDatabaseTable: self.	self setDatabasePrivilegesForTable.	(self needsSequenceFor: self)  ifTrue: [self createDatabaseSequence]</body><body package="Store-DB-BaseObjects" selector="createPhysicalSpaces">createPhysicalSpaces	^ self broker createPhysicalSpaces</body><body package="Store-DB-BaseObjects" selector="createViewForClass:">createViewForClass: aClass	self broker createViewForClass: aClass.	self broker grantForClass: aClass  permissions: #('SELECT')  toUsers: #('PUBLIC').</body><body package="Store-DB-BaseObjects" selector="deinstall">deinstall	"self deinstall"	self dropTables.	self dropViews.</body><body package="Store-DB-BaseObjects" selector="dropDatabases">dropDatabases	(Array with: Store.DBObject with: Store.Blob) do: [ :each | self broker dropDatabaseFor: each].</body><body package="Store-DB-BaseObjects" selector="dropSequenceForClass:">dropSequenceForClass: aClass 	self broker dropSequenceForClass: aClass.</body><body package="Store-DB-BaseObjects" selector="dropTableForClass">dropTableForClass	self broker dropTableForClass: self.	(self needsSequenceFor: self)		ifTrue: [ self broker dropSequenceForClass: self ]</body><body package="Store-DB-BaseObjects" selector="dropViewForClass">dropViewForClass	self broker dropViewForClass: self .</body><body package="Store-DB-BaseObjects" selector="flushTable">flushTable	table := nil</body><body package="Store-DB-BaseObjects" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE ', self tableSpaceName, ' '</body><body package="Store-DB-BaseObjects" selector="needsSequence">needsSequence	"Answer true to create a database sequence generator."	"Most subclasses are false."	^self == DBObject</body><body package="Store-DB-BaseObjects" selector="needsSequenceFor:">needsSequenceFor: aClass"Check with broker if it supports sequence"	^self broker needsSequenceFor: aClass.</body><body package="Store-DB-BaseObjects" selector="nextIndex">nextIndex	nextIndex isNil ifTrue: [nextIndex := SmallInteger minVal].	nextIndex := nextIndex + 1.	^nextIndex</body><body package="Store-DB-BaseObjects" selector="primaryKeyTypes">primaryKeyTypes	"Returns the primary key types"	^#( #PrimaryKey #PrimaryKeyInteger #PrimaryKeyString 		#PrimaryKeyChar PrimaryKeyShortString)</body><body package="Store-DB-BaseObjects" selector="registerToDebug">registerToDebug	^ self broker registerToDebug</body><body package="Store-DB-BaseObjects" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"Defines who can do what wtih the table"	self broker setDatabasePrivilegesForTable: self.</body><body package="Store-DB-BaseObjects" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 512K NEXT 512K PCTINCREASE 1) '</body><body package="Store-DB-BaseObjects" selector="table">table	table isNil ifTrue: [table := Dictionary new].	^table</body><body package="Store-DB-BaseObjects" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy defaultTableSpace</body></methods><methods><class-id>Store.DBObject class</class-id> <category>private-timestamp</category><body package="Store-DB-BaseObjects" selector="currentTimestampSQLString">currentTimestampSQLString	^[self broker currentTimestampSQLString]		on: SubclassResponsibilityError		do: [:exception | exception return: #unknown]</body><body package="Store-DB-BaseObjects" selector="getServerTimestamp">getServerTimestamp	"Read the server timestamp from the database, if possible"	"self getServerTimestamp"		| resultArray sqlString |	"If we're not connected at all, just use the image timestamp. This can happen during image startup."	DbRegistry isConnected ifFalse: [^ServerTimestamp := #unavailable].	sqlString := self currentTimestampSQLString.	resultArray := 		(sqlString = #unknown) 			ifTrue: [#(#())]			ifFalse: [				self broker					process: sqlString					onError: Error					do: 						[:exception |						exception return: #(#())]].	ServerTimestamp := (resultArray first isEmpty or: [(resultArray first first isKindOf: Timestamp) not])		ifTrue: [#unavailable]		ifFalse: [resultArray first first].	LastTimestamp := Time totalSeconds.</body><body package="Store-DB-BaseObjects" selector="resetServerTimestamp">resetServerTimestamp	LastTimestamp := ServerTimestamp := nil</body><body package="Store-DB-BaseObjects" selector="serverTimestampNow">serverTimestampNow	| secondsSinceLastAccess |	secondsSinceLastAccess := Time totalSeconds - (LastTimestamp ifNil: [LastTimestamp := Time totalSeconds]).	^ServerTimestamp asSeconds + secondsSinceLastAccess</body><body package="Store-DB-BaseObjects" selector="timeOffset">timeOffset	"Our offset is based on August 16, 1993 7:19:47. 	This then makes that date as the start of our epoch.	Timestamp fromSeconds: self timeOffset"	^2922938387</body></methods><methods><class-id>Store.DBRecord</class-id> <category>support</category><body package="Store-DB-BaseObjects" selector="textForItem">textForItem	^DbRegistry textForItem: self</body></methods><methods><class-id>Store.DBRecord</class-id> <category>comparing</category><body package="Store-DB-BaseObjects" selector="youngerThan:">youngerThan: aPackage	"Answer true if I'm younger than aPackage."	^aPackage isLoaded		ifTrue: [ ( aPackage youngerThan: self ) not ]		ifFalse: [ self timestamp &gt; aPackage timestamp ].</body></methods><methods><class-id>Store.DBRecord</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="displayString">displayString	^self textForItem</body></methods><methods><class-id>Store.DBRecord</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="dbIdentifier">dbIdentifier	"Answer the receiver's database identifier."	^dbIdentifier</body><body package="Store-DB-BaseObjects" selector="dbIdentifier:">dbIdentifier: aSymbol	"Set the receiver's database identifier."	dbIdentifier := aSymbol asSymbol</body><body package="Store-DB-BaseObjects" selector="dbTrace">dbTrace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="dbTrace:">dbTrace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="name">name	^name</body><body package="Store-DB-BaseObjects" selector="name:">name: anObject	name := anObject</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	"Answer the receiver's primaryKey."	^primaryKey</body><body package="Store-DB-BaseObjects" selector="primaryKey:">primaryKey: newPrimaryKey	"Set the receiver's primaryKey to newPrimaryKey."	primaryKey := newPrimaryKey</body><body package="Store-DB-BaseObjects" selector="setVersionTo:">setVersionTo: aVersion	self broker process: 			( self newSQL				update;				column: #version  equalTo: aVersion printString;				where;				column: #primaryKey equalTo: self primaryKey printString).	 self version: aVersion.</body><body package="StoreForGlorpVWUI" selector="timestamp">timestamp	"Answer the receiver's timeStamp."	^timeStamp</body><body package="Store-DB-BaseObjects" selector="timeStamp">timeStamp	"Answer the receiver's timeStamp."	^timeStamp</body><body package="Store-DB-BaseObjects" selector="timeStamp:">timeStamp: newTimeStamp	"Set the receiver's timeStamp to newTimeStamp."	timeStamp := newTimeStamp</body><body package="Store-DB-BaseObjects" selector="trace">trace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="trace:">trace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="userName">userName	"Returns a String, the name of the user who published this record."	^userName</body><body package="Store-DB-BaseObjects" selector="userName:">userName: anObject	userName := anObject</body><body package="Store-DB-BaseObjects" selector="version">version	"Returns a version String."	^version</body><body package="Store-DB-BaseObjects" selector="version:">version: anObject	version := anObject</body></methods><methods><class-id>Store.DBRecord</class-id> <category>utilities-repository</category><body package="Store-DB-BaseObjects" selector="children">children	"Consult the database and find all my children."	| coll |	coll := self broker process:				(self newSQL					selectAll;					where;					column: #trace equalTo: ':primaryKey')				bindInput: self				bindOutput: self class newPrimed.	coll		do: 			[:each | 			each unprime.			each processFields].	^coll</body><body package="Store-DB-BaseObjects" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent packages in the database."	"In this case, the receiver's class."	^self class.</body></methods><methods><class-id>Store.DBRecord</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="removeRecordFromDB">removeRecordFromDB	"Remove a record representing me from the database.	Note that this method can only be sent by the database	system administrator, since it requires privileges	that are not given to the regular users."	self broker process:				(self newSQL					delete;					where;					column: #primaryKey equalTo: ':primaryKey')			bindInput: self</body><body package="Store-DB-BaseObjects" selector="updateTrace:">updateTrace: newTrace	"Change the trace field in the database.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self dbTrace:  newTrace.	self broker process: 					( self newSQL					update;					column: #trace equalTo: ':trace';					where;					column: #primaryKey equalTo: ':primaryKey')			bindInput: self</body></methods><methods><class-id>Store.DBRecord</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="isInCurrentDatabase">isInCurrentDatabase		^#{Store.DbRegistry}		ifDefinedDo: [:registry | registry notNil and: [dbIdentifier isNil or: [dbIdentifier = registry dbIdentifier]]]		elseDo: [false]</body></methods><methods><class-id>Store.DBRecord</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	dbIdentifier := Object new.</body><body package="Store-DB-BaseObjects" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	dbIdentifier := DbRegistry dbIdentifier.		"where we came from"</body></methods><methods><class-id>Store.DBRecord</class-id> <category>shadow support</category><body package="Atomic Compiling and Loading" selector="belongsToClass">belongsToClass	"Answer true if the receiver depends on a class (ie method or shared in a class)"		^false</body></methods><methods><class-id>Store.DBRecord</class-id> <category>compatibilty</category><body package="Store-DB-BaseObjects" selector="allVersionsWithName:">allVersionsWithName: aName	^self class allVersionsWithName: aName</body><body package="Store-DB-BaseObjects" selector="newestVersionWithName:">newestVersionWithName: aName 	^self class newestVersionWithName: aName</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="columnNames">columnNames		"self columnNames"	^super columnNames		remove: 'dbIdentifier';		yourself</body><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'primaryKey' put: #PrimaryKey.	aDict at: 'timeStamp' put: #Integer.	aDict at: 'trace' put: #Integer.	^aDict</body><body package="Store-DB-BaseObjects" selector="viewColumnNames">viewColumnNames 	"This message is overided by collection classes that define	complex views."	^#()</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="allNames">allNames	"Answer a collection of all names known to the database."	"Note: should be sent to an appropiate subclass."	^ Cursor database showWhile: [		[ (( self broker process: 				(self newSQL					selectDistinct: #( name ))		  ) collect: [ :n | n first ] ) asSortedCollection		]		on: self errorSignals 		do: 	[ :ex | ex outer.				OrderedCollection new			].	]</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:">allVersionsWithName: aName 	"Answer a colection of db records	Note: should be sent to an appropiate subclass."	^[(self doPostLoadProcessingOn: (self broker 		process: ((self newSQL)			selectAll;			where;			column: #name equalTo: aName asString printString)		bindOutput: self newPrimed)) asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]] 			on: self errorSignals			do: 				[:exception | 				exception outer.				OrderedCollection new]</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:blessingLevel:">allVersionsWithName: aName blessingLevel: anInteger	^self allVersionsWithName: aName blessingLevels:(Array with: anInteger)</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:blessingLevels:">allVersionsWithName: aName blessingLevels: anArray	"Answer a colection of db records"	"Note: should be sent to an appropiate subclass."	|  items sqlStatement blessingORConditionalStatement |	"SELECT * FROM .. WHERE name = ..   AND (.. OR ...) "	sqlStatement := self newSQL 					selectAll; 					where; 					column: #name equalTo: aName asString printString;					and;					beginClause.	blessingORConditionalStatement := WriteStream on: (String new: 64).	anArray 		do:[:each | blessingORConditionalStatement 								nextPutAll: 'blessingLevel = '; 								print: each ] 		separatedBy:[ blessingORConditionalStatement nextPutAll: ' OR '].	sqlStatement addString:  blessingORConditionalStatement contents.	sqlStatement endClause.	[ items := self doPostLoadProcessingOn:				(self broker process: sqlStatement sqlString 						bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer.			 ^OrderedCollection new 		].		^items asSortedCollection: [ :x :y | x timestamp &gt; y timestamp ]</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:newerThan:">allVersionsWithName: aName newerThan: aDBRecord	"Answer a colection of db records"	"Note: should be sent to an appropiate subclass."	^[(self doPostLoadProcessingOn:					(self broker process: 							( self newSQL								selectAll;								where;								column: #timestamp greaterThan: aDBRecord timestamp printString;								and;								column: #name  equalTo:  aName asString printString)				 bindOutput: self newPrimed)	 ) asSortedCollection: [ :x :y | x timestamp &gt; y timestamp ]	] 	on: self  errorSignals 	do: 	[ :ex | ex outer.			OrderedCollection new		].</body><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by anID from the DB."	"This method can only be used for concrete subclasses." 	^ self getRecordWithID: anID</body><body package="Store-DB-BaseObjects" selector="doPostLoadProcessingOn:">doPostLoadProcessingOn: dbRecords 	^self processList: dbRecords.</body><body package="Store-DB-BaseObjects" selector="newestVersionWithName:">newestVersionWithName: aName 	"Answer a colection of db records"	"Note: should be sent to an appropriate subclass."	| items sqlString |	sqlString := self newSQL					selectAll;					where;					column: #name equalTo: aName asString printString;					and;					column: #timestamp;					equal;					beginClause;					addString: ( self newSQL									selectMax: #( timestamp );									where;									column: #name equalTo: aName asString printString);					endClause.	^self isOnline		ifTrue:			[ ( items := self doPostLoadProcessingOn: 				(self broker process: sqlString bindOutput: self newPrimed))			isEmpty				ifFalse: [ items first ].			].</body><body package="Store-DB-BaseObjects" selector="retrievalErrorString">retrievalErrorString	^(#ErrorEncountered1sCannotBeRetrieved &lt;&lt; #store &gt;&gt; 'Error encountered (&lt;1s&gt;).&lt;n&gt;Versions of: &lt;2s&gt; cannot be retrieved')</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>private-garbage collection</category><body package="Store-DB-BaseObjects" selector="removeFromDB:">removeFromDB: primaryKeys	"Remove all the records with matching primaryKeys."	"Generic method -- send to concrete subclass."	| maxIds pkeys |	maxIds :=  ( self broker maxSqlString - 100 ) // 10.	pkeys :=  primaryKeys asOrderedCollection collect: [ :k | k printString ].	1 to: pkeys size by: maxIds do:		[ :index | | keys |		keys := pkeys copyFrom:  index to: ( index + maxIds - 1 min: pkeys size ).		self broker process:			( self newSQL				delete;				where;				column: #primaryKey equalToArray: keys			).		].</body><body package="Store-DB-BaseObjects" selector="removeRecordsFromDB:">removeRecordsFromDB: records	"Remove all the records from the database."	"Generic method -- send to concrete subclass."	self removeFromDB: 		( records collect: [ :rec | rec primaryKey ] )</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="getRecordWithID:">getRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB. 	Use the prepared session stored in the PrimaryKeySession class instance 	variable.	This is a private method. Use aRecordWithID:"	| dbRecs res |	[dbRecs := self broker getAnswerFromSession: [self primaryKeySession]			bindInput: [:session| session bindInput primaryKey: anID ].	]	on: self  errorSignals 	do: 	[ :ex |   ex outer. ^nil ].	(dbRecs isNil or: [dbRecs isEmpty])		ifTrue: [^nil]		ifFalse: [res := dbRecs first].	res unprime.	res processFields.	^res</body></methods><methods><class-id>Store.Record</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="isClass">isClass	^false</body><body package="Store-DB-BaseObjects" selector="isDataModel">isDataModel	"Is this a Bernstein data model?"	^true</body><body package="Store-DB-BaseObjects" selector="isExtension">isExtension	^false</body><body package="Store-DB-BaseObjects" selector="isForClass">isForClass			^false</body><body package="Store-DB-BaseObjects" selector="isForClassOrExtension">isForClassOrExtension			^self isForClass</body><body package="Store-DB-BaseObjects" selector="isForData">isForData	^false</body><body package="Store-DB-BaseObjects" selector="isForGeneral">isForGeneral	^false</body><body package="Store-DB-BaseObjects" selector="isForMethod">isForMethod	^false</body><body package="Store-DB-BaseObjects" selector="isForNameSpace">isForNameSpace			^false</body><body package="Store-DB-BaseObjects" selector="isForProperty">isForProperty			^false</body><body package="Store-DB-BaseObjects" selector="isLoaded">isLoaded	^false</body><body package="Store-DB-BaseObjects" selector="isPseudo">isPseudo	^false.</body></methods><methods><class-id>Store.Record</class-id> <category>comparing</category><body package="Store-DB-BaseObjects" selector="sameAs:">sameAs: aThing 	^aThing notNil and: [aThing sameAsDBThing: self]</body><body package="Store-DB-BaseObjects" selector="sameAsDBThing:">sameAsDBThing: aThing	"If primary key is not set then a records have to be indentical."	aThing class ~= self class ifTrue: [^false].	self primaryKey isNil ifTrue: [^aThing == self].	^aThing primaryKey =  self primaryKey</body></methods><methods><class-id>Store.Record</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="fullDisplayString">fullDisplayString	^self displayString</body><body package="Store-DB-BaseObjects" selector="itemString">itemString	^self name , self versionString</body><body package="Store-DB-BaseObjects" selector="printOn:">printOn: aStream		aStream nextPut: ${.	name printOn: aStream.	aStream nextPut: $-.	version printOn: aStream.	aStream nextPut: $-.	primaryKey printOn: aStream.	aStream nextPut: $}.</body><body package="Store-DB-BaseObjects" selector="shortItemString">shortItemString	^self name , self shortVersionString</body><body package="Store-DB-BaseObjects" selector="shortVersionString">shortVersionString		| string |	string := self version.	string ifNil: [^''].	(string isNil or: [string class = Object]) ifTrue: [string := self timeStampString].	^'(' , string , ')'</body><body package="Store-DB-BaseObjects" selector="sourceOrBinaryString">sourceOrBinaryString	^''</body><body package="Store-UI-Comparitors" selector="statusLineString">statusLineString	^''</body><body package="Store-DB-BaseObjects" selector="versionString">versionString	| vr un |	vr := self version.	un := self userName.	(vr == nil and: [un == nil]) ifTrue: [^''].	(vr isNil or: [vr class = Object]) ifTrue: [vr := self timeStampString].	un isNil ifTrue: [un := (#unknown &lt;&lt; #store &gt;&gt; 'unknown') asString].	^'(' , vr , ',' , un , ')'</body><body package="Store-DB-BaseObjects" selector="versionStringAlternate">versionStringAlternate	^self versionString</body></methods><methods><class-id>Store.Record</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="getTrace">getTrace	"Given an ID of a record get the real record from 	database. If trace is zero answer nil."	^self class aRecordWithID: self dbTrace</body><body package="Store-DB-BaseObjects" selector="hasTrace">hasTrace	^self dbTrace notNil and: [self dbTrace ~= 0]</body><body package="Store-DB-BaseObjects" selector="setNoTrace">setNoTrace	self setTrace: nil</body><body package="Store-DB-BaseObjects" selector="setTrace:">setTrace: aDBRecord	trace := aDBRecord isNil ifTrue: [0] ifFalse: [aDBRecord primaryKey]</body></methods><methods><class-id>Store.Record</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="getDefinitionID:">getDefinitionID: anID		| record |	( record := self getDefinitionRecordID: anID ) notNil				ifTrue: [ ^record definition ].		^String new.</body><body package="Store-DB-BaseObjects" selector="getDefinitionRecordID:">getDefinitionRecordID: anID	"Given an ID of a record containing a string definition	answer a record."	self isInCurrentDatabase &amp; self class isOnline		ifFalse: [ ^nil ].	^self class definitionClass aRecordWithID: anID</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	"Retrieve and set primary key "	(self primaryKey isNil ) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"Some subclasses have prep work to perform before creating record."	self prepareInstallation.		"Set primary key and user name."	(self class needsSequenceFor: self class) ifTrue: [self primaryKey: self nextID].	self userName: self currentUserName.</body><body package="Store-DB-BaseObjects" selector="prepareInstallation">prepareInstallation	"Subclasses may need to 		create foreign key records etc., before creating record.	Default is do nothing"</body></methods><methods><class-id>Store.Record class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="viewColumnNames">viewColumnNames 	"This message is overided by collection classes that define	complex views."	^#()</body></methods><methods><class-id>Store.Record class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="allIn:butNotIn:refColumn:associationClass:">allIn: aKey1 butNotIn: aKey2 refColumn: aRefColumn associationClass: aClass 	| str inpObject res |	inpObject := Array with: aKey1 with: aKey2.	[ str := self newSQL			selectAll;			where;			column: #primaryKey;			in: ( (self newSQLFor: aClass)					select: ( Array with: aRefColumn );					where;					column: #packageRef equalTo: ':1';					and;					column: aRefColumn;					notIn: ((self newSQLFor: aClass)							select: ( Array with: aRefColumn );							where;							column: #packageRef equalTo: ':2')).	res := self processList: 			(self broker 	process: str						bindInput: inpObject						bindOutput: self newPrimed).	DbRegistry printDebug: 'Record&gt;&gt;allIn:butNotIn:..'; printDebug: res.	] on: self errorSignals  	  do: [ :ex | ex outer. ^OrderedCollection new ].	^res</body><body package="Store-DB-BaseObjects" selector="allInPackage:butNotIn:">allInPackage: pkgKey1 butNotIn: pkgKey2 	"Answer a collection of instances that are defined in pkgKey1, but not in pkgKey2"	"Send to concrete subclass."	"ClassRecord allClassesInPackage: 2631 butNotIn: 2495"	^self sourcesViewClass 		recordsWithSourcesIn:  pkgKey1 		butNotIn: pkgKey2</body><body package="Store-DB-BaseObjects" selector="allInPackages:">allInPackages: keys	"Answer a collection of items that are in the packages in keys"	"Send to a concrete subclass that implements #referenceColumn"	"Method allInPackages: #( '23' '55' )"	keys isEmpty		ifTrue: [ ^OrderedCollection new ].	^self allInPackages: keys refColumn: self referenceColumn</body><body package="Store-DB-BaseObjects" selector="allInPackages:butNotIn:">allInPackages: keys1 butNotIn: keys2 	"Answer a collection of items that are in one the packages in keys1 but not in keys2"	^self 		allInPackages: keys1 		butNotIn: keys2 		refColumn: self referenceColumn</body><body package="Store-DB-BaseObjects" selector="allInPackages:butNotIn:refColumn:">allInPackages: keys1 butNotIn: keys2 refColumn: referenceColumn	"Answer a collection of items that are in one the packages in keys1 but not in keys2"	| str res |	keys1 isEmpty		ifTrue: [ ^OrderedCollection new ].	keys2 isEmpty		ifTrue: [ ^self allInPackages: keys1 refColumn: referenceColumn ].	[ str := self newSQL			selectAll;			where;			column: #primaryKey;			in: ( ( self newSQLFor: self associationClass )					select: ( Array with: referenceColumn );					where;					column: #packageRef equalToArray: keys1;					and;					column: referenceColumn;					notIn: ( ( self broker newSQLFor: self associationClass )							select: ( Array with: referenceColumn  );							where;							column: #packageRef equalToArray: keys2 ) ).	res := self processList: ( self broker process: str bindOutput: self newPrimed ).	DbRegistry printDebug: 'Record&gt;&gt;allIn:butNotIn:..'; printDebug: res.	] on: self errorSignals  	  do: [ :ex | ex outer. ^OrderedCollection new ].	^res</body><body package="Store-DB-BaseObjects" selector="allInPackages:refColumn:">allInPackages: keys refColumn: referenceColumn	"Answer a collection of items that are in the packages in keys"	"Send to a concrete subclass"	^self broker processSQL:  		( self newSQL 			selectAll;			where;			column: #primaryKey;			in: ( self associationClass newSQL					select: ( Array with: referenceColumn );					where;					column: #packageRef equalToArray: keys				)		) bindOutput: self newPrimed.</body><body package="Store-DB-BaseObjects" selector="allNames">allNames	"self allNames"	^[DbRegistry allNamesFor: self] 		on: self errorSignals		do: 			[:exception | 			exception outer.			(self table collect: [:each | each name]) asSet]</body><body package="Store-DB-BaseObjects" selector="allNamesMatching:">allNamesMatching: aString	"Wildcard search. Send to appropiate subclass"	"Method allNamesMatching: 'all*' "	^[ self processList: 		( self broker process:			( self newSQL 				selectAll;				where;				column: #name wildcard: aString printString			 ) 		 bindOutput: self newPrimed		)		]		on: self  errorSignals 		do: 	[:ex |  ex outer. ^#() ].</body><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by anID from the DB."	"This method can only be used for concrete subclasses." 	^ self getRecordWithID: anID</body><body package="Store-DB-BaseObjects" selector="chooseNameMatching:description:">chooseNameMatching: aString description: bString 	"Wildcard search and select. Send to appropiate subclass. Answers a symbol or nil"	"Method chooseNameMatching: 'all*' description: 'selector' "	| list names |	(list := self allNamesMatching: aString) isEmpty 		ifTrue: 			[Dialog warn: ((#No1sMatching2s &lt;&lt; #store &gt;&gt; 'No &lt;1s&gt; matching &lt;2s&gt;') expandMacrosWith: bString with: aString).			^nil].	names := (list collect: [:dbr | dbr name asSymbol]) asSet 				asSortedCollection asOrderedCollection.	names size == 1 ifTrue: [^names first].	^Dialog 		choose: ((#ChooseA1sDots &lt;&lt; #store &gt;&gt; 'Choose a &lt;1s&gt;...') expandMacrosWith: bString)		fromList: names		values: names		lines: 12		cancel: nil</body><body package="Store-DB-BaseObjects" selector="resetPrimaryKeySessions">resetPrimaryKeySessions	"Reset all the session used to access records by the primary key."	self withAllSubclasses do: [:x | x resetPrimaryKeySession]</body><body package="Store-DB-BaseObjects" selector="selectPrimaryKeysIn:bindInput:">selectPrimaryKeysIn: keyCollection bindInput: inpObject 	"Select records from the DB with primary keys 	in 'keyCollection', return the records.	Get them in chunks of size 'step'."	| result step keys |	step := 100.	keyCollection isEmpty ifTrue: [^#()].	result := OrderedCollection new: keyCollection size.	keys := keyCollection asOrderedCollection.	1		to: keys size		by: step		do: 			[:startIndex | 			| stream str |			stream := (String new: 100) writeStream.			startIndex to: (startIndex + step - 1 min: keys size)				do: 	[:index | 						(keys at: index)						printOn: stream.						stream nextPutAll: ', '					].			stream skip: -2.			str := self newSQL						selectAll;						where;						column: #primaryKey;						in: stream contents.			result addAll: (self broker					process: str					bindInput: inpObject					bindOutput: self newPrimed)].	result notNil ifTrue: [result do: [:each | each unprime; processFields]].	^result</body></methods><methods><class-id>Store.Record class</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="executeSQL:onError:">executeSQL: aSqlStatement onError: aBlock	^ [ self doPostLoadProcessingOn: 			(self broker 	process: aSqlStatement 					bindOutput: self newPrimed).	] 	on: self  errorSignals 	do:	[:ex | aBlock value ].</body><body package="Store-DB-BaseObjects" selector="getRecordWithID:">getRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB. 	Use the prepared session stored in the PrimaryKeySession class instance 	variable.	This is a private method. Use aRecordWithID:"	| dbRecs res |	[dbRecs := self broker getAnswerFromSession: [self primaryKeySession]			bindInput: [:session| session bindInput primaryKey: anID ].	]	on: self  errorSignals 	do: 	[ :ex |   ex outer. ^nil ].	(dbRecs isNil or: [dbRecs isEmpty])		ifTrue: [^nil]		ifFalse: [res := dbRecs first].	res unprime.	res processFields.	^res</body><body package="Store-DB-BaseObjects" selector="primaryKeySession">primaryKeySession	"Answer session for accessing records when the primary	key for the record is known."	"PrimaryKeySession := nil."	( self isSessionValid: PrimaryKeySession)		ifFalse:			[PrimaryKeySession := self broker getNewSession.			PrimaryKeySession bindOutput: self newPrimed.			PrimaryKeySession bindInput: self newPrimed.			PrimaryKeySession prepare: 						( self newSQL							selectAll;							where;							column: #primaryKey equalTo: ':primaryKey').			PrimaryKeySession blockFactor: 10].	^PrimaryKeySession</body><body package="Store-DB-BaseObjects" selector="resetPrimaryKeySession">resetPrimaryKeySession	PrimaryKeySession notNil 		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: PrimaryKeySession ].			 PrimaryKeySession := nil			]</body></methods><methods><class-id>Store.Record class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="fromSourcesView:">fromSourcesView: aSourcesView 	| record |	record := self fromView: aSourcesView.	record sourceCode: ( self definitionClass fromView: aSourcesView ) definition.	^record</body></methods><methods><class-id>Store.Record class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="definitionClass">definitionClass		^Blob</body><body package="Store-DB-BaseObjects" selector="definitionClasses">definitionClasses	^Array with: self definitionClass</body></methods><methods><class-id>Store.ViewRecord class</class-id> <category>session</category><body package="Store-DB-BaseObjects" selector="createAllInButNotInSession">createAllInButNotInSession	"Answers all the records in one package, but not the other."	"Called by concrete subclasses."		| sql sqlAssist |	( sqlAssist := self newSQL )		selectAll;		where;		column: #primaryKey equalTo: ':1';		and;		column: #primaryKey notEqualTo: ':2'.			sql := ( self columnNames includes: 'definitionOrder' )		ifTrue: [ sqlAssist orderBy:  #definitionOrder ]		ifFalse: [ sqlAssist sqlString ].	^( self class		process: sql		bindOutput: self class newPrimed	) collect: [ :each | self  fromView: each]</body><body package="Store-DB-BaseObjects" selector="createSourcesSession">createSourcesSession	"Answer a sources session for the receiver."	"Called by concrete subclasses that have a sources view to initialize."		| sql sqlAssist |	( sqlAssist := self newSQL )		selectAll;		where;		column: #packageRef equalTo: ':primaryKey'.	sql := ( self columnNames includes: 'definitionOrder' )		ifTrue: [ sqlAssist orderBy:  #definitionOrder ]		ifFalse: [ sqlAssist sqlString ].				^self broker getNewSession		blockFactor: self blockFactor;		bindOutput: self newPrimed;		bindInput: self new;		prepare: sql;		yourself.</body></methods><methods><class-id>Store.ViewRecord class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="aliasedDefReferenceColumnNames">aliasedDefReferenceColumnNames	"Return aliased column names for the fields in the definition class."	^self defReferenceColumnNames.</body><body package="Store-DB-BaseObjects" selector="aliasedDefReferenceColumnNamesCollection">aliasedDefReferenceColumnNamesCollection	"Return aliased column names for the fields in the definition class."	^Array with: self aliasedDefReferenceColumnNames.</body><body package="Store-DB-BaseObjects" selector="childReferenceColumns">childReferenceColumns	^Array with: self childReference.</body><body package="Store-DB-BaseObjects" selector="definitionReferenceClass">definitionReferenceClass	"Answer the class for the table that contains the definitionReferenceColumn."	^self referencedClass.</body><body package="Store-DB-BaseObjects" selector="definitionReferenceClasses">definitionReferenceClasses	"Answer the class for the table that contains the definitionReferenceColumn."	^Array with: self definitionReferenceClass.</body><body package="Store-DB-BaseObjects" selector="definitionReferenceColumn">definitionReferenceColumn	"Answer the column symbol of the column that contains the definition id."	^#definitionID</body><body package="Store-DB-BaseObjects" selector="definitionReferenceColumns">definitionReferenceColumns	"Answer the column symbol of the column that contains the definition id."	^Array with: self definitionReferenceColumn</body><body package="Store-DB-BaseObjects" selector="definitionsAreOptional">definitionsAreOptional	^(Array new: self definitionReferenceClasses size) atAllPut: false; yourself.</body><body package="Store-DB-BaseObjects" selector="defIsOptional">defIsOptional	"Return true if it's possible that the definition class row will be missing (i.e. we need an outer join)."	^false</body><body package="Store-DB-BaseObjects" selector="defReferenceColumnNames">defReferenceColumnNames	^self definitionClass defReferenceColumnNames.</body><body package="Store-DB-BaseObjects" selector="defReferenceColumnNamesCollection">defReferenceColumnNamesCollection	^Array with: (self defReferenceColumnNames).</body></methods><methods><class-id>Store.ViewRecord class</class-id> <category>queries</category><body package="Store-DB-BaseObjects" selector="allInPackages:">allInPackages: pkgList	"Send only to a concrete subclass that implements #referencedClass and has a packageRef column.	Answer the referenced class instances defined in any the packages in the list"	"PkgClassesView allInPackages: ( Bundle newestVersionWithName: 'StoreBase' ) leafItems"	| views |	pkgList isEmpty		ifTrue: [ ^OrderedCollection new ].	views := self processList:		( [ self broker process:			( self newSQL				selectAll;				where;				column: #packageRef equalToArray: ( pkgList collect: [ :pkg | pkg primaryKey printString ] ) )			bindOutput: self newPrimed		] on: self errorSignals 			do: 	[ :ex | ex outer. ^OrderedCollection new ]	).	^views collect: [ :v | self referencedClass fromView: v ]</body><body package="Store-DB-BaseObjects" selector="recordsWithSourcesIn:">recordsWithSourcesIn: aPackage	"Answers all instances of the receiver's #referencedClass records."	"Send only to a concrete sources view subclass."	| dbRecords | 	^[ dbRecords := self broker 						getAnswerFromSession: [ self sourcesSession ]						bindInput: [ :session | session bindInput primaryKey: aPackage primaryKey].	dbRecords asOrderedCollection collect: [ :each | self referencedClass fromSourcesView: each ].	] on: self  errorSignals do: [ :ex | ^OrderedCollection new ].</body><body package="Store-DB-BaseObjects" selector="recordsWithSourcesIn:butNotIn:">recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey	"Answer all instances of the receiver's referenced class contained 	in aPackage, but not in bPackage. Used to compute package updates."	"Send to a concrete subclass that implemelments:		#referencedClass, #childReference and #subCollectionClass"	| sql sqlAssist |	( sqlAssist := self newSQL ) recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey.		sql := ( self columnNames includes: 'definitionOrder' )		ifTrue: [ sqlAssist orderBy:  #definitionOrder ]		ifFalse: [ sqlAssist sqlString ].	^( self broker		process: sql		bindOutput: self newPrimed	) collect: [ :each | self referencedClass fromSourcesView: each ]</body></methods><methods><class-id>Store.DataView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="commentID">commentID	^commentID</body><body package="Store-DB-Subdefs" selector="commentID:">commentID: id	^commentID := id</body><body package="Store-DB-Subdefs" selector="definitionID">definitionID 	^definitionID</body><body package="Store-DB-Subdefs" selector="definitionID:">definitionID: id	^definitionID := id</body><body package="Store-DB-Subdefs" selector="encodedDataID">encodedDataID	^self sourceCodeID</body><body package="Store-DB-Subdefs" selector="encodedDataID:">encodedDataID: anObject	self sourceCodeID: anObject</body><body package="Store-DB-Subdefs" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Subdefs" selector="environmentString:">environmentString: aString	environmentString := aString</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body><body package="Store-DB-Subdefs" selector="typeString">typeString	^typeString</body><body package="Store-DB-Subdefs" selector="typeString:">typeString: aString	typeString := aString</body></methods><methods><class-id>Store.DataView</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Subdefs" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.DataView class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="childReference">childReference	^'dataRef'</body><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes		"self fieldTypes"	| aDict  |	( aDict := super fieldTypes )		at: 'typeString' put: #Char.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="referencedClass">referencedClass	^DataElement				"^TT_Datum"</body><body package="Store-DB-Subdefs" selector="subCollectionClass">subCollectionClass	^Data</body><body package="Store-DB-Subdefs" selector="subCollectionClasses">subCollectionClasses	^Array with: self subCollectionClass.</body></methods><methods><class-id>Store.DataView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="dataKeySession">dataKeySession	"DataKeySession := nil"	( self isSessionValid: DataKeySession)		ifFalse: 			[DataKeySession := self broker getNewSession.			DataKeySession bindOutput: self newPrimed.			DataKeySession bindInput: self new.			DataKeySession prepare: 					( self newSQL						selectAll;						where;						column: #packageRef  equalTo: ':primaryKey';						and;						column: #name  equalTo: ':name') ].	^DataKeySession</body><body package="Store-DB-Subdefs" selector="dataSession">dataSession	"DataSession := nil"	( self isSessionValid: DataSession )		ifFalse: 			[ DataSession := self broker getNewSession				blockFactor: self blockFactor;				bindOutput: self newPrimed;				bindInput: self new;				prepare: 					( self newSQL 						selectAll; 						where; 						column: #packageRef equalTo: ':primaryKey' 					);				yourself. 			].	^DataSession</body><body package="Store-DB-Subdefs" selector="resetSession">resetSession	DataSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: DataSession].		DataSession := nil].	DataKeySession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: DataKeySession].		DataKeySession := nil]</body></methods><methods><class-id>Store.DataView class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="datumWithKey:ownerName:package:">datumWithKey: dataKey ownerName: aFullName package: aPackageID 	"Answer a TT_DataElement or nil."	| res |		[res := self broker getAnswerFromSession: [DataView dataKeySession]				bindInput: 					[:session | 					(session bindInput)						primaryKey: aPackageID;						name: dataKey asString]] 			on: self errorSignals			do: 				[:ex | 				ex outer.				^nil].	^res isEmpty 		ifTrue: [nil]		ifFalse: 			[res := res collect: [:each | DataElement fromView: each].			res := res select: [:de | de environmentString = aFullName].			res size == 0 				ifFalse: 					[res size &gt; 1 						ifTrue: 							[self 								error: #DuplicateDataDefinition &lt;&lt; #store &gt;&gt; 'Duplicate data definition'. nil]						ifFalse: [DataElement fromView: res first]]]</body></methods><methods><class-id>Store.DataView class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.DataAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="blobData">blobData	^blobData</body><body package="Store-DB-Subdefs" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.DataAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="resetSession">resetSession	DataWithSourcesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: DataWithSourcesSession].		DataWithSourcesSession := nil]</body><body package="Store-DB-Subdefs" selector="sourcesSession">sourcesSession	"DataWithSourcesSession := nil"	( self isSessionValid: DataWithSourcesSession )		ifFalse: [ DataWithSourcesSession := self createSourcesSession ].	^DataWithSourcesSession</body></methods><methods><class-id>Store.DataAndSourcesView class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="dataWithSourcesIn:">dataWithSourcesIn: aPackage	| dbMethods | 	^[ dbMethods := self broker 						getAnswerFromSession: [ self dataWithSourcesSession ]						bindInput: [ :session | session bindInput primaryKey: aPackage primaryKey].	dbMethods collect: [ :each | DataElement fromSourcesView: each ].	] 	on: self  errorSignals 	do: 	[ :ex | ^OrderedCollection new ].</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>publishing</category><body package="Store-Database Model" selector="checkForNameConflict">checkForNameConflict	| nameConflict |	nameConflict := self targetSession		readOneOf: self pundleType		where:			[:each | 			each name = newPundle name &amp; (each version = newPundle version) &amp; (each timestamp ~= newPundle timestamp)].		nameConflict isNil ifFalse:		[self validateVersionStringFor: newPundle].</body><body package="Store-Database Model" selector="isPreviousVersionPresent">isPreviousVersionPresent	^self previousVersionInTargetDatabase notNil.</body><body package="Store-Database Model" selector="isPundleTooBig:">isPundleTooBig: aPundle	^splitPundles and: [aPundle isBundle and: [aPundle bundles isEmpty not]].</body><body package="Store-Database Model" selector="newPundleFromPundle">newPundleFromPundle	"We are replicating;  the pundle we write is a copy of the original."		newPundle := pundle.	^newPundle.</body><body package="Store-Database Model" selector="newWriterFor:">newWriterFor: aPundleWriter	| instance |	instance := self class for: aPundleWriter.	instance splitPundles: self splitPundles.	^instance.</body><body package="Store-Database Model" selector="prepareBinarySaveFor:">prepareBinarySaveFor: aPundle	self deprecated: #(initial '7.7' use 'prepareBinarySaveFor:using:' sunset '7.7.1').	aPundle withAllContainedItems do:		[:each |		(each isPackage and: [each binFile notNil])			ifTrue: [each parcel ifNil: 				[ | parcelRecord |				parcelRecord := StoreParcelRecord from: each storeModel.				each storeModel parcelInto: parcelRecord.				each basicParcel: parcelRecord]]]</body><body package="Store-Database Model" selector="prepareBinarySaveFor:using:">prepareBinarySaveFor: aPundle using: aCollection	aPundle withAllContainedItems do:		[:each |		(each isPackage and: [each binFile notNil and: [aCollection contains: [:eachItem | eachItem name = each name]]])			ifTrue: [each parcel ifNil: 				[ | parcelRecord |				parcelRecord := StoreParcelRecord from: each storeModel.				each storeModel parcelInto: parcelRecord.				each basicParcel: parcelRecord]]]</body><body package="Store-Database Model" selector="prepareForNewPundle">prepareForNewPundle	"Note: we put off instantiating the whole package until we've done any recursive replications Otherwise we end up potentially doing unnecessary reads, and wasting memory in the meantime"	self instantiateAllOf: pundle.	self validateNewPundle: pundle.	self newPundleReconcileWith: nil</body><body package="Store-Database Model" selector="pundleType">pundleType	^self isBundle ifTrue: [StoreBundle] ifFalse: [StorePackage].</body><body package="Store-Database Model" selector="readPreviousVersion">readPreviousVersion	"Find our previous version. If we've been told it by version name, use that. Otherwise (normally) use the previous timestamp."	^self targetSession		readOneOf: self pundleType		where:			[:each | 			(each timestamp = pundle previous timestamp) &amp; (each name = pundle previous name)].</body><body package="Store-Database Model" selector="runPreWriteAction">runPreWriteAction	preWriteAction isNil ifFalse: [preWriteAction value: newPundle].</body><body package="Store-Database Model" selector="validateNewPundle:">validateNewPundle: aPundle	"Validate, but using the validation for new things, which can short-circuit over things that aren't new, and so be more efficient."	aPundle isValidAsNew ifFalse:		[(InvalidStorePundleError new pundle: pundle) signal].</body><body package="Store-Database Model" selector="validateVersionStringFor:">validateVersionStringFor: aStorePundle	aStorePundle validateVersionString</body><body package="Store-Database Model" selector="writeNewPundle">writeNewPundle	"This is a bit ugly. If the old pundle had a version, carry it forward (probably means we're replicating). But if it didn't, and the new one does, that means the user assigned it, and we're probably publishing. Push it back to the original, just to make sure that any logging shows it. We should never have both nil."		newPundle version isNil ifTrue: [newPundle version: pundle version].	pundle version isNil ifTrue: [pundle version: newPundle version].	self validateNewPundle: newPundle.	[self checkForNameConflict]		on: Store.UserCancelledPublish		do: 			[:exception |			^exception pass].	self targetSession transact: [self targetSession register: newPundle].	^newPundle</body><body package="Store-Database Model" selector="writePundle:">writePundle: aPundle	"Copying shoved inside reconcile:with:.  Should we use self class or self parent pundleWriterClass to write subcomponents	(no difference as yet)?\	If it's too big to handle at one gulp, write the sub-components first"	pundle := aPundle.	self writeSubComponentsOf: aPundle.	self isPreviousVersionPresent		ifTrue:			[self instantiateAllOfPundle.			self instantiateAllOf: previousVersionInTargetDatabase.			self newPundleReconcileWith: previousVersionInTargetDatabase]		ifFalse: [self prepareForNewPundle].	newPundle isNil ifTrue: [^nil].	self runPreWriteAction.	self writeNewPundle.	^newPundle.</body><body package="Store-Database Model" selector="writePundle:withChangesBasedOn:">writePundle: aPundle withChangesBasedOn: anImagePundle	self deprecated: #(initial '7.7' use 'writePundlePhase1:withChangesBasedOn:using:' sunset '7.7.1').	self writePundlePhase1: aPundle withChangesBasedOn: anImagePundle.	^self writePundlePhase2: aPundle withChangesBasedOn: anImagePundle.</body><body package="Store-Database Model" selector="writePundle:withChangesBasedOn:using:">writePundle: aPundle withChangesBasedOn: anImagePundle using: aCollection	self writePundlePhase1: aPundle withChangesBasedOn: anImagePundle using: aCollection.	^self writePundlePhase2: aPundle withChangesBasedOn: anImagePundle.</body><body package="Store-Database Model" selector="writePundlePhase1:withChangesBasedOn:">writePundlePhase1: aPundle withChangesBasedOn: anImagePundle	"Prepare to write out the pundle, using information from the image change sets. Do our initial reading of the previous version, but don't reconcile and don't write yet"	self deprecated: #(initial '7.7' use 'writePundlePhase1:withChangesBasedOn:using:' sunset '7.7.1').	pundle := aPundle.	self prepareBinarySaveFor: aPundle.	self isPreviousVersionPresent ifFalse: [^self].	self instantiateIndividualMethodsIn: aPundle requiredFor: anImagePundle.	self instantiateAllOf: previousVersionInTargetDatabase requiredFor: anImagePundle</body><body package="Store-Database Model" selector="writePundlePhase1:withChangesBasedOn:using:">writePundlePhase1: aPundle withChangesBasedOn: anImagePundle using: aCollection	"Prepare to write out the pundle, using information from the image change sets. Do our initial reading of the previous version, but don't reconcile and don't write yet"	pundle := aPundle.	self prepareBinarySaveFor: aPundle using: aCollection.	self isPreviousVersionPresent ifFalse: [^self].	self instantiateIndividualMethodsIn: aPundle requiredFor: anImagePundle.	self instantiateAllOf: previousVersionInTargetDatabase requiredFor: anImagePundle</body><body package="Store-Database Model" selector="writePundlePhase2:withChangesBasedOn:">writePundlePhase2: aPundle withChangesBasedOn: anImagePundle	self isPreviousVersionPresent ifFalse: [^self writePundle: aPundle].	self newPundleReconcileWith: previousVersionInTargetDatabase.	newPundle isNil ifTrue: [^nil].	self runPreWriteAction.	self writeNewPundle.	^newPundle.</body><body package="Store-Database Model" selector="writeSubComponentsOf:">writeSubComponentsOf: aPundle	"If it's too big to handle at one gulp, write the sub-components first. If we're publishing, we should only write those components that have changed. We know they've changed if they've been assigned a version number by the publish dialog or whatever else set up the publishing, but don't have a primary key. Once we've written it out, read it back as a proxy, so we won't have to trace through all of its relationships when we write the parent, and so memory that we don't need any more can be reused."		(self isPundleTooBig: aPundle) ifTrue:		[aPundle componentsDo:			[:each | 			each needsPublishing				ifTrue:					[(self newWriterFor: self) writePundle: each.					each componentsDo: [:eachComponent | self targetSession refresh: eachComponent]]				ifFalse: [each]]]</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>copying</category><body package="Store-Database Model" selector="copy">copy	^self shallowCopy postCopy.</body><body package="Store-Database Model" selector="postCopy">postCopy	previousVersionInTargetDatabase := Object new.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>reconciling</category><body package="Store-Database Model" selector="alreadyPresentVersionOf:">alreadyPresentVersionOf: aPundle	"Notes that in this case we also check for the version name, as opposed to replication, where we can't. In replication, we're looking for something potentially from a different database, and the name may have been modified if there was a conflict. In this case we know we're only dealing with one database, so the name should always be the same."	| alreadyThere |	alreadyThere := self targetSession		readOneOf: self pundleType		where:			[:each | each timestamp = aPundle timestamp &amp; (each name = aPundle name) &amp; (each version = aPundle version)].	^alreadyThere.</body><body package="Store-Database Model" selector="matchingPundleTo:in:">matchingPundleTo: aPundle in: previousVersionOfParent	| collection |	previousVersionOfParent isNil ifTrue: [^nil].	collection := aPundle isBundle ifTrue: [previousVersionOfParent bundles] ifFalse: [previousVersionOfParent packages].	^collection detect: [:each | aPundle matchesWith: each] ifNone: [nil].</body><body package="Store-Database Model" selector="newPundleReconcileWith:">newPundleReconcileWith: anotherPundle 	"Assign a publishable version of my pundle to newPundle and reconcile it."	self newPundleFromPundle.	newPundle reconcileWith: anotherPundle.	newPundle componentsCollect: 			[:each | 			self pundleVersionToUseFor: each withPreviousParentVersion: anotherPundle].	^newPundle</body><body package="Store-Database Model" selector="pundleVersionToUseFor:withPreviousParentVersion:">pundleVersionToUseFor: each withPreviousParentVersion: ignored	| secondaryWriter  existingTargetVersion |	"If the object already has a primary key, and it belongs to our session, then just use it."	(self targetSession cacheContainsObject: each) ifTrue: [^each].	"Otherwise, we'll need to fetch the corresponding version for this session and "	secondaryWriter := self class for: self.	secondaryWriter pundle: each.	secondaryWriter targetSession: self targetSession.	secondaryWriter previousVersionInTargetDatabase: each previous.	existingTargetVersion := secondaryWriter alreadyPresentVersionOf: each.	^existingTargetVersion isNil		ifTrue: [secondaryWriter newPundleReconcileWith: secondaryWriter previousVersionInTargetDatabase]		ifFalse: [existingTargetVersion]</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>api-publishing</category><body package="Store-Database Model" selector="addBlessing:">addBlessing: aStoreBlessing		aStoreBlessing username: self targetUsername.	[targetSession accessor permitEverything.	targetSession		transact:			[targetSession register: pundle.			pundle currentBlessingLevel: aStoreBlessing blessingLevel.			aStoreBlessing timestamp: (Dialect storeTimestampIn: targetSession).			pundle bless: aStoreBlessing]] 				ensure: [targetSession accessor insertOnly]</body><body package="Store-Database Model" selector="preWriteAction:">preWriteAction: aOneArgumentBlock	"Set an action that will be taken just before the pundle is written, and which takes the pundle as an argument. This allows us, for example, to set the version number and blessing on only those components that have been modified and will actually be written."	preWriteAction := aOneArgumentBlock.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>accessing</category><body package="Store-Database Model" selector="isBundle">isBundle	^pundle isBundle.</body><body package="Store-Database Model" selector="previousVersionInTargetDatabase">previousVersionInTargetDatabase	previousVersionInTargetDatabase class == Object		ifTrue:			[pundle previous = nil				ifTrue: [previousVersionInTargetDatabase := nil]				ifFalse: [previousVersionInTargetDatabase := self readPreviousVersion]].	^previousVersionInTargetDatabase.</body><body package="Store-Database Model" selector="previousVersionInTargetDatabase:">previousVersionInTargetDatabase: aStorePundle	previousVersionInTargetDatabase := aStorePundle</body><body package="Store-Database Model" selector="pundle">pundle	^pundle</body><body package="Store-Database Model" selector="pundle:">pundle: aStorePundle	pundle := aStorePundle</body><body package="Store-Database Model" selector="splitPundles">splitPundles	^splitPundles</body><body package="Store-Database Model" selector="splitPundles:">splitPundles: aBoolean	splitPundles := aBoolean</body><body package="Store-Database Model" selector="targetSession">targetSession	targetSession isNil ifTrue: [targetSession := StoreLoginFactory currentStoreSession].	^targetSession.</body><body package="Store-Database Model" selector="targetSession:">targetSession: aSession	targetSession := aSession.</body><body package="Store-Database Model" selector="targetUsername">targetUsername	^self targetSession accessor currentLogin username.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>instantiating</category><body package="Store-Database Model" selector="follow:">follow: aThing	self followSourceFor: aThing.	self followCommentFor: aThing.</body><body package="Store-Database Model" selector="followCommentFor:">followCommentFor: aThing	| source |	source := aThing comment.	source isString ifTrue: [^source].	source isNil ifTrue: [^source].	^[source next isNil] whileFalse: [source := source next].</body><body package="Store-Database Model" selector="followSourceFor:">followSourceFor: aThing	| source originalSource |	originalSource := aThing basicSource.	originalSource isNil ifTrue: [^self].	originalSource next isNil ifTrue: [^self].	source := originalSource.	[source next isNil] whileFalse: [source := source next].</body><body package="Store-Database Model" selector="instantiateAllOf:">instantiateAllOf: aPundle	aPundle isBundle		ifTrue: [self instantiateAllOfBundle: aPundle]		ifFalse: [self instantiateAllOfPackage: aPundle].	aPundle removeDuplicates.</body><body package="Store-Database Model" selector="instantiateAllOf:requiredFor:">instantiateAllOf: aPundle requiredFor: anImagePundle	"Bring in only those methods which list as changed in the change set. Also don't try to remove duplicates, because we probably don't have enough information to do it, and this will be based on image data anyway, so shouldn't have duplicates"	aPundle isBundle		ifTrue: [self instantiateAllOfBundle: aPundle requiredFor: anImagePundle]		ifFalse: [self instantiateAllOfPackage: aPundle requiredFor: anImagePundle].</body><body package="Store-Database Model" selector="instantiateAllOfBundle:">instantiateAllOfBundle: aBundle	"Traverse everything in the bundle, making sure we've got no proxies left, so we have everything we need to write to the other side. Note that for sub-packages we only bring in enough to be able to print them, because we may not end up replicating them if they already exist in the target database"	aBundle bundles do: [:each | self instantiateAllOf: each].	aBundle packages do: [:each | each printString].	aBundle blessings do: [:each | self followSourceFor: each].	self followCommentFor: aBundle.	aBundle propertiesRecordDictionary yourSelf isNil ifFalse: [		aBundle propertiesRecordDictionary do: [:each | self followSourceFor: each]].	aBundle propertiesBlob yourSelf.	aBundle files do: [:each | self followSourceFor: each ].</body><body package="Store-Database Model" selector="instantiateAllOfBundle:requiredFor:">instantiateAllOfBundle: aBundle requiredFor: aBundleModel	"Trace everything that we will need in order to publish a new version, assuming the change set associated with the corresponding store model objects is correct. aBundle should be the trace of aBundleModel and in the same database. Don't worry about getting rid of proxies, because we know this is being read from the current database. Do touch all the packages, unlike normally, but we know that the corresponding methods for packages won't do very much if the change set for that package is empty"	aBundle bundles do: [:each | self instantiateAllOf: each requiredFor: each storeModel].	aBundle packages do: [:each | self instantiateAllOf: each requiredFor: each storeModel].	aBundle blessings do: [:each | self followSourceFor: each].	self followCommentFor: aBundle.	aBundle propertiesRecordDictionary yourSelf isNil ifFalse: [		aBundle propertiesRecordDictionary do: [:each | self followSourceFor: each]].	aBundle propertiesBlob yourSelf.	aBundle files do: [:each | self followSourceFor: each ].</body><body package="Store-Database Model" selector="instantiateAllOfPackage:">instantiateAllOfPackage: aPackage	"Trace everything, making sure we've got no proxies left, so we have everything we need to write to the other side."	aPackage methods do: [:each | self follow: each definition].	self instantiateEverythingButMethodsOf: aPackage.</body><body package="Store-Database Model" selector="instantiateAllOfPackage:requiredFor:">instantiateAllOfPackage: aPackage requiredFor: aPackageModel	"Trace everything that we will need in order to publish a new version, assuming the change set associated with aPackageModel is correct. aPackage should be the trace of aPackageModel and in the same database. Don't worry about getting rid of proxies, because we know this is being read from the current database"	| dbInfo methodList methodNames query parameters nonOptimizedQuery tempMethods batchOfMethodNames|	aPackageModel ifNil: [^self].	dbInfo := aPackageModel databaseInformationFor: aPackage session system databaseIdentifier.	dbInfo isNil 		ifTrue: [methodList := #()]		ifFalse: [			dbInfo changeSet isEmpty ifTrue: [^self].			methodList := dbInfo changeSet modifiedMethodDescriptors].	(aPackage methods isGlorpProxy not or: [aPackage methods isInstantiated]) ifTrue: [		"We've already been read. Just go over the changed list of methods to make sure we haven't got any new ones"		self instantiateIndividualMethodsIn: aPackage requiredFor: aPackageModel.		^self].	parameters := aPackage methods parameters.	methodList isEmpty ifFalse: [		methodNames := methodList collect: [:eachMethodDescriptor | eachMethodDescriptor selector].		tempMethods := OrderedCollection new.		"Now we run a query to bring back methods with those names (this may bring back a few too many that haven't changed but have the same name, but that's OK). We really just want to bring these and their source into cache, but hold onto the collection against the off-chance it gets GCd"		1 to: methodNames size by: 100 do: [:i |			batchOfMethodNames := methodNames copyFrom: (i min: methodNames size) to: (i + 99 min: methodNames size).			query := ((aPackage session system descriptorFor: StorePackage) mappingForAttributeNamed: #methods) query copy.			query AND: [:each | each definition name in: batchOfMethodNames].			tempMethods add: (query executeWithParameters: parameters in: aPackage session)]].	"Now we force read the methods collection without any optimization as to what to bring back"	nonOptimizedQuery := ((aPackage session system descriptorFor: StorePackage) mappingForAttributeNamed: #methods) query copy.	nonOptimizedQuery tracing: nonOptimizedQuery defaultTracing.	nonOptimizedQuery alsoFetch: [:each | each definition].	aPackage privateSetMethods: (nonOptimizedQuery executeWithParameters: parameters in: aPackage session).	tempMethods yourself.	self instantiateEverythingButMethodsOf: aPackage.</body><body package="Store-Database Model" selector="instantiateAllOfPundle">instantiateAllOfPundle	^self instantiateAllOf: pundle.</body><body package="Store-Database Model" selector="instantiateEverythingButMethodsOf:">instantiateEverythingButMethodsOf: aPackage	aPackage classDefinitions		do:			[:each | 			self follow: each definition.			self follow: each metaclass].	aPackage namespaces do: [:each | self follow: each definition].	aPackage sharedVariables do: [:each | self follow: each definition].	aPackage blessings do: [:each | self followSourceFor: each].	self followCommentFor: aPackage.	aPackage propertiesRecordDictionary yourSelf isNil		ifFalse:			[aPackage propertiesRecordDictionary				do: [:each | self followSourceFor: each]].	aPackage propertiesBlob yourSelf.	aPackage parcel.</body><body package="Store-Database Model" selector="instantiateIndividualMethodsIn:requiredFor:">instantiateIndividualMethodsIn: aPundle requiredFor: aPackageModel	"Go through the methods changed in the change set for the image model and make sure that we've touched all of them"		| methodList changeSet |	aPundle leafItems do:		[:each | 		each storeModel ifNotNil:			[changeSet := each storeModel changeSetFor: aPundle session system databaseIdentifier.			methodList := changeSet isNil ifTrue: [#()] ifFalse: [changeSet modifiedMethodDescriptors].			methodList do: [:eachMethod | (each methodFor: eachMethod) ifNotNil: [:method | method source yourself]]]]</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>initializing</category><body package="Store-Database Model" selector="initialize">initialize	previousVersionInTargetDatabase := Object new.	splitPundles := false.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter</class-id> <category>private</category><body package="Store-Database Model" selector="removePackageInfo">removePackageInfo	pundle := nil.	previousVersionInTargetDatabase := nil.</body></methods><methods><class-id>Store.Glorp.StorePundleWriter class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="for:">for: aStorePundleWriter	| instance |	instance := self new.	instance splitPundles: aStorePundleWriter splitPundles.	^instance</body><body package="Store-Database Model" selector="new">new	^super new initialize.</body></methods><methods><class-id>Store.FileOutClassDoesntExistError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	Dialog warn: (#Class1sNoLongerExists &lt;&lt; #store &gt;&gt; 'Class &lt;1s&gt; no longer exists' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.FileOutClassDoesntExistError class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.StoreProgressOverlay</class-id> <category>initialize-release</category><body package="Store-UI" selector="addProgressView">addProgressView	| view |	view := StoreProgressView new.	view notifications: StoreWorkActivity notifications.	self add: view</body><body package="Store-UI" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	self childFramingBlock: 			[:rect :child :index |			index = 1				ifTrue: [rect]				ifFalse: [rect topLeft + (20 @ 0) corner: rect topRight + (-20 @ 50)]]</body><body package="Store-UI" selector="restoreOriginal">restoreOriginal	| window |	self progressView release.	window := container.	window		ifNil: 			[^self	"This situation arises when events outside of our know have caused the window to rebuild its widgets, leaving me out of the rebuild."].	container component: self regularView.	window damageRepairPolicy: originalDisplayPolicy.	window component invalidate.	window displayPendingInvalidation</body><body package="Store-UI" selector="subsume:">subsume: aWindow	| regularView |	originalDisplayPolicy := aWindow damageRepairPolicy.	aWindow damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	regularView := aWindow component.	aWindow component: self.	self add: regularView.	self addProgressView.	self invalidate.	aWindow displayPendingInvalidation</body></methods><methods><class-id>Store.StoreProgressOverlay</class-id> <category>private</category><body package="Store-UI" selector="backdrop">backdrop	"Return the regularView rendered on an Image and then darkened. If we've done it once already and the size of the window hasn't changed, just use the same one as last time."	| gc tempSurface |	(background notNil and: [background extent = self bounds extent])		ifTrue: [^background].	tempSurface := Pixmap extent: self bounds extent.	gc := tempSurface graphicsContext.	self regularView displayOn: gc.	background := tempSurface asImage.	self washOutBackdropImage.	^background</body><body package="Store-UI" selector="dropdownGradient">dropdownGradient	| image pgc color pm f |	dropdownGradient ifNotNil: [^dropdownGradient].	pm := Pixmap extent: 1 @ self progressView frame height.	pgc := pm graphicsContext.	pgc		paint: (ColorValue brightness: 0.9);		displayRectangle: pm bounds.	image := pm asImage.	0 to: image height - 1		do: 			[:y |			color := image valueAtPoint: 0 @ y.			f := y / image height.			f &lt; (1 / 3)				ifTrue: 					[color := ColorValue								hue: color hue								saturation: color saturation								brightness: (1 - color brightness) * (1 - (f * 3)) + color brightness].			f &gt; (2 / 3)				ifTrue: 					[color := ColorValue								hue: color hue								saturation: color saturation								brightness: color brightness										- ((color brightness - (color brightness * 3 / 4)) * ((f - (2 / 3)) * 3))].			image				atX: 0				y: y				put: (image palette indexOfPaintNearest: color)].	^dropdownGradient := image asPattern</body><body package="Store-UI" selector="dropdownRectangle">dropdownRectangle	"Return the rectangle to show as the dropdown rectangle."	| box |	box := self progressView frame.	^box left @ 0 corner: box corner</body><body package="Store-UI" selector="progressView">progressView	^self children last</body><body package="Store-UI" selector="regularView">regularView	^self children first</body><body package="Store-UI" selector="washOutBackdropImage">washOutBackdropImage	"In most cases, we have a FixedPalette of high depth and can do this much faster than using the palette, so take advantage of just having the bytes when we can."	| bits currentColor |	(background bitsPerPixel &gt;= 24		and: [background palette isKindOf: FixedPalette])			ifTrue: 				[bits := background bitsInstVar.				1 to: bits size do: [:n | bits at: n put: (bits at: n) * 6 // 10]]			ifFalse: 				[0 to: background width - 1					do: 						[:x |						0 to: background height - 1							do: 								[:y |								currentColor := background valueAtPoint: x @ y.								background									atX: x									y: y									put: (background palette indexOfPaintNearest: (ColorValue													red: currentColor red * 0.6													green: currentColor green * 0.6													blue: currentColor blue * 0.6))]]]</body></methods><methods><class-id>Store.StoreProgressOverlay</class-id> <category>displaying</category><body package="Store-UI" selector="displayChild:on:">displayChild: aChild on: aGC	aChild = self regularView		ifTrue: 			["Don't bother displaying the washed out image if we're just going to overwrite that with the dropdown panel (which is true 99% of the time as the health process spinner fires updates."			(self dropdownRectangle contains: aGC clippingBounds)				ifFalse: [self backdrop displayOn: aGC]]		ifFalse: 			[self displayDropdownOn: aGC.			super displayChild: aChild on: aGC]</body><body package="Store-UI" selector="displayDropdownOn:">displayDropdownOn: aGC	| box originalPaint |	box := self dropdownRectangle.	(aGC clippingBounds intersects: box) ifFalse: [^self].	originalPaint := aGC paint.	aGC paint: self dropdownGradient.	aGC displayRectangle: (box topLeft corner: box bottomRight).	"aGC displayRectangle: (box leftCenter + (box height half @ 0)				corner: box bottomRight - (box height half @ 0)).	aGC		displayWedgeBoundedBy: (box topLeft extent: box height asPoint)		startAngle: 90		sweepAngle: 360.	aGC		displayWedgeBoundedBy: (box topRight - (box height @ 0)				corner: box bottomRight)		startAngle: 0		sweepAngle: 360."	aGC paint: originalPaint</body></methods><methods><class-id>Store.StoreProgressOverlay class</class-id> <category>utility</category><body package="Store-UI" selector="subsume:while:">subsume: aWindowOrNil while: aBlock	self subsumeAll: (Array with: aWindowOrNil) while: aBlock</body><body package="Store-UI" selector="subsumeAll:while:">subsumeAll: aWindowCollection while: aBlock	"Only a ScheduledWindow should have an overlay."	| overlays windowsToSubsume |	windowsToSubsume := aWindowCollection				select: [:each | each notNil and: [each isOpen and: [each hasStoreProgressOverlay not]]].	^	[overlays := windowsToSubsume collect: 					[:each |					(self new)						subsume: each;						yourself].	aBlock value]			ensure: [overlays do: #restoreOriginal]</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	^tag existsInImage</body><body package="Store-Change Management" selector="isForOverriddenMethod">isForOverriddenMethod	^ false</body><body package="Store-Change Management" selector="isMoveModification">isMoveModification		^false</body><body package="Store-Change Management" selector="isPackageLoaded">isPackageLoaded	^package getImagePundle basicallySameVersionAsPublished: package</body><body package="Store-Change Management" selector="isPublishedModification">isPublishedModification		^false</body><body package="Store-Change Management" selector="isTextModification">isTextModification		^false</body><body package="Store-Change Management" selector="notOriginallyInImage">notOriginallyInImage	^self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aMod 	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>accessing</category><body package="Store-Change Management" selector="description">description	self subclassResponsibility</body><body package="Store-Change Management" selector="existsInPackage">existsInPackage	self subclassResponsibility</body><body package="Store-Change Management" selector="package">package	^package</body><body package="Store-Change Management" selector="package:">package: aPackage	package := aPackage.	tag == nil		ifFalse: [ tag package: aPackage ].</body><body package="Store-Change Management" selector="packageName">packageName	^package isNil		ifTrue: ['']		ifFalse: [package name]</body><body package="Store-Change Management" selector="record">record	"Added by Philippe F. Monnet of Andersen Consulting	Added for compatibity with TT_Modification. 	This is called by: TT_MergeData &gt; resolutionRecordForTag: aTag packageNamed: aName"		^nil</body><body package="Store-Change Management" selector="source">source	"Answer the source code or nil if not there."	self subclassResponsibility</body><body package="Store-Change Management" selector="tag">tag	^tag</body><body package="Store-Change Management" selector="tag:">tag: aTag	tag := aTag</body><body package="Store-Change Management" selector="timeStampString">timeStampString	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>printing</category><body package="Store-Change Management" selector="printOn:">printOn: aStream	"Print tag first and then package."	aStream nextPut: $&lt;.	tag printOn: aStream.	aStream nextPut: $@.	self package printOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>actions</category><body package="Store-Change Management" selector="apply">apply	"Apply a modification to the image. 	Answer true if the application is successful."	self subclassResponsibility</body><body package="Store-Change Management" selector="moveFromPackage:to:">moveFromPackage: oldPkg to: newPkg 	"Ask if this modification should be moved to the package it was loaded from."	(oldPkg isNil or: 		[Dialog confirm: ((#DoYouWishToMove1LoadedFrom3s &lt;&lt; #store &gt;&gt; 'Do you wish to move &lt;1p&gt;&lt;n&gt;from its current package [&lt;2s&gt;] &lt;n&gt;to the package it was loaded from [&lt;3s&gt;] ?') 						expandMacrosWith: tag						with: oldPkg name						with: newPkg name)				initialAnswer: true]) 		ifTrue: [tag moveToPackage: newPkg]</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersionIfExists">browseSystemVersionIfExists	"Open a browser on the system version of this override if possible.	 Answer if it was possible."	^tag browseSystemVersionIfExists</body><body package="Store-Change Management" selector="className">className	^tag className</body><body package="Store-Change Management" selector="cleanSourceFrom:">cleanSourceFrom: aString	"Return a version of aString which has a cr line-end convention imposed upon it."	^Kernel.Change new cleanSourceFrom: aString</body><body package="Store-Change Management" selector="componentString">componentString	^(#x1s2sComponentString &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: &lt;2s&gt;')		expandMacrosWith: package classDescription with: package name.</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream	"Fileout the change onto aStream."	tag fileOutOn: aStream from: self record in: package</body><body package="Store-Change Management" selector="hasVersionInSystem">hasVersionInSystem	^self existsInImage</body><body package="Store-Change Management" selector="isClassRelated">isClassRelated	^tag isForClass</body><body package="Store-Change Management" selector="isCommentChange">isCommentChange	^tag isCommentChange</body><body package="Store-Change Management" selector="isMethodRelated">isMethodRelated	^tag isForMethod</body><body package="Store-Change Management" selector="name">name	"Answer a name for the list."	^tag name</body><body package="Store-Change Management" selector="nonMetaClassName">nonMetaClassName	^tag nonMetaClassName</body><body package="Store-Change Management" selector="protocol">protocol	^[ tag protocol ] on: MessageNotUnderstood do:		[ :ex | ex return: nil ].</body><body package="Store-Change Management" selector="sameAsSystem">sameAsSystem	self subclassResponsibility</body><body package="Store-Change Management" selector="sameAsSystem:">sameAsSystem: list	^self sameAsSystem</body><body package="Store-Change Management" selector="selector">selector	^tag isForMethod		ifTrue: [ tag selector ]</body><body package="Store-Change Management" selector="text">text	"Asnwer the text to display in a text window."	^tag sourceTextForImage</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification." 	^tag type</body></methods><methods><class-id>Store.Glorp.InvalidStorePundleError</class-id> <category>accessing</category><body package="Store-Database Model" selector="pundle">pundle	^pundle</body><body package="Store-Database Model" selector="pundle:">pundle: aPundle	pundle := aPundle</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>fileIn/Out</category><body package="Store-UI" selector="fileOutOn:">fileOutOn: aSourceCodeStream	| sublist |	sublist := list reject: [ :mod | removed includes: mod ].	aSourceCodeStream deferInitializations.	sublist do: [ :next | next fileOutOn: aSourceCodeStream ].	aSourceCodeStream checkMethodChunkClass: nil protocol: nil.	aSourceCodeStream finishInitializations.</body><body package="Store-UI" selector="includesFileName:">includesFileName: aString	"Answer true if any of the non-removed changes in the list is 	from a file named aString."	^false</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>private</category><body package="Store-UI" selector="conflictObjectFor:">conflictObjectFor: anItem	"Answer the object to compare to. nil if there is none."	^( self conflictPundle == nil ) 		ifFalse: 			[ conflictCache at: anItem ifAbsentPut:				[ conflictPundle recordForTag: anItem tag ]			]</body><body package="Store-UI" selector="conflictSummaryForChange:">conflictSummaryForChange: change 	| protocol |	^( ( change isMethodRelated and: 		[ ( protocol := ( self conflictObjectFor: change ) protocol ) ~= ( change systemCategory ) ] ) 			ifTrue: [ #protocol1s &lt;&lt; #dialogs &gt;&gt; 'protocol &lt;1s&gt;'  expandMacrosWith: protocol ]			ifFalse: [#NoConflict &lt;&lt; #dialogs &gt;&gt; 'no conflict' ] 		  ) asText emphasizeAllWith: #italic</body><body package="Store-UI" selector="doFrom:">doFrom: firstIndex 	"Replay all the changes from the supplied index. Reset selection each time through the loop,	 so that if an error occurs, the selection is left at the item which caused it."	DbRegistry isOnlineImage ifFalse: 		[^Dialog warn: #NotConnectedToTheDatabase &lt;&lt; #store &gt;&gt; 'Not connected to the database.'].	super doFrom: firstIndex</body><body package="Store-UI" selector="doThis:">doThis: listIndex 	"Revert the change at listIndex to it's parent and update the entry."	| rec mod |	DbRegistry isOnlineImage ifFalse: 		[^Dialog warn: #NotConnectedToTheDatabase &lt;&lt; #store &gt;&gt; 'Not connected to the database.'].	mod := list at: listIndex.	(rec := self conflictObjectFor: mod) == nil ifTrue: 		[^Dialog warn: (#_1sCannotBeReverted &lt;&lt; #store &gt;&gt; '&lt;1s&gt; cannot be reverted.' expandMacrosWith: mod tag name)].	mod isCommentChange 		ifTrue: [rec loadCommentFor: mod tag actual]		ifFalse: 			[rec loadSrcIntoPackage: mod package confirm: false.			mod package changeSet forgetTag: mod tag.	"just the current one"			mod text: rec definition].	self updateSelection: listIndex</body><body package="Store-UI" selector="fieldTemplates">fieldTemplates	"return the templates for the fields (show file etc)"	^#(	#( showComponent showProtocol showConflicts )		#( componentString category conflicts))</body><body package="Store-UI" selector="filterTemplates">filterTemplates	"return the templates for the filters"	^#(	#( filterByPackage filterByType filterByClass filterByProtocol filterBySelector )		#( packageName type className category selector )        )</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>aspects</category><body package="Store-UI" selector="labelFor:">labelFor: aKey 	"Return a label for the existingText view."	| mod protocol conflictString |	aKey == #windowLabel ifTrue: [^self windowLabel].	conflictString := self conflictPundle == nil 				ifTrue: [(#notConnected &lt;&lt; #store &gt;&gt; 'not connected') asString]				ifFalse: [self conflictPundle versionString].	selectionIndex &gt; 0 		ifTrue: 			[mod := self selection.			(aKey == #imageLabel 				and: [mod tag isForMethod and: [(protocol := mod protocol) notNil]]) 					ifTrue: ['&lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: conflictString with: protocol]].	aKey == #imageLabel 		ifTrue: 			[^#FromDatabase1s2s &lt;&lt; #store &gt;&gt; 'From database: &lt;1s&gt;: &lt;2s&gt;' 				expandMacrosWith: dbIdentifier				with: conflictString].	aKey == #changeLabel 		ifTrue: 			[^selectionIndex &gt; 0 				ifTrue: [(#From1s &lt;&lt; #store &gt;&gt; 'From &lt;1s&gt;') expandMacrosWith: mod componentString]				ifFalse: [(#SelectedChange &lt;&lt; #store &gt;&gt; 'Selected Change') asString]].	^nil</body><body package="Store-UI" selector="windowLabel">windowLabel	^pundle == nil 		ifTrue: [(#PundleChangesList &lt;&lt; #store &gt;&gt; 'Pundle Changes List') asString]		ifFalse: 			[#_1s2sChangeListFrom3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt; Change List from &lt;3s&gt;' 				expandMacrosWith: pundle name				with: (pundle versionStringFor: dbIdentifier)				with: dbIdentifier asString]</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>accessing</category><body package="Store-UI" selector="conflictPundle">conflictPundle	"Answer the pundle used for comparisons. Defualt is pundle's parent."	conflictPundle == nil		ifTrue: 			[ conflictPundle := pundle parentRecord.			conflictCache := IdentityDictionary new.			 ]		ifFalse: 			[ conflictPundle isInCurrentDatabase				ifFalse:  					[ conflictPundle := pundle parentRecord.	"try to rehook"					conflictCache := IdentityDictionary new.					].			].	^conflictPundle</body><body package="Store-UI" selector="conflictTextFor:">conflictTextFor: anItem	"Asnwer the text to display in the conflict text window."	| obj |	obj := self conflictObjectFor: anItem.	^anItem tag isCommentTag		ifTrue: [ obj comment ]		ifFalse: [ obj text ]</body><body package="Store-UI" selector="dbIdentifier">dbIdentifier	^dbIdentifier</body><body package="Store-UI" selector="dbIdentifier:">dbIdentifier: aSymbol	^dbIdentifier := aSymbol asSymbol</body><body package="Store-UI" selector="noConflictTextFor:">noConflictTextFor: mod 	"Answer a Text corresponding to the conflicting text of the selected item in the system.	This is in fact, the reason why there is no text to compare to. Answer nil if okay to compare."	DbRegistry isOnlineImage ifFalse: 		[^(#NotConnectedToTheDatabase &lt;&lt; #store &gt;&gt; 'Not connected to the database.') asString].	(pundle validateDatabaseId not and: [self conflictPundle == nil]) ifTrue: 		[^#NotConnectedToDatabase1s &lt;&lt; #store &gt;&gt; 'Not connected to database: &lt;1s&gt;' expandMacrosWith: dbIdentifier].	self conflictPundle isInCurrentDatabase ifFalse: 		[^#NoLongerConnectedToDatabase1s &lt;&lt; #store &gt;&gt; 'No longer connected to database: &lt;1s&gt;' expandMacrosWith: conflictPundle dbIdentifier].	(self conflictObjectFor: mod) == nil ifTrue: 		[^((#notIn1s &lt;&lt; #store &gt;&gt; 'not in &lt;1s&gt;') expandMacrosWith: self conflictPundle displayString) asText emphasizeAllWith: #italic].	^nil</body><body package="Store-UI" selector="pundle">pundle	^pundle</body><body package="Store-UI" selector="pundle:">pundle: aPundle	pundle := aPundle</body><body package="Store-UI" selector="selectionText">selectionText	"Answer the text of the item currently selected, or nil if none."	| txt |	(txt := super selectionText) == nil 		ifTrue: 			[txt := (self selection == nil or: [self selection existsInPackage]) 						ifFalse: 							[#notIn1s &lt;&lt; #store &gt;&gt; 'not in &lt;1s&gt;' 								expandMacrosWith: self pundle displayString]						ifTrue: ['']].	^txt</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>menu messages</category><body package="Store-UI" selector="findPackage">findPackage	"Prompt and search for all changes of a given package. Select these changes"	self find: #packageName prompt: #package filter: #packageName</body><body package="Store-UI" selector="removeConflictsWithParent">removeConflictsWithParent	"Remove those changes that conflict with the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | | rec |				( removed includes: mod ) not					and: [ ( ( rec := self conflictObjectFor: mod ) == nil							or: [ ( ( rec textRepresentationForTag: mod tag ) = mod text ) not ] )						]				]			)		].	self redisplayList</body><body package="Store-UI" selector="removeEverythingNotInParent">removeEverythingNotInParent	"Remove those changes in methods not in the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | 				( removed includes: mod ) not and: 					[ ( self conflictObjectFor: mod ) == nil ] 				]			)		].	self redisplayList</body><body package="Store-UI" selector="removeMethodsNotInParent">removeMethodsNotInParent	"Remove those changes in methods not in the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | 				( removed includes: mod ) not and: 					[ mod isMethodRelated and: [ ( self conflictObjectFor: mod ) == nil ] ]				]			)		].	self redisplayList</body><body package="Store-UI" selector="removeSameSourceAsParent">removeSameSourceAsParent	"Remove those changes that are exactly the same as the conflict."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list reject: 				[ :mod | | rec |				( removed includes: mod )					or: [ ( ( rec := self conflictObjectFor: mod ) == nil							or: [ ( ( rec textRepresentationForTag: mod tag ) = mod text ) not ] )						]				]			)		].	self redisplayList</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>menu bar actions</category><body package="Store-UI" selector="toggleShowComponent">toggleShowComponent	self fieldMessage: #showComponent</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>instance creation</category><body package="Store-UI" selector="openOn:">openOn: aPundle 	^self openOn: aPundle for: aPundle anyDatabaseId</body><body package="Store-UI" selector="openOn:for:">openOn: aPundle for: dbid 	^(self new)		pundle: aPundle;		dbIdentifier: dbid;		openOn: (aPundle modificationsFor: dbid)</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>descriptors</category><body package="Store-Database Model" selector="addPackageMappingTo:">addPackageMappingTo: aDescriptor 	"For any of the Store&lt;X&gt;InPackage classes, add the mapping to the containing package"	| |	(aDescriptor newMapping: OneToOneMapping)				attributeName: #package;				join: (Join 							from: (aDescriptor table fieldNamed: 'packageRef')							to: ((self tableNamed: 'TW_Package') fieldNamed: 'primaryKey')).	^aDescriptor</body><body package="Store-Database Model" selector="addPropertiesMappingTo:">addPropertiesMappingTo: aDescriptor	"Add the properties mapping. Different between versions of Store schema"	(aDescriptor newMapping: OneToOneMapping)		attributeName: #propertiesBlob;		join: (Join from: (aDescriptor table fieldNamed: 'propertiesID') to: self blobId).</body><body package="Store-Database Model" selector="addStandardStoreDescriptorTo:forTable:andClass:">addStandardStoreDescriptorTo: aDescriptor forTable: table andClass: aClass 	| |	(aDescriptor newMapping: DirectMapping) 		from: #primaryKey to: (table fieldNamed: 'primaryKey').	"I hate typing 'primaryKey' so often, so allow 'id' as a synonym"	(aDescriptor directMapping from: #id to: 'primaryKey') beForPseudoVariable.	(aDescriptor newMapping: DirectMapping)		 from: #name to: (table fieldNamed: 'name').	self addTimestampTo: aDescriptor fromTable: table.	self addUsernameTo: aDescriptor fromTable: table.	(aDescriptor newMapping: OneToOneMapping)				attributeName: #trace;				referenceClass: aClass;				join: (Join from: (table fieldNamed: 'trace')							to: (table fieldNamed: 'primaryKey'));				shouldProxy: true."	traceMapping query returnTimedProxies: true."	"Add something to let us query on whether or not there's a trace"	(aDescriptor newMapping: DirectMapping)		beForPseudoVariable;		from: #previousID to: (table fieldNamed: 'trace').</body><body package="Store-Database Model" selector="descriptorForStoreAccessPrivilege:">descriptorForStoreAccessPrivilege: aDescriptor 	| table |	table := self tableNamed: 'TW_DBPundlePrivileges'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #pundleName				to: (table fieldNamed: 'pundleName')).	aDescriptor  addMapping: (DirectMapping from: #pundleType				to: (table fieldNamed: 'pundleType')).	aDescriptor  addMapping: (DirectMapping from: #userName				to: (table fieldNamed: 'userName')).	aDescriptor  addMapping: (DirectMapping from: #userType				to: (table fieldNamed: 'userType')).	aDescriptor  addMapping: (DirectMapping from: #privilege				to: (table fieldNamed: 'privilege')).	(aDescriptor newMapping: ConstantMapping) attributeName: #session; constantValueIsSession.	^aDescriptor</body><body package="Store-Database Model" selector="descriptorForStoreBinaryBlob:">descriptorForStoreBinaryBlob: aDescriptor 	^self descriptorForStoreBlob: aDescriptor class: StoreBinaryBlob inTable: 'TW_BinaryBlob'.</body><body package="Store-Database Model" selector="descriptorForStoreBlessing:">descriptorForStoreBlessing: aDescriptor 	| table |	table := self tableNamed: 'TW_Blessing'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #primaryKey to: (table fieldNamed: 'primaryKey').	self addTimestampTo: aDescriptor fromTable: table.	self addUsernameTo: aDescriptor fromTable: table.	(aDescriptor newMapping: OneToOneMapping)				attributeName: #comment;				join: (Join 							from: (table fieldNamed: 'commentID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey')).	(aDescriptor newMapping: DirectMapping) from: #blessingLevel to: (table fieldNamed: 'blessingLevel').	(aDescriptor newMapping: OneToOneMapping)				attributeName: #trace;				join: (Join from: (table fieldNamed: 'trace')							to: (table fieldNamed: 'primaryKey'));				shouldProxy: true.</body><body package="Store-Database Model" selector="descriptorForStoreBlob:">descriptorForStoreBlob: aDescriptor 	^self descriptorForStoreBlob: aDescriptor class: StoreBlob inTable: 'TW_Blob'.</body><body package="Store-Database Model" selector="descriptorForStoreBlob:class:inTable:">descriptorForStoreBlob: aDescriptor class: aClass inTable: aTableName	| table field conditional pkField |	table := self tableNamed: aTableName.	aDescriptor table: table.	field := table fieldNamed: 'blobType'.	conditional := aDescriptor newMapping: ConditionalMapping.	conditional 		forField: field		attribute: [:object | object validTypeField]		if: #valueIsNil: useMapping: ConstantMapping new.	conditional otherwise: (DirectMapping from: #type to: field).	pkField := table fieldNamed: 'primaryKey'.			(aDescriptor newMapping: DirectMapping) from: #primaryKey to: pkField.	(aDescriptor newMapping: AdHocMapping)				forAttribute: #next				fromDb: 					[:row :elementBuilder :context | 					| id |					id := elementBuilder valueOfField: (context translateField: field) in: row.					id := id isNil ifTrue: [-1] ifFalse: [id negated].					id &gt; 0 						ifTrue: 							[(Proxy returningOneOf: aClass where: [:each | each primaryKey = id]) 								session: aDescriptor session]						ifFalse: [nil]]				toDb: [:rows :nextBlob :nextBlobRows | 					self blobToDatabaseForRows: rows nextBlob: nextBlob nextBlobRows: nextBlobRows]				mappingFields: (Array with: field).	(aDescriptor newMapping: DirectMapping) from: #data to: (table fieldNamed: 'blobData').</body><body package="Store-Database Model" selector="descriptorForStoreBundle:">descriptorForStoreBundle: aDescriptor	| table linkTable |	table := self tableNamed: 'TW_Bundle'.	linkTable := self tableNamed: 'TW_Bundles'.	self descriptorForStorePundle: aDescriptor class: StoreBundle inTable: table.	(aDescriptor newMapping: ToManyMapping)		attributeName: #blessings;		collectionType: SortedCollection;			join:			(Join					from: (table fieldNamed: 'primaryKey')					to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'pkgID')					from: 'B'					to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'recType')).	(aDescriptor newMapping: BasicDictionaryMapping)			attributeName: #bundles;			referenceClass: StoreBundle;			orderBy: [:each | (each getTable: 'TW_Bundles') getField: 'seqNumber'];			keyField: (linkTable fieldNamed: 'seqNumber');			join:					(Join							from: (table fieldNamed: 'primaryKey')							to: (linkTable fieldNamed: 'bundleRef'));			relevantLinkTableFields:					(Array with: (linkTable fieldNamed: 'subBundleRef'))."	bundleMapping query proxyType: TimedProxy."	(aDescriptor newMapping: BasicDictionaryMapping)			attributeName: #packages;			referenceClass: StorePackage;			orderBy: [:each | (each getTable: 'TW_Packages') getField: 'seqNumber'];			keyField: ((self tableNamed: 'TW_Packages') fieldNamed: 'seqNumber');			join:				(Join					from: (table fieldNamed: 'primaryKey')					to: ((self tableNamed: 'TW_Packages') fieldNamed: 'bundleRef'));			relevantLinkTableFields:					(Array with: ((self tableNamed: 'TW_Packages') fieldNamed: 'packageRef'))."	packageMapping query proxyType: TimedProxy."</body><body package="Store-Database Model" selector="descriptorForStoreBundlePackageRelationship:">descriptorForStoreBundlePackageRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Packages'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #bundleID				to: (table fieldNamed: 'bundleRef')).	aDescriptor  addMapping: (DirectMapping from: #packageID				to: (table fieldNamed: 'packageRef')).	aDescriptor  addMapping: (DirectMapping from: #sequence				to: (table fieldNamed: 'seqNumber')).	aDescriptor  addMapping: (DirectMapping from: #expressionID				to: (table fieldNamed: 'expressionID')).</body><body package="Store-Database Model" selector="descriptorForStoreBundleSubBundleRelationship:">descriptorForStoreBundleSubBundleRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Bundles'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #bundleID				to: (table fieldNamed: 'bundleRef')).	aDescriptor  addMapping: (DirectMapping from: #subbundleID				to: (table fieldNamed: 'subbundleRef')).	aDescriptor  addMapping: (DirectMapping from: #sequence				to: (table fieldNamed: 'seqNumber')).	aDescriptor  addMapping: (DirectMapping from: #expressionID				to: (table fieldNamed: 'expressionID')).</body><body package="Store-Database Model" selector="descriptorForStoreClassDefinition:">descriptorForStoreClassDefinition: aDescriptor	| table |	table := self tableNamed: 'TW_ClassRecord'.	aDescriptor table: table.	self		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: aDescriptor describedClass.	aDescriptor		addMapping:			(DirectMapping				from: #environmentName				to: (table fieldNamed: 'environmentString')).	aDescriptor		addMapping:			(DirectMapping from: #superclassName to: (table fieldNamed: 'superclass')).	aDescriptor		addMapping:			((OneToOneMapping new)				attributeName: #definition;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'definitionID') to: self blobId)).	aDescriptor		addMapping:			((OneToOneMapping new)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'commentID') to: self blobId)).</body><body package="Store-Database Model" selector="descriptorForStoreClassDefinitionInPackage:">descriptorForStoreClassDefinitionInPackage: aDescriptor	| table orderMapping |	table := self tableNamed: 'TW_PkgClasses'.	aDescriptor table: table.	(aDescriptor newMapping: OneToOneMapping) attributeName: #package.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #definition;		join: (Join from: (table fieldNamed: 'classRef') to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey')).	orderMapping := aDescriptor newMapping: DirectMapping. 	orderMapping from: #definitionOrder to: (table fieldNamed: 'definitionOrder').	orderMapping beForPseudoVariable.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #metaclass;		join: (Join from:  (table fieldNamed: 'metaclassRef') to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey')).</body><body package="Store-Database Model" selector="descriptorForStoreClassExtension:">descriptorForStoreClassExtension: aDescriptor 	| table defLinkTable defTable methodTable methodLinkTable fullClassName sharedTable sharedLinkTable |	table := self tableNamed: 'IMAGINARY_CLASS_EXTENSION'.	aDescriptor table: table."	(aDescriptor newMapping: DirectMapping) from: #shortName to: (table fieldNamed: 'SHORTNAME').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'SHORTNAME')."	(aDescriptor newMapping: DirectMapping) from: #longName to: (table fieldNamed: 'LONGNAME').			(aDescriptor newMapping: OneToOneMapping)			attributeName: #package;			referenceClass: StorePackage.		defLinkTable := self tableNamed: 'TW_PkgClasses'.	defTable := self tableNamed: 'TW_ClassRecord'.	fullClassName := [:each |  | envString name |		envString := (each getTable: defTable) getField: (defTable fieldNamed: 'environmentString').		name := (each getTable: defTable) getField: (defTable fieldNamed: 'name').		(envString , '.'),  name] asGlorpExpression.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #classDefinition;			referenceClass: StoreClassDefinition;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (defLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: fullClassName);			relevantLinkTableFields: (Array with: (defLinkTable fieldNamed: 'classRef')).	methodTable := self tableNamed: 'TW_Method'.	methodLinkTable := self tableNamed: 'TW_Methods'.	(aDescriptor newMapping: ToManyMapping)			attributeName: #instanceMethods;			referenceClass: StoreMethod;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (methodLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: (methodTable fieldNamed: 'className')				from: 'F' 				to: (methodTable fieldNamed: 'metaString')).	(aDescriptor newMapping: ToManyMapping)			attributeName: #classMethods;			referenceClass: StoreMethod;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (methodLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: (methodTable fieldNamed: 'className')				from: 'T' 				to: (methodTable fieldNamed: 'metaString')).	sharedTable := self tableNamed: 'TW_DataElement'.	sharedLinkTable := self tableNamed: 'TW_Data'.	(aDescriptor newMapping: ToManyMapping)			attributeName: #sharedVariables;			referenceClass: StoreSharedVariable;			useLinkTable;			linkTableJoin: (Join 				from: (table fieldNamed: 'packageID')				to: (sharedLinkTable fieldNamed: 'packageRef'));			targetTableJoin: (Join				from: (table fieldNamed: 'LONGNAME')				to: (sharedTable fieldNamed: 'environmentString')).	"A complicated way of saying that the package plus one other attribute has to be there"	aDescriptor imaginaryTableIsDefinedByRelationFrom: #package to: #classDefinition.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #package to: #instanceMethods.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #package to: #classMethods.	aDescriptor buildReplacementTableSelect.</body><body package="Store-Database Model" selector="descriptorForStoreDatabaseIdentifier:">descriptorForStoreDatabaseIdentifier: aDescriptor 	| table |	table := self tableNamed: 'TW_DatabaseIdentifier'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'identityName').</body><body package="Store-Database Model" selector="descriptorForStoreMethod:">descriptorForStoreMethod: aDescriptor	"Mapping to version was missing and has been added. N.B. this version is the method type e.g. CType and has nothing to do with Store's CM versioning.  Type is needed to load ExternalInterface methods in right order - see fromDescription:trace:package:"	| table metaclassField |	table := self tableNamed: 'TW_Method'.	aDescriptor table: table.	self 		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreMethod.	(aDescriptor newMapping: OneToOneMapping)				attributeName: #source;				join: (Join 							from: (table fieldNamed: 'sourceCodeID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey')).	(aDescriptor newMapping: DirectMapping) from: #className				to: (table fieldNamed: 'className').	metaclassField := table fieldNamed: 'metaString'.	(aDescriptor newMapping: AdHocMapping) 				forAttribute: #isMetaclass				fromDb: [:row :elementBuilder :context| (elementBuilder valueOfField: (context translateField: metaclassField) in: row) includes: $T]				toDb: 					[:rows :attribute :attributeRows | 					(rows at: table) at: metaclassField 						put: (attribute ifTrue: ['T'] ifFalse: ['F'])]				mappingFields: (Array with: metaclassField).	(aDescriptor newMapping: DirectMapping)		 from: #protocol		to: (table fieldNamed: 'protocolName').	(aDescriptor newMapping: DirectMapping)		 from: #version		to: (table fieldNamed: 'version')."	(aDescriptor newMapping: OneToManyMapping) 		attributeName: #methodsInPackage;		referenceClass: StoreMethodInPackage;		beForPseudoVariable."</body><body package="Store-Database Model" selector="descriptorForStoreMethodInPackage:">descriptorForStoreMethodInPackage: aDescriptor	| table |	table := self tableNamed: 'TW_Methods'.	aDescriptor table: table.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #package.	(aDescriptor newMapping: OneToOneMapping) attributeName: #definition.</body><body package="Store-Database Model" selector="descriptorForStoreNameSpace:">descriptorForStoreNameSpace: aDescriptor	| table |	table := self tableNamed: 'TW_NameSpaceRecord'.	aDescriptor table: table.	self		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreNameSpace.	aDescriptor		addMapping:			(DirectMapping				from: #environmentName				to: (table fieldNamed: 'environmentString')).	aDescriptor		addMapping:			((OneToOneMapping new)				attributeName: #definition;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'definitionID') to: self blobId)).	aDescriptor		addMapping:			((OneToOneMapping new)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'commentID') to: self blobId)).	^aDescriptor.</body><body package="Store-Database Model" selector="descriptorForStoreNamespaceInPackage:">descriptorForStoreNamespaceInPackage: aDescriptor	| table orderMapping |	table := self tableNamed: 'TW_PkgNameSpaces'.	aDescriptor table: table.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #package.	(aDescriptor newMapping: OneToOneMapping) attributeName: #definition.	orderMapping := aDescriptor newMapping: DirectMapping. 	orderMapping from: #definitionOrder to: (table fieldNamed: 'definitionOrder').	orderMapping beForPseudoVariable.	^aDescriptor.</body><body package="Store-Database Model" selector="descriptorForStorePackage:">descriptorForStorePackage: aDescriptor	| table methodMapping classDefinitionsMapping blessingMapping sharedVariableMapping nameSpaceMapping |	table := self tableNamed: 'TW_Package'.	self descriptorForStorePundle: aDescriptor class: StorePackage inTable: table.	nameSpaceMapping := aDescriptor newMapping: ToManyMapping.	nameSpaceMapping				attributeName: #nameSpaces;				referenceClass: StoreNamespaceInPackage;				orderBy: #definitionOrder;				writeTheOrderField;				beExclusive.	nameSpaceMapping query alsoFetch: [:each | each definition].	nameSpaceMapping query alsoFetch: [:each | each definition definition].	classDefinitionsMapping := aDescriptor newMapping: ToManyMapping.	classDefinitionsMapping		attributeName: #classDefinitions;		referenceClass: StoreClassDefinitionInPackage;		orderBy: [:each | each definitionOrder];		writeTheOrderField;		beExclusive.	classDefinitionsMapping query alsoFetch: [:each | each definition].	classDefinitionsMapping query alsoFetch: [:each | each definition definition].	classDefinitionsMapping query		alsoFetch: [:each | each definition comment asOuterJoin].	classDefinitionsMapping query alsoFetch: [:each | each metaclass].	classDefinitionsMapping query alsoFetch: [:each | each metaclass definition].	classDefinitionsMapping query		alsoFetch: [:each | each metaclass comment asOuterJoin].	sharedVariableMapping := (aDescriptor newMapping: ToManyMapping)		shouldProxy: true;		attributeName: #sharedVariables;		referenceClass: StoreSharedVariableInPackage;		beExclusive.	sharedVariableMapping query alsoFetch: [:each | each definition].	sharedVariableMapping query alsoFetch: [:each | each definition definition].	sharedVariableMapping query alsoFetch: [:each | each definition comment asOuterJoin].	methodMapping := (aDescriptor newMapping: ToManyMapping)		attributeName: #methods;		referenceClass: StoreMethodInPackage;		beExclusive.	methodMapping query alsoFetch: [:each | each definition].	methodMapping query alsoFetch: [:each | each definition source].	self hasMethodComments ifTrue: [		methodMapping query alsoFetch: [:each | each definition comment asOuterJoin]].	methodMapping query expectedRows: 1000.	methodMapping collectionType: GlorpVirtualCollection.	blessingMapping := aDescriptor newMapping: ToManyMapping.	blessingMapping		attributeName: #blessings;		collectionType: SortedCollection;		join:				(Join						from: (table fieldNamed: 'primaryKey')						to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'pkgID')						from: 'P'						to: ((self tableNamed: 'TW_Blessing') fieldNamed: 'recType')).	blessingMapping query alsoFetch: [:each | each comment asOuterJoin].	"Alas, this is just too slow to just map to the DB. FullClasses is a workaround, constructing them in memory""	classesMapping := aDescriptor newMapping: ToManyMapping.	classesMapping		attributeName: #classExtensions;		join:				(Join						from: (table fieldNamed: 'primaryKey')						to:							((self tableNamed: 'IMAGINARY_CLASS_EXTENSION') fieldNamed: 'packageID')).	classesMapping query expectedRows: 100.	aDescriptor addMapping: classesMapping."	(aDescriptor newMapping: DirectMapping) from: #binFile to: (table fieldNamed: 'binFile').	(aDescriptor		newMapping: OneToOneMapping)				attributeName: #parcel;				join: (Join from: (table fieldNamed: 'parcelID') to: ((self tableNamed: 'TW_ParcelRecord') fieldNamed: 'primaryKey')).</body><body package="Store-Database Model" selector="descriptorForStoreParcelRecord:">descriptorForStoreParcelRecord: aDescriptor 	| table |	table := self tableNamed: 'TW_ParcelRecord'.	aDescriptor table: table.	self 		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreParcelRecord.	(aDescriptor newMapping: DirectMapping) from: #filename to: (table fieldNamed: 'filename').	(aDescriptor newMapping: OneToOneMapping)				attributeName: #blob;				referenceClass: StoreBinaryBlob;				join: (Join 							from: (table fieldNamed: 'blobID')							to: ((self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey')).	(aDescriptor newMapping: OneToOneMapping)				attributeName: #source;				referenceClass: StoreBinaryBlob;				join: (Join 							from: (table fieldNamed: 'sourceID')							to: ((self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey')).</body><body package="Store-Database Model" selector="descriptorForStorePundle:class:inTable:">descriptorForStorePundle: aDescriptor class: aClass inTable: table	"We can't do the inheritance thing, because it will make us use the same cache, and these share primary keys.""	(self typeResolverFor: StorePundle) register: aDescriptor."	aDescriptor table: table.	self		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: aClass.	(aDescriptor newMapping: DirectMapping)		from: #version to: (table fieldNamed: 'version').	(aDescriptor newMapping: DirectMapping)				from: #currentBlessingLevel				to: (table fieldNamed: 'blessingLevel').	(aDescriptor newMapping: OneToOneMapping)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join from: (table fieldNamed: 'commentID') to: self blobId).	self addPropertiesMappingTo: aDescriptor.	(aDescriptor newMapping: ConstantMapping) attributeName: #session; constantValueIsSession.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #versionless;		readOnly: true;		join: (Join from: (table fieldNamed: 'name') to: (table fieldNamed: 'name')).</body><body package="Store-Database Model" selector="descriptorForStoreSharedVariable:">descriptorForStoreSharedVariable: aDescriptor 	| table typeField |	table := self tableNamed: 'TW_DataElement'.	aDescriptor table: table.	self 		addStandardStoreDescriptorTo: aDescriptor		forTable: table		andClass: StoreSharedVariable.	aDescriptor addMapping: (DirectMapping from: #environmentName				to: (table fieldNamed: 'environmentString')).	aDescriptor addMapping: (DirectMapping from: #protocol				to: (table fieldNamed: 'protocolName')).	typeField := table fieldNamed: 'typeString'.	aDescriptor addMapping: (AdHocMapping 				forAttribute: #isClassVariable				fromDb: [:row :elementBuilder :context | (elementBuilder valueOfField: (context translateField: typeField) in: row) includes: $C]				toDb: 					[:rows :attribute :attributeRows | 					(rows at: table) at: typeField						put: (attribute ifTrue: ['C'] ifFalse: ['N'])]				mappingFields: (Array with: typeField)).	aDescriptor addMapping: ((OneToOneMapping new)				attributeName: #definition;				referenceClass: StoreBlob;				join: (Join 							from: (table fieldNamed: 'definitionID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey'))).	aDescriptor addMapping: ((OneToOneMapping new)				attributeName: #comment;				referenceClass: StoreBlob;				join: (Join 							from: (table fieldNamed: 'commentID')							to: ((self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey'))).	^aDescriptor</body><body package="Store-Database Model" selector="descriptorForStoreSharedVariableInPackage:">descriptorForStoreSharedVariableInPackage: aDescriptor	| table |	table := self tableNamed: 'TW_Data'.	aDescriptor table: table.	(aDescriptor newMapping: OneToOneMapping) attributeName: #package.	(aDescriptor newMapping: OneToOneMapping) attributeName: #definition.	^aDescriptor.</body><body package="Store-Database Model" selector="descriptorForStoreUserGroup:">descriptorForStoreUserGroup: aDescriptor 	| table |	table := self tableNamed: 'TW_DBUserGroup'.	aDescriptor table: table.	aDescriptor  addMapping: (DirectMapping from: #groupName				to: (table fieldNamed: 'groupName')).	aDescriptor  addMapping: (DirectMapping from: #userName				to: (table fieldNamed: 'userName')).	aDescriptor  addMapping: (DirectMapping from: #type				to: (table fieldNamed: 'type')).	(aDescriptor newMapping: ConstantMapping) attributeName: #session; constantValueIsSession.	^aDescriptor</body><body package="Store-Database Model" selector="descriptorForStoreVersionlessBundle:">descriptorForStoreVersionlessBundle: aDescriptor	| table |	table := self tableNamed: 'TW_Bundle'.	self descriptorForStoreVersionlessPundle: aDescriptor class: StoreVersionlessBundle table: table</body><body package="Store-Database Model" selector="descriptorForStoreVersionlessPackage:">descriptorForStoreVersionlessPackage: aDescriptor	| table |	table := self tableNamed: 'TW_Package'.	self descriptorForStoreVersionlessPundle: aDescriptor class: StoreVersionlessPackage table: table</body><body package="Store-Database Model" selector="descriptorForStoreVersionlessPundle:class:table:">descriptorForStoreVersionlessPundle: aDescriptor class: aClass table: table	| nameMapping field nameExpression versionMapping commentMapping |	aDescriptor table: table.	field := table fieldNamed: 'name'.	nameExpression := [:each | ((each getTable: table) getField: field) distinct] asGlorpExpression.	nameMapping := DirectMapping from: #name to: nameExpression.	nameMapping readOnly: true.	aDescriptor addMapping: nameMapping.	aDescriptor keyFields: (Array with: nameExpression).	versionMapping := OneToManyMapping new		attributeName: #versions;		referenceClass: aClass pundleClass;		orderBy: [:each | each timestamp descending];		join: (Join 				from: nameExpression				to: field).	versionMapping readOnly: true.	versionMapping controlsTables: false.	aDescriptor addMapping: versionMapping."	timestampField := table fieldNamed: self timestampFieldName.""	maximumTimestampExpression := [:each | ((each getTable: table) getField: timestampField) max] asGlorpExpression."	"I'd really rather have these as a 1-1 to the most recent version, but that requires a group by that I'm not sure how to manage"	commentMapping := (aDescriptor newMapping: ToManyMapping)		attributeName: #comment;		referenceClass: StoreBlob;		useLinkTable;		orderBy: [:each | ((each getTable: table) getField: self timestampFieldName) descending];		readOnly: true;		join: (Join			from: nameExpression			to: field);		relevantLinkTableFields: (Array with: (table fieldNamed: 'commentID')).	commentMapping query limit: 1."	propertyMapping := (aDescriptor newMapping: ToManyMapping)		attributeName: #properties;		referenceClass: StoreBlob;		useLinkTable;		readOnly: true;		orderBy: [:each | ((each getTable: table) getField: self timestampFieldName) descending];		join: (Join			from: nameExpression			to: field);		relevantLinkTableFields: (Array with: (table fieldNamed: 'propertiesID')).	propertyMapping query limit: 1."</body><body package="Store-Database Model" selector="typeResolverForStorePundle">typeResolverForStorePundle	| resolver |	resolver := HorizontalTypeResolver forRootClass: StorePundle.	resolver useSingleQuery: true.	^resolver.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>tables</category><body package="Store-Database Model" selector="binaryBlobId">binaryBlobId	^(self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey'.</body><body package="Store-Database Model" selector="blobId">blobId	^(self tableNamed: 'TW_Blob') fieldNamed: 'primaryKey'.</body><body package="Store-Database Model" selector="createStandardAndVersionRecordFieldsIn:">createStandardAndVersionRecordFieldsIn: aTable	| nameField timeStampField traceField field |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable))		bePrimaryKey.	(nameField := aTable createFieldNamed: 'name' type: (platform varChar: 255)) beIndexed.	nameField beNullable: false.	(timeStampField := aTable createFieldNamed: self timestampFieldName type: platform int4) beIndexed.	timeStampField beNullable: false.	field := aTable createFieldNamed: 'version' type: (platform varChar: 255).	field beIndexed.	field beNullable: false.	aTable createFieldNamed: 'userName' type: (platform varChar: 255).	(traceField := (aTable createFieldNamed: 'trace' type: platform int4) defaultValue: 0) beIndexed.	traceField beNullable: false.</body><body package="Store-Database Model" selector="createStandardRecordFieldsIn:">createStandardRecordFieldsIn: aTable	| nameField timeStampField traceField |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable))		bePrimaryKey.	(nameField := aTable createFieldNamed: 'name' type: (platform varChar: 255)) beIndexed.	nameField beNullable: false.	(timeStampField := aTable createFieldNamed: self timestampFieldName type: platform int4) beIndexed.	timeStampField beNullable: false.	aTable createFieldNamed: 'userName' type: (platform varChar: 255).	(traceField := (aTable createFieldNamed: 'trace' type: platform int4) defaultValue: 0) beIndexed.	traceField beNullable: false.</body><body package="Store-Database Model" selector="createVersionedRecordFieldsIn:">createVersionedRecordFieldsIn: aTable	| field |	field := aTable createFieldNamed: 'version' type: (platform varChar: 255).	field beIndexed.	field beNullable: false.	self createStandardRecordFieldsIn: aTable.</body><body package="Store-Database Model" selector="packageId">packageId	^(self tableNamed: 'TW_Package') fieldNamed: 'primaryKey'.</body><body package="Store-Database Model" selector="supportsTableSpaceBasedForeignKey">supportsTableSpaceBasedForeignKey	platform supportsPhysicalSpaces ifFalse: [^true].	platform class = SQLServerPlatform and: [^Store.Policies tableSpacePolicy allTableSpacesAreEqual].	^true</body><body package="Store-Database Model" selector="tableForIMAGINARY_CLASS_EXTENSION:">tableForIMAGINARY_CLASS_EXTENSION: aTable 	| pkgId |	aTable isImaginary: true.	(aTable createFieldNamed: 'LONGNAME' type: (platform varChar: 255)) bePrimaryKey.	pkgId := aTable createFieldNamed: 'packageID' type: platform int4.	aTable addForeignKeyFrom: pkgId		to: ((self tableNamed: 'TW_Package') fieldNamed: 'primaryKey').</body><body package="Store-Database Model" selector="tableForTW_BINARYBLOB:">tableForTW_BINARYBLOB: aTable 	| typeField |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable)) 		bePrimaryKey.	typeField := aTable createFieldNamed: 'blobType' type: platform int4.	typeField beNullable: false.	aTable createFieldNamed: 'blobData' type: platform blob.	aTable propertyAt: #tableSpaceName put: StoreBinaryBlob tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBinaryBlob tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_BLESSING:">tableForTW_BLESSING: aTable 	| commentId packageId foreignKey |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable)) 		bePrimaryKey.	(aTable createFieldNamed: self timestampFieldName type: platform int4) beIndexed.	aTable createFieldNamed: 'userName' type: (platform varChar: 255).	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId		to: self blobId.	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'blessingLevel' type: platform int4.	((aTable createFieldNamed: 'trace' type: platform int4) defaultValue: 0) beIndexed.		packageId := aTable createFieldNamed: 'pkgID' type: platform int4.	"This is an internal foreign key, and thus is always supported"	aTable createFieldNamed: 'recType' type: (platform varChar: 255).	aTable addIndexForField: packageId.	aTable propertyAt: #tableSpaceName put: StoreBlessing tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBlessing tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_BLOB:">tableForTW_BLOB: aTable 	| typeField |	(aTable createFieldNamed: 'primaryKey' type: (self sequenceFor: aTable)) 		bePrimaryKey.	typeField := aTable createFieldNamed: 'blobType' type: platform int4.	typeField beNullable: false.	aTable createFieldNamed: 'blobData' type: platform blob.	aTable propertyAt: #tableSpaceName put: StoreBlob tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBlob tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_BUNDLE:">tableForTW_BUNDLE: aTable	| commentId propId foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	aTable createFieldNamed: 'blessingLevel' type: platform int4.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	commentId defaultValue: 0.	"This foreignKey has a default, so we never actually create it"		foreignKey shouldCreateInDatabase: false.	propId := aTable createFieldNamed: 'propertiesID' type: platform int4.	propId defaultValue: 0.	propId beIndexed.	foreignKey := aTable addForeignKeyFrom: propId to: self blobId.	"This foreignKey has a default, so we never actually create it"	foreignKey shouldCreateInDatabase: false.	aTable		createFieldNamed: 'vanguardID'		type: (platform varChar: 255).	aTable		createFieldNamed: 'rearguardID'		type: (platform varChar: 255).	aTable addUniqueConstraintFor: (Array with: (aTable fieldNamed: 'version') with: (aTable fieldNamed: 'name')).	aTable createFieldNamed: 'vanguardStr' type: (platform varChar: 255).	aTable createFieldNamed: 'rearguardStr' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreBundle tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBundle tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_BUNDLES:">tableForTW_BUNDLES: aTable 	| constraint expId bundleRef subBundleRef foreignKey |	bundleRef := aTable createFieldNamed: 'bundleRef' type: platform int4.	bundleRef bePrimaryKey.	constraint := aTable addForeignKeyFrom: bundleRef		to: ((self tableNamed: 'TW_Bundle') fieldNamed: 'primaryKey').	constraint name: 'BUNDLEREF_CONSTRAINT'.	expId := aTable createFieldNamed: 'expressionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: expId		to: self blobId.		"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	(aTable createFieldNamed: 'seqNumber' type: platform int4) bePrimaryKey.	subBundleRef := aTable createFieldNamed: 'subBundleRef' type: platform int4.	constraint := aTable addForeignKeyFrom: subBundleRef		to: ((self tableNamed: 'TW_Bundle') fieldNamed: 'primaryKey').	constraint name: 'SUBBUNDLEREF_CONSTRAINT'.	aTable addIndexForField: bundleRef and: subBundleRef.	"This seems to make a big difference for postgresql."	aTable addIndexForField: subBundleRef.	aTable propertyAt: #tableSpaceName put: StoreBundle tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreBundle tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_CLASSRECORD:">tableForTW_CLASSRECORD: aTable	| defId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	defId := aTable createFieldNamed: 'definitionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: defId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	"This foreignKey has a default, so we never create it"	foreignKey shouldCreateInDatabase: false.	(aTable createFieldNamed: 'environmentString' type: (platform varChar: 255)) beIndexed.	aTable createFieldNamed: 'superclass' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreClassDefinition tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreClassDefinition tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_DATA:">tableForTW_DATA: aTable 	"All foreign keys talk to tables in the same tableSpace"	| packageRef dataRef |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	aTable addForeignKeyFrom: packageRef		to: self packageId.	packageRef bePrimaryKey.	dataRef := aTable createFieldNamed: 'dataRef' type: platform int4.	aTable addForeignKeyFrom: dataRef		to: ((self tableNamed: 'TW_DataElement') fieldNamed: 'primaryKey').	dataRef bePrimaryKey.	aTable addIndexForField: dataRef.	aTable propertyAt: #tableSpaceName put: StoreSharedVariable tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreSharedVariable tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_DATABASEIDENTIFIER:">tableForTW_DATABASEIDENTIFIER: aTable 	(aTable createFieldNamed: 'identityName' type: (platform varChar: 255)) 		bePrimaryKey.	aTable propertyAt: #tableSpaceName put: StoreObject tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreObject tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_DATAELEMENT:">tableForTW_DATAELEMENT: aTable	| defId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	defId := aTable createFieldNamed: 'definitionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: defId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	"This foreignKey has a Default, so we never create it"	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'environmentString' type: (platform varChar: 255).	aTable createFieldNamed: 'protocolName' type: (platform varChar: 255).	aTable createFieldNamed: 'typeString' type: (platform varChar: 1).	aTable propertyAt: #tableSpaceName put: StoreSharedVariable tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreSharedVariable tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_DBPUNDLEPRIVILEGES:">tableForTW_DBPUNDLEPRIVILEGES: aTable 	(aTable createFieldNamed: 'pundleName' type: (platform varChar: 255)) 		bePrimaryKey.	(aTable createFieldNamed: 'pundleType' type: (platform varChar: 1)) 		bePrimaryKey.	(aTable createFieldNamed: 'userName' type: (platform varChar: 255)) 		bePrimaryKey.	(aTable createFieldNamed: 'userType' type: (platform varChar: 1)) 		bePrimaryKey.	aTable createFieldNamed: 'privilege' type: (platform varChar: 32).	aTable propertyAt: #tableSpaceName put: StoreAccessPrivilege tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreAccessPrivilege tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_DBUSERGROUP:">tableForTW_DBUSERGROUP: aTable 	(aTable createFieldNamed: 'groupName' type: (platform varChar: 255)) 		bePrimaryKey.	(aTable createFieldNamed: 'userName' type: (platform varChar: 255)) 		bePrimaryKey.	aTable createFieldNamed: 'type' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreUserGroup tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreUserGroup tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_METHOD:">tableForTW_METHOD: aTable	"Mapping to version was missing and has been added.  N.B. this version is the method type e.g. CType and has nothing to do with Store's CM versioning.	At the bottom, we remove the automatically created 'name' index (from createStandardRecordFieldsInTable:) and add it back as a compound index on name and classNameField	Unlike other tables with version field, this one CAN be nil (and usually is)"	| srcId classNameField versionField foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	versionField := (aTable fieldNamed: 'version').	versionField beNullable: true.		srcId := aTable createFieldNamed: 'sourceCodeID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: srcId		to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	(classNameField := aTable createFieldNamed: 'className' type: (platform varChar: 255)) beIndexed.	aTable createFieldNamed: 'metaString' type: (platform varChar: 4).	(aTable createFieldNamed: 'protocolName' type: (platform varChar: 255)) beIndexed.	(aTable fieldNamed: 'name' ifAbsent: [nil] caseSensitive: false) ifNotNil: 		[:value | 		aTable indexes removeAllSuchThat: [:each | each indexesField: value]. 		aTable addIndexForField: value and: classNameField].	aTable propertyAt: #tableSpaceName put: StoreMethod tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreMethod tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_METHODS:">tableForTW_METHODS: aTable 	| packageRef methodRef foreignKey |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	foreignKey := aTable addForeignKeyFrom: packageRef		to: self packageId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	packageRef bePrimaryKey.	methodRef := aTable createFieldNamed: 'methodRef' type: platform int4.	aTable addForeignKeyFrom: methodRef		to: ((self tableNamed: 'TW_Method') fieldNamed: 'primaryKey').	"This foreignKey is in the same tableSpace"	methodRef bePrimaryKey.	"This seems to make a big difference for postgresql"	aTable addIndexForField: methodRef.	aTable propertyAt: #tableSpaceName put: StoreMethod tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreMethod tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_NAMESPACERECORD:">tableForTW_NAMESPACERECORD: aTable	| defId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	defId := aTable createFieldNamed: 'definitionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: defId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'environmentString' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StoreNameSpace tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreNameSpace tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_PACKAGE:">tableForTW_PACKAGE: aTable	| commentId propId parcelId foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	aTable createFieldNamed: 'blessingLevel' type: platform int4.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	commentId defaultValue: 0.	"We never create this FK because it has a default"	foreignKey shouldCreateInDatabase: false.	(propId := aTable createFieldNamed: 'propertiesID' type: platform int4) beIndexed.	foreignKey := aTable addForeignKeyFrom: propId to: self blobId.	propId defaultValue: 0.	foreignKey name: 'TW_Package_TW_Blob_PropID'.	"We never create this FK because it has a default"	foreignKey shouldCreateInDatabase: false.	aTable createFieldNamed: 'binFile' type: (platform varChar: 255).	parcelId := aTable createFieldNamed: 'parcelID' type: platform int4.	aTable addUniqueConstraintFor: (Array with: (aTable fieldNamed: 'version') with: (aTable fieldNamed: 'name')).	"We always create this FK because both tables are always in the same table space"	aTable addForeignKeyFrom: parcelId to: ((self tableNamed: 'TW_ParcelRecord') fieldNamed: 'primaryKey').	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_PACKAGES:">tableForTW_PACKAGES: aTable	| expId bundleRef packageRef foreignKey |	bundleRef := aTable createFieldNamed: 'bundleRef' type: platform int4.	bundleRef bePrimaryKey.	aTable		addForeignKeyFrom: bundleRef		to: ((self tableNamed: 'TW_Bundle') fieldNamed: 'primaryKey').	expId := aTable createFieldNamed: 'expressionID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: expId to: self blobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	(aTable createFieldNamed: 'seqNumber' type: platform int4) bePrimaryKey.	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	"This foreignKey is always in the same tableSpace so we always create it"	aTable addForeignKeyFrom: packageRef to: self packageId.	aTable addIndexForField: bundleRef and: packageRef.	"This seems to make a big difference for Postgresql."	aTable addIndexForField: packageRef.	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_PARCELRECORD:">tableForTW_PARCELRECORD: aTable 	| blobId sourceId pundleId foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	pundleId := aTable createFieldNamed: 'pundleID' type: platform int4.	pundleId defaultValue: 0.	blobId := aTable createFieldNamed: 'blobID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: blobId		to: self binaryBlobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	sourceId := aTable createFieldNamed: 'sourceID' type: platform int4.	foreignKey := aTable addForeignKeyFrom: sourceId		to: self binaryBlobId.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	aTable createFieldNamed: 'filename' type: (platform varChar: 255).	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_PKGCLASSES:">tableForTW_PKGCLASSES: aTable	"Primary key is packageRef + classRef, and thus an system index will be created for that"		| constraint packageRef classRef metaclassRef |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	packageRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	aTable addForeignKeyFrom: packageRef to: self packageId.	classRef := aTable createFieldNamed: 'classRef' type: platform int4.	classRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	constraint := aTable addForeignKeyFrom: classRef to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey').	constraint name: 'CLASSREF_CONSTRAINT'.	metaclassRef := aTable createFieldNamed: 'metaclassRef' type: platform int4.	"This foreignKey is always in the same table space, so we always create it"	constraint := aTable addForeignKeyFrom: metaclassRef to: ((self tableNamed: 'TW_ClassRecord') fieldNamed: 'primaryKey').	constraint name: 'METACLASSREF_CONSTRAINT'.	aTable createFieldNamed: 'definitionOrder' type: platform int4.	"This seems to make a big difference for postgresql."	aTable addIndexForField: classRef.	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_PKGNAMESPACES:">tableForTW_PKGNAMESPACES: aTable 	| packageRef nameSpaceRef |	packageRef := aTable createFieldNamed: 'packageRef' type: platform int4.	packageRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	aTable addForeignKeyFrom: packageRef		to: (self packageId).	nameSpaceRef := aTable createFieldNamed: 'nameSpaceRef' type: platform int4.	nameSpaceRef bePrimaryKey.	"This foreignKey is always in the same table space, so we always create it"	aTable addForeignKeyFrom: nameSpaceRef		to: ((self tableNamed: 'TW_NamespaceRecord') fieldNamed: 'primaryKey').	(aTable createFieldNamed: 'definitionOrder' type: platform int4).	"This seems to make a big difference for postgresql"	aTable addIndexForField: nameSpaceRef.	aTable propertyAt: #tableSpaceName put: StorePackage tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StorePackage tableSpaceName , '.' , session schema].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>classes</category><body package="Store-Database Model" selector="addPropertiesToClassModel:">addPropertiesToClassModel: aClassModel	"Varies by schema version"	aClassModel newAttributeNamed: #propertiesBlob type: StoreBlob.</body><body package="Store-Database Model" selector="addTimestampTo:fromTable:">addTimestampTo: aDescriptor fromTable: table	"Work around the hack they did in StoreForInterbase to avoid using reserved words"	| field fieldName |	fieldName := self timestampFieldName.	field := table fieldNamed: fieldName.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #timestamp		fromDb: 			[:row :elementBuilder :context |			| value index |			index := context canTranslateFields						ifTrue: [context translateField: field]						ifFalse: [context].			value := elementBuilder valueOfField: index in: row.			value isNil				ifTrue: [nil]				ifFalse: 					[value &lt; 0 ifTrue: [value := 0].					Dialect timestampClass fromSeconds: value + self timestampOffset]]		toDb: 			[:rows :attribute :targetRows |			"The timestamp can actually be a query object if we're doing a subselect"			self				convertTimestampToDbInRows: rows				attribute: attribute				forTable: table				field: field]		mappingFields: (Array with: field)</body><body package="Store-Database Model" selector="addUsernameTo:fromTable:">addUsernameTo: aDescriptor fromTable: table 	"We could use a DirectMapping, but that wouldn't allow us to have default values:"	aDescriptor addMapping: (DirectMapping from: #username				to: (table fieldNamed: 'userName'))."This doesn't let us query, and we're only reading right now anyway...	| field |	field := table fieldNamed: 'USERNAME'.	aDescriptor addMapping: (AdHocMapping 				forAttribute: #username				fromDb: [:row | row atIndex: field position]				toDb: 					[:rows :attribute | 					| name |					name := attribute first 								ifNil: [aDescriptor session accessor currentLogin username].					(rows at: table) atIndex: field position put: name]				mappingFields: (Array with: field))"</body><body package="Store-Database Model" selector="blobToDatabaseForRows:nextBlob:nextBlobRows:">blobToDatabaseForRows: rows nextBlob: nextBlob nextBlobRows: nextBlobRows	| rowMap me table pkField field rowArray |	nextBlob isNil ifTrue: [^nil].	rowArray := rows asArray.	table := rowArray first table.	pkField := table fieldNamed: 'primaryKey'.	field := table fieldNamed: 'blobType'.	rowMap := RowMap forRows: rows.	"somewhat of a hack"	nextBlobRows do: [:each | rowMap addRow: each].	me := rowArray first owner.	rowMap		unifyField: pkField		key: nextBlob		withField: field		key: me		transformationForward: [:value | value isNil ifTrue: [nil] ifFalse: [value * -1]]		inverse: [:value | value isNil ifTrue: [nil] ifFalse: [value * -1]].		"Now return a sensible value for queries"	(rows at: table) at: field.</body><body package="Store-Database Model" selector="classModelForStoreAccessPrivilege:">classModelForStoreAccessPrivilege: aClassModel	aClassModel newAttributeNamed: #pundleName type: String.	aClassModel newAttributeNamed: #pundleType type: String.	aClassModel newAttributeNamed: #userName type: String.	aClassModel newAttributeNamed: #userType type: String.	aClassModel newAttributeNamed: #privilege type: String.</body><body package="Store-Database Model" selector="classModelForStoreBinaryBlob:">classModelForStoreBinaryBlob: aClassModel	^self classModelForStoreBlob: aClassModel.</body><body package="Store-Database Model" selector="classModelForStoreBlessing:">classModelForStoreBlessing: aClassModel	aClassModel newAttributeNamed: #primaryKey.	aClassModel newAttributeNamed: #blessingLevel.	aClassModel newAttributeNamed: #comment type: StoreBlob.	aClassModel newAttributeNamed: #timestamp.	aClassModel newAttributeNamed: #username.	aClassModel newAttributeNamed: #trace type: StoreBlessing.</body><body package="Store-Database Model" selector="classModelForStoreBlob:">classModelForStoreBlob: aClassModel	aClassModel newAttributeNamed: #type.	aClassModel newAttributeNamed: #primaryKey.	aClassModel newAttributeNamed: #next.	aClassModel newAttributeNamed: #data.</body><body package="Store-Database Model" selector="classModelForStoreBundle:">classModelForStoreBundle: aClassModel	self classModelForStorePundle: aClassModel.	aClassModel newAttributeNamed: #bundles collection: Dictionary of: StoreBundle.	aClassModel newAttributeNamed: #packages collection: Dictionary of: StorePackage.	aClassModel newAttributeNamed: #versionless type: StoreVersionlessBundle.</body><body package="Store-Database Model" selector="classModelForStoreBundlePackageRelationship:">classModelForStoreBundlePackageRelationship: aClassModel	aClassModel newAttributeNamed: #bundleID.	aClassModel newAttributeNamed: #packageID.	aClassModel newAttributeNamed: #sequence.	aClassModel newAttributeNamed: #expressionID.</body><body package="Store-Database Model" selector="classModelForStoreBundleSubBundleRelationship:">classModelForStoreBundleSubBundleRelationship: aClassModel	aClassModel newAttributeNamed: #bundleID.	aClassModel newAttributeNamed: #subbundleID.	aClassModel newAttributeNamed: #sequence.	aClassModel newAttributeNamed: #expressionID.</body><body package="Store-Database Model" selector="classModelForStoreClassDefinitionInPackage:">classModelForStoreClassDefinitionInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreClassDefinition.	aClassModel newAttributeNamed: #metaclass type: StoreClassDefinition.</body><body package="Store-Database Model" selector="classModelForStoreClassExtension:">classModelForStoreClassExtension: aClassModel	aClassModel newAttributeNamed: #classDefinition type: StoreClassDefinition.	aClassModel newAttributeNamed: #classMethods collectionOf: StoreMethod.	aClassModel newAttributeNamed: #instanceMethods collectionOf: StoreMethod.	aClassModel newAttributeNamed: #sharedVariables type: StoreSharedVariable.	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #longName type: String.	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #longName type: StoreMetaclassExtension.</body><body package="Store-Database Model" selector="classModelForStoreDatabaseIdentifier:">classModelForStoreDatabaseIdentifier: aClassModel	aClassModel newAttributeNamed: #name type: Symbol.</body><body package="Store-Database Model" selector="classModelForStoreMetaclassExtension:">classModelForStoreMetaclassExtension: aClassModel	aClassModel newAttributeNamed: #mainClass type: StoreClassExtension.</body><body package="Store-Database Model" selector="classModelForStoreMethod:">classModelForStoreMethod: aClassModel	self classModelForStoreSourceObject: aClassModel.	aClassModel newAttributeNamed: #source type: StoreBlob.	aClassModel newAttributeNamed: #className type: String.	aClassModel newAttributeNamed: #isMetaclass type: Boolean.	aClassModel newAttributeNamed: #protocol type: Symbol.</body><body package="Store-Database Model" selector="classModelForStoreMethodInPackage:">classModelForStoreMethodInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreMethod.</body><body package="Store-Database Model" selector="classModelForStoreNamespaceInPackage:">classModelForStoreNamespaceInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreNameSpace.</body><body package="Store-Database Model" selector="classModelForStorePackage:">classModelForStorePackage: aClassModel	self classModelForStorePundle: aClassModel.	aClassModel newAttributeNamed: #methods collectionOf: StoreMethodInPackage.	aClassModel newAttributeNamed: #classDefinitions collectionOf: StoreClassDefinitionInPackage.	aClassModel newAttributeNamed: #nameSpaces collectionOf: StoreNamespaceInPackage.	aClassModel newAttributeNamed: #sharedVariables collectionOf: StoreSharedVariableInPackage.	aClassModel newAttributeNamed: #parcel type: StoreParcelRecord.	aClassModel newAttributeNamed: #binFile type: String.	aClassModel newAttributeNamed: #versionless type: StoreVersionlessPackage.</body><body package="Store-Database Model" selector="classModelForStoreParcelRecord:">classModelForStoreParcelRecord: aClassModel	aClassModel newAttributeNamed: #primaryKey.	aClassModel newAttributeNamed: #timestamp.	aClassModel newAttributeNamed: #username type: String.	aClassModel newAttributeNamed: #trace type: StoreParcelRecord.	aClassModel newAttributeNamed: #blob type: StoreBinaryBlob.	aClassModel newAttributeNamed: #source type: StoreBinaryBlob.	aClassModel newAttributeNamed: #filename type: String.</body><body package="Store-Database Model" selector="classModelForStorePundle:">classModelForStorePundle: aClassModel	self classModelForStoreSourceObject: aClassModel.	aClassModel newAttributeNamed: #comment type: StoreBlob.	self addPropertiesToClassModel: aClassModel.	aClassModel newAttributeNamed: #version type: String.	aClassModel newAttributeNamed: #blessings collectionOf: StoreBlessing.	aClassModel newAttributeNamed: #currentBlessingLevel type: Number.</body><body package="Store-Database Model" selector="classModelForStorePundlePropertyRelationship:">classModelForStorePundlePropertyRelationship: aClassModel	aClassModel newAttributeNamed: #pundleID.	aClassModel newAttributeNamed: #propertyID.	aClassModel newAttributeNamed: #recordType.</body><body package="Store-Database Model" selector="classModelForStoreSharedVariableInPackage:">classModelForStoreSharedVariableInPackage: aClassModel	aClassModel newAttributeNamed: #package type: StorePackage.	aClassModel newAttributeNamed: #definition type: StoreSharedVariable.</body><body package="Store-Database Model" selector="classModelForStoreSourceObject:">classModelForStoreSourceObject: aClassModel	aClassModel newAttributeNamed: #primaryKey type: Integer.	aClassModel newAttributeNamed: #trace type: aClassModel describedClass.	aClassModel newAttributeNamed: #username type: String.	aClassModel newAttributeNamed: #timestamp.	aClassModel newAttributeNamed: #name type: String.</body><body package="Store-Database Model" selector="classModelForStoreUserGroup:">classModelForStoreUserGroup: aClassModel	aClassModel newAttributeNamed: #groupName type: String.	aClassModel newAttributeNamed: #userName type: String.	aClassModel newAttributeNamed: #type type: String.</body><body package="Store-Database Model" selector="convertTimestampToDbInRows:attribute:forTable:field:">convertTimestampToDbInRows: rows attribute: attribute forTable: table field: field	| offset |	"The timestamp can actually be a query object if we're doing a subselect"	offset := attribute isNil ifTrue: [nil]		ifFalse: [attribute isGlorpExpression						ifTrue: [attribute]						ifFalse: [attribute asSeconds - self timestampOffset]].	^(rows at: table) at: field put: offset</body><body package="Store-Database Model" selector="timestampFieldName">timestampFieldName	^self platform class == FirebirdPlatform 		ifTrue: ['timeStmp']		ifFalse: ['timeStamp']</body><body package="Store-Database Model" selector="typeResolverForStoreVersionlessPundle">typeResolverForStoreVersionlessPundle	^HorizontalTypeResolver forRootClass: StoreVersionlessPundle.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>testing</category><body package="Store-Database Model" selector="hasMethodComments">hasMethodComments	^false.</body><body package="Store-Database Model" selector="hasPropertiesAsBlob">hasPropertiesAsBlob	^true.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>validation</category><body package="Store-Database Model" selector="validateRows:">validateRows: aUnitOfWork	| bundleTable timestampField blobId packageTable packageVersionField bundleVersionField bundleTraceField packageTraceField allPackageKeys packageField packageNames methodsTable |	super validateRows: aUnitOfWork.	"If this is a non-replicator session, for example a Store-on-Glorp publish or write-enabled Store workbook, then we want to allow updates so these validations aren't correct."	aUnitOfWork session accessor permitsUpdates ifTrue: [^self].	aUnitOfWork rowsToWrite		do:			[:each | 			each table hasCompositePrimaryKey				ifFalse:					[each primaryKey notNil						ifTrue: [self error: 'Row already has a primary key']]].	bundleTable := self tableNamed: 'TW_Bundle'.	timestampField := bundleTable fieldNamed: self timestampFieldName.	packageTable := self tableNamed: 'TW_Package'.	packageVersionField := packageTable fieldNamed: 'version'.	bundleVersionField := bundleTable fieldNamed: 'version'.	bundleTraceField := bundleTable fieldNamed: 'trace'.	packageTraceField := packageTable fieldNamed: 'trace'.	methodsTable := self tableNamed: 'TW_Methods'.	aUnitOfWork rowsToWrite		do: [:each | (each table = bundleTable and: [(each at: timestampField) isNil]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: 	[:each | (each table = bundleTable and: [(each at: bundleVersionField) isNil]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: [:each | (each table = bundleTable and: [each owner storeModel notNil and: [				each owner storeModel versionString = each owner version and: [					each owner storeModel databaseInfomation notNil and: [						each owner storeModel databaseInfomation dbTrace notNil and: [							(each at: bundleTraceField) isNil]]]]]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: 	[:each | (each table = packageTable and: [(each at: packageVersionField) isNil]) ifTrue: [self halt]].	aUnitOfWork rowsToWrite		do: [:each | (each table = packageTable and: [each owner storeModel notNil and: [				each owner storeModel versionString = each owner version and: [					each owner storeModel databaseInfomation notNil and: [						each owner storeModel databaseInfomation dbTrace notNil  and: [							(each at: packageTraceField) isNil]]]]]) ifTrue: [self halt]]."We believe the problem of methods with trace zero is now long solved and so skip this check.	methodTable := self tableNamed: 'TW_Method'.	methodTrace := methodTable fieldNamed: 'trace'.	aUnitOfWork rowsToWrite		do: [:each | (each table = methodTable and: [(each at: methodTrace) = 0]) ifTrue: [self halt]]."	blobId := self blobId.	aUnitOfWork rowsToWrite do: [:each |		(each table = blobId table and: [(each at: blobId) = 0]) ifTrue: [self halt]].	"Check if we are publishing any methods that refer to packages that don't exist, or multiple copies of the same package"	packageField := methodsTable fieldNamed: 'packageRef'.	allPackageKeys := (aUnitOfWork rowsToWrite select: [:each | each table = packageTable]) collect: [:each | each primaryKey].	aUnitOfWork rowsToWrite do: [:each |		each table = methodsTable ifTrue: [(allPackageKeys includes: (each at: packageField)) ifFalse: [self halt]]].	packageNames := (aUnitOfWork rowsToWrite select: [:each | each table = packageTable]) collect: [:each | each owner name].	packageNames size = packageNames asSet size ifFalse: [self halt].</body><body package="Store-Database Model" selector="validateRowsPostWrite:">validateRowsPostWrite: aUnitOfWork	"Validate after writing. This is a bit late, but some things may not be catchable ahead of time"	| table field |	super validateRowsPostWrite: aUnitOfWork.	aUnitOfWork session accessor permitsUpdates ifTrue: [^self].	table := self tableNamed: 'TW_Blob'.	field := table fieldNamed: 'blobType'.	aUnitOfWork rowsToWrite		do:			[:each | (each table = table and: [(each at: field) isNil]) ifTrue: [self halt]].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>other</category><body package="Store-Database Model" selector="allTableNames">allTableNames	^#('TW_Package' 'TW_Method' 'TW_Methods' 'TW_ClassRecord' 'TW_PkgClasses' 'TW_DataElement' 'TW_Data' 'TW_NameSpaceRecord' 'TW_PkgNameSpaces' 'TW_Bundle' 'TW_Bundles' 'TW_Packages' 'TW_Blob' 'TW_Blessing' 'TW_BinaryBlob' 'TW_ParcelRecord' 'TW_DatabaseIdentifier' 'TW_DBUserGroup' 'TW_DBPundlePrivileges')</body><body package="Store-Database Model" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: StoreBlessing;		add: StoreBlob;		add: StoreBundle;		add: StoreNameSpace;		add: StoreSharedVariable;		add: StoreClassDefinition;		add: StoreMethod;		add: StorePackage;		add: StoreVersionlessBundle;		add: StoreVersionlessPackage;		add: StoreClassExtension;		add: StoreDatabaseIdentifier;		add: StoreParcelRecord;		add: StoreBinaryBlob;		add: StoreClassDefinitionInPackage;		add: StoreMethodInPackage;		add: StoreNamespaceInPackage;		add: StoreSharedVariableInPackage;		add: StoreUserGroup;		add: StoreAccessPrivilege;		add: StoreBundleSubBundleRelationship;		add: StoreBundlePackageRelationship;		yourself</body><body package="Store-Database Model" selector="justSelectTheMaximumCurrentValueAndAddOneSequenceFor:">justSelectTheMaximumCurrentValueAndAddOneSequenceFor: aTable 	^self databaseSequenceNamed: aTable name ifAbsentPut: [JustSelectTheMaximumSequenceValueAndAddOne new table: aTable].</body><body package="Store-Database Model" selector="sequenceFor:">sequenceFor: aTable	| name sequence |	name := self platform storeSequenceNameFor: aTable name.	((platform isKindOf: AccessPlatform) or: [platform isKindOf: SQLite3Platform])		ifTrue:			["Ick. SQL Server used to work this way, but at least for Access it's single-user, so it shouldn't crash.			Can Access now use SQLServerSequence, as its code suggests, or not?  TBC."			"SQLite3Platform is only here because I (Niall) have not yet checked whether it has a valid sequence construct."			sequence := self justSelectTheMaximumCurrentValueAndAddOneSequenceFor: aTable]		ifFalse: [sequence := self databaseSequenceNamed: name].	sequence schema: aTable schema.	^self platform serial sequence: sequence.</body><body package="Store-Database Model" selector="timestampOffset">timestampOffset	^2922938387</body><body package="Store-Database Model" selector="valueIsNil:">valueIsNil: aValue	^aValue = nil.</body><body package="Store-Database Model" selector="valueIsNonNil:">valueIsNonNil: aValue	^aValue ~= nil.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>hooks</category><body package="Store-Database Model" selector="shouldForeignKeyValueBeTreatedAsNull:">shouldForeignKeyValueBeTreatedAsNull: aValue	"Return true if this foreign key value should be treated as null, meaning there's no relationship. Normally this means just nil, but descriptor systems can override if they have special values which they use (e.g. 0) that indicate a missing relationship. This can improve performance by avoiding unnecessary queries to the database for things we know will never return a result"	^aValue isNil or: [aValue = 0].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>private</category><body package="Store-Database Model" selector="initializeTable:">initializeTable: newTable	super initializeTable: newTable.	(self platform isKindOf: OraclePlatform) ifTrue: 		[session schema isEmpty			ifTrue: [newTable schema: Store.DbRegistry tablePrefix asUppercase]			ifFalse: [newTable schema: session schema asUppercase]].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>optimization parameters</category><body package="Store-Database Model" selector="maximumSizeToGroupWriteFor:">maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows	"We can get some really large row collections, which can be a problem. Cap the maximum size."	^1000 min: (super maximumSizeToGroupWriteFor: aCollectionOfDatabaseRows).</body><body package="Store-Database Model" selector="shouldUpdateOnlyChangedFieldsFor:">shouldUpdateOnlyChangedFieldsFor: aRow	"We may have permissions set limiting the columns that can be updated, so we only ever want to update the changed fields."	^true.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>convenience</category><body package="Store-Database Model" selector="databaseIdentifier">databaseIdentifier	"Convenience method. Return the database identifier name in cache. If there isn't one, read and then do so"	(self session cacheFor: StoreDatabaseIdentifier) do: [:each | ^each name].	(session readOneOf: StoreDatabaseIdentifier) ifNil: [self halt].	^self databaseIdentifier.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>utility methods</category><body package="Store-Database Model" selector="latestVersionOf:">latestVersionOf: aPundle	"Find the latest version of aPundle, defined by having the highest timestamp."	| query |	query := Query readOneOf: aPundle storeForGlorpPundleClass where: [:each |		| q |		q := Query read: aPundle storeForGlorpPundleClass where: [:eachPundle |			eachPundle name = aPundle name].		q retrieve: [:x | x timestamp max].		each timestamp = q].	^session execute: query.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>updating</category><body package="Store-Database Model" selector="update771">update771	| table versionField nameField constraint |	#('TW_BUNDLE' 'TW_PACKAGE') do:		[:each |		table := self tableNamed: each.		versionField := table fieldNamed: 'version'.		nameField := table fieldNamed: 'name'.		constraint := UniqueConstraint forTable: table fields: (Array with: versionField with: nameField).		session accessor addConstraint: constraint].</body><body package="Store-Database Model" selector="update78">update78	| packageClassesTable |	packageClassesTable := self tableNamed: 'TW_PkgClasses'.	self session accessor 		createTableIndexes: packageClassesTable 		ifError: 			[:exception | 			Transcript cr; show: exception description. 			exception resume: nil].</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>api</category><body package="Store-Database Model" selector="tableNamed:ifNone:">tableNamed: aString ifNone: aBlock		^tables		at: aString asString asUppercase		ifAbsent:			[| newTable |			newTable := StoreDatabaseTable new.			newTable name: aString.			tables at: aString asUppercase put: newTable.			self initializeTable: newTable.			newTable isEmpty ifTrue:				[tables removeKey: aString asUppercase.				^aBlock value].			newTable]</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem</class-id> <category>accessing</category><body package="Store-Database Model" selector="cachePolicy">cachePolicy	"Return the cache policy that will be used for Store"	cachePolicy isNil ifTrue: [cachePolicy := CachePolicy new].	^cachePolicy.</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>schema selection</category><body package="Store-Database Model" selector="checkStoreVersionFor:using:">checkStoreVersionFor: aLogin using: accessor	"Create the appropriate descriptor system for this login, by checking what version of store this appears to be."	accessor isLoggedIn ifFalse: [accessor storeLogin].	^self		checkStoreVersionFor: aLogin		using: accessor		forTable: 'TW_MethodDocs'		ifExistingUse: Store74DescriptorSystem		elseDo: [			self				checkStoreVersionFor: aLogin				using: accessor				forTable: 'TW_PropertyRecord'				ifExistingUse: Store73DescriptorSystem				elseDo: [StoreDescriptorSystem forPlatform: aLogin database]].</body><body package="Store-Database Model" selector="checkStoreVersionFor:using:forTable:ifExistingUse:elseDo:">checkStoreVersionFor: aLogin using: accessor forTable: tableName ifExistingUse: aClass elseDo: aBlock	"Create the appropriate descriptor system for this login, by checking what version of store this appears to be."	| schema |	schema := (aLogin schema isNil or: [aLogin schema isEmpty])				ifTrue: ['']				ifFalse: [aLogin schema].	(aLogin platform isSQLServerPlatform		and: [aLogin platform isAccessPlatform not])			ifTrue: [schema := Store.Policies tableSpacePolicy defaultTableSpace].	^(accessor isExistingTable: tableName inSchema: schema)		ifTrue: [aClass forPlatform: aLogin database]		ifFalse: [aBlock value]</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>connection detection</category><body package="Store-Database Model" selector="checkConnectionFor:using:">checkConnectionFor: aLogin using: aDatabaseAccessor	"Our goal is to test the database connection. If it fails to execute, 	we consider the connection dead and ask if the user wants to reconnect.	If they say no, we just go into sudden death mode and raise the lost connection error	Answer true if we installed tables, or false if tables were already installed"		| schema tableName tablesExist tries |	schema := (aLogin schema isNil or: [aLogin schema isEmpty]) ifTrue: [''] ifFalse: [aLogin schema].	(aLogin platform isSQLServerPlatform and: [aLogin platform isAccessPlatform not])		ifTrue: [schema := Store.Policies tableSpacePolicy defaultTableSpace].	tableName := 'TW_DatabaseIdentifier'.	tries := 0.	tablesExist := 		[tries := tries + 1.		aDatabaseAccessor isExistingTable: tableName inSchema: schema]			on: Error			do: 				[:exception |				tries &gt; 1 ifTrue: 					[Store.DbRegistry disconnect.					Store.DbRegistry currentlyNotConnectedSignal raiseSignal].				(Dialog confirm: #CurrentlyDisconnectedReconnectQ &lt;&lt; #store &gt;&gt; 'Currently disconnected. Do you want to reconnect?') ifTrue: 					[Store.DbRegistry disconnect.					Store.DbRegistry reconnect ifTrue:						[aDatabaseAccessor connection: Store.DbRegistry connection.						exception retry]].					Store.DbRegistry disconnect.					Store.DbRegistry currentlyNotConnectedSignal raiseSignal].	tablesExist == false ifTrue:		[self goToScriptOrCreateDatabaseTables 			ifFalse: 				[Transcript show: (#StoreSchemaNotInstalled &lt;&lt; #store &gt;&gt; '&lt;n&gt;Store Schema is not installed in database.&lt;n&gt;Execute: &lt;nt&gt;''Store.DbRegistry installDatabaseTables''&lt;n&gt;') expandMacros.				Store.DbRegistry currentlyNotConnectedSignal raiseSignal]			ifTrue: [self installStoreDatabaseTablesUsing: aLogin]].	^false</body><body package="Store-Database Model" selector="goToScriptOrCreateDatabaseTables">goToScriptOrCreateDatabaseTables		^DbRegistry goToScript or: [RequestInstallDatabaseTables raiseSignal]</body><body package="Store-Database Model" selector="userInputlExceptionsToIgnore">userInputlExceptionsToIgnore		| list |	list := OrderedCollection new.	list add: RequestUniqueDatabaseIdentifierString.	list add: RequestInstallDatabaseTables.	list add: InstallUserManagementPolicies.	list add: RequestImageAdministatorName.	list add: UserManagementPoliciesNotInstalledNotice.	^list</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>store schema creation</category><body package="Store-Database Model" selector="askToInstallUserManagementPoliciesIn:">askToInstallUserManagementPoliciesIn: aSession		InstallUserManagementPolicies raiseSignal		ifTrue: [self installUserManagementPoliciesIn: aSession]		ifFalse:			[UserManagementPoliciesNotInstalledNotice raiseSignal.			self logDidNotCreateManagementPolicies]</body><body package="Store-Database Model" selector="createTablesFor:">createTablesFor: aLogin	"Create the tables for this descriptor system in the given database. This will fail if the tables already exist. Use recreateTables for that."		| session |	session := self sessionForLogin: aLogin.	session storeLogin.	Store.DbRegistry goToScript ifTrue:		[session accessor logging: true.		session accessor logOnly: true.		session accessor logger: Store.DbRegistry debugger debugStream].	[session platform supportsPhysicalSpaces ifTrue:		[self installPhysicalSpacesIn: session].	session createTables.	self createUniqueDatabaseIdentifierIn: session.	self askToInstallUserManagementPoliciesIn: session] ensure: 		[session accessor logging: false.		session accessor logOnly: false.		session accessor logger: nil.		session logout].</body><body package="Store-Database Model" selector="createUniqueDatabaseIdentifierIn:">createUniqueDatabaseIdentifierIn: aSession		| identifierObject identifier |	identifier := RequestUniqueDatabaseIdentifierString raiseSignal.	identifierObject := Store.Glorp.StoreDatabaseIdentifier new.	^aSession		inUnitOfWorkDo:			[aSession register: identifierObject.			identifierObject name: identifier]</body><body package="Store-Database Model" selector="installPhysicalSpacesIn:">installPhysicalSpacesIn: aSession	aSession platform installPhysicalSpacesIn: aSession accessor.</body><body package="Store-Database Model" selector="installStoreDatabaseTablesUsing:">installStoreDatabaseTablesUsing: aLogin		[(InstallingDatabaseTables for: 'Store') started.	Store74DescriptorSystem createTablesFor: aLogin.	(InstallingDatabaseTables for: 'Store') finished] withStoreFeedbackOn: VisualLauncher allInstances first mainWindow</body><body package="Store-Database Model" selector="installUserManagementPolicies">installUserManagementPolicies	self installUserManagementPoliciesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="installUserManagementPoliciesIn:">installUserManagementPoliciesIn: aSession	| session admin |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	StoreUserGroup newGroupNamed: StoreUserGroup adminGroupName in: session.	StoreUserGroup newGroupNamed: 'QA' in: session.	admin := RequestImageAdministatorName raiseRequest.	StoreUserGroup newUserNamed: admin inGroupNamed: StoreUserGroup adminGroupName in: session</body><body package="Store-Database Model" selector="logDidNotCreateManagementPolicies">logDidNotCreateManagementPolicies		DbRegistry printDebug:		(#YouDidNotCreatedUsStallUserManagement &lt;&lt; #store &gt;&gt;			'You did not create user management policies. To add user management policies later execute: ''StoreDescriptorSystem installUserManagementPolicies''') asString</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>descriptors</category><body package="Store-Database Model" selector="addPropertiesMappingTo:">addPropertiesMappingTo: aDescriptor	"Add the properties mapping. Different between versions of Store schema, but this one can have both"	| linkTable propertyTable propertiesMapping |	super addPropertiesMappingTo: aDescriptor.	linkTable := self tableNamed: 'TW_Properties'.	propertyTable := self tableNamed: 'TW_PropertyRecord'.	propertiesMapping := (aDescriptor newMapping: BasicDictionaryMapping)		attributeName: #propertiesRecordDictionary;		useLinkTable;		keyField: (propertyTable fieldNamed: 'name');		join: (Join 			from: (aDescriptor table fieldNamed: 'primaryKey')			to: (linkTable fieldNamed: 'pundleRef')			from: aDescriptor describedClass propertyTypeCode			to: (linkTable fieldNamed: 'recType'));		yourself."	propertiesMapping useFilteredRead."   "This is causing intermittent errors in rare circumstances when merging, and the safe thing to do is just turn it off, at least for the time being."	propertiesMapping query alsoFetch: [:each | each definition].	"Make it more convenient to query development prerequisites"	aDescriptor oneToOneMapping		attributeName: #developmentPrerequisites;		beForPseudoVariable;		useLinkTable;		join: (Join 			from: (aDescriptor table fieldNamed: 'primaryKey')			to: (linkTable fieldNamed: 'pundleRef')			from: aDescriptor describedClass propertyTypeCode			to: (linkTable fieldNamed: 'recType')			from: 'developmentPrerequisites'			to: (propertyTable fieldNamed: 'name')).</body><body package="Store-Database Model" selector="descriptorForStoreBundle:">descriptorForStoreBundle: aDescriptor	| |	super descriptorForStoreBundle: aDescriptor.	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #files.</body><body package="Store-Database Model" selector="descriptorForStoreFile:">descriptorForStoreFile: aDescriptor	| table |	table := self tableNamed: 'TW_FileRecord'.	aDescriptor table: table.	self addStandardStoreDescriptorTo: aDescriptor forTable: table andClass: StoreFile.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #contents;		join: (Join from: (table fieldNamed: 'fileID') to: self binaryBlobId).	(aDescriptor newMapping: DirectMapping) from: #fileSize to: (table fieldNamed: 'fileSize').	(aDescriptor newMapping: DirectMapping) from: #filename to: (table fieldNamed: 'components').</body><body package="Store-Database Model" selector="descriptorForStoreMethod:">descriptorForStoreMethod: aDescriptor	| table |	super descriptorForStoreMethod: aDescriptor.	table := self tableNamed: 'TW_Method'."	(aDescriptor newMapping: OneToOneMapping)		attributeName: #comment;		join: (Join from: (table fieldNamed: 'commentID') to: self blobId)."</body><body package="Store-Database Model" selector="descriptorForStoreProperty:">descriptorForStoreProperty: aDescriptor	| table |	table := self tableNamed: 'TW_PropertyRecord'.	aDescriptor table: table.	self addStandardStoreDescriptorTo: aDescriptor forTable: table andClass: StoreProperty.	(aDescriptor newMapping: OneToOneMapping)		attributeName: #definition;		join: (Join from: (table fieldNamed: 'definitionID') to: self blobId).	(aDescriptor newMapping: DirectMapping) from: #searchString to: (table fieldNamed: 'searchString').</body><body package="Store-Database Model" selector="descriptorForStorePundlePropertyRelationship:">descriptorForStorePundlePropertyRelationship: aDescriptor	| table |	table := self tableNamed: 'TW_Properties'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #pundleID				to: (table fieldNamed: 'pundleRef')).	aDescriptor addMapping: (DirectMapping from: #propertyID				to: (table fieldNamed: 'propertyRef')).	aDescriptor addMapping: (DirectMapping from: #recordType				to: (table fieldNamed: 'recType'))</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>tables</category><body package="Store-Database Model" selector="allTableNames">allTableNames	^super allTableNames, #('TW_Files' 'TW_FileRecord' 'TW_PropertyRecord' 'TW_Properties')</body><body package="Store-Database Model" selector="tableForTW_FILERECORD:">tableForTW_FILERECORD: aTable 	| fileId foreignKey |	self createStandardAndVersionRecordFieldsIn: aTable.	fileId := aTable createFieldNamed: 'fileID' type: platform int4.	fileId defaultValue: 0.	(aTable fieldNamed: 'version') beNullable: true.	foreignKey := aTable addForeignKeyFrom: fileId to: self blobId.	"This is a foreignKey with a default 0, so we never put in database"	foreignKey shouldCreateInDatabase: false.	(aTable createFieldNamed: 'fileSize' type: platform int4).	(aTable createFieldNamed: 'components' type: platform blob).	aTable propertyAt: #tableSpaceName put: StoreFile tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreFile tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_FILES:">tableForTW_FILES: aTable 	| bundleRef fileRef |	bundleRef := aTable createFieldNamed: 'bundleRef' type: platform int4.	bundleRef bePrimaryKey.	aTable addForeignKeyFrom: bundleRef		to: ((self tableNamed: 'TW_Bundle') fieldNamed: 'primaryKey').	"This foreignKey is always in the same table space, so we always create it"	aTable createFieldNamed: 'expressionID' type: platform int4.	aTable createFieldNamed: 'seqNumber' type: platform int4.	fileRef := aTable createFieldNamed: 'fileRef' type: platform int4.	fileRef bePrimaryKey.	aTable addForeignKeyFrom: fileRef		to: ((self tableNamed: 'TW_FileRecord') fieldNamed: 'primaryKey').	"This foreignKey is always in the same table space, so we always create it"	aTable addIndexForField: fileRef.	aTable propertyAt: #tableSpaceName put: StoreFile tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreFile tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_METHOD:">tableForTW_METHOD: aTable 	| commentId |	super tableForTW_METHOD: aTable."	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	aTable addForeignKeyFrom: commentId		to: self blobId."</body><body package="Store-Database Model" selector="tableForTW_PROPERTIES:">tableForTW_PROPERTIES: aTable 	| pundleRef propertyRef foreignKey |	pundleRef := aTable createFieldNamed: 'pundleRef' type: platform int4.	pundleRef bePrimaryKey.	propertyRef := aTable createFieldNamed: 'propertyRef' type: platform int4.	propertyRef bePrimaryKey.	aTable addIndexForField: propertyRef.	foreignKey := aTable addForeignKeyFrom: propertyRef		to: ((self tableNamed: 'TW_PropertyRecord') fieldNamed: 'primaryKey').	foreignKey name: 'TW_Props_TW_PropRec_PriKY'.	"This foreignKey is always in the same table space, so we always create it"	(aTable createFieldNamed: 'recType' type: platform int4) bePrimaryKey.	aTable propertyAt: #tableSpaceName put: StoreProperty tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreProperty tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_PROPERTYRECORD:">tableForTW_PROPERTYRECORD: aTable 	| definitionId commentId foreignKey |	self createStandardRecordFieldsIn: aTable.	definitionId := aTable createFieldNamed: 'definitionID' type: platform int4.	definitionId defaultValue: 0.	definitionId beIndexed.	foreignKey := aTable addForeignKeyFrom: definitionId to: self blobId.	foreignKey name: 'TW_PropRec_TW_Blob_DefID'.	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	commentId := aTable createFieldNamed: 'commentID' type: platform int4.	commentId defaultValue: 0.	foreignKey := aTable addForeignKeyFrom: commentId to: self blobId.	foreignKey name: 'TW_PropRec_TW_Blob_ComtID'.	"This foreignKey has a Default so we never create it"	foreignKey shouldCreateInDatabase: false.	(aTable createFieldNamed: 'environmentString' type: (platform varchar: 255)).	(aTable createFieldNamed: 'searchString' type: (platform varchar: 255)) beIndexed.	aTable propertyAt: #tableSpaceName put: StoreProperty tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreProperty tableSpaceName , '.' , session schema].</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>classes</category><body package="Store-Database Model" selector="addPropertiesToClassModel:">addPropertiesToClassModel: aClassModel	"Varies by schema version"	super addPropertiesToClassModel: aClassModel.	aClassModel newAttributeNamed: #propertiesRecordDictionary collection: Dictionary of: StoreProperty.	aClassModel newAttributeNamed: #developmentPrerequisites type: StoreProperty.</body><body package="Store-Database Model" selector="classModelForStoreBundle:">classModelForStoreBundle: aClassModel	super classModelForStoreBundle: aClassModel.	aClassModel newAttributeNamed: #files collectionOf: StoreFile.</body><body package="Store-Database Model" selector="classModelForStoreFile:">classModelForStoreFile: aClassModel	self classModelForStoreSourceObject: aClassModel.	aClassModel newAttributeNamed: #contents type: StoreBinaryBlob.	aClassModel newAttributeNamed: #fileSize type: Integer.	aClassModel newAttributeNamed: #filename type: ByteArray.</body><body package="Store-Database Model" selector="classModelForStoreProperty:">classModelForStoreProperty: aClassModel	self classModelForStoreSourceObject: aClassModel.	(aClassModel attributeNamed: #name) type: Symbol.	aClassModel newAttributeNamed: #definition type: StoreBlob.	aClassModel newAttributeNamed: #searchString type: String.</body><body package="Store-Database Model" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: StorePundlePropertyRelationship;		add: StoreFile;		add: StoreProperty;		yourself</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>testing</category><body package="Store-Database Model" selector="hasMethodComments">hasMethodComments	"true"	^false.</body><body package="Store-Database Model" selector="hasPropertiesAsBlob">hasPropertiesAsBlob	^false.</body></methods><methods><class-id>Store.Glorp.Store73DescriptorSystem</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Store.ContainsUndeclaredError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog		warn:			(#_1sContainsValuesICtBeforePublishing &lt;&lt; #store &gt;&gt; '&lt;1s&gt; contains values in Undeclared. Please correct before publishing.' expandMacrosWith:					messageText).	^false</body></methods><methods><class-id>Store.ContainsUndeclaredError class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="compilationManager">compilationManager	^compilationManager</body><body package="Atomic Compiling and Loading" selector="compilationManager:">compilationManager: anObject	^compilationManager := anObject</body><body package="Atomic Compiling and Loading" selector="component">component	^package</body><body package="Atomic Compiling and Loading" selector="externalClassesNeedingRecompile">externalClassesNeedingRecompile	^externalClassesNeedingRecompile</body><body package="Atomic Compiling and Loading" selector="externalClassesNeedingRecompile:">externalClassesNeedingRecompile: aCollection	externalClassesNeedingRecompile := aCollection</body><body package="Atomic Compiling and Loading" selector="isAtomicallyLoadable">isAtomicallyLoadable		isAtomicallyLoadable isNil ifTrue: [isAtomicallyLoadable := true].	^isAtomicallyLoadable</body><body package="Atomic Compiling and Loading" selector="isAtomicallyLoadable:">isAtomicallyLoadable: aBoolean		isAtomicallyLoadable := aBoolean</body><body package="Atomic Compiling and Loading" selector="methodsMovedFromOriginalBinding">methodsMovedFromOriginalBinding	^methodsMovedFromOriginalBinding</body><body package="Atomic Compiling and Loading" selector="needsEarlyInstall">needsEarlyInstall	^needsEarlyInstall ifNil: [false]</body><body package="Atomic Compiling and Loading" selector="overrides">overrides		^overrides</body><body package="Atomic Compiling and Loading" selector="package">package	^package</body><body package="Atomic Compiling and Loading" selector="package:">package: anObject	package := anObject</body><body package="Atomic Compiling and Loading" selector="packageDifferences">packageDifferences	^packageComparitor</body><body package="Atomic Compiling and Loading" selector="parentManager:">parentManager: ignore</body><body package="Atomic Compiling and Loading" selector="pundle:">pundle: anObject	package := anObject</body><body package="Atomic Compiling and Loading" selector="root">root	^root</body><body package="Atomic Compiling and Loading" selector="root:">root: anObject	root := anObject</body><body package="Atomic Compiling and Loading" selector="shadowAt:">shadowAt: aPath	^(self root		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body><body package="Atomic Compiling and Loading" selector="shadowCompiler">shadowCompiler	^shadowCompiler</body><body package="Atomic Compiling and Loading" selector="shadowedObjects">shadowedObjects	^shadowObjects</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitions">unloadableDefinitions	^unloadableDefinitions</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitions:">unloadableDefinitions: anObject	unloadableDefinitions := anObject</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="addToShadowed:">addToShadowed: anObject	shadowObjects addLast: anObject</body><body package="Atomic Compiling and Loading" selector="collectShadowedRedefinition:">collectShadowedRedefinition: aNotification	"We need to capture the overrides as the system notifies of them.  Unfortunately, the overrides	 are not in a state that is installable.  We will fix that later."		| targetOverride |	targetOverride := aNotification override.	targetOverride isForMethod ifTrue: 		[overrides add: targetOverride.		compilationManager setOverriddenForMethod: targetOverride].	targetOverride isForClass ifTrue: 		[(overrides includes: targetOverride) ifFalse:			[overrides add: targetOverride.			targetOverride actual ifNotNil: [RedefinitionOfClass raiseRequestWith: targetOverride]].		(overrides includes: targetOverride) ifFalse: [overrides add: targetOverride].		compilationManager setOverriddenForClass: targetOverride].	targetOverride isForNameSpace ifTrue: 		[overrides add: targetOverride.		RedefinitionOfClass raiseRequestWith: targetOverride].	aNotification resume</body><body package="Atomic Compiling and Loading" selector="compileAllToShadow">compileAllToShadow	"Compile all the packages definitions into shadow.	First the Namespaces, Classes and Shared (data) in that order, then the methods"	(Compiling for: package) started.	package nameSpaces , package classes , package data		do: [:each | self shadowDefinedRecord: each].	self compileMethodRecords: package methodsWithSource.	(Compiling for: package) finished</body><body package="Atomic Compiling and Loading" selector="compileDeltasToShadow">compileDeltasToShadow	"Compile the deltas between the pundle and the image into shadow."		| pundleModel |	(package primaryKey = (pundleModel := package getImagePundle) dbTrace and: [pundleModel hasBeenModified not]) ifTrue: [^self].	packageComparitor := PackageComparitor differencesBetween: package and: pundleModel.	packageComparitor hasDifferences ifFalse: [^self].	(Compiling for: package) started.	packageComparitor mainPackageNamespaces , (StorePackage superclassOrder: packageComparitor mainPackageClasses) , packageComparitor mainPackageShareds		do: [:each | self shadowDefinedRecord: each].	self compileMethodRecords: packageComparitor mainPackageMethods.	(self willClassRemovalAffectAnotherPackage: pundleModel) ifTrue: [needsEarlyInstall := true].	(Compiling for: package) finished</body><body package="Atomic Compiling and Loading" selector="compileMethodRecords:">compileMethodRecords: aCollectionOfMethodRecords	"Because SystemUtils class&gt;&gt;#sortForLoading: will rely on #prerequisitesForLoading to determine	 prerequisites, we want to sort those methods out first and compile the ahead of time. "		| groupedMethodRecords |	groupedMethodRecords := aCollectionOfMethodRecords groupedBy: 		[:each | each isMeta and: [each selector = #prerequisitesForLoading]].	(groupedMethodRecords at: true ifAbsent: [Array new]) do: 		[:each | self shadowDbMethod: each].	(self sortMethodsForLoading: (groupedMethodRecords at: false ifAbsent: [Array new])) do: 		[:each | self shadowDbMethod: each]</body><body package="Atomic Compiling and Loading" selector="raiseUnloadableError:">raiseUnloadableError: aStoreDbRecord	Store.UnloadableDefinitionError new		definitionRecord: (aStoreDbRecord asStoreObjectInPackage: package);		raise.	^nil</body><body package="Atomic Compiling and Loading" selector="realFromShadow:">realFromShadow: aShadowedObject	"Looks up aShadowedObject in the real world and answers it, or nil if it doesn't exist. 		Works for NameSpaces and Classes."	| real shadowObject |	aShadowedObject ifNil: [^nil].	shadowObject := aShadowedObject isBehavior		ifTrue: [aShadowedObject instanceBehavior]		ifFalse: [aShadowedObject].	real := shadowObject absoluteName asStrictReference 		ifDefinedDo: [:value | value]		elseDo: [^nil].	^(aShadowedObject isBehavior and: [aShadowedObject isMeta])		ifTrue: [real class]		ifFalse: [real]</body><body package="Atomic Compiling and Loading" selector="willClassRemovalAffectAnotherPackage:">willClassRemovalAffectAnotherPackage: pundleModel	"Are there classes NOT in my package that are subclasses of any class that I need to remove from myself"		^packageComparitor sortedClassesToRemoveAfterLoad anySatisfy:		[:each | 		each correspondingImageClass notNil and: 			[each correspondingImageClass subclasses anySatisfy: 				[:eachSubclass | (Registry packageForClass: eachSubclass) name ~= pundleModel name]]]</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading" selector="initializeRoot:">initializeRoot: aShadowRootNamespace		root := aShadowRootNamespace.	shadowCompiler := ShadowCompiler root: root.	shadowObjects := OrderedCollection new.	overrides := OrderedCollection new.	externalClassesNeedingRecompile := OrderedCollection new.	methodsMovedFromOriginalBinding := OrderedCollection new.	needsEarlyInstall := false.	isAtomicallyLoadable := true</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="atomicCompileWith:">atomicCompileWith: aCompilationManager	"I was invoked by the UI (or directly) compile (or if binary, just binary load), and then answer back either nil or the compilation result?"	| result redefines |	compilationManager := aCompilationManager.	(package preCompileWith: aCompilationManager) ifFalse: [^nil].	(package binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]) ifTrue: 		[compilationManager installEarlyAndReInitialize.		compilationManager newShadowRoot.		^package binLoadWithin: nil using: compilationManager].	shadowCompiler shadowRoot: compilationManager root.	redefines := OrderedCollection new.	result := [[SystemUtils modifySystem: [self compile]]		on: RedefinitionOfClass		do: 			[:notification |			(redefines includes: notification parameter)				ifFalse: 					[compilationManager installEarlyAndReInitialize.					compilationManager newShadowRoot.					redefines add: notification parameter.					notification restart]				ifTrue: 					[notification resume]]]			on: NoDLLCCNotification			do: 				[:notification |				compilationManager installEarlyAndReInitialize.				compilationManager newShadowRoot.				notification restart].	result ifNotNil: 		[aCompilationManager addResult: result.		result needsEarlyInstall ifTrue: [aCompilationManager installEarlyWith: result]].	^result</body><body package="Atomic Compiling and Loading" selector="basicCompileWithOnDoHandlingWith:">basicCompileWithOnDoHandlingWith: isNew		^[[[[isNew 		ifTrue: [self compileAllToShadow] 		ifFalse: [self compileDeltasToShadow].	self recompileMethods]		on: UnloadableDefinitionError		do:			[:exception | 			unloadableDefinitions add: exception.			exception resume]] 				on: VariableConfirmation 				do: [:exception | exception resume: false]]					on: RedefinitionNotification					do: [:notification | self collectShadowedRedefinition: notification]]</body><body package="Atomic Compiling and Loading" selector="compile">compile	"Compile the package definitions into shadow space"		| isNew result block |	(isNew := package getImagePundle isNil) ifTrue: [package runPreRead ifFalse: [^nil]].	unloadableDefinitions := OrderedCollection new.	block := self basicCompileWithOnDoHandlingWith: isNew.	#{ExternalInterfaceTypeDefinitionCompiled} 		ifDefinedDo: [:value | self dllccBasedExceptionHandlerUsing: block with: value] 		elseDo: [block value].	result := AtomicCompilationResult from: self.	self hasChangesToLoad ifTrue:		[self processUnloadables: result.		result isFullyLoaded ifFalse: [^self shouldTryToLoad ifTrue: [result] ifFalse: [nil]]].	^result</body><body package="Atomic Compiling and Loading" selector="compileUnloadables:">compileUnloadables: aCollectionOfUnloadableDefinitionErrors	"Atttempt to compile the unloadableDefinitions definitions into shadow space"		unloadableDefinitions := OrderedCollection new.	[[aCollectionOfUnloadableDefinitionErrors do:		[:each | 		| definitionRecord |		definitionRecord := each definitionRecord.		definitionRecord isForMethod			ifTrue: [self shadowDbMethod: definitionRecord]			ifFalse: [self shadowDefinedRecord: definitionRecord]]]				on: UnloadableDefinitionError				do:					[:exception | 					unloadableDefinitions add: exception.					exception resume]]						on: VariableConfirmation						do: [:notification | notification resume: false].	^AtomicCompilationResult from: self</body><body package="Atomic Compiling and Loading" selector="dllccBasedExceptionHandlerUsing:with:">dllccBasedExceptionHandlerUsing: block with: value		^block		on: value		do:			[:notification | 			| class |			class := notification parameter.			(externalClassesNeedingRecompile includes: class) ifFalse: 				[externalClassesNeedingRecompile add: notification parameter].			notification resume]</body><body package="Atomic Compiling and Loading" selector="processUnloadables:">processUnloadables: result		| comp newResult |	result isFullyLoaded ifTrue: [^self].	(Compiling for: package) started.	comp := self class root: root.	comp package: result package.	newResult := [comp compileUnloadables: result unloadableDefinitions]		on: RedefinitionNotification		do: [:notification | notification resume].	result unloadableDefinitions: newResult unloadableDefinitions.	newResult shadowedObjects do: [:each | self addToShadowed: each].	newResult shadowedObjects notEmpty		ifTrue: [self processUnloadables: result].	(Compiling for: package) finished</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>compiling</category><body package="Atomic Compiling and Loading" selector="augment:usingBehaviorCompiler:">augment: shadowClass usingBehaviorCompiler: compiler		| newMethod |	newMethod := (Behavior compiledMethodAt: #compilerClass) copy.	newMethod		at: 1		put: (ValueHolder new value: compiler).	shadowClass replaceMethodAt: #compilerClass withMethod: newMethod</body><body package="Atomic Compiling and Loading" selector="compilerMethodInShadow:orRealClassDefinesCompiler:">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass nonMeta == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: [(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]				ifFalse: [(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copy]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copy]].</body><body package="Atomic Compiling and Loading" selector="extractCompilerFrom:andPutInto:">extractCompilerFrom: aClassOrMetaClass andPutInto: aShadowClass	"If aClassOrMetaClass (the real not shadowed class) is NOT nil, then we don't have to touch it."	| workingShadow realOrNil method |	workingShadow := aShadowClass.	[realOrNil := self realFromShadow: workingShadow.	workingShadow := workingShadow ifNotNil: [:value | value superclass].	(realOrNil isNil and: [workingShadow isNil]) ifTrue: [^self].	(self leaveCompilerAloneWithRegardTo: realOrNil) ifTrue: [^self].	(method := self compilerMethodInShadow: workingShadow orRealClassDefinesCompiler: realOrNil) notNil] whileFalse.	aShadowClass isMeta		ifTrue: [aShadowClass replaceMethodAt: #classCompilerClass withMethod: method]		ifFalse: [aShadowClass class replaceMethodAt: #compilerClass withMethod: method]</body><body package="Atomic Compiling and Loading" selector="leaveCompilerAloneWithRegardTo:">leaveCompilerAloneWithRegardTo: realOrNil	^(realOrNil notNil and: [realOrNil nonMeta == Object])		or: [realOrNil notNil				and: [realOrNil nonMeta includesBehavior: SmalltalkCompiler]]</body><body package="Atomic Compiling and Loading" selector="methodClassFor:">methodClassFor: aMethodRecord	"Return the class for which this method will be installed. If it's a new class, return the shadow, if it's an existing class, return that. If neither can be found, it's unloadable."		| methodClass |	methodClass := aMethodRecord correspondingImageClass		ifNil: [shadowCompiler findInShadow: aMethodRecord className asClassNameOnly asStrictReference]		ifNotNil: [:value | value instanceBehavior].	^methodClass		ifNil: [UnloadableDefinitionError signalWith: aMethodRecord]		ifNotNil:			[aMethodRecord isMeta				ifTrue: [methodClass class]				ifFalse: [methodClass]]</body><body package="Atomic Compiling and Loading" selector="recompileMethods">recompileMethods	"Recompile all of the methods in the class to try and eliminate any ordering dependencies between them.	A sneaky way to find the compiled methods without using isKindOf:"	shadowObjects := shadowObjects collect:		[:each | 		(each isLikeNameSpace or: [each isBindingReference])			ifTrue: [each]			ifFalse: 				[| selector |				selector := each selector.				(each mclass compiledMethodAt: selector ifAbsent: [nil]) ifNotNil:					[[[each mclass recompileForSunshine: selector from: each mclass]						on: Error						do: [:exception | exception return]]							on: UserNotification							do: 								[:notification |								notification isResumable									ifTrue: [notification resume]									ifFalse: [notification return]].					each mclass compiledMethodAt: selector]]].</body><body package="Atomic Compiling and Loading" selector="shadowDbMethod:">shadowDbMethod: aMethodRecord	"Convert aMethodRecord into an object in shadow root."		| realWorldClass selector shadowClass |	realWorldClass := aMethodRecord correspondingImageClass.	(shadowClass := shadowCompiler findInShadow: aMethodRecord className asClassNameOnly asStrictReference) ifNil:		[realWorldClass ifNil: [^self raiseUnloadableError: aMethodRecord].		shadowClass := shadowCompiler createShadowClassFor: realWorldClass instanceBehavior].	aMethodRecord isMeta ifTrue: [shadowClass := shadowClass class].	self extractCompilerFrom: realWorldClass andPutInto: shadowClass.	selector := [[shadowClass		compileForShadow: aMethodRecord definitionString		classified: aMethodRecord protocol		notifying: nil		environment: (package environmentFor: aMethodRecord selector in: shadowClass)		attributes: nil]			on: Error			do: [:exception | exception return: nil]]				on: UserNotification				do: 					[:exception | 					exception isResumable						ifTrue: [exception resume: nil]						ifFalse: [exception return: nil]].	selector ifNil: [^self raiseUnloadableError: aMethodRecord].	self addToShadowed: (shadowClass compiledMethodAt: selector).	aMethodRecord className asClassNameOnly = shadowClass longName asClassNameOnly ifFalse:		[methodsMovedFromOriginalBinding add: (shadowClass compiledMethodAt: selector)].</body><body package="Atomic Compiling and Loading" selector="shadowDefinedRecord:">shadowDefinedRecord: aDbRecord	"Convert aDbRecord into an object in shadow root."	"First make sure that a class dependant has a class in shadow to be installed into"		| newDefinitionObject |	aDbRecord isString ifTrue: [self halt].	aDbRecord isForData ifTrue:		[(shadowCompiler findInShadow: aDbRecord environmentString asStrictReference) ifNil:			[| definitionOwnerClass |			(definitionOwnerClass := aDbRecord owner) ifNil: [^self raiseUnloadableError: aDbRecord].			shadowCompiler createShadowClassOrNameSpaceFor: definitionOwnerClass.			shadowCompiler addShadowedClassToEnvironment: definitionOwnerClass]].	(newDefinitionObject := shadowCompiler evaluate: aDbRecord shadowLoadDefinition with: Object evaluatorClass new using: self) isNil		ifTrue: [(aDbRecord isForNameSpace and: [aDbRecord name = 'Root']) ifFalse: [self raiseUnloadableError: aDbRecord]]		ifFalse:			[self addToShadowed: newDefinitionObject.			newDefinitionObject isBindingReference 				ifFalse: [(aDbRecord comment notNil and: [aDbRecord comment notEmpty]) ifTrue: [newDefinitionObject comment: aDbRecord comment]]].	^newDefinitionObject</body><body package="Atomic Compiling and Loading" selector="sortMethodsForLoading:">sortMethodsForLoading: aMethodRecord	"Sort methods by class order, with extension methods last."	| orderedMethods methodsGroupedByClass orderedClasses absoluteClassNames classifiedMethods |	orderedMethods := OrderedCollection new.		methodsGroupedByClass := aMethodRecord groupedBy: [:each | (self methodClassFor: each) ifNil: [#none]].	methodsGroupedByClass removeKey: #none ifAbsent: [].	absoluteClassNames :=  package classes collect: [:each | each absoluteName asClassNameOnly].	classifiedMethods := methodsGroupedByClass keys groupedBy: 		[:each | 		| absoluteName |		absoluteName := each instanceBehavior absoluteName.		(absoluteClassNames includes: absoluteName)			ifTrue: [#defined]			ifFalse: [#extended]].	orderedClasses := (SystemUtils metaclassesFirst: (SystemUtils sortForAtomicLoading: (classifiedMethods at: #defined ifAbsent: [#()])))		addAll: (SystemUtils metaclassesFirst: (SystemUtils sortForAtomicLoading: (classifiedMethods at: #extended ifAbsent: [#()])));		yourself.	orderedClasses do: [:each | orderedMethods addAll: (methodsGroupedByClass at: each)].	^orderedMethods.</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $&lt;;		nextPutAll: package name;		nextPut: $&gt;.</body></methods><methods><class-id>ShadowPackageCompileManager</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="hasChangesToLoad">hasChangesToLoad	^shadowObjects notEmpty or:		[unloadableDefinitions notEmpty or:		[packageComparitor notNil and:		[packageComparitor hasDifferences]]]</body><body package="Atomic Compiling and Loading" selector="proceedToLoad">proceedToLoad	^#displayDialog = AtomicLoader loadFailOption		ifTrue: [Dialog confirm: (#LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?')]		ifFalse: [true]</body><body package="Atomic Compiling and Loading" selector="shouldTryToLoad">shouldTryToLoad	^#(#loadButNotify #displayDialog #load) includes: AtomicLoader loadFailOption</body></methods><methods><class-id>ShadowPackageCompileManager class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="root:">root: aShadowRoot		^(self new)		initializeRoot: aShadowRoot;		yourself</body><body package="Atomic Compiling and Loading" selector="root:pundle:">root: aShadowRoot pundle: aPackage		^(self new)		initializeRoot: aShadowRoot;		package: aPackage;		yourself</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>actions</category><body package="StoreForGlorpBrowserUI" selector="browseLocalSelectors">browseLocalSelectors	| node results |	node := self findNode.	(node isNil or: [node isMessage not])		ifFalse: 			[results := self environment implementorsOf: node selector.			results notEmpty				ifTrue: [results openEditor]				ifFalse: 					[Dialog						warn: (#NoLocalImplementorsOf1pFound &lt;&lt; #store								&gt;&gt; 'No local implementors of &lt;1p&gt; found' expandMacrosWith: node selector)]]</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>updating</category><body package="StoreForGlorpBrowserUI" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender	"I don't do this, at least not for now"</body><body package="StoreForGlorpBrowserUI" selector="updateContents">updateContents	| compiledMethod source text |	modified := false.	self updateTextWidget.	(self selectors size &gt; 1 or: [self selectedClass isNil])		ifTrue: [^self text: ''].	self selector isNil		ifTrue: [^self text: ''].	compiledMethod := self methodClass compiledMethodAt: self selector				ifAbsent: [self warn: #MethodHasBeenRemoved &lt;&lt; #pdp &gt;&gt; 'Method has been removed'.					^self text: ''].	source := self methodClass sourceCodeForMethod: compiledMethod				at: self selector.	text := self formatSource: source for: compiledMethod.	self text: text.	self updateSelection</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>private-environments</category><body package="StoreForGlorpBrowserUI" selector="protocolEnvironment">protocolEnvironment	^StoreProtocolEnvironment 		onEnvironment: self wrappedEnvironment		class: self selectedClass		protocols: self protocols</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI" selector="menuAugmentationRoot">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>testing</category><body package="Store-Ownership" selector="isGroup">isGroup	^self type = self class groupType</body><body package="Store-Ownership" selector="isUser">isUser	^self type = self class userType</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="initialize">initialize	self makeUser.</body><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	groupName := aStream upToSeparator.	aStream skipSeparators.	userName := aStream upToSeparator.	aStream skipSeparators.	type := aStream upToSeparator.	type := type asSymbol.</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>printing</category><body package="Store-Ownership" selector="itemString">itemString	^userName asString,	(self isUser		ifTrue:	['  [', (groupName isNil ifTrue: [''] ifFalse: [groupName asString]),']']		ifFalse:	[''])</body><body package="Store-Ownership" selector="printOn:">printOn: aStream	aStream nextPutAll: self userName asString."	aStream nextPutAll:	( self isUser		ifTrue:	['  [', ( groupName isNil ifTrue: [ '' ] ifFalse: [ groupName asString ] ),']' ]		ifFalse:	[ '' ]	)."</body><body package="Store-Ownership" selector="storeOn:">storeOn: aStream	aStream nextPutAll: groupName; tab.	aStream nextPutAll: userName; tab.	aStream nextPutAll: type asString; cr.</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>support</category><body package="Store-Ownership" selector="updateInDatabase">updateInDatabase	"Added by Philippe F. Monnet of Andersen Consulting"		self broker process: 			( self newSQL				update;				column: #groupName equalTo: self groupName printString;				where;				column: #userName equalTo: userName printString)</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>relationships</category><body package="Store-Ownership" selector="containsUserNamed:">containsUserNamed: aUserName	"Answer true if aUserName is the receiver, or contained in the receiver's users."	self isUser 	ifTrue: [ ^userName asUppercase = aUserName asUppercase ].	^( self class userNamesInGroupNamed: userName ) includes: aUserName.</body><body package="Store-Ownership" selector="relatedBy:">relatedBy: relToken	"Anwer set of relations. Main relationship is owner-&gt;pundle."	relToken == #tt_ownsRel		ifTrue: [ ^( self class pundlePrivilegesClass pundlesUser: self privilege: #owner ) asSet ].	relToken == #readRel		ifTrue: [ ^( self class pundlePrivilegesClass pundlesUser: self privilege: #read )  asSet ].	relToken == #publishRel		ifTrue: [ ^( self class pundlePrivilegesClass pundlesUser: self privilege: #publish ) asSet ].	^super relatedBy: relToken</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>accessing</category><body package="Store-Ownership" selector="groupName">groupName	"Answer the receiver's groupName."	^groupName</body><body package="Store-Ownership" selector="groupName:">groupName: newGroupName	"Set the receiver's groupName to newGroupName."	groupName := newGroupName</body><body package="Store-Ownership" selector="makeGroup">makeGroup	self type: self class groupType</body><body package="Store-Ownership" selector="makeUser">makeUser	self type: self class userType</body><body package="Store-Ownership" selector="name">name	"Answer the receiver's userName."	^self userName</body><body package="Store-Ownership" selector="type">type	"Answer the receiver's type."	^type</body><body package="Store-Ownership" selector="type:">type: newType	"Set the receiver's type to newType."	type := newType</body><body package="Store-Ownership" selector="userName">userName	"Answer the receiver's userName."	^userName == nil		ifTrue: [ '' ]		ifFalse: [ userName ]</body><body package="Store-Ownership" selector="userName:">userName: newUserName	"Set the receiver's userName to newUserName."	userName := newUserName</body><body package="Store-Ownership" selector="userType">userType	"Answer the receiver's type."	^type</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>comparing</category><body package="Store-Ownership" selector="&lt;=">&lt;= aDBUserGroup	aDBUserGroup class == self class		ifFalse: [ ^userName &lt;= aDBUserGroup name ].	^self isGroup = aDBUserGroup isGroup		ifTrue: [ userName &lt;= aDBUserGroup userName ]		ifFalse: [ self isGroup ].</body><body package="Store-Ownership" selector="=">= aDBUserGroup		aDBUserGroup class == self class		ifFalse: [ ^false ].	^( type = aDBUserGroup userType )  &amp;  ( userName = aDBUserGroup userName ) &amp; ( groupName = aDBUserGroup groupName )</body><body package="Store-Ownership" selector="hash">hash	^type hash bitXor: ( userName hash bitXor: groupName hash )</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>instance creation</category><body package="Store-Ownership" selector="new">new	^super new initialize</body><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	| baby |	baby := self new.	baby readFrom: aStream.	^baby</body><body package="Store-Ownership" selector="removeUserNamed:inGroupNamed:">removeUserNamed: aUserName inGroupNamed: aGroupName	"Remove a user from a group."	self new	 	groupName: aGroupName;		userName: aUserName;		makeUser;		removeFromDatabase.</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>accessing</category><body package="Store-Ownership" selector="adminGroupName">adminGroupName	^'ADMINISTRATOR'</body><body package="Store-Ownership" selector="pundlePrivilegesClass">pundlePrivilegesClass	^DBPundlePrivileges</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>private-visual blocks</category><body package="Store-Ownership" selector="selectedVisualBlock">selectedVisualBlock	^	[:view :index | 	| str pkg |	pkg := view sequence at: index.	str := DbRegistry textForItem: pkg.	BoundedWrapper on: (LabelAndIcon with: str attributes: view textStyle) beCheckMark]</body><body package="Store-Ownership" selector="visualBlock">visualBlock	^	[:view :index | 	| str pkg |	pkg := view sequence at: index.	str := DbRegistry textForItem: pkg.	BoundedWrapper on: (Label			with: str			attributes: view textStyle			offset: 16 @ 0)]</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>tmp-tests</category><body package="Store-Ownership" selector="test2">test2	"self test2"	^self isUser: 'kuba' memberOf: #('bernstein')</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>public-query</category><body package="Store-Ownership" selector="allDistinctUserGroups">allDistinctUserGroups	^( self broker answerFromQuery: 				(self newSQL selectDistinct: #( userName type ))		bindInput: 				( self new makeUser; yourself )) 	collect: 		[ :row |		self new userName: row first; type: row last; yourself		].</body><body package="Store-Ownership" selector="allGroupNames">allGroupNames	"Answer a collection of group names."	"self allGroupNames"		^self answerSetFromQuery:  			( self newSQL				selectDistinct: #( groupName );				where;				column: #type  equalTo: ':type')		bindInput: ( self new makeGroup).</body><body package="Store-Ownership" selector="allUserGroups">allUserGroups	^self allRecords</body><body package="Store-Ownership" selector="allUserNames">allUserNames	"Answer a collection of user names."	"self allUserNames"		^self answerSetFromQuery: 				( self newSQL					selectDistinct: #( userName );					where;					column: #type equalTo: ':type')		bindInput: ( self new makeUser)</body><body package="Store-Ownership" selector="dbHasAdmin">dbHasAdmin		"self dbHasAdmin"	^self tableExists and:		[ ( self userNamesInGroupNamed: self adminGroupName ) notEmpty ]</body><body package="Store-Ownership" selector="groupNamed:">groupNamed: aUserName 	"A user named aUserName, or nil if none."		"self groupNamed: 'Developer'"	| aList inp |	inp := self new.	inp userName: aUserName.	inp makeGroup.	[aList := self processList: 		(self  broker process: 				( self newSQL					selectAll;					where;					column: #userName equalTo: ':userName';					and;					column: #type  equalTo: ':type') 		bindInput: inp		bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer. ^nil ].	^ (aList isNil or: [ aList isEmpty])		ifTrue: [ nil] 		ifFalse: [ aList first ].</body><body package="Store-Ownership" selector="groupNamesForUserNamed:">groupNamesForUserNamed: aUserName 	"Answer a collection of group names that the user belongs to."	^self answerSetFromQuery:  				( self newSQL					selectDistinct: #( groupName );					where;					column: #userName equalTo: ':userName';					and;					column: #type equalTo: ':type')		bindInput: 				(self new					userName: aUserName;					makeUser;					yourself)</body><body package="Store-Ownership" selector="groupsForUser:">groupsForUser: aUser	"Answer a collection of groups that the user belongs to."	^( self answerSetFromQuery: 					( self newSQL						selectDistinct: #( groupName );						where;						column: #userName  equalTo: ':userName';						and;						column: #type equalTo: ':type')			bindInput: aUser ) 		collect:		[ :gname | self groupNamed: gname ].</body><body package="Store-Ownership" selector="isInAdmin:">isInAdmin: userName	^( self userNamesInGroupNamed: self adminGroupName )		includes: userName.</body><body package="Store-Ownership" selector="isUser:memberOf:">isUser: aUserName memberOf: aCollectionOfNames	"Answer true if a user belongs to one of the groups specified in the collection of names."		| set |	set := self groupNamesForUserNamed: aUserName.	aCollectionOfNames do: [:each|  (set includes: each) ifTrue: [^true]].	^false</body><body package="Store-Ownership" selector="userName:type:">userName: aUserName type:  aType	^aType = self groupType		ifTrue: [ self groupNamed: aUserName ]		ifFalse: [ self userNamed: aUserName ].</body><body package="Store-Ownership" selector="userNamed:">userNamed: aUserName 	"A user named aUserName, or nil if none."		"self userNamed: 'BERN'"	| aList inp |	inp := self new.	inp userName: aUserName.	inp makeUser.	[aList := self processList:			(self broker 	process: 					( self newSQL						selectAll;						where;						column: #userName equalTo: ':userName';						and;						column: #type equalTo: ':type') 		bindInput: inp		bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer. ^nil ].	^ (aList isNil or: [ aList isEmpty])		ifTrue: [ nil] 		ifFalse: [ aList first ].</body><body package="Store-Ownership" selector="userNamesInGroupNamed:">userNamesInGroupNamed: aGroupName 	"Answer a collection of user names in the group."	^self answerSetFromQuery:  				( self newSQL					selectDistinct: #( userName );					where;					column: #groupName equalTo: ':groupName';					and;					column: #type equalTo: ':type')						bindInput: 				( self new					groupName: aGroupName;					makeUser;					yourself)</body><body package="Store-Ownership" selector="usersInGroupNamed:">usersInGroupNamed: aGroupName 	"Get all users that belong to aGroupName. Answer a collection of my instances."	^[self processList:		( self broker 			process: 					( self newSQL						selectAll;						where;						column: #groupName equalTo: ':groupName') 			bindInput: 					( self new 						groupName: aGroupName; 						yourself)			bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer. OrderedCollection new ].</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>installation</category><body package="Store-Ownership" selector="databasePrivilegesList">databasePrivilegesList	^ #( 'UPDATE' 'DELETE' 'INSERT')</body><body package="Store-Ownership" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'groupName' put: #PrimaryKeyString.	aDict at: 'userName' put: #PrimaryKeyString.	aDict at: 'type' put: #String.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-Ownership" selector="grantDatabasePrivilegesTo:">grantDatabasePrivilegesTo: userName	"This table is controlled by the system admin."	"self grantDatabasePrivilegesTo: 'eliot' "	[ self broker grantForClass: self 				permissions:  #( 'INSERT' 'UPDATE' 'DELETE')				toUsers:  userName	]	on: self connectionClass unableToExecuteSQLSignal 	do: [ :e | Dialog warn: e description ]</body><body package="Store-Ownership" selector="groupType">groupType	^'G'</body><body package="Store-Ownership" selector="indexParameters">indexParameters	^nil</body><body package="Store-Ownership" selector="needsSequence">needsSequence	^false</body><body package="Store-Ownership" selector="revokeDatabasePrivilegesFrom:">revokeDatabasePrivilegesFrom: userName	"This table is controlled by the system admin."	"self revokeDatabasePrivilegesTo: 'eliot' "	[ self  broker revokeForClass: self 				permissions: #('INSERT'  'UPDATE'  'DELETE' )				fromUsers:  userName	]	on: self connectionClass unableToExecuteSQLSignal 	do: [ :e | Dialog warn: e description ]</body><body package="Store-Ownership" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"This table is controlled by the system admin."	self broker grantForClass: self permissions: #('SELECT') toUsers: #('PUBLIC')</body><body package="Store-Ownership" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy userAndOwnershipTableSpace</body><body package="Store-Ownership" selector="userType">userType	^'U'</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>menus</category><body package="Store-Ownership" selector="newUserNamed:inGroupNamed:">newUserNamed: aUserName inGroupNamed: aGroupName	"Add a user to a group."	| dbuser |	( dbuser  := self new )	 	groupName: aGroupName;		userName: aUserName;		makeUser.	[ dbuser installInDatabase ] 	on: self broker indexConflictSignal 	do: 	[ : e | e return ].			"adding again not really a mistake?"</body></methods><methods><class-id>Store.PrerequisiteUnableToLoadConfirmation</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	^Dialog confirm: messageText</body></methods><methods><class-id>Store.PrerequisiteUnableToLoadConfirmation</class-id> <category>constants</category><body package="Store-Base" selector="defaultResumeValue">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="Store-Base" selector="defaultReturnValue">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.PrerequisiteUnableToLoadConfirmation class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private-selector</category><body package="StoreForGlorpBrowserUI" selector="fileNameForSelectors">fileNameForSelectors		| sel |	sel := self definition isForSharedVariable		ifTrue: [self definition classOrNameSpace name , '-' , self definition variableName]		ifFalse:			[self selectedClass simpleNameWithMeta , '-' , (self selector asSymbol isKeyword				ifTrue:					[(self selector asSymbol keywords						inject: (WriteStream on: (String new: 20))						into:							[:sum :each | 							sum								nextPutAll: (each copyFrom: 1 to: each size - 1);								yourself]) contents]				ifFalse: [self selector])].	^Dialog requestNewFileName: #FileOutAs &lt;&lt; #browser &gt;&gt; 'File out as' default: (self filterFilename: sel , '.st')</body><body package="StoreForGlorpBrowserUI" selector="fileOutMessage">fileOutMessage	| fileName fileManager method shared |	fileName := self fileNameForSelectors.	fileName isEmpty ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	self definitions do: 		[:each | 		each isForSharedVariable 			ifTrue: 				[shared := self environment sharedVariable: each variableName for: each fullName.				shared fileOutSourceOn: fileManager]			ifFalse: 				[method := self environment methodNamed: each selector inClass: each implementingClass.				method fileOutSourceOn: fileManager]]] 			ensure: [fileManager close]</body><body package="StoreForGlorpBrowserUI" selector="spawnMethod">spawnMethod	self showWaitCursorWhile: 			[self openBrowserOnEnvironment: (StoreSelectorEnvironment						onMethods: self definitions						in: environment)]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private-class</category><body package="StoreForGlorpBrowserUI" selector="fileOutGlobal">fileOutGlobal		| theGlobals fileName fileManager |	(theGlobals := self selectedGlobals) isEmpty ifTrue: [^self warn: #NoLocallyDefined &lt;&lt; #store&gt;&gt; 'No locally defined objects selected'].	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (self filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: theGlobals first name)).	fileName isEmpty ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	theGlobals do: [:each | each fileOutSourceOn: fileManager]] 		ensure: [fileManager close]</body><body package="StoreForGlorpBrowserUI" selector="printOutClass">printOutClass	"Print the class."	| stream |	stream := TextStream on: (String new: 1000).	self selectedBindings do: [:each | each printOutOn: stream].	self hardcopyStream: stream</body><body package="StoreForGlorpBrowserUI" selector="spawnClass">spawnClass	self showWaitCursorWhile: 			[| allClasses |			allClasses := OrderedCollection withAll: self nonMetaClasses.			allClasses addAll: (self nonMetaClasses collect: [:each | each storeMetaClass]).			self 				openBrowserOnEnvironment: ((StoreForGlorpBrowserEnvironment on: self pundle) forClasses: allClasses)]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>accessing-pundles</category><body package="StoreForGlorpBrowserUI" selector="findPundle">findPundle		| dialog thePundle |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: (self sortedPundleList: environment allPundles)		filterBlock: [:entry :pundle | entry , '*' match: pundle name].	dialog		windowLabel: #FindPackageOrBundle &lt;&lt; #browser &gt;&gt; 'Find Package or Bundle';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #PackagesAndBundlesC &lt;&lt; #browser &gt;&gt; 'Packages and Bundles:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #toolListText;		iconSelector: #toolListIcon.	thePundle := dialog select.	thePundle isNil ifTrue: [^self].	self selectPundle: thePundle</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private-category</category><body package="StoreForGlorpBrowserUI" selector="findClass">findClass		| dialog theSelection |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: environment allClasses		filterBlock: [:entry :item | entry , '*' match: item name].	dialog		windowLabel: #FindClass &lt;&lt; #dialogs &gt;&gt; 'Find Class';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #ClassesC &lt;&lt; #labels &gt;&gt; 'Classes:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #displayString;		iconSelector: #toolListIcon.	theSelection := dialog select.	theSelection isNil ifTrue: [^self].	self setBinding: theSelection</body><body package="StoreForGlorpBrowserUI" selector="findNameSpace">findNameSpace		| dialog theSelection |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: environment allNameSpaces		filterBlock: [:entry :item | entry , '*' match: item name].	dialog		windowLabel: #FindNamespace &lt;&lt; #dialogs &gt;&gt; 'Find Namespace';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #NamespacesC &lt;&lt; #labels &gt;&gt; 'Namespaces:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #displayString;		iconSelector: #toolListIcon.	theSelection := dialog select.	theSelection isNil ifTrue: [^self].	self setBinding: theSelection</body><body package="StoreForGlorpBrowserUI" selector="findSharedVariable">findSharedVariable		| dialog theSelection |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: environment allShared		filterBlock: [:entry :item | entry , '*' match: item name].	dialog		windowLabel: #FindSharedVariable &lt;&lt; #dialogs &gt;&gt; 'Find Shared Variable';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #SharedVariablesC &lt;&lt; #labels &gt;&gt; 'SharedVariables';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #longNameFromSmalltalk;		iconSelector: #toolListIcon.	theSelection := dialog select.	theSelection isNil ifTrue: [^self].	self setBinding: theSelection</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>menus</category><body package="StoreForGlorpBrowserUI" selector="menuNameFor:">menuNameFor: aSelector	"Our selectors arrive as strings from glorp;  check this."	| selector |	selector := aSelector asSymbol.	selector isEmpty ifTrue: [^(#emptySymbol &lt;&lt; #browser &gt;&gt; '-empty symbol-')].	selector isInfix ifFalse: [^super menuNameFor: selector].	^selector asString copyReplaceAll: '&amp;' with: '&amp;&amp;'</body><body package="StoreForGlorpBrowserUI" selector="windowMenuItems">windowMenuItems	"Provide CodeTool menus on the main ToolBar."	| items |	items := OrderedCollection new.	items		add: (#_Class &lt;&lt; #browser &gt;&gt; '&amp;Class') asString					-&gt; (self menuNamed: #classMenu);		add: (#_Method &lt;&lt; #browser &gt;&gt; '&amp;Method') asString					-&gt; (self menuNamed: #selectorMenu).	^items</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="browserClass">browserClass	^StoreRefactoringBrowser</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>aspects</category><body package="StoreForGlorpBrowserUI" selector="ClassAndMethodTabNavigatorPart">ClassAndMethodTabNavigatorPart	^partsDictionary at: #StoreClassAndMethodTabNavigatorPart		ifAbsentPut: [parts add: (StoreClassAndMethodTabNavigatorPart onNavigator: self)]</body><body package="StoreForGlorpBrowserUI" selector="ClassNavigatorPart">ClassNavigatorPart	^partsDictionary at: #StoreClassNavigatorPart		ifAbsentPut: [parts add: (StoreClassNavigatorPart onNavigator: self)]</body><body package="StoreForGlorpBrowserUI" selector="CodeComponentTabNavigatorPart">CodeComponentTabNavigatorPart	^partsDictionary at: #StoreCodeComponentTabNavigatorPart		ifAbsentPut: [parts add: (StoreCodeComponentTabNavigatorPart onNavigator: self)]</body><body package="StoreForGlorpBrowserUI" selector="NameSpaceItemTabNavigatorPart">NameSpaceItemTabNavigatorPart		^partsDictionary		at: #StoreNameSpaceItemTabNavigatorPart		ifAbsentPut:			[parts add: ((StoreNameSpaceItemTabNavigatorPart onNavigator: self)				showProtocols: true;				yourself)]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="getState">getState	"Shadow browsers need to have their state initialized with the right environment (as do loaded ones until we provide a global access to loaded glorp store models)."	^super getState		environment: self environment;		yourself</body><body package="StoreForGlorpBrowserUI" selector="navigatorStateClass">navigatorStateClass		^StoreForGlorpNavigatorState</body><body package="StoreForGlorpBrowserUI" selector="setBinding:">setBinding: aBinding 	| newState owner |	newState := self getState.	newState clearClassDependentFields.	(aBinding isForNameSpace not and: [aBinding isForClassOrExtension not])		ifTrue: 			[owner := aBinding isInClass				ifTrue: [environment classForName:aBinding absoluteOwnerName asString]				ifFalse: [environment nameSpaceForName: aBinding absoluteOwnerName asString].			newState				objectName: owner fullRootName;				protocols: #();				definition: (StoreRBInitializerDefinition nameSpace: owner key: aBinding name)]		ifFalse: [newState objectName: aBinding fullRootName].	self updateWithState: newState</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>store-shared variables</category><body package="StoreForGlorpBrowserUI" selector="sharedVariableBinding">sharedVariableBinding	^self state selectedShareds first</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>actions</category><body package="StoreForGlorpBrowserUI" selector="fileOutMethodProtocol">fileOutMethodProtocol		| fileManager fileName methods |	fileName := Dialog		requestNewFileName: #FileOutAs &lt;&lt; #browser &gt;&gt; 'File out as'		default: (self filterFilename: self selectedClass simpleNameWithMeta , '-' , self protocol , '.st').	fileName isEmpty ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	self protocols do: 		[:each | 		methods := (self environment selectorsFor: each in: self selectedClass) collect: [:eachSelector | self environment methodNamed: eachSelector inClass: self selectedClass].		methods do: [:eachMethod | eachMethod fileOutSourceOn: fileManager]]]			ensure: [fileManager close]</body><body package="StoreForGlorpBrowserUI" selector="inspectClasses">inspectClasses	| items |	items := self selectedBindings.	items size &gt; 1	 	ifTrue: [items inspect]		ifFalse: [items first inspect]</body><body package="StoreForGlorpBrowserUI" selector="inspectPundle">inspectPundle	| items |	items := self pundles.	items size &gt; 1	 	ifTrue: [items inspect]		ifFalse: [items first inspect]</body><body package="StoreForGlorpBrowserUI" selector="inspectSelected">inspectSelected	| items |	items := self definitions.	items := (items allSatisfy: #isForSharedVariable)		ifTrue: [state selectedShareds]		ifFalse: [state selectedMethods].	items size &gt; 1	 	ifTrue: [items inspect]		ifFalse: [items first inspect]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI" selector="menuAugmentationRoot">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>store-classes</category><body package="StoreForGlorpBrowserUI" selector="storeClass">storeClass	^state classesAndNameSpaces first</body><body package="StoreForGlorpBrowserUI" selector="storeCompareBindingWithVersion:">storeCompareBindingWithVersion: binding		self dbRegistry doIfOnlineImage:		[| trace |		trace := binding isForSharedVariable			ifTrue: [self storeSharedVariableClass selectVersionNamed: binding name inOwner: binding absoluteOwnerName asString]			ifFalse:				[binding isForClassOrExtension					ifTrue: [self storeClassClass selectVersionNamed: binding name]					ifFalse: [self storeNameSpaceClass selectVersionNamed: binding name]].		trace isNil ifTrue: [^self].		self comparisonBrowserClass compareClass: binding toClass: trace]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>changing</category><body package="StoreForGlorpBrowserUI" selector="changeRequest">changeRequest	"The receiver wants to change; We don't do changes in the Store/Glorp version."	^true</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>store-methods</category><body package="StoreForGlorpBrowserUI" selector="storeMethod">storeMethod	^self state selectedMethods first.</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>browsing</category><body package="StoreForGlorpBrowserUI" selector="browseGlobalImplementors">browseGlobalImplementors	"In Store Browsers a selector is always a String."	self browseGlobalImplementorsOf: self selector asSymbol</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator</class-id> <category>private-protocol</category><body package="StoreForGlorpBrowserUI" selector="inheritedSelectors">inheritedSelectors	| selectors currentClass inheritToClass |	selectors := Set new.	currentClass := self selectedClass.	self inheritToClass ifNil: [self halt].	inheritToClass := self inheritToClass superclass.	[currentClass notNil and: [currentClass ~= inheritToClass]] whileTrue: 			[selectors addAll: (self environment selectorsForClass: currentClass).			currentClass := currentClass superclass].	^selectors</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator class</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="classSpecQuery">classSpecQuery		^[:navigator | 	navigator environment useSingleClassNavigator		ifTrue:			[| classNames |			classNames := navigator environment classNames asArray.			classNames isEmpty				ifTrue: [nil]				ifFalse:					[| packages |					packages := navigator environment pundles.					navigator						addConstantStateBlock:							[:ns | 							ns pundles: packages.							ns objectName: classNames first].					#classWindowSpec]]		ifFalse: [nil]]</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>testing</category><body package="Store-Change Management" selector="belongsToClass">belongsToClass	^self isInClass</body><body package="Store-Change Management" selector="existsInImage">existsInImage	^self subclassResponsibility</body><body package="Store-Change Management" selector="is:meaningfulChangeOf:">is: aRecord meaningfulChangeOf: aPackage	"Determine if modification is a meaningful change"	^aRecord == nil or: [self isMeaningfulChange: aRecord]</body><body package="Store-Change Management" selector="isClassCommentTag">isClassCommentTag	^false</body><body package="Store-Change Management" selector="isClassTag">isClassTag	^false</body><body package="Store-Change Management" selector="isCommentChange">isCommentChange		^self isClassCommentTag | self isNameSpaceCommentTag</body><body package="Store-Change Management" selector="isCommentTag">isCommentTag		^self isClassCommentTag | self isNameSpaceCommentTag</body><body package="Store-Change Management" selector="isComponentTag">isComponentTag	^false</body><body package="Store-Change Management" selector="isDataTag">isDataTag	^false</body><body package="Store-Change Management" selector="isForClass">isForClass	^false</body><body package="Store-Change Management" selector="isForData">isForData	^false</body><body package="Store-Change Management" selector="isForMethod">isForMethod	^false</body><body package="Store-Change Management" selector="isForNameSpace">isForNameSpace	^false</body><body package="Store-Change Management" selector="isInClass">isInClass	^false</body><body package="Store-Change Management" selector="isMeaningfulChange:">isMeaningfulChange: aRecord	^aRecord sameAsImage not</body><body package="Store-Change Management" selector="isMethodTag">isMethodTag	^false</body><body package="Store-Change Management" selector="isNameSpaceCommentTag">isNameSpaceCommentTag	^false</body><body package="Store-Change Management" selector="isNameSpaceTag">isNameSpaceTag	^false</body><body package="Store-Change Management" selector="isPropertyTag">isPropertyTag	^false</body><body package="Store-Change Management" selector="isStructureTag">isStructureTag	^false</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^false</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord	"Load the change. Answer true is the operation is successful."	self subclassResponsibility</body><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag	can be load into the image.	For methods and meta classes the class has to be already	loaded."	^self actualClass notNil</body><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: aPackage from: aRecord 	"Make sure that modification goes to the proper package."	self canLoad		ifFalse: 			[ Dialog warn: ( (#DefinitionFor1sCaE2sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Definition for &lt;1s&gt; cannot be loaded since &lt;2s&gt; is not loaded.') expandMacrosWith: self printString with: symbol ).			^false 			].	Policies packagePolicy forcePackage: aPackage while: 		[ ^aRecord == nil			ifTrue: 				[ self existsInImage 					ifTrue: [ self removeFromSystemTolerant: false fromPackage: aPackage ].				true				]			ifFalse: [ self applyDefinitionFrom: aRecord ]		].</body><body package="Store-Change Management" selector="removeFromSystem">removeFromSystem	self removeFromSystemTolerant: true fromPackage: self containingPackage</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="absoluteName">absoluteName	^self name</body><body package="Store-Change Management" selector="actual">actual	^self actualClass</body><body package="Store-Change Management" selector="actualClass">actualClass	"Answer the class in the image that the reciever applies to. nil if none."	^symbol asStrictReference ifDefinedDo: 		[ :cls | self isMeta 					ifTrue: [ cls class ]					ifFalse: [ cls ].		].</body><body package="Store-Change Management" selector="class:">class: aClass	isMeta := aClass isMeta.	symbol := 		( isMeta 			ifTrue: [ aClass soleInstance ] 			ifFalse: [aClass]		) absoluteName asSymbol</body><body package="Store-Change Management" selector="className">className	"Return the name as a string, in 'Foo' or 'Foo class' form."	^self isMeta ifTrue: [symbol asString, ' class'] ifFalse: [symbol asString]</body><body package="Store-Change Management" selector="className:">className: aClassName 	"Set the class from a name string."	symbol := aClassName asClassNameOnly asSymbol</body><body package="Store-Change Management" selector="classSymbol">classSymbol	^symbol</body><body package="Store-Change Management" selector="classSymbol:">classSymbol: aSymbol	symbol := aSymbol asClassNameOnly asSymbol</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me."	^self subclassResponsibility</body><body package="Store-Change Management" selector="description">description	self subclassResponsibility</body><body package="Store-Change Management" selector="fullClassName">fullClassName	^symbol</body><body package="Store-Change Management" selector="isMeta">isMeta	^isMeta</body><body package="Store-Change Management" selector="isMeta:">isMeta: aBoolean	isMeta := aBoolean</body><body package="Store-Change Management" selector="meta:">meta: aBoolean	isMeta := aBoolean</body><body package="Store-Change Management" selector="name">name	"Return the name as a string."	^symbol asString</body><body package="Store-Change Management" selector="name:">name: aName 	"Set the class/namespace from a name string."	symbol := aName asSymbol.</body><body package="Store-Change Management" selector="nonMetaClassName">nonMetaClassName	^symbol asClassNameOnly asSymbol</body><body package="Store-Change Management" selector="package:">package: aPackage	"most of us don't need this"</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	^self subclassResponsibility</body><body package="Store-Change Management" selector="sourceTextForImage:">sourceTextForImage: aPackage	^self sourceTextForImage</body><body package="Store-Change Management" selector="sourceTextForPackage:">sourceTextForPackage: aPackage	^aPackage sourceForTag: self</body><body package="Store-Change Management" selector="sourceTextForPackageID:">sourceTextForPackageID: anID	^self sourceTextForPackage: (Package aRecordWithID: anID)</body><body package="Store-Change Management" selector="symbol">symbol	^symbol</body><body package="Store-Change Management" selector="symbol:">symbol: aSymbol	symbol := aSymbol</body><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^self class tagBaseIndex</body><body package="Store-Change Management" selector="tagIndex">tagIndex	^self tagBaseIndex + 		( self isMeta			ifTrue: [self class metaOffset ]			ifFalse: [0]		)</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>printing</category><body package="Store-Change Management" selector="printOn:">printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self name.	aStream nextPut: $].</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>actions</category><body package="Store-Change Management" selector="browseVersions">browseVersions	Dialog warn: (#NotYetImplemented &lt;&lt; #store &gt;&gt; 'Not yet implemented')</body><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	self subclassResponsibility.	^nil</body><body package="Store-Change Management" selector="moveFromPackage:toPackage:">moveFromPackage: oldPackage toPackage: newPackage 	self moveFromPackage: oldPackage toPackage: newPackage	ifNotLoaded: 		[self error: (#AttemptingToMoveADNThatIsNotLoaded &lt;&lt; #store &gt;&gt; 'Attempting to move a definition that is not loaded.')]</body><body package="Store-Change Management" selector="moveFromPackage:toPackage:ifNotLoaded:">moveFromPackage: oldPackage toPackage: newPackage ifNotLoaded: aBlock	^self moveToPackage: newPackage ifNotLoaded: aBlock</body><body package="Store-Change Management" selector="moveToPackage:">moveToPackage: newPackage 	self moveToPackage: newPackage	ifNotLoaded: 		[self error: (#AttemptingToMoveADNThatIsNotLoaded &lt;&lt; #store &gt;&gt; 'Attempting to move a definition that is not loaded.')]</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock  	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	^self subclassResponsibility</body><body package="Store-Change Management" selector="browseSystemVersionIfExists">browseSystemVersionIfExists	"Open a browser on the system version of this override if possible.	 Answer if it was possible."	self existsInImage		ifFalse: [ ^false ].	self browseSystemVersion.	^true</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management" selector="fileOutOn:from:in:">fileOutOn: aStream from: aRecord in: aPackage	"Fileout the change onto aStream."		(aRecord == nil and: [self existsInImage not]) ifTrue: 		[^self fileOutRemovalOn: aStream].	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[(aStream sourceFormatter)			attributeFor: #package compute: [:ignore | aPackage name];			attributeForMethods: #package compute: [:ignore :moreIgnore | aPackage name]].	aRecord isNil 		ifTrue: [self fileOutOn: aStream] 			ifFalse: [self fileOutOn: aStream from: aRecord]</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#other</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>converting</category><body package="Store-Change Management" selector="asChange">asChange	"Answer the receiver as an instance of Change."	^Change new classSymbol: self classSymbol.		"good enough for most"</body><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aTag	| obj |	aTag class == self class		ifFalse: [^false].	obj := self actual.	^obj notNil		ifTrue: [obj == aTag actual]		ifFalse:			[aTag class == self class and:				[symbol == aTag symbol and: [isMeta == aTag isMeta]]]</body></methods><methods><class-id>Store.AbstractTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="classTagIndices">classTagIndices	"The indices for class like things (no subsequent key)."	"Class, Class comment, Meta-Class, Meta-Class comment"	^Array 		with: ClassTag tagBaseIndex		with: ClassCommentTag tagBaseIndex		with: ClassTag tagBaseIndex + self metaOffset		with: ClassCommentTag tagBaseIndex + self metaOffset.</body><body package="Store-Change Management" selector="componentTagIndices">componentTagIndices	"The indices for component related things, like properties 	and bundle structure."	^Array 		with: PropertyTag tagBaseIndex		with: BundleStructureTag tagBaseIndex</body><body package="Store-Change Management" selector="maxTagIndex">maxTagIndex	^11</body><body package="Store-Change Management" selector="metaOffset">metaOffset	"Offset added to class and class methods to get meta side"	^4</body><body package="Store-Change Management" selector="nameSpaceTagIndices">nameSpaceTagIndices	"The indices for namespace like things (no subsequent key)."	"NameSpace, NameSpace comment (?)"	^Array 		with: NameSpaceTag tagBaseIndex		with: NameSpaceCommentTag tagBaseIndex</body><body package="Store-Change Management" selector="subdefTagIndices">subdefTagIndices	"The indices for method like things (subsequent key)."	"instance methods, data, class methods"	^( OrderedCollection 			with: MethodTag tagBaseIndex			with: DataTag tagBaseIndex				with: MethodTag tagBaseIndex + self metaOffset	  ) addAll: self componentTagIndices;	    asArray</body><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	"Answer the unique index for each subclass."	^self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClass:">newClass: aClass	^self new class: aClass</body><body package="Store-Change Management" selector="newClassName:">newClassName: aString	^self new className: aString</body><body package="Store-Change Management" selector="newClassName:isMeta:">newClassName: aString  isMeta: aBoolean	^self new className: aString;  isMeta: aBoolean</body><body package="Store-Change Management" selector="newClassSymbol:isMeta:">newClassSymbol: aSymbol isMeta: aBoolean	^self new classSymbol: aSymbol; isMeta: aBoolean</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me, nil if none."	^package == nil		ifTrue: [ Registry pundleNamed: symbol asString ]		ifFalse: 			[ package isPackage				ifTrue: [ Registry packageNamed: package name ]				ifFalse: [ Registry bundleNamed: package name ]			].</body><body package="Store-Change Management" selector="package">package	"Answer the package/bundle from whence we came"	^package</body><body package="Store-Change Management" selector="package:">package: aPackage	"Set the package"	package := aPackage.	package == nil		ifFalse: [ symbol := aPackage name asSymbol ].</body><body package="Store-Change Management" selector="packageName">packageName	^package == nil		ifTrue: [ '' ]		ifFalse: [ package name ].</body><body package="Store-Change Management" selector="text">text	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>actions</category><body package="Store-Change Management" selector="moveToPackage:">moveToPackage: newPackage	"meaningless in this context."	self shouldNotImplement.</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock  	"meaningless in this context."	self shouldNotImplement.</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>testing</category><body package="Store-Change Management" selector="isComponentTag">isComponentTag	^true</body><body package="Store-Change Management" selector="isMeta">isMeta	^false</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^true</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag can be load into the image."	^self shouldNotImplement</body><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: imgPackage from: dbPackage	"Make sure that modification goes to the proper package."	( imgPackage == nil ) | ( dbPackage == nil )		ifTrue: 			[ Dialog warn: ( (#_1sCannotBeLoadedAckageIsNotLoaded &lt;&lt; #store &gt;&gt; '&lt;1s&gt; cannot be loaded since the package is not loaded.') 				expandMacrosWith: self printString ).			^false 			].	self applyDefinitionFrom: dbPackage into: imgPackage.	^true</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>converting</category><body package="Store-Change Management" selector="asChange">asChange	"Answer the receiver as an instance of Change."	^ComponentRelatedChange new tag: self</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aTag	^super = aTag and:		[self text = aTag text]</body><body package="Store-Change Management" selector="sameAsImage">sameAsImage	^self text = self sourceTextForImage</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="description">description	^property</body><body package="Store-Change Management" selector="name">name	^'&lt;1s&gt; propertyAt: &lt;2s&gt;' 		expandMacrosWith: symbol		with: self property printString</body><body package="Store-Change Management" selector="property">property	"Answer the property symbol represented by this tag"	^property</body><body package="Store-Change Management" selector="property:">property: aSymbol	"Set the property symbol represented by this tag"	property := aSymbol</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	^self sourceTextForImage: self containingPackage</body><body package="Store-Change Management" selector="sourceTextForImage:">sourceTextForImage: aPackage	| value |	aPackage == nil		ifTrue: [ ^nil  ].	value := aPackage propertyAt: self property.	value == nil		ifTrue: [ ^nil ].	^( self convertValue: value ) asText</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^property</body><body package="Store-Change Management" selector="text">text	^self convertValue: ( package propertyAt: self property ifAbsent: [ '' ] ).</body><body package="Store-Change Management" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	| value |	value := package propertyAt: aTag property ifAbsent: nil. 	^self convertValue: value.</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	| pkg |	^( pkg := self containingPackage ) ~~ nil 		and: [ ( pkg propertyAt: self property ifAbsent: nil ) ~~ nil ]</body><body package="Store-Change Management" selector="is:meaningfulChangeOf:">is: dbPackage meaningfulChangeOf: imgPackage 	^imgPackage == nil | (dbPackage == nil) or: 			[(imgPackage propertyAt: self property ifAbsent: nil) 				~= (dbPackage propertyAt: self property ifAbsent: nil)]</body><body package="Store-Change Management" selector="isPropertyTag">isPropertyTag	^true</body><body package="Store-Change Management" selector="sameAsImage">sameAsImage	^(package propertyAt: property ifAbsent: [^false]) = (self containingPackage propertyAt: property ifAbsent: [^false])</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:into:">applyDefinitionFrom: dbPackage into: imgPackage	"Load the change. Answer true is the operation is successful."	| dbp value |	"special case because of merge tool/changelist incompat"	"for changelist properties, the tag is needed to correctly filein"	dbp := dbPackage class == self class 			ifTrue: [ dbp := dbPackage package ]		ifFalse: [ dbPackage ].	dbp isLoaded		ifTrue: [ ^true ].		"already the in image version"	value :=  dbp propertyAt: self property ifAbsent: nil. 	[ imgPackage perform: ( self property, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | imgPackage propertyAt: self property put: value. e return ].	^true.</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	aPackage propertyAt: property put: nil</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| pkg |	^( pkg := self containingPackage ) == nil		ifTrue: [ false ]		ifFalse: [ pkg propertyAt: self property put: someText. true ].</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>converting</category><body package="Store-Change Management" selector="convertValue:">convertValue: value	^value isString		ifTrue: [ value ]		ifFalse: 			[ ( value isKindOf: BlockClosure )				ifTrue: [ CodeComponent stringFromAction: value ] 				ifFalse: [ value printString ]			].</body><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch. Answer nil if it's someone elses property"	^( ( package isNil ) or: [ package comparesTo: aPackage ] )		ifTrue: [ aPackage recordForPropertyTag: self ]</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	( package propertyAt: property ifAbsent: nil ) inspect.</body><body package="Store-Change Management" selector="definition">definition	^self text</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	package == nil		ifFalse: 			[ aStream				component: package componentType				named: package name				property: property				value: ( package propertyAt: property ifAbsent: nil )			].</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aStream		component: aRecord componentType		named: aRecord name		property: property		value: ( aRecord propertyAt: property ifAbsent: nil )</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	package == nil		ifFalse: 			[ aStream				component: package componentType				named: package name				property: property				value: ( package propertyAt: property ifAbsent: nil )			].</body><body package="Store-Change Management" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: aPackage confirm: aBoolean	"Load the receiver by setting the property value."	| value |	aBoolean 		ifTrue: 			[ ( Dialog confirm: ( (#ResetProperty1s &lt;&lt; #store &gt;&gt; 'Reset property &lt;1s&gt;?') expandMacrosWith: property ) )				ifFalse: [ ^self ].			].	value :=   package propertyAt: property ifAbsent: nil.	[ aPackage perform: ( property, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | aPackage propertyAt: property put: value. e return ].</body></methods><methods><class-id>Store.PropertyTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="package:property:">package: aPackage property: aSymbol	"Answer a tag that represents a change  in a property."	"Note - needs the package to be complete."	^self new		package: aPackage;		property: aSymbol;		yourself.</body></methods><methods><class-id>Store.PropertyTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^10</body></methods><methods><class-id>AtomicLoader</class-id> <category>private-installation</category><body package="Atomic Compiling and Loading" selector="fixAndInstallClassNotification:">fixAndInstallClassNotification: aRedefinitionNotification		| overridden |	overridden := workingResult overrides 		detect: [:each | each isForClass and: [each fullName = aRedefinitionNotification override absoluteName]]		ifNone: [nil].	overridden isNil		ifTrue: [aRedefinitionNotification override install]		ifFalse: [self fixAndInstallNotification: aRedefinitionNotification using: overridden].	aRedefinitionNotification override cleanUpAfterLoad.	overrides add: aRedefinitionNotification override</body><body package="Atomic Compiling and Loading" selector="fixAndInstallNameSpaceNotification:">fixAndInstallNameSpaceNotification: aRedefinitionNotification		| overridden |	overridden := workingResult overrides 		detect: [:each | each isForNameSpace and:[each fullName = aRedefinitionNotification override absoluteName]]		ifNone: [nil].	overridden isNil		ifTrue: [aRedefinitionNotification override install]		ifFalse: [self fixAndInstallNotification: aRedefinitionNotification using: overridden].	aRedefinitionNotification override cleanUpAfterLoad.	overrides add: aRedefinitionNotification override</body><body package="Atomic Compiling and Loading" selector="fixAndInstallNotification:">fixAndInstallNotification: aRedefinitionNotification		aRedefinitionNotification override isForClass ifTrue: [^self fixAndInstallClassNotification: aRedefinitionNotification].	aRedefinitionNotification override isForNameSpace ifTrue: [^self fixAndInstallNameSpaceNotification: aRedefinitionNotification].	aRedefinitionNotification override install.	aRedefinitionNotification override cleanUpAfterLoad.	overrides add: aRedefinitionNotification override</body><body package="Atomic Compiling and Loading" selector="fixAndInstallNotification:using:">fixAndInstallNotification: aRedefinitionNotification using: aClassOrNameSpaceOverride		aClassOrNameSpaceOverride definitionMessage receiver: aRedefinitionNotification override definitionMessage receiver.	aRedefinitionNotification override install.</body><body package="Atomic Compiling and Loading" selector="installClass:">installClass: aShadowedClass	"The KISS approach: 		execute the new class definition to install or replace the existing one."		| realWorldHomeEnvironment realWorldClass knownOverrides target |	realWorldHomeEnvironment := self realFromShadow: aShadowedClass environment.	(aShadowedClass strictReference valueOrDo: [nil]) ifNotNil:		[:value |		knownOverrides := Override overridesForClassOrNameSpace: value.		knownOverrides ifNotNil: [target := knownOverrides detect: [:eachOverride | eachOverride sources includes: packageModel] ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: ((aShadowedClass definitionMessage) receiver: realWorldHomeEnvironment)]].	Policies packagePolicy		forcePackage: packageModel		while:			[realWorldClass := [(aShadowedClass definitionMessage)				receiver: realWorldHomeEnvironment;				value]					on: ClassConstructionError					do: [:exception | exception resume].			(aShadowedClass comment notNil and: [aShadowedClass comment notEmpty]) ifTrue:				[realWorldClass comment: aShadowedClass comment].			realWorldClass addToSuper].	classesToInitialize add: realWorldClass -&gt; aShadowedClass</body><body package="Atomic Compiling and Loading" selector="installMethod:">installMethod: aCompiledMethod	"If the new method is already in the REAL class, then throw a RedefinitionNotification	If this is a new method, just move it directly to the package we want. 	The system will think it's in the package of the class definition, since no other packages have information about it yet.	If the method is NOT new, then this is an override. We need to move it to the package we want in a way that modifies other change sets."	| shadowClass realClass category selector existingMethod knownOverride |	shadowClass := aCompiledMethod mclass.	realClass := self realFromShadow: shadowClass.	selector := aCompiledMethod selector.	category := shadowClass whichCategoryIncludesSelector: selector.	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: 		[ | override methodNodeHolder |		methodNodeHolder := Compiler new 			parse: aCompiledMethod getSource			in: realClass			notifying: nil.		methodNodeHolder notNil ifTrue:			[override := workingResult overridden 				detect: [:each | each isForMethod and: [each selector = methodNodeHolder selector and: [each absoluteClassName = realClass absoluteName]]] 				ifNone: [nil].			override ifNotNil: 				[selector := override selector.				category := override protocol]]].	(existingMethod := realClass compiledMethodAt: selector ifAbsent: nil) ifNotNil:		[knownOverride := Override 			overrideForSelector: selector 			class: realClass 			in: packageModel.		knownOverride ifNotNil: 			[knownOverride setOverriddenDefinition: (self fixMClass: aCompiledMethod to: realClass).			^knownOverride setOverriddenProtocol: category].		RedefinitionNotification			redefinedSelector: selector			class: realClass			attributes: existingMethod attributes].	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: [^self].	self fixMClass: aCompiledMethod to: realClass.	realClass needsSafeRebinding ifTrue:		[aCompiledMethod literalsDo: [:each | (each isVariableBinding and: [each isDeferred]) ifTrue: [each resolveBinding]]]. 	(realClass		justAddSelectorUnsafe: selector		withMethod: aCompiledMethod		category: category) ifTrue: 			[classesToNotify add: realClass].	existingMethod ifNotNil:		[| sourcePackage |		sourcePackage := Registry containingPackageForSelector: aCompiledMethod selector class: realClass.		sourcePackage doSubdefChange: (Change new remove selector: aCompiledMethod selector; class: realClass)].	packageModel doSubdefChange:		((Change new add)			selector: aCompiledMethod selector;			class: realClass).	(realClass isMeta and: [selector = #initialize and: [(classesToInitialize anySatisfy: [:each | each key = realClass instanceBehavior]) not]])		ifTrue: [classesToInitialize add: realClass instanceBehavior -&gt; shadowClass instanceBehavior].	aCompiledMethod sourcePointer:		(SourceFileManager default			storeMethodSources: aCompiledMethod methodSources			class: realClass			selector: selector			category: category			safely: false)</body><body package="Atomic Compiling and Loading" selector="installNameSpace:">installNameSpace: aNameSpace	"The KISS approach: 		execute the new namespace definition to install or replace the existing one."		| environment namespace knownOverrides target |	environment := self realFromShadow: aNameSpace environment.	(aNameSpace strictReference valueOrDo: [nil]) ifNotNil:		[:value |		knownOverrides := Override overridesForClassOrNameSpace: value.		knownOverrides ifNotNil: [target := knownOverrides detect: [:eachOverride | eachOverride sources includes: packageModel] ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: ((aNameSpace definitionMessage) receiver: environment)]].	Policies packagePolicy		forcePackage: packageModel		while:			[namespace := (aNameSpace shadowLoadDefinitionMessage)				receiver: environment;				value.			(aNameSpace comment notNil and: [aNameSpace comment notEmpty]) ifTrue:				[namespace comment: aNameSpace comment]]</body><body package="Atomic Compiling and Loading" selector="installSharedBinding:">installSharedBinding: aBindingReference	"At the end, we try to initialize the binding now... If we can't, we queue it up to try later"		| owningClassOrNamespace binding messageSend target knownOverrides |	owningClassOrNamespace := self realFromShadow: aBindingReference environment.	messageSend := aBindingReference environment asNameSpace definitionMessageOfStatic: aBindingReference binding.	(aBindingReference environment strictReference valueOrDo: [nil]) ifNotNil:		[:value |		knownOverrides := Override overridesForStatic: aBindingReference binding in: value.		knownOverrides ifNotNil: [target := knownOverrides detect: [:eachOverride | eachOverride sources includes: packageModel] ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: (messageSend receiver: owningClassOrNamespace)]].	Policies packagePolicy		forcePackage: packageModel		while:			[binding := 				messageSend receiver: owningClassOrNamespace;				value].	binding needsInitialization ifTrue: 		[[binding initialize] on: Error do: [:exception | exception return].		bindingsToInitialize add: binding]</body><body package="Atomic Compiling and Loading" selector="recompileNewExternalInterfacesFrom:">recompileNewExternalInterfacesFrom: aResult	| classes externalClasses orderedClasses recompileClasses |	classes := aResult shadowedObjects select: [:each | each isBehavior].	classes := classes collect: [:each | self realFromShadow: each].	externalClasses := classes select: [:each | each isMeta not and: [each includesBehavior: ExternalInterface]].	orderedClasses := SystemUtils sortForLoading: externalClasses.	orderedClasses do:		[:each |		each recompileMethods].	(recompileClasses := aResult externalClassesNeedingRecompile) ifNil: [^self].	recompileClasses := (recompileClasses select: [:each | each notNil]) collect: [:each | self realFromShadow: each].	(recompileClasses reject: [:each | (orderedClasses includes: each) or: [each isMeta]]) do:		[:each | each recompileMethods]</body><body package="Atomic Compiling and Loading" selector="recompileScannerClassesIn:">recompileScannerClassesIn: aPackageModel		| allClasses scannerClasses sortedClasses |	allClasses := aPackageModel allDefinedClasses.	scannerClasses := allClasses select: [:each | each includesBehavior: Scanner].	sortedClasses := SystemUtils sortForLoading: scannerClasses.	sortedClasses do:		[:each | 		aPackageModel recompileMethodsFor: each class.		aPackageModel recompileMethodsFor: each]</body></methods><methods><class-id>AtomicLoader</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading" selector="resetInitializerCollections">resetInitializerCollections	classesToInitialize := OrderedCollection new.	bindingsToInitialize := OrderedCollection new.	classesToNotify := IdentitySet new: 4.	overrides := OrderedCollection new.	doNotMarkClean := false.	overriddenClassesInPackage := OrderedCollection new.</body></methods><methods><class-id>AtomicLoader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="collectRedefinedClassInPackage:">collectRedefinedClassInPackage: aClassOverride	overriddenClassesInPackage add: aClassOverride</body><body package="Atomic Compiling and Loading" selector="compileBindingInitializersIn:">compileBindingInitializersIn: aPackageModel		| initialized |	initialized := (bindingsToInitialize collect: [:each | each environment]) asSet.	initialized := initialized copy reject: [:each | each isNameSpace].	initialized do: [:each | aPackageModel recompileSunshineMethodsFor: each].</body><body package="Atomic Compiling and Loading" selector="externalInterfaceClassesFrom:">externalInterfaceClassesFrom: aResult	| externalInterfaceClasses |	externalInterfaceClasses := aResult shadowedObjects select:		[:each |		each isBehavior and: [each inheritsFrom: ExternalInterface]].	externalInterfaceClasses := externalInterfaceClasses collect: [:each | self realFromShadow: each].	^externalInterfaceClasses reject: [:each | each isNil].</body><body package="Atomic Compiling and Loading" selector="externalInterfaceCompiledMethodsFrom:">externalInterfaceCompiledMethodsFrom: aResult		^aResult shadowedObjects select:		[:each | 		each isExternalMethod].</body><body package="Atomic Compiling and Loading" selector="fixMClass:to:">fixMClass: aMethod to: newClass	"Scans blocks to update references to the new (not in shadow) class."	| originalClass |	originalClass := aMethod mclass.	aMethod mclass: newClass.	aMethod withAllBlockMethodsDo:		[:method |		1 to: method basicSize do:			[:i |			originalClass  == (method basicAt: i) ifTrue:				[method basicAt: i put: newClass]]].	^aMethod</body><body package="Atomic Compiling and Loading" selector="handleExternalInterfacesWith:">handleExternalInterfacesWith: aResult		| externalInterfaceObjects sortedObjects |	externalInterfaceObjects := Set new.	externalInterfaceObjects addAll:		((self externalInterfaceCompiledMethodsFrom: aResult)			collect: [:each | each mclass]).	externalInterfaceObjects addAll: (self externalInterfaceClassesFrom: aResult).	externalInterfaceObjects isEmpty ifTrue: [^self].	sortedObjects := SystemUtils sortForLoading: externalInterfaceObjects.	sortedObjects do:		[:each | 		| failed |		failed := OrderedCollection new.		each selectors do:			[:eachSelector | 			[each recompile: eachSelector]				on: Error, UserNotification				do:					[:error | 					failed add: eachSelector.					error isResumable						ifTrue: [error resume]						ifFalse: [error return]]].		failed do: [:eachFailed | (each selectors includes: eachFailed) ifFalse: [each recompile: eachFailed]]]</body><body package="Atomic Compiling and Loading" selector="initializeBindings">initializeBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| workingBindings workingSize copyBindings |	bindingsToInitialize isEmpty ifTrue: [^self].	workingBindings := bindingsToInitialize copy.	copyBindings := workingBindings copy.	workingSize := -1.	[workingSize ~= workingBindings size and: [workingBindings notEmpty]] whileTrue:		[workingSize := workingBindings size.		workingBindings do:			[:each |			[each recompile.			each initialize.			each ifNotNil: [copyBindings remove: each]]				on: MessageNotUnderstood				do: [:exception | exception resume]].			workingBindings := copyBindings copy]</body><body package="Atomic Compiling and Loading" selector="initializeClassesIn:">initializeClassesIn: aPackageModel	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"	| sortedClasses workingSize workingClasses |	classesToInitialize isEmpty ifTrue: [^self].	sortedClasses := SystemUtils sortForLoading: (classesToInitialize collect: [:each | each key]).	workingClasses := sortedClasses copy.	workingSize := -1.	[workingSize ~= sortedClasses size and: [sortedClasses notEmpty]] whileTrue:		[workingSize := sortedClasses size.		sortedClasses do:			[:each | 			[each postLoad: aPackageModel.			workingClasses remove: each]				on: InitializerFailedError				do:					[:exception | 					exception return: nil]].			sortedClasses := workingClasses copy].	sortedClasses notEmpty ifTrue:		[doNotMarkClean := true.		sortedClasses do: 			[:each |			[each postLoad: aPackageModel]				on: InitializerFailedError				do: [:exception | exception resignalAs: MessageNotUnderstood new]]]</body><body package="Atomic Compiling and Loading" selector="initializeDefinitionsForPackage:">initializeDefinitionsForPackage: aPackageModel	"Initialize any datum and classes that require initialization.	The collection of bindings will only contain those that need to be initialized."		aPackageModel recompileExtensionsForSunshine.	self compileBindingInitializersIn: aPackageModel.	self initializeBindings.	classesToInitialize do: [:each | each key postCopyFromShadow: each value].	self initializeClassesIn: aPackageModel.	classesToNotify do: [:each | each instanceMethodsChanged]</body><body package="Atomic Compiling and Loading" selector="realFromShadow:">realFromShadow: aShadowedObject		"Looks up aShadowedObject in the real world and answers it, or nil if it doesn't exist. 		Works for NameSpaces and Classes."	| real obj |	obj := aShadowedObject isBehavior 		ifTrue: [ aShadowedObject instanceBehavior ]		ifFalse: [ aShadowedObject ].	real := obj absoluteName asStrictReference 			ifDefinedDo: [ :value |  value ]			elseDo: [ ^nil ].	^( aShadowedObject isBehavior and: [ aShadowedObject isMeta ] )		ifTrue: [ real class ]		ifFalse: [ real ].</body><body package="Atomic Compiling and Loading" selector="recompileLocalOverriddenClasses">recompileLocalOverriddenClasses	| allClassesWithSubclasses classesToRecompile |	allClassesWithSubclasses := Set new.	overriddenClassesInPackage isEmpty ifTrue: [^self].	classesToRecompile := overriddenClassesInPackage collect: [:each | each actual].	classesToRecompile do: [:each | allClassesWithSubclasses addAll: each withAllSubclasses].	(SystemUtils sortForAtomicLoading: allClassesWithSubclasses)		do: [:each | packageModel recompileMethodsFor: each].</body></methods><methods><class-id>AtomicLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="collectShadowedRedefinition:">collectShadowedRedefinition: aNotification	"We need to capture the overrides as the system notifies of them.  Unfortunately, the overrides	 are not in a state that is installable.  We will fix that later."	overrides add: aNotification override.	aNotification resume.</body><body package="Atomic Compiling and Loading" selector="installCompilationResult:">installCompilationResult: aResult	"Note that we use an explicit linkSystem rather than a modifySystem: call. 	We are very likely to have invalid bindings in the code we just installed, referring to shadow. 	We need those flushed before we run the initializers."	aResult package isComponentLoaded ifFalse: [aResult pundle runPreRead ifFalse: [^nil]].	aResult package runPreLoad ifFalse: [^nil].	packageModel := aResult package createImagePundle.	self resetInitializerCollections.	aResult packageDifferences ifNotNil: 		[:value |		value hasDifferences ifFalse: 			[aResult package postLoad: packageModel.			aResult markContentsInstalled: doNotMarkClean.			^packageModel]].	(Installing for: aResult package) started.	workingResult := aResult.	self installShadowObjects: aResult shadowedObjects.	aResult packageDifferences ifNotNil: [:value | packageModel removeDeletedDefinitions: value].	self recompileScannerClassesIn: packageModel.	packageModel recompileOverrideAffectedMethods.	SystemUtils linkSystem.	Store.Policies packagePolicy 		forcePackage: packageModel		while: 			[self handleExternalInterfacesWith: aResult.			self recompileNewExternalInterfacesFrom: aResult.			self recompileLocalOverriddenClasses.			self initializeDefinitionsForPackage: packageModel].	aResult package postLoad: packageModel.	aResult markContentsInstalled: doNotMarkClean.	packageModel cleanse: false.	(doNotMarkClean or: [aResult methodsMovedFromOriginalBinding notNil and: [aResult methodsMovedFromOriginalBinding notEmpty]]) ifTrue: 		[packageModel reconcileWithDbVersion: aResult component].	(Installing for: aResult package) finished.	^packageModel</body><body package="Atomic Compiling and Loading" selector="installShadowObjects:">installShadowObjects: aCollection	"Ignore unpackaged.	If there is a ClassConstructionError, there is a likelyhood that the problem is a push up of an instance variable.	If so, we check if this package's changes has the target class in it, and if so, then we say resume, 'cause that's the problem	If not, we do a pass, because the problem is other than this.	Note, we make sure when detecting that we only test the behavior objects, others will DNU if we send them to #realFromShadow:"		[[[aCollection do: 		[:each | 		each ifNotNil: [each redirectInstallTo: self]]] 			on: RedefinitionNotification			do: 				[:notification |				| package |				(package := notification currentPackage) ifNil: [notification resume].				(packageModel name = package name and: [notification override isForClass])					ifTrue: [self collectRedefinedClassInPackage: notification override].				(packageModel name = package name or: [package name = Registry nullPackageName]) ifFalse: [self fixAndInstallNotification: notification].				notification resume]]					on: VariableConfirmation					do: [:notification | notification resume: false]]						on: ClassConstructionError						do: 						[:exception |						| failedClass |						failedClass := exception originator targetClass.						(aCollection detect: [:each | each isBehavior and: [(self realFromShadow: each) = failedClass]] ifNone: [nil]) isNil							ifTrue: [exception pass]							ifFalse: [exception resume]].	overrides do: [:each | each cleanUpAfterLoad].</body></methods><methods><class-id>AtomicLoader class</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="loadFailOption">loadFailOption	^LoadFailedOption value</body></methods><methods><class-id>Store.Glorp.StoreBundleSubBundleRelationship</class-id> <category>accessing</category><body package="Store-Database Model" selector="bundleID">bundleID		^bundleID</body><body package="Store-Database Model" selector="bundleID:">bundleID: anObject		bundleID := anObject</body><body package="Store-Database Model" selector="expressionID">expressionID		^expressionID</body><body package="Store-Database Model" selector="expressionID:">expressionID: anObject		expressionID := anObject</body><body package="Store-Database Model" selector="sequence">sequence		^sequence</body><body package="Store-Database Model" selector="sequence:">sequence: anObject		sequence := anObject</body><body package="Store-Database Model" selector="subbundleID">subbundleID		^subbundleID</body><body package="Store-Database Model" selector="subbundleID:">subbundleID: anObject		subbundleID := anObject</body></methods><methods><class-id>Store.Modification</class-id> <category>testing</category><body package="Store-Change Management" selector="belongsToClass">belongsToClass	^tag belongsToClass</body><body package="Store-Change Management" selector="isForNameSpace">isForNameSpace	^tag isForNameSpace</body><body package="Store-Change Management" selector="isForOverriddenMethod">isForOverriddenMethod		| theMethodDescriptor |	^record notNil 		and: [record isForMethod		and: [(theMethodDescriptor := self record asDescriptor) existsInImage		and: [Override isOverriddenSelector: theMethodDescriptor selector class: theMethodDescriptor classFromClassName in: self package]]]</body><body package="Store-Change Management" selector="isMeaningful">isMeaningful	"This was modeled after #apply"	| imPkg |	(tag existsInImage not and: [record isNil]) ifTrue: 		[^false].	(tag existsInImage and: [record isNil &amp; package isNil]) ifTrue: 		[^true	"must be a removal"].	imPkg := package getImagePundle.	imPkg isNil ifTrue: 		["Create a package."		self error: (#Package1sMissingFromImage &lt;&lt; #store&gt;&gt; 'Package named "&lt;1s&gt;" missing from image - should not occur' expandMacrosWith: package name).		imPkg := PackageModel named: package name.		imPkg dbTrace: package primaryKey].	^tag is: record meaningfulChangeOf: imPkg</body><body package="Store-Change Management" selector="isPublishedModification">isPublishedModification		^true</body><body package="Store-Change Management" selector="isRemoval">isRemoval	^tag existsInImage and: [record isNil]</body><body package="Store-Change Management" selector="notOriginallyInImage">notOriginallyInImage	^originallyInImage not</body></methods><methods><class-id>Store.Modification</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aMod 	^self == aMod or:	[( aMod notNil and: [ record notNil ] ) and: 		[ aMod isPublishedModification and: 			[ aMod isMoveModification not and: [ aMod record = self record ] ]		]]</body></methods><methods><class-id>Store.Modification</class-id> <category>accessing</category><body package="Store-Change Management" selector="description">description	self package isNil ifTrue: [^''].	^((#x1s2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt;')		expandMacrosWith: self packageName		with: self package versionStringAlternate)</body><body package="Store-Change Management" selector="existsInPackage">existsInPackage	^record notNil</body><body package="Store-Change Management" selector="key">key	^package isNil		ifTrue: [nil]		ifFalse: [package primaryKey]</body><body package="Store-Change Management" selector="originallyInImage">originallyInImage	^originallyInImage</body><body package="Store-Change Management" selector="record">record	^record</body><body package="Store-Change Management" selector="record:">record: aRecord	record := aRecord</body><body package="Store-Change Management" selector="source">source	"Answer the source code or nil if not there."	^record isNil		ifTrue: [nil]		ifFalse: [record textRepresentationForTag: tag ]</body><body package="Store-Change Management" selector="timeStampString">timeStampString	^self package timeStampString</body></methods><methods><class-id>Store.Modification</class-id> <category>actions</category><body package="Store-Change Management" selector="apply">apply	"Apply a modification to the image. 	Answer true if the application is successful."	| imPkg result |	(tag existsInImage not and: [record isNil]) ifTrue: [^true].	(tag existsInImage and: [record isNil &amp; package isNil]) 		ifTrue: 			[tag removeFromSystem.			^true	"must be a removal"].	imPkg := package getImagePundle.	imPkg isNil 		ifTrue: 			["Create a package."			self error: ((#Package1sMissing &lt;&lt; #store &gt;&gt; 'Package &lt;1s&gt; missing from image - should not occur') 						expandMacrosWith: package name).			imPkg := PackageModel named: package name.			imPkg dbTrace: package primaryKey].	result := tag loadIntoPackage: imPkg from: record.	^result</body><body package="Store-Change Management" selector="determineOriginallyInImage">determineOriginallyInImage	originallyInImage := self isMeaningful not</body></methods><methods><class-id>Store.Modification</class-id> <category>change list support</category><body package="Store-Change Management" selector="category">category	^record isForMethod		ifTrue: [ record protocolName ]</body><body package="Store-Change Management" selector="name">name	"Answer a name for the list."	^tag name</body><body package="Store-Change Management" selector="sameAs:">sameAs: aModification 	"No record, so this is the system."	^self packageName = aModification packageName and:		[record isNil			ifTrue: [aModification record isNil and: [tag = aModification tag]]			ifFalse: [aModification record notNil and: [self source = aModification source]]]</body><body package="Store-Change Management" selector="sameAsSystem">sameAsSystem	^record isNil		ifTrue: [tag existsInImage not]		ifFalse: [record sameAsImage]</body><body package="Store-Change Management" selector="systemCategory">systemCategory	"Return the category of the corresponding change in the system, if any"	^record isForMethod		ifTrue: [ record systemCategory ]</body></methods><methods><class-id>Store.Modification class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="tag:package:record:">tag: aTag package: aPackage record: aRecord	|baby|	baby := self new.	baby tag: aTag; package: aPackage; record: aRecord.	^baby</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>comparing</category><body package="Store-User Management" selector="&lt;">&lt; aBlessing	^level &lt; aBlessing level</body><body package="Store-User Management" selector="&lt;=">&lt;= aBlessing	^level &lt;= aBlessing level</body><body package="Store-User Management" selector="=">= aBlessing	^self class = aBlessing class		and: [self level = aBlessing level]</body><body package="Store-User Management" selector="hash">hash	^level hash</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>types</category><body package="Store-User Management" selector="beAdminOnly">beAdminOnly	type := #admin</body><body package="Store-User Management" selector="beNormal">beNormal	"Remove any type restrictions."	type := nil</body><body package="Store-User Management" selector="beOwnerOnly">beOwnerOnly	type := #owner</body><body package="Store-User Management" selector="beQaOnly">beQaOnly	type := #qa</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>testing</category><body package="Store-User Management" selector="isAdminOnly">isAdminOnly	^type == #admin</body><body package="Store-User Management" selector="isOwnerOnly">isOwnerOnly	^type == #owner</body><body package="Store-User Management" selector="isQaOnly">isQaOnly	^type == #qa</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>printing</category><body package="Store-User Management" selector="printOn:">printOn: aStream	aStream nextPutAll: name.	type == nil		ifFalse: [ aStream nextPut: $-; nextPutAll: type ].	aStream 		nextPut: $(;		nextPutAll: level printString;		nextPut: $).</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>accessing</category><body package="Store-User Management" selector="level">level	^level</body><body package="Store-User Management" selector="level:">level: anInteger	level := anInteger</body><body package="Store-User Management" selector="name">name	^name</body><body package="Store-User Management" selector="name:">name: aString	name := aString</body></methods><methods><class-id>Store.BlessingLevel class</class-id> <category>instance creation</category><body package="Store-User Management" selector="name:level:">name: aString level: anInteger	^self new		name: aString;		level: anInteger;		yourself.</body></methods><methods><class-id>Store.FileRecord</class-id> <category>downloading</category><body package="Store-DB-Pundles" selector="download">download	"Download the file. Answer whether we did so successfully"	| filename stream blob |	( blob := self fileData ) == nil		ifTrue: [ 				Dialog warn: (#IsEmpty &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is empty' expandMacrosWith: self filename). 				^false				].	filename := self filename asFilename.	( filename := self validateFilenameForDownload: filename ) == nil		ifTrue: [ ^false ].	stream := filename writeStream binary.	[ stream nextPutAll: blob rawData ] 			ensure: [ stream close ].	^true.</body><body package="Store-DB-Pundles" selector="downloadTo:">downloadTo: aFilename		| blob bytes stream validFIlename |	((blob := self fileData) isNil or: [(bytes := blob rawData) isNil])		ifTrue:			[Dialog warn: (#IsEmpty &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is empty' expandMacrosWith: self filename).			^false].	(validFIlename := self validateFilenameForDownload: aFilename) ifNil: [^false].	stream := validFIlename writeStream binary.	[stream nextPutAll: bytes] ensure: [stream close].	^true</body><body package="Store-DB-Pundles" selector="validateFilenameForDownload:">validateFilenameForDownload: aFilename 	"Validate that a file can be written. Answer the filename to be used."	| filename |	filename := aFilename.	[filename canBeWritten] whileFalse: 			[filename := (Dialog 							request: #PleaseEnterAValidFAmeForThisPlatform &lt;&lt; #store &gt;&gt; 'Please enter a valid filename for this platform'							initialAnswer: filename asString							onCancel: [^nil]) asFilename].	^filename</body></methods><methods><class-id>Store.FileRecord</class-id> <category>support</category><body package="Store-DB-Pundles" selector="processFields">processFields	super processFields.	self revertBinaryData</body><body package="Store-DB-Pundles" selector="textForItem">textForItem	^name</body></methods><methods><class-id>Store.FileRecord</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDescriptor">asDescriptor	^( self descriptionClass from: self filename asString )		dbTrace: primaryKey;		name: self filename;		yourself</body><body package="Store-DB-Pundles" selector="components">components	^components</body><body package="Store-DB-Pundles" selector="components:">components: collection	components := collection</body><body package="Store-DB-Pundles" selector="descriptionClass">descriptionClass	^FileModel</body><body package="Store-DB-Pundles" selector="fileData">fileData	"Allow for lazy evaluation."	fileData == nil		ifTrue: [ fileData := self class definitionClass aRecordWithID: fileID ].	^fileData</body><body package="Store-DB-Pundles" selector="fileData:">fileData: byteArray	^fileData := byteArray</body><body package="Store-DB-Pundles" selector="fileID">fileID	^fileID</body><body package="Store-DB-Pundles" selector="fileID:">fileID: anInteger	fileID := anInteger</body><body package="Store-DB-Pundles" selector="filename">filename	^components == nil		ifTrue: [ nil ]		ifFalse: [ LogicalFilename fromComponents: components ].</body><body package="Store-DB-Pundles" selector="fileSize">fileSize	^fileSize</body><body package="Store-DB-Pundles" selector="fileSize:">fileSize: anInteger	fileSize := anInteger</body><body package="Store-DB-Pundles" selector="name:">name: aString	name := aString asString.	self timeStamp: self class timeStamp.</body></methods><methods><class-id>Store.FileRecord</class-id> <category>private</category><body package="Store-DB-Pundles" selector="convertBinaryData">convertBinaryData	"Before storing the record into the database, we first have to convert the components of the 	 filename into BOSS data."		components := self encode: components.</body><body package="Store-DB-Pundles" selector="prepareInstallation">prepareInstallation	"Create records for the file data."	| filename |	( filename := self filename ) == nil		ifTrue: [ ^self ].	self fileID isNil		ifTrue: 			[ 			fileSize := filename fileSize.			fileData := filename asFilename contentsOfEntireBinaryFile.			self fileID: ( self class definitionClass fromRawData: self fileData ) primaryKey 			].</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	fileData := Object new.</body><body package="Store-DB-Pundles" selector="revertBinaryData">revertBinaryData	"Once the record has been stored into the database, revert the components back from the BOSS object."	components := self decode: components.</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	fileData := nil.</body></methods><methods><class-id>Store.FileRecord</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="installInDatabase">installInDatabase	"Create a corresponding record in the database."	self preDatabaseInstall.		[self convertBinaryData.	self broker process: self installSqlString bindInput: self] 			ensure: [self revertBinaryData].	self postDatabaseInstall</body></methods><methods><class-id>Store.FileRecord class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="componentMark">componentMark	^'F'</body><body package="Store-DB-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	"Answer a signal for a component not found error."	"Place holder in case we decide to do file specific stuff later."	^Pundle componentNotFoundSignal</body><body package="Store-DB-Pundles" selector="definitionClass">definitionClass	^BinaryBlob</body><body package="Store-DB-Pundles" selector="partClass">partClass	^Files</body></methods><methods><class-id>Store.FileRecord class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames	"self columnNames"	^super columnNames		remove: 'fileData';		yourself</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	"self fieldTypes "	| dict |	dict := super fieldTypes		at: 'fileID' put: #Integer;		at: 'fileSize' put: #Integer;		at: 'components' put: #BinData;		yourself.	self checkFieldsWith: dict.	^dict.</body><body package="Store-DB-Pundles" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.FileRecord class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="fromPortableFilename:">fromPortableFilename: aPortableFilename	^self new		components: aPortableFilename componentStrings;		name: (aPortableFilename asString);		yourself</body><body package="Store-DB-Pundles" selector="newFrom:">newFrom: aFileModel	"Given a fileModel create a new instance of the receiver.		This is a private method used by all public methods that store files in the database."	| newDBFile |	DBObject resetServerTimestamp.	newDBFile := self fromPortableFilename: aFileModel portableFilename.	^newDBFile</body><body package="Store-DB-Pundles" selector="newFrom:userData:">newFrom: aFileModel userData: userData 	"Create a new instance of a FileRecord and install it in DB. Sources are save in DB"	| newDBFile result transaction |	newDBFile := self newFrom: aFileModel.	transaction := 		[newDBFile install.		newDBFile].	MessageNotification raiseSignal: (#file1s &lt;&lt; #store &gt;&gt; 'file &lt;1s&gt;' expandMacrosWith: aFileModel name).	ResetIncrementNotification signalWith: 1.	result := self broker publishTransaction: transaction.	result ifNotNil: [aFileModel dbTrace: newDBFile primaryKey].	^result</body></methods><methods><class-id>Store.FileRecord class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_FileName' #('name'))		#('ST_FileTimestamp' #('timeStamp'))		#('ST_FileGCSupport' #('trace'))		)</body></methods><methods><class-id>Store.Glorp.GeneralResolution</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^false</body><body package="Store-Merge Management" selector="isAbsentResolution">isAbsentResolution	^false</body><body package="Store-Merge Management" selector="isDoNothingResolution">isDoNothingResolution	^false</body><body package="Store-Merge Management" selector="isNoOpResolution">isNoOpResolution	^false</body><body package="Store-Merge Management" selector="isRemovalResolution">isRemovalResolution	^false</body><body package="Store-Merge Management" selector="isStandardResolution">isStandardResolution	^false</body><body package="Store-Merge Management" selector="isUserInputResolution">isUserInputResolution	^false</body></methods><methods><class-id>Store.Glorp.GeneralResolution</class-id> <category>accessing</category><body package="Store-Merge Management" selector="key">key	^package</body><body package="Store-Merge Management" selector="package">package	^package</body><body package="Store-Merge Management" selector="package:">package: anObject	package := anObject</body><body package="Store-Merge Management" selector="value">value	self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.GeneralResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="forPackage:">forPackage: aPundle	| instance |	instance := self new.	instance package: aPundle.	^instance</body><body package="Store-Merge Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Tools.BindingTextualDetailComparisonView</class-id> <category>row population</category><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	^Array with: (SideBySideTextComparisonView new leftText: leftText				rightText: rightText)</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| header |	super populateHeader.	header := self header.	header add: icon.	header add: (self italicizedText: name)</body></methods><methods><class-id>Tools.BindingTextualDetailComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="icon:name:leftText:rightText:">icon: aGraphic name: aStringThing leftText: aLeftText rightText: aRightText	icon := aGraphic.	name := aStringThing.	leftText := aLeftText.	rightText := aRightText.	self populate</body></methods><methods><class-id>Tools.BindingTextualDetailComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^Array with: #compareBindingDetail with: name</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>private-database installation</category><body package="Store-Ownership" selector="updateUserInDatabase:">updateUserInDatabase: newUser	self broker process: 		'UPDATE ownerName, ownerType		WHERE pundleName = :pundleName 			AND pundleType = :pundleType			AND  privilige = ''owner'''		bindInput: self</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>accessing</category><body package="Store-Ownership" selector="functionalKey">functionalKey	^Array with: self pundleName with: self pundleType with: self userName</body><body package="Store-Ownership" selector="privilege">privilege	"Answer the receiver's privilege."	^privilege</body><body package="Store-Ownership" selector="privilege:">privilege: newPrivilege	"Set the receiver's privilege to newPrivilege."	privilege := newPrivilege</body><body package="Store-Ownership" selector="pundle">pundle	^(self isBundle ifTrue: [Bundle] ifFalse: [Package]) newNamed: self pundleName</body><body package="Store-Ownership" selector="pundle:">pundle: aPundle	self pundleName: aPundle name.	self pundleType: (self typeOfPundle: aPundle)</body><body package="Store-Ownership" selector="pundleName">pundleName	"Answer the receiver's pundleName."	^pundleName</body><body package="Store-Ownership" selector="pundleName:">pundleName: newPundleName	"Set the receiver's pundleName to newPundleName."	pundleName := newPundleName</body><body package="Store-Ownership" selector="pundleType">pundleType	"Answer the receiver's pundleType."	^pundleType</body><body package="Store-Ownership" selector="pundleType:">pundleType: newPundleType	"Set the receiver's pundleType to newPundleType."	pundleType := newPundleType</body><body package="Store-Ownership" selector="user:">user: aDBUserGroup	self userName: aDBUserGroup userName.	self userType: aDBUserGroup type.</body><body package="Store-Ownership" selector="userName">userName	"Answer the receiver's userName."	^userName</body><body package="Store-Ownership" selector="userName:">userName: newUserName	"Set the receiver's userName to newUserName."	userName := newUserName</body><body package="Store-Ownership" selector="userType">userType	"Answer the receiver's userType."	^userType</body><body package="Store-Ownership" selector="userType:">userType: newUserType	"Set the receiver's userType to newUserType."	userType := newUserType</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>types</category><body package="Store-Ownership" selector="isBundle">isBundle	^pundleType = 'B'</body><body package="Store-Ownership" selector="isGroup">isGroup	^pundleType = self class pundleOwnerClass groupType</body><body package="Store-Ownership" selector="isPackage">isPackage	^self isBundle not</body><body package="Store-Ownership" selector="isUser">isUser	^self isGroup not</body><body package="Store-Ownership" selector="typeOfPundle:">typeOfPundle: aPundle 	^self class typeOfPundle: aPundle</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>printing</category><body package="Store-Ownership" selector="fullDescription">fullDescription	| stream |	stream := ( String new: 30 ) writeStream.	stream nextPutAll: userName.	( self isGroup )		ifTrue: [ stream nextPutAll: '(G)' ].	stream nextPutAll:		( privilege = 'owner'			ifTrue: [ ' owns ' ]			ifFalse: 				[ privilege = 'read'					ifTrue: [ ' can read ' ]					ifFalse: 						[ privilege = 'publish'							ifTrue: [ ' can publlish ' ]							ifFalse: [  ' *', privilege, '* ' ]						]				]		), pundleName.	self isBundle		ifTrue: [ stream nextPutAll: '(B)' ].	^stream contents.</body><body package="Store-Ownership" selector="itemString">itemString	^privilege == #owner 		ifTrue: 			[(#_1pIsOwnedBy2s &lt;&lt; #store &gt;&gt; '&lt;1p&gt; is owned by &lt;2s&gt;') expandMacrosWith: pundleName				with: userName asString]		ifFalse: 			['&lt;1p&gt; &lt;2p&gt; &lt;3s&gt;' 				expandMacrosWith: pundleName				with: privilege				with: userName asString]</body><body package="Store-Ownership" selector="printOn:">printOn: aStream	"*** created 9 January 1995 at 5:58:17 pm by PHM (Philippe F. Monnet	) in B941220 ***"	self itemString printOn: aStream</body><body package="Store-Ownership" selector="storeOn:">storeOn: aStream	"|ws|	ws := 'xxx' asFilename writeStream. DBPundlePrivileges allRecords 	do: [:r| r storeOn: ws]. ws close"	aStream nextPutAll: pundleName; tab.	aStream nextPutAll: pundleType; tab.	aStream nextPutAll: userName; tab.	aStream nextPutAll: userType asString; tab.	aStream nextPutAll: privilege asString; cr</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>relationships</category><body package="Store-Ownership" selector="relatedBy:">relatedBy: relToken	"Anwer set of relations. Main relationship is owner-&gt;pundle."	| index |	( index := #( #ownerRel #readRel #publishRel ) indexOf: relToken ) &gt; 0		ifTrue:			[ ^self class pundlesUser: userName privilege: 					( #( #owner #read #publish ) at: index )			].	( index := #( #ownerRRel #readRRel #publishRRel ) indexOf: relToken ) &gt; 0		ifTrue:			[ ^self class 				usersWithPrivilege: ( #( #owner #read #publish ) at: index )				pundleName: pundleName 				pundleType: pundleType			].	^super relatedBy: relToken</body><body package="Store-Ownership" selector="stringKey:">stringKey: hints	^( hints includes: #sort ) 		ifTrue: [ userName, ' ', privilege ]		ifFalse: [ userName ]</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	"|ws bb| 	ws := 'xxx' asFilename readStream. bb := DBPundlePrivileges readFrom: ws. ws close. bb"	pundleName := aStream upTo: Character tab.	aStream skipSeparators.	pundleType := aStream upTo: Character tab.	aStream skipSeparators.	userName := aStream upTo: Character tab.	aStream skipSeparators.	userType := aStream upTo: Character tab.	aStream skipSeparators.	privilege := (aStream upTo: Character cr) asSymbol.</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>comparing</category><body package="Store-Ownership" selector="&lt;=">&lt;= aPrivilege	self class == aPrivilege class		ifFalse: [ ^false ].	self userName = aPrivilege userName		ifFalse: [ ^self userName &lt;= aPrivilege userName ].	self privilege = aPrivilege privilege		ifFalse: [ ^self privilege &lt;= aPrivilege privilege ].	^self pundleName &lt;= pundleName.</body><body package="Store-Ownership" selector="=">= aPrivilege	self class == aPrivilege class		ifFalse: [ ^false ].	^( self userName = aPrivilege userName )	  &amp;		( self privilege = aPrivilege privilege )	&amp;		( self pundleName = aPrivilege pundleName )  &amp;		( self pundleType = aPrivilege pundleType ) 	 &amp;		( self userType = aPrivilege userType )</body><body package="Store-Ownership" selector="hash">hash	^self userName hash</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>instance creation</category><body package="Store-Ownership" selector="forPundle:">forPundle: aPundle	^self new pundle: aPundle</body><body package="Store-Ownership" selector="forPundle:user:">forPundle: aPundle user: aDBUser	^self new 		pundle: aPundle;  		user: aDBUser;		yourself.</body><body package="Store-Ownership" selector="forPundle:user:privilege:">forPundle: aPundle user: aDBUser privilege: privilege	^self new 		pundle: aPundle;  		user: aDBUser;  		privilege: privilege;		yourself.</body><body package="Store-Ownership" selector="forPundleName:type:">forPundleName: aPundleName type: aPundleType	^self new 		pundleName: aPundleName;		pundleType: aPundleType</body><body package="Store-Ownership" selector="forUser:">forUser: aUser	^self new user: aUser.</body><body package="Store-Ownership" selector="grant:to:for:">grant: aPrivilege to: aDBUser for: aPundle	"Set the access privilege to aDBUser for  a Pundle."		| priv |	aPrivilege == #owner		ifTrue: [ ^self updateOwnershipFor: aPundle to: aDBUser ].	priv := self forPundle: aPundle user: aDBUser privilege: aPrivilege.	[ priv installInDatabase ] on: self broker indexConflictSignal do:		[ :e | Dialog warn: 'User may only have one privilege per pundle.' ].</body><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	| baby |	baby := self new.	baby readFrom: aStream.	^baby</body><body package="Store-Ownership" selector="revoke:to:for:">revoke: privilege to: aDBUser for: aPundle	"Deny the access privilege to aDBUser for  a Pundle."		( self forPundle: aPundle user: aDBUser privilege: privilege )		removeFromDatabase.</body><body package="Store-Ownership" selector="revokeAllFor:for:">revokeAllFor: aDBUser for: aPundle	"Deny the access privilege to aDBUser for  a Pundle."		| temp |	temp := self forPundle: aPundle user: aDBUser.	self rights do:		[ :priv | temp privilege: priv.		temp removeFromDatabase.		].</body><body package="Store-Ownership" selector="setOwnershipFor:to:">setOwnershipFor: aPundle to: anOwnerName	self updateOwnershipFor: aPundle to: anOwnerName</body><body package="Store-Ownership" selector="updateOwnershipFor:to:">updateOwnershipFor: aPundle to: aUser	| new old in |	new := self forPundle: aPundle user: aUser privilege: #owner.	( old := self ownerOfPundle: aPundle ) == nil		ifTrue: [ [ new installInDatabase ] on: self broker indexConflictSignal do:					[ :e | Dialog warn: 'User may only have one privilege per pundle.' ]			   ]		ifFalse: 			[ in := self forPundle: aPundle user: old  privilege: #owner.			self broker process: 				( self newSQL					setColumns: #( #userName #userType ) equalTo: 						( Array with: aUser userName printString with: aUser userType  printString );					whereSqlString 				  )				bindInput: in.			].</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>accessing</category><body package="Store-Ownership" selector="pundleOwnerClass">pundleOwnerClass	^DBUserGroup</body><body package="Store-Ownership" selector="rights">rights	^# ( #owner #read #publish )</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>private-pundle types</category><body package="Store-Ownership" selector="bundleType">bundleType	^'B'</body><body package="Store-Ownership" selector="packageType">packageType	^'P'</body><body package="Store-Ownership" selector="typeOfPundle:">typeOfPundle: aPundle	"Moved to class side by Philippe F. Monnet of Andersen Consulting"		^aPundle isBundle		ifTrue: [ self bundleType ]		ifFalse: [ self packageType ]</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>public-query</category><body package="Store-Ownership" selector="allPrivileges">allPrivileges	^self allRecords</body><body package="Store-Ownership" selector="allPrivilegesFor:">allPrivilegesFor: aUser 	"Answer a set of privileges for aUser."	"self allPrivilegesFor: ( DBUserGroup userNamed:'bern' )	"	| inp |	inp := self forUser: aUser.	^[self processList:			(self broker process: 				( self newSQL					selectAll;					where;					column: #userName equalTo: ':userName';					and;					column: #userType equalTo: ':userType')			bindInput: inp 			bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body><body package="Store-Ownership" selector="allPrivilegesForPundle:">allPrivilegesForPundle: aPundle	"Answer a set of privileges for aPundle."	"self allPrivilegesForPundle: ( Registry packageNamed: 'Store' )	"	| inp |	inp := self forPundle: aPundle.	^[self processList: 		(self broker process: 				( self newSQL					selectAll;					where;					column: #pundleName equalTo: ':pundleName';					and;					column: #pundleType equalTo: ':pundleType')			bindInput: inp 			bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body><body package="Store-Ownership" selector="allUsersFor:">allUsersFor: aPundle	"Answer a set of user names that have any privileges for aPundle"	| inp |	inp := self forPundle: aPundle.	[self processList:		( self broker process: 				(self newSQL					selectAll;					where;					column: #pundleName equalTo: ':pundleName'					and;					column: #pundleType equalTo: ':pundleType')			bindInput: inp 			bindOutput: self newPrimed)	]	on: self  errorSignals 	do: 	[:ex | ex outer. OrderedCollection new ].</body><body package="Store-Ownership" selector="ownerOfPundle:">ownerOfPundle: pundle 	| list |	pundle == nil ifTrue: [^nil].	list := self 				usersWithPrivilege: #owner				pundleName: pundle name				pundleType: (self typeOfPundle: pundle).	list size == 0 ifTrue: [^nil].	list size &gt; 1 		ifTrue: 			[Dialog 				warn: ((#_1sHasMoreThanOneOwner &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has more than one owner.') expandMacrosWith: pundle name)].	^list asOrderedCollection first</body><body package="Store-Ownership" selector="privilegeForUser:pundle:">privilegeForUser: aUser pundle: aPundle	"Answer the privilige the user has for aPundle."	| inp coll |	inp := self forPundle: aPundle user: aUser.	coll := self broker process: 				( self newSQL					selectAll;					where;					column: #pundleName equalTo: ':pundleName';					and;					column: #pundleType equalTo: ':pundleType';					and;					column: #userName equalTo: ':userName';					and;					column: #userType equalTo: ':userType')			bindInput: inp.	coll isEmpty ifTrue: [ ^nil].	^coll first first</body><body package="Store-Ownership" selector="pundlesGroupName:privilege:">pundlesGroupName: aUserName privilege: aSymbol	"Answer a collection of pundles for which a group has given privilege."	^self pundlesUserName: aUserName userType: self pundleOwnerClass groupType privilege: aSymbol.</body><body package="Store-Ownership" selector="pundlesOwnedBy:">pundlesOwnedBy: aDBUser	"Answer a collection of priviliges for which a user is the owner."	^self pundlesUser: aDBUser privilege: #owner</body><body package="Store-Ownership" selector="pundlesUser:privilege:">pundlesUser: aUser privilege: aSymbol	"Answer a collection of pundles for which a user has given privilege."	^self pundlesUserName: aUser userName userType: aUser type privilege: aSymbol.</body><body package="Store-Ownership" selector="pundlesUserName:userType:privilege:">pundlesUserName: aUserName userType: typeString privilege: aSymbol	"Answer a collection of priviliges for which a user has given privilege."	| inp |	inp := self new.	inp userName: aUserName; 		userType: typeString;		privilege: aSymbol.	^[self processList:			(self broker process:				( self newSQL					selectAll;					where;					column: #privilege equalTo: ':privilege';					and;					column: #userName equalTo: ':userName';					and;					column: #userType equalTo: ':userType')		bindInput: inp		bindOutput: self newPrimed)	]	on: self  errorSignals 	do: 	[:ex |  ex outer. OrderedCollection new ].</body><body package="Store-Ownership" selector="user:hasPrivilege:to:">user: aUser hasPrivilege: privilege to: aPundle	"Check aUser and all groups the user belongs to for a privilege"	| groups users |	^[	users := self usersWithPrivilege: privilege pundle: aPundle.		( users includes: aUser ) ifTrue: [ ^true ].		groups := self pundleOwnerClass groupsForUser: aUser.		groups do:			[ :grp | ( users includes: grp ) ifTrue: [ ^true] ].		false.	] 	on: self errorSignals	do: [ :ex | false].</body><body package="Store-Ownership" selector="usersWithPrivilege:pundle:">usersWithPrivilege: aSymbol pundle: aPundle	"Answer a set of user names that have a given privilege for aPundle"	"self controlPundle: "	^self usersWithPrivilege: aSymbol 		 pundleName: aPundle name 		 pundleType: ( self typeOfPundle: aPundle )</body><body package="Store-Ownership" selector="usersWithPrivilege:pundleName:pundleType:">usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aType	"Answer a set of user names that have a given privilege for aPundle"	"self usersWithPrivilege: #owner pundleName: 'Store-Base' pundleType: self packageType "	| inp coll |	inp := self forPundleName: aPundleName type: aType.	inp privilege: aSymbol.	[ coll := self broker process: 				( self newSQL					select: #( #userName #userType );					where;					column: #pundleName equalTo: ':pundleName';					and;					column: #pundleType equalTo: ':pundleType';					and;					column: #privilege equalTo: ':privilege')			bindInput: inp	] on: self errorSignals do: [ :ex | ex outer. ^nil].	^( coll collect: 			[ :each |  self pundleOwnerClass userName: each first type: each last 		] )</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>installation</category><body package="Store-Ownership" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'pundleName' 	put: #PrimaryKeyString.	aDict at: 'pundleType' 	put: #PrimaryKeyChar.	aDict at: 'userName' 	put: #PrimaryKeyString.	aDict at: 'userType' 		put: #PrimaryKeyChar.	aDict at: 'privilege'		put: #String32. 	self checkFieldsWith: aDict.	^aDict</body><body package="Store-Ownership" selector="grantDatabasePrivilegesTo:">grantDatabasePrivilegesTo: userName	"This table is controlled by the system admin."	"self grantDatabasePrivilegesTo: 'eliot' "	self broker grantForClass: self  		permissions: #( #INSERT #UPDATE #DELETE) 		toUsers: (Array with:  userName)</body><body package="Store-Ownership" selector="indexParameters">indexParameters	^nil</body><body package="Store-Ownership" selector="revokeDatabasePrivilegesFrom:">revokeDatabasePrivilegesFrom: userName	"This table is controlled by the system admin."	"self revokeDatabasePrivilegesTo: 'eliot' "	self broker revokeForClass: self 			permissions: #( #INSERT  #UPDATE #DELETE) 			fromUsers: (Array with: userName)</body><body package="Store-Ownership" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"This table is controlled by the system admin."	self broker grantForClass: self permissions: #(#SELECT) toUsers: #( #PUBLIC)</body><body package="Store-Ownership" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy userAndOwnershipTableSpace</body></methods><methods><class-id>Store.Glorp.StoreLogin</class-id> <category>accessing</category><body package="Store-Database Model" selector="driverClassName">driverClassName		^driverClassName</body><body package="Store-Database Model" selector="driverClassName:">driverClassName: anObject		driverClassName := anObject</body><body package="Store-Database Model" selector="schema">schema	"SQLite3 and PGSql (and maybe others) don't use schemas. Filtering it at the getter for now."	^self platform supportsSchemaForLogin ifTrue: [schema] ifFalse: ['']</body></methods><methods><class-id>Store.Glorp.StoreLogin</class-id> <category>printing</category><body package="Store-Database Model" selector="printOn:">printOn: aStream	aStream nextPutAll: 'a Login('.	database printOn: aStream.	aStream nextPutAll: ', '.	driverClassName printOn: aStream.	aStream nextPutAll: ', '.	username printOn: aStream.	aStream nextPutAll: ', '.	connectString printOn: aStream.	aStream nextPutAll: ', '.	schema printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="existsVersionString:forPundle:">existsVersionString: aString forPundle: aPundleModel		^aPundleModel storeForGlorpPundleClass pundleWithName: aPundleModel name hasVersion: aString</body><body package="Store-User Management" selector="increment:">increment: aString 	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"	| lastNonDigit incrementedVersionNumber | 	lastNonDigit := aString findLast: [ :char | char isDigit not ]. 	lastNonDigit = aString size ifTrue: [ ^aString ]. 	incrementedVersionNumber := ( aString copyFrom: lastNonDigit + 1 to: aString size ) asNumber + 1. 	^( aString copyFrom: 1 to: lastNonDigit ) 		, incrementedVersionNumber printString</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="initialVersionForPundle:">initialVersionForPundle: aPundle   "Answer a string describing the first version of the package."	^'1.0'</body><body package="Store-User Management" selector="nextVersion:forPundle:">nextVersion: aString forPundle: aPundle	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit	sequence in 'aString'.  If 'aString' does not end with a digit, returns	'aString'"	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	^self increment: aString.</body><body package="Store-User Management" selector="versionStringForPundle:initialVersion:">versionStringForPundle: aPundleModel initialVersion: initVerString 	"If a pundle with the same name and type (package/bundle) as aPundle doesn't	exist already, returns initVerString if initVerString is not nil.  Otherwise, returns 	another version string that doesn't conflict with a database entry.  Returns	nil if the user cancels the operation."	| verString |	verString := initVerString isNil 				ifTrue: [self initialVersionForPundle: aPundleModel]				ifFalse: [initVerString].		[(self existsVersionString: verString forPundle: aPundleModel) and: 			[verString := Dialog 						request: ((#Version1sOf2sAHerVersionFor3s &lt;&lt; #store &gt;&gt; 'Version &lt;1s&gt; of &lt;2s&gt; already exists.&lt;n&gt;Enter another version for &lt;3s&gt;.') 								expandMacrosWith: verString								with: aPundleModel name								with: aPundleModel name)						initialAnswer: verString						onCancel: [nil].			verString notNil]] 			whileTrue.	^verString</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;=">&lt;= aVersionlessPundle	self precedence &lt;= aVersionlessPundle precedence ifFalse: [^false].	^name &lt;= aVersionlessPundle name</body><body package="Store-Database Model" selector="packageFirstOrder:">packageFirstOrder: aVersionlessPundle	"Sort by name, but packages first"	self precedence &gt;= aVersionlessPundle precedence ifFalse: [^false].	^name &lt;= aVersionlessPundle name</body><body package="Store-Database Model" selector="precedence">precedence	^self subclassResponsibility.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="basicComment">basicComment	comment = nil ifTrue: [^nil].	^comment isEmpty ifTrue: [nil] ifFalse: [comment first].</body><body package="Store-Database Model" selector="comment">comment	self basicComment isNil ifTrue: [^''].	^self basicComment source</body><body package="Store-Database Model" selector="comment:">comment: anObject	comment := anObject</body><body package="Store-Database Model" selector="name">name	^name</body><body package="Store-Database Model" selector="name:">name: anObject	name := anObject</body><body package="Store-Database Model" selector="properties">properties	^self versions first properties.</body><body package="Store-Database Model" selector="versionComment">versionComment	^self comment.</body><body package="Store-Database Model" selector="versions">versions	^versions</body><body package="Store-Database Model" selector="versions:">versions: anObject	versions := anObject</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>printing</category><body package="Store-Database Model" selector="displayString">displayString	^name.</body><body package="Store-Database Model" selector="printOn:">printOn: aStream	aStream nextPutAll: self name.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle</class-id> <category>testing</category><body package="Store-Database Model" selector="isBundle">isBundle	^false.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPundle class</class-id> <category>constants</category><body package="Store-Database Model" selector="isBundle">isBundle	^false.</body><body package="Store-Database Model" selector="pundleClass">pundleClass	^self subclassResponsibility.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessBundle</class-id> <category>comparing</category><body package="Store-Database Model" selector="precedence">precedence	^1</body></methods><methods><class-id>Store.Glorp.StoreVersionlessBundle</class-id> <category>testing</category><body package="Store-Database Model" selector="isBundle">isBundle	^true.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessBundle class</class-id> <category>constants</category><body package="Store-Database Model" selector="isBundle">isBundle	^true.</body><body package="Store-Database Model" selector="pundleClass">pundleClass	^StoreBundle.</body></methods><methods><class-id>Store.LoadOrSaveInvalidArgumentsError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog warn: (#_1sInvalidArguments2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: invalid arguments &lt;2s&gt;'		expandMacrosWith: messageText first 		with: messageText last)</body></methods><methods><class-id>Store.ShadowedObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="from:">from: aStoreObjectInPackage	package := aStoreObjectInPackage package.	storeObject := aStoreObjectInPackage.	override := false</body><body package="Atomic Compiling and Loading" selector="from:in:">from: aStoreObject in: aStorePackage	package := aStorePackage.	storeObject := aStoreObject asStoreObjectInPackage: aStorePackage.	override := false</body><body package="Atomic Compiling and Loading" selector="package">package	^package</body><body package="Atomic Compiling and Loading" selector="packageModel">packageModel	^package storeModel</body><body package="Atomic Compiling and Loading" selector="shadowCompiledDefinition">shadowCompiledDefinition	^shadowCompiledDefinition</body><body package="Atomic Compiling and Loading" selector="storeObject">storeObject	^storeObject</body></methods><methods><class-id>Store.ShadowedObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading" selector="compileWith:">compileWith: anAtomicAnalysisLoader	self subclassResponsibility</body><body package="Atomic Compiling and Loading" selector="fixAndInstallNotification:">fixAndInstallNotification: aRedefinitionNotification	aRedefinitionNotification override install.	aRedefinitionNotification override cleanUpAfterLoad</body><body package="Atomic Compiling and Loading" selector="installWith:">installWith: anAtomicAnalysisLoader	self subclassResponsibility</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading" selector="compileWith:">compileWith: anAtomicAnalysisLoader	[[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDefinedRecord: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader unloadableDefinitions add: (exception definitionRecord: self).			exception resume]]				on: RedefinitionNotification				do: 					[:notification |					anAtomicAnalysisLoader overrides add: notification.					override := true.					notification resume]]						on: VariableConfirmation 						do: [:exception | exception resume: false]</body><body package="Atomic Compiling and Loading" selector="installWith:">installWith: anAtomicAnalysisLoader	[[anAtomicAnalysisLoader installNameSpace: self]		on: RedefinitionNotification		do:			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			(currentPackage notNil and: [self packageModel name = currentPackage name or: [currentPackage name = Registry nullPackageName]]) 				ifFalse: 					[self fixAndInstallNotification: notification.					anAtomicAnalysisLoader overrides add: notification].			notification resume]]				on: VariableConfirmation 				do: [:exception | exception resume: false]</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="from:">from: aStoreNamespaceInPackage	super from: aStoreNamespaceInPackage.	longName := aStoreNamespaceInPackage longName.	ownerName := aStoreNamespaceInPackage definition environmentName.</body><body package="Atomic Compiling and Loading" selector="from:in:">from: aStoreNamespace in: aStorePackage	super from: aStoreNamespace in: aStorePackage.	longName := aStoreNamespace longName.	ownerName := aStoreNamespace environmentName.</body><body package="Atomic Compiling and Loading" selector="longName">longName	^longName</body><body package="Atomic Compiling and Loading" selector="ownerName">ownerName	^ownerName</body></methods><methods><class-id>Store.ShadowedNamespaceObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	aStream nextPutAll: 'aShadowedNamespace('.	aStream nextPutAll: self longName.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.PkgClassesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="commentID">commentID	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: aValue	commentID := aValue</body><body package="Store-DB-Records" selector="definitionID">definitionID	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: aValue	definitionID := aValue</body><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: anInteger	"Set the receiver's definitionOrder."	definitionOrder := anInteger</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: aString		environmentString  := aString</body><body package="Store-DB-Records" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: anObject	packageRef := anObject</body><body package="Store-DB-Records" selector="superclass">superclass	^superclass</body><body package="Store-DB-Records" selector="superclass:">superclass: anObject	superclass := anObject</body></methods><methods><class-id>Store.PkgClassesView</class-id> <category>private</category><body package="Store-DB-Records" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Records" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.PkgClassesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'classRef'</body><body package="Store-DB-Records" selector="parentReference">parentReference	^'packageRef'</body><body package="Store-DB-Records" selector="referencedClass">referencedClass	^ClassRecord</body><body package="Store-DB-Records" selector="subCollectionClass">subCollectionClass	^PkgClasses</body></methods><methods><class-id>Store.PkgClassesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="classesSession">classesSession	( self isSessionValid: ClassesSession)		ifFalse:			[ClassesSession := self broker getNewSession.			ClassesSession bindOutput: self newPrimed.			ClassesSession bindInput: Package new.			ClassesSession prepare: 						( self newSQL						selectAll;						where;						column: #packageRef equalTo: ':primaryKey';						orderBy:  #definitionOrder)].	^ClassesSession</body><body package="Store-DB-Records" selector="resetSession">resetSession	ClassesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: ClassesSession].		ClassesSession := nil]</body></methods><methods><class-id>Store.PkgClassesView class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.PkgMetaclassesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'metaclassRef'</body></methods><methods><class-id>Store.PkgMetaclassesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="metaclassesSession">metaclassesSession	( self isSessionValid: MetaclassesSession)		ifFalse:			[MetaclassesSession := self broker getNewSession.			MetaclassesSession bindOutput: self newPrimed.			MetaclassesSession bindInput: Package new.			MetaclassesSession prepare: 						( self newSQL							selectAll;							where;							column: #packageRef equalTo: ':primaryKey';							orderBy: #definitionOrder) ].	^MetaclassesSession</body><body package="Store-DB-Records" selector="resetSession">resetSession	MetaclassesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: MetaclassesSession].		MetaclassesSession := nil]</body></methods><methods><class-id>Store.Association</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	self subclassResponsibility</body></methods><methods><class-id>Store.Association class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	^Dictionary new.</body></methods><methods><class-id>Store.Association class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="referenceColumn">referenceColumn	"implement for any class doing package cross-referencing."	^self subclassResponsibility</body><body package="Store-DB-BaseObjects" selector="viewColumnNames">viewColumnNames	"Answer a collection of column names that should be included 	into a view table."	^#()</body></methods><methods><class-id>Store.Association class</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="allInstancesInAndOnlyIn:">allInstancesInAndOnlyIn: packageKeys	"Send to a concrete subclass. Answer a collection of ids of instance records 	that is in the set of packages and no others." 	| rows out in |	rows := self allPackagesCrossReferenced: packageKeys.	out := Set new: rows size.	in := Set new: rows size.	rows do:		[ :row |		( packageKeys includes: row packageRef )			ifTrue: 				[ ( out includes: row referenceField )					ifFalse: [ in add: row referenceField ]				]			ifFalse: 				[ out add: row referenceField.				in remove: row referenceField ifAbsent: nil.				]		].	^in asOrderedCollection</body><body package="Store-DB-BaseObjects" selector="allPackagesCrossReferenced:">allPackagesCrossReferenced: packageKeys	"Send to a concrete subclass. Answer a collection of instances that is in the set of packages and no others" 	^self allPackagesCrossReferenced: packageKeys refColumn: self referenceColumn</body><body package="Store-DB-BaseObjects" selector="allPackagesCrossReferenced:refColumn:">allPackagesCrossReferenced: packageKeys refColumn: refColumn 	"Send to a concrete subclass. Answer a collection of instances that includes 	all the methods 	referenced by all the packages and back again."	"Methods allPackagesCrossReferenced: #( 100 178 ) refColumn: #methodRef"	"We need to make sure the query string isn't too long. 	What follows is an overly cautious."	| res maxIds answer pkeys |	maxIds := (self broker maxSqlString - 100) // 10.	answer := OrderedCollection new: 500.	pkeys := packageKeys asOrderedCollection.	1 to: pkeys size by: maxIds do: 		[ :index |  | keys |		keys := pkeys copyFrom: index to: (index + maxIds - 1 min: packageKeys size).		[ res := self broker 					getAnswerFromSession: [self crossRefSession: keys refColumn: refColumn]					bindInput: [:x | ]		] on: self errorSignals do: 				[ :exp | self error: #CannotCompleteGC &lt;&lt; #store &gt;&gt; 'Cannot complete GC' ].			answer addAll: res ].	^answer asOrderedCollection</body><body package="Store-DB-BaseObjects" selector="crossRefSession:refColumn:">crossRefSession: packageKeys refColumn: refColumn	"Answer a session for doing a cross-reference between packageKeys and a column."	"Send to a concrete subclass. NOTE- a once only session, so we're not saving it"	| stringKeys |	stringKeys := packageKeys collect: [ :k | k printString ].	^self broker getNewSession		bindOutput: self newPrimed;		blockFactor: ( self safeBlockFactor: 10000 );		prepare:			( self newSQL				selectAll;				where;				column: refColumn;				in: ( self newSQL						selectDistinct: ( Array with: refColumn );						where;						column: #packageRef equalToArray: stringKeys					)			);		yourself.</body><body package="Store-DB-BaseObjects" selector="removeAllConnectedTo:">removeAllConnectedTo: aPackageID	"Remove any record from the table which references aPackageID.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self deleteWhereColumn:  #packageRef value: aPackageID printString.</body></methods><methods><class-id>Store.Association class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="itemCountForPackage:">itemCountForPackage: aPackageRef	"Ansert the number of instances associated with aPackageRef."	"Send to a concrete subclass."	| res query |	( query := self newSQLFor: self )		selectCountAll;		where;		column: #packageRef equalTo: aPackageRef printString.				res := self broker processSQL: query sqlString.	^res first first</body></methods><methods><class-id>Store.BundlePart</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="bundleRef">bundleRef	"Answer the receiver's bundleRef."	^bundleRef</body><body package="Store-DB-Pundles" selector="bundleRef:">bundleRef: newBundleRef	"Set the receiver's bundleRef to newBundleRef."	bundleRef := newBundleRef</body><body package="Store-DB-Pundles" selector="expressionID">expressionID	"Answer the receiver's expressionID."	^expressionID</body><body package="Store-DB-Pundles" selector="expressionID:">expressionID: newExpressionID	"Set the receiver's expressionID to newExpressionID."	expressionID := newExpressionID</body><body package="Store-DB-Pundles" selector="expressionStr">expressionStr	"Answer the receiver's expressionStr."	^expressionStr</body><body package="Store-DB-Pundles" selector="expressionStr:">expressionStr: newExpressionStr	"Set the receiver's expressionStr to newExpressionStr."	expressionStr := newExpressionStr</body><body package="Store-DB-Pundles" selector="seqNumber">seqNumber	"Answer the receiver's seqNumber."	^seqNumber</body><body package="Store-DB-Pundles" selector="seqNumber:">seqNumber: newSeqNumber	"Set the receiver's seqNumber to newSeqNumber."	seqNumber := newSeqNumber</body></methods><methods><class-id>Store.BundlePart</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $&lt;.	bundleRef printOn: aStream.	aStream nextPut: $[.	seqNumber printOn: aStream.	aStream nextPut: $].</body></methods><methods><class-id>Store.BundlePart</class-id> <category>private</category><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB. 	It is crucial for reading from DB since the primed slots are skipped."	expressionStr := Object new</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	expressionStr := nil</body></methods><methods><class-id>Store.BundlePart class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames	| columnNames |	columnNames := super columnNames.	columnNames remove: 'expressionStr'.	^columnNames</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'bundleRef' put: #PrimaryKey.	aDict at: 'expressionID' put: #Integer.	aDict at: 'seqNumber' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.BundlePart class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="allFromBundleID:">allFromBundleID: aBundleID	"Answer a collection of descriptions that comprises	the content of a bundle aBundleID."	^[self processList: (self broker process: 							( self newSQL								selectAll;								where;								column: #bundleRef equalTo: aBundleID printString)						bindOutput: self newPrimed)	]	on: self  errorSignals 	do: 	[:ex |  ex outer.  ^OrderedCollection new ]</body></methods><methods><class-id>Store.BundlePart class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Pundles" selector="removeAllConnectedTo:">removeAllConnectedTo: aBundleID	"Remove any record from the table which references aBundleID.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self deleteWhereColumn:  #bundleRef value: aBundleID printString.</body></methods><methods><class-id>Store.Bundles</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDBComponent">asDBComponent	"Answer a corresponding Bundle."	| rec |	[ rec := Bundle aRecordWithID: subBundleRef ]		on: self errorSignals		do: [ :ex | ex outer. ^nil ].	rec == nil 		ifTrue: [ Pundle componentNotFoundSignal raiseWith: self ].	^rec</body><body package="Store-DB-Pundles" selector="subBundleRef">subBundleRef	"Answer the receiver's subBundleRef."	^subBundleRef</body><body package="Store-DB-Pundles" selector="subBundleRef:">subBundleRef: newSubBundleRef	"Set the receiver's subBundleRef to newSubBundleRef."	subBundleRef := newSubBundleRef</body></methods><methods><class-id>Store.Bundles</class-id> <category>private</category><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription		^BundleDescription new		id: subBundleRef;		dbIdentifier: DbRegistry dbIdentifier;		yourself</body></methods><methods><class-id>Store.Bundles class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'subBundleRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Bundles class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_BundlesReverse' #('subBundleRef'))		)</body><body package="Store-DB-Pundles" selector="viewColumnNames">viewColumnNames	"Answer a collection of column names that should be included 	into a view table."	| coll |	coll := OrderedCollection withAll: super viewColumnNames.	coll add: 'expression'; add: 'seqNumber'.	^coll</body></methods><methods><class-id>Store.Bundles class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="enclosingComponentsOfId:">enclosingComponentsOfId: aBundleID	"Answer a collection of bundles that comprise the containers of a bundle, aBundleID."	^ self select: #bundleRef column: #subBundleRef  value: aBundleID printString.</body><body package="Store-DB-Pundles" selector="select:column:value:">select: column column: aCol value: aVal	"Answer a collection of bundles that comprise the containers of a bundle, aBundleID."	| sql items |	sql := ( self newSQL			select: (Array with: column);			where;			column: aCol equalTo: aVal).	items := [ ( self broker process: sql ) collect: [ :array | Bundle aRecordWithID: array first ] ] 		on: self errorSignals 		do: [:ex | ex outer. OrderedCollection new ].	^items asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp].</body></methods><methods><class-id>Store.Glorp.ClassVersionsNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="packageClassesFor:">packageClassesFor: packageCollection 	| objects |	packageCollection isEmpty ifTrue: [^nil].	objects := OrderedCollection new.	packageCollection do: 			[:each | 			objects				addAll: (self convertToFullNames: each allClasses asSortedCollection);				addAll: (self convertToFullNames: each allNameSpaces asSortedCollection)].	^objects</body><body package="StoreForGlorpBrowserUI" selector="sortList:">sortList: aCollection 	^aCollection asList</body></methods><methods><class-id>Store.ClassTag</class-id> <category>testing</category><body package="Store-Change Management" selector="belongsToClass">belongsToClass	^true</body><body package="Store-Change Management" selector="existsInImage">existsInImage	^self actualClass notNil</body><body package="Store-Change Management" selector="isClassTag">isClassTag	^true</body><body package="Store-Change Management" selector="isForClass">isForClass	^true</body><body package="Store-Change Management" selector="isInClass">isInClass	^true</body></methods><methods><class-id>Store.ClassTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new class from a definition contained in 	aRecord.	Return true is the operation is successful."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag 	can be load into the image. 	For class definition it is always true."	^self isMeta		ifTrue: [super canLoad]		ifFalse: [true]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the 	defintion described by me."	"(ClassCommentTag newClassName: 'MethodTag class') 	containingPackage"	^Registry containingPackageForClassNamed: self className</body><body package="Store-Change Management" selector="description">description	^'class definition'</body><body package="Store-Change Management" selector="name">name	^self className</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl definition]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag.  Return True if	sucessful and False on failure."	| actualClass changedClass |	actualClass := self actualClass.	actualClass isNil ifTrue: [actualClass := nil class].	Cursor execute showWhile: [changedClass := actualClass evaluatorClass "subclassDefinerClass"					evaluate: someText string					notifying: aController					logged: true].	^changedClass ~~ nil</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	actual notNil		ifTrue: [XChangeSet current				moveClassDefinition: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	"Remove the receiver's definition from the image if aPackage owns it. If tolerantBoolean is false, 	display an error if the definition doesn't exist."	| cls |	cls := self actualClass.	cls isNil 		ifTrue: 			[tolerantBoolean 				ifFalse: 					[self error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') 								expandMacrosWith: self className)]]		ifFalse: 			[(aPackage hasDefinitionFor: cls) 				ifTrue: [Override unloadClassOrNameSpace: cls from: aPackage]]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseClass: self actualClass.</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType	^#class</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self actualClass ) == nil		ifFalse:  [ obj fileOutDefinitionOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutDefinitionOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	self isMeta		ifFalse: [ aStream removeObject: symbol type: self fileOutObjectType ]</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'class definition'</body></methods><methods><class-id>Store.ClassTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForClassTag: self.</body></methods><methods><class-id>Store.ClassTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^1		"also reserves 5 for metaclass"</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>accessing</category><body package="Store-UI" selector="fillInFor:">fillInFor: anObject	self subclassResponsibility</body><body package="Store-UI" selector="fillListWith:">fillListWith: aCollection		self itemsInList list: aCollection</body><body package="Store-UI" selector="listMenu">listMenu	^[| menu |	menu := (self class mainMenu atNameKey: #Action) submenu.	menu augmentFrom: self class		to: DefinitionsForListPane		menuName: #listMenu		for: self.	menu]</body><body package="Store-UI" selector="listOfThings">listOfThings	^self</body><body package="Store-UI" selector="listTitle">listTitle	self subclassResponsibility</body><body package="Store-UI" selector="reportUnpackagedDefinitionNamed:">reportUnpackagedDefinitionNamed: aString		Transcript		show:				(#AtLeastOneVersionOf1sNoPackage &lt;&lt; #store &gt;&gt; 'At least one version of &lt;1s&gt; has no associated package.&lt;n&gt;It has been excluded from the version list'						expandMacrosWith: aString);		cr</body><body package="Store-UI" selector="selections">selections	^self itemsInList selections</body><body package="Store-UI" selector="title">title	^title ifNil: ['']</body><body package="Store-UI" selector="title:">title: aString	title := aString</body><body package="Store-UI" selector="tool:">tool: aDefinitionForListTool	tool := aDefinitionForListTool</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>actions</category><body package="Store-UI" selector="inspectSelected">inspectSelected	self itemsInList selections first inspect</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated	self subclassResponsibility</body><body package="Store-UI" selector="updateStatusPaneWith:">updateStatusPaneWith: aStringOrText	tool updateStatusPaneWith: aStringOrText</body><body package="Store-UI" selector="updateStatusUsing:">updateStatusUsing: package		| statusText hasDefinition |	hasDefinition := (package isGlorpProxy not or: [package isInstantiated]).	hasDefinition ifFalse: [package getValue].	statusText := TextStream on: String new.	package ifNotNil:		[statusText emphasis: #bold.		statusText nextPutAll: (#PackageOrBundleColon &lt;&lt; #store &gt;&gt; '&lt;1?Package:Bundle&gt;: ' expandMacrosWith: package isPackage).		statusText emphasis: #none.		statusText nextPutAll: package name.		statusText space.		statusText nextPutAll: package versionString].	self updateStatusPaneWith: statusText contents</body><body package="Store-UI" selector="updateTextPaneWith:">updateTextPaneWith: aStringOrText	tool updateTextPaneWith: aStringOrText</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>aspects</category><body package="Store-UI" selector="itemsInList">itemsInList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^itemsInList isNil		ifTrue:			[itemsInList := MultiSelectionInList new]		ifFalse:			[itemsInList]</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane</class-id> <category>interface opening</category><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self itemsInList selectionIndexHolder onChangeSend: #selectionsUpdated to: self</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane class</class-id> <category>utility</category><body package="Store-UI" selector="fileOutDifferencesBetweenBundle:and:into:using:">fileOutDifferencesBetweenBundle: aPundle and: anotherPundle into: fileName using: session		| comparitor fileManager fromPundleItems toPundleItems matchups |	fromPundleItems := aPundle withAllItems.	toPundleItems := anotherPundle withAllItems.	matchups := OrderedCollection new.	fromPundleItems do:		[:each |		| toPundle |		toPundle := toPundleItems 			detect: [:eachPundle | eachPundle name = each name and: [eachPundle isBundle = each isBundle]]			ifNone: [nil].		matchups add: each -&gt; (toPundle ifNil: [Store.PseudoPackage new])].	toPundleItems do:		[:each |		| fromPundle |		fromPundle := fromPundleItems 			detect: [:eachPundle | eachPundle name = each name and: [eachPundle isBundle = each isBundle]]			ifNone: [nil].		fromPundle isNil ifTrue: [matchups add: (fromPundle ifNil: [Store.PseudoPackage new]) -&gt; each]].	[fileManager := SourceCodeStream write: fileName encoding: #Source.	fileManager timeStamp.	matchups do:		[:eachPair |		(Store.FilingOut for: eachPair key) started.		comparitor := Store.PackageComparitor			differencesWithPropertiesBetween: (eachPair key asStoreComparisonObjectIn: session)			and: (eachPair value asStoreComparisonObjectIn: session).		fileManager sourceFormatter attributeFor: #package compute: [:ignore | eachPair key name].		fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | eachPair key name].		comparitor fileOutMainToOtherDifferencesOn: fileManager.		(Store.FilingOut for: eachPair key) finished]] ensure: [fileManager close]</body><body package="Store-UI" selector="fileOutDifferencesBetweenPackage:and:into:using:">fileOutDifferencesBetweenPackage: aPundle and: anotherPundle into: fileName using: session		| comparitor fileManager |	comparitor := Store.PackageComparitor		differencesWithPropertiesBetween: (aPundle asStoreComparisonObjectIn: session)		and: (anotherPundle asStoreComparisonObjectIn: session).	fileManager := SourceCodeStream write: fileName encoding: #Source.	[fileManager timeStamp.	fileManager sourceFormatter attributeFor: #package compute: [:ignore | aPundle name].	fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aPundle name].	comparitor fileOutMainToOtherDifferencesOn: fileManager] ensure: [fileManager close]</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>actions</category><body package="Store-UI" selector="askToReinitializeSharedVariable:">askToReinitializeSharedVariable: aVariableBinding		^Dialog confirm: (#ReInitializeSharedVariable &lt;&lt; #store &gt;&gt; '(Re)Initialize Shared Variable : ''&lt;1s&gt;''?' expandMacrosWith: aVariableBinding absoluteName)</body><body package="Store-UI" selector="compareSelectionWith">compareSelectionWith	| shared target |	shared := self itemsInList selections first.	target := shared class selectStoreVersionOf: shared name in: shared package session.	target ifNotNil: [TextDifferenceBrowser compare: shared definitionString with: target definitionString]</body><body package="Store-UI" selector="compareVersions">compareVersions	| class target |	class := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	TextDifferenceBrowser compare: class definitionString with: target definitionString</body><body package="Store-UI" selector="containingPackages">containingPackages	| shared packages |	shared := self itemsInList selections first.	[(Gathering for: shared name) started.	packages := StoreSharedVariableInPackage allPackagesContaining: shared.	(Gathering for: shared name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: shared longNameFromSmalltalk</body><body package="Store-UI" selector="fileOut">fileOut	| shared fileName fileManager |	shared := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (shared longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: shared package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			shared fileOutOn: fileManager]				ensure: [fileManager close].			(FilingOut for: shared package) finished].</body><body package="Store-UI" selector="loadShared">loadShared	| package shared |	shared := self itemsInList selections first.	package := shared package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: 					[shared loadSource.					shared definition correspondingImageBinding ifNotNil: 						[:value | 						(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]].			(Loading for: package) finished].</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText emphasis: #bold.				updateText nextPutAll: each longName.				updateText emphasis: #none.				updateText cr.				updateText nextPutAll: each definition definitionString.				updateText cr.				updateText cr.				updateText emphasis: (Array with: #color-&gt; ColorValue navy).				updateText nextPutAll: each definition comment.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>menu</category><body package="Store-UI" selector="oneItemAndInImage">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection definition owner notNil]</body><body package="Store-UI" selector="onlyOneItemSelected">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI" selector="onlyTwoItemsSelected">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>interface opening</category><body package="Store-UI" selector="compositeViewUsing:nameSize:longestTimestamp:longestUsername:in:">compositeViewUsing: aShared nameSize: longestName longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView	| iconPart currentStart nameLabel timestampLabel mainThing usernameLabel packageNameLabel |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aShared toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aShared longNameFromSmalltalk asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	timestampLabel := Label with: aShared definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aShared definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: aShared package name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestTimestamp := longestUsername :=  0.	items do:		[:each | 		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestName := (Label with: each longNameFromSmalltalk asText allBold attributes: widget textStyle) width max: longestName].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane</class-id> <category>accessing</category><body package="Store-UI" selector="fillInFor:">fillInFor: aShared	| sharedsInPackage finalSharedsInPackage |	(Gathering for: aShared name) started.	sharedsInPackage := (StoreSharedVariableInPackage		allVersionsWithName: aShared name		inOwner: aShared environmentName		in: (aShared package ifNotNil: [:value | value session])) asList.	finalSharedsInPackage :=  sharedsInPackage reject: [:each | each package isNil].	finalSharedsInPackage size ~= sharedsInPackage size		ifTrue: [self reportUnpackagedDefinitionNamed: aShared name].	self fillListWith: finalSharedsInPackage.	(Gathering for: aShared name) started.</body><body package="Store-UI" selector="listTitle">listTitle		self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title</body><body package="Store-UI" selector="title">title		^title ifNil: [#VersionsOfShared1s &lt;&lt; #store &gt;&gt; 'Versions of shared &lt;1s&gt;' expandMacrosWith: self itemsInList list first name]</body></methods><methods><class-id>Store.DBAccess</class-id> <category>list-text</category><body package="Store-Database" selector="list:includes:">list: list includes: anObject 		list do: [:each | (anObject sameAs: each) ifTrue: [^true]].	^false</body><body package="Store-Database" selector="textForItem:">textForItem: item	^self textForItem: item list: nil</body><body package="Store-Database" selector="textForItem:list:">textForItem: item list: aList 	| nameText |	nameText := item itemString asText.	(aList notNil and: [(self list: aList includes: item) not])		ifTrue: [nameText allBold].	^nameText</body></methods><methods><class-id>Store.DBAccess</class-id> <category>accessing</category><body package="Store-Database" selector="cachedNames">cachedNames	cachedNames isNil ifTrue: [cachedNames := IdentityDictionary new].	^cachedNames</body><body package="Store-Database" selector="cachedNames:">cachedNames: aDictionary	cachedNames := aDictionary</body><body package="Store-Database" selector="connectedProfile">connectedProfile	^connectedProfileHolder value</body><body package="Store-Database" selector="connectedProfileHolder">connectedProfileHolder	"A ValueHolder which always contains a ConnectionProfile for the	currently connected repository, or nil if there is no connection."	^connectedProfileHolder</body><body package="Store-Database" selector="connectionClass">connectionClass	^connection notNil 		ifTrue: [ connection class]		ifFalse: 	[ExternalDatabaseConnection].</body><body package="Store-Database" selector="currentDatabaseAccessorForLogin:">currentDatabaseAccessorForLogin: aGlorpLogin	(currentDatabaseAccessor isNil or: [currentDatabaseAccessor isLoggedIn not or: [self connectedProfile isNil]])		ifTrue: [currentDatabaseAccessor := Glorp.DatabaseAccessor forLogin: aGlorpLogin].	(self connectedProfile notNil and: [self connectedProfile asGlorpLogin ~= aGlorpLogin])		ifTrue: [^Glorp.DatabaseAccessor forLogin: aGlorpLogin].	^currentDatabaseAccessor</body><body package="Store-Database" selector="currentUserName">currentUserName	^self userName</body><body package="Store-Database" selector="databaseIdentifier">databaseIdentifier		(databaseIdentifier isNil and: [self isOnline]) ifTrue: 		[databaseIdentifier := StoreObject databaseIdentifier asString].	^databaseIdentifier</body><body package="Store-Database" selector="databaseIdentifier:">databaseIdentifier: aString	databaseIdentifier := aString.</body><body package="Store-Database" selector="dbIdentifier">dbIdentifier		^self databaseIdentifier ifNotNil: [:value | value asSymbol]</body><body package="Store-Database" selector="dbObject">dbObject	^#{DBObject} valueOrDo: 		[self error: #AttemptToAccessUnloadedDatabaseCode &lt;&lt; #store &gt;&gt; 'Attempt to access unloaded database code']</body><body package="Store-Database" selector="debugger">debugger	^debugger isNil		ifTrue: [ debugger := StoreLogEnvironment new ]		ifFalse: [ debugger ]</body><body package="Store-Database" selector="doIfImageAdministrator:label:">doIfImageAdministrator: aBlock label: aString 	"Evaluate aBlock if we are online and the current user has admistration rights.	Otherwise display an error message"	self doIfOnlineImage: 			[self isSystemAdministrator 				ifTrue: [aBlock value]				ifFalse: 					[Dialog 						warn: (#OnlyTheImageAdministratorCan1s &lt;&lt; #store  &gt;&gt; 'Only the image administrator can &lt;1s&gt;.' expandMacrosWith: aString)]]</body><body package="Store-Database" selector="doIfOnlineImage:">doIfOnlineImage: aBlock 	| choice |	self isOnlineImage ifTrue: [^aBlock value].	storeBroker ifNil: [^self].	choice := Dialog confirm: (#TheImageIsDisconnecOuLikeToReconnect &lt;&lt; #store &gt;&gt; 'The image is disconnected from the Database.&lt;n&gt;Would you like to reconnect?') expandMacros.	choice ifFalse: [^self].	self restoreConnection.	self isOnlineImage ifFalse: [^self].	^aBlock value</body><body package="Store-Database" selector="highestPrimaryKeyChecked">highestPrimaryKeyChecked	highestPrimaryKeyChecked isNil ifTrue: [highestPrimaryKeyChecked := IdentityDictionary new].	^highestPrimaryKeyChecked</body><body package="Store-Database" selector="highestPrimaryKeyChecked:">highestPrimaryKeyChecked: anObject	highestPrimaryKeyChecked := anObject</body><body package="Store-Database" selector="isOnline:">isOnline: aValue 	isOnline := aValue</body><body package="Store-Database" selector="isSystemAdministrator">isSystemAdministrator		^[self isOnline 		ifFalse: [false] 		ifTrue: [Store.Glorp.StoreUserGroup dbHasAdmin not or: [Store.Glorp.StoreUserGroup isInAdmin: self currentUserName]]]			on: self errorSignals			do:				[:ex | 				Transcript					cr;					show: ex description.				ex return: false]</body><body package="Store-Database" selector="recentProfile">recentProfile	^recentProfile</body><body package="Store-Database" selector="resetConnection">resetConnection	connection := nil.	connectedProfileHolder value: nil.	currentDatabaseAccessor := nil</body><body package="Store-Database" selector="storeBroker">storeBroker	storeBroker isNil 		ifTrue: 			[Dialog warn: #BrokerDisconnectedFromDB &lt;&lt; #store &gt;&gt; 'Broker: Disconnected from DB'.			^StoreError raiseSignal].	^storeBroker</body><body package="Store-Database" selector="storeBroker:">storeBroker: aBroker	storeBroker := aBroker</body><body package="Store-Database" selector="storeDescriptorSystemFor:">storeDescriptorSystemFor: aSymbol	storeDescriptorSystems ifNil: [storeDescriptorSystems := Dictionary new].	^storeDescriptorSystems at: aSymbol ifAbsent: [nil]</body><body package="Store-Database" selector="storeDescriptorSystemFor:ifAbsentPut:">storeDescriptorSystemFor: aSymbol ifAbsentPut: aStoreDescriptorSystemBlock	storeDescriptorSystems ifNil: [storeDescriptorSystems := Dictionary new].	^storeDescriptorSystems at: aSymbol ifAbsentPut: aStoreDescriptorSystemBlock</body><body package="Store-Database" selector="storeDescriptorSystemForLogin:inSession:">storeDescriptorSystemForLogin: aGlorpLogin inSession: aSession	| databaseID systemClass |	databaseID := aGlorpLogin connectString.	systemClass := self 		storeDescriptorSystemFor: databaseID		ifAbsentPut: 			[(StoreDescriptorSystem				checkStoreVersionFor: aGlorpLogin				using: aSession accessor) class].	^systemClass forPlatform: aGlorpLogin database.</body><body package="Store-Database" selector="tableOwner">tableOwner	^self tablePrefix</body><body package="Store-Database" selector="tablePrefix">tablePrefix	tablePrefix isNil ifTrue: [tablePrefix := self defaultTablePrefix].	^tablePrefix</body><body package="Store-Database" selector="tablePrefix:">tablePrefix: aString	tablePrefix := aString</body><body package="Store-Database" selector="useAtomicLoader">useAtomicLoader	^self class useAtomicLoader</body><body package="Store-Database" selector="useAtomicLoader:">useAtomicLoader: aBoolean	^self class useAtomicLoader: aBoolean</body></methods><methods><class-id>Store.DBAccess</class-id> <category>initialize-release</category><body package="Store-Database" selector="cloneFrom:">cloneFrom: existingDBAccess 	connectedProfileHolder := existingDBAccess  connectedProfileHolder.	self isOnline: existingDBAccess  isOnline.	(existingDBAccess  tablePrefix isEmpty not and: [existingDBAccess  tablePrefix last == $.]) 		ifTrue: [ self tablePrefix: (existingDBAccess  tablePrefix copyUpTo: $.)]		ifFalse: [ self tablePrefix: existingDBAccess   tablePrefix].	self tablePrefix: existingDBAccess  tablePrefix.	self storeBroker: existingDBAccess  storeBroker.	"If we have a connection, we will have discarded it. Make sure we cleanly log out from the other connection, and force ourselves to reconnect."	self connection: existingDBAccess connection.	recentProfile := existingDBAccess recentProfile.	databaseIdentifier := existingDBAccess databaseIdentifier.	currentDatabaseAccessor := existingDBAccess currentDatabaseAccessor.	storeDescriptorSystems := existingDBAccess storeDescriptorSystems</body><body package="Store-Database" selector="initialize">initialize	connectedProfileHolder := nil asValue</body></methods><methods><class-id>Store.DBAccess</class-id> <category>actions</category><body package="Store-Database" selector="createInstallScript">createInstallScript		installScript := true.	self openLogTool.	[self installDatabaseTables]		ensure:			[installScript := nil]</body><body package="Store-Database" selector="deinstallDatabaseTables">deinstallDatabaseTables		| connectionProfile login session newConnection |	(connectionProfile := Store.ConnectionDialog chooseProfile) ifNil: [^self].	[(UninstallingDatabaseTables for: 'Store') started.	newConnection := Store.ConnectionDialog connect: connectionProfile.	login := StoreLoginFactory convertStoreLogin: connectionProfile.	session := Glorp.GlorpSession fromLogin: login.	session accessor connection: newConnection.	StoreDescriptorSystem checkConnectionFor: login using: session accessor.	session dropTables.	(UninstallingDatabaseTables for: 'Store') finished] withStoreFeedbackOn: VisualLauncher allInstances first mainWindow</body><body package="Store-Database" selector="goToScript">goToScript	^installScript notNil</body><body package="Store-Database" selector="installDatabaseTables">installDatabaseTables	| connectionProfile login session newConnection |	(connectionProfile := Store.ConnectionDialog chooseProfile) ifNil: [^self].	[(InstallingDatabaseTables for: 'Store') started.	newConnection := Store.ConnectionDialog connect: connectionProfile.	login := StoreLoginFactory convertStoreLogin: connectionProfile.	session := Glorp.GlorpSession fromLogin: login.	session accessor connection: newConnection.	(StoreDescriptorSystem checkConnectionFor: login using: session accessor)		ifFalse: [Dialog warn: #TablesAlreadyInstalled &lt;&lt; #store &gt;&gt; 'Tables already installed'].	(InstallingDatabaseTables for: 'Store') finished] withStoreFeedbackOn: VisualLauncher allInstances first mainWindow</body><body package="Store-Database" selector="oldDeinstallDatabaseTables">oldDeinstallDatabaseTables		self deprecated: #(#initial '5i' #obsolete '7.8' #for 'reference only').	self error: 'This code should NOT be run, and is here for research and reference only'.	"[self reconnect: false.	Package deinstallPkgs.	Privileges dropTables.	(Dialog confirm: #DoYouWantToDropTablespacesDatabases &lt;&lt; #store &gt;&gt; 'Do you want to drop tablespaces/databases?') 			ifTrue: [DBObject dropDatabases].	self goOffLine] 			on: Error			do: 				[:ex | 				self goOffLine.				ex return]"</body><body package="Store-Database" selector="oldInstallDatabaseTables">oldInstallDatabaseTables	self deprecated: #(#initial '5i' #obsolete '7.8' #for 'reference only').	self error: 'This method is deprecated, and here for research and reference only'.	"self reconnect: false.	DBObject installPhysicalSpaces isNil 		ifTrue: 			[self goOffLine.			^false].	Package installPkgs.	self goToScript ifFalse: [DatabaseIdentifier installInDatabase].	Privileges installUserManagementTables.	self goToScript 		ifFalse: 			[(Dialog confirm: #InstallManagementPolicies &lt;&lt; #store &gt;&gt; 'Install management policies?') 				ifTrue: [Privileges installUserManagement]				ifFalse: 					[Dialog 						warn: (#ToAddUserManagementStallUserManagement &lt;&lt; #store &gt;&gt;									'To add user management policies later, execute:&lt;n&gt;''StoreDescriptorSystem installUserManagementPolicies''') expandMacros.					self printDebug: (#YouDidNotCreatedUsStallUserManagement &lt;&lt; #store &gt;&gt;			'You did not create user management policies. To add user management policies later execute: ''StoreDescriptorSystem installUserManagementPolicies''') asString]].	self goOffLine"</body><body package="Store-Database" selector="openLogTool">openLogTool		self debugger reset.	StoreLoggingTool clear.	self debugger dependents isEmpty ifTrue: [StoreLoggingTool openWith: self debugger]</body><body package="Store-Database" selector="update5i2">update5i2		self deprecated: #(#initial '5i.2' #sunset '7.0').	"Store.DatabaseIdentifier createDatabaseTable.	(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: self databaseIdentifier.	Store.Package update5i2"</body><body package="Store-Database" selector="update5i3">update5i3	"Fix for databases created with 5i.2. Alter STORAGE PSTINCREASE from 0 to 1"	Package alterTablesPctincrease.	Privileges alterTablesPctincrease</body><body package="Store-Database" selector="update7">update7	"Adds sourceViews."	DBObject broker 		createSourcesViewForClass: MethodsAndSourcesView;		createSourcesViewForClass: DataAndSourcesView;		createSourcesViewForClass: PkgClassesAndSourcesView;		createSourcesViewForClass: PkgNameSpacesAndSourcesView.</body><body package="Store-Database" selector="update73">update73	"Adds tables and views for properties, files and column for SmalltalkDoc."	"merges in update7 for those who didn't upgrade last time."	Store.Properties createDatabaseTable.	Store.PropertyRecord createDatabaseTable.	Store.PropertiesView createViewForClass: Store.PropertiesView.	FileRecord createDatabaseTable.	Files createDatabaseTable.	MethodsView tableExists ifTrue: 		[self storeBroker dropViewForClass: MethodsView].	MethodsAndSourcesView tableExists ifTrue: 		[self storeBroker dropViewForClass: MethodsAndSourcesView].	self storeBroker		createViewForClass: MethodsView;		createSourcesViewForClass: MethodsAndSourcesView.	PkgClassesAndSourcesView tableExists		ifFalse: 			[ self storeBroker  				createSourcesViewForClass: DataAndSourcesView;				createSourcesViewForClass: PkgClassesAndSourcesView;				createSourcesViewForClass: PkgNameSpacesAndSourcesView.			].</body><body package="Store-Database" selector="update77">update77	"Adds the indexes for tables... First remove the one from Method, then proceed with the rest"	"Store.DbRegistry update77"		Package createTableIndexes.</body><body package="Store-Database" selector="update771">update771	"Adds the indexes for Method and Methods tables and adds Unique Constraints for Bundle and Package on version+name	Note: If either the Package or Bundle table have duplicate version+name rows, the adding of unique constraints will fail"	"Store.DbRegistry update771"		| session |	Cursor execute showWhile: 		[Store.Method createDatabaseIndex.		Store.Methods createDatabaseIndex.		session := Store.Glorp.StoreLoginFactory currentStoreSession.		session system update771].</body><body package="Store-Database" selector="update78">update78	"This update makes sure that the indexes for TW_PkgClasses are correct, since we have modified that table's descriptor"	"Store.DbRegistry update78"		| session |	Cursor execute showWhile: 		[session := Store.Glorp.StoreLoginFactory currentStoreSession.		session system update78].</body></methods><methods><class-id>Store.DBAccess</class-id> <category>defaults</category><body package="Store-Database" selector="defaultEnvironmentString">defaultEnvironmentString	^''</body><body package="Store-Database" selector="defaultTablePrefix">defaultTablePrefix	^'BERN'</body></methods><methods><class-id>Store.DBAccess</class-id> <category>debug</category><body package="Store-Database" selector="debug">debug		^ debug == nil		ifTrue: [ debug := false]		ifFalse: [ debug].</body><body package="Store-Database" selector="debug:">debug: aBoolean		debug := aBoolean</body><body package="Store-Database" selector="debugOff">debugOff		self debug: false.</body><body package="Store-Database" selector="debugOn">debugOn		self debug: true.</body><body package="Store-Database" selector="log">log		^ log == nil		ifTrue: [ log := false]		ifFalse: [ log ].</body><body package="Store-Database" selector="log:">log: aBoolean		log := aBoolean</body><body package="Store-Database" selector="logFile">logFile	^ logFile isNil 		ifTrue: [ logFile := (Filename named: 'StoreLog.txt') readAppendStream]		ifFalse: [ logFile]</body><body package="Store-Database" selector="logOff">logOff		self log: false.</body><body package="Store-Database" selector="logOn">logOn		self log: true.</body><body package="Store-Database" selector="printDebug:">printDebug: anObj	self debug		ifTrue: [ Transcript cr; show: (self printString: anObj)].	self printLog: anObj.</body><body package="Store-Database" selector="printLog:">printLog: anObj	self log		ifTrue: 			[				self logFile nextPutAll: (self printString: anObj); cr.				self logFile flush.				self logFile close.			]</body><body package="Store-Database" selector="printString:">printString: anObj	| stream |	stream := ( String new: 50) writeStream.		anObj printOn: stream.	^ stream contents.</body></methods><methods><class-id>Store.DBAccess</class-id> <category>utilities</category><body package="Store-Database" selector="checkForUpdates">checkForUpdates		^self checkForUpdates73</body><body package="Store-Database" selector="checkForUpdates73">checkForUpdates73	^self 		withUpgradeExpression: 'update73' 		andWarningDo: 			[:upgradeExpression :warning|			|okToConnect|			okToConnect := true.			DbRegistry isImage73Enabled				ifTrue: 					[ DbRegistry isDb73Enabled						ifFalse:  							[ Transcript cr; show: upgradeExpression.							okToConnect := Dialog confirm: warning							]						].			okToConnect]</body><body package="Store-Database" selector="connectProfileNamed:">connectProfileNamed: aString	| profile |	profile := RepositoryManager repositories		detect: [:each | each name = aString]		ifNone: [^self error: ((#NoSuchConnectionNamed1s &lt;&lt; #store &gt;&gt; 'No Connection Named &lt;1s&gt;') expandMacrosWith: aString)].	self connectedProfile ifNotNil: [ :connectedProfile |		( connectedProfile name = profile name) ifTrue: [			(AlreadyConnected raiseRequestWith: aString) ifFalse: [^self] ] ].	self connectTo: profile</body><body package="Store-Database" selector="withUpgradeExpression:andWarningDo:">withUpgradeExpression: upgradeMethod andWarningDo: twoArgumentBlockClosure	| upgradeExpression warning |	upgradeExpression := 'Please, ask your DBA to evaluate the expression:&lt;nntt&gt;Store.DbRegistry &lt;1s&gt;.' expandMacrosWith: upgradeMethod.	warning := 'You need to update your database.  &lt;1s&gt;&lt;nn&gt;This expression is also in the Transcript and will not affect the ability of older clients to access the database.&lt;n&gt;You should not attempt to perform Store database operations until the update is complete.&lt;nn&gt;Continue to connect so that the expression can be evaluated?' expandMacrosWith: upgradeExpression.	^twoArgumentBlockClosure value: upgradeExpression value: warning</body></methods><methods><class-id>Store.DBAccess</class-id> <category>private-utilities</category><body package="Store-Database" selector="allNamesFor:">allNamesFor: aDbRecordClass 	| sql number names allNames oldNames |	sql := aDbRecordClass newSQL.	sql selectDistinct: #(#name).	(self cachedNames at: aDbRecordClass ifAbsent: [#()]) isEmpty ifFalse: 		[sql			where;			column: #primaryKey greaterThan: (self highestPrimaryKeyChecked at: aDbRecordClass ifAbsent: [0]) printString].	number := (self storeBroker safelyExecuteBlock: 		[self storeBroker 			process: (aDbRecordClass newSQL selectMax: #(#primaryKey))			bindInput: nil			bindOutput: nil]) first first.	number ~= nil ifTrue:		[number &gt; (self highestPrimaryKeyChecked at: aDbRecordClass ifAbsent: [0]) ifFalse: 			[^self cachedNames at: aDbRecordClass]].	names := (self storeBroker safelyExecuteBlock: 		[self storeBroker 			process: sql sqlString			bindInput: nil			bindOutput: nil			usingSession: aDbRecordClass session]) collect: [:each | each first].	oldNames := self cachedNames at: aDbRecordClass ifAbsent: [nil].	allNames := oldNames isNil 		ifTrue: [names asSet] 		ifFalse: [oldNames addAll: names. oldNames].	self cachedNames at: aDbRecordClass put: allNames.	self highestPrimaryKeyChecked at: aDbRecordClass put: (number ifNil: [0]).	^allNames</body><body package="Store-Database" selector="connectedImageMessage">connectedImageMessage	^(#SinceThisImageCannoAbleToSeeSources &lt;&lt; #store &gt;&gt; 'Since this image cannot be used without the database connection if you choose "Cancel" you will not be able to see sources.') asString</body><body package="Store-Database" selector="detachedImageMessage">detachedImageMessage	^(#SinceThisImageCanBAbaseAtThisMoment &lt;&lt; #store &gt;&gt; 'Since this image can be used without the database connection you can choose "Detach" if you do not wish to be connected to the database at this moment.') asString</body><body package="Store-Database" selector="resetSystemDescriptorDictionary">resetSystemDescriptorDictionary	storeDescriptorSystems := nil</body><body package="Store-Database" selector="userName">userName	^connection == nil		ifTrue: [ String new ]		ifFalse: [ connection username ].</body></methods><methods><class-id>Store.DBAccess</class-id> <category>signal constants</category><body package="Store-Database" selector="currentlyNotConnectedSignal">currentlyNotConnectedSignal	^self class currentlyNotConnectedSignal</body><body package="Store-Database" selector="errorSignals">errorSignals	^self class errorSignals</body><body package="Store-Database" selector="notConnectedSignal">notConnectedSignal	^StoreNotConnectedError</body></methods><methods><class-id>Store.DBAccess</class-id> <category>connecting</category><body package="Store-Database" selector="collectOpenBrowsers">collectOpenBrowsers	"We need protected binding references here because the classes in question come later in load order."	| browsers |	browsers := OrderedCollection new.	#{Store.Glorp.StoreRefactoringBrowser} bindingOrNil		ifNotNil: [:binding | browsers addAll: binding value allInstances].	#{Store.Glorp.DefinitionForListTool} bindingOrNil		ifNotNil: [:binding | browsers addAll: binding value allInstances].	^browsers select: [:each | each mainWindow notNil and: [each mainWindow isOpen]]</body><body package="Store-Database" selector="connectTo:">connectTo: aProfile	| glorpSession |	aProfile isConnectable ifFalse:		[self isOnline: false.		StoreWarning			raiseSignal:				(#UnableToConnectToPresentInTheImage &lt;&lt; #store &gt;&gt; 'Unable to connect to "&lt;1s&gt;" because the database driver class&lt;n&gt;"&lt;2s&gt;" is not present in the image.'					expandMacrosWith: aProfile displayString					with: aProfile driverClassName).			^false].	self isConnected ifTrue: [self disconnect].	connection := aProfile asConnection.	glorpSession := [connection connect: aProfile password.			Store.Glorp.StoreLoginFactory				currentStoreSessionFromProfile: aProfile				andItsConnection: connection]		on: Error		do:			[:exception | 			(StoreDescriptorSystem userInputlExceptionsToIgnore includes: exception class) ifTrue: [exception pass].			self isOnline: false.			StoreWarning raiseSignal:				(#UnableToConnectToLlowingErrorN2s &lt;&lt; #store &gt;&gt; 'Unable to connect to "&lt;1s&gt;" because of the following error:&lt;n&gt;&lt;2s&gt;'					expandMacrosWith: aProfile displayString					with: (exception messageText isEmpty ifTrue: [exception defaultMessageText] ifFalse: [exception messageText])).			exception return: nil].	glorpSession isNil ifTrue: [^false].	self		isOnline: true;		storeBroker: connection storeBroker;		updateTablePrefix: aProfile tableOwner;		updateDatabaseIdentifierTo: glorpSession system databaseIdentifier.	self checkForUpdates ifFalse: [^self goOffLine].	self connectedProfileHolder value: aProfile.	recentProfile := aProfile.	self isOnline ifTrue: [self announce: StoreConnect].	^self isOnline</body><body package="Store-Database" selector="disconnect">disconnect	self handleDisconnectWithOpenBrowsers ifFalse: [^self].	self announce: StoreDisconnect.	self isOnline: false.	self closeConnection.	self connectedProfileHolder value: nil</body><body package="Store-Database" selector="handleDisconnectWithOpenBrowsers">handleDisconnectWithOpenBrowsers	"Allow user to terminate disconnect request if there are any open Store Browsers.	 If the user confirms the disconnect request, proactively terminate any open Store Browsers."	| answer openBrowsers |	(openBrowsers := self collectOpenBrowsers) isEmpty ifTrue: [^true].	(answer := Dialog				confirm: (#DisconnectingWithOpenBrowsers &lt;&lt; #store						&gt;&gt; 'There are open Store Browser windows connected to the database with content which will become obsolete.&lt;n&gt;Disconnecting will close these browser windows.  Do you want to continue?')							expandMacros				for: Dialog defaultParentWindow)			ifTrue: [openBrowsers do: [:ea | ea terminateBrowser]].	^answer</body><body package="Store-Database" selector="restoreConnection">restoreConnection	self isConnected ifTrue: [^self].	self closeConnectionIfNewOrPaused.	connection isNil 		ifTrue: 			[| profile |			profile := ConnectionDialog chooseProfileInitially: recentProfile.			[profile isNil ifTrue: [self disconnect] ifFalse: [self connectTo: profile]] 				ifCurtailed: [self disconnect]].	^self isConnected</body></methods><methods><class-id>Store.DBAccess</class-id> <category>private-accessing</category><body package="Store-Database" selector="brokerOrNil">brokerOrNil	"Use storeBroker in all cases where nil is not an acceptable response."	^storeBroker</body><body package="Store-Database" selector="currentDatabaseAccessor">currentDatabaseAccessor	^currentDatabaseAccessor</body><body package="Store-Database" selector="isThereAnyTableInstalled">isThereAnyTableInstalled" This method is used only to prevent the database identifier request if there is no tables installed"	^[self storeBroker processSQL: 		((self storeBroker newSQLFor: Package)			selectAll;			where;			column: #primaryKey equalTo: '1').	true	] 	on: Error do: [ :ex | false ]</body><body package="Store-Database" selector="nilOutConnection">nilOutConnection	"self nilOutConnection"	"This method is sent when we cannot close connection, 	and we can do is to nuke them."	self resetSessions.	connection notNil 		ifTrue:			[connection nilParams.			connection := nil].</body><body package="Store-Database" selector="resetDatabaseIdentifier">resetDatabaseIdentifier		self databaseIdentifier: nil.	[(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: nil] 		on: Error 		do: [:exception | ]</body><body package="Store-Database" selector="resetSequenceGeneratorSessions">resetSequenceGeneratorSessions	"Reset all the session used to generate the primary keys."	DBObject withAllSubclasses do: [:x | x resetSequenceGeneratorSession]</body><body package="Store-Database" selector="resetSessions">resetSessions	DBObject resetSession.	Package resetSessions.	Store.Glorp.StorePackage initializeCache.	Store.Glorp.StoreBundle initializeCache.	Record resetPrimaryKeySessions.	DbRegistry resetSequenceGeneratorSessions.	cachedNames := nil.	highestPrimaryKeyChecked := nil.</body><body package="Store-Database" selector="showYouNeedToUpdateDatabaseDialog">showYouNeedToUpdateDatabaseDialog		^Dialog		warn:			(#TtYouNeedToUpdateStallFromLogWindow &lt;&lt; #store &gt;&gt;					'&lt;tt&gt;You need to update your database.&lt;n&gt;Please, ask DBA to evaluate (Do It) the expression:&lt;nt&gt;"Store.DbRegistry update5i2".&lt;n&gt;&lt;tt&gt; or if you just install database using installation script &lt;n&gt; run PostInstall from Log Window')				expandMacros</body><body package="Store-Database" selector="storeDescriptorSystems">storeDescriptorSystems	^storeDescriptorSystems</body><body package="Store-Database" selector="updateDatabaseIdentifier:">updateDatabaseIdentifier: repositoryShouldHaveIdentifier	"Update the database identifier from information held in the repository. 	If repositoryShouldHaveIdentifier is false, just ignore (swallow) exceptions."		| identifierString |	self deprecated: #(#initial '5i' #obsolete '7.8' #use '#updateDatabaseIdentifierTo: aString').	[identifierString := (StoreObject databaseIdentifier) asString.	self databaseIdentifier: identifierString.	(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: identifierString]		on: Error		do:			[:exception | 			repositoryShouldHaveIdentifier ifTrue: [exception pass]]</body><body package="Store-Database" selector="updateDatabaseIdentifierTo:">updateDatabaseIdentifierTo: aString	"Update the database identifier from information held in the repository. 	If repositoryShouldHaveIdentifier is false, just ignore (swallow) exceptions."		self databaseIdentifier: aString asString.	(Store.StoreSettings preferenceModelFor: #databaseIdentifier) value: aString</body><body package="Store-Database" selector="updateTablePrefix:">updateTablePrefix: aString		self tablePrefix: aString.	(Store.StoreSettings preferenceModelFor: #tablePrefix) value: aString</body></methods><methods><class-id>Store.DBAccess</class-id> <category>privileged-connecting</category><body package="Store-Database" selector="closeConnection">closeConnection	"Close and forget the datebase connection if it exists."	"DbRegistry closeConnection"	connection notNil ifTrue: 		[self resetSessions.		[connection disconnect] 			on: Error			do: 				[:ex | 				Transcript cr; show: ex description.				ex return].		connection := nil].	currentDatabaseAccessor := nil</body><body package="Store-Database" selector="closeConnectionIfNewOrPaused">closeConnectionIfNewOrPaused	connection notNil 		ifTrue: 			[(connection state == #paused or: [connection state == #new]) 				ifTrue: [self closeConnection]]</body><body package="Store-Database" selector="connection">connection	"Connection disconnect. Connection := nil. Session := nil"	self closeConnectionIfNewOrPaused.	connection isNil ifTrue: [self restoreConnection].	^connection</body><body package="Store-Database" selector="connection:">connection: aDbConnection		connection := aDbConnection.</body><body package="Store-Database" selector="connectionOrNil">connectionOrNil	self closeConnectionIfNewOrPaused.	connection == nil ifTrue: [self goOffLine].	^connection</body><body package="Store-Database" selector="goOffLine">goOffLine	"This message is used when we want to go off line."	"self goOffLine"	self disconnect.	^self isOnline</body><body package="Store-Database" selector="goOnLine">goOnLine	"This message is used when we want to go back on line."	"self goOnLine"	self isOnline: true.	[ self connection ]		ensure: 	[ self isOnline: ( self  isConnectionAlive ) ]</body><body package="Store-Database" selector="reconnect">reconnect	"Reconnect to the same database we were connnected to."	self closeConnectionIfNewOrPaused.	[ self connectTo: recentProfile ]		ifCurtailed: [ self disconnect ].	^self isConnected.</body><body package="Store-Database" selector="reconnect:">reconnect: storeTablesShouldExist		self goToScript ifTrue: [^nil].	self setConnection.	connection notNil		ifTrue:			[self isOnline: true.			self updateDatabaseIdentifier: storeTablesShouldExist.			storeTablesShouldExist ifTrue: [self checkForUpdates]]		ifFalse: [self isOnline: false].	^self isOnline</body><body package="Store-Database" selector="setConnection">setConnection	self resetSessions.	self disconnect.	connection := ConnectionDialog connection.	self storeBroker: 		( connection == nil			ifTrue: [ nil ]			ifFalse: [ connection storeBroker ]		).</body></methods><methods><class-id>Store.DBAccess</class-id> <category>testing</category><body package="Store-Database" selector="is73Enabled">is73Enabled	^( DbRegistry isDb73Enabled ) &amp; ( DbRegistry isImage73Enabled )</body><body package="Store-Database" selector="isConnected">isConnected	^connectedProfileHolder value notNil</body><body package="Store-Database" selector="isConnectionAlive">isConnectionAlive	"Checks if at this moment we are connected to the database."	"self isConnectionAlive"	^connection notNil</body><body package="Store-Database" selector="isConnectionConnected">isConnectionConnected	"Checks if at this moment we are connected to the database."	"self isConnectionAlive"	^self isConnected and: [self isConnectionAlive]</body><body package="Store-Database" selector="isConnectionFullyAvailable">isConnectionFullyAvailable	^[StoreObject databaseIdentifier.	true]		on: Error		do: 			[:exception | 			exception return: false].</body><body package="Store-Database" selector="isDb73Enabled">isDb73Enabled	^#{Store.Properties} 		ifDefinedDo: [ :cls | cls tableExists.]		elseDo: [ false ]</body><body package="Store-Database" selector="isImage73Enabled">isImage73Enabled	^#{Store.FileRecord} isDefined.</body><body package="Store-Database" selector="isOnline">isOnline	isOnline isNil ifTrue: [isOnline := false].	^isOnline</body><body package="Store-Database" selector="isOnlineImage">isOnlineImage		"Answer true if we are attached to the database."	^self isOnline</body><body package="Store-Database" selector="useAnalysisLoader">useAnalysisLoader	^self class useAnalysisLoader</body><body package="Store-Database" selector="useAnalysisLoader:">useAnalysisLoader: aBoolean	self class useAnalysisLoader: aBoolean</body></methods><methods><class-id>Store.DBAccess</class-id> <category>announcements</category><body package="Store-Database" selector="subscriptionRegistry:">subscriptionRegistry: anObject		subscriptionRegistry := anObject</body><body package="Store-Database" selector="subscriptionRegistryOrNil">subscriptionRegistryOrNil	^subscriptionRegistry</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>class initialization</category><body package="Store-Database" selector="initialize">initialize	"Need only be executed on first installation or on change in definition."	"self initialize"	DbRegistry := DbRegistry == nil		ifTrue: [ self new ]		ifFalse: [ self new cloneFrom: DbRegistry ].	"Make myself dependent on ObjectMemory so I'm	notified when the image returns from snapshot."	( ExternalDatabaseConnection dependents includes: self )		ifFalse:	[ ExternalDatabaseConnection addDependent: self ]</body><body package="Store-Database" selector="obsolete">obsolete	"Remove dependancies"	ExternalDatabaseConnection removeDependent: self.	super obsolete.</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>private</category><body package="Store-Database" selector="update:with:from:">update: anAspect with: arguments from: anObject 	anAspect == #returnFromSnapshot ifTrue: 		[DbRegistry resetSessions.		DbRegistry resetSystemDescriptorDictionary]</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>instance creation</category><body package="Store-Database" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>accessing</category><body package="Store-Database" selector="currentlyNotConnectedSignal">currentlyNotConnectedSignal	^LostConnectionError</body><body package="Store-Database" selector="errorSignals">errorSignals	^self currentlyNotConnectedSignal</body><body package="Store-Database" selector="useAnalysisLoader">useAnalysisLoader	UseAnalysisLoader ifNil: [#{UseAnalysisLoader} initialize].	^UseAnalysisLoader</body><body package="Store-Database" selector="useAnalysisLoader:">useAnalysisLoader: aBoolean	UseAnalysisLoader := aBoolean</body><body package="Store-Database" selector="useAtomicLoader">useAtomicLoader	UseAtomicLoader ifNil: [#{UseAtomicLoader} initialize].	^UseAtomicLoader</body><body package="Store-Database" selector="useAtomicLoader:">useAtomicLoader: aBoolean	UseAtomicLoader := aBoolean</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>private</category><body package="Store-UI" selector="connectTo:">connectTo: aProfile	Cursor wait showWhile: [DbRegistry connectTo: aProfile]</body><body package="Store-UI" selector="connectToMessageTextFor:">connectToMessageTextFor: aProfile	^(#repmanConnectToProfile &lt;&lt; #labels &gt;&gt; 'Connect to &lt;1s&gt;')		expandMacrosWith: (self labelForProfile: aProfile)</body><body package="Store-UI" selector="connectToNew">connectToNew	self disconnect.	DbRegistry restoreConnection</body><body package="Store-UI" selector="currentRepositoryLabel">currentRepositoryLabel	| connectedProfile |	connectedProfile := DbRegistry connectedProfile.	^connectedProfile isNil 		ifTrue: [#repmanNotConnected &lt;&lt; #labels &gt;&gt; 'Not connected']		ifFalse: [self labelForProfile: connectedProfile]</body><body package="Store-UI" selector="disconnect">disconnect	Cursor wait showWhile: [DbRegistry disconnect]</body><body package="Store-UI" selector="disconnectFromMessageTextFor:">disconnectFromMessageTextFor: aProfile	^(#repmanDisconnectFrom &lt;&lt; #labels &gt;&gt; 'Disconnect from &lt;1s&gt;')		expandMacrosWith: (self labelForProfile: aProfile)</body><body package="Store-UI" selector="installLabelController">installLabelController	| controller |	controller := ControllerWithSelectMenu new.	controller		selectMenuHolder: [self repositoryListMenu];		menuHolder: [self repositoryMenu];		performer: self.	(self widgetAt: #label) controller: controller</body><body package="Store-UI" selector="isConnected">isConnected	^DbRegistry connectedProfileHolder value notNil</body><body package="Store-UI" selector="isConnectedProfileRegistered">isConnectedProfileRegistered	^RepositoryManager repositories includes: DbRegistry connectedProfile</body><body package="Store-UI" selector="labelForProfile:">labelForProfile: connectedProfile 	| label |	label := connectedProfile name.	(label notNil and: [label notEmpty]) ifTrue: [^label].	label := connectedProfile environment.	(label notNil and: [label notEmpty]) ifTrue: [^label].	^(#aRepository &lt;&lt; #labels &gt;&gt; 'a Repository') asString</body><body package="Store-UI" selector="storeIcon">storeIcon	^GeneralIcons repository</body><body package="Store-UI" selector="updateRepositoryLabel">updateRepositoryLabel	self labelHolder value: self currentRepositoryLabel</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>actions</category><body package="Store-UI" selector="openRepositoryManager">openRepositoryManager	RepositoryManager open</body><body package="Store-UI" selector="repositoryExport">repositoryExport	RepositoryManager saveRepositoriesToFile</body><body package="Store-UI" selector="repositoryImport">repositoryImport	RepositoryManager importRepositoriesFromFile</body><body package="Store-UI" selector="repositoryMoreRecentlyPublishedItems">repositoryMoreRecentlyPublishedItems	DbRegistry doIfOnlineImage: 		[[Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItems] withStoreFeedbackOn: self mainWindow]</body><body package="Store-UI" selector="repositoryNew">repositoryNew	RepositoryManager addProfileFromUser</body><body package="Store-UI" selector="repositoryProperties">repositoryProperties	DbRegistry connectedProfileHolder value ifNotNil:		[:selection |		RepositoryPropertiesDialog openOn: selection.		RepositoryManager updateRepository: selection]</body><body package="Store-UI" selector="repositoryPublishedItems">repositoryPublishedItems	DbRegistry 		doIfOnlineImage: [Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundles]</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>menu building</category><body package="Store-UI" selector="createConnectOrDisconnectItemFor:">createConnectOrDisconnectItemFor: aProfile 	| item |	item := MenuItem labeled:		(aProfile isConnected 			ifTrue: [self disconnectFromMessageTextFor: aProfile]			ifFalse: [self connectToMessageTextFor: aProfile]).	item value: (aProfile isConnected 				ifTrue: [[:controller | self disconnect]]				ifFalse: [[:controller | self connectTo: aProfile]]).	aProfile isConnected ifTrue:		[item labelImage: self storeIcon].	^item</body><body package="Store-UI" selector="createConnectToNewItem">createConnectToNewItem	^(MenuItem labeled: #repmanConnectToNew &lt;&lt; #labels &gt;&gt; 'Connect to...')		value: [:controller | self connectToNew];		yourself</body><body package="Store-UI" selector="disablePropertiesIn:">disablePropertiesIn: aMenu	(aMenu atNameKey: #repositoryProperties) disable</body><body package="Store-UI" selector="disableRepositoryItemsIn:">disableRepositoryItemsIn: aMenu	#(repositoryPublishedItems repositoryMoreRecentlyPublishedItems repositoryProperties) do:		[:each | 	(aMenu atNameKey: each) disable]</body><body package="Store-UI" selector="repositoryListMenu">repositoryListMenu	| menu repositories currentlyConnected |	menu := Menu new.	repositories := RepositoryManager repositories asSortedCollection: [:a :b | (a name ifNil: ['']) &lt; (b name ifNil: [''])].	currentlyConnected := DbRegistry connectedProfile.	currentlyConnected notNil ifTrue:		[(repositories includes: currentlyConnected) ifFalse:			[menu				addItem: (self createConnectOrDisconnectItemFor: currentlyConnected);				addLine]].	repositories do: 		[:each | menu addItem: (self createConnectOrDisconnectItemFor: each)].	menu 		addLine;		addItem: self createConnectToNewItem.	^menu</body><body package="Store-UI" selector="repositoryMenu">repositoryMenu	| menu |	menu := self class repositoryMenu.	self isConnected 		ifFalse: [self disableRepositoryItemsIn: menu]		ifTrue: [self isConnectedProfileRegistered			ifFalse: [self disablePropertiesIn: menu]].	^menu</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	"Hack to enable loading."	DbRegistry ifNil: [^self].	DbRegistry connectedProfileHolder		onChangeSend: #connectedProfileChanged		to: self.	self connectedProfileChanged</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder 	self installLabelController</body><body package="Store-UI" selector="preBuildWith:">preBuildWith: aBuilder 	super preBuildWith: aBuilder.	aBuilder visualAt: #storeIcon put: self storeIcon</body><body package="Store-UI" selector="release">release	super release.	DbRegistry connectedProfileHolder ifNotNil: 		[:valueHolder | valueHolder retractInterestsFor: self]</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>notifications</category><body package="Store-UI" selector="connectedProfileChanged">connectedProfileChanged	self updateRepositoryLabel</body><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self release.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>aspects</category><body package="Store-UI" selector="labelHolder">labelHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^labelHolder isNil		ifTrue:			[labelHolder := String new asValue]		ifFalse:			[labelHolder]</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>fileIn/Out</category><body package="Store-UI" selector="prerequisitesForLoading">prerequisitesForLoading	^(super prerequisitesForLoading)		add: DBAccess;		yourself</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"Hack to enable loading into a fresh image."	VisualLauncherToolDock instanceMethodsChanged</body></methods><methods><class-id>Store.PseudoDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="hasBothDefinitions">hasBothDefinitions	^mainPackage notNil and: [otherPackage notNil]</body><body package="Store-Difference Management" selector="hasMainDifferences">hasMainDifferences	^mainObject notNil</body><body package="Store-Difference Management" selector="hasOnlyMainDefinition">hasOnlyMainDefinition	^mainPackage notNil and: [otherPackage isNil]</body><body package="Store-Difference Management" selector="hasOnlyOtherDefinition">hasOnlyOtherDefinition	^mainPackage isNil and: [otherPackage notNil]</body><body package="Store-Difference Management" selector="hasOtherDifferences">hasOtherDifferences	^otherObject notNil</body><body package="Store-Difference Management" selector="isBundleStructureOnly">isBundleStructureOnly	^false</body><body package="Store-Difference Management" selector="isClass">isClass	^false</body><body package="Store-Difference Management" selector="isClassExtension">isClassExtension	^false</body><body package="Store-Difference Management" selector="isExtensionInMain">isExtensionInMain	^mainObject isNil</body><body package="Store-Difference Management" selector="isExtensionInOther">isExtensionInOther	^otherObject isNil</body><body package="Store-Difference Management" selector="isForSharedVariable">isForSharedVariable	^false</body><body package="Store-Difference Management" selector="isMeta">isMeta	^false</body><body package="Store-Difference Management" selector="isMetaMethod">isMetaMethod	^self isMethod and: [self isMeta]</body><body package="Store-Difference Management" selector="isMethod">isMethod	^false</body><body package="Store-Difference Management" selector="isNamespace">isNamespace	^false</body><body package="Store-Difference Management" selector="isNamespaceExtension">isNamespaceExtension	^false</body><body package="Store-Difference Management" selector="isNotMeta">isNotMeta	^self isMeta not</body><body package="Store-Difference Management" selector="isProperty">isProperty	^false</body><body package="Store-Difference Management" selector="isPropertyDifference">isPropertyDifference	^false</body><body package="Store-Difference Management" selector="isShared">isShared	^false</body><body package="Store-Difference Management" selector="isStandin">isStandin	^false</body></methods><methods><class-id>Store.PseudoDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="differenceName">differenceName	^self classListName</body><body package="Store-Difference Management" selector="firstTextFragments">firstTextFragments	| text |	text := self mainDefinition asText.	^text smalltalkOrWordAndWhitespaceFragments</body><body package="Store-Difference Management" selector="mainObject">mainObject	^mainObject</body><body package="Store-Difference Management" selector="mainObject:">mainObject: anObject	mainObject := anObject</body><body package="Store-Difference Management" selector="mainPackage">mainPackage	^mainPackage</body><body package="Store-Difference Management" selector="mainPackage:">mainPackage: anObject	mainPackage := anObject</body><body package="Store-Difference Management" selector="mainPackage:object:">mainPackage: aPackage object: anObject	mainPackage := aPackage.	mainObject := anObject</body><body package="Store-Difference Management" selector="notDefinedInThisPackage">notDefinedInThisPackage	^Text new</body><body package="Store-Difference Management" selector="otherObject">otherObject	^otherObject</body><body package="Store-Difference Management" selector="otherObject:">otherObject: anObject	otherObject := anObject</body><body package="Store-Difference Management" selector="otherPackage">otherPackage	^otherPackage</body><body package="Store-Difference Management" selector="otherPackage:">otherPackage: anObject	otherPackage := anObject</body><body package="Store-Difference Management" selector="otherPackage:object:">otherPackage: aPackage object: anObject	otherPackage := aPackage.	otherObject := anObject</body><body package="Store-Difference Management" selector="secondTextFragments">secondTextFragments	| text |	text := self otherDefinition asText.	^text smalltalkOrWordAndWhitespaceFragments</body></methods><methods><class-id>Store.PseudoDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	self subclassResponsibility</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	self subclassResponsibility</body></methods><methods><class-id>Store.PseudoDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:">mainPackage: aPackage	| instance |	instance := self new.	^instance 		mainPackage: aPackage;		yourself</body><body package="Store-Difference Management" selector="otherPackage:">otherPackage: aPackage	| instance |	instance := self new.	^instance 		otherPackage: aPackage;		yourself</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="isMeta">isMeta	^true</body><body package="Store-Difference Management" selector="isMethod">isMethod	^true</body><body package="Store-Difference Management" selector="isNotMeta">isNotMeta	^true</body><body package="Store-Difference Management" selector="isPropertyDifference">isPropertyDifference	^true</body><body package="Store-Difference Management" selector="isStandin">isStandin	^true</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="differenceName">differenceName	(mainObject notNil and: [mainObject key = #structure]) ifTrue: [^(#BracketBundleStructureBracket &lt;&lt; #store &gt;&gt; '[Bundle Structure]') asString].	^self selectorListName</body><body package="Store-Difference Management" selector="mainDefinition">mainDefinition	^(mainObject isNil		ifTrue: ['']		ifFalse: 			[ | stream |			stream := WriteStream on: String new.			mainObject value storeOn: stream.			stream contents]) asText</body><body package="Store-Difference Management" selector="mainPackage:property:">mainPackage: aPackage property: anAssociation	self mainPackage: aPackage object: anAssociation</body><body package="Store-Difference Management" selector="mainProtocol">mainProtocol	^''</body><body package="Store-Difference Management" selector="otherDefinition">otherDefinition	^(otherObject isNil		ifTrue: ['']		ifFalse: 			[ | stream |			stream := WriteStream on: String new.			otherObject value storeOn: stream.			stream contents]) asText</body><body package="Store-Difference Management" selector="otherPackage:property:">otherPackage: aPackage property: anAssociation	self otherPackage: aPackage object: anAssociation</body><body package="Store-Difference Management" selector="otherProtocol">otherProtocol	^''</body><body package="Store-Difference Management" selector="resolutionClass">resolutionClass	(mainObject notNil and: [mainObject key = #structure]) ifTrue: [^BundleStructureResolver].	^PropertyChangeResolver</body><body package="Store-Difference Management" selector="selectorListIcon">selectorListIcon	^String toolListIcon</body><body package="Store-Difference Management" selector="selectorListName">selectorListName	^otherObject 		ifNil: [mainObject key]		ifNotNil: [otherObject key]</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	aStream		component: #package 		named: mainPackage name		property: mainObject key		value: mainObject value</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	aStream		component: #package 		named: otherPackage name		property: otherObject key		value: otherObject value</body></methods><methods><class-id>Store.PseudoPropertyDifference</class-id> <category>loading</category><body package="Store-Difference Management" selector="loadMainDefinitionFrom:">loadMainDefinitionFrom: aStoreClassOrNamepace	mainPackage storeModel propertyAt: mainObject key put: mainObject value</body><body package="Store-Difference Management" selector="loadOtherDefinitionFrom:">loadOtherDefinitionFrom: aStoreClassOrNamepace	otherPackage storeModel propertyAt: otherObject key put: otherObject value</body></methods><methods><class-id>Store.PseudoPropertyDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:property:">mainPackage: aPackage property: anAssociation	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: anAssociation;		yourself</body><body package="Store-Difference Management" selector="otherPackage:property:">otherPackage: aPackage property: anAssociation	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: anAssociation;		yourself</body></methods><methods><class-id>Store.BasicPublishPolicy</class-id> <category>publishing</category><body package="Store-User Management" selector="basicCanPublish:atBlessing:">basicCanPublish: aPundle atBlessing: aBlessing	^Policies blessingPolicy basicCanPublish: aPundle atBlessing: aBlessing</body><body package="Store-User Management" selector="objectionsToPublishingBundle:atBlessingLevel:">objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may 	not be published.  Return nil if it may."	^Policies blessingPolicy objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel</body><body package="Store-User Management" selector="objectionsToPublishingPackage:atBlessingLevel:">objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^Policies blessingPolicy objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel</body><body package="Store-User Management" selector="objectionsToPublishingParcel:atBlessingLevel:">objectionsToPublishingParcel: aParcel  atBlessingLevel: aLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^Policies blessingPolicy objectionsToPublishingParcel: aParcel  atBlessingLevel: aLevel</body><body package="Store-User Management" selector="objectionsToPublishingPundle:atBlessingLevel:">objectionsToPublishingPundle: aPundle atBlessingLevel: aLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^Policies blessingPolicy objectionsToPublishingPundle: aPundle atBlessingLevel: aLevel</body></methods><methods><class-id>Store.BasicPublishPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="allowBinaryLoading">allowBinaryLoading	allowBinaryLoading == nil		ifTrue: [ allowBinaryLoading := true ].	^allowBinaryLoading</body><body package="Store-User Management" selector="allowBinaryLoading:">allowBinaryLoading: aBoolean	allowBinaryLoading := aBoolean</body><body package="Store-User Management" selector="allowOverridesWithinBundles">allowOverridesWithinBundles	allowOverridesWithinBundles isNil ifTrue: [allowOverridesWithinBundles := true].	^allowOverridesWithinBundles.</body><body package="Store-User Management" selector="allowOverridesWithinBundles:">allowOverridesWithinBundles: aBoolean	allowOverridesWithinBundles := aBoolean</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="leftMethod:rightMethod:">leftMethod: aLeftMethodBlueprint rightMethod: aRightMethodBlueprint	leftMethod := aLeftMethodBlueprint.	rightMethod := aRightMethodBlueprint.	self populate</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>row population</category><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	| rows |	rows := OrderedCollection new.	leftMethod packageName = rightMethod packageName		ifFalse: 			[rows add: ((self newRow)						add: ComparisonIcons movePackage;						add: (self italicizedText: 'Package');						add: 'changed from';						add: leftMethod packageName asText allBold;						add: 'to';						add: rightMethod packageName asText allBold;						yourself)].	leftMethod category = rightMethod category		ifFalse: 			[rows add: ((self newRow)						add: ComparisonIcons moveCategory;						add: (self italicizedText: 'Category');						add: 'changed from';						add: leftMethod category asText allBold;						add: 'to';						add: rightMethod category asText allBold;						yourself)].	leftMethod source = rightMethod source		ifFalse: 			[rows				add: (SideBySideTextComparisonView new leftText: leftMethod sourceText						rightText: rightMethod sourceText)].	^rows</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| header icons |	super populateHeader.	header := self header.	icons := Panel new beRow: 0.5.	leftMethod source = rightMethod source		ifFalse: [icons add: ComparisonIcons modify].	leftMethod category = rightMethod category		ifFalse: [icons add: ComparisonIcons moveCategory].	leftMethod packageName = rightMethod packageName		ifFalse: [icons add: ComparisonIcons movePackage].	header add: icons.	header add: (Label with: leftMethod selectorDisplayText).	header add: self moreInfoTooltipHandle</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="openMethodVersions">openMethodVersions	| selections |	selections := Set new.	self leftStoreMethod		ifNotNil: [:storeMethodInPackage | selections add: storeMethodInPackage definition].	self rightStoreMethod		ifNotNil: [:storeMethodInPackage | selections add: storeMethodInPackage definition].	self openMethodVersions: selections</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>testing</category><body package="Store-Code Comparison" selector="canRevertFrom:to:">canRevertFrom: anImageMethodDefinition to: aStoreMethodInPackage	aStoreMethodInPackage		ifNotNil: 			[:storeMethodInPackage |			anImageMethodDefinition				ifNotNil: 					[:imageMethodDefinition |					storeMethodInPackage package primaryKey = (imageMethodDefinition package								dbTraceFor: storeMethodInPackage package dbIdentifier)						ifTrue: [^true]]].	^false</body><body package="Store-Code Comparison" selector="hasMenu">hasMenu	^true</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>private</category><body package="Store-Code Comparison" selector="leftImageMethod">leftImageMethod	^self imageMethodDefinitionFrom: leftMethod</body><body package="Store-Code Comparison" selector="leftStoreMethod">leftStoreMethod	^leftMethod originalStoreObject</body><body package="Store-Code Comparison" selector="rightImageMethod">rightImageMethod	^self imageMethodDefinitionFrom: rightMethod</body><body package="Store-Code Comparison" selector="rightStoreMethod">rightStoreMethod	^rightMethod originalStoreObject</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison" selector="categoryInfoTooltipText">categoryInfoTooltipText	| output |	output := TextStream on: String new.	output		nextPutAll: (leftMethod category = rightMethod category				ifTrue: [#MethodCategoryC &gt;&gt; 'Category:' &lt;&lt; #IDE]				ifFalse: [#MethodCategoriesC &gt;&gt; 'Categories:' &lt;&lt; #IDE]) asString.	output space.	output		emphasis: #bold;		nextPutAll: leftMethod category;		emphasis: nil.	rightMethod category = leftMethod category		ifFalse: 			[output				nextPut: $/;				emphasis: #bold;				nextPutAll: rightMethod category;				emphasis: nil].	^output contents</body><body package="Store-Code Comparison" selector="packageInfoTooltipText">packageInfoTooltipText	| output |	output := TextStream on: String new.	output		nextPutAll: (leftMethod packageName = rightMethod packageName				ifTrue: [#DefinitionPackageC &gt;&gt; 'Package:' &lt;&lt; #IDE]				ifFalse: [#DefinitionPackagesC &gt;&gt; 'Packages:' &lt;&lt; #IDE]) asString.	output space.	output		emphasis: #bold;		nextPutAll: leftMethod packageName;		emphasis: nil.	rightMethod packageName = leftMethod packageName		ifFalse: 			[output				nextPut: $/;				emphasis: #bold;				nextPutAll: rightMethod packageName;				emphasis: nil].	^output contents</body><body package="Store-Code Comparison" selector="tooltipTextChunks">tooltipTextChunks	^Array with: self categoryInfoTooltipText with: self packageInfoTooltipText</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^Array		with: #compareMethods		with: leftMethod selector		with: leftMethod isInstanceBehavior</body></methods><methods><class-id>Store.Glorp.StorePundleEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="at:ifAbsent:">at: aBinding ifAbsent: aBlock	^environment at: aBinding asString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="classForName:ifAbsent:">classForName: aString ifAbsent: aBlock	"We may sometimes hand out object name wrappers but should always receive full names back from our navigator and state.  (Our code assumes that aBlock will either return or answer something that responds to #objectNamed:)"	| containingPundle theClass |	containingPundle := self pundles		detect: [:each | (each objectNamed: aString) notNil]		ifNone: aBlock.	theClass := containingPundle objectNamed: aString.	^theClass isNil ifTrue: aBlock ifFalse: [theClass]</body><body package="StoreForGlorpBrowserUI" selector="glorpSession">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI" selector="navigatorClass">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI" selector="openEditor">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI" selector="pundleNamed:isPackage:">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body><body package="StoreForGlorpBrowserUI" selector="pundles">pundles	| pundles |	pundles := OrderedCollection new.	self bundleNames collect:		[:each |		pundles add: (self environment pundleNamed: each isPackage: false)].	self packageNames collect:		[:each |		pundles add: (self environment pundleNamed: each isPackage: true)].	^pundles</body><body package="StoreForGlorpBrowserUI" selector="repositoryName">repositoryName	^environment repositoryName</body></methods><methods><class-id>Store.Glorp.StorePundleEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI" selector="classForName:">classForName: aString	^self classForName: aString ifAbsent: [nil]</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>accessing</category><body package="Store-Merge Management" selector="alternative">alternative	^alternative</body><body package="Store-Merge Management" selector="alternative:">alternative: anObject	alternative := anObject</body><body package="Store-Merge Management" selector="applied">applied	^applied</body><body package="Store-Merge Management" selector="applied:">applied: anObject	applied := anObject</body><body package="Store-Merge Management" selector="base">base	^base</body><body package="Store-Merge Management" selector="base:">base: anObject	base := anObject</body><body package="Store-Merge Management" selector="image">image	^image</body><body package="Store-Merge Management" selector="image:">image: anObject	image := anObject</body><body package="Store-Merge Management" selector="package">package	^package</body><body package="Store-Merge Management" selector="package:">package: anObject	package := anObject</body><body package="Store-Merge Management" selector="proposed">proposed	^proposed</body><body package="Store-Merge Management" selector="proposed:">proposed: anObject	proposed := anObject</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>comparing</category><body package="Store-Merge Management" selector="=">= aResolutionPackageItem	^self class = aResolutionPackageItem class and:		[self package = aResolutionPackageItem package and:		[self image = aResolutionPackageItem image and:		[self base = aResolutionPackageItem base and:		[self alternative = aResolutionPackageItem alternative]]]]</body><body package="Store-Merge Management" selector="hash">hash	^self package hash</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	base := image := proposed := applied := false</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>private</category><body package="Store-Merge Management" selector="addAndInTo:">addAndInTo: textStream		textStream		emphasis: (Array with: #bold with: #color -&gt; ColorValue red);		nextPutAll: (#and &lt;&lt; #store &gt;&gt; 'and') asString;		space;		emphasis: nil</body><body package="Store-Merge Management" selector="addDoNotApplyChangeTo:">addDoNotApplyChangeTo: textStream		textStream		emphasis: (Array with: #bold with: #color -&gt; ColorValue red);		nextPutAll: (#ThreeStars &lt;&lt; #store &gt;&gt; '***') asString;		space;		emphasis: #bold;		nextPutAll: (#DoNotApplyChange &lt;&lt; #store &gt;&gt; 'Do Not Apply Change') asString;		emphasis: (Array with: #bold with: #color -&gt; ColorValue red);		space;		nextPutAll: (#ThreeStars &lt;&lt; #store &gt;&gt; '***') asString;		emphasis: nil</body><body package="Store-Merge Management" selector="addInBaseTo:">addInBaseTo: textStream		textStream		emphasis: #bold;		nextPutAll: (#BaseColon &lt;&lt; #store &gt;&gt; 'Base:') asString;		space;		emphasis: nil</body><body package="Store-Merge Management" selector="addInImageTo:">addInImageTo: textStream		textStream		emphasis: #bold;		nextPutAll: (#ImageColon &lt;&lt; #store &gt;&gt; 'Image:') asString;		space;		emphasis: nil</body><body package="Store-Merge Management" selector="asGeneralResolution">asGeneralResolution	| instance |	instance := self copy.	instance alternative: nil.	^instance</body><body package="Store-Merge Management" selector="packageLabel">packageLabel		^package 		ifNil: [(#DashAbsentDash &lt;&lt; #store &gt;&gt; '- absent -') asString] 		ifNotNil: 			[:value | 			value pseudoPackage ifTrue: [^(#DashAbsentDash &lt;&lt; #store &gt;&gt; '- absent -') asString].			value displayString , ' ', 			(alternative isUserInputResolution				ifTrue: ['']				ifFalse: [value timeStampString])]</body><body package="Store-Merge Management" selector="populateFrom:in:">populateFrom: anAlternative in: aResolution	| inImageResolution |	alternative := anAlternative.	package := anAlternative isRemovalResolution ifTrue: [anAlternative base key] ifFalse: [anAlternative key].	aResolution proposed ifNotNil:		[aResolution proposed isNoOpResolution			ifTrue:  				[proposed := aResolution proposed = anAlternative.				applied := proposed and: [aResolution applied].				alternative = anAlternative]			ifFalse: 				[aResolution makeResolutionProposals.				anAlternative isAbsentResolution ifTrue: [alternative := nil].				anAlternative isRemovalResolution					ifTrue: 						[applied := aResolution applied and: [aResolution proposed = anAlternative].						proposed := aResolution proposed = anAlternative]					ifFalse: [	applied := (proposed := anAlternative = aResolution proposed) and: [aResolution applied]]]].	base := (anAlternative = aResolution base and: [anAlternative isRemovalResolution not]) or: [anAlternative isRemovalResolution and: [aResolution base = anAlternative]].	inImageResolution := aResolution alternatives detect: [:each | each isDoNothingResolution not and: [each key isImageObject]] ifNone: [nil].	anAlternative = inImageResolution 		ifTrue: [image := anAlternative value = inImageResolution value]		ifFalse: [image := (anAlternative = aResolution original and: [anAlternative isRemovalResolution not and: [anAlternative package isVersionLoaded]]) or: [anAlternative isRemovalResolution and: [aResolution original notNil and: [anAlternative package isVersionLoaded]]]].</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>relationships</category><body package="Store-Merge Management" selector="sortKey">sortKey	"Primary key can be nil if the underlying object is a PseudoPackage"	^self package ifNil: [-1] ifNotNil: [self package primaryKey ifNil: [-2]].</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>printing</category><body package="Store-Merge Management" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		space;		nextPut: $(;		nextPutAll: (self package ifNil: [(#DashAbsentDash &lt;&lt; #store &gt;&gt; '- absent -') asString] ifNotNil: [:value | value displayString]);		nextPut: $)</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>testing</category><body package="Store-Merge Management" selector="isAbsentResolution">isAbsentResolution	^package isNil</body><body package="Store-Merge Management" selector="isForGeneralResolution">isForGeneralResolution	^alternative isNil</body></methods><methods><class-id>Store.ResolutionPackageItem</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFrom:">definitionTextFrom: aChangeResolver	^aChangeResolver definitionTextFrom: self</body><body package="Store-Merge Management" selector="icon">icon	^applied 		ifTrue: [MergeIcons applied]		ifFalse: 			[proposed				ifTrue: [MergeIcons resolved]				ifFalse: [nil]]</body><body package="Store-Merge Management" selector="labelText">labelText		| textStream |	textStream := TextStream on: String new.	(self alternative isNil or: [self alternative isUserInputResolution not])		ifTrue:			[image ifTrue: [self addInImageTo: textStream].			(image and: [base]) ifTrue: [self addAndInTo: textStream].			base ifTrue: [self addInBaseTo: textStream]].	(self alternative notNil and: [self alternative isNoOpResolution])		ifTrue: [self addDoNotApplyChangeTo: textStream] 		ifFalse: [textStream nextPutAll: self packageLabel].	(self alternative notNil and: [self alternative isUserInputResolution])		ifTrue:			[textStream emphasis: #color -&gt; ColorValue darkGreen.			textStream nextPutAll: (#SpaceParenUserSuppliedParen &lt;&lt; #store &gt;&gt; ' (User Supplied)') asString].	^textStream contents</body><body package="Store-Merge Management" selector="selectionText">selectionText		| textStream |	textStream := TextStream on: String new.	textStream nextPutAll: self packageLabel.	^textStream contents</body></methods><methods><class-id>Store.ResolutionPackageItem class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="forAbsentBase">forAbsentBase	| instance |	instance := self new.	instance base: true.	^instance</body><body package="Store-Merge Management" selector="forAbsentBaseAndImage">forAbsentBaseAndImage	| instance |	instance := self new.	instance base: true.	instance image: true.	^instance</body><body package="Store-Merge Management" selector="forAbsentImage">forAbsentImage	| instance |	instance := self new.	instance image: true.	^instance</body><body package="Store-Merge Management" selector="new">new	^super new initialize</body><body package="Store-Merge Management" selector="on:in:">on: anAlternative in: aResolution	| instance |	instance := self new.	instance populateFrom: anAlternative in: aResolution.	^instance</body></methods><methods><class-id>Store.LoadAnalysisError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	^Dialog		chooseReport: messageText		labels: (Array with: (#OK &lt;&lt; #dialogs &gt;&gt; 'OK'))		values: (Array with: true)		default: true		for: nil</body></methods><methods><class-id>Store.LoadAnalysisError class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteName">absoluteName	^self definition absoluteName</body><body package="Store-Database Model" selector="absoluteSymbol">absoluteSymbol	^self definition absoluteSymbol</body><body package="StoreForGlorpVWUI" selector="actual">actual	^self definition actual.</body><body package="StoreForGlorpVWUI" selector="anyStoreObjectInPackage">anyStoreObjectInPackage	^self</body><body package="Store-Database Model" selector="application">application	^self package yourSelf.</body><body package="Store-Database Model" selector="bracketedVersionString">bracketedVersionString	^'(&lt;1s&gt;, &lt;2s&gt;)' expandMacrosWith: self timestamp printString with: self definition userName</body><body package="Store-Database Model" selector="browserIcon">browserIcon	^nil</body><body package="Store-Database Model" selector="definition">definition	^definition</body><body package="Store-Database Model" selector="definition:">definition: aStoreObject	definition := aStoreObject</body><body package="StoreForGlorpVWUI" selector="definitionAndComment">definitionAndComment	^self definition definitionAndComment.</body><body package="Store-Database Model" selector="definitionObject">definitionObject	^definition</body><body package="Store-Database Model" selector="definitionString">definitionString	^self definition isNil ifTrue: [''] ifFalse: [self definition definitionString].</body><body package="StoreForGlorpVWUI" selector="environmentString">environmentString	^self definition isNil ifTrue: [''] ifFalse: [self definition environmentString].</body><body package="Store-Database Model" selector="fullName">fullName	^self longName.</body><body package="Store-Database Model" selector="longName">longName	^self definition longName.</body><body package="Store-Database Model" selector="name">name	^self definition name.</body><body package="Store-Database Model" selector="package">package	^package</body><body package="Store-Database Model" selector="package:">package: aStorePackage	package := aStorePackage</body><body package="Store-Database Model" selector="prerequisitesForAtomicLoading">prerequisitesForAtomicLoading	"If we're trying to sort one of our in-database class definitions, there's not much we can do. Just return an empty list of prerequisites."	"NOTE: No User Subclass Class Should Implement This Method"	^OrderedCollection with: self</body><body package="Store-Database Model" selector="prerequisitesForLoading">prerequisitesForLoading	"If we're trying to sort one of our in-database class definitions, there's not much we can do. Just return an empty list of prerequisites."	^OrderedCollection new.</body><body package="Store-Database Model" selector="primaryKey">primaryKey	"This is important because we may hand these objects to Store with it thinking they're records for the definitions"	^self definition primaryKey.</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	^self definition source</body><body package="StoreForGlorpVWUI" selector="simpleName">simpleName	^self name</body><body package="Store-Database Model" selector="timestamp">timestamp	^self package timestamp.</body><body package="Store-Database Model" selector="value">value	^definition.</body><body package="Store-Database Model" selector="versionString">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printString with: self definition userName)</body><body package="Store-Database Model" selector="versions">versions	self subclassResponsibility</body><body package="Store-Database Model" selector="xmlDefinition">xmlDefinition	^self definition xmlDefinition</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;">&lt; aStoreObjectInPackage	^self definitionString &lt; aStoreObjectInPackage definitionString.</body><body package="Store-Database Model" selector="&lt;=">&lt;= aStoreObjectInPackage	^self definition &lt;= aStoreObjectInPackage definition.</body><body package="Store-Database Model" selector="hash">hash	^self package yourSelf hash bitXor: self definition yourSelf hash.</body><body package="Store-Database Model" selector="sourceMatches:">sourceMatches: aStoreObject	^self definition sourceMatches: aStoreObject definition.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>reconciling</category><body package="Store-Database Model" selector="unreconcile">unreconcile	self definition unreconcile.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>testing</category><body package="Store-Database Model" selector="belongsToClass">belongsToClass	^self definition belongsToClass.</body><body package="Store-Database Model" selector="isExtension">isExtension	^false</body><body package="StoreForGlorpVWUI" selector="isLoaded">isLoaded	^false.</body><body package="StoreForGlorpVWUI" selector="isPseudo">isPseudo	^false.</body><body package="Store-Database Model" selector="isStoreDefinitionInPackage">isStoreDefinitionInPackage	^true</body><body package="StoreForGlorpVWUI" selector="matchesWith:">matchesWith: aStoreMethodInPackage	^self definition = aStoreMethodInPackage definition</body><body package="Store-Database Model" selector="sameAsDBThing:">sameAsDBThing: anObject	^self = anObject.</body><body package="Store-Database Model" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version."	^self definition sameAsImage.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	package := package glorpCopyIn: aDictionary.	definition := definition glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>printing</category><body package="Store-Database Model" selector="fileOutSourceOn:">fileOutSourceOn: aSourceFileManager	self subclassResponsibility</body><body package="Store-Database Model" selector="printOn:">printOn: aStream	aStream nextPut: $(.	self definition printOn: aStream.	aStream nextPutAll: ' in '.	self package printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>private</category><body package="Store-Database Model" selector="fileOutDefinitionOn:">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	aStream sourceFormatter attributeFor: #package compute: [:ignored | self package name].	aStream sourceFormatter attributeForMethods: #package compute: [:ignored :more | self package name].	aStream storeObjectDefinition: self.</body><body package="Store-Database Model" selector="fileOutOn:">fileOutOn: aSourceFileManager		aSourceFileManager addComment: self longName.	self fileOutSourceOn: aSourceFileManager.	aSourceFileManager cr</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>displaying</category><body package="Store-Database Model" selector="fullDisplayString">fullDisplayString	^'[&lt;3s&gt;] &lt;1s&gt; &lt;2s&gt;' 		expandMacrosWith: self displayString		with: self bracketedVersionString		with: self package name</body><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self longName</body><body package="StoreForGlorpVWUI" selector="longNameWithMetaFromSmalltalk">longNameWithMetaFromSmalltalk	| index startingFromSmalltalk |	index := self classNameWithMeta findString: '.Smalltalk' startingAt: 1.	startingFromSmalltalk := self classNameWithMeta copyFrom: index + 1 to: self classNameWithMeta size.	index isZero ifTrue: [(self classNameWithMeta findString: 'Root' startingAt: 1) isZero ifFalse: [index := 1]].	index isZero ifFalse: [index := startingFromSmalltalk indexOf: $.].	^startingFromSmalltalk copyFrom: index + 1 to: startingFromSmalltalk size</body><body package="StoreForGlorpVWUI" selector="shortItemString">shortItemString	^self longNameFromSmalltalk</body><body package="StoreForGlorpVWUI" selector="text">text	^self definitionString</body><body package="StoreForGlorpVWUI" selector="timeStampString">timeStampString	^self definition timeStampString</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>converting</category><body package="Store-Database Model" selector="asStoreObjectInPackage:">asStoreObjectInPackage: aPackage	^self</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="asShadowedObjectIn:">asShadowedObjectIn: aPackage	| instance |	instance := self shadowedObjectClass new.	instance from: self.	^instance</body><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	self subclassResponsibility</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StoreObjectInPackage class</class-id> <category>database utility</category><body package="Store-Database Model" selector="allPackagesContaining:">allPackagesContaining: aStoreDefinitionInPackage	^self allPackagesContaining: aStoreDefinitionInPackage in: aStoreDefinitionInPackage package session</body><body package="Store-Database Model" selector="allPackagesContaining:in:">allPackagesContaining: aStoreDefinitionInPackage in: aSession	| query session objects |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: 			[:eachObject | 			eachObject definition name = aStoreDefinitionInPackage name AND: 				[eachObject definition primaryKey = aStoreDefinitionInPackage definitionObject primaryKey]].	query alsoFetch: #definition.	query alsoFetch: [:eachObject | eachObject package].	query orderBy: [:each | each package timestamp descending].	objects := session execute: query.	^objects collect: [:each | each package]</body><body package="Store-Database Model" selector="allVersionsWithName:">allVersionsWithName: aString	^self allVersionsWithName: aString in: nil</body><body package="Store-Database Model" selector="allVersionsWithName:in:">allVersionsWithName: aString in: aSession	| query session objects uniqueKeys |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachClass | eachClass definition name = aString].	query alsoFetch: #definition.	query alsoFetch: [:eachObject | eachObject definition definition].	query orderBy: [:each | each definition timestamp descending].	objects := session execute: query.	uniqueKeys := Set new.	^objects inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:">selectStoreVersionOf: aString	"Produce a dialogue that answers a store class definitin in package object or nil."		^self selectStoreVersionOf: aString in: nil</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:in:">selectStoreVersionOf: aString in: aSession	"Produce a dialogue that answers a store class definitin in package object or nil."		^self selectStoreVersionOf: aString in: aSession warnIfNone: true</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:in:warnIfNone:">selectStoreVersionOf: aString in: aSession warnIfNone: aBoolean	"Produce a dialogue that answers a store class definitin in package object or nil."		| list session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	list := self allVersionsWithName: aString in: session.	list isEmpty ifTrue:		[aBoolean ifTrue: [Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions') asString].		^nil].	list size == 1 ifTrue: [^list first].	^Dialog		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list collect: [:each | each longNameFromSmalltalk, ' ', each definition timeStampString])		values: list		lines: 10		cancel: [^nil]		for: nil</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:warnIfNone:">selectStoreVersionOf: aString warnIfNone: aBoolean	"Produce a dialogue that answers a store class definitin in package object or nil."		^self selectStoreVersionOf: aString in: nil warnIfNone: aBoolean</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteSymbol">absoluteSymbol	^self longName asSymbol.</body><body package="Store-Code Comparison" selector="asBlueprint">asBlueprint	| definitionParts myReference blueprint |	blueprint := NamespaceBlueprint of: self.	definitionParts := blueprint parseDefinition: self definition definition.	myReference := self fullName asQualifiedReference.	blueprint reference: myReference.	blueprint isPrivate: (definitionParts at: #private:).	blueprint importsString: (definitionParts at: #imports:).	self comment ifNotNil: [:string | blueprint comment: string].	^blueprint</body><body package="Store-Database Model" selector="asNameSpace">asNameSpace	"hack"	^StoreNameSpace new</body><body package="Store-Database Model" selector="comment">comment	^self definition comment</body><body package="Store-Database Model" selector="correspondingImageNamespace">correspondingImageNamespace	^definition correspondingImageNamespace</body><body package="Store-Database Model" selector="isForClass">isForClass	^false</body><body package="StoreForGlorpBrowserUI" selector="isForGeneral">isForGeneral	^false.</body><body package="StoreForGlorpVWUI" selector="loadSrcInto:">loadSrcInto: aPackageModel	Store.Policies packagePolicy 		forcePackage: aPackageModel		while: [self definition loadSource]</body><body package="Store-Database Model" selector="organization">organization	^self definition organization</body><body package="StoreForGlorpVWUI" selector="removeFromPackage:">removeFromPackage: aPackageModel	"For adding a removal of unloaded defintions from the change sets."	Store.XMainChangeSet current		addRemoveNameSpace: self absoluteName		package: aPackageModel</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := self definition source.	insertPoint := definitionString indexOfSubCollection: 'defineNameSpace:' startingAt: 1.	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Store-Database Model" selector="versions">versions	| session query namespaces uniqueKeys |	session := StoreLoginFactory currentStoreSession.	query := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	query alsoFetch: #definition.	query alsoFetch: [:eachClass | eachClass definition definition].	query orderBy: [:each | each definition timestamp descending].	namespaces := session execute: query.	uniqueKeys := Set new.	^namespaces inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>comparing</category><body package="Store-Database Model" selector="=">= aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifFalse: 		[self isForNameSpace == aStoreObjectInPackage isForNameSpace ifFalse: [^false].		^self definition = aStoreObjectInPackage asStoreNameSpace].	^self package yourSelf = aStoreObjectInPackage package yourSelf and: [self definition reconcilesWith: aStoreObjectInPackage definition].</body><body package="Store-Database Model" selector="equalsSignatureIn:">equalsSignatureIn: aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifFalse: [		^self definition equalsSignatureIn: aStoreObjectInPackage asStoreNameSpace].	^self package yourSelf = aStoreObjectInPackage package yourSelf and: [self definition equalsSignatureIn: aStoreObjectInPackage definition].</body><body package="Store-Database Model" selector="signatureHash">signatureHash	^self definition signatureHash</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="asString">asString	^self longName</body><body package="StoreForGlorpVWUI" selector="displayString">displayString	^self name</body><body package="Store-Database Model" selector="printOutOn:">printOutOn: aStream	"Print me out on a textStream"	| saved |	saved := aStream emphasis.	aStream emphasis: #bold.	aStream nextPutAll: self definitionString.	aStream cr.	aStream emphasis: #italic.	aStream cr.	aStream nextPutAll: self comment.	aStream emphasis: saved.	aStream cr.	aStream cr</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>filing out</category><body package="Store-Database Model" selector="fileOutDifferencesBetween:on:">fileOutDifferencesBetween: aNamespaceInPackage on: aSourceCodeStream	self definitionString = aNamespaceInPackage definitionString ifFalse:		[self fileOutSourceOn: aSourceCodeStream]</body><body package="Store-Database Model" selector="fileOutObjectType">fileOutObjectType	^#nameSpace</body><body package="Store-Database Model" selector="fileOutSourceOn:">fileOutSourceOn: aSourceFileManager	aSourceFileManager storeObjectDefinition: self</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>private</category><body package="Store-Database Model" selector="fileOutOn:">fileOutOn: aSourceFileManager		super fileOutOn: aSourceFileManager.	self comment notEmpty ifTrue: [aSourceFileManager comment: self value: self comment]</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>testing</category><body package="Store-Database Model" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[[[binding := Compiler evaluate: self definitionString]				on: VariableConfirmation				do: [:exception | exception resume: false]]					on: UnhandledException					do:						[:exception | 						Store.UnloadableDefinitionError signalWith: self.						^nil].			self comment notEmpty ifTrue: [binding comment: self comment].			(self package sharedVariablesForClass: self) do: [:each | each loadSource]]</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	[[binding := Compiler evaluate: self definitionString]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: UnhandledException			do:				[:exception | 				Store.UnloadableDefinitionError signalWith: self.				^nil].	self comment notEmpty ifTrue: [binding comment: self comment].</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon		^BehaviorIcons Namespace</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>enumeration</category><body package="StoreForGlorpVWUI" selector="bindingFor:">bindingFor: aKey	self package sharedVariableWithLongName: (self longName, '.' , aKey asString)</body><body package="StoreForGlorpVWUI" selector="bindingsDo:">bindingsDo: ignore	^self</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="fullyQualifiedReference">fullyQualifiedReference	^(BindingReference simpleName: self name) home: self</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreNameSpace">asStoreNameSpace	^self definition</body></methods><methods><class-id>Store.Glorp.StoreNamespaceInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeNamespace: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedNamespaceObject</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>printing</category><body package="Store-Change Management" selector="printOn:">printOn: aStream	aStream nextPutAll: 		( (#ChangesFor1s2s3s &lt;&lt; #store &gt;&gt; 'Changes for &lt;1s&gt; (&lt;2s&gt;/&lt;3s&gt;)') expandMacrosWithArguments: 			( Array 				with: pundle1  name				with: pundle1 version				with: pundle2 version			)		)</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>private</category><body package="Store-Change Management" selector="addOtherChanges">addOtherChanges	"Add other changes to the changesets.	Ensure that we remove any property keys that are volatile or system only.  The list of 	these property keys has changed over time so there is not point tracking them."		| props1 props2 |	props1 := pundle1 propertiesForFileOut.	props2 := pundle2 propertiesForFileOut.	CodeComponent systemOnlyPropertyKeys do:		[:each | 		props1 removeKey: each ifAbsent: [nil].		props2 removeKey: each ifAbsent: [nil]].	props1 associationsDo:		[:each | 		((props2 includesKey: each key) and: [each value = (props2 at: each key)])			ifFalse:				[changeSet1 addPropertyChange: each key.				changeSet2 addPropertyChange: each key]].	props2 keysDo:		[:each | 		(props1 includesKey: each)			ifFalse:				[changeSet1 addPropertyChange: each.				changeSet2 addPropertyChange: each]].	IncrementNotification raiseSignal</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="changeSet1">changeSet1	"Answer the change set 'belonging' to  package1. That is, changes that	when applied to package2 will result in package1."	^changeSet1</body><body package="Store-Change Management" selector="changeSet2">changeSet2	"Answer the change set 'belonging' to  package2. That is, changes that	when applied to package1 will result in package2."	^changeSet2</body><body package="Store-Change Management" selector="changeSetFor:">changeSetFor: anInteger	^anInteger == 1		ifTrue: [ changeSet1 ]		ifFalse: [ changeSet2 ].</body><body package="Store-Change Management" selector="otherPackageFor:">otherPackageFor: anInteger	^anInteger == 1		ifTrue: [ pundle2 ]		ifFalse: [ pundle1 ].</body><body package="Store-Change Management" selector="otherPundleFor:">otherPundleFor: anInteger	^anInteger == 1		ifTrue: [ pundle2 ]		ifFalse: [ pundle1 ].</body><body package="Store-Change Management" selector="pundle1">pundle1	^pundle1</body><body package="Store-Change Management" selector="pundle2">pundle2	^pundle2</body><body package="Store-Change Management" selector="pundleFor:">pundleFor: anInteger	^anInteger == 1		ifTrue: [ pundle1 ]		ifFalse: [ pundle2 ].</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>initialization</category><body package="Store-Change Management" selector="fromPackageDifferences:">fromPackageDifferences: pkgDiffs	pundle1 := pkgDiffs pkgSide: 1.	pundle2 := pkgDiffs pkgSide: 2.	changeSet2 := pkgDiffs changeSet.	changeSet1 := changeSet2 reflection.	self addOtherChanges.</body><body package="Store-Change Management" selector="recurseChanges">recurseChanges	"Only required for bundles"</body><body package="Store-Change Management" selector="reflectChangesFrom:">reflectChangesFrom: changeSet	"Answer a changeSet that reflects the changes in changeSet."	^changeSet reflection.</body><body package="Store-Change Management" selector="with:parent:">with: aPackage parent: bPackage	"Initialize the receiver for comparing aPackage with bPackage where it can be assumed	that aPackage's changeset reflects all the changes between them."	pundle1 := aPackage.	pundle2 := bPackage.	changeSet1 := aPackage changeSet.	changeSet2 := self reflectChangesFrom: changeSet1.</body><body package="Store-Change Management" selector="with:with:">with: aPackage with: bPackage	"Initialize the receiver for comparing aPackage with bPackage."	pundle1 := aPackage.	pundle2 := bPackage.	changeSet1 := XChangeSet new.	changeSet2 := XChangeSet new.	( pundle1 sameVersionAs: pundle2 )		ifFalse:			[ [ self requiresFullCompare				ifTrue:					[ Notice 						showProgress:  ((#ComparingVersionsOfPackage1s &lt;&lt; #store &gt;&gt; 'Comparing versions of package &lt;1s&gt;.')											expandMacrosWith: pundle1 name)						complete: self calcItemCount 						while: [ self calculateChanges ]						title: #Reconciling &lt;&lt; #store &gt;&gt; 'Reconciling'.					]				ifFalse: [ self calculateChanges ].			  ] on: DbRegistry errorSignals do: [ :ex | ex outer ].			]</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>fileout</category><body package="Store-Change Management" selector="changedPropertiesFor:">changedPropertiesFor: id	| props all |	props := IdentityDictionary new.	all := ( self pundleFor: id ) properties.	( self changeSetFor: id ) properties do:		[ :key | props at: key put: ( all at: key ifAbsent: [ ] ) ].	^props.</body><body package="Store-Change Management" selector="fileOutChangesFor:">fileOutChangesFor: id	| fileName stream |	fileName := ( self pundleFor: id ) name.	fileName := Dialog			requestNewFileName: #FileOutChangesOn &lt;&lt; #store &gt;&gt; 'File out changes on'			default: (Filename filterFilename: fileName, '-diffs.st'). 	fileName isEmpty ifTrue: [ ^nil ].	stream := SourceCodeStream  write: fileName.	self recurseChanges.		"ensure we get the whole thing."	[ Notice 		showProgress:  ( (#FilingOut1sChanges &lt;&lt; #store &gt;&gt; 'Filing out &lt;1s&gt; changes.')  expandMacrosWith: pundle1 name )		complete: self itemCount 		while:			[ stream timeStamp. 			stream addComment: 				( (#ChangesFrom1sTo2s &lt;&lt; #store &gt;&gt; 'Changes from: &lt;1s&gt;  to: &lt;2s&gt;') 					expandMacrosWith: ( self otherPundleFor: id ) displayString 					with: ( self pundleFor: id ) displayString ).			stream deferInitializations.			self fileOutChangesFor: id on: stream.			stream finishInitializations] 		title: #Store &lt;&lt; #store &gt;&gt; 'Store'	] ensure: [ stream close ].</body><body package="Store-Change Management" selector="fileOutChangesFor:on:">fileOutChangesFor: id on: stream	self fileOutChangesFor: id within: nil on: stream</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>testing</category><body package="Store-Change Management" selector="requiresFullCompare">requiresFullCompare	"Answer true if a source code comparison is neccessary, false if a db compare is good enough."		( pundle1 isLoaded and: 			[ pundle1 hasTrace not or: [ pundle1 userWantsFullCompare ] ] 	)		ifTrue: [ ^true ].	( pundle2 isLoaded and:			[ pundle2 hasTrace not or: [ pundle2 userWantsFullCompare ] ]	)		ifTrue: [ ^true ].		^false</body></methods><methods><class-id>Store.PundleChanges class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="fromPackageDifferences:">fromPackageDifferences: pkgDiffs	^self basicNew fromPackageDifferences: pkgDiffs.</body><body package="Store-Change Management" selector="new">new	"Use #with:with: "	^self shouldNotImplement</body><body package="Store-Change Management" selector="with:parent:">with: pkg1 parent: pkg2	^self basicNew		with: pkg1 parent: pkg2;		yourself.</body><body package="Store-Change Management" selector="with:with:">with: pkg1 with: pkg2	^( pkg1 isLoaded and: [ pkg1 dbTrace == pkg2 primaryKey ] )		ifTrue: [ self  with: pkg1 parent: pkg2 ]		ifFalse: [ self basicNew with: pkg1 with: pkg2 ]</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>private</category><body package="Store-Change Management" selector="addComponentChanges">addComponentChanges	componentChanges := self compareComponents collect:		[ :array |		array first pundleChangesClass			with: array first with: array last.		]</body><body package="Store-Change Management" selector="addComponentChangesNonRecursive">addComponentChangesNonRecursive	| items1 items2 |	items1 := pundle1 	containedItems.	items2 := pundle2 	containedItems.	items1 do:		[ :pundle |		items2 detect: 			[ :i | ( i isBundle == pundle isBundle ) and: [ i name = pundle name ] ]				ifNone: 					[ changeSet1 addOtherChange: BundleModel structureMark.					changeSet2 addOtherChange: BundleModel structureMark.					]			].	items2 do:		[ :pundle |		items1 detect: 			[ :i | ( i isBundle == pundle isBundle ) and: [ i name = pundle name ] ] 				ifNone: 					[ changeSet2 addOtherChange: BundleModel structureMark.					changeSet1 addOtherChange: BundleModel structureMark.					]		].</body><body package="Store-Change Management" selector="addOtherChanges">addOtherChanges	"Add other changes to the changesets."	super addOtherChanges.	self addStructureChanges.</body><body package="Store-Change Management" selector="addStructureChanges">addStructureChanges	pundle1 structure = pundle2 structure		ifFalse:			[ changeSet1 addOtherChange: BundleModel structureMark.			changeSet2 addOtherChange: BundleModel structureMark.			].</body><body package="Store-Change Management" selector="calculateChanges">calculateChanges	self addComponentChanges.	self addOtherChanges.</body><body package="Store-Change Management" selector="calculateChangesNonRecursive">calculateChangesNonRecursive"	self addComponentChangesNonRecursive. "	self addOtherChanges.</body><body package="Store-Change Management" selector="compareComponents">compareComponents	"Compare the packages contained in the two bundles. Answer a collection of paired packages."	| diffs pdict bdict |	pdict := Dictionary new.	bdict := Dictionary new.	diffs := OrderedCollection new.	pundle2 allItems do: 		[ :pkg | pkg isPackage 					ifTrue: [ pdict at: pkg name put: pkg ]					ifFalse: [ bdict at: pkg name put: pkg ]		].	pundle1 allItems do: 		[ :pkg | 	| other dict |		dict := pkg isPackage ifTrue: [ pdict ] ifFalse: [ bdict ].		other := dict at: pkg name ifAbsent: [ PseudoPackage fromPackage: pkg ].		( other sameVersionAs: pkg )			ifFalse: [ diffs add: ( Array with: pkg with: other ) ].		dict removeKey: pkg  name ifAbsent: [ ].		].	pdict do: [ :pkg | diffs add: ( Array with: ( PseudoPackage fromPackage: pkg ) with: pkg ) ].	bdict do: [ :pkg | diffs add: ( Array with: ( PseudoPackage fromPackage: pkg ) with: pkg ) ].	^diffs</body><body package="Store-Change Management" selector="comparePackages">comparePackages	"Compare the packages contained in the two bundles. Answer a collection of paired packages."	| dict diffs |	dict := Dictionary new.	diffs := OrderedCollection new.	pundle2 allItems do: [ :pkg | dict at: pkg name put: pkg ].	pundle1 allItems do: 		[ :pkg | 	| other |		other := dict at: pkg name					ifAbsent:						[ diffs add: ( Array with: pkg with: nil ).						nil						].		other notNil			ifTrue: 				[ ( other sameVersionAs: pkg )					ifFalse: [ diffs add: ( Array with: pkg with: other ) ].				dict at: pkg name put: nil				]		].	dict do: [ :pkg | pkg notNil ifTrue: [ diffs add: ( Array with: nil with: pkg ) ] ].	^diffs</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>initialization</category><body package="Store-Change Management" selector="recurseChanges">recurseChanges	"Calculate the changes for the bundle's subcomponents. Not always neccessary."	componentChanges == nil		ifFalse: [ ^self ].	self requiresFullCompare		ifTrue: [ self addComponentChanges ]		ifFalse:			[ Notice 				showProgress:  					( (#Comparing1sWith2s &lt;&lt; #store &gt;&gt; 'Comparing &lt;1s&gt; with &lt;2s&gt;.')  							expandMacrosWith: pundle1 displayString 							with: pundle2 displayString 					 )				complete: self calcItemCount 				while: [ self addComponentChanges ]				title: #Store &lt;&lt; #store &gt;&gt; 'Store'			].</body><body package="Store-Change Management" selector="with:with:">with: aBundle with: bBundle	pundle1 := aBundle.	pundle2 := bBundle.	changeSet1 := XChangeSet new.	changeSet2 := XChangeSet new.	[ self calculateChangesNonRecursive ] 		on: DbRegistry errorSignals do: [ :ex | ex outer ].</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>fileout</category><body package="Store-Change Management" selector="fileOutChangesFor:on:">fileOutChangesFor: id on: stream	self fileOutChangesFor: id within: ( self pundleFor: id ) on: stream</body><body package="Store-Change Management" selector="fileOutChangesFor:within:on:">fileOutChangesFor: anInteger within: aBundle on: aStream		| bundle |	bundle := self pundleFor: anInteger.	componentChanges ifNotNil:		[| block |		block := [componentChanges do: [:comp | comp fileOutChangesFor: anInteger within: aBundle on: aStream]].		self requiresFullCompare			ifTrue: [block value]			ifFalse:				[Notice					showProgress: (#FilingOut1sChanges &lt;&lt; #store &gt;&gt; 'Filing out &lt;1s&gt; changes.' expandMacrosWith: pundle1 name)					complete: self itemCount					while: block					title: #Store &lt;&lt; #store &gt;&gt; 'Store']].	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[bundle fileOutProperties: (self changedPropertiesFor: anInteger) on: aStream.		((self changeSetFor: anInteger) otherChangesInclude: BundleModel structureMark) ifTrue: 			[(BundleStructureChange new component: bundle) fileOutOn: aStream]]</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="calcItemCount">calcItemCount	^self requiresFullCompare		ifTrue: 			[ componentChanges inject: componentChanges size into: 				[ :count  :cc | count + cc calcItemCount ]				]		ifFalse: [ pundle1 leafItems size * 2 + 1 ].</body><body package="Store-Change Management" selector="itemCount">itemCount	componentChanges == nil		ifTrue: [ ^1 ].	^componentChanges 		inject: componentChanges size		into: [ :count :cc | count + cc itemCount ].</body></methods><methods><class-id>Store.StoreWorkActivity</class-id> <category>accessing</category><body package="Store-Base" selector="actionText">actionText	^self subclassResponsibility</body><body package="Store-Base" selector="announce">announce	"Bullet proof announcing these things. We don't want any misbehaved clients bringing store loads to a halt."	[self class notifications announce: self] on: Error		do: 			[:ex |			Transcript				show: 'StoreWorkActivity error: ' , ex errorString;				cr]</body><body package="Store-Base" selector="codeComponent">codeComponent	^self subject</body><body package="Store-Base" selector="codeComponent:">codeComponent: anObject	self subject: anObject</body><body package="Store-Base" selector="componentName">componentName	"Assume that subject is a CodeComponent"	^self codeComponent shortItemString</body><body package="Store-Base" selector="finished">finished	self isFinished: true.	self announce</body><body package="Store-Base" selector="isFinished:">isFinished: aBoolean	isFinished := aBoolean</body><body package="Store-Base" selector="started">started	self isFinished: false.	self announce</body><body package="Store-Base" selector="subject">subject	^subject</body><body package="Store-Base" selector="subject:">subject: anObject	subject := anObject</body></methods><methods><class-id>Store.StoreWorkActivity</class-id> <category>testing</category><body package="Store-Base" selector="isComplement:">isComplement: anActivity	^self class = anActivity class and: 			[subject = anActivity codeComponent				and: [self isStarted = anActivity isFinished]]</body><body package="Store-Base" selector="isFinished">isFinished	^isFinished</body><body package="Store-Base" selector="isStarted">isStarted	^self isFinished not</body></methods><methods><class-id>Store.StoreWorkActivity</class-id> <category>initialize-release</category><body package="Store-Base" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	subject := nil.	isFinished := false.	^self</body></methods><methods><class-id>Store.StoreWorkActivity class</class-id> <category>instance creation</category><body package="Store-Base" selector="for:">for: aCodeComponent	^self new codeComponent: aCodeComponent</body><body package="Store-Base" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Store.StoreWorkActivity class</class-id> <category>announcements</category><body package="Store-Base" selector="notifications">notifications	^DefaultNotifications ifNil: [DefaultNotifications := Announcer new]</body></methods><methods><class-id>Store.Analyzing</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="actionText">actionText	^(#Analyzing &lt;&lt; #store &gt;&gt; 'Analyzing') asString</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="allItems">allItems	"Default to just me"	^Array with: self</body><body package="Store-Database Model" selector="allModifiedItems">allModifiedItems	| allItems |	allItems := self allItems.	^allItems select: [:each | each isNotLoaded]</body><body package="Store-Database Model" selector="allUniqueItems">allUniqueItems	"Answer a list of unique pundles contianed in this pundle. 	The list preserves the pundle order. 	Remove duplicates from the list."		| items present |	items := self allItems.	present := Set new: items size.	^items select:		[:each | 		| result |		result := present includes: each.		present add: each.		result not].</body><body package="Store-Database Model" selector="asStorePundle">asStorePundle	^self</body><body package="Store-Database Model" selector="basicComment">basicComment	^comment</body><body package="Store-Database Model" selector="basicComment:">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model" selector="blessings">blessings	^blessings</body><body package="Store-Database Model" selector="blessings:">blessings: aCollection	blessings := aCollection.</body><body package="Store-Database Model" selector="comment:">comment: aString	self basicComment: (StoreBlob forString: aString).</body><body package="Store-Database Model" selector="copyrightNotice">copyrightNotice	^self propertyAt: #notice ifAbsent: [nil].</body><body package="Store-Database Model" selector="currentBlessingLevel">currentBlessingLevel	^currentBlessingLevel</body><body package="Store-Database Model" selector="currentBlessingLevel:">currentBlessingLevel: anInteger	currentBlessingLevel := anInteger.</body><body package="StoreForGlorpVWUI" selector="dbIdentifier">dbIdentifier	^self session system databaseIdentifier.</body><body package="Store-Database Model" selector="deploymentPrerequisites">deploymentPrerequisites	^self properties at: #prerequisiteParcels ifAbsent: [ #() ]</body><body package="Store-Database Model" selector="developmentPrerequisites">developmentPrerequisites	^self properties at: #developmentPrerequisites ifAbsent: [#()]</body><body package="StoreForGlorpVWUI" selector="elementLabel:">elementLabel: hints 	"This method returns a visual component used to represent me in a  browser graph."	| lab |	lab := LabelAndIcon with: ( self stringKey: hints )				attributes: ( TextAttributes styleNamed: #systemDefault ).	lab icon: ( AbstractTool iconForPundle: self ).	^lab</body><body package="Store-Database Model" selector="enclosingComponents">enclosingComponents	^StoreBundle enclosingComponentsFor: self in: self session</body><body package="Store-Database Model" selector="environment">environment	^ nil</body><body package="Store-Database Model" selector="nameSpaces">nameSpaces	self subclassResponsibility.</body><body package="Store-Database Model" selector="namespaces">namespaces	self subclassResponsibility.</body><body package="Store-Database Model" selector="package">package	^self.</body><body package="Store-Database Model" selector="parentRecord">parentRecord	^self previous</body><body package="Store-Database Model" selector="parentVersionString">parentVersionString	| parentRecord |	^(parentRecord := self parentRecord) isNil		ifTrue: [''] 		ifFalse: [parentRecord version ifNil: ['']]</body><body package="Store-Database Model" selector="postLoadBlock">postLoadBlock	^self properties at: #postLoadBlock ifAbsent: [nil].</body><body package="Store-Database Model" selector="postUnloadBlock">postUnloadBlock	^self properties at: #postUnloadBlock ifAbsent: [nil].</body><body package="Store-Database Model" selector="preLoadBlock">preLoadBlock	"Dummy method template.  This was installed by the debugger	define method command."	^self properties at: #preLoadBlock ifAbsent: [nil].</body><body package="Store-Database Model" selector="preReadBlock">preReadBlock	"Dummy method template.  This was installed by the debugger	define method command."	^self properties at: #preReadBlock ifAbsent: [nil].</body><body package="Store-Database Model" selector="preSaveBlock">preSaveBlock	^self properties at: #preSaveBlock ifAbsent: [nil].</body><body package="Store-Database Model" selector="preUnloadBlock">preUnloadBlock	^self properties at: #preUnloadBlock ifAbsent: [nil].</body><body package="Store-Database Model" selector="prefetchAllFromDatabase">prefetchAllFromDatabase	"Resursively fetch all children to populate the browser environment."	self fullClasses;		nameSpaces;		sharedVariables</body><body package="Store-Database Model" selector="prerequisiteDescriptions">prerequisiteDescriptions	^(PrerequisiteDescription		descriptionsFrom: (self properties at: #prerequisiteDescriptions				ifAbsent: [nil])		orDeployment: self deploymentPrerequisites		andDevelopment: self developmentPrerequisites)			collect: [:each | each client: self]</body><body package="Store-Database Model" selector="properties">properties	properties yourSelf isNil ifTrue: [self convertProperties].	^properties.</body><body package="Store-Database Model" selector="properties:">properties: aDictionary	properties := aDictionary.</body><body package="Store-Database Model" selector="propertiesBlob">propertiesBlob	^propertiesBlob</body><body package="Store-Database Model" selector="propertiesBlob:">propertiesBlob: aStoreBlob	propertiesBlob := aStoreBlob</body><body package="Store-Database Model" selector="propertiesForFileOut">propertiesForFileOut	^self properties.</body><body package="Store-Database Model" selector="propertiesRecordDictionary">propertiesRecordDictionary	^propertiesRecordDictionary</body><body package="Store-Database Model" selector="propertiesRecordDictionary:">propertiesRecordDictionary: aDictionaryOfStoreProperty	propertiesRecordDictionary := aDictionaryOfStoreProperty</body><body package="StoreForGlorpVWUI" selector="propertiesWithoutVolatileKeys">propertiesWithoutVolatileKeys	| propertiesCopy |	propertiesCopy := self properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body><body package="Store-Database Model" selector="propertyAt:">propertyAt: aSymbol	"Answer the property at the symbol"	^properties at: aSymbol ifAbsent: nil</body><body package="Store-Database Model" selector="propertyAt:ifAbsent:">propertyAt: aKey ifAbsent: aBlock	^self properties at: aKey ifAbsent: aBlock.</body><body package="Store-Code Comparison" selector="propertyBlueprints">propertyBlueprints	| output |	output := Array new writeStream.	self propertiesWithoutVolatileKeys keysAndValuesDo: 			[:propertyName :propertyValue |			propertyName = #version				ifFalse: 					[output nextPut: ((CodeComponentPropertyBlueprint new)								codeComponent: self;								key: propertyName;								value: propertyValue)]].	^output contents</body><body package="StoreForGlorpVWUI" selector="pundleListIcon">pundleListIcon	^self storeModel ifNil: [nil] ifNotNil: [:model | model pundleListIcon].</body><body package="Store-Database Model" selector="relatedParcel">relatedParcel	"Store compatibility"	storeModel isNil ifTrue: [^nil] ifFalse: [^storeModel relatedParcel].</body><body package="StoreForGlorpVWUI" selector="selectStoreVersion">selectStoreVersion	^self selectStoreVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession.</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionIn:">selectStoreVersionIn: aSession	^self class selectStoreVersionOf: self name in: aSession</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionIn:warnIfNone:">selectStoreVersionIn: aSession warnIfNone: aBoolean	^self class selectStoreVersionOf: self name in: aSession warnIfNone: aBoolean</body><body package="Store-Database Model" selector="session">session	^session.</body><body package="Store-Database Model" selector="session:">session: aGlorpSession	session := aGlorpSession.</body><body package="Store-Database Model" selector="sharedVariables">sharedVariables	^self subclassResponsibility</body><body package="Store-Database Model" selector="simpleVersionString">simpleVersionString	"Return a string describing this version of the form (&lt;version&gt;,&lt;username&gt;)"	(version isNil and: [username isNil]) ifTrue: [^''].	^(version ifNil: [self timeStampString]) , ',' , (username ifNil: ['unknown'])</body><body package="StoreForGlorpVWUI" selector="storeModel">storeModel	storeModel isNil		ifTrue:			[storeModel := self isBundle				ifTrue: [Registry bundleNamed: self name]				ifFalse: [Registry packageNamed: self name]].	^storeModel.</body><body package="Store-Database Model" selector="storeModel:">storeModel: aPundleModel	storeModel := aPundleModel</body><body package="Store-Database Model" selector="streamDirectory">streamDirectory	"parcel loading call-back"	^nil</body><body package="Store-Database Model" selector="textForItem">textForItem	^self printString</body><body package="Store-Database Model" selector="typeStringForBlessing">typeStringForBlessing	self subclassResponsibility.</body><body package="Store-Database Model" selector="version">version	^version</body><body package="Store-Database Model" selector="version:">version: aString	version := aString.</body><body package="Store-Database Model" selector="versionComment">versionComment	^self blessings inject: String new into: [:sum :each | sum, each printString].</body><body package="Store-Database Model" selector="versionSelectionBlock">versionSelectionBlock	^self propertyAt: #versionSelectionBlock ifAbsent: [nil]</body><body package="Store-Database Model" selector="versionString">versionString	"Return a string describing this version of the form (&lt;version&gt;,&lt;username&gt;)"	(version isNil and: [username isNil]) ifTrue: [^''].	^'(' , self simpleVersionString , ')'</body><body package="Store-Database Model" selector="versionless">versionless	^versionless</body><body package="Store-Database Model" selector="versionless:">versionless: anObject	versionless := anObject</body><body package="Store-Database Model" selector="warningSuppressionBlock">warningSuppressionBlock	^self propertyAt: #warningSuppressionBlock ifAbsent: [nil].</body><body package="Store-Database Model" selector="withAllContainedItems">withAllContainedItems	^(Array with: self), self allContainedItems.</body><body package="Store-Database Model" selector="withAllItems">withAllItems	"Default to just me"	^Array with: self</body><body package="Store-Database Model" selector="withAllUniqueItems">withAllUniqueItems	"Answer a list of unique pundles contianed in this pundle. 	The list preserves the pundle order, but unlike allUniqueItems, it puts the Bundle first.	Remove duplicates from the list."		| items present |	items := self withAllItems.	present := Set new: items size.	^items select:		[:each | 		| result |		result := present includes: each.		present add: each.		result not].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>enumerating</category><body package="Store-Database Model" selector="allComponentsDo:">allComponentsDo: aBlock	self subclassResponsibility.</body><body package="Store-Database Model" selector="allVersionsWithName:">allVersionsWithName: aString	^self class allVersionsWithName: aString in: self session</body><body package="Store-Database Model" selector="allVersionsWithName:after:">allVersionsWithName: aString after: anInteger	^self class allVersionsWithName: aString after: anInteger in: self session</body><body package="Store-Database Model" selector="componentsCollect:">componentsCollect: aBlock</body><body package="Store-Database Model" selector="componentsDo:">componentsDo: aBlock</body><body package="Store-Database Model" selector="newComponentsDo:">newComponentsDo: aBlock 	"Loop over all our sub-components, but only those which are instantiated and new - that is, have no primary key"</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>loading</category><body package="StoreForGlorpVWUI" selector="asDBComponent">asDBComponent	"So that Store thinks we're something it can load from"	^self.</body><body package="Store-Database Model" selector="basicPostLoad:">basicPostLoad: aPundleModel	aPundleModel 		properties: self properties;						runComponentPostLoad</body><body package="Store-Database Model" selector="cleanOverrides">cleanOverrides	Override cleanseLists.	Override cleanseLists</body><body package="Store-Database Model" selector="directCompileAndLoad">directCompileAndLoad	self subclassResponsibility</body><body package="Store-Database Model" selector="directLoadSource">directLoadSource	"Lead method to non-atomically load the receiver.  	Ensure that the prerequisite recursion detection mechanism gets reset after the load."	Glorp.Dialect reset.	[[^self directCompileAndLoad]		on: LoadCanceled		do: 			[:exception | 			Transcript 				cr;				show: ((#LoadingOf1sHasBeenCanceled &lt;&lt; #store &gt;&gt; 'Loading of &lt;1s&gt; has been canceled') expandMacrosWith: self name)]] ensure:			[self prerequisiteRecursionReset.			self resetStoreModel.			self applyPundleVersionsToTheImage.			self cleanOverrides.			Registry cleanseModels]</body><body package="Glorp Atomic Compiling" selector="doActionEvalualtion:withArguments:for:">doActionEvalualtion: aString withArguments: args for: aDescription		| block val |	block := Cursor execute		showWhile:			[nil class evaluatorClass new				evaluate: (ReadStream on: aString asString)				in: nil				allowReceiver: false				receiver: nil				environment: CodeComponent environmentForActionBlocks				notifying: nil				ifFail:					[LoadOrSaveCompilationError raiseRequestErrorString: (Array with: self name with: aDescription).					^false]].	block numArgs == args size		ifFalse:			[LoadOrSaveInvalidArgumentsError raiseRequestErrorString: (Array with: self name with: aDescription).			^false].	[val := block valueWithArguments: args]		on: Error		do:			[:exception | 			LoadOrSaveEvaluationError raiseRequestErrorString: (Array with: self name with: aDescription).			^false].	^val ~~ false</body><body package="StoreForGlorpVWUI" selector="forceStoreConnectionDuring:">forceStoreConnectionDuring: aBlock	"Store has a lot of code that depends on, if not the current database connection, then the current database identifier. It makes it very difficult to reuse that code if we're using a different database. So instead, we explicitly disconnect the connection (which will make some things like trace code just accept that they can't get that information right now) and we force the database identifier to be the database we're using, for the duration of the operation"	| oldIdentifier wasConnected newIdentifier |	[	wasConnected := DbRegistry isConnected.	oldIdentifier := DbRegistry dbIdentifier.	newIdentifier := session system databaseIdentifier.	newIdentifier == oldIdentifier ifFalse: [		DbRegistry disconnect.		DbRegistry databaseIdentifier: newIdentifier].	aBlock value] 		ensure: [			DbRegistry databaseIdentifier: oldIdentifier.			(newIdentifier ~~ oldIdentifier) &amp; wasConnected ifTrue: [DbRegistry reconnect]].</body><body package="Store-Database Model" selector="isNotLoaded">isNotLoaded	^self asComponentDescriptionForReal isNotLoaded.</body><body package="Store-Database Model" selector="loadSource">loadSource	"Lead method to atomically load the receiver.  Ensure that the prerequisite recursion detection mechanism gets reset after the load."	^[self quietlyLoadSource] ensure: [Undeclared purgeUnusedBindings]</body><body package="Store-Database Model" selector="loadSourceWith:">loadSourceWith: aCompilationManager	"Lead method to atomically load the receiver.  Ensure that the prerequisite recursion detection mechanism gets reset after the load."		| pundleCompilerManger |	DbRegistry useAtomicLoader ifFalse: [^self directCompileAndLoad].	aCompilationManager ifNil: [^self quietlyLoadSource].	pundleCompilerManger := self defaultCompileManager root: aCompilationManager root pundle: self.	^pundleCompilerManger atomicCompileWith: aCompilationManager</body><body package="Store-Database Model" selector="loadSrc">loadSrc	"Call loadSource which now does all the dirty work"	^self loadSource</body><body package="Store-Database Model" selector="postLoad:">postLoad: aPundleModel	self basicPostLoad: aPundleModel.	ChangeSet loadPundle: self.	SourceFileManager default loadPundle: self.	Root allNameSpaces do: [:each | each organization removeEmptyCategories].</body><body package="Store-Database Model" selector="quietlyLoadSource">quietlyLoadSource	"Lead method to atomically load the receiver.  Ensure that the prerequisite recursion detection mechanism gets reset after the load."	DbRegistry useAtomicLoader		ifFalse: [^self directLoadSource].	^[[Store.DBAccess useAnalysisLoader		ifTrue: [self analyzeAndLoad]		ifFalse: [self atomicCompileAndLoad]]			on: LoadCanceled			do: 				[:exception | 				Transcript 					cr;					show: ((#LoadingOf1sHasBeenCanceled &lt;&lt; #store &gt;&gt; 'Loading of &lt;1s&gt; has been canceled') expandMacrosWith: self name)]] ensure: 		[self prerequisiteRecursionReset.		self resetStoreModel.		self applyPundleVersionsToTheImage.		Glorp.Dialect reset]</body><body package="StoreForGlorpVWUI" selector="resetStoreModel">resetStoreModel	"Our Store model will change when we load a new version. Nil ours out so that we will recalculate it if required"	storeModel := nil.</body><body package="Store-Database Model" selector="runPreLoad">runPreLoad		| action |	(action := self preLoadBlock) ifNil: [^true].	[self		unprotectedActionEvaluation: action		withArguments: (Array with: self)]		on: Error		do: [:exception | (LoadingActionError pundle: self action: #preLoad error: exception) ifFalse: [^false]].	^true</body><body package="Store-Database Model" selector="runPreRead">runPreRead		| preReadBlockAction |	(preReadBlockAction := self preReadBlock) ifNil: [^true].	(self		doActionEvalualtion: preReadBlockAction		withArguments: Array new		for: 'PreRead') ifTrue: [^true].	^PreReadActionConfirmation raiseRequestErrorString: name</body><body package="Glorp Atomic Compiling" selector="unprotectedActionEvaluation:withArguments:">unprotectedActionEvaluation: aString withArguments: args		| block |	block := Cursor execute		showWhile:			[nil class evaluatorClass new				evaluate: (ReadStream on: aString asString)				in: nil				allowReceiver: false				receiver: nil				environment: CodeComponent environmentForActionBlocks				notifying: nil				ifFail: [^Error signalWith: #CompilationError &lt;&lt; #store &gt;&gt; 'Compilation Error']].	^(block valueWithArguments: args) ~~ false</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="blessingLevel:">blessingLevel: aString	self currentBlessingLevel: aString asNumber</body><body package="StoreForGlorpVWUI" selector="blessingLevelNumber">blessingLevelNumber	^currentBlessingLevel.</body><body package="StoreForGlorpVWUI" selector="blessingLevelString">blessingLevelString	"Answer the name of my blessing.."	^Policies blessingPolicy blessingName: currentBlessingLevel.</body><body package="Store-Database Model" selector="displayString">displayString	^name, self versionString</body><body package="StoreForGlorpVWUI" selector="longItemString">longItemString	^self itemString</body><body package="Store-Database Model" selector="mergeItemString">mergeItemString	| postfix |	postfix := self isVersionLoaded				ifTrue: [' [Image]']				ifFalse: [''].	^self itemString , postfix</body><body package="Store-Merge Management" selector="printPremergeBlessingCommentHistoryOn:withLeadingCR:">printPremergeBlessingCommentHistoryOn: aStream withLeadingCR: aBoolean		aBoolean ifTrue: [aStream cr].	aStream nextPutAll: self displayString asString.	aStream cr.	(blessings select: [:blessing | blessing blessingLevel &gt;= 0])		do: [:blessing | blessing printMergeCommentHistoryOn: aStream]		separatedBy: [aStream cr]</body><body package="Store-Merge Management" selector="printPremergeCommentHistoryOn:from:withLeadingCR:">printPremergeCommentHistoryOn: aStream from: aString withLeadingCR: aBoolean		self printPremergeBlessingCommentHistoryOn: aStream withLeadingCR: aBoolean.	(self version = aString or: [self parentRecord isNil]) ifTrue: [^self].	self parentRecord 		printPremergeCommentHistoryOn: aStream 		from: aString 		withLeadingCR: true</body><body package="Store-Database Model" selector="shortItemString">shortItemString	^self name, self shortVersionString.</body><body package="StoreForGlorpVWUI" selector="stringKey:">stringKey: hints 	"A string used to represent myself in browsers, for example in a menu. The 	default is to use my displayString"	^(hints includes: #blessing)		ifTrue: [Policies blessingPolicy stringKeyFor: self versionString blessingLevel: self blessingLevelNumber]		ifFalse: [primaryKey == nil				ifTrue: [name]				ifFalse: [self name, self versionString]]</body><body package="StoreForGlorpVWUI" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body><body package="StoreForGlorpVWUI" selector="toolListText">toolListText	^self displayString</body><body package="StoreForGlorpVWUI" selector="traceVersionString">traceVersionString	^self version ifNil: ['(???)'].</body><body package="Store-Database Model" selector="versionStringAlternate">versionStringAlternate	^self versionString</body><body package="Store-Database Model" selector="versionStringWithUserName">versionStringWithUserName	^self versionString</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>reconciling</category><body package="Store-Database Model" selector="bless:">bless: aStoreBlessing	"Prior versions of this method set the currentBlessingLevel to a string but it is an integer in the database and retrieved as an integer by the descriptor system."	(aStoreBlessing username isNil or: [aStoreBlessing username = '???']) ifTrue: [aStoreBlessing username: username].	aStoreBlessing timestamp isNil ifTrue: [aStoreBlessing timestamp: timestamp].	blessings add: aStoreBlessing.	currentBlessingLevel := aStoreBlessing blessingLevel.</body><body package="Store-Database Model" selector="ifMatchesWith:do:else:">ifMatchesWith: aStorePundle do: matchBlock else: noMatchBlock	"Check if we are a match with the argument. Note that this is very specialized, and expects the blocks to return from the outer scope. Also note that if we can't tell for sure, we just return, and let the caller figure out. Expected to be called from matchesWith:"	aStorePundle isNil ifTrue: [^noMatchBlock value].	self name = aStorePundle name ifFalse: [^noMatchBlock value].	"If the version name doesn't match, don't even bother looking. Note that in a different database, the version name could have a prefix, but we should only ever get this far if we're publishing. When replicating, we'd get a timestamp match on two versions that were really the same but the version had been renamed due to a conflict"	(self version notNil and: [self version ~= aStorePundle version]) ifTrue: [^noMatchBlock value].	"Short circuit if name and timestamp match. It's a go"	(self timestamp notNil and: [self timestamp = aStorePundle timestamp]) ifTrue: [^matchBlock value].	self reconcileWith: aStorePundle.	self basicComment yourSelf = aStorePundle basicComment yourSelf ifFalse: [^noMatchBlock value].	self propertiesMatch ifFalse: [^noMatchBlock value].	^self</body><body package="Store-Database Model" selector="ignorableProperties">ignorableProperties	"Return a list of the properties that we don't really care if they match, 	because they're likely to have been set on an image level, 	and the corresponding database package won't have them"		^#(#parcelName #bundleName #packageName #version #parcelDirectory)</body><body package="Store-Database Model" selector="makeProxiesForSubcomponents">makeProxiesForSubcomponents	"If we contain sub-bundles or packages, proxy each one individually"	self subclassResponsibility.</body><body package="Store-Database Model" selector="propertiesMatch">propertiesMatch	| previousProperties myProperties previousSize mySize |	self previous isNil ifTrue: [^false].	previousProperties := self previous properties copy.	Dialect volatilePropertyKeys do: [:each | previousProperties removeKey: each ifAbsent: []].	myProperties := self properties.	myProperties isNil ifTrue: [^previousProperties == myProperties].	myProperties keysAndValuesDo: [:eachKey :eachValue |		(self ignorableProperties includes: eachKey)			ifFalse: [				(previousProperties at: eachKey ifAbsent: [Object new]) = eachValue					ifFalse: [^false]]].	previousSize := 0.	previousProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [previousSize := previousSize + 1]].	mySize := 0.	myProperties keysDo: [:eachKey | (self ignorableProperties includes: eachKey) ifFalse: [mySize := mySize + 1]].	^mySize = previousSize.</body><body package="Store-Database Model" selector="reconcile">reconcile	self reconcileComment.	self reconcileProperties.	self reconcileBlessings.</body><body package="Store-Database Model" selector="reconcileBlessings">reconcileBlessings	" I don't believe that blessings are ever shared between versions"	blessings do: [:each | each trace: nil].</body><body package="Store-Database Model" selector="reconcileComment">reconcileComment	self comment = self previous comment		ifTrue: [comment := self previous basicComment]		 ifFalse: [self markModified].</body><body package="Store-Database Model" selector="reconcileProperties">reconcileProperties	"I suspect this and propertiesMatch could be refactored to read more simply."	self reconcilePropertiesRecords.	(self properties isNil or: [self properties isEmpty]) ifTrue:		[propertiesBlob := nil.		(self previous isNil or: [self propertiesMatch]) ifFalse: [self markModified].		^self].	(self propertiesMatch and: [self previous propertiesBlob notNil and: [self previous propertiesBlob primaryKey ~= 0]]) 		ifTrue: [propertiesBlob := self previous propertiesBlob]			ifFalse:			[self markModified.			propertiesBlob := StoreBlob forObject: self properties].</body><body package="Store-Database Model" selector="reconcilePropertiesRecords">reconcilePropertiesRecords	"Instvar properties are keyed by symbol but instvar propertiesRecords are keyed by string."	| newRecords previousRecords volatile |	newRecords := Dictionary new.	previousRecords :=		(self previous isNil or: [self previous propertiesRecordDictionary isNil])			ifTrue: [Dictionary new]			ifFalse: [self previous propertiesRecordDictionary].			self properties keysAndValuesDo:		[:eachKey :eachObject || previousObject |		previousObject := previousRecords at: eachKey asString ifAbsent: [nil].		newRecords			at: eachKey asString			put: ((previousObject notNil and: [previousObject basicDefinition object = eachObject])					ifTrue: [previousObject]					ifFalse:						[self markModified.						StoreProperty named: eachKey asString forObject: eachObject in: self])].	volatile := Dialect volatilePropertyKeys select: [:each | previousRecords includesKey: each asString].	newRecords size = (previousRecords size - volatile size) ifFalse: [self markModified].	propertiesRecordDictionary := newRecords.</body><body package="Store-Database Model" selector="reconcileWith:">reconcileWith: aPundle	"When we share source with aPundle, use it instead of our own"	self previous: aPundle.	aPundle isNil ifTrue: [self unreconcile] ifFalse: [self reconcile].	self removeDuplicates.</body><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStorePundle	self version = aStorePundle version ifFalse: [^false].	self timestamp =aStorePundle timestamp ifFalse: [^false].	self username = aStorePundle username ifFalse: [^false].	^super reconcilesWith: aStorePundle.</body><body package="Store-Database Model" selector="uninstantiateSubcomponentProxies">uninstantiateSubcomponentProxies	"This will only work if makeProxiesForSubcomponents has been previous called, to set them up as individual proxies. Used to conserve memory when doing a large iteration."	^self.</body><body package="Store-Database Model" selector="unreconcile">unreconcile	super unreconcile.	self unreconcileStoreModel.	self basicComment isNil ifFalse: [self basicComment unreconcile].	self propertiesBlob isNil		ifTrue: [propertiesBlob := StoreBlob forObject: self properties]		ifFalse: [self propertiesBlob unreconcile].	self propertiesRecordDictionary isNil		ifTrue: [self reconcilePropertiesRecords]		ifFalse: [self propertiesRecordDictionary do: [:each | each unreconcile]].	blessings do: [:each | each unreconcile].</body><body package="Store-Database Model" selector="unreconcileStoreModel">unreconcileStoreModel	"We are asserting we have no previous.  If our storeModel has no previous then it may still be legitimate for us."	storeModel isNil ifFalse:		[storeModel parentRecord isNil ifFalse:			[storeModel parentRecord parentRecord isNil ifTrue: [^self]]].	self markModified.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="canLoadNewOrReplaceExistingVersion">canLoadNewOrReplaceExistingVersion	^self storeModel isNil		ifTrue: [true]		ifFalse: [self storeModel canReplaceVersions]</body><body package="Store-Database Model" selector="hasCodeOverridden">hasCodeOverridden	"Store compatibility. Answer false because we don't care if we have overridden code or not"	^false.</body><body package="Store-Database Model" selector="hasRelatedParcel">hasRelatedParcel	^self subclassResponsibility</body><body package="Store-Database Model" selector="isBundle">isBundle	^false.</body><body package="Store-Database Model" selector="isComponentLoaded">isComponentLoaded	^self storeModel notNil.</body><body package="Store-Database Model" selector="isImageModel">isImageModel	^false</body><body package="Store-Database Model" selector="isPackage">isPackage	^self isBundle not.</body><body package="Store-Database Model" selector="isPublishedBinary">isPublishedBinary	^self subclassResponsibility</body><body package="Store-Database Model" selector="isSameAsImage">isSameAsImage	"We first send self storeModel to make sure that it is in me"	self storeModel.	self isLoaded ifFalse: [^false].	^self sameVersionAs: self storeModel.</body><body package="Store-Database Model" selector="isValid">isValid	^true.</body><body package="Store-Database Model" selector="isValidAsNew">isValidAsNew	"Return true if we are valid as a newly created pundle. This is the same as normal validation, but short-circuits if we already have a primary key, meaning that we're not actually new. So validating e.g. a new bundle, but which contains references to old packages, won't need to revalidate the packages. This assumes that they have already been validated"		self primaryKey isNil ifFalse: [^true].	^self isValid.</body><body package="Store-Database Model" selector="needsPublishing">needsPublishing	"Return true if this is a sub-component (or main component) that needs to be published. We know this, because it won't have a primary key, so it's not in the database, but it has been assigned a version number. It's even possible we don't actually care if there's a version number."	^self primaryKey isNil and: [self version notNil].</body><body package="StoreForGlorpVWUI" selector="sameAsImage">sameAsImage	| imageModel |	imageModel := self storeModel.	imageModel isNil ifTrue: [^false].	^imageModel sameVersionAs: self</body><body package="Store-Database Model" selector="sameVersionAs:">sameVersionAs: aStorePundleOrPundleModel		^aStorePundleOrPundleModel sameVersionAsPublished: self</body><body package="Store-Database Model" selector="sameVersionAsPublished:">sameVersionAsPublished: aStorePundle	^self primaryKey = aStorePundle primaryKey</body><body package="Store-Database Model" selector="youngerThan:">youngerThan: aPackage		^(aPackage isLoaded and: [aPackage isImageObject])		ifTrue: [(aPackage youngerThan: self) not] 		ifFalse: [self primaryKey &gt; aPackage primaryKey]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>fixups</category><body package="Store-Database Model" selector="convertBlobProperties">convertBlobProperties	properties := propertiesBlob object.	properties isNil ifTrue: [properties := Dictionary new].</body><body package="Store-Database Model" selector="convertProperties">convertProperties	"Create an in-memory representation of properties as a dictionary from symbols to objects"	(propertiesRecordDictionary yourSelf notNil and: [propertiesRecordDictionary yourSelf isEmpty not])		ifTrue: [^self convertRecordProperties].	propertiesBlob yourSelf isNil ifFalse: [^self convertBlobProperties].	properties := Dictionary new.</body><body package="Store-Database Model" selector="convertRecordProperties">convertRecordProperties	properties := Dictionary new.	propertiesRecordDictionary keysAndValuesDo: [:eachKey :eachValue |		properties at: eachKey asSymbol put: eachValue object].</body><body package="Store-Database Model" selector="removeDuplicates">removeDuplicates</body><body package="Store-Database Model" selector="replicationNoticeBlessing">replicationNoticeBlessing	^Dialect isVWWithNameSpaces		ifTrue: [(Dialect smalltalkAt: #'Store.Policies') blessingPolicy blessingNumber: 'Replication Notice']		ifFalse: [-1].</body><body package="Store-Database Model" selector="validateVersionString">validateVersionString	"Check to see it the receiver's version string is already used. 	This is way too late in the game to cancel, so insist on a new version string."		^[Policies versionPolicy existsVersionString: version forPundle: self]		whileTrue:			[version := Dialog				request:					(#Version1sOf2sANotherVersionString &lt;&lt; #store &gt;&gt; 'Version &lt;1s&gt; of &lt;2s&gt; already exists.&lt;n&gt;Enter another version string'						expandMacrosWith: version						with: self name)				initialAnswer: (Policies versionPolicy nextVersion: version forPundle: self)				onCancel: [^UserCancelledPublish signal]]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>prerequisites</category><body package="Store-Database Model" selector="attemptToLoadBundleNamed:version:">attemptToLoadBundleNamed: aBundleName version: aVersionString	"Attempt to load a bundle that satifies the prerequisite."	"We know an acceptable version is not already loaded."		| bundles |	(StoreBundle loadWithName: aBundleName version: aVersionString in: self session) ifNotNil: [^true].	bundles := StoreBundle allVersionsWithName: aBundleName in: self session.	bundles isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aBundleName from: bundles version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:bundle | bundle loadSource notNil]</body><body package="Store-Database Model" selector="attemptToLoadBundleNamed:version:with:">attemptToLoadBundleNamed: aBundleName version: aVersionString with: aCompilationManager	"Attempt to load a bundle that satifies the prerequisite."	"We know an acceptable version is not already loaded."		| bundles |	(StoreBundle loadWithName: aBundleName version: aVersionString with: aCompilationManager in: self session) ifNotNil: [^true].	bundles := StoreBundle allVersionsWithName: aBundleName in: self session.	bundles isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aBundleName from: bundles version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:bundle | (bundle loadSourceWith: aCompilationManager) notNil]</body><body package="Store-Database Model" selector="attemptToLoadPackageNamed:version:">attemptToLoadPackageNamed: aPackageName version: aVersionString	"Attempt to load a package that satifies the prerequisite.	We know an acceptable version is not already loaded."		| packages |	(StorePackage loadWithName: aPackageName version: aVersionString in: self session) ifNotNil: [^true].	packages := StorePackage allVersionsWithName: aPackageName in: self session.	packages isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aPackageName from: packages version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:value | value quietlyLoadSource notNil]</body><body package="Store-Database Model" selector="attemptToLoadPackageNamed:version:with:">attemptToLoadPackageNamed: aPackageName version: aVersionString with: aCompilationManager	"Attempt to load a package that satifies the prerequisite.	We know an acceptable version is not already loaded."		| packages |	(StorePackage loadWithName: aPackageName version: aVersionString with: aCompilationManager in: self session) ifNotNil: [^true].	packages := StorePackage allVersionsWithName: aPackageName in: self session.	packages isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aPackageName from: packages version: aVersionString for: self)		ifNil: [false]		ifNotNil: [:value | (value loadSourceWith: aCompilationManager) notNil]</body><body package="Store-Database Model" selector="checkParcelPrerequisite:version:">checkParcelPrerequisite: aParcelName version: aVersionString	"Validate the existense of a parcel as a prerequisite. Answer true if loaded"		^([Parcel ensureLoadedParcel: aParcelName withVersion: aVersionString forPundle: self]		on: Parcel missingParcelSignal		do: [:exp | exp return: nil]) notNil</body><body package="Store-Database Model" selector="checkParcelPrerequisite:version:with:">checkParcelPrerequisite: aParcelName version: aVersionString with: aCompilationManager	"Validate the existense of a parcel as a prerequisite. Answer true if loaded"		^([Parcel ensureLoadedParcel: aParcelName withVersion: aVersionString forPundle: self with: aCompilationManager]		on: Parcel missingParcelSignal		do: [:exp | exp return: nil]) notNil</body><body package="Store-Database Model" selector="checkPrerequisite:with:">checkPrerequisite: aPrerequisiteDescription with: aCompilationManager	"Validate the existence of a prerequisite. Either by verifying an appropriate match is loaded, or by loading one that does. Answer true if okay to finish loading"	| message loadSources |	(self checkPrerequisiteLoaded: aPrerequisiteDescription) ifTrue: [^true].	loadSources := aPrerequisiteDescription possibleLoadSources.	[loadSources do: 		[:eachSourceType |		(self prerequisiteRecursionIncludes: (aPrerequisiteDescription name -&gt; eachSourceType))			ifTrue: [^true].		self prerequisiteRecursionAdd: (aPrerequisiteDescription name -&gt; eachSourceType).		#parcel = eachSourceType ifTrue: 			[(self				checkParcelPrerequisite: aPrerequisiteDescription name				version: aPrerequisiteDescription versionFilter				with: aCompilationManager) ifTrue:[^true]].		#package = eachSourceType ifTrue: 			[(self				attemptToLoadPackageNamed: aPrerequisiteDescription name				version: aPrerequisiteDescription versionFilter				with: aCompilationManager) ifTrue: [^true]].		#bundle = eachSourceType ifTrue: 			[(self				attemptToLoadBundleNamed: aPrerequisiteDescription name				version: aPrerequisiteDescription versionFilter				with: aCompilationManager) ifTrue: [^true]]]]		on: SkipPrerequisite		do: 			[:exception |			Transcript 				cr;				show: ((#Prerequisite1sSkipped2s &lt;&lt; #store &gt;&gt; 'Prerequisite &lt;1s&gt; has been skipped for: &lt;2s&gt;') 					expandMacrosWith: aPrerequisiteDescription name					with: self name).			^true].	message := #UnableToLoadPrerequ2sNtttContinue &lt;&lt; #store		&gt;&gt; 'Unable to load prerequisite &lt;1s&gt; &lt;2s&gt;&lt;nttt&gt;Continue?'				expandMacrosWith: aPrerequisiteDescription name				with: (#version1s &lt;&lt; #store &gt;&gt; 'version &lt;1s&gt;' expandMacrosWith: aPrerequisiteDescription versionFilter).	^PrerequisiteUnableToLoadConfirmation raiseRequestErrorString: message</body><body package="Store-Database Model" selector="checkPrerequisiteLoaded:">checkPrerequisiteLoaded: aPrerequisiteDescription	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications |	verifications := aPrerequisiteDescription possibleLoadSources				collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: 			[:each |			self				perform: each				with: aPrerequisiteDescription name				with: aPrerequisiteDescription versionFilter]</body><body package="Store-Database Model" selector="checkPrerequisiteLoaded:named:version:">checkPrerequisiteLoaded: aPrereqType named: aNameString version: aVersionString	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications prereqTypes |	prereqTypes := self classicPrereqTypeAsList: aPrereqType.	verifications := prereqTypes collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: [:each | self perform: each with: aNameString with: aVersionString]</body><body package="Store-Database Model" selector="checkPrerequisiteLoaded:named:version:with:">checkPrerequisiteLoaded: aPrereqType named: aNameString version: aVersionString with: aCompilationManager	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications prereqTypes |	prereqTypes := self classicPrereqTypeAsList: aPrereqType.	verifications := prereqTypes collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: 			[:each |			self				perform: each				with: aNameString				with: aVersionString				with: aCompilationManager]</body><body package="Store-Database Model" selector="checkPrerequisiteNamed:withVersion:requiredVersion:">checkPrerequisiteNamed: prerequisiteName withVersion: prerequisiteVersionString requiredVersion: requiredVersionString	"Answer if the version of the prerequisite prerequisiteName is acceptable.	Callback for prerequiste loading"		| actionBlock |	(actionBlock := CodeComponent asActionBlock: self versionSelectionBlock) ifNil:		[^(requiredVersionString isNil or: [requiredVersionString isEmpty])			ifTrue: [true]			ifFalse: [prerequisiteVersionString = requiredVersionString]].	^actionBlock value: prerequisiteName value: prerequisiteVersionString value: requiredVersionString</body><body package="Store-Database Model" selector="checkPrerequisitesWithin:with:">checkPrerequisitesWithin: aBundle with: aCompilationManager	"Check the prereqs, but reject those belonging to aBundle. 	Answer true if it's okay to load."	| prereqs |	(prereqs := self prerequisiteDescriptions) ifNil: [^true].	prereqs isEmpty ifTrue: [^true].	self prerequisiteRecursionAdd: self name -&gt; self componentType.	(prereqs select: #isForStore) do: 		[:each |		(self checkPrerequisite: each within: aBundle with: aCompilationManager) ifFalse: [^false]].	^true</body><body package="Store-Database Model" selector="checkPundlePrerequisiteContained:">checkPundlePrerequisiteContained: aPrerequisiteDescription	| typeSelector |	typeSelector := #(#isPackage #isBundle #notNil)				at: (#(#package #bundle nil)						indexOf: aPrerequisiteDescription componentType).	^self withAllUniqueItems anySatisfy: 			[:item |			item name = aPrerequisiteDescription name				and: [item perform: typeSelector]]</body><body package="Store-Database Model" selector="checkPundlePrerequisiteContained:named:">checkPundlePrerequisiteContained: aPrereqType named: aCodeComponentName	| items typeSelector prereqVector |	items := self allUniqueItems.	prereqVector := self classicPrereqTypeAsList: aPrereqType.	^prereqVector anySatisfy:		[:eachPrereqType | 		typeSelector := #(#isPackage #isBundle #notNil) at: (#(#package #bundle #parcel) indexOf: eachPrereqType).		items anySatisfy: [:item | item name = aCodeComponentName and: [item perform: typeSelector]]]</body><body package="Store-Database Model" selector="loadedVerificationMethodForType:">loadedVerificationMethodForType: aLoadSourrceType	"What method should we use against ourself to verify aPundleType of given name and version is loaded?"	aLoadSourrceType = #parcel ifTrue: [^#verifyLoadedParcelNamed:version:].	aLoadSourrceType = #package ifTrue: [^#verifyLoadedPackageNamed:version:].	aLoadSourrceType == #bundle ifTrue: [^#verifyLoadedBundleNamed:version:].	^self error: ('Unknown code component type: &lt;1p&gt;'				expandMacrosWith: aLoadSourrceType)</body><body package="Store-Database Model" selector="prerequisiteRecursion">prerequisiteRecursion		^PrerequisiteRecursion ifNil: [PrerequisiteRecursion := Set new].</body><body package="Store-Database Model" selector="prerequisiteRecursionAdd:">prerequisiteRecursionAdd: anAssociation		^self prerequisiteRecursion add: anAssociation</body><body package="Store-Database Model" selector="prerequisiteRecursionIncludes:">prerequisiteRecursionIncludes: anAssociation		^self prerequisiteRecursion includes: anAssociation</body><body package="Store-Database Model" selector="prerequisiteRecursionReset">prerequisiteRecursionReset		PrerequisiteRecursion := nil</body><body package="Store-Database Model" selector="verifyLoadedBundleNamed:version:">verifyLoadedBundleNamed: aNameString version: aVersionString	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry bundleNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model" selector="verifyLoadedBundleNamed:version:with:">verifyLoadedBundleNamed: aNameString version: aVersionString with: aCompilationManager	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry bundleNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model" selector="verifyLoadedPackageNamed:version:">verifyLoadedPackageNamed: aNameString version: aVersionString	"Validate the existense of a package by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry packageNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model" selector="verifyLoadedPackageNamed:version:with:">verifyLoadedPackageNamed: aNameString version: aVersionString with: aCompilationManager	"Validate the existense of a package by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry packageNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value extractVersionFromVersionDisplayString				requiredVersion: aVersionString]</body><body package="Store-Database Model" selector="verifyLoadedParcelNamed:version:">verifyLoadedParcelNamed: aNameString version: aVersionString	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Parcel parcelNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value version				requiredVersion: aVersionString]</body><body package="Store-Database Model" selector="verifyLoadedParcelNamed:version:with:">verifyLoadedParcelNamed: aNameString version: aVersionString with: aCompilationManager	"Validate the existense of a parcel by a given name and version. 	Answer true if acceptable version is already loaded"		^(Parcel parcelNamed: aNameString)		ifNil: [false]		ifNotNil:			[:value | 			self				checkPrerequisiteNamed: aNameString				withVersion: value version				requiredVersion: aVersionString]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>full classes</category><body package="Store-Database Model" selector="allClasses">allClasses	^self fullClasses.</body><body package="Store-Database Model" selector="definedObjectNamed:">definedObjectNamed: aString	^(self fullClasses asArray, self nameSpaces, self sharedVariables) detect: [:each | each longName = aString] ifNone: [nil].</body><body package="Store-Database Model" selector="fullClassNamed:">fullClassNamed: aString	^self fullClasses detect: [:each | each longName = aString] ifNone: [nil].</body><body package="Store-Database Model" selector="fullClasses">fullClasses	self subclassResponsibility.</body><body package="Store-Database Model" selector="fullClassesAndMetaClasses">fullClassesAndMetaClasses	self subclassResponsibility.</body><body package="Store-Database Model" selector="nameSpaceNamed:">nameSpaceNamed: aString	^self nameSpaces detect: [:each | each longName = aString] ifNone: [nil].</body><body package="Store-Database Model" selector="objectNamed:">objectNamed: aString	^(self fullClasses asArray, self nameSpaces, self sharedVariables) detect: [:each | each longName = aString] ifNone: [nil].</body><body package="Store-Database Model" selector="resetFullClasses">resetFullClasses	self subclassResponsibility.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	| newProps |	super postCopyIn: aDictionary.	comment := (comment isNil or: [comment unchainedBinaryData isNil]) ifTrue: [nil] ifFalse: [comment glorpCopyIn: aDictionary].	properties := properties glorpCopyIn: aDictionary.	propertiesBlob := propertiesBlob glorpCopyIn: aDictionary.	newProps := Dictionary new.	propertiesRecordDictionary isNil ifFalse: [		propertiesRecordDictionary keysAndValuesDo: [:eachKey :eachValue |				newProps at: eachKey put: (eachValue glorpCopyIn: aDictionary)].		propertiesRecordDictionary := newProps].	blessings := blessings collect: [:each | each glorpCopyIn: aDictionary].	session := nil.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>constants</category><body package="Store-Database Model" selector="componentType">componentType		self subclassResponsibility</body><body package="Store-Database Model" selector="propertyTypeCode">propertyTypeCode	^self class propertyTypeCode.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>utilities</category><body package="Store-Database Model" selector="addBlessingLevel:andComment:">addBlessingLevel: anInteger andComment: aString	| publishSpecification |	publishSpecification := PublishSpecification pundle: self.	publishSpecification blessing: anInteger.	publishSpecification comment: aString.	publishSpecification publish: true.	publishSpecification publishBlessing.</body><body package="Store-Database Model" selector="allVersionPrimaryKeysWithProperty:">allVersionPrimaryKeysWithProperty: aStoreProperty	^self class allVersionPrimaryKeysWithProperty: aStoreProperty in: session</body><body package="Store-Database Model" selector="allVersionsWithTrace:">allVersionsWithTrace: anInteger	^self class allVersionsWithTrace: anInteger in: session</body><body package="Store-Database Model" selector="classicPrereqTypeAsList:">classicPrereqTypeAsList: aTypeSymbol	"Convert simple prereq types (#any, #bundle, #package, #parcel) into the appropriate sequence of specific prereqs, which means converting #any based on the search order preferences, wrapping anything else as any array."	aTypeSymbol == #any		ifTrue: 			[^Policies prerequisitePolicy searchOrder = #parcelsFirst				ifTrue: [#(#parcel #bundle #package)]				ifFalse: [#(#bundle #package #parcel)]].	^Array with: aTypeSymbol</body><body package="Store-Database Model" selector="sharesProperty:">sharesProperty: aStoreProperty	^self class sharesProperty: aStoreProperty in: session</body><body package="Store-Database Model" selector="withName:version:">withName: aNameString version: aVersionString	^self class withName: aNameString version: aVersionString in: self session</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>deleting</category><body package="Store-Database Model" selector="delete">delete	"Delete this pundle from the database"	self session delete: self.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;=">&lt;= aStorePundle	self name &lt; aStorePundle name ifTrue: [^true].	self name = aStorePundle name ifTrue: [^self timestamp &gt;= aStorePundle timestamp].	^false.</body><body package="StoreForGlorpVWUI" selector="allPropertiesAndValuesIn:butNotIn:">allPropertiesAndValuesIn: aDictionary butNotIn: anotherDictionary	| dictionary |	dictionary := Dictionary new.	aDictionary keysAndValuesDo: [:key :value | dictionary at: key put: key -&gt; value].	aDictionary isEmpty ifTrue: [^Dictionary new].	anotherDictionary keysAndValuesDo: 		[:key :value | 		(dictionary at: key ifAbsent: [nil -&gt; nil]) value = value ifTrue:			[dictionary removeKey: key ifAbsent: []]].	^dictionary</body><body package="StoreForGlorpVWUI" selector="allPropertiesAndValuesInPundle:butNotIn:">allPropertiesAndValuesInPundle: aStorePundle butNotIn: anotherStorePundle	^self		allPropertiesAndValuesIn: (aStorePundle ifNil: [#()] ifNotNil: [aStorePundle propertiesWithoutVolatileKeys])		butNotIn: (anotherStorePundle ifNil: [#()] ifNotNil: [anotherStorePundle propertiesWithoutVolatileKeys]).</body><body package="StoreForGlorpVWUI" selector="compareToImage">compareToImage	^self getImagePundle		ifNil: [#notLoaded]		ifNotNil: [:value | value compareToPundle: self]</body><body package="Store-Database Model" selector="comparesTo:">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isPackage and: [ name = aCodeComponent name ].</body><body package="StoreForGlorpVWUI" selector="computePropertyDifferencesBetween:into:">computePropertyDifferencesBetween: aPundle into: aPackageComparitor	"If aPackage is already a StorePackage, compute the diffs ourselves. 	Otherwise, convert it into one, either by reading it from the database if it's a Package, or by converting the image packageModel"		| other |	other := (aPundle pseudoPackage or: [aPundle class = self class])		ifTrue: [aPundle]		ifFalse:			[aPundle primaryKey = 0				ifTrue: [aPundle asStorePundleIn: self session]				ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aPundle primaryKey]]].	^other computePropertyDiffsBetweenDBPundle: self into: aPackageComparitor</body><body package="StoreForGlorpVWUI" selector="computePropertyDiffsBetweenDBPundle:into:">computePropertyDiffsBetweenDBPundle: aStorePundle into: aPackageComparitor	"Store  differences between receiver and a aStorePackage into an instance of PackageComparitor.	Store receiver's definitions as main and the other as other since this method	is called with arguments reversed."	| realOtherPackage |	realOtherPackage := (aStorePundle isNil or: [aStorePundle class == self class]) 		ifTrue: [aStorePundle] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aStorePundle primaryKey]].	self = realOtherPackage ifTrue: [aPackageComparitor makeEmpty. ^self].	aPackageComparitor otherPackageProperties: (self allPropertiesAndValuesInPundle: self butNotIn: realOtherPackage).	aPackageComparitor mainPackageProperties: (self allPropertiesAndValuesInPundle: realOtherPackage butNotIn: self).	aStorePundle isBundle ifTrue:		[self structure = realOtherPackage structure ifFalse:			[aPackageComparitor otherPackageProperties add: (#structure -&gt; realOtherPackage structure).			aPackageComparitor mainPackageProperties add: (#structure -&gt;  self structure)]].	^aPackageComparitor</body><body package="StoreForGlorpVWUI" selector="itemString">itemString	^self name , self versionString.</body><body package="StoreForGlorpVWUI" selector="itemStringWithBlessing">itemStringWithBlessing	^self displayString , ' ', self blessingLevelString</body><body package="Store-Database Model" selector="sameVersionAsLoadedPundle:">sameVersionAsLoadedPundle: anImPundle	^anImPundle sameVersionAsPublished: self</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>converting</category><body package="Store-Database Model" selector="asPrerequisiteDescription">asPrerequisiteDescription	^(PrerequisiteDescription new)		name: self name;		componentType: self componentType;		yourself</body><body package="Store-Database Model" selector="asStoreComparisonObjectIn:">asStoreComparisonObjectIn: ignore	^self</body><body package="Store-Database Model" selector="asStorePundleIn:">asStorePundleIn: aSession	"I don't care about the session, at least I don't think so	aSession = self session ifFalse: [self error: 'Incompatible sessions']."	^self.</body><body package="StoreForGlorpVWUI" selector="recordForPropertyTag:">recordForPropertyTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"		^(self properties includesKey: aTag property)		ifFalse: [nil]		ifTrue:			[(aTag copy)				package: self;				yourself]</body><body package="StoreForGlorpVWUI" selector="storeForGlorpPundleClass">storeForGlorpPundleClass	^self class</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize	super initialize.	blessings := OrderedCollection new</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>image model</category><body package="Store-Database Model" selector="createImagePundle">createImagePundle	"Check if there if already loaded versions of the receiver and answer it. 	If not create a new pundle and register it."		| pundleModel |	pundleModel := self getImagePundle.	pundleModel ifNil:		[pundleModel := self class imageClass named: self name.		pundleModel dbIdentifier: self dbIdentifier].	^pundleModel</body><body package="StoreForGlorpVWUI" selector="getImagePundle">getImagePundle	^self storeModel.</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>browsing</category><body package="StoreForGlorpVWUI" selector="browseContents">browseContents	^GlorpHelper dialect isVWWithNameSpaces		ifTrue: [(Store.Glorp.StoreForGlorpBrowserEnvironment on: self) openEditor]		ifFalse: 			[Refactory.Browser.RefactoringBrowser				openOnEnvironment: self asBrowserEnvironment]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>streams</category><body package="StoreForGlorpVWUI" selector="baseOfBranch">baseOfBranch	^self baseOfBranchWithMaximumDepth: 20.</body><body package="StoreForGlorpVWUI" selector="baseOfBranchWithMaximumDepth:">baseOfBranchWithMaximumDepth: anInteger	"Assuming that we are part of a branch differentiated by a naming convention of '+ something', 	find the base version from which that branch was made and compare us to it. Give up if we don't find anything within anInteger versions."	| changeFromPrevious |	self previous isNil ifTrue: [^nil].	anInteger &lt;= 0 ifTrue: [^nil].	changeFromPrevious := (self version ifNil: [self parent version]) readStream nextAvailable: (self previous version size); upToEnd.	(changeFromPrevious size &lt;= 1 or: [changeFromPrevious first = $+ or: [(changeFromPrevious at: 2) = $+]]) 		ifFalse: ["We haven't made a transition, keep going"			^self previous baseOfBranchWithMaximumDepth: anInteger - 1].	"A completely arbitrary size criteria to make sure they're not just tacking a + on the end."	^(changeFromPrevious size &gt; 5)		ifTrue: [self previous]		ifFalse: [self previous baseOfBranchWithMaximumDepth: anInteger - 1].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>publishing</category><body package="StoreForGlorpVWUI" selector="applyPundleVersionsToTheImage">applyPundleVersionsToTheImage	"After we have been published, or loaded, take all of our version and trace information and set it into the image pundles. We want to do this after loading because the component descriptions we return during loading are our own objects, and we want to put them back to normal store descriptions.  Also reset the contentDescriptions of any other databaseInformations of bundles so the image knows what subpundles it has loaded whoever we then connect to."	| databaseIdentifier |	databaseIdentifier := session system databaseIdentifier.	self allComponentsDo:		[:each |		| imageModel | 		imageModel := each storeModel.		imageModel isNil ifFalse:			[imageModel databaseInfomationForOrCreate: databaseIdentifier.			imageModel setDbTraceAndVersionUsing: each for: databaseIdentifier.			imageModel resetNoDatabaseInformation.			imageModel isPackage ifTrue: [imageModel removeEmptyProtocols].			each isBundle ifTrue:				[imageModel					setContentsFromDB: each asPundleWithComponentDescriptions for: databaseIdentifier;					initializeFromImage: (Registry bundleNamed: imageModel name) for: databaseIdentifier]]].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="asComponentDescription">asComponentDescription	"Return a representation of ourselves as a store component description, used to update the image after a publish, or while loading"	^self descriptionClass new		id: primaryKey;		dbIdentifier: self session system databaseIdentifier;		componentName: name;		yourself</body><body package="StoreForGlorpVWUI" selector="asComponentDescriptionForReal">asComponentDescriptionForReal	"Return a representation of ourselves as a store component description, used to update the image after a publish, or while loading"	^self descriptionClass new		id: primaryKey;		dbIdentifier: self session system databaseIdentifier;		componentName: name;		yourself</body><body package="StoreForGlorpVWUI" selector="asPundleWithComponentDescriptions">asPundleWithComponentDescriptions	"I should never be sent!"	| copy |	copy := self copy.	^copy.</body><body package="StoreForGlorpVWUI" selector="binarySave">binarySave	^self propertyAt: #binarySave ifAbsent: [nil]</body><body package="StoreForGlorpVWUI" selector="blessingLevel">blessingLevel	^self blessingLevelNumber printString</body><body package="Store-Database Model" selector="canBePublishedToCurrentDatabase">canBePublishedToCurrentDatabase	^self isInCurrentDatabase</body><body package="StoreForGlorpVWUI" selector="changeSet">changeSet	^self storeModel changeSet.</body><body package="Store-Database Model" selector="checkPrerequisite:within:with:">checkPrerequisite: aPrerequisiteDescription within: aBundle with: aCompilationManager	"Validate the existence of a prerequisite of given name and type within a bundle. Answer true if okay to finish loading"	aBundle ifNotNil: 		[(aBundle checkPundlePrerequisiteContained: aPrerequisiteDescription) ifTrue: [^true]].	^self checkPrerequisite: aPrerequisiteDescription with: aCompilationManager</body><body package="Store-Database Model" selector="classOfDbRecord">classOfDbRecord	^self.</body><body package="Store-Database Model" selector="cleanse">cleanse	"I do nothing, since I'm in the Database"</body><body package="Store-Database Model" selector="cleanse:">cleanse: ignore	"I do nothing, since I'm in the Database"</body><body package="Store-Database Model" selector="component">component	^self storeModel.</body><body package="Store-Database Model" selector="databaseList">databaseList	^Array with: self session system databaseIdentifier</body><body package="Store-Database Model" selector="dbTrace">dbTrace	^self previous ifNotNil: [self previous primaryKey]</body><body package="StoreForGlorpVWUI" selector="describesPackageNamed:">describesPackageNamed: aString	"Copied from Store.ComponentDescription"	"Answer true if the description refers to a package named aString."	^false</body><body package="StoreForGlorpVWUI" selector="descriptionClass">descriptionClass	self subclassResponsibility.</body><body package="Store-Database Model" selector="hasBeenModified">hasBeenModified	"If the storeModel is nil we cannot meaningfully say we are unmodified.  (Standard store takes a similar approach;  pundle models with no db info are regarded as modified.)"	^storeModel isNil or: [storeModel hasBeenModified]</body><body package="Store-Database Model" selector="hasTrace">hasTrace	"Since we are using this to imitate a pundleModel, we return true if we have a primary key of our own, which means we correspond to a database entry. Otherwise, it can get confused about a version 1.0 not having version information"	^self primaryKey notNil or: [self previous yourSelf notNil].</body><body package="Store-Database Model" selector="isInCurrentDatabase">isInCurrentDatabase	^true</body><body package="Store-Database Model" selector="isLoaded">isLoaded	^storeModel notNil.</body><body package="Store-Database Model" selector="isVersionLoaded">isVersionLoaded	| result |	self session ifNil: [^false].	result := self compareToImage.	^(result == #same or: [result == #modified])</body><body package="StoreForGlorpVWUI" selector="loadingPropertyRecords">loadingPropertyRecords	^self properties yourSelf.</body><body package="Store-Database Model" selector="markModified">markModified	"If this is called, our storeModel should agree.  If it does not, it does not correspond to our state and so is nilled."	self hasBeenModified ifFalse: [storeModel := nil].</body><body package="Store-Database Model" selector="parcelName">parcelName	^storeModel isNil		ifTrue: ['']		ifFalse: [storeModel parcelName].</body><body package="Store-Database Model" selector="propertiesForSave">propertiesForSave	^self properties</body><body package="Store-Database Model" selector="pseudoPackage">pseudoPackage	^false.</body><body package="Store-Database Model" selector="pundle">pundle	^self</body><body package="StoreForGlorpVWUI" selector="pundleChangesClass">pundleChangesClass	^self isBundle ifTrue: [BundleChanges] ifFalse: [PackageChanges].</body><body package="Store-Database Model" selector="pundleWithName:version:">pundleWithName: aString version: versionString		^self class pundleWithName: aString version: versionString in: self session</body><body package="StoreForGlorpVWUI" selector="resetProperties">resetProperties	^self.</body><body package="Store-Database Model" selector="runPreReadAndLoad">runPreReadAndLoad	"Run the preload and answer it's result. If there's no pre-load, don't bother doing the relatively expensive conversion to a store record."	self isNotLoaded ifFalse: [^true].	self runPreRead ifFalse: [^false].	^self runPreLoad</body><body package="StoreForGlorpVWUI" selector="shortVersionString">shortVersionString		| string |	string := self version.	string ifNil: [^''].	(string isNil or: [string class = Object]) ifTrue: [string := self timeStampString].	^'(' , string , ')'</body><body package="Store-Database Model" selector="storeTracePackage">storeTracePackage	^self previous.</body><body package="Store-Database Model" selector="tracePackage">tracePackage	^self previous.</body><body package="Store-Database Model" selector="userWantsFullCompare">userWantsFullCompare	^PundleModel useChangeSetsForCompare not or: [InputState default ctrlDown]</body><body package="Store-Database Model" selector="validateLoadOrder">validateLoadOrder	^self storeModel isNil ifTrue: [''] ifFalse: [self storeModel validateLoadOrder].</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>private-file out</category><body package="StoreForGlorpVWUI" selector="fileOut">fileOut	| fileName fileManager |	fileName := Dialog				requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'				default: (Filename						filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: self name)).	fileName isEmpty ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: #Source.		[fileManager timeStamp.	self fileOutOn: fileManager]			ensure: [fileManager close]</body><body package="StoreForGlorpVWUI" selector="fileOutOn:withoutRepeatingAnyOf:">fileOutOn: aFileManager withoutRepeatingAnyOf: aSet	"File out package on aFileManager"	(aSet includes: self) ifTrue: [^self].	self fileOutOn: aFileManager</body><body package="StoreForGlorpVWUI" selector="fileOutPropertiesOn:">fileOutPropertiesOn: aSourceFileManager		self propertiesForFileOut associationsDo: 		[:each | 		aSourceFileManager 			component: self componentType 			named: self name 			property: each key 			value: each value]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>displaying</category><body package="Store-Merge Management" selector="mergeDisplayString">mergeDisplayString	| result versionString textString |	versionString := self simpleVersionString.	result := self compareToImage.	result == #modified ifTrue: [versionString := #x1sStar &lt;&lt; #store &gt;&gt; '&lt;1s&gt; *' expandMacrosWith: versionString].	textString := versionString asText.	(result == #same or: [result == #modified]) ifTrue: [textString := textString allBold].	^textString</body><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	self isVersionLoaded ifFalse: [^self class toolListIcon].	^self getImagePundle class toolListIcon</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>relationships</category><body package="StoreForGlorpVWUI" selector="relatedBy:">relatedBy: aSymbol 	"This answers the relationship between objects when used in a Version Graph"	aSymbol == #tt_derivesRel		ifTrue: 			[| children pundleModel |			children := (self allVersionsWithTrace: self primaryKey) asOrderedCollection.			pundleModel := self getImagePundle.			(pundleModel notNil and: [pundleModel dbTrace = self primaryKey])				ifTrue: [children add: pundleModel].			^children].	aSymbol == #tt_derivesRRel ifTrue: [^Set with: (self class cachedItemFor: self tracePackage yourSelf)].	^super relatedBy: aSymbol</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="analyzeAndLoad">analyzeAndLoad	(AtomicAnalysisLoader pundle: self) analyze.	^self getImagePundle</body><body package="Glorp Atomic Compiling" selector="asAtomicInstallObject">asAtomicInstallObject	| instance |	instance := self pundleInstallClass new.	instance pundle: self.	^instance</body><body package="Glorp Atomic Compiling" selector="atomicCompileAndLoad">atomicCompileAndLoad	"Do the actual atomic compiling and loading, with UI feedback. 	If all doesn't go well we throw up the Unloadables dialol"		| shadowRootNameSpace compilerManager |	DbRegistry clearPundleCaches.	shadowRootNameSpace := ShadowNameSpaceBuilder new createShadowRoot.	compilerManager := AtomicCompilationManager root: shadowRootNameSpace pundle: self.	compilerManager compileAndInstall ifNil: [^nil].	(compilerManager isCompilationResult not and: [compilerManager isPackage])		ifTrue: [^compilerManager].	(compilerManager isFullyLoaded not and: [AtomicLoader loadFailOption ~~ #load]) ifTrue:		[UnloadableDefinitionsViewer openOnExceptions: compilerManager unloadableDefinitionsForBrowsing].	self prerequisiteRecursionReset.	^compilerManager pundle getImagePundle</body><body package="Glorp Atomic Compiling" selector="defaultCompileManager">defaultCompileManager	self subclassResponsibility</body><body package="Glorp Atomic Compiling" selector="pundleInstallClass">pundleInstallClass	^self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>query utility</category><body package="Store-Database Model" selector="allNames">allNames	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	^self allNamesIn: StoreLoginFactory currentStoreSession.</body><body package="Store-Database Model" selector="allNamesIn:">allNamesIn: asSessionOrNil	"This does DbRegistry caching"	| session query highestKnownPrimaryKey maxPrimary newNames oldNames allNames |	session := asSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self.	query retrieve: [:each | each primaryKey max].	maxPrimary := (session execute: query) ifNil: [^OrderedCollection new].	(maxPrimary &gt; (DbRegistry highestPrimaryKeyChecked at: self ifAbsent: [0])) ifFalse:		[^DbRegistry cachedNames at: self].	highestKnownPrimaryKey := DbRegistry highestPrimaryKeyChecked at: self ifAbsent: [0].	query := Query readManyOf: self.	(DbRegistry cachedNames at: self ifAbsent: [#()]) isEmpty ifFalse:		[query where: [:each | each primaryKey &gt; highestKnownPrimaryKey]]. 	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	newNames := session execute: query.	oldNames := DbRegistry cachedNames at: self ifAbsent: [nil].	allNames := oldNames isNil 		ifTrue: [newNames asSet] 		ifFalse: [oldNames addAll: newNames; yourself].	DbRegistry cachedNames at: self put: allNames.	DbRegistry highestPrimaryKeyChecked at: self put: (maxPrimary ifNil: [0]).	^allNames</body><body package="Store-Database Model" selector="allNamesSorted">allNamesSorted	"Answer back all unique names for versions of this class that exist in the database, sorted by name"	^(self allNamesSortedIn: StoreLoginFactory currentStoreSession)</body><body package="Store-Database Model" selector="allNamesSortedIn:">allNamesSortedIn: aSession	"Answer back all unique names for versions of this class that exist in the database, sorted by name, using aSession"	"This doesn't do DbRegistry caching"	| results allNames |	results := self getNamesAndMaxTimestampsIn: aSession.	allNames := results collect: [:ea | ea first].	^allNames</body><body package="Store-Database Model" selector="allPundlesIn:withNewerInDBIn:">allPundlesIn: pundleCollection withNewerInDBIn: aSession	"Answer a collection of pundles with newer published versions."	| result session newestPundleDict |	result := OrderedCollection new.	session := aSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	self updateTimestampsFor: pundleCollection in: session.	newestPundleDict := self newestVersionsInSession: aSession.	pundleCollection do: 			[:each |			| mostRecentTimestamp |			mostRecentTimestamp := newestPundleDict 				at: each name				ifAbsent: [Timestamp fromSeconds: 0].			(each publishedBefore: mostRecentTimestamp) ifTrue: [result add: each]].	^result</body><body package="Store-Database Model" selector="allVersionPrimaryKeysWithProperty:in:">allVersionPrimaryKeysWithProperty: aStoreProperty in: aSession	"Answer back all versions of this class that share the passed in Property"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each propertiesRecordDictionary includes: aStoreProperty].	query retrieve: [:each | each primaryKey distinct].	^(session execute: query)</body><body package="Store-Database Model" selector="allVersionsInitiallyNamed:">allVersionsInitiallyNamed: aString	"Answer back all versions of this class that match aString for the name and any parent names, ordered by their timestamp in newest first order"	^self allVersionsInitiallyNamed: aString in: nil</body><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:">allVersionsInitiallyNamed: aString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query sameNamed otherNames result oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	(sameNamed := session execute: query) isEmpty ifTrue: [^#()].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed inject: OrderedCollection new into:		[:sum :each |		(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not]])			ifTrue: [sum add: each parent name].		sum].	result := otherNames copy inject: sameNamed copy into:		[:sum :each |		sum, (self allVersionsInitiallyNamed: each in: aSession notIn: (otherNames copy add: aString; yourself) olderThan: oldestTimestamp)].	^result sorted: [:each :other | each timestamp &gt; other timestamp]</body><body package="Store-Database Model" selector="allVersionsInitiallyNamed:in:notIn:olderThan:">allVersionsInitiallyNamed: aString in: aSession notIn: aCollection olderThan: aTimeStamp	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"		| session query sameNamed otherNames oldestTimestamp |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aString AND: each timestamp &lt;= aTimeStamp].	query orderBy: [:each | each timestamp descending].	sameNamed := session execute: query.	sameNamed isEmpty ifTrue: [^sameNamed].	oldestTimestamp := sameNamed last timestamp.	otherNames := sameNamed		inject: OrderedCollection new		into:			[:sum :each | 			(each parent notNil and: [each parent name ~= aString and: [(sum includes: each parent name) not and: [(aCollection includes: each parent name) not]]])				ifTrue: [sum add: each parent name].			sum].	^otherNames copy		inject: sameNamed copy		into:			[:sum :each | 			sum , (self allVersionsInitiallyNamed: each in: aSession notIn: aCollection , otherNames olderThan: oldestTimestamp)]</body><body package="StoreForGlorpVWUI" selector="allVersionsWithBlessingLevel:in:">allVersionsWithBlessingLevel: anInteger in: aSession	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each currentBlessingLevel = anInteger].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model" selector="allVersionsWithName:">allVersionsWithName: aString	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	^self allVersionsWithName: aString in: StoreLoginFactory currentStoreSession.</body><body package="Store-Database Model" selector="allVersionsWithName:after:">allVersionsWithName: aString after: anInteger	"Answer back all versions of this class that match aString for the name whos primaryKey (anInteger) is larger"	^self allVersionsWithName: aString after: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allVersionsWithName:after:in:">allVersionsWithName: aString after: anInteger in: aSession	"Answer back all versions of this class that match aString for the name whos primaryKey (anInteger) is larger"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aString AND: (each primaryKey &gt; anInteger)].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model" selector="allVersionsWithName:in:">allVersionsWithName: aString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model" selector="allVersionsWithName:version:">allVersionsWithName: aString version: aBlock	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock,	or nil if there is no match.	Examples: 		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage allVersionsWithName: 'PackageCategories' version: [:version | '*47769*' match: version]"	^self allVersionsWithName: aString version: aBlock in: nil</body><body package="Store-Database Model" selector="allVersionsWithName:version:in:">allVersionsWithName: aString version: aBlock in: aSessionOrNil	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock,	or nil if there is no match.	Examples: 		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle allVersionsWithName: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage allVersionsWithName: 'PackageCategories' version: [:version | '*47769*' match: version]"	| session query result matching versionValues blessingValues |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	query retrieve: [:each | each currentBlessingLevel].	query retrieve: [:each | each version].	result := session execute: query.	matching := aBlock numArgs = 1		ifTrue: [result select: [:each | aBlock value: each last]]		ifFalse: [result select: [:each | aBlock value: each last value: each first]].	matching isEmpty ifTrue: [^nil].	versionValues := matching collect: [:each | each last].	blessingValues := matching collect: [:each | each first].	query := aBlock numArgs = 1		ifTrue: [Query readManyOf: self where: [:each | each name = aString AND: (each version in: versionValues)]]		ifFalse: [Query readManyOf: self where: [:each | each name = aString AND: (each version in: versionValues) AND: (each currentBlessingLevel in: blessingValues)]].	^session execute: query</body><body package="Store-Database Model" selector="allVersionsWithNameLike:">allVersionsWithNameLike: aWildcardString	"Answer back all versions of this class that match aWildcardString for the name, ordered by their timestamp in newest first order"	^self allVersionsWithNameLike: aWildcardString in: StoreLoginFactory currentStoreSession.</body><body package="Store-Database Model" selector="allVersionsWithNameLike:in:">allVersionsWithNameLike: aWildcardString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name like: aWildcardString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model" selector="allVersionsWithTrace:in:">allVersionsWithTrace: anInteger in: aSession	"Answer back all versions of this class that match the previous (trace) primaryKey equals anInteger, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each trace ~= nil AND: [each trace primaryKey = anInteger]].	query orderBy: [:each | each timestamp descending].	^(session execute: query) collect: [:each | self cachedItemFor: each yourSelf]</body><body package="Store-Database Model" selector="allVersionsWithVersionNameLike:in:">allVersionsWithVersionNameLike: aWildcardString in: aSession	"Answer back all versions of this class that match aString for the name, ordered by their timestamp in newest first order"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each version like: aWildcardString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model" selector="getNamesAndMaxTimestampsIn:">getNamesAndMaxTimestampsIn: aSession	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self.	query retrieve: #name.	query retrieve: [:ea | ea timestamp max].	query groupBy: #name.	query orderBy: #name.	^session execute: query</body><body package="Store-Database Model" selector="getNamesAndTimestampsForKeys:in:">getNamesAndTimestampsForKeys: keys in: aSession	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query read: self where: [:each| each primaryKey in: keys ].	query retrieve: #name.	query retrieve: #timestamp.	query orderBy: #name.	^session execute: query</body><body package="Store-Database Model" selector="latestOf:version:">latestOf: aString version: aBlock	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock.	Examples: 		StoreBundle latestOf: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage latestOf: 'PackageCategories' version: [:version | '*47769*' match: version]"	^self latestOf: aString version: aBlock in: nil</body><body package="Store-Database Model" selector="latestOf:version:in:">latestOf: aString version: aBlock in: aSessionOrNil	"Returns the latest (based on timestamp) version of pundle named aString whose version string satisfies aBlock,	or nil if there is no match.	Examples: 		StoreBundle latestOf: 'Tools-IDE' version: [:version | '7.3*' match: version]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | ('7.3*' match: version) and: [blessingLevel = 20]]		StoreBundle latestOf: 'Tools-IDE' version: [:version :blessingLevel | blessingLevel = 50]				StorePackage latestOf: 'PackageCategories' version: [:version | '*47769*' match: version]"	| session query result matching targetValues |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	query retrieve: [:each | each currentBlessingLevel].	query retrieve: [:each | each version].	result := session execute: query.	matching := aBlock numArgs = 1		ifTrue: [result select: [:each | aBlock value: each last]]		ifFalse: [result select: [:each | aBlock value: each last value: each first]].	matching isEmpty ifTrue: [^nil].	targetValues := matching first.	query := aBlock numArgs = 1		ifTrue: [Query readOneOf: self where: [:each | each name = aString AND: (each version = targetValues last)]]		ifFalse: [Query readOneOf: self where: [:each | each name = aString AND: (each version = targetValues last) AND: (each currentBlessingLevel = targetValues first)]].	^session execute: query</body><body package="Store-Database Model" selector="newerVersionsOf:">newerVersionsOf: aStorePundle	| session query |	session := aStorePundle session.	query := Query read: self where: [:each | each trace primaryKey = aStorePundle primaryKey].	query alsoFetch: [:each | each trace].	^session execute: query.</body><body package="Store-Database Model" selector="newestVersionWithName:">newestVersionWithName: aString	| session query |	session := StoreLoginFactory currentStoreSession.	query := Query readOneOf: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	^session execute: query.</body><body package="Store-Database Model" selector="newestVersionsInSession:">newestVersionsInSession: aSession	| session namesAndTimestamps newestDict |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	namesAndTimestamps := self getNamesAndMaxTimestampsIn: session.	newestDict := Dictionary new.	namesAndTimestamps		do: [:eaArray | newestDict at: (eaArray first) put: (eaArray last)].	^newestDict</body><body package="Store-Database Model" selector="pundleWithName:hasVersion:">pundleWithName: aName hasVersion: aString	^self pundleWithName: aName hasVersion: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="pundleWithName:hasVersion:in:">pundleWithName: aName hasVersion: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each name = aName AND: (each version = aString)].	query retrieve: #name.	^(session execute: query) notNil</body><body package="Store-Database Model" selector="pundleWithName:version:">pundleWithName: aNameString version: aVersionString	^self pundleWithName: aNameString version: aVersionString in: nil</body><body package="Store-Database Model" selector="pundleWithName:version:in:">pundleWithName: aNameString version: aVersionString in: aSession		| session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	^session readOneOf: self where: [:each | each name = aNameString &amp; (each version = aVersionString)]</body><body package="Store-Database Model" selector="sharesProperty:in:">sharesProperty: aStoreProperty in: aSession	"Answer back if  versions of this class that share the passed in Property"	| session query primaryKey |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	primaryKey := aStoreProperty primaryKey.	query := Query count: self where: [:each | each propertiesRecordDictionary primaryKey =  primaryKey].	^(session execute: query) ~= 1</body><body package="Store-Database Model" selector="traceVersionFor:">traceVersionFor: anInteger	^self traceVersionFor: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="traceVersionFor:in:">traceVersionFor: anInteger in: aSessionOrNil	| session query |	(anInteger isNil or: [anInteger isZero]) ifTrue: [^nil].	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each primaryKey = anInteger].	query retrieve: #version.	^(session execute: query).</body><body package="Store-Database Model" selector="traceVersionStringFor:">traceVersionStringFor: anInteger	^self traceVersionStringFor: anInteger in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="traceVersionStringFor:in:">traceVersionStringFor: anInteger in: aSessionOrNil	| session query result |	(anInteger isNil or: [anInteger isZero]) ifTrue: [^nil].	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each primaryKey = anInteger].	query retrieve: #version.	query retrieve: #username.	result := (session execute: query).	^(result isNil or: [result isEmpty])		ifTrue: [nil]		ifFalse: ['(', result first, ',', result last, ')']</body><body package="Store-Database Model" selector="updateTimestampsFor:in:">updateTimestampsFor: aCollection in: aSession	"This is necessary since we don't keep timestamps when we load pundles into the image.  If we added dbTimestamp	to DatabaseConnectionInformation and maintained it, this query would be redundant in most cases."	| keys session namesAndTimestamps |	aCollection isEmpty ifTrue: [^self].	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	keys := aCollection inject: OrderedCollection new 		into: [:collection :each| (each dbTrace notNil and: [each dbTimestamp isNil]) 			ifTrue: [collection add: each dbTrace]. collection].	namesAndTimestamps := self getNamesAndTimestampsForKeys: keys in: session.	namesAndTimestamps do: [:eachArray| | pundle |	 	pundle := aCollection at: (eachArray first) ifAbsent: [nil].		pundle notNil ifTrue: [pundle dbTimestamp: (eachArray last)]].</body><body package="Store-Database Model" selector="withName:version:">withName: aNameString version: aVersionString		^self withName: aNameString version: aVersionString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="withName:version:in:">withName: aNameString version: aVersionString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aNameString AND: (each version = aVersionString)].	query orderBy: [:each | each timestamp descending].	^session execute: query</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>load utilities</category><body package="Store-Database Model" selector="loadWithName:version:">loadWithName: aNameString version: aVersionString		^self loadWithName: aNameString version: aVersionString in: nil</body><body package="Store-Database Model" selector="loadWithName:version:in:">loadWithName: aNameString version: aVersionString in: aSession		| storePundle session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	storePundle := self pundleWithName: aNameString version: aVersionString in: session.	storePundle ifNotNil: [storePundle quietlyLoadSource].	aSession ifNil: [Undeclared purgeUnusedBindings].	^storePundle</body><body package="Store-Database Model" selector="loadWithName:version:with:in:">loadWithName: aNameString version: aVersionString with: aCompilationManager in: aSession		| storePundle session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	storePundle := self pundleWithName: aNameString version: aVersionString in: session.	storePundle ifNotNil: [storePundle loadSourceWith: aCompilationManager].	aSession ifNil: [Undeclared purgeUnusedBindings].	^storePundle</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>testing</category><body package="Store-Database Model" selector="isBundle">isBundle	^false.</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>database-utilities</category><body package="Store-Database Model" selector="allNonBinaryNamesIn:">allNonBinaryNamesIn: aSessionOrNil	^self allNamesIn: aSessionOrNil</body><body package="StoreForGlorpVWUI" selector="hasVersionNamed:">hasVersionNamed: aString	"Answer a boolean if there is any version of myself that has the name aString"	^self hasVersionNamed: aString in: nil</body><body package="StoreForGlorpVWUI" selector="hasVersionNamed:in:">hasVersionNamed: aString in: aSessionOrNil	"Answer a boolean if there is any version of myself that has the name aString"	| session query |	session := aSessionOrNil ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	query := Query count: self where: [:each | each name = aString].	^(session execute: query) &gt; 0</body><body package="Store-Database Model" selector="initializeCache">initializeCache	cache := WeakDictionary new.</body><body package="StoreForGlorpVWUI" selector="rename">rename	| names session oldName targetWindow newName |	session := StoreLoginFactory currentStoreSession.	targetWindow := VisualLauncher raiseSingleInstance.	[names := self allNonBinaryNamesIn: session] withStoreFeedbackOn: targetWindow.	names := names asSortedCollection asOrderedCollection.	names isEmpty ifTrue: 		[^Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	oldName := Dialog 		choose: ((#Choose1s &lt;&lt; #store &gt;&gt; 'Choose &lt;1s&gt;...') expandMacrosWith: self class name asClassNameOnly)		fromList: names		values: names		lines: 15		cancel: [^nil]		for: nil.	[newName := SmalltalkWorkbench requestNewPackageName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(names includes: newName)		ifTrue:			[Dialog warn: (#_1sAlreadyExists &lt;&lt; #store &gt;&gt; '&lt;1s&gt; already exists.' expandMacrosWith: newName).			false]		ifFalse: [true]] whileFalse.	[(Renaming for: self from: oldName to: newName) announce.	self rename: oldName to: newName inSession: session] withStoreFeedbackOn: targetWindow.</body><body package="Store-Database Model" selector="rename:to:inSession:">rename: anOldName to: aNewName inSession: aSession	"This method is dangerous. It does not check if aNewName already exists. Also, you MUST have aSession.	Also, after execution, we get rid of the cachedNames for my class "	| targets |	aSession ifNil: [^self].	(targets := self allVersionsWithName: anOldName in: aSession) isEmpty ifTrue: 		[^Dialog warn: #NoPublishedVersions &lt;&lt; #store &gt;&gt; 'No published versions'].	aSession inUnitOfWorkDo:		[targets do:			[:each |			aSession register: each.			each name: aNewName]].	DbRegistry cachedNames removeKey: self ifAbsent: [nil].	DbRegistry highestPrimaryKeyChecked: nil</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:">selectStoreVersionOf: aString	"Produce a dialogue that answers a store pundle object or nil."		^self selectStoreVersionOf: aString in: nil</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:in:">selectStoreVersionOf: aString in: aSession	"Produce a dialogue that answers a store pundle object or nil."		^self selectStoreVersionOf: aString in: aSession warnIfNone: true</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:in:warnIfNone:">selectStoreVersionOf: aString in: aSession warnIfNone: aBoolean	"Produce a dialogue that answers a store pundle object or nil."		| list session |	session := aSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	list := self allVersionsWithName: aString in: session.	list isEmpty ifTrue:		[aBoolean ifTrue: [Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions') asString].		^nil].	list size == 1 ifTrue: [^list first].	^Dialog		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list collect: [:each | each displayString , ' ' , each blessingLevelString])		values: list		lines: 10		cancel: [^nil]		for: nil</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionOf:warnIfNone:">selectStoreVersionOf: aString warnIfNone: aBoolean	"Produce a dialogue that answers a store pundle object or nil."		^self selectStoreVersionOf: aString in: nil warnIfNone: aBoolean</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>private</category><body package="Store-Database Model" selector="cache">cache	cache isNil ifTrue: [cache := WeakDictionary new].	^cache</body><body package="Store-Database Model" selector="cachedItemFor:">cachedItemFor: aStorePundle	| cachedPundle |	aStorePundle ifNil: [^aStorePundle].	cachedPundle := self cache at: aStorePundle primaryKey ifAbsent: [nil].	^(cachedPundle notNil and: [cachedPundle class == self])		ifTrue: [cachedPundle]		ifFalse: 			[self cache at: aStorePundle primaryKey put: aStorePundle.			aStorePundle].</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="newNamed:">newNamed: aString	| instance |	instance := self new.	instance name: aString.	^instance</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>testing</category><body package="Store-Database Model" selector="definesClass:">definesClass: aStoreClass	^self containedItems anySatisfy: 		[:each | each definesClass: aStoreClass]</body><body package="Store-Database Model" selector="definesObject:">definesObject: aStoreNameSpace	^self containedItems anySatisfy: 		[:each | each definesObject: aStoreNameSpace]</body><body package="Store-Database Model" selector="definesSelector:forClass:">definesSelector: aSymbol forClass: aClass		^self		includesSelector: aSymbol		className: aClass absoluteName asClassNameOnly		meta: aClass isMeta</body><body package="StoreForGlorpVWUI" selector="describesBundleNamed:">describesBundleNamed: aString	"Copied from Store.BundleDescription"	"Answer true if the description refers to a bundle named aString"	^self name = aString</body><body package="StoreForGlorpVWUI" selector="describesSameAs:">describesSameAs:  aComponentDescr	"Copied from Store.BundleDescription"	"Answer true if aComponentDescr refers to	a bundle named the same as my bundle"	^aComponentDescr isBundle		and: [ self describesBundleNamed: aComponentDescr name ].</body><body package="Store-Database Model" selector="hasRelatedParcel">hasRelatedParcel	^false</body><body package="StoreForGlorpVWUI" selector="hasValidLoadOrder">hasValidLoadOrder	^true</body><body package="Store-Database Model" selector="includesSelector:className:meta:">includesSelector: aSelector className: aClassName meta: isMeta	^self containedItems anySatisfy: [:each |		each includesSelector: aSelector className: aClassName meta: isMeta].</body><body package="Store-Database Model" selector="isBundle">isBundle	^true.</body><body package="Store-Database Model" selector="isPublishedBinary">isPublishedBinary	^false</body><body package="Store-Database Model" selector="isValid">isValid	self bundles do: [:each | each isValid ifFalse: [^false]].	self packages do: [:each | each isValid ifFalse: [^false]].	^true.</body><body package="Store-Database Model" selector="isValidAsNew">isValidAsNew	"Return true if we are valid as a newly created pundle. This is the same as normal validation, but short-circuits if we already have a primary key, meaning that we're not actually new. So validating e.g. a new bundle, but which contains references to old packages, won't need to revalidate the packages. This assumes that they have already been validated"	self bundles do: [:each | each isValidAsNew ifFalse: [^false]].	self packages do: [:each | each isValidAsNew ifFalse: [^false]].	^true.</body><body package="StoreForGlorpVWUI" selector="needsLoadOrderWarning">needsLoadOrderWarning	^false</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>accessing</category><body package="Store-Database Model" selector="allContainedItems">allContainedItems	| all |	all := OrderedCollection new.	self containedItems do: [:each |		all add: each.		all addAll: each allContainedItems].	^all.</body><body package="Store-Database Model" selector="allItems">allItems	^self allContainedItems</body><body package="Store-Database Model" selector="basicComment">basicComment	^comment</body><body package="Store-Database Model" selector="bundles">bundles	^bundles.</body><body package="Store-Code Comparison" selector="classBlueprints">classBlueprints	^Array new</body><body package="Store-Database Model" selector="containedItems">containedItems	| items |	items := self pundles.	^items keys asSortedCollection asOrderedCollection collect: [:index | items at: index].</body><body package="StoreForGlorpVWUI" selector="dbContent">dbContent	"So that Bundle can initialize itself from us"	^(((bundles associations asArray, packages associations asArray) asSortedCollection: [:x :y | x key &lt; y key]) 		collect: [:each | each value]) asList.</body><body package="Store-Database Model" selector="definedClasses">definedClasses	^self containedItems inject: #() into: [:sum :each |		sum, each definedClasses asArray].</body><body package="StoreForGlorpVWUI" selector="descriptionClass">descriptionClass	^Store.BundleDescription</body><body package="StoreForGlorpVWUI" selector="enclosingBundlesFor:">enclosingBundlesFor: aStorePundle	| target |	target := self containedItems 		detect: [:each | each name = aStorePundle name]		ifNone: [nil].	target ifNotNil: [^Array with: self].	self bundles do:		[:each |		(each enclosingBundlesFor: aStorePundle) ifNotNil: [:value | ^value]].	^nil</body><body package="Store-Database Model" selector="fileDescriptions">fileDescriptions	^self files.</body><body package="Store-Database Model" selector="files">files	files isNil ifTrue: [files := #()].	^files.</body><body package="Store-Database Model" selector="files:">files: aCollection	files := aCollection.</body><body package="Store-Database Model" selector="itemCount">itemCount	^(bundles inject: 0 into: [:sum :each | sum + each itemCount])		+  (packages inject: 0 into: [:sum :each | sum + each itemCount]).</body><body package="Store-Code Comparison" selector="methodBlueprints">methodBlueprints	^Array new</body><body package="Store-Database Model" selector="methods">methods	^self containedItems inject: (OrderedCollection new: 500) into: [:sum :each |		sum addAll: (each methods yourSelf collect: [:eachMethod | eachMethod yourSelf]). sum].</body><body package="Store-Database Model" selector="nameSpaces">nameSpaces	^self containedItems inject: #() into: [:sum :each |		sum, each nameSpaces].</body><body package="Store-Code Comparison" selector="namespaceBlueprints">namespaceBlueprints	^Array new</body><body package="Store-Database Model" selector="packages">packages	^packages.</body><body package="StoreForGlorpVWUI" selector="pseudoPundleClass">pseudoPundleClass	^Store.PseudoBundle</body><body package="Store-Database Model" selector="pundles">pundles	| pundles |	pundles := Dictionary new.	bundles keysAndValuesDo: [:eachKey :eachValue | pundles at: eachKey put: eachValue].	packages keysAndValuesDo: [:eachKey :eachValue | pundles at: eachKey put: eachValue].	^pundles</body><body package="Store-Code Comparison" selector="sharedVariableBlueprints">sharedVariableBlueprints	^Array new</body><body package="Store-Database Model" selector="sharedVariables">sharedVariables	^self containedItems inject: #() into: [:sum :each |		sum, each sharedVariables].</body><body package="Store-Database Model" selector="structure">structure	"Answer an array that reflects the receiver's contents in the form:		#( #( #package name ) #( #bundle name ) .... )"	| answer |	answer := OrderedCollection new.	self componentsInOrderDo: [:eachPundle | 		eachPundle isPackage			ifTrue: [answer add: (Array with: #package with: eachPundle name)]			ifFalse: [answer add: (Array with: #bundle with: eachPundle name)]].	^answer asArray.</body><body package="Store-Database Model" selector="typeStringForBlessing">typeStringForBlessing	^'B'</body><body package="Store-Database Model" selector="withAllItems">withAllItems	^super withAllItems, self allContainedItems</body><body package="Store-Database Model" selector="withContainedItems">withContainedItems	^self containedItems addFirst: self; yourself</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>reconciling</category><body package="Store-Database Model" selector="individualProxyFor:">individualProxyFor: aPundle	"Construct a proxy that reads us back."	| query |	aPundle isGlorpProxy ifTrue: [^aPundle].	"This should never happen, but let's be sure."	aPundle primaryKey isNil ifTrue: [self error: 'Attempt to construct an individual proxy for a package or bundle with no primary key'].	"Construct a slightly sneaky query, to run quickly, because the fields are indexed, but be sure that we don't get a cache hit, which would defeat the proxying."	query := Query readOneOf: aPundle class where: [:each | each primaryKey = aPundle primaryKey &amp; (each timestamp = aPundle timestamp)].	query returnProxies: true.	"Executing the query means it will actually go to the database, then return a proxy, which is a bit of waste of time, but a good deal simpler than constructing a proxy manually"	^aPundle session execute: query.</body><body package="Store-Database Model" selector="makeProxiesForSubcomponents">makeProxiesForSubcomponents	"If we contain sub-bundles or packages, proxy each one individually"	self privateSetBundles: (bundles collect: [:each | self individualProxyFor: each]).	self privateSetPackages: (packages collect: [:each | self individualProxyFor: each]).</body><body package="Store-Database Model" selector="matchesRecursivelyWith:">matchesRecursivelyWith: aStorePundle	"Return true if all of our contents match"	(self ifMatchesWith: aStorePundle do: [^true] else: [^false]).	self bundles size = aStorePundle bundles size ifFalse: [^false].	self packages size = aStorePundle packages size ifFalse: [^false].	self bundles asSortedCollection with: aStorePundle bundles asSortedCollection do: [:ours :theirs |		(ours matchesRecursivelyWith: theirs) ifFalse: [^false]].	self packages asSortedCollection with: aStorePundle packages asSortedCollection do: [:ours :theirs |		(ours matchesRecursivelyWith: theirs) ifFalse: [^false]].	^true.</body><body package="Store-Database Model" selector="matchesWith:">matchesWith: aStorePundle	"Return true if all of our contents match"	(self ifMatchesWith: aStorePundle do: [^true] else: [^false]).	self bundles asSortedCollection = aStorePundle bundles asSortedCollection ifFalse: [^false].	self packages asSortedCollection = aStorePundle packages asSortedCollection ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="reconcile">reconcile	"When we share source with our previous version, use it instead of our own"	super reconcile.	self reconcileBundles.	self reconcilePackages.	self reconcileFiles.</body><body package="Store-Database Model" selector="reconcileBundle:">reconcileBundle: aStoreBundle	^self previous bundles detect: [:each |		aStoreBundle reconcilesWith: each] ifNone: [aStoreBundle].</body><body package="Store-Database Model" selector="reconcileBundles">reconcileBundles	| newBundles |	newBundles := Dictionary new.	bundles		keysAndValuesDo:			[:eachKey :eachValue | newBundles at: eachKey put: (self reconcileBundle: eachValue)].	bundles := newBundles.	bundles do: [:each | 		each username isNil ifTrue: [each username: username].		each timestamp isNil ifTrue: [each timestamp: timestamp]].</body><body package="Store-Database Model" selector="reconcileFile:">reconcileFile: aStoreFile	^self previous files detect: [:each |		aStoreFile reconcilesWith: each] ifNone: [aStoreFile].</body><body package="Store-Database Model" selector="reconcileFiles">reconcileFiles	files := self files collect: [:each | self reconcileFile: each].	files do: [:each | 		each username isNil ifTrue: [each username: username].		each timestamp isNil ifTrue: 			[each timestamp: timestamp.			each privateSetPrimaryKey: nil]].</body><body package="Store-Database Model" selector="reconcilePackage:">reconcilePackage: aStorePackage	^self previous packages detect: [:each |		aStorePackage reconcilesWith: each] ifNone: [aStorePackage].</body><body package="Store-Database Model" selector="reconcilePackages">reconcilePackages	| newPackages |	newPackages := Dictionary new.	packages keysAndValuesDo: [:eachKey :eachValue |		newPackages at: eachKey put: (self reconcilePackage: eachValue)].	packages := newPackages.	packages do: [:each | 		each username isNil ifTrue: [each username: username].		each timestamp isNil ifTrue: [each timestamp: timestamp]].</body><body package="Store-Database Model" selector="uninstantiateSubcomponentProxies">uninstantiateSubcomponentProxies	"This will only work if makeProxiesForSubcomponents has been previous called, to set them up as individual proxies. Used to conserve memory when doing a large iteration."	self bundles do: [:each | each isGlorpProxy ifTrue: [each uninstantiate]].	self packages do: [:each | each isGlorpProxy ifTrue: [each uninstantiate]].</body><body package="Store-Database Model" selector="unreconcile">unreconcile	super unreconcile.	self files do: [:each | each unreconcile].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize	super initialize.	bundles := Dictionary new.	packages := Dictionary new.		files := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>deleting</category><body package="Store-Database Model" selector="delete">delete	"Delete this bundle from the database, and delete all of this packages and sub-bundles associated with it "	| components |	components := self pundles.	self session delete: self.	components do: [:each |		| containing |		containing := session count: StoreBundle where: [:eachContainer |			(each isBundle ifTrue: [eachContainer bundles] ifFalse: [eachContainer packages])				anySatisfy: [:eachSubComponent | eachSubComponent value = each]].		containing = 0 ifTrue: [each delete]]</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>enumerating</category><body package="Store-Database Model" selector="allComponentsDo:">allComponentsDo: aBlock	packages do: aBlock.	bundles do: [:each | 		"ugh. Tolerate malformed bundles from very old Store versions."		each isNil ifFalse: [each allComponentsDo: aBlock]].	aBlock value: self.</body><body package="Store-Database Model" selector="componentsCollect:">componentsCollect: aBlock	| newBundles newPackages |	newBundles := Dictionary new.	bundles keysAndValuesDo: [:eachKey :eachValue |		newBundles at: eachKey put: (aBlock value: eachValue)].	bundles := newBundles.	newPackages := Dictionary new.	packages keysAndValuesDo: [:eachKey :eachValue |		newPackages at: eachKey put: (aBlock value: eachValue)].	packages := newPackages.</body><body package="Store-Database Model" selector="componentsDetect:ifNone:">componentsDetect: aBlock ifNone: missingBlock	| valueInSubBundle |	bundles do: [:eachBundle |		(aBlock value: eachBundle) ifTrue: [^eachBundle].		valueInSubBundle := eachBundle componentsDetect: aBlock ifNone: [nil].		valueInSubBundle isNil ifFalse: [^valueInSubBundle]].	packages do: [:eachPackage |		(aBlock value: eachPackage) ifTrue: [^eachPackage]].	^missingBlock value.</body><body package="Store-Database Model" selector="componentsDo:">componentsDo: aBlock	bundles do: aBlock.	packages do: aBlock.</body><body package="Store-Database Model" selector="componentsInOrderDo:">componentsInOrderDo: aBlock	| keys |	keys := OrderedCollection new addAll: bundles keys; addAll: packages keys; yourself.	keys asSortedCollection do: [:eachKey |		aBlock value: (bundles at: eachKey ifAbsent: [packages at: eachKey])].</body><body package="Store-Database Model" selector="newComponentsDo:">newComponentsDo: aBlock 	"Loop over all our sub-components, but only those which are instantiated and new - that is, have no primary key"	(bundles isGlorpProxy not or: [bundles isInstantiated]) 		ifTrue: 			[bundles do: 					[:each | 					((each isGlorpProxy not or: [each isInstantiated]) 						and: [each primaryKey isNil]) ifTrue: [aBlock value: each]]].	(packages isGlorpProxy not or: [packages isInstantiated]) 		ifTrue: 			[packages do: 					[:each | 					((each isGlorpProxy not or: [each isInstantiated]) 						and: [each primaryKey isNil]) ifTrue: [aBlock value: each]]].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>store faking</category><body package="StoreForGlorpVWUI" selector="asPundleWithComponentDescriptions">asPundleWithComponentDescriptions	"Return a copy of ourselves that has actual store component descriptions instead of our entities. Used in e.g. initializeFromDB: to let Store put things back the way it thinks things ought to be, and not old onto any of our entities. This copy really won't work at all for most purposes. The bundles and packages aren't even going to be dictionaries"	| copy |	copy := self copy.	copy privateSetBundles: #().	copy privateSetPackages: (self pundles collect: [:each | each asComponentDescriptionForReal]).	copy privateSetFiles: (self files collect: [:each | each asComponentDescriptionForReal]).	^copy.</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>fixups</category><body package="Store-Database Model" selector="removeDuplicates">removeDuplicates	"Don't bother removing duplicates if we've already got a primary key. That is, we're already in the database"	self primaryKey isNil ifFalse: [^self].	self bundles do: [:each | each removeDuplicates].	self packages do: [:each | each removeDuplicates].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>private</category><body package="StoreForGlorpVWUI" selector="ownRecordForTag:">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^aTag isComponentTag		ifTrue: [ aTag recordForPackage: self ].</body><body package="Store-Database Model" selector="privateSetBundles:">privateSetBundles: aDictionary	bundles := aDictionary.</body><body package="Store-Database Model" selector="privateSetFiles:">privateSetFiles: aCollection	files := aCollection.</body><body package="Store-Database Model" selector="privateSetPackages:">privateSetPackages: aDictionary	packages := aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>loading</category><body package="StoreForGlorpVWUI" selector="dbLoadWithin:">dbLoadWithin: aBundle	"We are being told to load within the context of a Store.Bundle. Turn ourselves into an appropriate Store entity and do what it would do in these circumstances"	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource).	self loadSource</body><body package="Store-Database Model" selector="directCompileAndLoad">directCompileAndLoad	| bundleModel |	Glorp.Dialect reset.	(Loading for: self) started.	(self preCompileWith: nil) ifFalse: 		[(Loading for: self) finished.		^nil].	(self getImagePundle isNil) ifTrue: 		[self runPreRead ifFalse: 			[(Loading for: self) finished.			^nil]].	bundleModel := self createImagePundle.	self storeModel: bundleModel.	self componentsInOrderDo: 		[:each | each directCompileAndLoad].	self postLoad: bundleModel.	self resetStoreModel.	bundleModel cleanse: false.	self applyPundleVersionsToTheImage.	bundleModel markNotModified.	(Loading for: self) finished.	^bundleModel</body><body package="Store-Database Model" selector="downloadFiles">downloadFiles		| allFiles |	allFiles := self files copy.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	(DownloadingFiles for: self) started.	Store.Policies filePolicy downloadFiles: allFiles.	(DownloadingFiles for: self) finished</body><body package="Store-Database Model" selector="downloadFilesUsing:">downloadFilesUsing: aBundleCompilationResult		| allFiles |	allFiles := self files copy.	(self leafItems collect: 		[:each | 		each isBundle			ifTrue: [each files]			ifFalse: [#()]]) do: 				[:each | allFiles addAll: each].	allFiles size &gt; 0 ifFalse: [^self].	Store.Policies filePolicy downloadFiles: allFiles using: aBundleCompilationResult</body><body package="Store-Database Model" selector="postLoad:">postLoad: aPundleModel	super postLoad: aPundleModel.	self downloadFiles.</body><body package="Store-Database Model" selector="postLoad:using:">postLoad: aPundleModel using: aBundleCompilationResult 	super postLoad: aPundleModel.	self downloadFilesUsing: aBundleCompilationResult.	aPundleModel cleanUpOverrides.	aPundleModel markNotModified</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>constants</category><body package="Store-Database Model" selector="componentType">componentType	^#bundle</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	| newBundles newPackages |	super postCopyIn: aDictionary.	newBundles := Dictionary new.	bundles keysAndValuesDo:  [:eachKey :eachValue | newBundles at: eachKey put: (eachValue glorpCopyIn: aDictionary)].	newPackages := Dictionary new.	"Note that we don't copy the packages. This is to stop us from prematurely instantiating and copying package versions from the database that we don't need to touch. At a different point we will figure out if we want to use the corresponding version from the database, or if we need to copy this. See StorePundleWriter&gt;&gt;pundleVersionToUseFor:withPreviousParentVersion:"	packages keysAndValuesDo:  [:eachKey :eachValue | newPackages at: eachKey put: eachValue].	bundles := newBundles.	packages := newPackages.	files := files collect: [:each | each glorpCopyIn: aDictionary].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>printing</category><body package="Store-Database Model" selector="describeContents">describeContents	| stream |	stream := WriteStream on: String new.	self describeContentsOn: stream level: 0.	^stream contents</body><body package="StoreForGlorpVWUI" selector="describeContentsOn:level:">describeContentsOn: aStream level: anInteger		self containedItems do:		[:each | 		anInteger timesRepeat: [aStream tab].		aStream			nextPutAll: (each stringKey: #());			cr.		each isBundle ifTrue: [each describeContentsOn: aStream level: anInteger + 1]]</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>full classes</category><body package="Store-Database Model" selector="fullClasses">fullClasses	^self containedItems inject: #() into: [:sum :each  |		sum, each fullClasses asArray].</body><body package="Store-Database Model" selector="resetFullClasses">resetFullClasses	self containedItems do: [:each | each resetFullClasses].</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>compatibility</category><body package="Store-Database Model" selector="definesName:in:">definesName: aSymbol in: aNameSpace	"Bundles don't define stuff as such"	^false</body><body package="Store-Database Model" selector="descriptionsAndLevels">descriptionsAndLevels	"Answer a list of pairs. The first element contains a descriptions the second the 	level on which the description was found. This should be in the order that the components occur within the bundle."	| descriptionsAndLevels items |	items := self pundles.	descriptionsAndLevels := OrderedCollection new.	items keys asSortedCollection do: [:index | | pundle |		pundle := items at: index. 		descriptionsAndLevels add: (Array with: pundle with: 1).		pundle isBundle 			ifTrue: [								descriptionsAndLevels addAll: (pundle descriptionsAndLevels 					collect: [:eachArray | Array with: eachArray first with: eachArray last + 1])]].	^descriptionsAndLevels.</body><body package="StoreForGlorpVWUI" selector="fileContent">fileContent	"So that Bundle can initialize itself from us"	^self files.</body><body package="StoreForGlorpVWUI" selector="leafItems">leafItems	| items |	items := OrderedCollection new.	self allComponentsDo: [:each |		each isPackage ifTrue: [items add: each]].	^items.</body><body package="StoreForGlorpVWUI" selector="setName">setName</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>private-file out</category><body package="StoreForGlorpVWUI" selector="fileOutOn:">fileOutOn: aFileManager	"File out the bundle on aFileManager"	self		fileOutOn: aFileManager		withoutRepeatingAnyOf: Set new</body><body package="StoreForGlorpVWUI" selector="fileOutOn:withoutRepeatingAnyOf:">fileOutOn: aSourceCodeStream withoutRepeatingAnyOf: aSet	"File out bundle on aFileManager"		(aSet includes: self) ifTrue: [^self].	aSourceCodeStream createdComponent: self.	aSourceCodeStream cr.	aSourceCodeStream addComment: (#Bundle1s &lt;&lt; #packages &gt;&gt; 'Bundle &lt;1s&gt;' expandMacrosWith: self itemString).	(UI.UISettings preferenceFor: #fileoutOption) == #never ifFalse: [self fileOutPropertiesOn: aSourceCodeStream].	self containedItems do:		[:each | 		each fileOutOn: aSourceCodeStream withoutRepeatingAnyOf: aSet.		aSet add: each].	aSourceCodeStream bundleStructure: self</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>comparing</category><body package="Store-Database Model" selector="computeDifferencesBetween:into:">computeDifferencesBetween: aBundle into: aComparitor	"A bundle does not compare itself for class/namespace/shared/methods differences"	^self</body><body package="StoreForGlorpVWUI" selector="computeDiffsBetween:into:">computeDiffsBetween: aBundle into: aComparitor	| other |	other := (aBundle class = self class or: [aBundle pseudoPackage])		ifTrue: [aBundle] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aBundle primaryKey]].	^other computeDiffsBetweenDBBundle: self into: aComparitor</body><body package="StoreForGlorpVWUI" selector="computeDiffsBetweenDBBundle:into:">computeDiffsBetweenDBBundle: aDBBundle into: aComparitor	"Store  differences between receiver and a aDBPackage into an instance of 	PackageDifferences. Store receiver's definitions as number2 since this method	is called with arguments reversed. "	| myPackages his other otherBundle |	otherBundle := aDBBundle class = self class 		ifTrue: [aDBBundle] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aDBBundle primaryKey]].			myPackages := self leafItems.	his := otherBundle leafItems.	myPackages do: [:each |		other := his detect: [:eachOtherPackage | eachOtherPackage name = each name] ifNone: [nil].		each computeDiffsBetweenDBPackage: other into: aComparitor.		other ifNotNil: [his remove: other]].	his do: [:each |		each computeDiffsBetweenDBPackage: nil into: aComparitor].</body><body package="StoreForGlorpVWUI" selector="descriptionAndLevels:level:">descriptionAndLevels: aCollection level: anInteger		self containedItems do:		[:each | 		aCollection add: (Array with: each with: anInteger).		each isBundle ifTrue: [each descriptionAndLevels: aCollection level: anInteger + 1]].	^aCollection</body><body package="StoreForGlorpVWUI" selector="uniqueItemsAndLevels">uniqueItemsAndLevels	"Answer a colleciton of description level pairs"	| collection |	collection := OrderedCollection new.	self descriptionAndLevels: collection level: 1.	^collection</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>utilities</category><body package="Store-Database Model" selector="allVersionPrimaryKeysWithFile:">allVersionPrimaryKeysWithFile: aStoreFile	^self class allVersionPrimaryKeysWithFile: aStoreFile in: session</body><body package="Store-Database Model" selector="sharesFile:">sharesFile: aStoreFile	"Answer back a Boolean if another Bundle shares the passed in StoreFile"	^self class sharesFile: aStoreFile in: session</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="defaultCompileManager">defaultCompileManager	^ShadowBundleCompileManager</body><body package="Glorp Atomic Compiling" selector="preCompileWith:">preCompileWith: aCompilationManager	"Before we compile the bundle, check all of its contained items to ensure that its 	 prerequisities are met.  If they are, then run any pre-read actions.  Return false	 if any of the pre-read actions fail, of if prerequisites are not satisified.  This has a 	 side-effect of loading only those properties that are needed for loading."	| allItems |	allItems := self withAllUniqueItems.	^allItems allSatisfy: [:each | each checkPrerequisitesWithin: self with: aCompilationManager]</body><body package="Glorp Atomic Compiling" selector="pundleInstallClass">pundleInstallClass	^BundleInstall</body></methods><methods><class-id>Store.Glorp.StoreBundle</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there.	Unlike other 'records' for tag objects, we answer a tag with the package(pundle) being me"	^aTag copy		package: self; 		yourself</body><body package="StoreForGlorpVWUI" selector="recordForTag:">recordForTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there."		aTag isComponentTag ifTrue: [^aTag recordForPackage: self].	self leafItems do:		[:each | 		| tagOrStoreObjectInPackage |		(tagOrStoreObjectInPackage := each recordForTag: aTag) ifNotNil: [^tagOrStoreObjectInPackage]].	^nil</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>constants</category><body package="StoreForGlorpVWUI" selector="imageClass">imageClass	^Store.BundleModel</body><body package="Store-Database Model" selector="propertyTypeCode">propertyTypeCode	^0.</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>testing</category><body package="Store-Database Model" selector="isBundle">isBundle	^true.</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>accessing</category><body package="Store-Database Model" selector="enclosingComponentsFor:in:">enclosingComponentsFor: aStorePundle in: aSession	| queryBlock query |	queryBlock := aStorePundle isBundle		ifTrue: [ [:each | each bundles anySatisfy: [:eachPundle | eachPundle = aStorePundle]]]		ifFalse: [ [:each | each packages anySatisfy: [:eachPundle | eachPundle = aStorePundle]]].	query := Query readManyOf: self where: queryBlock.	^aSession execute: query</body><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	^BehaviorIcons BundleDisconnected</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>query utility</category><body package="Store-Database Model" selector="allVersionPrimaryKeysWithFile:in:">allVersionPrimaryKeysWithFile: aStoreFile in: aSession	"Answer back all versions of this Bundle that share the passed in File"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each files includes: aStoreFile].	query retrieve: [:each | each primaryKey distinct].	^(session execute: query)</body><body package="Store-Database Model" selector="sharesFile:in:">sharesFile: aStoreFile in: aSession	"Answer back all versions of this Bundle that share the passed in File"	| session query |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query count: self where: [:each | each files includes: aStoreFile].	^(session execute: query) ~= 1</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="environment:">environment: anEnvironment	environment := anEnvironment</body><body package="StoreForGlorpBrowserUI" selector="glorpSession">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI" selector="nameSpaceForName:ifAbsent:">nameSpaceForName: aString ifAbsent: aBlock	^environment nameSpaceForName: aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="navigatorClass">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI" selector="openEditor">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI" selector="pundleNamed:isPackage:">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body><body package="StoreForGlorpBrowserUI" selector="repositoryName">repositoryName	^environment repositoryName</body><body package="StoreForGlorpBrowserUI" selector="sharedVariable:for:">sharedVariable: aName for: aClassOrNameSpace	^environment sharedVariable: aName for: aClassOrNameSpace asString</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id> <category>adding</category><body package="StoreForGlorpBrowserUI" selector="addClass:selector:">addClass: aClass selector: aSymbol 	definitions add: (StoreMethodDefinition class: aClass selector: aSymbol).	super addClass: aClass selector: aSymbol</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI" selector="at:ifAbsent:">at: className ifAbsent: aBlock	^environment at: className ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="classForName:ifAbsent:">classForName: aString ifAbsent: aBlock	^environment classForName:  aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="classesDo:">classesDo: aBlock 	classSelectors keysDo: 		[:each | 		| class |		class := environment classForName: each.		(class notNil and: [environment includesClass: class]) 			ifTrue: [aBlock value: class]].	metaClassSelectors keysDo: 		[:each | 		| class |		class := environment classForName: each.		(class notNil and: [environment includesClass: class storeMetaClass]) 			ifTrue: [aBlock value: class storeMetaClass]]</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinitionEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI" selector="implementorsMatching:in:">implementorsMatching: aString in: anEnvironment	^self implementorsOf: aString in: anEnvironment</body><body package="StoreForGlorpBrowserUI" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copy].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copy]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body><body package="StoreForGlorpBrowserUI" selector="new">new	^self onEnvironment: StoreForGlorpBrowserEnvironment new</body></methods><methods><class-id>Store.FileModel</class-id> <category>testing</category><body package="Store-IMG-Configurations" selector="isBundle">isBundle	^false.</body><body package="Store-IMG-Configurations" selector="isForFile">isForFile	^true</body></methods><methods><class-id>Store.FileModel</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="asDBDescription">asDBDescription	^self class partClass new		fileRef: self primaryKey;		"??"		bundleRef: bundle primaryKey;		yourself</body><body package="Store-IMG-Configurations" selector="bundle">bundle	^bundle</body><body package="Store-IMG-Configurations" selector="bundle:">bundle: ourBundle	bundle := ourBundle</body><body package="Store-IMG-Configurations" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent this component type in the database."	^FileRecord</body><body package="Store-IMG-Configurations" selector="component">component	"Find a component named componentName and answer it."	^self</body><body package="Store-IMG-Configurations" selector="dbTrace">dbTrace	^dbtrace</body><body package="Store-IMG-Configurations" selector="dbTrace:">dbTrace: anIneger	dbtrace := anIneger</body><body package="Store-IMG-Configurations" selector="filename">filename	^name == nil		ifTrue: [ nil ]		ifFalse: [ LogicalFilename named: name ].</body><body package="Store-IMG-Configurations" selector="itemCount">itemCount	^1</body><body package="Store-IMG-Configurations" selector="name">name	^portableFilename asString	"^name asString"</body><body package="Store-IMG-Configurations" selector="name:">name: aString	name := aString asFilename.</body><body package="Store-IMG-Configurations" selector="portableFilename">portableFilename	^portableFilename</body><body package="Store-IMG-Configurations" selector="portableFilename:">portableFilename: anObject	portableFilename := anObject</body><body package="Store-IMG-Configurations" selector="primaryKey">primaryKey	^dbtrace</body><body package="Store-IMG-Configurations" selector="textForItem">textForItem	^name</body></methods><methods><class-id>Store.FileModel</class-id> <category>printing</category><body package="Store-IMG-Configurations" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name, '(', self portableFilename asString, ')'.</body></methods><methods><class-id>Store.FileModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asComponentDescription">asComponentDescription	^self.</body></methods><methods><class-id>Store.FileModel class</class-id> <category>constants</category><body package="Store-IMG-Configurations" selector="partClass">partClass	^Files</body></methods><methods><class-id>Store.FileModel class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="from:">from: aFilename	^super new		name: aFilename;		portableFilename: aFilename asLogicalFileSpecification;		yourself.</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading" selector="compileWith:">compileWith: anAtomicAnalysisLoader	[[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDefinedRecord: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader unloadableDefinitions add: (exception definitionRecord: self).			exception resume]]				on: VariableConfirmation 				do: [:exception | exception resume: false]]					on: RedefinitionNotification					do: 						[:notification |						anAtomicAnalysisLoader overrides add: notification.						override := true.						notification resume]</body><body package="Atomic Compiling and Loading" selector="installWith:">installWith: anAtomicAnalysisLoader	[[anAtomicAnalysisLoader installSharedBinding: self]		on: RedefinitionNotification		do:			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			(self packageModel name = currentPackage name or: [currentPackage name = Registry nullPackageName]) 				ifFalse: 					[self fixAndInstallNotification: notification.					anAtomicAnalysisLoader overrides add: notification].			notification resume]]				on: VariableConfirmation				do: [:notification | notification resume: false]</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="from:">from: aStoreSharedVariableInPackage	super from: aStoreSharedVariableInPackage.	longName := aStoreSharedVariableInPackage longName.	ownerName := aStoreSharedVariableInPackage definition environmentName.</body><body package="Atomic Compiling and Loading" selector="from:in:">from: aStoreSharedVariable in: aStorePackage	super from: aStoreSharedVariable in: aStorePackage.	longName := aStoreSharedVariable longName.	ownerName := aStoreSharedVariable environmentName.</body><body package="Atomic Compiling and Loading" selector="longName">longName	^longName</body><body package="Atomic Compiling and Loading" selector="ownerName">ownerName	^ownerName</body></methods><methods><class-id>Store.ShadowedSharedVariableObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	aStream nextPutAll: 'aShadowedShared('.	aStream nextPutAll: self longName.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.Glorp.StoreDatabaseTable</class-id> <category>accessing</category><body package="Store-Database Model" selector="propertyAt:">propertyAt: aSymbol	^properties at: aSymbol ifAbsent: [nil]</body><body package="Store-Database Model" selector="propertyAt:put:">propertyAt: aSymbol put: anObject	anObject isNil ifTrue: [^properties removeKey: aSymbol ifAbsent: [nil]].	properties at: aSymbol put: anObject</body></methods><methods><class-id>Store.Glorp.StoreDatabaseTable</class-id> <category>initialize</category><body package="Store-Database Model" selector="initialize">initialize	super initialize.	properties := IdentityDictionary new</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="conflictsWithImage">conflictsWithImage		"Answer true if the receiver's name conflicts with something already		in the image."	^self fullName asStrictReference isDefined</body><body package="Store-DB-Records" selector="definitionClass">definitionClass		^Blob</body><body package="Store-DB-Records" selector="definitionRecord">definitionRecord	"Create a new record in the database that holds the source code."	^self class definitionClass fromString: definitionStr</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="absoluteName">absoluteName	^self fullName</body><body package="Store-DB-Records" selector="absoluteSymbol">absoluteSymbol	^self absoluteName asSymbol</body><body package="Store-DB-Records" selector="actual">actual		"Answer the object represented by the receiver as it exists in the image."	^self object</body><body package="Store-DB-Records" selector="comment">comment	| aString |	aString := self commentStr.	aString size = 0 ifTrue: [ ^'' ].	^aString	"get string only of classComment, undoubling quotes   ???""	^String readFromString: aString  "</body><body package="Store-DB-Records" selector="commentID">commentID	"Answer the receiver's commentID."	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: newCommentID	"Set the receiver's commentID to newCommentID."	commentID := newCommentID</body><body package="Store-DB-Records" selector="commentStr">commentStr	"Allow for lazy evaluation."	^commentStr isNil		ifTrue: [commentStr := self getDefinitionID: self commentID]		ifFalse: [commentStr]</body><body package="Store-DB-Records" selector="commentStr:">commentStr: aValue	commentStr := aValue</body><body package="Store-DB-Records" selector="definition">definition	| str |	str := self definitionStr.	^( str isEmpty not and: [ str first == $&lt; ] )		ifTrue: [ self convertFromXML: str ]		ifFalse: [ str ]</body><body package="Store-DB-Records" selector="definitionAndComment">definitionAndComment	^self class mergeDefinition: self definition andComment: self comment</body><body package="Store-DB-Records" selector="definitionID">definitionID	"Answer the receiver's definitionID."	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: newDefinitionID	"Set the receiver's definitionID to newDefinitionID."	definitionID := newDefinitionID</body><body package="Store-DB-Records" selector="definitionStr">definitionStr	"Allow for lazy evaluation."	^definitionStr isNil		ifTrue: [definitionStr := self getDefinitionID: self definitionID]		ifFalse: [definitionStr]</body><body package="Store-DB-Records" selector="definitionStr:">definitionStr: aValue	definitionStr := aValue</body><body package="Store-DB-Records" selector="definitionString">definitionString	^self definition</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: aString	environmentString := aString</body><body package="Store-DB-Records" selector="fullName">fullName	^BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.</body><body package="Store-DB-Records" selector="fullyQualifiedPath">fullyQualifiedPath	^self environmentString == nil		ifTrue: [ '' ]		ifFalse: [ environmentString ].</body><body package="Store-DB-Records" selector="nameSpace">nameSpace		"Answer the receiver's containing NameSpace as it exists in the image.		nil if not there."  "May be a class' namespace."	| obj |	^( obj := self owner ) == nil		ifTrue: [ obj ]		ifFalse: [ obj asNameSpace ]</body><body package="Store-DB-Records" selector="nameSpaceName">nameSpaceName	^self fullyQualifiedPath</body><body package="Store-DB-Records" selector="object">object		"Answer the object represented by the receiver as it exists in the image."	^self fullName asStrictReference valueOrDo: [ nil ]</body><body package="Store-DB-Records" selector="owner">owner		"Answer the receiver's container as it exists in the image.		nil if not there."	^( self environmentString == nil or: [ environmentString isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ environmentString asStrictReference valueOrDo: [ nil ] ].</body><body package="Store-DB-Records" selector="ownerName">ownerName		"Answer the receiver's owner's name. nil if not there."	^( self environmentString == nil or: [ environmentString isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ environmentString ].</body><body package="Store-DB-Records" selector="package">package	^package </body><body package="Store-DB-Records" selector="package:">package: pkg	package := pkg</body><body package="Store-DB-Records" selector="realname">realname	^name</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefinition">shadowLoadDefinition	"Subclasses may need special definition strings and thus may need to change their version of this method"	^self definition</body><body package="Store-DB-Records" selector="sourceCode">sourceCode	"Answer a definition"	^self definition</body><body package="Store-DB-Records" selector="sourceCode:">sourceCode: aValue	"Set the definition string. To have the same protocol as method records"	definitionStr := aValue</body><body package="Store-DB-Records" selector="xmlDefinition">xmlDefinition	| str |	str := self definitionStr.	^(str isEmpty or: [str first == $&lt;])		ifTrue: [str]		ifFalse: [self convertToXML: str]</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="&lt;=">&lt;= aDescriptor	^self name &lt;= aDescriptor name</body><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^anObject absoluteName asClassNameOnly = self absoluteName</body><body package="Store-DB-Records" selector="hash">hash	^self name hash</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^self subclassResponsibility</body><body package="Store-DB-Records" selector="quickComparesTo:">quickComparesTo: anObject		"Answer true if anObject could be another version of the receiver."		"For comparing differenct db versions."	self  class == anObject class		ifFalse: [ ^false ].	name = anObject name and: [ self environmentString = anObject environmentString ].</body><body package="Store-DB-Records" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version."	^self sameAsImThing: self asDescriptor</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="convertFromXML:">convertFromXML: aString	^self subclassResponsibility</body><body package="Store-DB-Records" selector="convertToXML:">convertToXML: aString	^self subclassResponsibility</body><body package="Store-DB-Records" selector="convertVariableNodeToXML:">convertVariableNodeToXML: aParseNode	| eName |	eName := (aParseNode respondsTo: #name)			ifTrue: [aParseNode name asString]			ifFalse: [aParseNode value == nil				ifTrue: ['nil']				ifFalse: [aParseNode value isBindingReference					ifTrue: [aParseNode value asString]					ifFalse: [self error: #ExpectedToFindAGlobalReferenceHere &lt;&lt; #store &gt;&gt; 'Expected to find a global reference here']]].	('Smalltalk.#*' match: eName)		ifTrue: [eName := eName copyFrom: 'Smalltalk.*' size to: eName size].	^eName</body><body package="Store-DB-Records" selector="convertXMLNameToSmalltalk:quoted:">convertXMLNameToSmalltalk: aString quoted: shouldBeQuoted	| eName |	aString = 'nil' ifTrue: [^aString].	eName := aString.	((eName includes: $.) or: [eName = 'Smalltalk'])		ifFalse: [eName := 'Smalltalk.', eName].	shouldBeQuoted		ifTrue: [eName := '#{', eName, '}'].	^eName</body><body package="Store-DB-Records" selector="loadDefinition:into:logged:">loadDefinition: aString into: anImagePackage logged: aBoolean	"Load the receiver into the image by compiling it's definition.	Ensure that it gets into imgPackage (NOTE: only neccessary if definition not being evaluated)."		| classOrNamespace |	classOrNamespace := self object.	classOrNamespace := [[Object evaluatorClass evaluate: aString notifying: nil logged: aBoolean]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: Error			do: 				[:exception | 				UnloadableDefinitionError new					originalError: exception;					parameter: self;					raise].	IncrementNotification raiseSignal.	^classOrNamespace</body><body package="Store-DB-Records" selector="loadDefinition:logged:">loadDefinition: aString logged: logFlag	"Load the receiver into the image by compiling it's definition."	"DS- took out optimazation of not compiling  unchanged defs."	IncrementNotification raiseSignal.	^Object evaluatorClass "subclassDefinerClass"		evaluate: aString		notifying: nil		logged: logFlag.</body><body package="Store-DB-Records" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	self subclassResponsibility</body><body package="Store-DB-Records" selector="prepareInstallation">prepareInstallation	"Create first records for both definition string and comment string."	self definitionID == nil		ifTrue: [ self definitionID: 	(self class definitionClass fromString: definitionStr) primaryKey ].	self commentID == nil		ifTrue: 			[ self commentID: 				( ( commentStr isNil or: [ commentStr isEmpty ] )					ifTrue: [ 0 ]					ifFalse: [ ( self class definitionClass fromString: commentStr ) primaryKey ]				  )			].</body><body package="Store-DB-Records" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"	super prime.	definitionStr := Object new.	commentStr := Object new.	version := Object new.	package := Object new.</body><body package="Store-DB-Records" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	definitionStr notNil ifTrue: 		[ self definitionStr: ( self processString: self definitionStr ) ].	commentStr notNil 		ifTrue: [ self commentStr: ( self processString: self commentStr ) ]</body><body package="Store-DB-Records" selector="sax:tag:value:">sax: driver tag: tag value: value	driver startElement: tag atts: nil.	driver characters: value.	driver endElement</body><body package="Store-DB-Records" selector="unprime">unprime	"Nil out the slots that do not map to table columns"	super unprime.	definitionStr := nil.	commentStr := nil.	version := nil.	package := nil.</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>public interface</category><body package="Store-DB-Records" selector="load">load	| record |	record := self loadDefinition.	self loadCommentFor: record</body><body package="Store-DB-Records" selector="loadCommentFor:">loadCommentFor: aLoadedRecord 	"Given the loadedClass set the record's comment."	(self class commentFor: aLoadedRecord) ~= self comment 		ifTrue: [ aLoadedRecord comment: self comment ]</body><body package="Store-DB-Records" selector="loadDefinition">loadDefinition	"Load the defintion only"	^self loadDefinition: self definition logged: true</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>filing out</category><body package="Store-DB-Records" selector="fileOutCommentOn:">fileOutCommentOn: aStream	"Fileout the receiver's  comment on a stream."	self comment isEmpty 		ifFalse: [ aStream comment: self value: self commentStr ].	"	IncrementNotification raiseSignal. "</body><body package="Store-DB-Records" selector="fileOutDefinitionOn:">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	aStream storeObjectDefinition: self.</body><body package="Store-DB-Records" selector="fileOutDifferencesBetween:on:">fileOutDifferencesBetween: other on: aStream	"Create a file that upon filing in brings transforms other into myself."	( other == nil or: [ other definition ~= self definition ] ) 		ifTrue: [ aStream storeObjectDefinition: self ].	( other == nil or: [ other comment ~= self comment ] ) 		ifTrue: 			[ self comment isEmpty 				ifFalse: [ aStream comment: self value: self commentStr ].			].	IncrementNotification raiseSignal.</body><body package="Store-DB-Records" selector="fileOutSourceOn:">fileOutSourceOn: aStream	"File the receiver out on aSourceFileManager.	If I'm a Meta definition, then file out my instanceBehavior"	self isMeta 		ifTrue: [self object instanceBehavior fileOutDefinitionOn: aStream]		ifFalse: [self fileOutDefinitionOn: aStream].	self fileOutCommentOn: aStream.	IncrementNotification raiseSignal.</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="fullDisplayString">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;)' 		expandMacrosWith: self displayString 		with: self versionString</body><body package="Store-DB-Records" selector="storeOn:">storeOn: aStream	"Append to the argument aStream the global names of the receiver."	aStream nextPutAll: self fullName</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>change list support</category><body package="Store-DB-Records" selector="text">text	"Asnwer the text to display in a text window."	^self definition</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>testing</category><body package="Store-DB-Records" selector="isMeta">isMeta	^false</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>db-accessing</category><body package="Store-DB-Records" selector="allVersionsNamed:">allVersionsNamed: aName 	"Given a name of a NameSpace answer a collection of all versions of the space in the database.	NameSpaceRecord allVersionsNamed: 'Smalltalk'	ClassRecord allVersionsNamed: 'TT_Class'"	| versions simpleName |	simpleName := (BindingReference pathString: aName) simpleName.	versions := self 		executeSQL: ((self newSQL)			selectAll;			where;			column: #name equalTo: simpleName asString printString)		onError: [self table select: [:each | each name = aName asString]].	^versions asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]</body><body package="Store-DB-Records" selector="selectVersionNamed:">selectVersionNamed: aName 	| list |	list := self allVersionsNamed: aName.	list isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	list size == 1 ifTrue: [^list first].	^Dialog 		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (list collect: [:m | m itemString])		values: list		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes		"self fieldTypes"	| aDict  |	( aDict := super fieldTypes )		at: 'commentID' put: #Integer;		at: 'definitionID' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Records" selector="needsSequence">needsSequence	^true</body><body package="Store-DB-Records" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 2M NEXT 512K PCTINCREASE 1) '</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>private</category><body package="Store-DB-Records" selector="newFrom:">newFrom: anObject	"anObject is a property, namespace, class or data object"		| instance |	instance := self		from: anObject		timeStamp: self timeStamp		trace: nil.	instance install.	^instance</body><body package="Store-DB-Records" selector="newOrExistingFrom:trace:">newOrExistingFrom: anObject trace: aDefinedRecord	"Answer an instance of the receiver, if a trace is the same as an object answer the trace class.	If either definition or comment for a trace class is the same reuse it."		| instance |	instance := self		from: anObject		timeStamp: self timeStamp		trace: aDefinedRecord.	aDefinedRecord definition string = instance definition string ifTrue: 		[instance definitionID: aDefinedRecord definitionID].	aDefinedRecord commentStr string = instance commentStr string ifTrue: 		[instance commentID: aDefinedRecord commentID].	^(instance commentID = aDefinedRecord commentID and: [instance definitionID = aDefinedRecord definitionID])		ifTrue: [aDefinedRecord]		ifFalse:			[instance install.			instance]</body><body package="Store-DB-Records" selector="recordFor:trace:">recordFor: anObject trace: aDefinedRecord	"anObject is a property, namespace, class or data object"		^aDefinedRecord isNil		ifTrue: [self newFrom: anObject]		ifFalse: [self newOrExistingFrom: anObject trace: aDefinedRecord]</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="fromView:">fromView: aView	| newDBRecord |	newDBRecord := self new.	self moveFieldsFrom: aView to: newDBRecord.	newDBRecord processFields.	^newDBRecord</body><body package="Store-DB-Records" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord	aDBRecord		primaryKey: aView primaryKey;		name: aView name;		timeStamp: aView timeStamp;	 	version: aView version;	 	userName: aView userName;	 	dbTrace: aView dbTrace;	 	definitionID: aView definitionID;	 	commentID: aView commentID;		environmentString: aView environmentString.</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"		"TT_Class columnNames"	^super columnNames		remove: 'commentStr';		remove: 'definitionStr';		remove: 'version';		remove: 'package';		yourself.</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>utility</category><body package="Store-DB-Records" selector="mergeDefinition:andComment:">mergeDefinition: definitionString andComment: aComment	^definitionString string, 'COMMENT:', aComment string</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="recordsReferingToCommentID:">recordsReferingToCommentID: aDefinitionID 	"Collect records that use a given definition record as a comment. 	Answer a collection of IDs."	"Should only be sent to a specific subclass."	"self classesReferingToCommentID: 149745"	| ids |	ids := self broker process: 				( self newSQL					select: #( primaryKey );					where;					column: #commentID equalTo: aDefinitionID printString).	ids size &gt; 1 ifTrue: [ids := ids collect: [:each| each first]].	^ids</body><body package="Store-DB-Records" selector="recordsReferingToDefinitionID:">recordsReferingToDefinitionID: aDefinitionID 	"Collect Records that refer to a given definition record. 	Answer a collection of IDs."	"Should only be sent to a concrete subclass."	"self classesReferingToDefinitionID: 149744"	| ids |	ids := self broker process: 					( self newSQL						select: #( primaryKey );						where;						column: #definitionID equalTo: aDefinitionID printString).	^ids collect: [ :each | each first ]</body></methods><methods><class-id>Store.DataElement</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="convertFromXML:">convertFromXML: aString	| p element out attr value i |	p := XML.XMLParser on: aString readStream.	element := p validate: false; getNextChar; element.	out := (String new: 128) writeStream.	out nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'environment') characterData			quoted: false).	out nextPutAll: ' defineSharedVariable: ';		store: (element elementNamed: 'name') characterData asSymbol.	out crtab; nextPutAll: 'private: ';		nextPutAll: (element elementNamed: 'private') characterData.	out crtab; nextPutAll: 'constant: ';		nextPutAll: (element elementNamed: 'constant') characterData.	out crtab; nextPutAll: 'category: ';		store: (element elementNamed: 'category') characterData.	out crtab; nextPutAll: 'initializer: ';		store: (element elementNamed: 'initializer') characterData.	attr := [element elementNamed: 'attributes'] on: Error do: [:ex | ex return: nil].	attr == nil ifFalse:		[out crtab; nextPutAll: 'attributes: #('.		attr elements do: [:elm |			elm isElement ifTrue:				[out crtab: 3; nextPutAll: '#('; store: elm tag type asSymbol; space.				((elm elements contains: [:e | e isElement]) or: [elm elements isEmpty])					ifTrue: [value := (elm elements select: [:e | e isElement])							collect: [:e | e characterData]]					ifFalse:						[value := elm characterData.						i := #('nil' 'true' 'false') indexOf: value.						value := i = 0 ifTrue: [value asSymbol] ifFalse: [#(nil true false) at: i]].				out store: value; nextPutAll: ')']].		out nextPutAll: ')'].	^out contents</body><body package="Store-DB-Subdefs" selector="convertToXML:">convertToXML: aString	| parse driver data sName eName init |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'shared-variable' atts: nil.	sName := (data at: 'defineSharedVariable:' ifAbsent: [data at: 'defineStatic:']) value asString.	self sax: driver tag: 'name' value: sName.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'constant' value: (data at: 'constant:') value printString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	init := ( init := (data at: 'initializer:' ) value ) == nil		ifFalse: [ self sax: driver tag: 'initializer' value: init asString ].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body><body package="Store-DB-Subdefs" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	XChangeSet current moveDataKey: self dataKey owner: self owner toPackage: imgPackage</body></methods><methods><class-id>Store.DataElement</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="displayString">displayString	^self name</body><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	aStream nextPutAll: 'Element{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body><body package="Store-UI-Comparitors" selector="statusLineString">statusLineString	^self protocolName</body></methods><methods><class-id>Store.DataElement</class-id> <category>support</category><body package="Store-DB-Subdefs" selector="textForItem">textForItem	^self itemString asText</body></methods><methods><class-id>Store.DataElement</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="absoluteOwnerName">absoluteOwnerName	^environmentString</body><body package="Store-DB-Subdefs" selector="dataKey">dataKey	^name asSymbol</body><body package="Store-DB-Subdefs" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Subdefs" selector="environmentString:">environmentString: aString	environmentString := aString</body><body package="Store-DB-Subdefs" selector="inClass">inClass		"Set typeString to indicate receiver is in a Class."	typeString := 'C'.</body><body package="Store-DB-Subdefs" selector="inNameSpace">inNameSpace		"Set typeString to indicate receiver is in a NameSpace."	typeString := 'N'</body><body package="Store-DB-Subdefs" selector="key">key	^self dataKey</body><body package="Store-DB-Subdefs" selector="protocol">protocol	^protocolName isNil		ifTrue: [ #unknown ]		ifFalse: [ protocolName asSymbol ]</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body><body package="Store-DB-Subdefs" selector="setTypeString:">setTypeString: anObject	anObject isBehavior		ifTrue: [ self inClass ]		ifFalse: [ self inNameSpace ]</body><body package="Store-DB-Subdefs" selector="stDocumentation">stDocumentation	^self commentStr isNil		ifTrue: [ '' ]		ifFalse: [ commentStr ].</body><body package="Store-DB-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag		^self definition</body><body package="Store-DB-Subdefs" selector="typeString">typeString	^typeString</body><body package="Store-DB-Subdefs" selector="typeString:">typeString: aString	typeString := aString.</body></methods><methods><class-id>Store.DataElement</class-id> <category>testing</category><body package="Store-DB-Subdefs" selector="isForData">isForData	^true</body><body package="Store-DB-Subdefs" selector="isForGeneral">isForGeneral	^true</body><body package="Store-DB-Subdefs" selector="isInClass">isInClass		"Answer true if the receiver resides in a Class."	^typeString ~~ nil and: [ typeString = 'C' ].</body><body package="Store-DB-Subdefs" selector="isInNameSpace">isInNameSpace		"Answer true if the receiver resides in a NameSpace."		"This is the default."	^typeString == nil or: [ typeString = 'N' ]</body></methods><methods><class-id>Store.DataElement</class-id> <category>public interface</category><body package="Store-DB-Subdefs" selector="loadSrc">loadSrc	"Load the datum. Answer true if the installation was successful."	IncrementNotification raiseSignal.	self nameSpace == nil		ifTrue: 			[ UnloadableDefinitionError signalWith: self.			^false			].	[ [ Compiler evaluate: self definitionStr ] 		on: VariableConfirmation do: [ :ex | ex resume: false ]	] on: UnhandledException do:		[ :e | UnloadableDefinitionError signalWith: self.		^false		]."	XChangeSet current removeDataKeyChanges: self dataKey owner: ns namedReferent.  "	^true</body><body package="Store-DB-Subdefs" selector="loadSrcInto:">loadSrcInto: imagePackage	"Load the definition for the receiver into imagePackage."	self loadSrcIntoPackage: imagePackage confirm: false</body><body package="Store-DB-Subdefs" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean 	"Load the datum. Make sure that it goes to the imPkg. and it does not	overwrites existing definition form another package."	aBoolean ifTrue: 		[(Dialog confirm: #DoYouWantToLoadTheSelectedData &lt;&lt; #store &gt;&gt; 'Do you want to load the selected data?') ifFalse: [^self]].	(LoadAnalyzer canLoadDatum: self from: imPkg) ifTrue: 		[Policies packagePolicy forcePackage: imPkg while: [self loadSrc]]</body><body package="Store-DB-Subdefs" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveStatic: self dataKey		ownerName: self environmentString		isInNameSpace: self isInNameSpace		package: aPackage</body></methods><methods><class-id>Store.DataElement</class-id> <category>converting</category><body package="Store-DB-Subdefs" selector="asDescriptor">asDescriptor	"Answer an instance of DatumDescriptor."	^self isInClass		ifTrue: [ 	DatumDescriptor fromDataKey: self dataKey className: self environmentString ]		ifFalse: [ DatumDescriptor fromDataKey: self dataKey nameSpaceName: self environmentString ]</body><body package="Store-DB-Subdefs" selector="asTag">asTag	"Answer an instance of TT_DataTag."	^self isInClass		ifTrue: [ 	DataTag newClassName: self environmentString dataKey: self dataKey ]		ifFalse: [ DataTag newNameSpaceName: self environmentString dataKey: self dataKey ]</body></methods><methods><class-id>Store.DataElement</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( super comparesTo: anObject ) 		ifFalse: [ ^false ].	self isInClass = anObject isInClass		ifFalse: [ ^false ].	^self dataKey = anObject dataKey</body><body package="Store-DB-Subdefs" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForData</body><body package="Store-DB-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aDatum 	"When comparing with DB - the definition has it all"	"Note: at the moment, no comments for data."	^self definition = aDatum definition</body><body package="Store-DB-Subdefs" selector="sameAsImThing:">sameAsImThing: aDatum 	"When comparing with DB - the definition has it all"	"Note: at the moment, no comments for data."	^self definition = aDatum definition</body><body package="Store-DB-Subdefs" selector="sourceMatches:">sourceMatches: aDataElement 	"Answer whether the source matches.	Note: since protocol is part of the definition, we don't need to check it."	^aDataElement notNil and: [self definition equalsAcrossPlatforms: aDataElement definition]</body></methods><methods><class-id>Store.DataElement</class-id> <category>fileout</category><body package="Store-DB-Subdefs" selector="fileOutOn:">fileOutOn: aFileManager	aFileManager storeObjectDefinition: self.</body></methods><methods><class-id>Store.DataElement</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="containingPackages">containingPackages	^[( Data packagesContainingDatum: primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body></methods><methods><class-id>Store.DataElement</class-id> <category>shadow support</category><body package="Atomic Compiling and Loading" selector="belongsToClass">belongsToClass	"Answer true if the receiver depends on a class (ie method or shared in a class)"		^self isInClass</body></methods><methods><class-id>Store.DataElement class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="moveDatum:">moveDatum: aDatum	"Ask for destination package and move the datum."	| dPkg   dataKey |		( aDatum isNil or: [ aDatum isLoaded not ] )		ifTrue: [ ^false ].	dataKey := aDatum dataKey.	( dPkg := PackageChooser chooseOrAdd ) isNil ifTrue: [ ^false ].	XChangeSet current 		moveDataKey: dataKey		owner: aDatum owner		toPackage: dPkg.	^true</body></methods><methods><class-id>Store.DataElement class</class-id> <category>instance creation</category><body package="Store-DB-Subdefs" selector="from:timeStamp:trace:">from: bindingReference timeStamp: timeStamp trace: oldDB		"create an instance from a InitializedVariableBinding."	| env binding sname |	env := bindingReference environment.	binding := bindingReference binding.	sname := bindingReference simpleName asString.	^self new		name: sname;		environmentString: env absoluteName;		setTypeString: env;		timeStamp: timeStamp;		definitionStr:  binding binding source;		protocolName: ( self protocolNameFor: sname in: env ); 		commentStr: nil;  	"MAY BE: binding binding comment"		setTrace: oldDB;		yourself.</body><body package="Store-DB-Subdefs" selector="fromDescriptor:timeStamp:trace:">fromDescriptor: datumDescriptor timeStamp: timeStamp trace: oldDBDatum 	| owner |	owner :=datumDescriptor owner.	^self new 		name: datumDescriptor dataKey asString;		 timeStamp: timeStamp; 		environmentString: owner absoluteName;		setTypeString: owner;		definitionStr: datumDescriptor sourceCode;		protocolName: datumDescriptor protocol; 		setTrace: oldDBDatum;		yourself</body><body package="Store-DB-Subdefs" selector="fromOwner:named:timeStamp:trace:">fromOwner: owner named: aName timeStamp: timeStamp trace: oldDBDatum 	^( self new ) name: aName asString;		 timeStamp: timeStamp; 		environmentString: owner absoluteName;		setTypeString: owner;		definitionStr: ( owner asNameSpace definitionOf: aName ifAbsent: [nil] );		protocolName: ( self protocolNameFor: aName in: owner ); 		setTrace: oldDBDatum</body><body package="Store-DB-Subdefs" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord	super moveFieldsFrom: aView to: aDBRecord.	aDBRecord protocolName: aView protocolName.	aDBRecord typeString: aView typeString.</body></methods><methods><class-id>Store.DataElement class</class-id> <category>public interface</category><body package="Store-DB-Subdefs" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| set |	self error: #WhatAreWeDoingHere &lt;&lt; #store &gt;&gt; 'What are we doing here?'.	( set := aSet copy )		remove: #methods ifAbsent: [];		remove: #data ifAbsent: [].		super loadComponents: set package: aDBPackage.</body></methods><methods><class-id>Store.DataElement class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="associationClass">associationClass	^Data</body><body package="Store-DB-Subdefs" selector="commentFor:">commentFor: aBinding	^''			"until bindings have comments"</body><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn	^#dataRef</body><body package="Store-DB-Subdefs" selector="sourcesViewClass">sourcesViewClass	^DataAndSourcesView</body></methods><methods><class-id>Store.DataElement class</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="compare:key:in:">compare: dbDatum key: dataKey in: owner		"Answer true if dbDatum reflects the image."	 ( dbDatum == nil  or: [ dataKey ~= dbDatum dataKey ] )		ifTrue: [ ^false ].	^( owner asNameSpace definitionOf: dataKey ifAbsent: [ ^false ] )		= dbDatum definition</body><body package="Store-DB-Subdefs" selector="newNamed:inOwner:trace:package:">newNamed: aName inOwner: owner trace: oldDBDatum package: aDBPackage	| newDBDatum  |	newDBDatum := self				fromOwner: owner				named: aName				timeStamp: self timeStamp				trace: oldDBDatum.	(oldDBDatum notNil and: [oldDBDatum sourceCode = newDBDatum sourceCode])		ifTrue: [newDBDatum encodedDataID: oldDBDatum encodedDataID]."	newDBDatum creatorPackage: aDBPackage primaryKey.  "	newDBDatum install.	^newDBDatum</body><body package="Store-DB-Subdefs" selector="protocolNameFor:in:">protocolNameFor: aString in: owner		"Answer the protocol for aString in a namespace or class."	| protocolName |	protocolName := owner asNameSpace organization categoryOfElement: aString.	^protocolName isNil		ifTrue: [ 'unclassified' ]		ifFalse: [ protocolName asString ]</body><body package="Store-DB-Subdefs" selector="recordFromDescriptor:trace:package:">recordFromDescriptor: datumDescriptor trace: oldDBDatum package: aDBPackage	| newDBDatum  |"	Transcript show: 'Creating new data ' , owner fullName, '&gt;&gt;', aName; cr; flush. "	newDBDatum := 		self fromDescriptor: datumDescriptor 			timeStamp: self timeStamp 			trace: oldDBDatum.	( oldDBDatum notNil and: [oldDBDatum sourceCode = newDBDatum sourceCode ] )		ifTrue: [ newDBDatum encodedDataID: oldDBDatum encodedDataID ].	newDBDatum install.	^newDBDatum</body><body package="Store-DB-Subdefs" selector="recordNamed:inOwner:trace:package:">recordNamed: dataKey inOwner: owner trace: oldDBDatum package: aDBPackage	"Answer a record for aDatum. If the trace is identical as aDatum 	answer the trace instead creating a new record."	^( self compare: oldDBDatum key: dataKey in: owner )			ifTrue: [oldDBDatum]			ifFalse: 				[ self					newNamed: dataKey					inOwner: owner					trace: oldDBDatum					package: aDBPackage				]</body></methods><methods><class-id>Store.DataElement class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on methodRef to speed up	garbage collection process."	^self broker createIndexForClass: self</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on methodRef to speed up	garbage collection process."	^self broker dropIndexForClass: self</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames	^ Array with: 'sourceCodeID'</body><body package="Store-DB-Subdefs" selector="indexName">indexName	^ '_DEF_IDX'</body></methods><methods><class-id>Store.DataElement class</class-id> <category>utilities</category><body package="Store-DB-Subdefs" selector="sortStaticsForLoading:">sortStaticsForLoading: elementCollection	"Answer elementCollection ordered by namespace using class/namespace load order."	| dict ordered |	"First group all the data by class/namespace"	dict := IdentityDictionary new.	elementCollection do:		[ :dataElement | | ns |		( ns := dataElement owner ) == nil			ifTrue: [ 	UnloadableDefinitionError signalWith: dataElement ]			ifFalse: 				[ ( dict at: ns ifAbsentPut: [ OrderedCollection new ] )					add: dataElement.				]		].	ordered := OrderedCollection new: elementCollection size.	( SystemUtils sortForLoading: dict keys ) do:		[ :ns | ordered addAll: ( dict at: ns ) ].	^ordered.</body></methods><methods><class-id>Store.DataElement class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="allVersionsNamed:in:">allVersionsNamed: aName in: ownerName	"Given a name of a dataelement answer a collection of all versions 	of the space in the database."	"self allVersionsNamed: 'DataSession' in: TT_DataView absoluteName"	^( self allVersionsNamed: aName )		select: [ :de | de environmentString = ownerName ]</body><body package="Store-DB-Subdefs" selector="selectVersionNamed:">selectVersionNamed: aName	^self shouldNotImplement</body><body package="Store-DB-Subdefs" selector="selectVersionNamed:in:">selectVersionNamed: aName in: ownerName 	| list |	list := self allVersionsNamed: aName in: ownerName.	list isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	list size == 1 ifTrue: [^list first].	^Dialog 		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (list collect: [:m | m itemString])		values: list		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.DataElement class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes		"self fieldTypes"	| aDict  |	( aDict := super fieldTypes )		at: 'typeString' put: #Char.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="component">component	^package</body><body package="Atomic Compiling and Loading" selector="externalClassesNeedingRecompile">externalClassesNeedingRecompile	^externalClassesNeedingRecompile</body><body package="Atomic Compiling and Loading" selector="externalClassesNeedingRecompile:">externalClassesNeedingRecompile: anObject	externalClassesNeedingRecompile := anObject</body><body package="Atomic Compiling and Loading" selector="installed">installed	^installed</body><body package="Atomic Compiling and Loading" selector="installed:">installed: aBoolean	installed := aBoolean</body><body package="Atomic Compiling and Loading" selector="installedWithoutBundlePostLoad">installedWithoutBundlePostLoad	^installed</body><body package="Atomic Compiling and Loading" selector="leafItems">leafItems	^Array with: self</body><body package="Atomic Compiling and Loading" selector="methodsMovedFromOriginalBinding">methodsMovedFromOriginalBinding	^methodsMovedFromOriginalBinding</body><body package="Atomic Compiling and Loading" selector="methodsMovedFromOriginalBinding:">methodsMovedFromOriginalBinding: aCollection	methodsMovedFromOriginalBinding := aCollection</body><body package="Atomic Compiling and Loading" selector="needsEarlyInstall:">needsEarlyInstall: aBoolean		needsEarlyInstall := aBoolean</body><body package="Atomic Compiling and Loading" selector="overridden">overridden	^overridden</body><body package="Atomic Compiling and Loading" selector="overridden:">overridden: aCollection	overridden := aCollection</body><body package="Atomic Compiling and Loading" selector="overrides">overrides		^overrides</body><body package="Atomic Compiling and Loading" selector="overrides:">overrides: aCollection		overrides := aCollection</body><body package="Atomic Compiling and Loading" selector="package">package	^package</body><body package="Atomic Compiling and Loading" selector="package:">package: anObject	package := anObject</body><body package="Atomic Compiling and Loading" selector="packageDifferences">packageDifferences	^packageDifferences</body><body package="Atomic Compiling and Loading" selector="packageDifferences:">packageDifferences: anObject	packageDifferences := anObject</body><body package="Atomic Compiling and Loading" selector="pundle">pundle	^self package.</body><body package="Atomic Compiling and Loading" selector="results">results	^nil</body><body package="Atomic Compiling and Loading" selector="resultsFromParent">resultsFromParent	^nil</body><body package="Atomic Compiling and Loading" selector="shadowedObjects">shadowedObjects	^shadowedObjects</body><body package="Atomic Compiling and Loading" selector="shadowedObjects:">shadowedObjects: anObject	shadowedObjects := anObject</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitions">unloadableDefinitions	^unloadableDefinitions</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitions:">unloadableDefinitions: anObject	unloadableDefinitions := anObject</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitionsForBrowsing">unloadableDefinitionsForBrowsing	"Answer a collection of Unloadable with the package set."	| pkg |	pkg := package createImagePundle.	unloadableDefinitions do:		[ : def | def package: pkg ].	^unloadableDefinitions</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="finishInstall">finishInstall	"I do nothing but am here for being polymorphic with BundleCompilationResult"</body><body package="Atomic Compiling and Loading" selector="install">install	AtomicLoader new installCompilationResult: self.</body><body package="Atomic Compiling and Loading" selector="installWithoutBundlePostLoad">installWithoutBundlePostLoad	"We actually DO do a post load, but for Polymorphic reasons with the Bundle result, we let this go"	^self installWithoutPostLoad</body><body package="Atomic Compiling and Loading" selector="installWithoutPostLoad">installWithoutPostLoad	"We actually DO do a post load, but for Polymorphic reasons with the Bundle result, we let this go"	^AtomicLoader new installCompilationResult: self.</body><body package="Atomic Compiling and Loading" selector="markContentsInstalled">markContentsInstalled	installed := true.	package ifNotNil: 		[package applyPundleVersionsToTheImage.		package storeModel markNotModified]</body><body package="Atomic Compiling and Loading" selector="markContentsInstalled:">markContentsInstalled: aBoolean	installed := true.	package ifNotNil: 		[package applyPundleVersionsToTheImage.		aBoolean ifFalse: [package storeModel markNotModified]]</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="classForCompiledMethod:">classForCompiledMethod: aCompiledMethod		| class |	^(class := aCompiledMethod mclass nonMeta) isInStandardEnvironment		ifTrue: [class]		ifFalse: [class standardEnvironmentClass ifNil: [class]]</body><body package="Atomic Compiling and Loading" selector="hasChanges">hasChanges	packageDifferences ifNotNil: [packageDifferences isEmpty ifFalse: [^true]].	shadowedObjects isEmpty ifFalse: [^true].	^unloadableDefinitions isEmpty not</body><body package="Atomic Compiling and Loading" selector="hasChangesToLoad">hasChangesToLoad	^self hasChanges</body><body package="Atomic Compiling and Loading" selector="hasShadowClassMatching:">hasShadowClassMatching: aClass	^shadowedObjects anySatisfy: [:each | each = aClass]</body><body package="Atomic Compiling and Loading" selector="hasShadowMethodMatching:">hasShadowMethodMatching: aCompiledMethod	^shadowedObjects anySatisfy: [:each | each = aCompiledMethod and: [each mclass = aCompiledMethod mclass]]</body><body package="Atomic Compiling and Loading" selector="isAtomicallyLoadable">isAtomicallyLoadable	^isAtomicallyLoadable and: [unloadableDefinitions isEmpty]</body><body package="Atomic Compiling and Loading" selector="isAtomicallyLoadable:">isAtomicallyLoadable: aBoolean	isAtomicallyLoadable := aBoolean.</body><body package="Atomic Compiling and Loading" selector="isCodeReader">isCodeReader	^false</body><body package="Atomic Compiling and Loading" selector="isCompilationResult">isCompilationResult	^true</body><body package="Atomic Compiling and Loading" selector="isForBundle">isForBundle	^false</body><body package="Atomic Compiling and Loading" selector="isFullyLoaded">isFullyLoaded	"Answer true if no there are no unloadables"	^unloadableDefinitions isEmpty</body><body package="Atomic Compiling and Loading" selector="needsEarlyInstall">needsEarlyInstall	needsEarlyInstall == true ifTrue: [^true].	((shadowedObjects select: [:each | each isKindOf: CompiledMethod]) anySatisfy:		[:each | 		((self classForCompiledMethod: each) includesBehavior: Scanner) or: [((self classForCompiledMethod: each) includesBehavior: SmalltalkCompiler) or: [(self classForCompiledMethod: each) = ExternalInterface]]]) 			ifTrue: [^true].	((shadowedObjects select: [:each | each isBehavior]) anySatisfy:		[:each |		(each includesBehavior: Scanner) or: [each includesBehavior: SmalltalkCompiler]])			ifTrue: [^true].	package propertyAt: #installBeforeContinuing ifAbsent: [^false].	^true</body></methods><methods><class-id>AtomicCompilationResult</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="description">description	^self printString</body><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $&lt;;		nextPutAll: package name;		nextPut: $&gt;.</body></methods><methods><class-id>AtomicCompilationResult class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="from:">from: aShadowPackageCompileManager	^self new		package: aShadowPackageCompileManager package;		shadowedObjects: aShadowPackageCompileManager shadowedObjects;		unloadableDefinitions: aShadowPackageCompileManager unloadableDefinitions;		packageDifferences: aShadowPackageCompileManager packageDifferences;		isAtomicallyLoadable: aShadowPackageCompileManager isAtomicallyLoadable;		overrides: aShadowPackageCompileManager overrides;		overridden: OrderedCollection new;		externalClassesNeedingRecompile: aShadowPackageCompileManager externalClassesNeedingRecompile;		methodsMovedFromOriginalBinding: aShadowPackageCompileManager methodsMovedFromOriginalBinding;		needsEarlyInstall: aShadowPackageCompileManager needsEarlyInstall;		installed: false;		yourself</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="connectionStatus">connectionStatus	^self isConnected		ifTrue: ['Connected']		ifFalse: ['']</body><body package="Store-DB-BaseObjects" selector="isConnected">isConnected	^DbRegistry connectedProfileHolder value = self</body><body package="Store-DB-BaseObjects" selector="tableOwner">tableOwner	^tableOwner</body><body package="Store-DB-BaseObjects" selector="tableOwner:">tableOwner: aString 	tableOwner := aString</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>initialize-release</category><body package="Store-DB-BaseObjects" selector="initialize">initialize	super initialize.	tableOwner := 'BERN'.</body><body package="Store-DB-BaseObjects" selector="initializeFromXml:">initializeFromXml: anElement 	name := anElement valueOfAttribute: 'name' ifAbsent: [self error: (#invalidFileFormat &lt;&lt; #store &gt;&gt; 'invalid file format') asString].	driverClassName := self valueOf: anElement childNamed: 'driver-class-name'.	environment := self valueOf: anElement childNamed: 'environment'.	userName := self valueOf: anElement childNamed: 'user-name'.	password := self valueOf: anElement childNamed: 'password'.	tableOwner := self valueOf: anElement childNamed: 'table-owner'.	self isValid ifFalse: [self error: #invalidAttributesSpecifiedInTheFile &lt;&lt; #store &gt;&gt; 'invalid attributes specified in the file']</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="addXmlElementsTo:">addXmlElementsTo: anElement	anElement		addNode: (self elementFor: 'driver-class-name' with: self driverClassName);		addNode: (self elementFor: 'environment' with: self environment);		addNode: (self elementFor: 'user-name' with: self userName);		addNode: (self elementFor: 'password' with: self password);		addNode: (self elementFor: 'table-owner' with: self tableOwner)</body><body package="Store-DB-BaseObjects" selector="asXmlNode">asXmlNode	| root |	root := Element 		tag: 'store-repository' 		attributes: (Array with: (Attribute name: 'name' value: name))		elements: nil.	self addXmlElementsTo: root.	^root</body><body package="Store-DB-BaseObjects" selector="elementFor:with:">elementFor: tagString with: contentsString	^(Element tag: tagString)		addNode: (XML.Text text: contentsString)</body><body package="Store-DB-BaseObjects" selector="valueOf:childNamed:">valueOf: anElement childNamed: aString 	| children textElement |	children := (anElement elementNamed: aString) children.	children isEmpty ifTrue: [^String new].	textElement := children first.	textElement isText ifFalse: [self error: #invalidFileFormat &lt;&lt; #store &gt;&gt; 'invalid file format'].	^textElement text</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asGlorpDatabase">asGlorpDatabase	self driverClassName asString = 'PostgreSQLEXDIConnection' ifTrue: [^Glorp.PostgreSQLPlatform new].	self driverClassName asString = 'OracleConnection' ifTrue: [^Glorp.OraclePlatform new].	self driverClassName asString = 'OracleThreadedConnection' ifTrue: [^Glorp.OraclePlatform new].	self driverClassName asString = 'ODBCConnection' ifTrue: [^Glorp.AccessPlatform new].	self driverClassName asString = 'MS_SQLServerConnection' ifTrue: [^Glorp.SQLServerPlatform new].	self driverClassName asString = 'InterBaseConnection' ifTrue: [^Glorp.FirebirdPlatform new].	self driverClassName asString = 'SQLite3Connection' ifTrue: [^Glorp.SQLite3Platform new].	self driverClassName asString = 'DB2Connection72' ifTrue: [^Glorp.DB2Platform new].	self driverClassName asString = 'DB2Connection' ifTrue: [^Glorp.DB2Platform new].	^self error: 'Please add missing EXDI-Glorp mapping here'</body><body package="StoreForGlorpVWUI" selector="asGlorpLogin">asGlorpLogin	| database |	database := self asGlorpDatabase.	^(Store.Glorp.StoreLogin new)		name: self name;		username: self userName;		password: self password;		connectString: self environment;		database: database;		driverClassName: self driverClassName asString;		"Postgres doesn't use the table owner"		schema: (database supportsTableOwners ifFalse: [''] ifTrue: [self tableOwner]);		yourself.</body></methods><methods><class-id>Store.ConnectionProfile class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="fromXmlElement:">fromXmlElement: anElement	^self new initializeFromXml: anElement</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>aspects</category><body package="Store-UI" selector="databaseHolder">databaseHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseHolder isNil		ifTrue:			[databaseHolder := String new asValue]		ifFalse:			[databaseHolder]</body><body package="Store-UI" selector="databaseListHolder">databaseListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseListHolder isNil		ifTrue:			[databaseListHolder := List new asValue]		ifFalse:			[databaseListHolder]</body><body package="Store-UI" selector="environmentHolder">environmentHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentHolder isNil		ifTrue:			[environmentHolder := String new asValue]		ifFalse:			[environmentHolder]</body><body package="Store-UI" selector="nameHolder">nameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameHolder isNil		ifTrue:			[nameHolder := String new asValue]		ifFalse:			[nameHolder]</body><body package="Store-UI" selector="passwordHolder">passwordHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordHolder isNil		ifTrue:			[passwordHolder := String new asValue]		ifFalse:			[passwordHolder]</body><body package="Store-UI" selector="tableOwnerHolder">tableOwnerHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerHolder isNil		ifTrue:			[tableOwnerHolder := String new asValue]		ifFalse:			[tableOwnerHolder]</body><body package="Store-UI" selector="userNameHolder">userNameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameHolder isNil		ifTrue:			[userNameHolder := String new asValue]		ifFalse:			[userNameHolder]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	self initializeAspects.	self databaseListHolder value: self knownDatabaseInterfaces</body><body package="Store-UI" selector="profile:">profile: aConnectionProfile	profileHolder value: aConnectionProfile</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>private</category><body package="Store-UI" selector="canAccept">canAccept	^self validateRequiredValues and: [self validateName]</body><body package="Store-UI" selector="hasRequiredValues">hasRequiredValues	^(self isProvided: self nameHolder value)		and: [(self isProvided: self databaseHolder value)		and: [self isProvided: self userNameHolder value]]</body><body package="Store-UI" selector="initializeAspects">initializeAspects	profileHolder := ValueHolder new.	acceptTrigger := false asValue.	nameHolder := self profileAspect: #name.	databaseHolder := self profileAspect: #driverClassName.	environmentHolder := self profileAspect: #environment.	userNameHolder := self profileAspect: #userName.	passwordHolder := self profileAspect: #password.	tableOwnerHolder := self profileAspect: #tableOwner</body><body package="Store-UI" selector="isProvided:">isProvided: anObject	^anObject notNil and: [anObject notEmpty]</body><body package="Store-UI" selector="knownDatabaseInterfaces">knownDatabaseInterfaces	| result |	result := OrderedCollection new.	SQLBroker allSubclasses do: 		[:sb | 		(sb class includesSelector: #connectionClass) 			ifTrue: [result add: sb connectionClass name]].	^result</body><body package="Store-UI" selector="nameIsUnique">nameIsUnique	| name |	name := self nameHolder value.	^(RepositoryManager repositories anySatisfy: [:any | any name = name]) not		or: [profileHolder value name = name]</body><body package="Store-UI" selector="profileAspect:">profileAspect: aSymbol	| aspect |	aspect := (AspectAdaptor forAspect: aSymbol)		subjectChannel: profileHolder;		yourself.	^BufferedValueHolder subject: aspect triggerChannel: acceptTrigger</body><body package="Store-UI" selector="validateName">validateName	^self nameIsUnique		ifTrue: [true]		ifFalse:			[Dialog warn:				((#nameXIsAlreadyInUsePleaseChooseAnother &lt;&lt; #dialogs &gt;&gt; 'The name "&lt;1s&gt;" is already in use. Please choose a different name.')					expandMacrosWith: self nameHolder value).			false]</body><body package="Store-UI" selector="validateRequiredValues">validateRequiredValues	^self hasRequiredValues		ifTrue: [true]		ifFalse:			[Dialog warn: #aBunchOfValuesAreRequired &lt;&lt; #dialogs &gt;&gt; 'Name, interface, and a user name are required'.			false]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>actions</category><body package="Store-UI" selector="ok">ok	self canAccept ifTrue:		[acceptTrigger value: true.		self accept value: true]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog class</class-id> <category>instance creation</category><body package="Store-UI" selector="openOn:">openOn: aConnectionProfile	^self new		profile: aConnectionProfile;		open</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>aspects</category><body package="Store-UI" selector="repositoryHolder">repositoryHolder	^nil asValue</body><body package="Store-UI" selector="repositoryListHolder">repositoryListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^repositoryListHolder isNil		ifTrue:			[repositoryListHolder :=  SelectionInListSortAware new.			repositoryListHolder selectionIndexHolder compute:				[:v |				self repositoryHolder value: repositoryListHolder selection].			repositoryListHolder]		ifFalse:			[repositoryListHolder]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>initialize-release</category><body package="Store-UI" selector="manager:">manager: aManager	super manager: aManager.	manager triggerChannel onChangeSend: #triggered to: self</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self repositorySelectionChanged</body><body package="Store-UI" selector="setting:">setting: aStoreRepositoryListSetting	setting := aStoreRepositoryListSetting.	self repositoryListHolder list: setting profiles.	self repositoryListHolder selectionIndexHolder		onChangeSend: #repositorySelectionChanged to: self.</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>private</category><body package="Store-UI" selector="accept">accept	setting installProfiles</body><body package="Store-UI" selector="reset">reset	setting resetProfiles.	self repositoryListHolder list: setting profiles</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>actions</category><body package="Store-UI" selector="addRepository">addRepository	| newProfile |	newProfile := ConnectionProfile new.	newProfile name: (#Repository1p &lt;&lt; #store &gt;&gt; 'Repository &lt;1p&gt;'  expandMacrosWith: self repositoryListHolder list size + 1).	(RepositoryPropertiesDialog openOn: newProfile) 		ifTrue: 			[(self repositoryListHolder list)				add: newProfile;				sortWith: [:a :b | a name &lt; b name].			self repositoryListHolder selection: newProfile.			manager tickle]</body><body package="Store-UI" selector="importSnapshots:">importSnapshots: aCollection	| snapshot newProfiles |	snapshot := aCollection detect: [:some | some id = setting id] ifNone: [^self].	newProfiles := List new.	snapshot stateNodes do:		[:each |		newProfiles add: (ConnectionProfile fromXmlElement: each)].	self repositoryListHolder list		removeAllSuchThat: [:each | true];		addAll: newProfiles.	self tickle</body><body package="Store-UI" selector="removeRepository">removeRepository	self repositoryListHolder selectionDo:		[:selection |		(Dialog confirm: #RemoveThisRepositoryQ &lt;&lt; #labels &gt;&gt; 'Remove this repository?')			ifTrue: 				[self repositoryListHolder list remove: selection.				manager tickle]]</body><body package="Store-UI" selector="repositoryProperties">repositoryProperties	self repositoryListHolder selectionDo:		[:selection |		RepositoryPropertiesDialog openOn: selection.		manager tickle]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>notifications</category><body package="Store-UI" selector="repositorySelectionChanged">repositorySelectionChanged	| hasSelection |	builder isNil ifTrue: [^self].	hasSelection := self repositoryListHolder selection notNil.	#(removeButton propertiesButton) do:		[:each | (self wrapperAt: each) isEnabled: hasSelection]</body><body package="Store-UI" selector="triggered">triggered	manager triggerChannel value 		ifTrue: [self accept]		ifFalse: [self reset]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>accessing</category><body package="Store-UI" selector="settings">settings	^Array with: setting</body></methods><methods><class-id>Store.Pundle</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="canBePublishedToCurrentDatabase">canBePublishedToCurrentDatabase	"For a database pundle, this means, can be modified in the current db. In other words,	is this pundle in the current database."	^self isInCurrentDatabase</body><body package="Store-DB-Pundles" selector="existsInImage">existsInImage	^false</body><body package="Store-DB-Pundles" selector="hasBeenModified">hasBeenModified	"We are in the DB so we can not be modified."	^false</body><body package="Store-DB-Pundles" selector="isBundle">isBundle	^false</body><body package="Store-DB-Pundles" selector="isPackage">isPackage	^false</body><body package="Store-DB-Pundles" selector="isParcel">isParcel	^false</body><body package="Store-DB-Pundles" selector="pseudoPackage">pseudoPackage	"Answer false since I'm genuine."	^false</body></methods><methods><class-id>Store.Pundle</class-id> <category>relationships</category><body package="Store-DB-Pundles" selector="elementLabel:">elementLabel: hints 	"This method returns a visual component used to represent me in a 	browser graph."	| lab |	lab := LabelAndIcon with: (self stringKey: hints)				attributes: (TextAttributes styleNamed: #systemDefault).	lab icon: (AbstractTool iconForPundle: self).	^lab</body><body package="Store-DB-Pundles" selector="relatedBy:">relatedBy: token 	""	token == #tt_derivesRel		ifTrue: 			[| kids imPun |			kids := (self class allVersionsWithTrace: self primaryKey) asOrderedCollection.			imPun := self getImagePundle.			(imPun notNil and: [imPun dbTrace = self primaryKey])				ifTrue: [kids add: imPun].			^kids].	token == #tt_derivesRRel ifTrue: [^Set with: self parentRecord].	^super relatedBy: token</body><body package="Store-DB-Pundles" selector="stringKey:">stringKey: hints 	^(hints includes: #blessing)		ifTrue: [Policies blessingPolicy stringKeyFor: self versionString blessingLevel: self blessingLevelNumber]		ifFalse: [primaryKey == nil				ifTrue: [name]				ifFalse: [self displayString]]</body></methods><methods><class-id>Store.Pundle</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="allDatabases">allDatabases	"Answer a collection of datbase identifiers that the receiver has links to"	^Array with: dbIdentifier</body><body package="Store-DB-Pundles" selector="allEnclosingComponents">allEnclosingComponents	"Answer a collection of all enclosing bundles."	| coll |	coll := self enclosingComponents asSet.	coll copy do: [ :bundle | coll addAll: bundle allEnclosingComponents ].	^coll</body><body package="Atomic Compiling and Loading" selector="allItems">allItems	"Default to just me"	^Array with: self</body><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription	^self descriptionClass new		id: primaryKey;		dbIdentifier: dbIdentifier;		componentName: name;		yourself</body><body package="Store-DB-Pundles" selector="asDBDescription">asDBDescription	^self subclassResponsibility</body><body package="Store-DB-Pundles" selector="blessingLevel">blessingLevel	"Answer the receiver's blessingLevel."	^blessingLevel</body><body package="Store-DB-Pundles" selector="blessingLevel:">blessingLevel: newBlessingLevel	"Set the receiver's blessingLevel to newBlessingLevel."	blessingLevel := newBlessingLevel</body><body package="Store-DB-Pundles" selector="blessingLevelNumber">blessingLevelNumber	"Answer the value of my blessing.."	^( self  blessingLevel == nil )		ifTrue: [ 0 ]		ifFalse: 			[ self blessingLevel isString				ifTrue: [ self blessingLevel asNumber ]				ifFalse: [ self blessingLevel ]			].</body><body package="Store-DB-Pundles" selector="blessingLevelString">blessingLevelString	"Answer the name of my blessing.."	^Policies blessingPolicy blessingName: self blessingLevelNumber.</body><body package="Store-DB-Pundles" selector="comment">comment	"Return empty string if the comment is not set."	| str |	^(str := self commentOrNil) isNil		ifTrue: ['']		ifFalse: [str]</body><body package="Store-DB-Pundles" selector="comment:">comment: aString 	commentStr := ( aString == nil or: [ aString isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ aString string ].</body><body package="Store-DB-Pundles" selector="commentID">commentID	"Answer the receiver's commentID."	^commentID</body><body package="Store-DB-Pundles" selector="commentID:">commentID: newCommentID	"Set the receiver's commentID to newCommentID."	commentID := newCommentID</body><body package="Store-DB-Pundles" selector="commentOrNil">commentOrNil	"Allow for lazy evaluation."	commentStr isNil		ifTrue: [ commentStr := self getDefinitionID: self commentID ].	^commentStr isEmpty		ifTrue: [ nil ]		ifFalse: [ commentStr ]</body><body package="Store-DB-Pundles" selector="componentType">componentType	^self subclassResponsibility</body><body package="Store-DB-Pundles" selector="databaseId">databaseId	^DbRegistry databaseIdentifier.</body><body package="Store-DB-Pundles" selector="databaseList">databaseList	"Answer an array of datbase identifiers whether the receiver has links or not"	^Array with: dbIdentifier</body><body package="Store-DB-Pundles" selector="deploymentPrerequisites">deploymentPrerequisites	^self  properties at: #prerequisiteParcels ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="developmentPrerequisites">developmentPrerequisites	^self properties at: #developmentPrerequisites ifAbsent: [#()]</body><body package="Store-DB-Pundles" selector="enclosingComponents">enclosingComponents	"Answer a collection of all owning bundles."	^self class partClass enclosingComponentsOfId: self primaryKey.</body><body package="Store-DB-Pundles" selector="environment">environment	| environmentName |	environmentName := self propertyAt: #namespace ifAbsent: [^nil].	^environmentName asQualifiedReference valueOrDo: [nil].</body><body package="Store-DB-Pundles" selector="getImagePundle">getImagePundle	"Check if there if already loaded versions of a bundle and answer it"	^self subclassResponsibility.</body><body package="Store-DB-Pundles" selector="name:">name: anObject	name := anObject asString</body><body package="Store-DB-Pundles" selector="parcelDirectory">parcelDirectory	^self propertyAt: #parcelDirectory ifAbsent: [nil]</body><body package="Store-DB-Pundles" selector="parcelDirectory:">parcelDirectory: aString	"Answer the parcel directory, or receiver's name if absent."		self properties at: #parcelDirectory put: aString</body><body package="Store-DB-Pundles" selector="parcelName">parcelName	"Answer the parcel name, or receiver's name if absent."		^self properties at: #parcelName ifAbsent: [ name ]</body><body package="Store-DB-Pundles" selector="parentRecord">parentRecord	^(trace isNil or: [trace isZero])		ifTrue: [nil]		ifFalse: [self class aRecordWithID: trace]</body><body package="Store-DB-Pundles" selector="postLoadAction">postLoadAction	^self  properties at: #postLoadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="postLoadBlock">postLoadBlock	^self  properties at: #postLoadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="postUnloadAction">postUnloadAction	^self  properties at: #postUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="postUnloadBlock">postUnloadBlock	^self  properties at: #postUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preLoadBlock">preLoadBlock	^self  properties at: #preLoadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preReadBlock">preReadBlock	^self  properties at: #preReadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preSaveAction">preSaveAction	^self  properties at: #preSaveBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preSaveBlock">preSaveBlock	^self  properties at: #preSaveBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preUnloadAction">preUnloadAction	^self  properties at: #preUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preUnloadAction:">preUnloadAction: aString	"Was finalDoitString.  Stored in the properties dictionary."	self  properties at: #preUnloadAction put: aString string</body><body package="Store-DB-Pundles" selector="preUnloadBlock">preUnloadBlock	^self  properties at: #preUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="prerequisiteDescriptions">prerequisiteDescriptions	^(PrerequisiteDescription		descriptionsFrom: (self properties at: #prerequisiteDescriptions				ifAbsent: [nil])		orDeployment: self deploymentPrerequisites		andDevelopment: self developmentPrerequisites)			collect: [:each | each client: self]</body><body package="Store-DB-Pundles" selector="prerequisiteParcels">prerequisiteParcels	"Answer the names of the receiver's prerequisite parcels	 as an Array of Name String, Version String pairs."	^self properties at: #prerequisiteParcels ifAbsent: [#()]</body><body package="Store-DB-Pundles" selector="properties">properties	"Answer the property dictionary. First, try loading it from the relational tables.	If no properties are found, maybe it is an older record, so try loading from	the old style BOSSed dictionary, stored binary in another file under propertiesID."	(properties == nil and: [self class shouldLoadPropertyRecords]) 		ifTrue: 			[self propertyRecords isEmpty 				ifFalse: [properties := self propertyRecordsAsDictionary]].	properties == nil 		ifTrue: [properties := self getPropertiesID: self propertiesID].	properties == nil ifTrue: [properties := IdentityDictionary new].	^properties</body><body package="Store-DB-Pundles" selector="properties:">properties: idDictionary	"Set the properties dictionary."	properties := idDictionary</body><body package="Store-DB-Pundles" selector="propertiesForFileOut">propertiesForFileOut	"Answer a version of the property dictionary for filingout.."	^self properties.</body><body package="Store-DB-Pundles" selector="propertiesForSave">propertiesForSave	"Answer a version of the property dictionary for saving. Since we're already saved, it's the same."	^self properties.</body><body package="Store-DB-Pundles" selector="propertiesID">propertiesID	^propertiesID</body><body package="Store-DB-Pundles" selector="propertiesID:">propertiesID: anInteger	"Set the receiver's propertiesID to newPrimaryKey."	propertiesID := anInteger</body><body package="Store-DB-Pundles" selector="propertiesOrNil">propertiesOrNil	"Answer properties if it contains  values, or nil."	"Because we really aren't interested in storing a bunch of empty property dictionaries."		^( properties == nil or: [ properties isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ properties ].</body><body package="Store-DB-Pundles" selector="propertyAt:ifAbsent:">propertyAt: symbol ifAbsent: aBlock	^self properties at: symbol ifAbsent: aBlock</body><body package="Store-DB-Pundles" selector="pundle">pundle	^self</body><body package="Store-DB-Pundles" selector="pundleChangesClass">pundleChangesClass	self subclassResponsibility</body><body package="Store-DB-Pundles" selector="structure">structure	"Answer an array that reflects the receiver's contents in the form:		#( #( #package name ) #( #bundle name ) .... )"		| answer |	answer := OrderedCollection new: self contents size.	self contents do:		[ :cd | | comp |		( comp := cd asDBComponent ) isPackage			ifTrue: [ answer add: ( Array with: #package with: comp name ) ]			ifFalse: [ answer add: ( Array with: #bundle with: comp name ) ].		].	^answer asArray</body><body package="Store-DB-Pundles" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body><body package="Store-DB-Pundles" selector="tracePackage">tracePackage		^self parentRecord</body><body package="Store-DB-Pundles" selector="versionComment">versionComment	"Return empty string if the comment is not set."	| str |	^(str := self versionCommentOrNil) isNil		ifTrue: ['']		ifFalse: [str]</body><body package="Store-DB-Pundles" selector="versionComment:">versionComment: aString 	commentStr := aString</body><body package="Store-DB-Pundles" selector="versionCommentOrNil">versionCommentOrNil	"Allow for lazy evaluation."	^commentStr isNil		ifTrue: [commentStr := self getDefinitionID: self commentID]		ifFalse: [commentStr]</body><body package="Store-DB-Pundles" selector="versionSelectionBlock">versionSelectionBlock	"Answer the versionSelectionBlock string or nil if none."		^self propertyAt: #versionSelectionBlock ifAbsent: [nil]</body><body package="Store-DB-Pundles" selector="warningSuppressionBlock">warningSuppressionBlock		^self propertyAt: #warningSuppressionBlock ifAbsent: [nil]</body></methods><methods><class-id>Store.Pundle</class-id> <category>private-accessing</category><body package="Store-DB-Pundles" selector="createImagePundle">createImagePundle	"Check if there if already loaded versions of the receiver and answer it. 	If not create a new pundle and register it."	| imPkg |	imPkg := self getImagePundle.	imPkg isNil		ifTrue: 			[ imPkg := self class imageClass named: self name.			imPkg dbIdentifier: self  dbIdentifier 			].	^imPkg</body><body package="Store-DB-Pundles" selector="ownRecordForTag:">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^self recordForTag: aTag</body><body package="Store-DB-Pundles" selector="parentVersionString">parentVersionString	"Answer a string describing the parent version."	| parentRecord |	^(parentRecord := self parentRecord) isNil		ifTrue: [''] 		ifFalse: [parentRecord version ifNil: ['']]</body><body package="Store-DB-Pundles" selector="recordForPropertyTag:">recordForPropertyTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^( self properties includesKey: aTag property )		ifFalse: [ nil ]		ifTrue: 			[ aTag copy				package: self; 				yourself			].</body><body package="Store-DB-Pundles" selector="recordForTag:">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^self subclassResponsibility.</body><body package="Store-DB-Pundles" selector="updateBlessing:">updateBlessing: aNewLevel	"Update DB to reflect changes in my latest 	blessing level."	Cursor database showWhile: [		self broker process: 			( self newSQL				update;				column: #blessingLevel equalTo: aNewLevel printString;				where;				column: #primaryKey equalTo: primaryKey printString)	].	self blessingLevel: aNewLevel.	Registry blessingChangedForPundle: self.</body></methods><methods><class-id>Store.Pundle</class-id> <category>ownership</category><body package="Store-DB-Pundles" selector="owner">owner	^Policies ownershipPolicy ownerOfPundle: self</body></methods><methods><class-id>Store.Pundle</class-id> <category>comparing</category><body package="Store-DB-Pundles" selector="=">= aPundle 	"Compare two database pundles."	^self class = aPundle class and: 		[ self primaryKey = aPundle primaryKey and: 			[ self primaryKey notNil or: [ self name = aPundle name ] ] 		]</body><body package="Store-DB-Pundles" selector="comparesTo:">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isPackage = self isPackage		and: [ name = aCodeComponent name ].</body><body package="Store-DB-Pundles" selector="hash">hash	^self primaryKey hash</body></methods><methods><class-id>Store.Pundle</class-id> <category>actions</category><body package="Store-DB-Pundles" selector="doActionEvalualtion:withArguments:for:">doActionEvalualtion: aString withArguments: args for: aDescription 	| block val |	block := Cursor execute showWhile: 					[nil class evaluatorClass new 						evaluate: (ReadStream on: aString asString)						in: nil						allowReceiver: false						receiver: nil						environment: CodeComponent environmentForActionBlocks						notifying: nil						ifFail: 							[Dialog 								warn: ((#_1sCompilationErrorIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: Compilation error in &lt;2s&gt;') expandMacrosWith: self name										with: aDescription).							^false]].	block numArgs == args size 		ifFalse: 			[Dialog 				warn: ((#_1sInvalid2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: invalid &lt;2s&gt;') expandMacrosWith: self name with: aDescription).			^false].	[val := block valueWithArguments: args] on: Error		do: 			[:e | 			Dialog warn: ((#_1sErrorEvaluating2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: Error evaluating &lt;2s&gt;') expandMacrosWith: self name						with: aDescription).			^false].	^val ~~ false</body><body package="Store-DB-Pundles" selector="loadSrcWithImgPundle:">loadSrcWithImgPundle: aPundleModel		self prerequisiteRecursionReset.	((aPundleModel notNil and: [aPundleModel dbTrace == self primaryKey]) and: [aPundleModel hasBeenModified not]) ifTrue:		[(Dialog confirm: 			(#TheSelectedVersionIReconcileAndReload &lt;&lt; #store &gt;&gt; 'The selected version is already loaded.&lt;nt&gt;Reconcile and reload?') expandMacros)				ifTrue: [aPundleModel reconcileWithDb: self]				ifFalse: [^self]].	self loadSrc.	self prerequisiteRecursionReset.</body><body package="Store-DB-Pundles" selector="runPreLoad">runPreLoad	| action |	(action := self preLoadBlock ) == nil		ifTrue: [ ^nil ].	^self doActionEvalualtion: action withArguments: ( Array with: self ) for: 'preLoad'</body><body package="Store-DB-Pundles" selector="runPreRead">runPreRead	| action |	( action := self preReadBlock ) == nil		ifTrue: [ ^true ].	( self doActionEvalualtion: action withArguments: ( Array new ) for: 'PreRead' )		ifTrue: [ ^true ].	^Dialog confirm: ( (#PreReadActionFor1IledNttttContinue &lt;&lt; #store &gt;&gt; 'Pre-read action for &lt;1s&gt; failed.&lt;ntttt&gt;Continue?') expandMacrosWith: name ).</body></methods><methods><class-id>Store.Pundle</class-id> <category>private</category><body package="Store-DB-Pundles" selector="addBlessingLevel:andComment:">addBlessingLevel: aLevel andComment: aComment 	"Create a new record with the blessing level only 	if the level is higher then zero or the comment is not empty."	(aLevel &gt; 0 or: [aComment isEmpty not])		ifTrue: [Blessing				forPundle: self 				withLevel: aLevel				andComment: aComment]</body><body package="Store-DB-Pundles" selector="addDBProperties:">addDBProperties: aCollectionOfDBProperties 	"Create new entries in the table which binds properties to packages.	These relate new packages to either new or pre-existing property records."	| property |	aCollectionOfDBProperties do: 			[:each | 			(property := Properties new)				pundleRef: self primaryKey;				propertyRef: each primaryKey;				recType: (Properties typeCodeForClass: self).			property install]</body><body package="Store-DB-Pundles" selector="addProperties:">addProperties: aCollectionOfProperties 	"Convert collection of properties into collection of DB properties and add 	them to the receiver."	self addProperties: aCollectionOfProperties mergeData: nil</body><body package="Store-DB-Pundles" selector="addProperties:mergeData:">addProperties: aCollectionOfProperties mergeData: mergeData 	"Convert collection of properties into collection of DB properties and add 	them to the receiver. Currently, mergeData is not used (07-24-04).	Note that if the trace is not null then check the properties from the trace and 	create new records only for properties that are different."	| propertyList newDBProperties traceProperties |	self class shouldSavePropertyRecords ifFalse: 		[self error: #SavingPropertyRecordSupposedlyDisabled &lt;&lt; #store &gt;&gt; 'Saving property records is supposedly disabled.'].	traceProperties := self hasTrace 				ifTrue: [self getTrace propertyRecords]				ifFalse: [#()].	propertyList := aCollectionOfProperties.	"SystemUtils sortForLoading:"	newDBProperties := OrderedCollection new.	propertyList do: 			[:each | 			| aDBProperty |			aDBProperty := nil.			"mergeData == nil			ifFalse: 				[ aDBProperty := mergeData resolutionRecordForTag: 						(PropertyTag newProperty: each) packageNamed: self name. 				]."			aDBProperty == nil 				ifTrue: 					[aDBProperty := traceProperties 								detect: [:dbProp | dbProp absoluteName = each absoluteName]								ifNone: [nil]].			"Add property record to list, creating in DB if necessary."			newDBProperties add: (PropertyRecord recordFor: each trace: aDBProperty)].	"Create relational links in DB for all properties."	self addDBProperties: newDBProperties</body><body package="Store-DB-Pundles" selector="descriptionClass">descriptionClass	self subclassResponsibility.</body><body package="Store-DB-Pundles" selector="getPropertiesID:">getPropertiesID: anID	anID == 0 ifTrue: [ ^nil ].	^( self getDefinitionRecordID: anID ) binData</body><body package="Store-DB-Pundles" selector="preDatabaseInstall">preDatabaseInstall	"Some subclasses have prep work to perform before creating record."	super preDatabaseInstall.	self validateVersionString.</body><body package="Store-DB-Pundles" selector="prepareInstallation">prepareInstallation	"Create records for pundle properties and comment, if necessary.	The BOSSed properties dictionary will only be saved if enabled. Otherwise, the	propertiesID := 0, to indicate no BOSSed dictionary available for this pundle.	The property records array, like namespaces, are saved elsewhere."	self class shouldSaveBOSSedProperties		ifTrue:			[				(self propertiesID isNil or: [self propertiesID = 0])					ifTrue: [self propertiesID: (self class definitionClass fromBinData: self propertiesOrNil) primaryKey]			]		ifFalse: [self propertiesID: 0].	self commentID isNil ifTrue:		[self commentID: (self class definitionClass fromString: self commentOrNil) primaryKey]</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	commentStr := Object new.	properties := Object new.	propertyRecords := Object new.</body><body package="Store-DB-Pundles" selector="propertyRecords">propertyRecords	"Retrieve this pundle's property records from the relational tables.	If found,	these are used to generate the properties (a dictionary)."	| dbProperties |	propertyRecords isNil 		ifTrue: 			[			[dbProperties := self broker 						getAnswerFromSession: [PropertiesView propertiesSession]						bindInput: 							[:session | 							| bindObject |							bindObject := session bindInput.							bindObject pundleRef: self primaryKey.							bindObject recType: (Properties typeCodeForClass: self)].			propertyRecords := (dbProperties 						collect: [:each | (PropertyRecord fromView: each) package: self]) 							asOrderedCollection] 					on: self errorSignals					do: 						[:ex | 						propertyRecords := OrderedCollection new.						^propertyRecords]].	^propertyRecords</body><body package="Store-DB-Pundles" selector="propertyRecordsAsDictionary">propertyRecordsAsDictionary	"Return an IdentityDictionary of properties."	| dict |	dict := IdentityDictionary new.	propertyRecords 		do: [ :propRecord | dict at: propRecord name asSymbol put: propRecord definitionStr ].	^dict</body><body package="Store-DB-Pundles" selector="sameVersionAs:">sameVersionAs: aPundle		^aPundle sameVersionAsPublished: self</body><body package="Store-DB-Pundles" selector="sameVersionAsLoadedPundle:">sameVersionAsLoadedPundle: anImPundle	^anImPundle sameVersionAsPublished: self</body><body package="Store-DB-Pundles" selector="sameVersionAsPublished:">sameVersionAsPublished: aDbPundle	^aDbPundle primaryKey = self primaryKey</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	commentStr := nil.	properties := nil.	propertyRecords := nil.</body><body package="Store-DB-Pundles" selector="validateVersionString">validateVersionString	"Check to see it the receiver's version string is already used. 	This is way too late in the game to cancel, so insist on a new version string."	[ Policies versionPolicy existsVersionString: version forPundle: self ] whileTrue: 		[ version := 			Dialog				request: ( (#Version1sOf2sANotherVersionString &lt;&lt; #store &gt;&gt; 'Version &lt;1s&gt; of &lt;2s&gt; already exists.&lt;n&gt;Enter another version string') 							expandMacrosWith: version with: self name )				initialAnswer: ( Policies versionPolicy nextVersion: version forPundle: self )				onCancel: [ version ].		].</body></methods><methods><class-id>Store.Pundle</class-id> <category>private-file out</category><body package="Store-DB-Pundles" selector="fileOutMethods:on:">fileOutMethods: aCollection on: aFileManager	"First group methods by class and protocol 	and the ask aFileManager to do the job class by class"		| toFileOut classes protocols |	toFileOut := Dictionary new.	aCollection do:		[:each | 		classes := toFileOut			at: each className			ifAbsent: [Dictionary new].		protocols := classes			at: each protocolName			ifAbsent: [Set new].		protocols add: each.		classes			at: each protocolName			put: protocols.		toFileOut			at: each className			put: classes.		(each name = 'initialize' and: [each className namesMetaClass])			ifTrue: [aFileManager initializeThisClass: (PseudoClass newNamed: each className asClassNameOnly)]].	toFileOut keysAndValuesDo:		[:key :value | 		aFileManager fileOutTTMessages: value for: key logging: false.		aFileManager cr.		IncrementNotification signalWith: (value inject: 0 into: [:sum :each | sum + each size])]</body><body package="Store-DB-Pundles" selector="fileOutProperties:on:">fileOutProperties: props on: aFileManager	props associationsDo:		[ :assoc |		aFileManager 			component: self componentType			named: self name			property: assoc key			value: assoc value				].</body><body package="Store-DB-Pundles" selector="fileOutPropertiesOn:">fileOutPropertiesOn: aFileManager		self fileOutProperties: self propertiesForFileOut on: aFileManager.</body></methods><methods><class-id>Store.Pundle</class-id> <category>utilities</category><body package="Store-DB-Pundles" selector="classicPrereqTypeAsList:">classicPrereqTypeAsList: aTypeSymbol	"Convert simple prereq types (#any, #bundle, #package, #parcel) into the appropriate sequence of specific prereqs, which means converting #any based on the search order preferences, wrapping anything else as any array."	aTypeSymbol == #any		ifTrue: 			[^Policies prerequisitePolicy searchOrder = #parcelsFirst				ifTrue: [#(#parcel #bundle #package)]				ifFalse: [#(#bundle #package #parcel)]].	^Array with: aTypeSymbol</body><body package="Store-DB-Pundles" selector="interactiveSelectVersion">interactiveSelectVersion 	"Answer a version of the receiver selected by the user, or nil if cancelled.	Always show a list with OK and Cancel options, no matter how many	actual versions are on the list."	^self class interactiveSelectVersionOf: self name.</body><body package="Store-DB-Pundles" selector="mostRecentVersion">mostRecentVersion	"Answer a pundle that is the most recently published version of the receiver."	^self class mostRecentVersionOfPundleWithName: name</body><body package="Store-DB-Pundles" selector="selectVersion">selectVersion 	^self class selectVersionOf: self name.</body><body package="Store-DB-Pundles" selector="silentlyFailSelectVersion">silentlyFailSelectVersion 	^self class silentlyFailSelectVersionOf: self name.</body></methods><methods><class-id>Store.Pundle</class-id> <category>fileout</category><body package="Store-DB-Pundles" selector="fileOut">fileOut	"Ask for file name and file out the content of the pundle into it."	| fileName |	fileName := Dialog 				requestNewFileName: #FileOutOnC &lt;&lt; #store &gt;&gt; 'File out on:'				default: self name , '.st'.	fileName isEmpty ifTrue: [^nil].	self fileOutOnFileNamed: fileName</body><body package="Store-DB-Pundles" selector="fileOutOnFileNamed:">fileOutOnFileNamed: fileName 	| aFileManager |	aFileManager := SourceCodeStream write: fileName.		[Notice 		showNotice: (#FilingOut1s &lt;&lt; #store &gt;&gt; 'Filing out &lt;1s&gt;' expandMacrosWith: self name)		complete: self itemCount		while: 			[aFileManager timeStamp.			aFileManager deferInitializations.			self fileOutOn: aFileManager.			aFileManager finishInitializations]		title: #Store &lt;&lt; #store &gt;&gt; 'Store'] 			ensure: [aFileManager close]</body></methods><methods><class-id>Store.Pundle</class-id> <category>private-differences calculation</category><body package="Store-DB-Pundles" selector="classesAndNameSpacesFromChanges:">classesAndNameSpacesFromChanges: changeSet	| list |	list := OrderedCollection new.	changeSet keysAndValuesDo:		[ :symbol :cc | 		( cc isForClass			ifTrue: 				[ list add: 					( self classes 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: false ]					).				list add: 					( self metaclasses 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: true ]					).				]				ifFalse:					[ list add: 						( self nameSpaces 							detect: 	[ :cls | cls absoluteName = symbol asString ] 							ifNone: [ PseudoNameSpace newNamed: symbol ]						)					]			)		].	^list</body><body package="Store-DB-Pundles" selector="modificationsFor:">modificationsFor: id	"Answer my content as a list of modifications."	"Pundle adds the common properties. Subclasses take care of the rest."	^dbIdentifier = id		ifTrue: [ self modifications ]		ifFalse: [ #( ) ].</body></methods><methods><class-id>Store.Pundle</class-id> <category>shadow loading</category><body package="Atomic Compiling and Loading" selector="allModifiedItems">allModifiedItems	| allItems |	allItems := self allItems.	^allItems select: [:each | each asComponentDescription isNotLoaded]</body><body package="Atomic Compiling and Loading" selector="basicPostShadowLoad:">basicPostShadowLoad: anImagePundle		self class shouldLoadPropertyRecords ifTrue: 		[self resetProperties].	anImagePundle		properties: self properties;		dbTrace: self primaryKey;		runComponentPostLoad;		markNotModified</body><body package="Atomic Compiling and Loading" selector="defaultCompileManager">defaultCompileManager	self subclassResponsibility</body><body package="Store-DB-Pundles" selector="itemCount">itemCount	^self subclassResponsibility</body><body package="Atomic Compiling and Loading" selector="resetProperties">resetProperties	propertyRecords := nil.	properties := nil.</body><body package="Atomic Compiling and Loading" selector="unprotectedActionEvaluation:withArguments:">unprotectedActionEvaluation: aString withArguments: args 	| block |	block := Cursor execute showWhile: 		[ nil class evaluatorClass new				evaluate: (ReadStream on: aString asString)				in: nil 				allowReceiver: false				receiver: nil				environment: CodeComponent environmentForActionBlocks				notifying: nil				ifFail: [ ^Error signalWith: #CompilationError &lt;&lt; #store &gt;&gt; 'Compilation Error' ]		].	^(block valueWithArguments: args) ~~ false</body></methods><methods><class-id>Store.Pundle</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="longItemString">longItemString	| versionName user |	versionName := self version ifNil: [#unknown &lt;&lt; #store &gt;&gt; 'unknown'].	user := self userName ifNil: [#unknown &lt;&lt; #store &gt;&gt; 'unknown'].	^'&lt;1s&gt; &lt;t&gt;(&lt;2s&gt;, &lt;3s&gt;) &lt;t&gt;&lt;4s&gt;&lt;t&gt;&lt;t&gt;&lt;5s&gt;&lt;t&gt;&lt;6s&gt;'		expandMacrosWithArguments:			(OrderedCollection new				add: self name;				add: versionName;				add: user;				add: self blessingLevelString;				add: self timeStampString;				add: self sourceOrBinaryString;				yourself)</body><body package="Store-DB-Pundles" selector="propertyText">propertyText	| stream |	stream := ( String new: 100 ) stream.	stream nextPutAll: ( DbRegistry textForItem: self ); cr; cr.	( self properties associations asSortedCollection: [ :a :b | a key &lt; b key ] ) do:		[ :prop | 		stream nextPutAll: prop key, ': ', prop value printString; cr.		].	^stream contents.</body></methods><methods><class-id>Store.Pundle</class-id> <category>prereqs</category><body package="Store-DB-Pundles" selector="attemptToLoadBundleNamed:version:">attemptToLoadBundleNamed: aBundleName version: aVersionString	"Attempt to load a bundle that satifies the prerequisite."	"We know an acceptable version is not already loaded."		| bundles |	(Bundle loadWithName: aBundleName version: aVersionString) ifNotNil: [^true].	bundles := Bundle allVersionsWithName: aBundleName.	bundles isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aBundleName from: bundles version:			aVersionString for: self)		ifNil: [false]		ifNotNil: [:bundle | bundle loadSrc notNil]</body><body package="Store-DB-Pundles" selector="attemptToLoadPackageNamed:version:">attemptToLoadPackageNamed: aPackageName version: aVersionString	"Attempt to load a package that satifies the prerequisite."	"We know an acceptable version is not already loaded."		| packages |	(Package loadWithName: aPackageName version: aVersionString) ifNotNil: [^true].	packages := Package allVersionsWithName: aPackageName.	packages isEmpty ifTrue: [^false].	^(Policies prerequisitePolicy getPrereq: aPackageName from: packages version:			aVersionString for: self)		ifNil: [false]		ifNotNil: [:package | package loadSrc notNil]</body><body package="Store-DB-Pundles" selector="checkParcelPrerequisite:version:">checkParcelPrerequisite: aParcelName version: aVersionString	"Validate the existense of a parcel as a prerequisite. Answer true if loaded"		^([Parcel ensureLoadedParcel: aParcelName withVersion: aVersionString forPundle:			self]		on: Parcel missingParcelSignal		do: [:exp | exp return: nil]) notNil</body><body package="Store-DB-Pundles" selector="checkPrerequisite:">checkPrerequisite: aPrerequisiteDescription	"Validate the existence of a prerequisite. Either by verifying an appropriate match is loaded, or by loading one that does. Answer true if okay to finish loading"	| message loadSources |	(self checkPrerequisiteLoaded: aPrerequisiteDescription) ifTrue: [^true].	loadSources := aPrerequisiteDescription possibleLoadSources.	loadSources do: 		[:eachSourceType |		(self prerequisiteRecursionIncludes: (aPrerequisiteDescription name -&gt; eachSourceType))				ifTrue: [^true].		self prerequisiteRecursionAdd: (aPrerequisiteDescription name -&gt; eachSourceType).		#parcel = eachSourceType ifTrue: 			[(self checkParcelPrerequisite: aPrerequisiteDescription name version: aPrerequisiteDescription versionFilter) 				ifTrue: [^true]].		#package = eachSourceType ifTrue: 			[(self attemptToLoadPackageNamed: aPrerequisiteDescription name version: aPrerequisiteDescription versionFilter) 				ifTrue: [^true]].		#bundle = eachSourceType ifTrue: 			[(self attemptToLoadBundleNamed: aPrerequisiteDescription name version: aPrerequisiteDescription versionFilter) 				ifTrue: [^true]]].	message := #UnableToLoadPrerequ2sNtttContinue &lt;&lt; #store		&gt;&gt; 'Unable to load prerequisite &lt;1s&gt; &lt;2s&gt;&lt;nttt&gt;Continue?'			expandMacrosWith: aPrerequisiteDescription name			with: (#version1s &lt;&lt; #store &gt;&gt; 'version &lt;1s&gt;' expandMacrosWith: aPrerequisiteDescription versionFilter).	^Dialog confirm: message</body><body package="Store-DB-Pundles" selector="checkPrerequisite:within:">checkPrerequisite: aPrerequisiteDescription within: aBundle	"Validate the existence of a prerequisite of gien name and type within a bundle. Answer true if okay to finish loading"	aBundle ifNotNil: 		[(aBundle checkPundlePrerequisiteContained: aPrerequisiteDescription) ifTrue: [^true]].	^self checkPrerequisite: aPrerequisiteDescription</body><body package="Store-DB-Pundles" selector="checkPrerequisiteLoaded:">checkPrerequisiteLoaded: aPrerequisiteDescription	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications |	verifications := aPrerequisiteDescription possibleLoadSources				collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: 			[:each |			self				perform: each				with: aPrerequisiteDescription name				with: aPrerequisiteDescription versionFilter]</body><body package="Store-DB-Pundles" selector="checkPrerequisiteLoaded:named:version:">checkPrerequisiteLoaded: aPrereqType named: aNameString version: aVersionString	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Based on the prerequisiteType, assemble a properly ordered list of verifications to try."	| verifications prereqTypes |	prereqTypes := self classicPrereqTypeAsList: aPrereqType.	verifications := prereqTypes collect: [:each | self loadedVerificationMethodForType: each].	^verifications anySatisfy: [:each | self perform: each with: aNameString with: aVersionString]</body><body package="Store-DB-Pundles" selector="checkPrerequisiteNamed:withVersion:requiredVersion:">checkPrerequisiteNamed: prerequisiteName withVersion: prerequisiteVersionString requiredVersion: requiredVersionString	"Answer if the version of the prerequisite prerequisiteName is acceptable.	Callback for prerequiste loading"	| blk |	( blk := CodeComponent asActionBlock: self versionSelectionBlock  ) == nil 		ifTrue: 			[ ^( requiredVersionString isNil or: [ requiredVersionString isEmpty ] )				ifTrue: [ true ]				ifFalse: 	[ prerequisiteVersionString = requiredVersionString ].			].	^blk		value: prerequisiteName		value: prerequisiteVersionString		value: requiredVersionString</body><body package="Store-DB-Pundles" selector="checkPrerequisites">checkPrerequisites	"Check the prereqs. Answer true if it's okay to load."	| prerequisiteProperties |	(prerequisiteProperties := self prerequisiteDescriptions) isEmpty		ifTrue: [^true].	self prerequisiteRecursionAdd: (self name -&gt; self componentType).	prerequisiteProperties do: [:each | (self checkPrerequisite: each) ifFalse: [^false]].	^true</body><body package="Store-DB-Pundles" selector="checkPundlePrerequisiteContained:">checkPundlePrerequisiteContained: aPrerequisiteDescription	| typeSelector |	typeSelector := #(#isPackage #isBundle #notNil)				at: (#(#package #bundle nil)						indexOf: aPrerequisiteDescription componentType).	^self allUniqueItems anySatisfy: 			[:item |			item name = aPrerequisiteDescription name				and: [item perform: typeSelector]]</body><body package="Store-DB-Pundles" selector="checkPundlePrerequisiteContained:named:">checkPundlePrerequisiteContained: aPrereqType named: aCodeComponentName	"Answer if the receiver contains a version of a prerequisite."		| items typeSelector prereqVector |	items := self allUniqueItems.	prereqVector := self classicPrereqTypeAsList: aPrereqType.	^prereqVector		anySatisfy:			[:eachPrereqType | 			typeSelector := #(#isPackage #isBundle #notNil)				at: (#(#package #bundle #parcel) indexOf: eachPrereqType).			items				anySatisfy:					[:item | item name = aCodeComponentName and: [item perform: typeSelector]]]</body><body package="Store-DB-Pundles" selector="loadedVerificationMethodForType:">loadedVerificationMethodForType: aLoadSourceType	"What method should we use against ourself to verify aPundleType of given name and version is loaded?"	aLoadSourceType = #parcel ifTrue: [^#verifyLoadedParcelNamed:version:].	aLoadSourceType = #package ifTrue: [^#verifyLoadedPackageNamed:version:].	aLoadSourceType == #bundle ifTrue: [^#verifyLoadedBundleNamed:version:].	^self error: ('Unknown code component type: &lt;1p&gt;'				expandMacrosWith: aLoadSourceType)</body><body package="Store-DB-Pundles" selector="prerequisiteRecursion">prerequisiteRecursion		^PrerequisiteRecursion ifNil: [PrerequisiteRecursion := Set new].</body><body package="Store-DB-Pundles" selector="prerequisiteRecursionAdd:">prerequisiteRecursionAdd: anAssociation		^self prerequisiteRecursion add: anAssociation</body><body package="Store-DB-Pundles" selector="prerequisiteRecursionIncludes:">prerequisiteRecursionIncludes: anAssociation		^self prerequisiteRecursion includes: anAssociation</body><body package="Store-DB-Pundles" selector="prerequisiteRecursionReset">prerequisiteRecursionReset		PrerequisiteRecursion := nil</body><body package="Store-DB-Pundles" selector="selectPrereqVersionOf:fromList:version:">selectPrereqVersionOf: aPundleName fromList: aList version: aString	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."		 ^Dialog 		choose: ((#ChoosePrereq &lt;&lt; #store &gt;&gt; 'Choose version to fullfill prerequiste: &lt;1s&gt;') expandMacrosWith:  aString)		fromList: ( aList collect: [ :m | m displayString, ' ', m blessingLevelString ] )		values: aList		lines: 10 cancel: [ ^nil ]		for: nil.</body><body package="Store-DB-Pundles" selector="shouldSuppressLoadWarningsForParcel:">shouldSuppressLoadWarningsForParcel: prerequisiteName	"Evaluate the warningSuppressionBlock for the given prerequisite.	 The block should return true to suppress warnings.	Callback for prerequiste loading"	| blk |	( blk := self warningSuppressionBlock  ) == nil		ifTrue: [ ^false ].	^blk value: prerequisiteName</body><body package="Store-DB-Pundles" selector="streamDirectory">streamDirectory	"parcel loading call-back"	^nil</body><body package="Store-DB-Pundles" selector="verifyLoadedBundleNamed:version:">verifyLoadedBundleNamed: aNameString version: aVersionString	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry bundleNamed: aNameString)		ifNil: [false]		ifNotNil:			[:bundle | 			self				checkPrerequisiteNamed: aNameString				withVersion: bundle traceVersion				requiredVersion: aVersionString]</body><body package="Store-DB-Pundles" selector="verifyLoadedPackageNamed:version:">verifyLoadedPackageNamed: aNameString version: aVersionString	"Validate the existense of a package by a given name and version. 	Answer true if acceptable version is already loaded"		^(Registry packageNamed: aNameString)		ifNil: [false]		ifNotNil:			[:package | 			self				checkPrerequisiteNamed: aNameString				withVersion: package traceVersion				requiredVersion: aVersionString]</body><body package="Store-DB-Pundles" selector="verifyLoadedParcelNamed:version:">verifyLoadedParcelNamed: aNameString version: aVersionString	"Validate the existense of a bundle by a given name and version. 	Answer true if acceptable version is already loaded"		^(Parcel parcelNamed: aNameString)		ifNil: [false]		ifNotNil:			[:parcel | 			self				checkPrerequisiteNamed: aNameString				withVersion: parcel version				requiredVersion: aVersionString]</body></methods><methods><class-id>Store.Pundle</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="loadSrc">loadSrc	self subclassResponsibility.</body><body package="Store-DB-Pundles" selector="noteLoad">noteLoad	"If the database supports it, make a note that we are loading this item."	| checkTableExistenceStatement broker tableExists logEntry |	checkTableExistenceStatement := LoadRecord new newSQL selectCountAll; where; column: 'username' equalTo: 'NULL'.	broker := self broker.	tableExists := true.	[broker process: checkTableExistenceStatement bindInput: nil bindOutput: nil usingSession: ( broker sessionFromOutputObject: nil )] on: Error do: [:ex | tableExists := false].	tableExists ifFalse: [^self].	logEntry := LoadRecord new		username: Store.DbRegistry userName;		pundleName: self name;		pundleType: (self isBundle ifTrue: ['B'] ifFalse: ['P']);		pundleVersion: version;		timestamp: self class timeStamp.	logEntry installInDatabase.</body></methods><methods><class-id>Store.Pundle</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="objectionsToPublishing:atBlessing:">objectionsToPublishing: imBndl atBlessing: level	"Answer true if there are no objections to publishing 	the pundle at blessing level 'level'"	self subclassResponsibility.</body></methods><methods><class-id>Store.Pundle</class-id> <category>utilities-repository</category><body package="Store-DB-Pundles" selector="typeStringForBlessing">typeStringForBlessing		self subclassResponsibility.</body></methods><methods><class-id>Store.Pundle</class-id> <category>converting</category><body package="Store-DB-Pundles" selector="asPrerequisiteDescription">asPrerequisiteDescription	^(PrerequisiteDescription new)		name: self name;		componentType: self componentType;		yourself</body></methods><methods><class-id>Store.Pundle class</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="allPackagesOrBundles">allPackagesOrBundles	"This method is common for packages and bundles but it should be called 	only from a concrete class (TT_Package or TT_Bundle). 	Answer a SortedCollection of TT_Packages/TT_Bundles"	^Cursor wait showWhile: 		[[(self doPostLoadProcessingOn: (self broker 			process: self newSQL selectAll 			bindOutput: self newPrimed)) asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]] 				on: self errorSignal				do: 					[:exception | 					exception outer.					OrderedCollection new]]</body><body package="Store-DB-Pundles" selector="cachedItemFor:">cachedItemFor: aPundle 	"Answer the cached item if there is one. 	Put item in the cache otherwise."	| pundle cached |	cached := self cache at: aPundle primaryKey ifAbsent: [nil].	pundle := (cached notNil and: [cached class == self])				ifTrue: [cached]				ifFalse: 					[self cache at: aPundle primaryKey put: aPundle.					aPundle].	^pundle</body><body package="Store-DB-Pundles" selector="canPublish:atBlessing:">canPublish: imPundle atBlessing: level 	"Answer true if there are no bojections to publishing 	the imPkg at blessing level 'level'"	| objections |	objections := self objectionsToPublishing: imPundle atBlessing: level.	objections == nil 		ifFalse: 			[Dialog 				warn: (#YourPolicyPreventsTLessingLevelN1s &lt;&lt; #store &gt;&gt; 					'The publish policy prevents the publication at this blessing level:&lt;n&gt;&lt;1s&gt;' 					expandMacrosWith: objections).			^false].	^true</body><body package="Store-DB-Pundles" selector="firstVersionOfPundleWithName:">firstVersionOfPundleWithName: aName 	"This method takes advantage of the key generation schema: 	the more recent the version the higher key."	| dbPundles |	dbPundles := self allVersionsWithName: aName.	^dbPundles isEmpty		ifTrue: [nil]		ifFalse: [dbPundles last ]</body><body package="Store-DB-Pundles" selector="knownPackagesOrBundles">knownPackagesOrBundles	"Answer a SelectionInList containing names of all bundles/packages stored in DB.	Note that this is an abstract method and must be called from a concrete subclass like Package or Bundle."	| names |	names := self allNames asSortedCollection.	^SelectionInList with: names asList.</body><body package="Store-DB-Pundles" selector="mostRecentVersionOfPundleWithName:">mostRecentVersionOfPundleWithName: aName 	"This method takes advantage of the key generation schema: 	the more recent the version the higher key."	^self newestVersionWithName: aName.</body><body package="Store-DB-Pundles" selector="propertyRecordsFromDictionary:">propertyRecordsFromDictionary: aDictionary 	"Return an OrderedCollection of propertyRecords from the (properties) dictionary."	| propertyRec records |	records := OrderedCollection new.	aDictionary keysAndValuesDo: 			[:key :value | 			propertyRec := PropertyRecord newName: key definition: value.			records add: propertyRec].	^records</body></methods><methods><class-id>Store.Pundle class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames		"self columnNames"	^super columnNames		remove: 'commentStr';		remove: 'properties';		remove: 'propertyRecords';		yourself.</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes		" self fieldTypes "	^super fieldTypes		at: 'blessingLevel' put: #Integer;		at: 'commentID' put: #Integer;		at: 'propertiesID' put: #Integer;		yourself.</body><body package="Store-DB-Pundles" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.Pundle class</class-id> <category>class initalization</category><body package="Store-DB-Pundles" selector="initialize">initialize	"self initialize"	ComponentNotFoundSignal := Object informationSignal newSignal 		notifierString: 'Component not found';		nameClass: self message: #componentNotFoundSignal.</body><body package="Store-DB-Pundles" selector="initializeCache">initializeCache	"This is subclass specific method."	self cache: WeakDictionary new.</body></methods><methods><class-id>Store.Pundle class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="newNamed:">newNamed: aName 	"Create a record for a package. Put the name and the time stamp. 	Do not install the package in the database."	| newDBPundle |	newDBPundle := self new.	newDBPundle setNoTrace; name: aName; timeStamp: self timeStamp.	^newDBPundle</body><body package="Store-DB-Pundles" selector="propertyRecordsFromPundle:">propertyRecordsFromPundle: aPundle 	"Extract an OrderdCollection of PropertyRecords from aPundle object.	aPundle might be a PackageModel, in which case we convert its properties dictionary."	^(aPundle isKindOf: Pundle) 		ifTrue: [aPundle propertyRecords]		ifFalse: [self propertyRecordsFromDictionary: aPundle propertiesForSave]</body></methods><methods><class-id>Store.Pundle class</class-id> <category>signals</category><body package="Store-DB-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	^ComponentNotFoundSignal</body></methods><methods><class-id>Store.Pundle class</class-id> <category>private</category><body package="Store-DB-Pundles" selector="allVersionsWithName:andBlessingLevel:notIn:">allVersionsWithName: aName andBlessingLevel: aBlessingLevel notIn: aCollectionOfNames	"This method is private and used to recurse into renamed bundles/packages only	This should not be called directly"	| basicVersions otherNames |	basicVersions := self basicAllVersionsWithName: aName andBlessingLevel: aBlessingLevel.	basicVersions do: [:each | self cache at: each primaryKey put: each].	otherNames := basicVersions inject: OrderedCollection new into: [:sum :each |		| parent |		parent := each parentRecord.		(parent notNil and: [parent name ~= aName and: [(aCollectionOfNames includes: parent name) not]])			ifTrue: [sum add: parent name].		sum].	^otherNames copy inject: basicVersions into: [:sum :each |		sum, (self allVersionsWithName: each andBlessingLevel: aBlessingLevel notIn: aCollectionOfNames, otherNames)].</body><body package="Store-DB-Pundles" selector="allVersionsWithName:notIn:">allVersionsWithName: aName notIn: aSet	"For bundles and packages, also follow renames, when the trace has a different name from us."	self deprecated: #(#version '7.8' #sunset '8.0' #use 'Store.Glorp.StorePundle&gt;&gt;#allVersionsInitiallyNamed:in:notIn:').	^self allVersionsWithName: aName notIn: aSet lessThanTimeStamp: nil.</body><body package="Store-DB-Pundles" selector="allVersionsWithName:notIn:lessThanTimeStamp:">allVersionsWithName: aName notIn: aSet lessThanTimeStamp: aTimeStamp	"For bundles and packages, also follow renames, when the trace has a different name from us."	| basicVersions namesAndTimestamps result |	basicVersions := aTimeStamp isNil 		ifTrue: [super allVersionsWithName: aName]		ifFalse: [self allVersionsWithName: aName lessThanTimeStamp: aTimeStamp].	basicVersions isEmpty ifTrue: [^basicVersions]. 	basicVersions do: [:each | self cache at: each primaryKey put: each].	"For previous names of this package, store a dictionary from name-&gt;most recent occurence of it in the ancestor list"	namesAndTimestamps := Dictionary new.	basicVersions do: [:each |		| parent |		parent := each parentRecord.		(parent notNil and: [parent name ~= aName and: [(aSet includes: parent name) not]])			ifTrue: [					| previousTimestamp |				aSet add: parent name.				previousTimestamp := namesAndTimestamps at: parent name ifAbsentPut: [parent timestamp].				namesAndTimestamps at: parent name put: (previousTimestamp max: parent timestamp)]].	result := basicVersions.	namesAndTimestamps keysAndValuesDo: [:eachName :eachTimestamp |		result := result,  (self allVersionsWithName: eachName notIn: aSet lessThanTimeStamp: eachTimestamp + 1)].	^result.</body><body package="Store-DB-Pundles" selector="newFrom:">newFrom: anImagePundle 	"Given a image pundle create a new instance of the receiver.		This is a private method used by all public methods that store pundles in the database."	| newDBPundle parentPundle props |	DBObject resetServerTimestamp.	newDBPundle := self newNamed: anImagePundle name.	parentPundle := anImagePundle parentRecord.	anImagePundle dbIdentifier: DbRegistry dbIdentifier.	newDBPundle setTrace: parentPundle.	(parentPundle notNil and: [parentPundle commentOrNil = anImagePundle commentOrNil]) 		ifTrue: [newDBPundle commentID: parentPundle commentID]		ifFalse: [newDBPundle comment: anImagePundle commentOrNil].	props := anImagePundle propertiesForSave.	(parentPundle notNil and: [self properties: parentPundle properties equals: props]) 		ifTrue: [newDBPundle propertiesID: parentPundle propertiesID]		ifFalse: [newDBPundle properties: props].	^newDBPundle</body><body package="Store-DB-Pundles" selector="properties:equals:">properties: aPropertiesDictionary equals: bPropertiesDictionary	"Anwer true if  the two dictionaries contain the same key/values."	aPropertiesDictionary size == bPropertiesDictionary size		ifFalse: [ ^false ].	( aPropertiesDictionary == nil ) &amp; ( bPropertiesDictionary == nil )		ifTrue: [ ^true ].	aPropertiesDictionary keysAndValuesDo:		[ :key :value |		( bPropertiesDictionary at: key ifAbsent: [ ^false ] ) = value			ifFalse: [ ^false ]		].	^true</body><body package="Store-DB-Pundles" selector="shouldLoadPropertyRecords">shouldLoadPropertyRecords	"Should the property records be loaded? Answer should not be false for older DBs."	^self shouldSavePropertyRecords</body><body package="Store-DB-Pundles" selector="shouldSaveBOSSedProperties">shouldSaveBOSSedProperties	"Should the properties also be saved as a BOSSed dictionary, for reading by pre-7.3 images?"	"#(#bossAndTable #tableOnly #bossOnly )"	^DbRegistry isDb73Enabled not or:		[ #(#bossAndTable #bossOnly) includes: PropertiesPublishingPolicy ]</body><body package="Store-DB-Pundles" selector="shouldSavePropertyRecords">shouldSavePropertyRecords	"Should the property records be saved? Answer should not be false for older DBs."	"#(#bossAndTable #tableOnly #bossOnly )"	^DbRegistry isDb73Enabled		and: [ #(#bossAndTable #tableOnly) includes: PropertiesPublishingPolicy ]</body><body package="Store-DB-Pundles" selector="subclassFromType:">subclassFromType: aSymbol	"Answer the subclass that is represented by a type symbol."	^aSymbol == #package			ifTrue: [ Package ]			ifFalse: [ Bundle ].</body></methods><methods><class-id>Store.Pundle class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Pundles" selector="pundlesReferingTo:">pundlesReferingTo: aDefinitionID	"Answer a set of IDS that refer to a given definition either as 	comment or initialization or finalization string."	"Note: should be sent to the appropiate subclass."	| str |	str := aDefinitionID printString.	^[(self broker process:					( self newSQL						selectAll;						where;						column: #commentID  equalTo: str;						or;						column: #propertiesID  equalTo: str)	 ) collect: [ :each | each first ]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body></methods><methods><class-id>Store.Pundle class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="aRecordWithID:">aRecordWithID: anID 	"Check my cache first then use super method.  If the item is not in the cache, then add it."	| rec |	rec := self cache at: anID ifAbsent: [nil].	"Just in case we've managed to have things lingering in the cache from a different database."	(rec notNil and: [rec dbIdentifier ~~ DbRegistry dbIdentifier]) ifTrue: [		self initializeCache.		rec := nil].	(rec notNil and: [rec class == self])		ifFalse: 			[rec := super aRecordWithID: anID.			rec notNil ifTrue: [self cache at: anID put: rec]].	^rec</body><body package="Store-DB-Pundles" selector="allVersionsWithName:">allVersionsWithName: aName 	"For bundles and packages, also follow renames, when the trace has a different name from us."		^self allVersionsWithName: aName notIn: (Set with: aName)</body><body package="Store-DB-Pundles" selector="allVersionsWithName:after:">allVersionsWithName: aName after: dbTrace 	"Answer a colection of db records, that were published since dbTrace.	Note: should be sent to an appropiate subclass."	| items |	[items := self doPostLoadProcessingOn: (self broker 		process: ((self newSQL)			selectAll;			where;			column: #name equalTo: aName asString printString;			and;			column: #primaryKey greaterThan: dbTrace printString)		bindOutput: self newPrimed)] 			on: self errorSignals			do: 				[:exception | 				exception outer.				^OrderedCollection new].	^items asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]</body><body package="Store-DB-Pundles" selector="allVersionsWithName:andBlessingLevel:">allVersionsWithName: aName andBlessingLevel: aBlessingLevel	"Answer a colection of Store.Package or Store.Bundle"	"Note this message has to be sent to a Store.Package or Store.Bundle class."	| basicVersions otherNames |	basicVersions := self basicAllVersionsWithName: aName andBlessingLevel: aBlessingLevel.	basicVersions do: [:each | self cache at: each primaryKey put: each].	otherNames := basicVersions inject: OrderedCollection new into: [:sum :each |		| parent |		parent := each parentRecord.		(parent notNil and: [parent name ~= aName])			ifTrue: [sum add: parent name].		sum].	^otherNames copy inject: basicVersions copy into: [:sum :each |		sum, (self allVersionsWithName: each andBlessingLevel: aBlessingLevel notIn: (otherNames copy add: aName; yourself))].</body><body package="Store-DB-Pundles" selector="allVersionsWithName:lessThanTimeStamp:">allVersionsWithName: aName lessThanTimeStamp:  timeStamp	"Answer a colection of Packages or Bundles"	"Note this message has to be sent to Bundle or Package class."	| items |	[items := self  doPostLoadProcessingOn:				(self broker 					process: 						( self newSQL							selectAll;							where;							column: #name equalTo: aName asString printString;							and;							column: #timeStamp  lessThan: timeStamp printString)					bindOutput: self newPrimed).	] 	on: self errorSignals 	do: 	[ :ex | ex outer.  ^OrderedCollection new ].	^items asOrderedCollection</body><body package="Store-DB-Pundles" selector="allVersionsWithTrace:">allVersionsWithTrace: anInteger 	"Answer a colection of Packages	self allVersionsWithTrace: 341"	| dbPackages packages |	dbPackages := 		[packages := self doPostLoadProcessingOn: (self broker 			process: ((self newSQL)				selectAll;				where;				column: #trace equalTo: anInteger printString)			bindOutput: self newPrimed).		packages] 			on: self errorSignals			do: 				[:exception | 				exception outer.				self table select: [:each | each dbTrace = anInteger]].	^dbPackages isNil		ifTrue: [OrderedCollection new] 		ifFalse: [dbPackages asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]]</body><body package="Store-DB-Pundles" selector="basicAllVersionsWithName:andBlessingLevel:">basicAllVersionsWithName: aName andBlessingLevel: aBlessingLevel 	"Answer a colection of TT_Packages or TT_Bundles	Note this message has to be sent to a TT_Bundle or TT_Package class."	| items |	[items := self doPostLoadProcessingOn: (self broker 		process: ((self newSQL)			selectAll;			where;			column: #name equalTo: aName asString printString;			and;			column: #blessingLevel equalTo: aBlessingLevel printString)		bindOutput: self newPrimed).] 			on: self errorSignals			do: 				[:exception | 				exception outer.				^OrderedCollection new].	^items asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]</body><body package="Store-DB-Pundles" selector="canPublish:userData:">canPublish: aPundle userData: publishSpec 	"Check if a user can publish aPundle with a given blessing 	and if the version string is unique in the database."	| verString |	aPundle isSaveableWithWarning		ifFalse: [ ^false ].	( self canPublish: aPundle atBlessing: publishSpec blessing )		ifFalse: [^false].	verString := Policies versionPolicy versionStringForPundle: aPundle initialVersion: publishSpec version.	verString isNil ifTrue: [ ^false ].	publishSpec version: verString.	^true</body><body package="Store-DB-Pundles" selector="doPostLoadProcessingOn:">doPostLoadProcessingOn: dbRecords		^(super doPostLoadProcessingOn: dbRecords)		collect: [:each | self cachedItemFor: each].</body><body package="Store-DB-Pundles" selector="hasVersionNamed:">hasVersionNamed: aName	"Answer true if a version named aName exists.	Note: must be sent to a concrete subclass."	"Bundle hasVersionNamed: 'StoreBase' "	| res query |	( query := self newSQLFor: self )		selectCountAll;		where;		column: 'name' equalTo: aName printString.				res := self broker processSQL: query sqlString.	^res first first &gt; 0</body><body package="Store-DB-Pundles" selector="interactiveSelectVersionOf:">interactiveSelectVersionOf: pundleName 	"Display a list of pundle versions. Answer the selection, or nil if none.	Always show a list with OK and Cancel options, no matter how many	actual versions are on the list."	| list |	list := self allVersionsWithName: pundleName.	^Dialog 		choose: ((#ChooseVersionOf1s &lt;&lt; #store &gt;&gt; 'Choose version of &lt;1s&gt;:') expandMacrosWith: pundleName)		fromList: (list collect: [:m | '&lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: m version with: m blessingLevelString]) 		values: list		lines: 10		cancel: [^nil]		for: nil</body><body package="Store-DB-Pundles" selector="knownPundles">knownPundles	"Answer a SelectionInList containing names of 	all bundles and packages stored in DB."	| pkgs buns names |	pkgs := (Package allPackages collect: [:each | each name]) asSet.	buns := (Bundle allBundles collect: [:each | each name]) asSet.	names := OrderedCollection new: pkgs size + buns size.	names addAll: pkgs.	names addAll: buns.	^SelectionInList with: names asSortedCollection asList.</body><body package="Store-DB-Pundles" selector="latestOf:version:">latestOf: aString version: aBlock	"Returns the latest (based on timestamp) version of pundle named aName whose version string satisfies aBlock.	Examples: 		Bundle latestOf: 'Tools' version: [ :version | '*5i*' match: version]		Package latestOf: 'PackageCategories' version: [:version | '*47769*' match: version]"		| query list top |	query := (self newSQL)		select: #(#timestamp #version);		where;		column: #name equalTo: aString asString printString.	list := self broker process: query.	list := list asSortedCollection: [:each :other | each first &gt; other first].	list := list collect: [:columns | columns last].	top := list		detect: aBlock		ifNone: [^nil].	query := (self newSQL)		selectAll;		where;		column: #name equalTo: aString asString printString;		and;		column: #version equalTo: top printString.	^[(self doPostLoadProcessingOn: (self broker process: query bindOutput: self newPrimed)) first]		on: self errorSignals		do:			[:exception | 			exception outer.			nil]</body><body package="Store-DB-Pundles" selector="loadMostRecentlyMergedWithName:">loadMostRecentlyMergedWithName: aName	| aPundle |	aPundle := self mostRecentlyMergedWithName: aName.	aPundle notNil		ifTrue:[aPundle loadSrc].	^aPundle</body><body package="Store-DB-Pundles" selector="loadPundleId:">loadPundleId: primaryKey	"Loads a pundle by key. Note: must be sent to a particular subclass - not the abstract Pundle class."	( self aRecordWithID: primaryKey ) loadSrc</body><body package="Store-DB-Pundles" selector="loadWithName:version:">loadWithName: aName version: aVersion	| aPundle |	aPundle := self pundleWithName: aName version: aVersion.	aPundle notNil		ifTrue:[aPundle loadSrc].	^aPundle</body><body package="Store-DB-Pundles" selector="mostRecentlyMergedWithName:">mostRecentlyMergedWithName: aName 	| packages |	packages := self 		allVersionsWithName: aName 		andBlessingLevel: Policies mergePolicy blessingForIntegrated.	packages isEmpty ifTrue: [^nil].	packages := packages asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp].	^packages first</body><body package="Store-DB-Pundles" selector="pundleWithName:version:">pundleWithName: aName version: aVersion 	| coll |	coll := self withName: aName version: aVersion.	^coll isEmpty ifTrue:[nil] ifFalse:[coll first]</body><body package="Store-DB-Pundles" selector="reloadPundle:id:fromDatabase:">reloadPundle: pundleName id: primaryKey fromDatabase: databaseId 	"Loads a pundle based on the primary key."	"Note: must be sent to a subclass, not the abstract Pundle class."	| choice |	self connection.	(DbRegistry databaseIdentifier = databaseId or: [DbRegistry databaseIdentifier asSymbol printString = databaseId])		ifFalse: 			[^Dialog warn: ((#CannotLoad1sFrom2sNotLoggedOn &lt;&lt; #store &gt;&gt; 'Cannot load &lt;1s&gt; from &lt;2s&gt; - not logged on') 						expandMacrosWith: pundleName						with: databaseId printString)].	choice := Dialog 				choose: ((#_1s2sWasLoadedOrPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; &lt;2s&gt; was loaded or published.') 						expandMacrosWith: self instanceBehavior name						with: pundleName)				labels: (Array 						with: (#ReloadFromTheDatabase &lt;&lt; #store &gt;&gt; 'Reload From the Database') asString						with: (#SetTheParent &lt;&lt; #store &gt;&gt; 'Set the Parent') asString						with: (#DoNothing &lt;&lt; #store &gt;&gt; 'Do Nothing') asString)				values: #(#reload #reset #cancel)				default: #reset.	choice == #cancel ifTrue: [^self].	choice == #reload 		ifTrue: [self loadPundleId: primaryKey]		ifFalse: [self resetPundleId: primaryKey]</body><body package="Store-DB-Pundles" selector="reloadPundle:named:id:fromDatabase:">reloadPundle: aSymbol named: pundleName id: primaryKey fromDatabase: databaseId 	"Loads a pundle based on the primary key."	( self subclassFromType: aSymbol )		reloadPundle: pundleName id: primaryKey fromDatabase: databaseId.</body><body package="Store-DB-Pundles" selector="reloadPundle:type:id:fromDatabase:">reloadPundle: pundleName type: aSymbol id: primaryKey fromDatabase: databaseId 	"Loads a pundle based on the primary key."	( self subclassFromType: aSymbol )		reloadPundle: pundleName id: primaryKey fromDatabase: databaseId.</body><body package="Store-DB-Pundles" selector="rename">rename	"Rename aName to aNewName for all matching records in the db.	Send to appropiate subclass. Only the system admin has rights."		| oldName newName |	oldName := self selectNonBinaryName.	oldName ifNil: [^self].	newName := ''.	[newName := SmalltalkWorkbench requestNewPackageName: newName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(self hasVersionNamed: newName)		ifTrue:			[Dialog warn: (#_1sAlreadyExists &lt;&lt; #store &gt;&gt; '&lt;1s&gt; already exists.' expandMacrosWith: newName).			false]		ifFalse: [true]] whileFalse.	self rename: oldName to: newName</body><body package="Store-DB-Pundles" selector="rename:to:">rename: aName to: aNewName 	"Rename aName to aNewName for all matching records in the db.	Send to appropiate subclass. Only the system admin has rights."	| list |	list := self allVersionsWithName: aName.	list isEmpty	 ifTrue: 		[Dialog warn: #NoPublishedVersions &lt;&lt; #store &gt;&gt; 'No published versions'.		^nil].	Cursor database showWhile: 			[ list do: 				[:pundle | 				self broker process: 					( self newSQL						update;						column: #name equalTo: aNewName printString;						where;						column: #primaryKey equalTo: pundle primaryKey printString					)				]			]</body><body package="Store-DB-Pundles" selector="resetPundleId:">resetPundleId: primaryKey	"Resets the image pundle to match the database pundle indetified by key."	"Note: must be sent to a particular subclass - not the abstract Pundle class."	| dbPundle imgPundle |	dbPundle := self aRecordWithID: primaryKey.	( imgPundle := dbPundle getImagePundle ) == nil		ifTrue: [ ^( Dialog confirm: 						( (#ImageVersionOf1sAdFromTheDatabase &lt;&lt; #store &gt;&gt; 'Image version of &lt;1s&gt; does not exist.&lt;ntt&gt;Load from the database?') 							expandMacrosWith: dbPundle name						)				)  ifTrue: [ self loadPundleId: primaryKey ].				].	imgPundle 		dbTrace: dbPundle primaryKey;		markNotModified.</body><body package="Store-DB-Pundles" selector="selectMultipleVersionsOf:">selectMultipleVersionsOf: aPundleName 	"Display a list of pundle versions. Answer the selections,	nil if none. Send to appropiate subclass."	"Package selectMultipleVersionsOf: 'Store-ImageModel'"	| list |	list := self allVersionsWithName: aPundleName.	list isEmpty ifTrue: 		[Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions').		^nil].	list size == 1 ifTrue: [^OrderedCollection with: list first].	^SimpleDialog new 		chooseMultiple: (#ChooseVersions &lt;&lt; #store &gt;&gt; 'Choose versions...') 		fromList: (list 				collect: [:m | m displayString , ' ' , m blessingLevelString])		values: list		buttons: #()		values: #()		lines: 12		cancel: nil		for: nil</body><body package="Store-DB-Pundles" selector="selectName">selectName	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."	"Bundle selectName"	| list |	list := self allNames asSortedCollection.	list isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	^Dialog 		choose: ((#Choose1s &lt;&lt; #store &gt;&gt; 'Choose &lt;1s&gt;...') expandMacrosWith: self class name asClassNameOnly)		fromList: list		values: list		lines: 15		cancel: [^nil]		for: nil</body><body package="Store-DB-Pundles" selector="selectNonBinaryName">selectNonBinaryName	"Display a list of pundle versions, which if Packages, are not saved Binary. Answer the selection,	nil if none. Send to appropiate subclass."	"Bundle selectNonBinaryName"	| list |	list := self allNonBinaryNames asSortedCollection.	list isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	^Dialog 		choose: ((#Choose1s &lt;&lt; #store &gt;&gt; 'Choose &lt;1s&gt;...') expandMacrosWith: self class name asClassNameOnly)		fromList: list		values: list		lines: 15		cancel: [^nil]		for: nil</body><body package="Store-DB-Pundles" selector="selectVersionOf:">selectVersionOf: pundleName 	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."	| list |	self deprecated: #(#version '7.8' #sunset '8.0' #use 'Store.Glorp.StorePundle class&gt;&gt;#selectStoreVersionOf:').	list := self allVersionsWithName: pundleName.	list isEmpty 		ifTrue: 			[Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions') asString.			^nil].	list size == 1 ifTrue: [^list first].	^Dialog 		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list 				collect: [:m | m displayString , ' ' , m blessingLevelString])		values: list		lines: 10		cancel: [^nil]		for: nil</body><body package="Store-DB-Pundles" selector="silentlyFailSelectVersionOf:">silentlyFailSelectVersionOf: pundleName 	"Display a list of pundle versions. Answer the selection,	nil if none. Don't raise warning if no versions exist. Send to appropiate subclass."	| list |	list := self allVersionsWithName: pundleName.	list isEmpty 		ifTrue: [ ^nil ].	list size == 1 ifTrue: [ ^list first ].	^Dialog 		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list 				collect: [:m | m displayString , ' ' , m blessingLevelString])		values: list		lines: 10		cancel: [^nil]		for: nil</body><body package="Store-DB-Pundles" selector="versionAndBlessingsTextForPundles:">versionAndBlessingsTextForPundles: pundles		| stream blessings |	stream := TextStream on: (String new: 512).	pundles do:		[:each | 		stream			nextPutAllText: each displayString asText allBold;			space;			nextPutAll: each timeStampString;			cr.		blessings := Blessing			blessingsForRecordID: each primaryKey			type: each typeStringForBlessing.		stream nextPutAllText: ((blessings isNil or: [blessings isEmpty])			ifTrue: [(#NoBlessings &lt;&lt; #store &gt;&gt; 'No blessings.') asText emphasizeAllWith: #italic]			ifFalse: [Policies blessingPolicy describeBlessings: blessings])].	^stream contents</body><body package="Store-DB-Pundles" selector="withName:version:">withName: aName version: aVersion 	"Answer a collection of DBRecords."	"Note: should be sent to an appropiate subclass."	^ [(self doPostLoadProcessingOn:					(self broker process:						( self newSQL							selectAll;							where;							column: #name equalTo: aName asString printString;							and;							column: #version equalTo: aVersion asString printString)				 bindOutput: self newPrimed)	 ) asOrderedCollection		] 	on: self  errorSignals 	do: 	[ :ex | ex outer. 			OrderedCollection new 		].</body></methods><methods><class-id>Store.Pundle class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="allNonBinaryNames">allNonBinaryNames	^self allNames</body><body package="Store-DB-Pundles" selector="cache">cache	cache isNil ifTrue: [cache := WeakDictionary new].	^cache</body><body package="Store-DB-Pundles" selector="cache:">cache: anObject	cache := anObject</body><body package="Store-DB-Pundles" selector="legalPublishingProperties">legalPublishingProperties	^LegalPublishingProperties</body><body package="Atomic Compiling and Loading" selector="loadingProperties">loadingProperties	^#( 'version' 'preRead' 'preReadBlock' 'preLoad' 'preLoadBlock' 			'developmentPrerequisites' 'warningSuppressionBlock' 'versionSelectionBlock' 'namespace')</body><body package="Store-DB-Pundles" selector="propertiesPublishingPolicy">propertiesPublishingPolicy	^PropertiesPublishingPolicy</body><body package="Store-DB-Pundles" selector="propertiesPublishingPolicy:">propertiesPublishingPolicy: aSymbol 	(self legalPublishingProperties includes: aSymbol) ifFalse: 		[self error: (#InvalidPropertyPolicy &lt;&lt; #store &gt;&gt; '&lt;1&gt; is not a valid properties publishing policy' 							expandMacrosWith: aSymbol)].	PropertiesPublishingPolicy := aSymbol</body><body package="Atomic Compiling and Loading" selector="useShadowLoader">useShadowLoader	^DbRegistry useAtomicLoader</body><body package="Atomic Compiling and Loading" selector="useShadowLoader:">useShadowLoader: aBoolean	DbRegistry useAtomicLoader: aBoolean</body></methods><methods><class-id>Store.Bundle</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="containsDescription:">containsDescription: aComponentDescription	^self containedItems contains: 		[ :item | aComponentDescription describesSameAs: item ]</body><body package="Store-DB-Pundles" selector="includesDataKey:owner:">includesDataKey: key owner: owner		^( self leafItems 		detect: [ :pkg | pkg includesDataKey: key owner: owner ]		ifNone: [ nil ]  	  ) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDefinitionOf:">includesDefinitionOf: absoluteName		^( self leafItems 		detect: [ :pkg | pkg includesDefinitionOf: absoluteName ]		ifNone: [ nil ]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesMethod:">includesMethod: aMethodDescriptor	^self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor className 		meta: aMethodDescriptor isMeta</body><body package="Store-DB-Pundles" selector="includesSelector:class:">includesSelector: selector class: aClass		^( self leafItems 		detect: [ :pkg | pkg includesSelector: selector class: aClass ]		ifNone: [ nil ]  	  ) ~~ nil</body><body package="Store-DB-Pundles" selector="includesSelector:className:meta:">includesSelector: selector className: className meta: isMeta	"Answer whether the reciver contains className&gt;&gt;aSelector."	self leafItems 		detect: [ :pkg | pkg includesSelector: selector className: className meta: isMeta ]		ifNone: [ ^false ].	^true</body><body package="Store-DB-Pundles" selector="isBundle">isBundle	^true</body><body package="Store-DB-Pundles" selector="isLeaf">isLeaf	^self contents size == 0.</body></methods><methods><class-id>Store.Bundle</class-id> <category>private-file out</category><body package="Store-DB-Pundles" selector="fileOutSelectors:in:on:">fileOutSelectors: aCollection in: aClass on: aFileManager 	| meths cname |	cname := aClass absoluteName.	meths := OrderedCollection new.	aCollection do: 		[ :sel | | meth |		self leafItems 				detect: [ :pkg | ( meth := pkg method: sel forClassNamed: cname meta: aClass isMeta ) ~~ nil ]				ifNone: [ nil ].		meth == nil ifFalse: [ meths add: meth ].		].	self fileOutMethods: meths on: aFileManager.</body></methods><methods><class-id>Store.Bundle</class-id> <category>relationships</category><body package="Store-DB-Pundles" selector="relatedBy:">relatedBy: token 	token == #tt_containsRel ifTrue: [^self containedItems asSet].	^super relatedBy: token</body></methods><methods><class-id>Store.Bundle</class-id> <category>browser support</category><body package="Store-DB-Pundles" selector="allClasses">allClasses	"Answer a collection of classes. The collection contains classes that are defined in the bundle and 	pseudo classes for which only methods or data are defined"	| defined extended |	defined := self classes collect: [ :class | class absoluteName ].	extended := ( MethodsView classNamesInPackages: self leafItems ).	extended addAll: ( ( self data select: [ :elem | elem isInClass ] )				collect: [ :elem | elem environmentString ] ).	defined do: [ :each | extended remove: each ifAbsent: nil ].	extended := extended collect: [ :cName | PseudoClass newNamed: cName ].	^( self classes, extended asOrderedCollection ).</body><body package="Store-DB-Pundles" selector="allMetaclasses">allMetaclasses	"Answer a collection of metaclasses. The collection contains classes that are defined in the package and 	pseudo classes for which only methods or data are defined"	| classes |	classes := Set new.	self leafItems do: [ :pkg | classes addAll: pkg allMetaclasses ].	^classes</body><body package="Store-DB-Pundles" selector="allNameSpaces">allNameSpaces	"Answer a collection of namespaces. The collection contains namespaces that are defined in the package 	and pseudo namespaces for which only data are defined"	| set |	set := Set new.	self leafItems do: [ :pkg | set addAll: pkg allNameSpaces ].	^set</body><body package="Store-DB-Pundles" selector="classInPackageNamed:meta:">classInPackageNamed: aString meta: aBoolean	"Answer a collection of classes. The collection contains classes that are defined in the package and 	pseudo classes for which only methods or data are defined"	| cls |	self leafItems do: 		[ :pkg | 		( cls := pkg classInPackageNamed: aString meta: aBoolean ) == nil			ifFalse: [ ^cls ].		].	^nil</body><body package="Store-DB-Pundles" selector="dataForNamed:">dataForNamed: aFullName 	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName ) ].	^set asOrderedCollection</body><body package="Store-DB-Pundles" selector="dataForNamed:andProtocol:">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName andProtocol: aSymbol) ].	^set asOrderedCollection</body><body package="Store-DB-Pundles" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName	"Answer whether the reciver contains aName.dataKey."	self leafItems 		detect: [ :pkg | pkg includesDataKey: dataKey ownerName: aName ] 		ifNone: [ ^false ].	^true</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:andProtocol:meta:">methodsForClassNamed: cName andProtocol: protocolName meta: isMeta	"Answer a collection of method descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 			( pkg methodsForClassNamed: cName 					andProtocol: protocolName meta: isMeta ) 		].	^set asOrderedCollection</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:meta:">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of methods."	| set |	set := Set new.	self leafItems do: [ :pkg | set addAll: ( pkg methodsForClassNamed: aClassName meta: isMeta ) ].	^set  asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-DB-Pundles" selector="protocolsForClassNamed:meta:">protocolsForClassNamed: aClassName meta: isMeta	"Answer a collection of protocols."	| set |	set := Set new.	self leafItems do: 		[ :pkg | set addAll: ( pkg protocolsForClassNamed: aClassName meta: isMeta ) ].	^set</body><body package="Store-DB-Pundles" selector="protocolsForDataIn:">protocolsForDataIn: anObject	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: ( pkg protocolsForDataIn: anObject ) ].	^set asSortedCollection</body></methods><methods><class-id>Store.Bundle</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="allItems">allItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this 	bundle. 	The list preserves the bundle order. Put this bundle as a last item on the list."	| items |	items := OrderedCollection new.	self containedItems do: 		[ :item | 		item isBundle			ifTrue: [ items addAll: item allItems ]			ifFalse: [ items add: item ]		].	items add: self. 	^items</body><body package="Store-DB-Pundles" selector="allUniqueItems">allUniqueItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this bundle. 	The list preserves the bundle order. 	Put this bundle as a last item on the list. 	Remove duplicates from the list."	| items present |	items := self allItems.	present := Set new: items size.	items := items				select: 					[:each | 					| res |					res := present includes: each.					present add: each.					res not].	^items</body><body package="Store-DB-Pundles" selector="asDBDescription">asDBDescription	^self class partClass new		subBundleRef: self primaryKey		yourself</body><body package="Store-DB-Pundles" selector="classes">classes	"Answer all the classes defined in the receiver's pacakges."	^PkgClassesView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="componentType">componentType	"Answer a symbol representing the class of the receiver."	^#bundle</body><body package="Store-DB-Pundles" selector="containedItems">containedItems	"Answer a collection of TT_Bundles/TT_Packages."	| items |	items := OrderedCollection new: self contents size.	[self contents do: 		[ :each | | item |		item := each asDBComponent.		item notNil ifTrue: [ items add: item ]		]	]	on: self errorSignals	do: [ :ex | ^OrderedCollection new ].	^items</body><body package="Store-DB-Pundles" selector="contents">contents	"Returns a collection of all of the Store.Bundle and Store.Package objects	contained in the receiver. Note, this collection is a list of references	and you need to send #asDBComponent to each element in the collection	to get the actual Bundle or Package object."	contents isNil ifTrue: [self getContent].	^contents</body><body package="Store-DB-Pundles" selector="contents:">contents: aCollection		contents := aCollection</body><body package="Store-DB-Pundles" selector="contentsFromImage:">contentsFromImage:  anImageBundle	"Get record descriptions.	This message assumes that all bundle components	have been published already."	contents := anImageBundle dbContent.	files := anImageBundle fileContent.</body><body package="Store-DB-Pundles" selector="contentsFromImage:pundleFragments:">contentsFromImage:  anImageBundle pundleFragments: aDictionary	"Get record descriptions.	This message assumes that all bundle components	have been published already."	contents := anImageBundle dbContentPundleFragments: aDictionary</body><body package="Store-DB-Pundles" selector="data">data	"Answer all the DataElements defined in the receiver's pacakges."	^DataView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="describeContents">describeContents	| strm |	strm := WriteStream on: String new.	self describeContentsOn: strm level: 0.	^strm contents</body><body package="Store-DB-Pundles" selector="describeContentsOn:level:">describeContentsOn: aStream level: aDepth 	self containedItems		do: 			[:pun | 			aDepth timesRepeat: [aStream tab].			aStream nextPutAll: (pun stringKey: #()); cr.			pun isBundle ifTrue: [pun describeContentsOn: aStream level: aDepth + 1]]</body><body package="Store-DB-Pundles" selector="descriptionAndLevels:level:">descriptionAndLevels: collection level: aDepth 	self containedItems do: 		[ :pun | 		collection add: ( Array with: pun with: aDepth ).		pun isBundle 			ifTrue: [ pun descriptionAndLevels: collection level: aDepth + 1 ]		].	^collection.</body><body package="Store-DB-Pundles" selector="fileDescriptions">fileDescriptions	"Answer a collection of FileModels for any files that are associated with the receiver."	^self files collect: [:file | file asComponentDescription]</body><body package="Store-DB-Pundles" selector="files">files		files isNil ifTrue: [self getContent].	^files</body><body package="Store-DB-Pundles" selector="getImagePundle">getImagePundle	"Check if there if already loaded versions of a bundle and answer it"	^Registry bundleNamed: self name.</body><body package="Store-DB-Pundles" selector="itemCount">itemCount	"Answer a count of work to be done."	^self containedItems inject: 1 into:		[ :sz :pun | sz + pun itemCount ]</body><body package="Store-DB-Pundles" selector="leafItems">leafItems	"Answer a list of packages contianed in this bundle 	and in bundles contained by this bundle."	| items |	items := OrderedCollection new.	self isInCurrentDatabase		ifFalse: [ ^items ].	self containedItems do: [:item | items addAll: item leafItems].	^items</body><body package="Store-DB-Pundles" selector="metaclasses">metaclasses	"Answer all the classes defined in the receiver's pacakges."	| coll |	coll := OrderedCollection new.	self leafItems do:		[ :pkg | coll addAll: pkg metaclasses ].	^coll.</body><body package="Store-DB-Pundles" selector="methods">methods	"Answer all the methods defined in the receiver's packages."	^MethodsView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="nameSpaces">nameSpaces	"Answer all the namespaces defined in the receiver's packages."	^PkgNameSpacesView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="pundleChangesClass">pundleChangesClass	^BundleChanges</body><body package="Store-DB-Pundles" selector="traceBundle">traceBundle		^self parentRecord</body><body package="Store-DB-Pundles" selector="uniqueItemsAndLevels">uniqueItemsAndLevels	"Answer a colleciton of description level pairs"	| collection |	collection := OrderedCollection new.	self descriptionAndLevels: collection level: 1.	^collection</body></methods><methods><class-id>Store.Bundle</class-id> <category>utilities-repository</category><body package="Store-DB-Pundles" selector="installContentInDatabase">installContentInDatabase	1 to: contents size do: [:i | 		(contents at: i)			seqNumber: i;			bundleRef: self primaryKey; 			installInDatabase]</body><body package="Store-DB-Pundles" selector="installFilesInDatabase">installFilesInDatabase	files == nil		ifTrue: [ ^self ].	files do: 		[ :file | 		file 			bundleRef: self primaryKey; 			installInDatabase		]</body><body package="Store-DB-Pundles" selector="installInDatabase">installInDatabase 	"Install and store package list."	super installInDatabase.	self installContentInDatabase.	self installFilesInDatabase.</body><body package="Store-DB-Pundles" selector="installSqlString">installSqlString	"Column names must be String, for consistency with #columnNames"	^ self newSQL		insertColumnsValues:  #( 'primaryKey' 'name' 'timeStamp' 'version' 'userName' 'trace' 'commentID' 'propertiesID' ).</body><body package="Store-DB-Pundles" selector="loadSrcWithin:">loadSrcWithin: parentBundle	"Load the contents form the database. Answer an image bundle."	^BundleModel newFromDB: self within: parentBundle.</body><body package="Store-DB-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForBundles</body></methods><methods><class-id>Store.Bundle</class-id> <category>private</category><body package="Store-DB-Pundles" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry bundleNamedOrCreate: ', self name printString, '  ) '.</body><body package="Store-DB-Pundles" selector="definesClass:">definesClass: aClass 	^self includesDefinitionOf: aClass absoluteName asClassNameOnly</body><body package="Store-DB-Pundles" selector="definesName:in:">definesName: key in: nameSpace	^self includesDataKey: key owner: nameSpace</body><body package="Store-DB-Pundles" selector="definesObject:">definesObject: aNameSpace 	^self includesDefinitionOf: aNameSpace absoluteName</body><body package="Store-DB-Pundles" selector="definesSelector:forClass:">definesSelector: aSymbol forClass: aClass		^self		includesSelector: aSymbol		className: aClass absoluteName asClassNameOnly		meta: aClass isMeta</body><body package="Store-DB-Pundles" selector="descriptionClass">descriptionClass	^BundleDescription</body><body package="Store-DB-Pundles" selector="downloadFiles">downloadFiles	| allFiles | 	Store.DbRegistry is73Enabled  		ifFalse: [ ^self ].	allFiles := OrderedCollection new.	(self allUniqueItems collect: [ :p | p isBundle ifTrue: [ p files ] ifFalse: [ #() ] ] ) do: [:each | allFiles addAll: each].	allFiles size &gt; 0		ifFalse: [ ^self ].	allFiles := allFiles collect: [ :f | FileRecord aRecordWithID: f fileRef ].	Policies filePolicy downloadFiles: allFiles</body><body package="Store-DB-Pundles" selector="getContent">getContent	"Consult the database and retrive components 	descriptions."	| packages bundles |	bundles := Bundles allFromBundleID: self primaryKey.	packages := Packages allFromBundleID: self primaryKey.	files := DbRegistry is73Enabled		ifTrue: [ ( Files allFromBundleID: self primaryKey ) asList ]		ifFalse: [ OrderedCollection new asList ].	contents := ((bundles , packages) asSortedCollection: [:x :y | x seqNumber &lt; y seqNumber]) asList</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	contents := Object new.	files := Object new.</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	contents := nil.	files :=  nil.</body></methods><methods><class-id>Store.Bundle</class-id> <category>private-differences calculation</category><body package="Store-DB-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aBundle into: aComparitor	^aBundle computeDiffsBetweenDBBundle: self into: aComparitor</body><body package="Store-DB-Pundles" selector="computeDiffsBetweenDBBundle:into:">computeDiffsBetweenDBBundle: aDBBundle into: diff	"Store  differences between receiver and a aDBPackage into an instance of 	PackageDifferences. Store receiver's definitions as number2 since this method	is called with arguments reversed. "	| myPackages dbPackages pkgs dbpkgs |	myPackages := self leafItems collect: [ :pkg | pkg primaryKey printString ].	dbPackages := aDBBundle  leafItems collect: [ :pkg | pkg primaryKey printString ].	pkgs := myPackages reject: [ :pkg | dbPackages includes: pkg ].      dbpkgs := dbPackages reject: [ :pkg | myPackages  includes:  pkg ].	diff nameSpacesSide: 2 put: (NameSpaceRecord allInPackages: pkgs butNotIn: dbpkgs).	diff classesSide: 2 put: (ClassRecord allInPackages: pkgs butNotIn: dbpkgs).	diff metaSide: 2 put: (ClassRecord allMetaclassesInPackages: pkgs butNotIn: dbpkgs).	diff methodsSide: 2 put: (Method allInPackages: pkgs butNotIn: dbpkgs).	diff dataSide: 2 put: (DataElement allInPackages: pkgs butNotIn: dbpkgs ).	diff nameSpacesSide: 1 put: (NameSpaceRecord allInPackages: dbpkgs butNotIn: pkgs).	diff classesSide: 1 put: (ClassRecord allInPackages: dbpkgs butNotIn: pkgs).	diff metaSide: 1 put: (ClassRecord allMetaclassesInPackages: dbpkgs butNotIn: pkgs).	diff methodsSide: 1 put: (Method allInPackages: dbpkgs butNotIn: pkgs).	diff dataSide: 1 put: (DataElement allInPackages: dbpkgs butNotIn: pkgs).	^diff</body></methods><methods><class-id>Store.Bundle</class-id> <category>private-accessing</category><body package="Store-DB-Pundles" selector="ownRecordForTag:">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^aTag isComponentTag		ifTrue: [ aTag recordForPackage: self ].</body><body package="Store-DB-Pundles" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^aTag copy		package: self; 		yourself</body><body package="Store-DB-Pundles" selector="recordForTag:">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	aTag isComponentTag		ifTrue: [ ^aTag recordForPackage: self ].	self leafItems do:		[ :pkg | | rec |		( rec := pkg recordForTag: aTag ) == nil			ifFalse: [ ^rec ]		].	^nil</body></methods><methods><class-id>Store.Bundle</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="loadSourceWithinSelf">loadSourceWithinSelf		| imageBundle |	Notice		showNotice: (#Loading1s &lt;&lt; #store &gt;&gt; 'Loading &lt;1s&gt;' expandMacrosWith: self itemString)		complete: self itemCount		while:			[([imageBundle := self loadSrcWithin: self]				on: RedefinitionNotification				do:					[:notification | 					notification override install.					notification resume])				ifNotNil:					[ChangeSet loadPundle: self.					SourceFileManager default loadPundle: self.					imageBundle cleanUpOverrides.					self downloadFiles]]		title: #Store &lt;&lt; #store &gt;&gt; 'Store'.	Undeclared purgeUnusedBindings.	^imageBundle</body><body package="Store-DB-Pundles" selector="loadSrc">loadSrc	"Load the contents form the database. Answer an image bundle.	This must be the outer bundle."	^self asStorePundle loadSource"	| imageBundle |	self class useShadowLoader ifTrue:		[^self asStorePundle loadSource].	imageBundle := self loadSourceWithinSelf.	self prerequisiteRecursionReset.	^imageBundle"</body></methods><methods><class-id>Store.Bundle</class-id> <category>shadow loading</category><body package="Atomic Compiling and Loading" selector="defaultCompileManager">defaultCompileManager	^ShadowBundleCompileManager</body></methods><methods><class-id>Store.Bundle</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="sourceOrBinaryString">sourceOrBinaryString	^''.</body></methods><methods><class-id>Store.Bundle</class-id> <category>fileIn/Out</category><body package="Store-DB-Pundles" selector="fileOutOn:">fileOutOn: aFileManager 	"When writing the Bundle to aFileManager, we need to ensure that there is a change to	 both create the Bundle and to set its structure.  The structure change needs to be written	 out after all the contained items have been filed out."	(ComponentCreatedChange new component: self) fileOutOn: aFileManager.	self fileOutPropertiesOn: aFileManager.	self containedItems do: 		[ :comp | comp fileOutOn: aFileManager ].	(BundleStructureChange new component: self) fileOutOn: aFileManager.</body></methods><methods><class-id>Store.Bundle</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI" selector="storeForGlorpPundleClass">storeForGlorpPundleClass	^self class storeDatabaseClass</body></methods><methods><class-id>Store.Bundle class</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="objectionsToPublishing:atBlessing:">objectionsToPublishing: imBndl atBlessing: level 	"Answer true if there are no bojections to publishing 	the imPkg at blessing level 'level'"	^Policies publishPolicy objectionsToPublishingBundle: imBndl atBlessingLevel: level.</body></methods><methods><class-id>Store.Bundle class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="newFrom:userData:">newFrom: anImageBundle userData: userData 	"Given a image bundle create a new record in the database.	Only a description of this bundle has to be stored in the database.	Version checking and policy checking is done BEFORE this message	is sent."	| newDBBundle transaction res propRecords |	newDBBundle := self newFrom: anImageBundle.	newDBBundle version: userData version.	transaction :=		[ newDBBundle contentsFromImage: anImageBundle.		newDBBundle installInDatabase.		self shouldSavePropertyRecords					ifTrue: [ propRecords := self propertyRecordsFromPundle: anImageBundle.							"Insert the property records and/or links into the DB."							newDBBundle addProperties: propRecords].		newDBBundle addBlessingLevel: (userData at: #blessing)			andComment: (userData at: #comment) asString.		newDBBundle		].	MessageNotification raiseSignal:  ( (#bundle1s &lt;&lt; #store &gt;&gt; 'bundle &lt;1s&gt;') expandMacrosWith: newDBBundle name ).	ResetIncrementNotification signalWith: anImageBundle itemCount.	res := self broker publishTransaction: transaction.	res notNil		ifTrue:			[ anImageBundle				dbTrace: newDBBundle primaryKey;				setContentsFromDB: res;				markNotModified.			].	^res</body><body package="Store-DB-Pundles" selector="newFrom:userData:pundleFragments:">newFrom: anImageBundle userData: userData pundleFragments: aCollection 	"Given a image bundle create a new record in the database. 	Only a description of this bundle has to be stored in the database.	Version checking and policy checking is done BEFORE this message	is sent."	| newDBBundle transaction res propRecords |	newDBBundle := self newFrom: anImageBundle.	newDBBundle version: (userData at: #version).	transaction := 			[newDBBundle contentsFromImage: anImageBundle pundleFragments: aCollection.			newDBBundle installInDatabase.			self shouldSavePropertyRecords 				ifTrue: 					[propRecords := self propertyRecordsFromPundle: anImageBundle.					"Insert the property records and/or links into the DB."					newDBBundle addProperties: propRecords].			newDBBundle addBlessingLevel: (userData at: #blessing)				andComment: (userData at: #comment) asString.			newDBBundle].	res := self broker 				publishTransaction: transaction				showing: (#PublishingBundle1s &lt;&lt; #store &gt;&gt; 'Publishing bundle: &lt;1s&gt;' 						expandMacrosWith: newDBBundle name)				count: anImageBundle itemCount.	^res</body></methods><methods><class-id>Store.Bundle class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="allBundles">allBundles	"Answer a SortedCollection of TT_Bundles"	"self allBundles"	^self allPackagesOrBundles</body><body package="Store-DB-Pundles" selector="knownBundles">knownBundles	"Answer a SelectionInList containing names of 	all bundles stored in DB."	"self knownBundles"	^self knownPackagesOrBundles</body></methods><methods><class-id>Store.Bundle class</class-id> <category>class initalization</category><body package="Store-DB-Pundles" selector="initialize">initialize	"TT_Bundle initialize"	self initializeCache.</body></methods><methods><class-id>Store.Bundle class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames	"Answer all the instance variable names that coorespond to column names in the database table."		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'contents'.	columnNames remove: 'files'.	^columnNames</body><body package="Store-DB-Pundles" selector="deInstallBundles">deInstallBundles	"self deInstallBundles "	self broker dropTableForClass: self.	self broker dropTableForClass: Bundles.	self broker dropTableForClass: Packages.	self broker dropTableForClass: Files.</body><body package="Store-DB-Pundles" selector="installBundles">installBundles	"self installBundles"	self createDatabaseTable.	Bundles createDatabaseTable.	Packages createDatabaseTable.	Files createDatabaseTable.</body></methods><methods><class-id>Store.Bundle class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="imageClass">imageClass	^BundleModel</body><body package="Store-DB-Pundles" selector="partClass">partClass	^Bundles</body><body package="StoreForGlorpVWUI" selector="storeDatabaseClass">storeDatabaseClass	^Store.Glorp.StoreBundle</body></methods><methods><class-id>Store.Bundle class</class-id> <category>private</category><body package="Store-DB-Pundles" selector="newFrom:">newFrom: anImagePundle 	"Given a image pundle create a new instance of the receiver.		This is a private method used by all public methods that store pundles in the database.	And make sure it gets initialized first"	anImagePundle initializeForReconcileWith: nil.	^super newFrom: anImagePundle.</body></methods><methods><class-id>Store.Bundle class</class-id> <category>private-accessing</category><body package="Store-DB-Pundles" selector="defaultBlockFactor">defaultBlockFactor  	^100</body></methods><methods><class-id>Store.Bundle class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_BundleName' #('name'))		#('ST_BundleTimestamp' #('timeStamp'))		#('ST_BundleVersion' #('version'))		#('ST_BundleProperties' #('propertiesID'))		#('ST_BundleGCSupport' #('trace'))		)</body></methods><methods><class-id>Store.Glorp.StorePundleNavigatorPart</class-id> <category>updating widgets</category><body package="StoreForGlorpBrowserUI" selector="addBindingPackages:to:">addBindingPackages: aNavigatorState to: pundles 	aNavigatorState classesAndNameSpaces do: 		[:each | 		self 			addPackagesIfAbsent: (self environment packagesContaining: each)			to: pundles]</body><body package="StoreForGlorpBrowserUI" selector="addSharedVariablePackages:to:">addSharedVariablePackages: aNavigatorState to: pundles 	navigator showOnlyFiltered ifFalse: [^self].	aNavigatorState classesAndNameSpaces do:		[:each | 		| packages |		packages := self environment packagesContaining: each.		self addPackagesIfAbsent: packages to: pundles]</body></methods><methods><class-id>Store.Glorp.StoreClassEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="at:ifAbsent:">at: aBinding ifAbsent: aBlock	^environment at: aBinding asString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="bindingReferencesDo:">bindingReferencesDo: aBlock	environment bindingReferencesDo: aBlock</body><body package="StoreForGlorpBrowserUI" selector="glorpSession">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI" selector="includesClass:">includesClass: aClass 	^(aClass isMeta		ifTrue: [classBehaviorNames includes: aClass fullRootName]		ifFalse: [instanceBehaviorNames includes: aClass fullRootName])			and: [environment includesClass: aClass mainClass]</body><body package="StoreForGlorpBrowserUI" selector="navigatorClass">navigatorClass		^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI" selector="openEditor">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI" selector="pundleNamed:isPackage:">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body><body package="StoreForGlorpBrowserUI" selector="pundles">pundles	^environment pundles</body><body package="StoreForGlorpBrowserUI" selector="repositoryName">repositoryName	^environment repositoryName</body><body package="StoreForGlorpBrowserUI" selector="sharedVariable:for:">sharedVariable: aName for: aClassOrNameSpace	^environment sharedVariable: aName for: aClassOrNameSpace asString</body><body package="StoreForGlorpBrowserUI" selector="sharedVariableProtocolsFor:">sharedVariableProtocolsFor: aClass	^environment sharedVariableProtocolsFor: aClass</body><body package="StoreForGlorpBrowserUI" selector="sharedVariableReferencesDo:">sharedVariableReferencesDo: aBlock 	self bindingReferencesDo: 		[:each | 		| binding |		binding := each bindingOrNil.		(binding notNil and: [binding isForSharedVariable and: [binding isInClass]]) ifTrue: [aBlock value: each]]</body><body package="StoreForGlorpBrowserUI" selector="sharedVariablesFor:in:">sharedVariablesFor: aProtocol in: aClassOrNameSpace	^environment sharedVariablesFor: aProtocol in: aClassOrNameSpace</body><body package="StoreForGlorpBrowserUI" selector="sharedVariablesForClass:">sharedVariablesForClass: aClass 	^environment sharedVariablesForClass: aClass</body><body package="StoreForGlorpBrowserUI" selector="whichProtocolIncludesVariable:in:">whichProtocolIncludesVariable: aSymbol in: aClass	| result |	result := self pundles first sharedVariables 		detect: [:each | each absoluteOwnerName asString = aClass longName and: [each name = aSymbol]]		ifNone: [^nil].	^result protocol</body></methods><methods><class-id>Store.Glorp.StoreClassEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI" selector="classForName:ifAbsent:">classForName: aString ifAbsent: aBlock	"We may sometimes hand out object name wrappers but should always receive full names back from our navigator and state.  (Our code assumes that aBlock will either return or answer something that responds to #objectNamed:)"	| containingPundle theClass |	containingPundle := self pundles		detect: [:each | (each objectNamed: aString) notNil]		ifNone: aBlock.	theClass := containingPundle objectNamed: aString.	^theClass isNil ifTrue: aBlock ifFalse: [theClass]</body><body package="StoreForGlorpBrowserUI" selector="classesDo:">classesDo: aBlock 	instanceBehaviorNames do: 			[:each | 			| class |			class := environment classForName: each.			(class notNil and: [environment includesClass: class]) 				ifTrue: [aBlock value: class]].	classBehaviorNames do: 			[:each | 			| class |			class := environment classForName: each.			(class notNil and: [environment includesClass: class storeMetaClass]) 				ifTrue: [aBlock value: class storeMetaClass]]</body></methods><methods><class-id>Store.ParcelRecord</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="isParcel">isParcel	^true</body></methods><methods><class-id>Store.ParcelRecord</class-id> <category>private</category><body package="Store-DB-Pundles" selector="getDefinitionID:">getDefinitionID: anID	"Override definition in Record because my definitions are raw data."	^(self getDefinitionRecordID: anID) rawData</body><body package="Store-DB-Pundles" selector="prepareInstallation">prepareInstallation	"Create first records for both definition string and comment string."	self sourceID == nil		ifTrue: [ self sourceID: (self class definitionClass fromRawData: sourceData ) primaryKey ].	self blobID == nil		ifTrue: [ self blobID: ( self class definitionClass fromRawData: blobData ) primaryKey ].</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	pundle := blobData := sourceData := Object new.</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	pundle := blobData := sourceData := nil.</body></methods><methods><class-id>Store.ParcelRecord</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asString">asString	"Answer a string representation - for binary parcel loading"	^name</body><body package="Store-DB-Pundles" selector="blobData">blobData	"Allow for lazy evaluation."	blobData == nil		ifTrue: [ blobData := self getDefinitionID: self blobID ].	^blobData</body><body package="Store-DB-Pundles" selector="blobData:">blobData: byteArray	^blobData := byteArray</body><body package="Store-DB-Pundles" selector="blobID">blobID	^blobID</body><body package="Store-DB-Pundles" selector="blobID:">blobID: anInteger	blobID := anInteger</body><body package="Store-DB-Pundles" selector="defaultParcelName">defaultParcelName	"This method is used to return a name that can be used in the creation	of a temporary source file (*.pst) when loading a parcel from a Store	database.  Currently only uses [name][primaryKey].pst but will need to	also have some way of identifying the database being accessed since	two different ParcelRecords in two different databases could have the	same name and the same primary key."	self needsMoreWork.	^name, primaryKey printString</body><body package="Store-DB-Pundles" selector="filename">filename	^filename</body><body package="Store-DB-Pundles" selector="filename:">filename: aFilename	filename := aFilename</body><body package="Store-DB-Pundles" selector="getImagePundle">getImagePundle	"Check if there is already loaded versions of the receiver and answer it"	^Parcel parcelNamed: self name.</body><body package="Store-DB-Pundles" selector="parcelName">parcelName	"Answer a parcel name for the receiver - use the package properties where possible."	^pundle == nil		ifTrue: [ name ]		ifFalse: [ pundle parcelName ].</body><body package="Store-DB-Pundles" selector="pundle:">pundle: value	pundle := value</body><body package="Store-DB-Pundles" selector="pundleID">pundleID	^pundleID</body><body package="Store-DB-Pundles" selector="pundleID:">pundleID: anInteger	pundleID := anInteger</body><body package="Store-DB-Pundles" selector="readHeader">readHeader	[^CodeReader new readHeaderFromRecord: self]		on: CodeReader fileFormatSignal		do:[:ex | ex return]</body><body package="Store-DB-Pundles" selector="readInfo">readInfo	[^CodeReader new readInfoFromRecord: self]		on: CodeReader fileFormatSignal		do:[:ex | ex return]</body><body package="Store-DB-Pundles" selector="sourceData">sourceData	"Allow for lazy evaluation."	sourceData == nil		ifTrue: [ sourceData := self getDefinitionID: self sourceID ].	^sourceData</body><body package="Store-DB-Pundles" selector="sourceData:">sourceData: byteArray	^sourceData := byteArray</body><body package="Store-DB-Pundles" selector="sourceID">sourceID	^sourceID</body><body package="Store-DB-Pundles" selector="sourceID:">sourceID: anInteger	sourceID := anInteger</body><body package="Store-DB-Pundles" selector="sourceStream">sourceStream	"Answer an internal encoded source stream on the package source."		^self sourceData == nil		ifTrue: [ nil ]		ifFalse: [ ( sourceData withEncoding: #Source) "readStream" ]</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames		"self columnNames"	 ^super columnNames	 	remove: 'pundle';		remove: 'blobData' ;		remove: 'sourceData';		yourself</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes		" self fieldTypes "	^super fieldTypes		 at: 'pundleID' put: #Integer;		 at: 'blobID' put: #Integer;		 at: 'sourceID' put: #Integer;		 at: 'pundleType' put: #Char;		yourself</body><body package="Store-DB-Pundles" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="from:">from: aPackage	"Create a parcel record for a packagel.  	Do not install the record in the database."	^( self newNamed: aPackage name )		pundleID: aPackage primaryKey.</body><body package="Store-DB-Pundles" selector="newNamed:">newNamed: aName 	"Create a record for a parcel. Put the name and the time stamp. 	Do not install the package in the database."	^self new		setNoTrace; 		name: aName; 		timeStamp: self timeStamp;		yourself.</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="definitionClass">definitionClass	^BinaryBlob</body><body package="Store-DB-Pundles" selector="imageClass">imageClass	^Parcel</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_ParcelName' #('name'))		#('ST_ParcelTimestamp' #('timeStamp'))		#('ST_ParcelVersion' #('version'))		#('ST_ParcelGCSupport' #('trace'))		)</body><body package="Store-DB-Pundles" selector="parcelDirectory">parcelDirectory	"self parcelDirectory"	| dir |	dir := PundleAccess parcelDirectory.	^DbRegistry databaseIdentifier		ifNil: [ dir ]		ifNotNil: [ :dbIdentifier| dir := dir construct:  ( Filename canonicalize: dbIdentifier ) ]</body></methods><methods><class-id>Store.IgnorePossibleOverrideNotice</class-id> <category>private - actions</category><body package="Store-Merge Management" selector="defaultAction">defaultAction	^false</body></methods><methods><class-id>Store.IgnorePossibleOverrideNotice class</class-id> <category>testing</category><body package="Store-Merge Management" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>actions</category><body package="Store-UI" selector="fileClose">fileClose	self closeRequest</body><body package="Store-UI" selector="fileImport">fileImport	self class importRepositoriesFromFile</body><body package="Store-UI" selector="fileSave">fileSave	self class saveRepositoriesToFile</body><body package="Store-UI" selector="helpAbout">helpAbout	AboutVisualWorksDialog open</body><body package="Store-UI" selector="repositoryMoreRecentlyPublishedItems">repositoryMoreRecentlyPublishedItems	DbRegistry doIfOnlineImage: 		[[Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItems] withStoreFeedbackOn: self mainWindow]</body><body package="Store-UI" selector="repositoryNew">repositoryNew	RepositoryManager addProfileFromUser ifNotNil: 		[:newProfile | self repositoryListHolder selection: newProfile]</body><body package="Store-UI" selector="repositoryProperties">repositoryProperties	self repositoryListHolder selectionDo:		[:selection |		RepositoryPropertiesDialog openOn: selection.		self class updateRepository: selection]</body><body package="Store-UI" selector="repositoryPublishedItems">repositoryPublishedItems	DbRegistry 		doIfOnlineImage: [Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundles]</body><body package="Store-UI" selector="repositoryRemove">repositoryRemove	self repositoryListHolder selectionDo:		[:selection |		(Dialog confirm: #repmanRemoveRepositoryQuestion &lt;&lt; #labels &gt;&gt; 'Remove the selected repository?') 			ifTrue: [self class removeRepository: selection]]</body><body package="Store-UI" selector="repositoryToggleConnection">repositoryToggleConnection	Cursor wait showWhile:		[self repositoryListHolder selectionDo:			[:profile |			profile isConnected				ifTrue: [DbRegistry disconnect]				ifFalse: [DbRegistry connectTo: profile]]]</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	DbRegistry connectedProfileHolder		onChangeSend: #connectedProfileChanged		to: self</body><body package="Store-UI" selector="on:">on: aProfileCollection	self setRepositoryList: aProfileCollection</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	| descriptors |	descriptors := (self widgetAt: #repositoryDataset) columnDescriptors.	descriptors first rendererSpec: self statusColumnSpec.</body><body package="Store-UI" selector="release">release	super release.	DbRegistry connectedProfileHolder		retractInterestsFor: self</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>notifications</category><body package="Store-UI" selector="connectedProfileChanged">connectedProfileChanged	self refreshRepositoryView</body><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self release.	^super noticeOfWindowClose: aWindow</body><body package="Store-UI" selector="repositoryListDoubleClicked">repositoryListDoubleClicked	self repositoryToggleConnection</body><body package="Store-UI" selector="repositorySelected">repositorySelected	self updateToolbar</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>aspects</category><body package="Store-UI" selector="repositoryListHolder">repositoryListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^repositoryListHolder isNil		ifTrue:			[repositoryListHolder :=  SelectionInList new]		ifFalse:			[repositoryListHolder]</body><body package="Store-UI" selector="selectedRepositoryHolder">selectedRepositoryHolder	^self repositoryListHolder selectionHolder</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>menus</category><body package="Store-UI" selector="menuBar">menuBar	| menu |	menu := self class menuBar.	menu		augmentFrom: self class		to: RepositoryManager		menuName: #menuBar		for: self.	(menu atNameKey: #repositoryToggleConnection) 		rawLabel: [self repositoryToggleConnectionItemLabel].	^menu</body><body package="Store-UI" selector="repositoryListMenu">repositoryListMenu	| menu |	menu := self class repositoryListMenu.	menu 		augmentFrom: self class		to: RepositoryManager		menuName: #listMenu		for: self.	(menu atNameKey: #repositoryToggleConnection) 		rawLabel: [self repositoryToggleConnectionItemLabel].	^menu</body><body package="Store-UI" selector="repositoryToggleConnectionItemLabel">repositoryToggleConnectionItemLabel	^self repositoryListHolder selection		ifNil: [#repmanConnectItem &lt;&lt; #labels &gt;&gt; '&amp;Connect']		ifNotNil: [:profile |			profile isConnected 				ifTrue: [#repmanDisconnectItem &lt;&lt; #labels &gt;&gt; '&amp;Disconnect'] 				ifFalse: [#repmanConnectItem &lt;&lt; #labels &gt;&gt; '&amp;Connect']]</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>private</category><body package="Store-UI" selector="connectedRepositoryIcon">connectedRepositoryIcon	^connectedIcon ifNil: 		[connectedIcon := ToolbarIconLibrary visualFor: #store]</body><body package="Store-UI" selector="refreshRepositoryView">refreshRepositoryView	(self widgetAt: #repositoryDataset) invalidate</body><body package="Store-UI" selector="setRepositoryList:">setRepositoryList: aList	self repositoryListHolder list: Repositories</body><body package="Store-UI" selector="statusColumnSpec">statusColumnSpec	^ArbitraryViewSpec new		source: #statusColumnVisual:;		flags: 0</body><body package="Store-UI" selector="statusColumnVisual:">statusColumnVisual: isConnected 	^isConnected 		ifTrue: [self connectedRepositoryIcon]		ifFalse: [VisualPart new]</body><body package="Store-UI" selector="updateToolbar">updateToolbar	(self widgetAt: #toolbarMenu) updateMenu</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>testing</category><body package="Store-UI" selector="isRepositorySelected">isRepositorySelected	^self repositoryListHolder selectionIndex ~= 0</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>accessing</category><body package="Store-UI" selector="addRepository:">addRepository: aProfile	Repositories 		add: aProfile;		sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI" selector="removeRepository:">removeRepository: aProfile	Repositories remove: aProfile</body><body package="Store-UI" selector="repositories">repositories	^Repositories</body><body package="Store-UI" selector="sortRepositoryList">sortRepositoryList	Repositories sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI" selector="updateRepository:">updateRepository: aProfile	| index |	index := Repositories indexOf: aProfile.	index = 0 ifFalse: [Repositories changed: #at: with: index].	DbRegistry connectedProfileHolder value = aProfile		ifTrue: [DbRegistry connectedProfileHolder changed: #value]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>private</category><body package="Store-UI" selector="addRepositories:">addRepositories: aCollection	Repositories 		removeAllSuchThat: 			[:existingProfile | 			aCollection anySatisfy: [:newProfile| newProfile = existingProfile]];		addAll: aCollection;		sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI" selector="replaceRepositoriesWith:">replaceRepositoriesWith: aCollection	Repositories 		removeAllSuchThat: [:anything | true];		addAll: aCollection;		sortWith: [:a :b | a name &lt; b name]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>instance creation</category><body package="Store-UI" selector="new">new	^super new on: self repositories</body><body package="Store-UI" selector="open">open	"Override to use the currently-open manager, if one exists."	^self raiseSingleInstance ifNil: [super open]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>utilities</category><body package="Store-UI" selector="addProfileFromUser">addProfileFromUser	| newProfile |	newProfile := Store.ConnectionProfile new.	newProfile name: (#Repository1p &lt;&lt; #store &gt;&gt; 'Repository &lt;1p&gt;' expandMacrosWith: Repositories size + 1).	^(RepositoryPropertiesDialog openOn: newProfile) 		ifTrue: 			[self addRepository: newProfile.			newProfile]		ifFalse: [nil]</body><body package="Store-UI" selector="importRepositoriesFromFile">importRepositoriesFromFile		| stream dialog filename |	dialog := OpenFileDialog new.	dialog		windowTitle: #importRepositoriesFilesNamed1C &gt;&gt; 'Import repositories file named:' &lt;&lt; #dialogs;		acceptButtonLabel: #import &gt;&gt; 'Import' &lt;&lt; #dialogs;		addFileFilter: 'XML file (*.xml)' pattern: '*.xml';		defaultFilename: 'repositories.xml';		fileCondition: #mustBeOld.	filename := dialog select ifNil: [^self].	stream := (filename asFilename withEncoding: #UTF_8) readStream.	self importRepositoriesFromStream: stream</body><body package="Store-UI" selector="importRepositoriesFromStream:">importRepositoriesFromStream: aStream	"Read the repositories from aStream using the Settings framework.  Try to be	 backward compatible with older versions of repository files that might have 	 been created in 7.5 or earlier releases.  The receiver will close aStream."		| reader |	reader := SettingReader on: VisualWorksSettings current.	[[reader readFrom: aStream] ensure: [aStream close].	reader snapshots do: [:collection| StoreRepositoryListSetting new restoreFrom: collection]]		on: InvalidStoredSettingDataError		do:			[:ex | 			aStream reset.			[self importRepositoriesFromXmlOn: aStream] ensure: [aStream close]]</body><body package="Store-UI" selector="saveRepositoriesToFile">saveRepositoriesToFile		| filenameString stream |	filenameString := Dialog		requestFileName: #SaveRepositoriesToFileNamed &lt;&lt; #store &gt;&gt; 'Save repositories to file named:'		default: 'repositories.xml'.	filenameString isEmpty ifTrue: [^self].	stream := (filenameString asFilename withEncoding: #UTF_8) writeStream.	self saveRepositoriesToStream: stream</body><body package="Store-UI" selector="saveRepositoriesToStream:">saveRepositoriesToStream: aStream	"Write the Repositories to aStream.  Ensure that the format of the file is 	 compatible with the Settings tool.  The receiver will close the stream."	| writer |	writer := SettingsWriter		on: VisualWorksSettings current		settings: VisualWorksSettings storeRepositoriesPage settings.	[writer writeTo: aStream] ensure: [aStream close]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>deprecated</category><body package="Store-UI" selector="importRepositoriesFromXmlOn:">importRepositoriesFromXmlOn: aStream	"This method is deprecated and will be removed in a future release."	| loadedRepositories |	loadedRepositories := self repositoriesFromXmlOn: aStream.	self addRepositories: loadedRepositories</body><body package="Store-UI" selector="repositoriesFromXmlOn:">repositoriesFromXmlOn: aStream 	"This method is deprecated and will be removed in a future release."	| parser document loadedRepositories |	parser := XMLParser new.	parser validate: false.	document := parser parse: aStream.	document root tag type = 'store-repositories' ifFalse: 		[self error: 'invalid file format'].	loadedRepositories := document root realElements collect: 		[:each | ConnectionProfile fromXmlElement: each].	^loadedRepositories</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileIn">fileIn	"File-in the receiver - ie. make the change to the system."	Pundle 		reloadPundle: componentType 		named: componentName  		id: primaryKey  		fromDatabase: databaseId</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aSourceFile	aSourceFile		loadPundleNamed: componentName		type: componentType		primaryKey: databaseId		databaseId: primaryKey</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>testing</category><body package="Store-Change Management" selector="sameAsSystem">sameAsSystem	"Return true if the receiver represents an object that is the same as the system."	| comp |	( comp := self component ) == nil		ifTrue: [ ^false ].	^databaseId = comp databaseId and: [ primaryKey = comp dbTrace ]</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aChange	^( super = aChange ) and:		[ ( databaseId = aChange databaseId ) &amp; ( primaryKey = aChange primaryKey ) ].</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>accessing</category><body package="Store-Change Management" selector="actionString">actionString	"Answer a string for messages describing the receiver."	^(#LoadedFrom &lt;&lt; #store &gt;&gt; ' loaded from ') asString</body><body package="Store-Change Management" selector="component:">component: aCodeComponent	"Extract relevant information from aCodeComponent."	super component: aCodeComponent.	databaseId := aCodeComponent dbIdentifier.	primaryKey := aCodeComponent primaryKey.</body><body package="Store-Change Management" selector="databaseId">databaseId	^databaseId</body><body package="Store-Change Management" selector="databaseId:">databaseId: aString	databaseId := aString</body><body package="Store-Change Management" selector="parameters">parameters	"Return the parameters used for the 'same as' test"	^super parameters asOrderedCollection		add: databaseId;		add: primaryKey;		asArray.</body><body package="Store-Change Management" selector="primaryKey">primaryKey	^primaryKey</body><body package="Store-Change Management" selector="primaryKey:">primaryKey: anInteger	primaryKey := anInteger</body><body package="Store-Change Management" selector="systemVersion:">systemVersion: aCodeComponent	"Answer an appropiate version string for aCodeComponent."	^aCodeComponent databaseId 		ifNil: [ (#NotInConnectedDatabase &lt;&lt; #store &gt;&gt; 'Not in Connected Database') asString ]		ifNotNil: [ :id | id , ': ' , aCodeComponent primaryKey printString ]</body><body package="Store-Change Management" selector="type">type 	"Answer the sub-type of this kind of change."	^#componentLoaded</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>printing</category><body package="Store-Change Management" selector="version">version	^databaseId, ': ', primaryKey printString</body></methods><methods><class-id>Store.PundleSavedChange</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileIn">fileIn	"File-in the receiver - ie. make the change to the system."	"Note- The saving of a Pundle action is same as loading. "	super fileIn</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aSourceFile	aSourceFile		savePundleNamed: componentName		type: componentType		primaryKey: databaseId		databaseId: primaryKey</body></methods><methods><class-id>Store.PundleSavedChange</class-id> <category>accessing</category><body package="Store-Change Management" selector="actionString">actionString	"Answer a string for messages describing the receiver."	^(#SavedTo &lt;&lt; #store &gt;&gt; ' saved to ') asString</body><body package="Store-Change Management" selector="type">type 	"Answer the sub-type of this kind of change."	^#componentSaved</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id> <category>updating</category><body package="StoreForGlorpBrowserUI" selector="definitionOfBinding:">definitionOfBinding: binding 	| namespace definitionString |	binding isForGeneral ifFalse: 		[^(definitionString := binding definitionString) isEmpty 			ifTrue: [(#NotDefinedInThisPackage &lt;&lt; #store &gt;&gt; 'Not defined in this package') asText]			ifFalse: [definitionString asText]].	namespace := Root whoDefinesBinding: binding.	namespace isNil ifTrue: [^''].	^namespace definitionOfStatic: binding</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI" selector="menuAugmentationRoot">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="canDefineClassesAndNameSpaces">canDefineClassesAndNameSpaces	^false</body></methods><methods><class-id>Store.Glorp.StoreBrowserCommentTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI" selector="menuAugmentationRoot">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.Merging</class-id> <category>accessing</category><body package="Store-Merge Management" selector="actionText">actionText	^(#Merging &lt;&lt; #store &gt;&gt; 'Merging') asString</body><body package="Store-Merge Management" selector="componentName">componentName	^self codeComponent 		ifNotNil: [:value | value isString ifTrue: [value] ifFalse: [value shortItemString]]		ifNil: [self actionText]</body></methods><methods><class-id>ShadowCompiler</class-id> <category>compilation</category><body package="Atomic Compiling and Loading" selector="evaluate:with:">evaluate: aString with: aCompiler	"Compile and execute a definition string into Shadow space. Answer the result.	Answer nil if fails."		^[[[self invokeMethod: (self compileDefinitionString: aString with: aCompiler)]		on: SharedNeedsShadowRoot		do: [:notification | notification resume: self]]			on: ClassConstructionError			do: [:exception | exception resume]]				on: Error				do: [:exception | ^nil]</body><body package="Atomic Compiling and Loading" selector="evaluate:with:using:">evaluate: aString with: aCompiler using: aCompilationManager	"Compile and execute a definition string into Shadow space. Answer the result.	Answer nil if fails."		^[[[self invokeMethod: (self compileDefinitionString: aString with: aCompiler)]		on: SharedNeedsShadowRoot		do: [:notification | notification resume: aCompilationManager]]			on: ClassConstructionError			do: [:exception | exception resume]]				on: Error				do: [:exception | ^nil]</body></methods><methods><class-id>ShadowCompiler</class-id> <category>utility</category><body package="Atomic Compiling and Loading" selector="findInShadow:">findInShadow: aReference	"Locate aReference off of shadow root. Answer nil if not found."	"Cavaet: works for namespaces and classes, but not shareds whose value can be nil."	| path current |	path := aReference path.	path first == #Root		ifTrue: [ current := shadowRoot ]		ifFalse: [ path first == #Smalltalk					ifTrue: [ current := shadowRoot at: #Smalltalk ]					ifFalse: 						[ current := ( shadowRoot at: #Smalltalk ) localBindingFor: path first.						current == nil ifTrue: [ ^nil ].						current := current value.						]				].	2 to: path size do:		[ :i | 		( current := current localBindingFor: ( path at: i ) ) == nil			ifTrue: [ ^nil ].		current := current value.		].	^current</body></methods><methods><class-id>ShadowCompiler</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="shadowAt:">shadowAt: aPath	^(self shadowRoot		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body><body package="Atomic Compiling and Loading" selector="shadowRoot">shadowRoot	^shadowRoot</body><body package="Atomic Compiling and Loading" selector="shadowRoot:">shadowRoot: anObject	shadowRoot := anObject</body></methods><methods><class-id>ShadowCompiler</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="addShadowNamespaceToEnvironment:">addShadowNamespaceToEnvironment: aShadowEnvironment	| namespace builder newNamespace binding |	(namespace := self findInShadow: aShadowEnvironment environment unambiguousName asStrictReference)		ifNil: [self addShadowNamespaceToEnvironment: aShadowEnvironment environment].	builder := ShadowNameSpaceBuilder new.	newNamespace := builder createShadowOf: aShadowEnvironment.	newNamespace environment: namespace. 	binding := (namespace createKey: aShadowEnvironment name value: newNamespace).	(namespace includesKey: binding key)		ifFalse: [	namespace addBinding: binding].</body><body package="Atomic Compiling and Loading" selector="addShadowedClassToEnvironment:">addShadowedClassToEnvironment: aShadowedClass	| namespace binding |	(self findInShadow: aShadowedClass environment unambiguousName asStrictReference) ifNil:		[self addShadowNamespaceToEnvironment: aShadowedClass environment].	namespace := self findInShadow: aShadowedClass environment unambiguousName asStrictReference. 	binding := (namespace createKey: aShadowedClass name value: aShadowedClass).	binding environment: namespace.	(namespace includesKey: binding key)		ifFalse: [	namespace addBinding: binding].</body><body package="Atomic Compiling and Loading" selector="compileDefinitionString:with:">compileDefinitionString: aString with: aCompiler 	"Compiles a definition string (NameSpace, Class or Shared) in the context of the shadowed space.	Answers the method"	| method |	method := aCompiler 				compile: aString				in: nil				allowReceiver: true				class: nil class				environment: self shadowRoot				noPattern: true				notifying: SilentCompilerErrorHandler new				ifFail: [nil].	method == nil ifTrue: [self error: #badDefinition &lt;&lt; #store &gt;&gt; 'bad definition'].	^method</body><body package="Atomic Compiling and Loading" selector="createShadowClassFor:">createShadowClassFor: existingClass	"Create a shadow class for existingClass and return what was created.  One would	 use this for creating a shadowed class to put extension methods/shareds on."		| string shadowedClass insertPoint |	existingClass isInStandardEnvironment ifFalse: 		[^existingClass].	(shadowedClass := self findInShadow: existingClass unambiguousName asStrictReference) ifNotNil: 		[^shadowedClass].	string := existingClass definition.	shadowedClass := (self class root: self shadowRoot)		evaluate: string		with: Compiler new.	shadowedClass ifNil:		[insertPoint := string indexOfSubCollection: 'defineClass:' startingAt: 1.		string := string copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.		shadowedClass := (self class root: self shadowRoot)			evaluate: string			with: Compiler new].	shadowedClass reallyFullyQualifiedReference bindingOrNil ifNotNil: [:value | value setReservedFlag: true].	^shadowedClass</body><body package="Atomic Compiling and Loading" selector="createShadowClassOrNameSpaceFor:">createShadowClassOrNameSpaceFor: existingClass	"Create a shadow class for existingClass and return what was created.  One would	 use this for creating a shadowed class to put extension methods/shareds on."		| string shadowedClass insertPoint |	existingClass isInStandardEnvironment ifFalse: 		[^existingClass].	(shadowedClass := self findInShadow: existingClass unambiguousName asStrictReference) ifNotNil: 		[^shadowedClass].	string := existingClass definition.	insertPoint := string indexOfSubCollection: 'defineClass:' startingAt: 1.	insertPoint isZero		ifTrue: [insertPoint := string indexOfSubCollection: 'defineNameSpace:' startingAt: 1].	string := string copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.	shadowedClass := ((self class root: self shadowRoot)		evaluate: string		with: Compiler new) environment.	shadowedClass ifNil: 		[string := existingClass definition.		shadowedClass := (self class root: self shadowRoot)			evaluate: string			with: Compiler new].	shadowedClass reallyFullyQualifiedReference bindingOrNil ifNotNil: [:value | value setReservedFlag: true].	^shadowedClass</body><body package="Atomic Compiling and Loading" selector="invokeMethod:">invokeMethod: aMethod	"Executes aMethod in the context of shadowed space, allowing it to resolve variables in Shadow-land	and only if not found, in the system."		^Processor activeProcess scopeEnvironmentWhile:		[:newProcessEnvironment | 		| handler |		handler := ShadowNameSpaceHandler new.		handler shadowRoot: self shadowRoot.		newProcessEnvironment bindingHandler: handler.		nil performMethod: aMethod]</body></methods><methods><class-id>ShadowCompiler class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="root:">root: aRootNameSpace	"Answer an instance that uses aRootNameSpace as it's compilation environment."		^(self new)		shadowRoot: aRootNameSpace;		yourself</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>reconciling</category><body package="Store-Database Model" selector="unreconcile">unreconcile	"Do nothing, we have no direct reference to previous versions"</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>private-two byte strings</category><body package="Store-Database Model" selector="byteOrder">byteOrder	| test null chara |	test := 'abc' asTwoByteString.	null := 0.	chara := $a asInteger.	(((test basicAt: 1) = chara) and: [(test basicAt: 2) = null]) ifTrue: [^#(0 1)].	(((test basicAt: 2) = chara) and: [(test basicAt: 1) = null]) ifTrue: [^#(1 0)].	self error: 'Can not determine byte order for TwoByteString'</body><body package="Store-Database Model" selector="decodeTwoByteDefinitionStream:">decodeTwoByteDefinitionStream: strm	| string2Byte order inx |	string2Byte := TwoByteString new: strm size.	order := self byteOrder.	inx := 1.	[strm atEnd]		whileFalse: 			[string2Byte basicAt: inx + order first put: (self readDecodedByteFrom: strm).			string2Byte basicAt: inx + order last put: (self readDecodedByteFrom: strm).			inx := inx + 2].	^string2Byte copyFrom: 1 to: ((inx - 1)//2)</body><body package="Store-Database Model" selector="encodeTwoByteDefinition:">encodeTwoByteDefinition: aString	| strm order |	strm := WriteStream on: (String new: (aString size * 4)).	order := self byteOrder.	1 to: aString basicSize by: 2 do: [:inx|		self writeByte: (aString basicAt: inx + order first) encodedOn: strm.		self writeByte: (aString basicAt: inx + order last) encodedOn: strm].	^strm contents asByteArray</body><body package="Store-Database Model" selector="readDecodedByteFrom:">readDecodedByteFrom: aStream 	| code |	code := aStream next asInteger.	^(code &gt;= 16 and: [code &lt;= 127])		ifTrue: [code]		ifFalse: [code = 1				ifTrue: [0]				ifFalse: [(code &gt;= 2 and: [code &lt;= 5])						ifTrue: [aStream next asInteger - 32 + ((code - 2) * 64)]						ifFalse: 							[self error: 'Invalid encoding of TwoByteString'.							0]]]</body><body package="Store-Database Model" selector="writeByte:encodedOn:">writeByte: aByte encodedOn: aStream 	(aByte &gt;= 16 and: [aByte &lt;= 127])		ifTrue: [aStream nextPut: (Character value: aByte)]		ifFalse: [aByte = 0				ifTrue: [aStream nextPut: (Character value: 1)]				ifFalse: 					[aStream nextPut: (Character value: 2 + (aByte // 64)).					aStream nextPut: (Character value: 32 + (aByte \\ 64))]]</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>accessing</category><body package="Store-Database Model" selector="asText">asText	^self source asText.</body><body package="Store-Database Model" selector="basicType">basicType	^type.</body><body package="Store-Database Model" selector="binaryData">binaryData	| stream |	next isNil ifTrue: [^data].	stream := WriteStream on: (ByteArray new: 64000).	self binaryDataInto: stream.	^stream contents</body><body package="Store-Database Model" selector="binaryData:">binaryData: aByteArray	self binaryData: aByteArray startingAt: 1.</body><body package="Store-Database Model" selector="binaryData:startingAt:">binaryData: aByteArray startingAt: anOffset	aByteArray size - anOffset + 1 &gt; self maximumDataSize		ifTrue:			[data := aByteArray copyFrom: anOffset to: anOffset - 1 + self maximumDataSize.			next := self class forByteArray: aByteArray startingAt: anOffset + self maximumDataSize.			self lastInChain type: type.			type := nil]		ifFalse: [data := aByteArray copyFrom: anOffset to: aByteArray size].</body><body package="Store-Database Model" selector="binaryDataInto:">binaryDataInto: aStream 	aStream nextPutAll: data.	next notNil ifTrue: [next binaryDataInto: aStream]</body><body package="Store-Database Model" selector="lastInChain">lastInChain	| current |	current := self.	[current next isNil] whileFalse: [current := current next].	^current.</body><body package="Store-Database Model" selector="next">next	^next</body><body package="Store-Database Model" selector="object">object	| stream boss bossClass |	result notNil ifTrue: [^result].	bossClass := Smalltalk at: #BinaryObjectStorage ifAbsent: [nil].	bossClass isNil 		ifTrue: 			["self error: 'Cannot load properties without BinaryObjectStorage class'" ^Dictionary new].	stream := ReadStream on: self binaryData.	boss := bossClass onOld: stream.	result := [boss next] on: Dialect error do: [:ex | nil].	^result</body><body package="Store-Database Model" selector="source">source	| myData |	result notNil ifTrue: [^result].	myData := self binaryData.	myData isNil ifTrue: [^''].	"The encoding used here is bizarre. Just reuse"	result := self isTwoByteString		ifTrue: [self decodeTwoByteDefinitionStream: (ReadStream on: myData)]		ifFalse: [myData asString].	Dialect isVisualAge ifTrue: [result := result copyReplaceAll: (String with: Character cr) with: (Dialect smalltalkAt: #CwText) lineDelimiter].	^result</body><body package="Store-Database Model" selector="type">type	^next isNil ifTrue: [type] ifFalse: [next type]</body><body package="Store-Database Model" selector="type:">type: anInteger	type := anInteger</body><body package="Store-Database Model" selector="unchainedBinaryData">unchainedBinaryData	^data.</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>testing</category><body package="Store-Database Model" selector="glorpPostFetch:">glorpPostFetch: aSession	primaryKey = 0 ifTrue: [self halt].	type = 0 ifTrue: [self halt].</body><body package="Store-Database Model" selector="glorpPostFetchValidate:">glorpPostFetchValidate: aSession	"Note that returning false means that this object will be ignored. Used because on at least one occasion I've seen a Store database with a blob record in it of primary key zero, which just messes things up horribly."	primaryKey = 0 ifTrue: [^false].	type = 0 ifTrue: [^false].</body><body package="Store-Database Model" selector="isTwoByteString">isTwoByteString	^self type = 3.</body><body package="Store-Database Model" selector="validTypeField">validTypeField	type isNil ifTrue: [^nil].	^type &gt; 0 ifTrue: [type] ifFalse: [nil].</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>constants</category><body package="Store-Database Model" selector="maximumDataSize">maximumDataSize	"We could probably go higher than this, but with PostGreSQL the limit of an encoded blob is 64K. Unfortunately, that's Base64Encoding, and keeping it 1/2 that make sure we don't EVER overrun the Base64Encoding"	^32000.</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>initializing</category><body package="Store-Database Model" selector="forByteArray:">forByteArray: aCollection	type := 4.	self binaryData: aCollection asByteArray.</body><body package="Store-Database Model" selector="forByteArray:startingAt:">forByteArray: aCollection startingAt: anOffset	type := 4.	self binaryData: aCollection asByteArray startingAt: anOffset.</body><body package="Store-Database Model" selector="forObject:">forObject: anObject	| bossClass stream boss |	type := 1.	bossClass := Smalltalk at: #BinaryObjectStorage ifAbsent: [nil].	bossClass isNil 		ifTrue: 			[self error: 'Cannot store properties without BinaryObjectStorage class'].	stream := WriteStream on: (ByteArray new: 500).	boss := bossClass onNew: stream.	boss nextPut: anObject.	self binaryData: stream contents.</body><body package="Store-Database Model" selector="forString:">forString: aCollection	| newData invalidCharacter |	type := 2.	"This criteria for two-byte strings is kind of fuzzy. We're out of range if the unicode code point is out of single byte range. But without knowing what encoding the database is using, it's hard to know"	invalidCharacter := aCollection detect: [:each | each asInteger &gt; 255] ifNone: [nil].	invalidCharacter isNil ifFalse: [^self forTwoByteString: aCollection].	newData := Dialect isVisualAge		ifTrue:			[aCollection				copyReplaceAll: (Dialect smalltalkAt: #CwText) lineDelimiter				with: (String with: Character cr)]		ifFalse: [aCollection].	self binaryData: newData asByteArray.</body><body package="Store-Database Model" selector="forTwoByteString:">forTwoByteString: aCollection	| newData |	type := 3.	Dialect isVisualAge		ifTrue:			[newData := aCollection				copyReplaceAll: (Dialect smalltalkAt: #CwText) lineDelimiter				with: (String with: Character cr)]		ifFalse: [			Dialect isVisualWorks ifTrue: [newData := aCollection asTwoByteString] ifFalse: [newData := aCollection]].	"The encoding scheme used here is quite weird, and I can't tell if it corresponds to any known encoding. Just reuse"	self binaryData: (self encodeTwoByteDefinition: newData) asByteArray.</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	next := next glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreBlob</class-id> <category>comparing</category><body package="Store-Database Model" selector="identityHash">identityHash	^super identityHash bitXor: data hash</body></methods><methods><class-id>Store.Glorp.StoreBlob class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="forByteArray:">forByteArray: aByteArray	^self basicNew initialize forByteArray: aByteArray.</body><body package="Store-Database Model" selector="forObject:">forObject: aString	^self basicNew initialize forObject: aString.</body><body package="Store-Database Model" selector="forString:">forString: aString	^self basicNew initialize forString: aString.</body><body package="Store-Database Model" selector="forTwoByteString:">forTwoByteString: aString	^self basicNew initialize forTwoByteString: aString.</body><body package="Store-Database Model" selector="new">new	self error: 'Don''t use new, specify a type of blob'.</body></methods><methods><class-id>Store.Glorp.StoreBlob class</class-id> <category>private</category><body package="Store-Database Model" selector="forByteArray:startingAt:">forByteArray: aByteArray startingAt: anOffset	^self basicNew initialize forByteArray: aByteArray startingAt: anOffset.</body></methods><methods><class-id>Store.Glorp.StoreBlob class</class-id> <category>installation</category><body package="Store-Database Model" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy blobTableSpace</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="selectionModule">selectionModule	^selectionModule</body><body package="Store-UI-Browser" selector="versions:">versions: definitionRecords	self selectionModule list: definitionRecords</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>interface opening</category><body package="Store-UI-Browser" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #selectionModule)		client: selectionModule		spec: selectionModule preferredWindowSpec		builder: aBuilder newSubBuilder.	selectionModule selectionHolder 		onChangeSend: #selectionChanged to: self</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>initialize-release</category><body package="Store-UI-Browser" selector="initialize">initialize	super initialize.	selectionModule := ListSelectionModule new.	selectionModule displayStringSelector: #versionString</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>private</category><body package="Store-UI-Browser" selector="selectionModuleSelection">selectionModuleSelection	^selectionModule selection 			ifNil: [String new]			ifNotNil: [:selection | selection definition asText]</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>aspects</category><body package="Store-UI-Browser" selector="text">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body></methods><methods><class-id>Store.RecordVersionsViewer</class-id> <category>notifications</category><body package="Store-UI-Browser" selector="selectionChanged">selectionChanged	self text value: self selectionModuleSelection</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Browser" selector="windowSpec">windowSpec	^self perform: self specPreference</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>class initialization</category><body package="Store-UI-Browser" selector="initialize">initialize	specPreference := #horizontalWindowSpec</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="specPreference">specPreference		^specPreference</body><body package="Store-UI-Browser" selector="specPreference:">specPreference: aSymbol		specPreference := aSymbol</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>instance creation</category><body package="Store-UI-Browser" selector="openOnVersionsOf:">openOnVersionsOf: aRecord	|app|	app := self new.	app versions: aRecord versions.	app open</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="downloadDirectory">downloadDirectory	^downloadDirectory</body><body package="Store-User Management" selector="downloadDirectory:">downloadDirectory: aFilename	downloadDirectory := aFilename asLogicalFileSpecification</body><body package="Store-User Management" selector="downloadPreference">downloadPreference	^downloadPreference</body><body package="Store-User Management" selector="downloadPreference:">downloadPreference: symbol	downloadPreference := symbol</body><body package="Store-User Management" selector="useDownloadDirectory">useDownloadDirectory	^useDownloadDirectory</body><body package="Store-User Management" selector="useDownloadDirectory:">useDownloadDirectory: aBoolean	useDownloadDirectory := aBoolean</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>private</category><body package="Store-User Management" selector="downloadFile:">downloadFile: aStoreFile 	| logicalFilename |	logicalFilename := aStoreFile filename.	self useDownloadDirectoryIfNotNil: 		[:directory | 		(logicalFilename hasSystemVariable or: [logicalFilename isAbsolute]) ifTrue: 			[logicalFilename := LogicalFilename fromComponents: (logicalFilename componentStrings allButFirst: 1)].		logicalFilename := directory construct: logicalFilename asString].	self ensureDirectoryExistsFor: logicalFilename.	aStoreFile downloadTo: logicalFilename</body><body package="Store-User Management" selector="ensureDirectoryExistsFor:">ensureDirectoryExistsFor: aFilename	| path current|	path := (aFilename asLogicalFileSpecification componentStrings) asOrderedCollection.	path removeLast.	path isEmpty ifTrue: [^self].	current := path removeFirst asFilename asLogicalFileSpecification.	[current definitelyExists ifFalse: [current asFilename makeDirectory].	path isEmpty] whileFalse: [current := current construct: path removeFirst]</body><body package="Store-User Management" selector="useDownloadDirectoryIfNotNil:">useDownloadDirectoryIfNotNil: aBlock	self useDownloadDirectory ifFalse: [^self].	self downloadDirectory ifNotNil: [:directory | aBlock value: directory]</body><body package="Store-User Management" selector="userSelectedFiles:">userSelectedFiles: fileRecords 	^SimpleDialog new 		chooseMultiple: #downloadFilesDotDotDot &lt;&lt; #store &gt;&gt; 'Download files...'		fromList: (fileRecords collect: [:n | n filename asString])		values: fileRecords		initialSelections: #()		buttons: #()		values: #()		lines: (12 min: fileRecords size) + 1		cancel: [List new]		for: Dialog defaultParentWindow</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>testing</category><body package="Store-User Management" selector="alwaysDownload">alwaysDownload	^downloadPreference = #always</body><body package="Store-User Management" selector="neverDownload">neverDownload	^downloadPreference = #never</body><body package="Store-User Management" selector="promptForDownload">promptForDownload	^downloadPreference = #prompt</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>initialize-release</category><body package="Store-User Management" selector="initialize">initialize	downloadPreference := #prompt.	downloadDirectory := Filename currentDirectory asLogicalFileSpecification.	useDownloadDirectory := false</body></methods><methods><class-id>Store.BasicFilePolicy</class-id> <category>actions</category><body package="Store-User Management" selector="downloadFiles:">downloadFiles: aCollection 	| filesToDownload |	self neverDownload ifTrue: [^self].	filesToDownload := self promptForDownload 		ifTrue: [self userSelectedFiles: aCollection]		ifFalse: [aCollection].	filesToDownload do: [:each | self downloadFile: each]</body><body package="Store-User Management" selector="downloadFiles:using:">downloadFiles: fileRecords using: aBundleCompilationResult	| filesToDownload |	self neverDownload ifTrue: [^self].	filesToDownload := self promptForDownload		ifTrue: [self userSelectedFiles: fileRecords]		ifFalse: [fileRecords].	(DownloadingFiles for: aBundleCompilationResult pundle) started.	filesToDownload do: 		[:each |		self downloadFile: each].	(DownloadingFiles for: aBundleCompilationResult pundle) finished</body></methods><methods><class-id>Store.BasicFilePolicy class</class-id> <category>class initialization</category><body package="Store-User Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.NoOpResolution</class-id> <category>testing</category><body package="Store-Merge Management" selector="isDoNothingResolution">isDoNothingResolution	^true</body><body package="Store-Merge Management" selector="isNoOpResolution">isNoOpResolution	^true</body><body package="Store-Merge Management" selector="proposed">proposed	^true</body><body package="Store-Merge Management" selector="value">value	^(#StarsDoNotApplyChangeStars &lt;&lt; #store &gt;&gt; '*** Do Not Apply Change ***') asString</body></methods><methods><class-id>Store.Glorp.NoOpResolution</class-id> <category>accessing</category><body package="Store-Merge Management" selector="key">key 	^nil</body></methods><methods><class-id>Store.Glorp.NoOpResolution</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	applied := false</body></methods><methods><class-id>Store.LoadingError</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="package">package	^package</body><body package="Atomic Compiling and Loading" selector="package:">package: anObject	package := anObject</body></methods><methods><class-id>Store.AtomicLoadingError</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="abortLoad">abortLoad	"This is a helper method for users of this Error"	self return</body><body package="Atomic Compiling and Loading" selector="defaultAction">defaultAction	"What to do when the exception is unhandled."		Dialog warn: self defaultMessageText.	^false</body></methods><methods><class-id>Store.AtomicLoadingError</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="defaultMessageText">defaultMessageText		^#_1sIsUnableToBeLoadedN2s3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is unable to be loaded' expandMacrosWith: package name</body></methods><methods><class-id>Store.AtomicLoadingError class</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.AtomicLoadingError class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="pundle:">pundle: aPundle	^self new		package: aPundle;		raise</body><body package="Atomic Compiling and Loading" selector="pundle:failed:">pundle: aPundle failed: aShadowPackageCompileManager	^self new		package: aPundle;		parameter: aShadowPackageCompileManager;		raise</body></methods><methods><class-id>Store.MethodTag</class-id> <category>testing</category><body package="Store-Change Management" selector="belongsToClass">belongsToClass	^true</body><body package="Store-Change Management" selector="existsInImage">existsInImage	^self compiledMethod notNil</body><body package="Store-Change Management" selector="isForMethod">isForMethod	^true</body><body package="Store-Change Management" selector="isInClass">isInClass	^true</body><body package="Store-Change Management" selector="isMethodTag">isMethodTag	^true</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^true</body></methods><methods><class-id>Store.MethodTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new method from a definition contained in 	aPackage."	^aRecord loadAsNew</body></methods><methods><class-id>Store.MethodTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="actual">actual	^self compiledMethod</body><body package="Store-Change Management" selector="compiledMethod">compiledMethod	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl compiledMethodAt: selector ifAbsent: [nil]]</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contains the 	defintion described by me."	"(MethodTag newClass: MethodTag selector: #containingPackage) 	containingPackage" 	^Registry		quickContainingPackageForSelector: self selector		classSymbol: self classSymbol		meta: self isMeta</body><body package="Store-Change Management" selector="description">description	^'#', selector, 		(isMeta			ifTrue: [' (class method)']			ifFalse: [''])</body><body package="Store-Change Management" selector="name">name	^self className, '&gt;&gt;', selector asString</body><body package="Store-Change Management" selector="protocol">protocol	protocol == nil		ifTrue: [ protocol := self actualClass organization categoryOfElement: self selector ].	^protocol.</body><body package="Store-Change Management" selector="protocol:">protocol: aSymbol	protocol := aSymbol</body><body package="Store-Change Management" selector="selector">selector	^selector</body><body package="Store-Change Management" selector="selector:">selector: aSymbol	selector := aSymbol</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| cm |	cm := self compiledMethod.	^cm isNil		ifTrue: [nil]		ifFalse: [cm getSource]</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^selector</body></methods><methods><class-id>Store.MethodTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| actualClass newSelector |	actualClass := self actualClass.	actualClass isNil 		ifTrue: 			[Dialog warn: ((#TheClass1sMustAndApplyResolved &lt;&lt; #store &gt;&gt; 'The class "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept edited code.&lt;n&gt;Resolve conflicts in the class definition, if any,&lt;n&gt;and "Apply Resolved".') expandMacrosWith: self classSymbol asString).			^false].	newSelector := actualClass parserClass new parseSelector: someText.	newSelector isNil 		ifTrue: 			[Dialog warn: #ParseFailure &lt;&lt; #store &gt;&gt; 'Parse failure'.			^false].	newSelector ~~ self selector ifTrue: 		[Dialog warn: #selectorMustNotChange &lt;&lt; #store &gt;&gt; 'selector must not change'.		^false].	self protocol size = 0 ifTrue: 		[protocol := Dialog request: #UseWhatProtocol &lt;&lt; #store &gt;&gt; 'Use what protocol?'].	protocol size = 0 ifTrue: [protocol := ClassOrganizer defaultProtocol].	Cursor execute showWhile: 			[newSelector := actualClass 						compile: someText						classified: protocol						notifying: aController].	^newSelector ~~ nil</body><body package="Store-Change Management" selector="moveFromPackage:toPackage:ifNotLoaded:">moveFromPackage: oldPackage toPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	(actual notNil and: [actual includesSelector: self selector])		ifTrue: [XChangeSet current				moveSelector: self selector				class: actual				fromPackage: oldPackage				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	(actual notNil and: [actual includesSelector: self selector])		ifTrue: [XChangeSet current				moveSelector: self selector				class: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	| cls |	cls := self actualClass.	cls isNil 		ifTrue: 			[tolerantBoolean ifFalse: 				[self error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') expandMacrosWith: self className)]]		ifFalse: 			[(aPackage hasSelector: self selector in: cls) 				ifTrue: 					[((Override 						unloadSelector: self selector						class: cls						from: aPackage						logged: true) not 						and: [tolerantBoolean not]) 							ifTrue: 								[(cls includesSelector: self selector) 									ifFalse: 										[self error: ((#Quotes1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; '"&lt;1s&gt;" does not exist in the image.') expandMacrosWith: self name)]]]]</body></methods><methods><class-id>Store.MethodTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	MethodCollector new 		openListBrowserOn: (Array with: (MethodDefinition class: self actualClass selector: selector))		label: (#CurrentDefinition &lt;&lt; #store &gt;&gt; 'Current Definition') asString</body><body package="Store-Change Management" selector="category">category	^protocol == nil		ifTrue: [ self systemCategory ]		ifFalse: [ protocol ].</body><body package="Store-Change Management" selector="classProxy">classProxy 	^( Kernel.ChangeSupportClassProxy pathString: self fullClassName asClassNameOnly ) 			meta: self isMeta</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| cls |	( cls := self actualClass ) == nil		ifTrue: [ ^nil ].	aStream		saveSource: self sourceTextForImage		class: cls		protocol: self category		attributes: nil.	"to add the &lt;/methods&gt; tag, according to steve"	aStream checkMethodChunkClass: nil protocol: nil.</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	aStream removeSelector: selector from: self classProxy</body><body package="Store-Change Management" selector="systemCategory">systemCategory	"Return the category of the corresponding method the system, if any"	| class |	^( class := self actualClass ) == nil		ifFalse: [ class whichCategoryIncludesSelector: self selector ]</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'method definition'</body></methods><methods><class-id>Store.MethodTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForMethodTag: self.</body></methods><methods><class-id>Store.MethodTag</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aTag	^super = aTag and:		[selector == aTag selector and: [protocol = aTag protocol]]</body></methods><methods><class-id>Store.MethodTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClass:selector:">newClass: aClass selector: aSelector		^self new class: aClass; selector: aSelector</body><body package="Store-Change Management" selector="newClassName:meta:selector:protocol:">newClassName: aString meta: aBoolean selector: aSelector protocol: protocol	^self new 		className: aString;		isMeta: aBoolean;  		selector: aSelector;		protocol: protocol</body><body package="Store-Change Management" selector="newClassName:selector:meta:">newClassName: aString selector: aSelector meta: isMeta		^self new className: aString; meta: isMeta; selector: aSelector</body><body package="Store-Change Management" selector="newClassSymbol:isMeta:selector:">newClassSymbol: aSymbol isMeta: aBoolean selector: aSelector		^self new classSymbol: aSymbol; isMeta: aBoolean;  selector: aSelector</body></methods><methods><class-id>Store.MethodTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^3		"also reserves 7 for the meta-class methods"</body></methods><methods><class-id>Store.Data</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="dataRef">dataRef	"Answer the receiver's dataRef."	^dataRef</body><body package="Store-DB-Subdefs" selector="dataRef:">dataRef: newDataRef	"Set the receiver's dataRef to newDataRef."	dataRef := newDataRef</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Subdefs" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Subdefs" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self methodRef</body><body package="Store-DB-Subdefs" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self dataRef</body></methods><methods><class-id>Store.Data</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: packageRef printString, ': ', dataRef printString;		nextPut: $).</body></methods><methods><class-id>Store.Data class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="copyDataFromTrace:to:">copyDataFromTrace: oldPkgID to: newPkgID 	"Copy all data present in oldPkgID 	into newPkgID."	self broker process: 		( self newSQL				insert: #( packageRef dataRef );				select: 	(Array with: newPkgID printString with: #dataRef);				where;				column: #packageRef equalTo: oldPkgID printString).</body><body package="Store-DB-Subdefs" selector="removeDatum:inPackage:">removeDatum: dID inPackage: pkgID 	"Remove the row: pkgID, dID"	self broker process: (self newSQL						delete;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #dataRef equalTo: dID printString).</body><body package="Store-DB-Subdefs" selector="replaceDatum:with:inPackage:">replaceDatum: oldID with: newID inPackage: pkgID 	"Replace the row: pkgID, oldID with a row: pkgID, newID"	self broker process: (self newSQL						update;						column: #dataRef equalTo: newID printString;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #dataRef equalTo: oldID printString)</body></methods><methods><class-id>Store.Data class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'packageRef' put: #PrimaryKey.	aDict at: 'dataRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"We need update and delete on Data to speed up publishing."	super setDatabasePrivilegesForTable.	self broker grantForClass: self permissions: #('UPDATE' 'DELETE') toUsers: #('PUBLIC')</body></methods><methods><class-id>Store.Data class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on dataRef to speed up	garbage collection process."	^self broker createIndexForClass: self</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on dataRef to speed up	garbage collection process."	^self broker dropIndexForClass: self.</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames 	^ Array with: 'dataRef'</body><body package="Store-DB-Subdefs" selector="indexName">indexName		^ '_DATUM_IDX'</body><body package="Store-DB-Subdefs" selector="packagesContainingDatum:">packagesContainingDatum: datumID 	"Check what packages define datumID.	Return a collection of package IDs "	"self packagesContainingDatum: 15"	^[(self broker process: 			( self newSQL				select: #( packageRef );				where;				column: #dataRef equalTo: datumID printString)	 ) collect: [:each| each first]	]	on: self  errorSignals 	do: 	[:ex | ex outer.  OrderedCollection new ].</body></methods><methods><class-id>Store.Data class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn		^#dataRef</body></methods><methods><class-id>Store.Glorp.StoreDatabaseIdentifier</class-id> <category>accessing</category><body package="Store-Database Model" selector="name">name	^name</body><body package="Store-Database Model" selector="name:">name: aString	name := aString</body></methods><methods><class-id>Store.Preloading</class-id> <category>accessing</category><body package="Store-Base" selector="actionText">actionText	^(#Preloading &lt;&lt; #store &gt;&gt; 'Preloading') asString</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing numbers</category><body package="Store-User Management" selector="blessingName:">blessingName: aNumber 	"Given a number from DB answer the official name of the blessing level."	aNumber = 0 ifTrue: [ ^'Unblessed' ].	^( self blessings detect:		[ :bless | bless level == aNumber ] ifNone: [ ^'Unknown' ]	) name.</body><body package="Store-User Management" selector="blessingNumber:">blessingNumber: aName	"Given the name for the blessing level answer a number used in DB."	aName = 'Unblessed' ifTrue: [ ^0 ].	^( self blessings detect:		[ :bless | bless name = aName ] ifNone: [ ^nil ] 	  ) level.</body><body package="Store-User Management" selector="defaultBlessing">defaultBlessing		^defaultBlessing</body><body package="Store-User Management" selector="defaultBlessing:">defaultBlessing: aNumber		defaultBlessing := aNumber</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-User Management" selector="initialize">initialize	self initializeBlessings.	self defaultBlessing: self developmentBlessing.</body><body package="Store-User Management" selector="initializeBlessings">initializeBlessings	"Policies blessingPolicy initializeBlessings"	blessings := IdentityDictionary new		at: #MarkedForDeletion put: (BlessingLevel name: 'Marked For Deletion' level: -54);		at: #Obsolete put: (BlessingLevel name: 'Obsolete' level: -10);		at: #ReplicationNotice put: (BlessingLevel name: 'Replication Notice' level: -1);		at: #Broken put: ( BlessingLevel name: 'Broken' level: 10 );		at: #WorkInProgress put: ( BlessingLevel name: 'Work In Progress' level: 15 );	 	at: #Development put: ( BlessingLevel name:  'Development' level: 20 );		at: #ToReview put: (  BlessingLevel name: 'To Review' level: 25 );		at: #Patch put: ( BlessingLevel name:  'Patch' level: 30 );	 	at: #IntegrationReady put: ( BlessingLevel name:  'Integration-Ready' level: 40 );		at: #Integrated put: ( BlessingLevel name:  'Integrated' level: 50 );		at: #ReadyToMerge put: ( BlessingLevel name: 'Ready to Merge' level: 55 );		at: #Merged put: ( BlessingLevel name:  'Merged'  level: 60 );		at: #Tested put: ( BlessingLevel name:  'Tested' level: 70 );		at: #InternalRelease put: ( BlessingLevel name:  'Internal Release' level:  80 );		at: #Release put: ( BlessingLevel name:  'Released' level:  99 );		yourself.</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>display</category><body package="Store-User Management" selector="blessingLevelsNotToBeDisplayed">blessingLevelsNotToBeDisplayed	"Return a list of blessing levels that will not be displayed in a printed blessing history."	^#(-1).</body><body package="Store-User Management" selector="describeBlessings:">describeBlessings: aCollection	"Answer a string that describes a collection of database blessings."	| output blessingsToPrint |	output := WriteStream on: String new. 	blessingsToPrint := aCollection reject: [:each | self blessingLevelsNotToBeDisplayed includes: each blessingLevel].	blessingsToPrint do: 		[ :each | 		output 			nextPutAll: '--- Blessed: ';			nextPutAll: each blessingLevelString;			cr;			nextPutAll: '--- By: ';	 		nextPutAll: each userNameString;			cr;			nextPutAll: '--- On: ';			nextPutAll: each timeStampString;			cr;			nextPutAll: each getCommentString;			cr; 			cr.		].	^output contents</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>relationships</category><body package="Store-User Management" selector="stringKeyFor:blessingLevel:">stringKeyFor: aString blessingLevel: blessingLevel	blessingLevel = self developmentBlessing 		ifTrue: [^(aString , ' D') asText emphasizeAllWith: #italic].	blessingLevel = self integrationReadyBlessing 		ifTrue: [^( aString , ' Y' ) asText emphasizeAllWith: #bold ].	^aString , ' ' , ( String with: ( self blessingName: blessingLevel ) first )</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="blessingAt:put:">blessingAt: aSymbol put: aBlessingLevel	blessings at: aSymbol put: aBlessingLevel.</body><body package="Store-User Management" selector="blessingNumbers">blessingNumbers	"Answer an array of existing blessing numbers."	^blessings values collect:		[ :bl | bl level ]</body><body package="Store-User Management" selector="blessings">blessings	"Answer an array of existing BlessingLevels."	^blessings values</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>publishing</category><body package="Store-User Management" selector="basicCanPublish:atBlessing:">basicCanPublish: aPundle atBlessing: aBlessing	^true</body><body package="Store-User Management" selector="objectionsToPublishingBundle:atBlessingLevel:">objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body><body package="Store-User Management" selector="objectionsToPublishingPackage:atBlessingLevel:">objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel 	"Return a string specifying why this package may not be published.  Return nil if it may.	An example policy is shown below:"	^nil"	aPackage changeSet listOfClasses 			detect: [:className | 				(className copyFrom: 1 to: 3) ~= 'TT_']			ifNone: [^nil].	^aLevel = (Policies blessingPolicy blessingNumber: 'Development')		ifTrue: [nil]		ifFalse: ['Changes to external classes may not\be published with this blessing.']"</body><body package="Store-User Management" selector="objectionsToPublishingParcel:atBlessingLevel:">objectionsToPublishingParcel: aParcel atBlessingLevel: aLevel 	"Return a string specifying why this parcel may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body><body package="Store-User Management" selector="objectionsToPublishingPundle:atBlessingLevel:">objectionsToPublishingPundle: aPundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing menus</category><body package="Store-User Management" selector="blessingLevelsMenu">blessingLevelsMenu	"Answer a menu with all existing blessing names and levels."	| menu labels values list |	list := self blessings asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body><body package="Store-User Management" selector="blessingLevelsMenuForPundle:">blessingLevelsMenuForPundle: aPundle	^self blessingLevelsMenu</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing names</category><body package="Store-User Management" selector="brokenBlessing">brokenBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Broken ) level</body><body package="Store-User Management" selector="developmentBlessing">developmentBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Development ) level.</body><body package="Store-User Management" selector="integratedBlessing">integratedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Integrated ) level</body><body package="Store-User Management" selector="integrationReadyBlessing">integrationReadyBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"		^(blessings at: #IntegrationReady) level</body><body package="Store-User Management" selector="internalReleaseBlessing">internalReleaseBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"		^(blessings at: #InternalRelease) level</body><body package="Store-User Management" selector="mergedBlessing">mergedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Merged ) level.</body><body package="Store-User Management" selector="patchBlessing">patchBlessing 	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Patch ) level</body><body package="Store-User Management" selector="readyToMergeBlessing">readyToMergeBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #ReadyToMerge ) level</body><body package="Store-User Management" selector="releasedBlessing">releasedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Release ) level</body><body package="Store-User Management" selector="testedBlessing">testedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Tested ) level</body><body package="Store-User Management" selector="toReviewBlessing">toReviewBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #ToReview ) level</body><body package="Store-User Management" selector="workInProgressBlessing">workInProgressBlessing 	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #WorkInProgress ) level</body></methods><methods><class-id>Store.BasicBlessingPolicy class</class-id> <category>instance creation</category><body package="Store-User Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="defaultIncludeBranchBlessingCommentHistoryPolicy">defaultIncludeBranchBlessingCommentHistoryPolicy	^true</body><body package="Store-User Management" selector="defaultIntegratedBlessingChangePolicy">defaultIntegratedBlessingChangePolicy	^#change</body><body package="Store-User Management" selector="defaultMergeToolMaxInitialTreeSize">defaultMergeToolMaxInitialTreeSize	^999</body><body package="Store-User Management" selector="includeBranchBlessingCommentHistory">includeBranchBlessingCommentHistory	includeBranchBlessingCommentHistory isNil		ifTrue: [^self defaultIncludeBranchBlessingCommentHistoryPolicy].	^includeBranchBlessingCommentHistory</body><body package="Store-User Management" selector="includeBranchBlessingCommentHistory:">includeBranchBlessingCommentHistory: aSymbol	includeBranchBlessingCommentHistory := aSymbol</body><body package="Store-User Management" selector="integratedBlessingChangePolicy">integratedBlessingChangePolicy	integratedBlessingChangePolicy isNil		ifTrue: [^self defaultIntegratedBlessingChangePolicy].	^integratedBlessingChangePolicy</body><body package="Store-User Management" selector="integratedBlessingChangePolicy:">integratedBlessingChangePolicy: aSymbol	integratedBlessingChangePolicy := aSymbol</body><body package="Store-User Management" selector="integratedBlessingLevelForPackage:">integratedBlessingLevelForPackage: aPackage	^self integratedBlessingChangePolicy == #change		ifTrue: [self blessingForIntegrated]		ifFalse: [aPackage blessingLevel asNumber].</body><body package="Store-User Management" selector="mergeToolMaxInitialTreeSize">mergeToolMaxInitialTreeSize	mergeToolMinInitialTreeSize isNil		ifTrue: [^self defaultMergeToolMaxInitialTreeSize].	^mergeToolMinInitialTreeSize</body><body package="Store-User Management" selector="mergeToolMaxInitialTreeSize:">mergeToolMaxInitialTreeSize: anObject	mergeToolMinInitialTreeSize := anObject</body><body package="Store-User Management" selector="selectVersionsReadyForIntegration:">selectVersionsReadyForIntegration: aCollectionOfVersion	"Given a collection of versions select only integration ready versions."	^aCollectionOfVersion select: [:each| self isReadyForIntegration: each]</body><body package="Store-User Management" selector="shouldPublishAll">shouldPublishAll	^true</body><body package="Store-User Management" selector="versionsReadyForIntegration:">versionsReadyForIntegration: aName	| versions |	versions := Store.Glorp.StorePackage allVersionsWithName: aName.	^self selectVersionsReadyForIntegration: versions</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>blessings</category><body package="Store-User Management" selector="blessingForIntegrated">blessingForIntegrated	^Policies blessingPolicy integratedBlessing</body><body package="Store-User Management" selector="blessingForMerged">blessingForMerged	^Policies blessingPolicy mergedBlessing</body><body package="Store-User Management" selector="blessingForReadyForIntegration">blessingForReadyForIntegration	^Policies blessingPolicy integrationReadyBlessing</body><body package="Store-User Management" selector="blessingsForReadyForIntegration">blessingsForReadyForIntegration	"Use the array so  this can be extended to use other blessings if desired."		^Array with: ( self blessingForReadyForIntegration )</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>testing</category><body package="Store-User Management" selector="isReadyForIntegration:">isReadyForIntegration: aPackageVersion	"Answer true if aPackageVersion is ready for integration."	^aPackageVersion blessingLevelNumber = self blessingForReadyForIntegration</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="nextVersion:forPundle:">nextVersion: aString forPundle: aPundle	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit sequence in 'aString'. 	If this version already exists, creates a branch off the original.	 If 'aString' does not end with a digit, returns 'aString'"	| versionString |	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	versionString := self increment: aString.	(self existsVersionString: versionString forPundle: aPundle) ifFalse: [^versionString].	versionString := aString, self initialBranchString.	(self existsVersionString: versionString forPundle: aPundle) ifFalse: [^versionString].	versionString := aString, self nullBranchString.	^self nextVersion: versionString forPundle: aPundle</body><body package="Store-User Management" selector="nullBranchString">nullBranchString	^'.0'</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="increment:">increment: aString	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"		| lastNonDigit incrementedVersionNumber numberPortion newVersionString |	lastNonDigit := aString findLast: [:char | char isDigit not].	lastNonDigit = aString size ifTrue: [^aString].	numberPortion := aString copyFrom: lastNonDigit + 1 to: aString size.	incrementedVersionNumber :=  numberPortion asNumber + 1.	newVersionString := incrementedVersionNumber printString.	[numberPortion size &gt; newVersionString size] whileTrue: [newVersionString := '0' , newVersionString].	^(aString copyFrom: 1 to: lastNonDigit) , newVersionString</body><body package="Store-User Management" selector="initialBranchString">initialBranchString	^'.1'</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>accessing preferences</category><body package="Store-UI" selector="preferenceFor:">preferenceFor: aSubject 	^(self preferenceModelFor: aSubject) value</body><body package="Store-UI" selector="preferenceModelFor:">preferenceModelFor: aSubject 	UserPreferences isNil ifTrue: [self initializeUserPreferences].	^(UserPreferences at: aSubject ifAbsent: [^nil])</body><body package="Store-UI" selector="preferenceModelFor:put:">preferenceModelFor: aSubject put: aModel	UserPreferences isNil ifTrue: [self initializeUserPreferences].	^UserPreferences at: aSubject put: aModel</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	self initializeUserPreferences.</body><body package="Store-UI" selector="initializeUserPreferences">initializeUserPreferences	"The user preference profile is a Dictionary with of value models against subject keys."	"self initializeUserPreferences"	UserPreferences == nil ifTrue: [ UserPreferences := Dictionary new ].	UserPreferences		at: #databaseIdentifier  put: (self databaseIdentifier asValue);		at: #fileoutOption ifAbsentPut: [ #always asValue ];		at: #tablePrefix ifAbsentPut: [self tablePrefix asValue];		at: #newClassUseCurrent put: Policies packagePolicy newClassUseCurrent asValue;		at: #methodPlacement ifAbsentPut: [self methodPlacementInitialize asValue];		at: #datumPlacement ifAbsentPut: [self datumPlacementInitialize asValue];		at: #versionManagerView ifAbsentPut: [#listPresentation asValue];		yourself.</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>load/unload</category><body package="Store-UI" selector="prerequisitesForLoading">prerequisitesForLoading	"DBAcess initializes DBRegistry."	^super prerequisitesForLoading		add: DBAccess;		add: Access;		yourself</body></methods><methods><class-id>Store.StoreSettings class</class-id> <category>private</category><body package="Store-UI" selector="databaseIdentifier">databaseIdentifier	"Answer the current database indentifier, nil if none"	^ #{DbRegistry} ifDefinedDo:		[ :reg | reg databaseIdentifier ]</body><body package="Store-UI" selector="datumPlacementInitialize">datumPlacementInitialize	Policies packagePolicy newDatumUseCurrent		ifTrue: [Policies packagePolicy newDatumUseClass				ifTrue: [^#currentINUTCP]				ifFalse: [^#currentINAU]]		ifFalse: [Policies packagePolicy newDatumUseClass				ifTrue: [Policies packagePolicy newDatumUseClassIfNoCurrent						ifTrue: [Policies packagePolicy newDatumUseClassIfCurrentSame								ifTrue: [^#TCPICON]								ifFalse: [^#TCPIC]]						ifFalse: [^#useTCP]]				ifFalse: [^#alwaysAsk]].	^#alwaysAsk</body><body package="Store-UI" selector="methodPlacementInitialize">methodPlacementInitialize	Policies packagePolicy newMethodUseCurrent		ifTrue: [Policies packagePolicy newMethodUseClass				ifTrue: [^#currentINUTCP]				ifFalse: [^#currentINAU]]		ifFalse: [Policies packagePolicy newMethodUseClass				ifTrue: [Policies packagePolicy newMethodUseClassIfNoCurrent						ifTrue: [Policies packagePolicy newMethodUseClassIfCurrentSame								ifTrue: [^#TCPICON]								ifFalse: [^#TCPIC]]						ifFalse: [^#useTCP]]				ifFalse: [^#alwaysAsk]].	^#alwaysAsk</body><body package="Store-UI" selector="tablePrefix">tablePrefix		^DbRegistry tablePrefix</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>interface opening</category><body package="Store-Merge Management" selector="postBuildWith:">postBuildWith: aBuilder	| iconComponent |	super postBuildWith: aBuilder.	(iconComponent := builder componentAt: #HelpIconList) isNil		ifTrue: [^self].	self setupVisualBlockFor: iconComponent widget.</body><body package="Store-Merge Management" selector="postOpenWith:">postOpenWith: aBuilder	super postBuildWith: aBuilder.	self setCloseOnEscapeKeyboardHook.	(builder componentAt: #HelpText) ifNotNil: 		[:wrapper | 		wrapper takeKeyboardFocus.		self setHelpTextKeyboardHook: wrapper widget controller].	(builder componentAt: #HelpIconList) isNil		ifTrue: [^self].	self helpIconList list: self createIconList.</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>private</category><body package="Store-Merge Management" selector="createIconList">createIconList	| widget list style offset |	widget := (builder componentAt: #HelpIconList) widget.	widget lineGrid: 20.	style := widget textStyle.	offset := 6 @ 2.	list := List new.	list		add: ((LabelAndIcon				with: #Unresolved &lt;&lt; #store &gt;&gt; 'Unresolved'				attributes: style				offset: offset) icon: MergeIcons unresolved).	list		add: ((LabelAndIcon				with: #ResolvedOrResolution &lt;&lt; #store &gt;&gt; 'Resolved or resolution'				attributes: style				offset: offset) icon: MergeIcons resolved).	list		add: ((LabelAndIcon				with: #Applied &lt;&lt; #store &gt;&gt; 'Applied'				attributes: style				offset: offset) icon: MergeIcons applied).	list		add: ((LabelAndIcon				with: #Class &lt;&lt; #store &gt;&gt; 'Class'				attributes: style				offset: offset) icon: Behavior toolListIcon).	list		add: ((LabelAndIcon				with: #Namespace &lt;&lt; #store &gt;&gt; 'Namespace'				attributes: style				offset: offset) icon: GeneralNameSpace toolListIcon).	list		add: ((LabelAndIcon				with: #AddComponent &lt;&lt; #store &gt;&gt; 'Add component'				attributes: style				offset: offset) icon: MergeIcons add).	list		add: ((LabelAndIcon				with: #ModifiyComponent &lt;&lt; #store &gt;&gt; 'Modifiy component'				attributes: style				offset: offset) icon: MergeIcons modify).	list		add: ((LabelAndIcon				with: #RemoveComponent &lt;&lt; #store &gt;&gt; 'Remove component'				attributes: style				offset: offset) icon: MergeIcons remove).	list		add: ((LabelAndIcon				with: #MoveComponent &lt;&lt; #store &gt;&gt; 'Move component'				attributes: style				offset: offset) icon: MergeIcons move).	^list</body><body package="Store-Merge Management" selector="helpText">helpText	^ (#MergeHelpText &lt;&lt; #store &gt;&gt; 'Overview&lt;n&gt;Merging of a package is done by merging a version from the repository into the version in the image. The image version is referred to as the trunk and the repository version is referred to as the branch. The merge process first finds the most recent version that is the ancestor of trunk and the branch, i.e. where branch forked off. Next, changes are computed from this common (base) version to both the trunk and the branch. For each component change, a modification set is created. Each modification set holds the changes made by the versions being merged.&lt;nn&gt;After all the modification sets have been created, the modifications are analyzed to calculate resolutions. If there is only one change from the base version then that change becomes the resolution. If there is more than one change then the modification set is left to the user to resolve. Additionally, if the computed resolution is already in the trunk then the modification is marked as having been applied. Also, if the "Hide Image Only Mods" option, under the View menu, is set then these mods are not shown in the modification view.&lt;nn&gt;Image Only Mods are modification sets that contain only changes between the base version and the image. When one considers the image version to be the trunk version the image only mods are of little interest because they are the desired changes and need no further review.&lt;nn&gt;The modification sets are displayed in either in a list or a hierarchy in the Modifications pane. The resolution status of each modification set is shown by the leftmost icon. Upon selecting a modification set, the individual modification versions are shown in the Versions pane. The user can then review, compare, and determine which version is to be the resolution. After the modification resolutions have been determined they must be applied. Applying a resolution modifies the image to correspond to the resolution. After all resolutions have been applied the bundles/packages can be published.&lt;nn&gt;Selecting packages to merge&lt;nt&gt;Open the package selection dialog either from the Packages menu or from "Select Packages..." button.&lt;nt&gt;Only bundles/packages loaded in the image will appear in the "Bundles and packages" list. Upon selecting a package/bundle the versions will appear in the "Versions:" list. The versions to merge can then be added to the "Selected versions:" list.&lt;nt&gt;When the "Selected versions:" list has all the desired versions, hit the OK button and the process to calculate the modification set will begin.&lt;nn&gt;Modifications Pane&lt;n&gt;The modification sets can be viewed (top left) either in a list or a hierrarchy. When viewed in a hierarchy the first level is either a package or a bundle. The second level items can be a namespace, a class, a property, or an aggregate class operation.&lt;nn&gt;Commands&lt;nt&gt;Unresolve&lt;tttt&gt;Marks the modification set as being unresolved. However, if a resolution had been applied the image state is not reverted.&lt;nt&gt;Apply Resolution&lt;tt&gt;Applies the selected resolution.&lt;nt&gt;Browse Senders&lt;ttt&gt;Opens a browser on the method senders.&lt;nt&gt;Browse Implementors&lt;t&gt;Opens a browser on the method implementors.&lt;nt&gt;Browse Versions&lt;tt&gt;Opens a version browser on the selected component.&lt;nt&gt;Show All&lt;tttt&gt;Unfiltered.&lt;nt&gt;Show Conflicts&lt;ttt&gt;Filters the modifications pane so only modification sets with conflicts are shown.&lt;nt&gt;Show Unresolved&lt;tt&gt;Filters the modifications pane so only unresolved modification sets are shown.&lt;nt&gt;Hide Image-only Mods&lt;t&gt;Hides modification sets that contain only changes between the image and base version.&lt;nn&gt;Versions Pane&lt;n&gt;The versions pane (top right) shows the different versions available, and can be used to choose a resolution for the item selected in the modifications pane.&lt;nn&gt;Commands&lt;nt&gt;Unresolve&lt;tttt&gt;Marks the modification set as being unresolved. However, if a resolution had been applied the image state is not reverted.&lt;nt&gt;Select as Resolution&lt;t&gt;Marks the selected version as the resolution for the current modification set.&lt;nt&gt;Apply Resolution&lt;tt&gt;Applies the current resolution of the selected modification set.&lt;nt&gt;Open comparison with Base&lt;ttt&gt;Opens a differator window comparing the base with the selected version.&lt;nt&gt;Open comparison with Resolution&lt;t&gt;Opens a differator window comparing the resolution with the selected version.&lt;nt&gt;Open comparison with Image&lt;tt&gt;Opens a differator window comparing the image with the selected version.&lt;nt&gt;Open Comparison of Selected&lt;tt&gt;Opens a differator window comparing the two selected versions.&lt;nn&gt;Code Pane&lt;n&gt;The lower left pane shows the code associated with a selected version. Sometimes when a conflict is encountered, there is no selection that represents the desired outcome. This pane may be used as a normal code editing pane to accept an entirely new resolution. The particular change will be marked as applied when changes are accepted in this pane.&lt;nn&gt;Comparison Pane&lt;n&gt;The lower right pane allows the user to choose different versions that are available as part of the merge and compare them against the version selected in the versions pane.') expandMacros</body><body package="Store-Merge Management" selector="setCloseOnEscapeKeyboardHook">setCloseOnEscapeKeyboardHook	builder keyboardProcessor keyboardHook:		[:event :controller |		Character esc = event keyValue ifTrue: [self closeRequest].		event].</body><body package="Store-Merge Management" selector="setHelpTextKeyboardHook:">setHelpTextKeyboardHook: aController	aController keyboardHook:		[:event :controller |		(#(PageDown PageUp) includes: event keyValue)			ifTrue: [event]			ifFalse: [nil]]</body><body package="Store-Merge Management" selector="setupVisualBlockFor:">setupVisualBlockFor: listView	listView visualBlock: 		[:view :index | BoundedWrapper on: (view sequence at: index)].	listView controller: NoController new.</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	super initialize.	self helpIconList list: List new.</body></methods><methods><class-id>Store.MergeToolHelp</class-id> <category>aspects</category><body package="Store-Merge Management" selector="helpIconList">helpIconList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^helpIconList isNil		ifTrue:			[helpIconList := SelectionInList new]		ifFalse:			[helpIconList]</body><body package="Store-Merge Management" selector="helpTextHolder">helpTextHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^helpTextHolder isNil		ifTrue:			[helpTextHolder := self helpText asValue]		ifFalse:			[helpTextHolder]</body></methods><methods><class-id>Store.MergeToolHelp class</class-id> <category>interface opening</category><body package="Store-Merge Management" selector="openHowToUseHelp">openHowToUseHelp	self openWithSpec: #howToUseHelpSpec</body><body package="Store-Merge Management" selector="openIconHelp">openIconHelp	self openWithSpec: #iconHelpSpec</body></methods><methods><class-id>Store.Blob</class-id> <category>private-db</category><body package="Store-DB-BaseObjects" selector="chainTo:">chainTo: aBlob 	"Store the primary key of aBlob in the 'blobType' instance variable."	blobType := aBlob primaryKey negated</body><body package="Store-DB-BaseObjects" selector="convertData">convertData	"Use the 'blobType' field to convert the binary data blob into the appropriate type."	blobData isNil ifTrue: [^nil].	self isString ifTrue: [^blobData := blobData asString].	self isTwoByteString 		ifTrue: 			[| strm |			strm := ReadStream on: blobData.			^blobData := self decodeTwoByteDefinitionStream: strm].	self isData ifTrue: [^blobData := self decode: blobData].	self isByteArray ifTrue: [^blobData].	self error: #UnknownDataType &lt;&lt; #store &gt;&gt; 'Unknown data type'</body><body package="Store-DB-BaseObjects" selector="convertToBinary">convertToBinary	"Temporarily convert the data stored in the blobData instance variable into 	binary data. This conversion is done just before storing data in the data base."	blobData := self isTwoByteString		ifTrue: [ self encodeTwoByteDefinition: blobData ]		ifFalse: [ ( self isString )  |  ( self isByteArray )					ifTrue: [ blobData asByteArray ]					ifFalse: [ ( self encode: blobData ) asByteArray ]				].</body><body package="Store-DB-BaseObjects" selector="getBlobData">getBlobData	^ self broker getBlobData: blobData</body><body package="Store-DB-BaseObjects" selector="getBlobType">getBlobType	^blobType</body><body package="Store-DB-BaseObjects" selector="hasFakeType">hasFakeType	"Used to mark definitions that are spread among multiple records."	^blobType &lt; 0</body><body package="Store-DB-BaseObjects" selector="installInDatabase">installInDatabase	"If the blobData field is nil or empty then do not create the new record in DB. 	If the definition is longer then allowed by database then split it into multiple records."	| originalData |	( blobData ==nil  )		ifTrue: [ self primaryKey: 0.  	^self ].	originalData := blobData.		[ self convertToBinary.	blobData size &gt; self broker maxLongBytes		ifTrue: [ self installMultipleChunks  ]		"Split definition into multiple chunks."		ifFalse: [ self putIntoDatabase ]	] ensure: [ blobData := originalData ]</body><body package="Store-DB-BaseObjects" selector="installMultipleChunks">installMultipleChunks	"The definition is too long to fit into one record, split 	it into chunks no bigger then 'maxLongBytes' and install 	them as separate records. Mark chunks by putting	'fakeType' into the 'blobType' column.	The last chunk contains the real type."	| len nbr cSize chunks min max  def |	def := blobData.	len := def size.	nbr := len // self broker maxLongBytes + 1.	cSize := len // nbr + 1.	chunks := OrderedCollection new.	min := 1.		[max := len min: min + cSize - 1.	chunks add: (def copyFrom: min to: max).	min := max + 1.	min &lt; len] whileTrue.		self putChunksIntoDatabase: chunks</body><body package="Store-DB-BaseObjects" selector="nextChunk">nextChunk	^blobType negated</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	(self primaryKey isNil ) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"Set primary key."	(self class needsSequenceFor: self class) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="putChunksIntoDatabase:">putChunksIntoDatabase: chunks 	"Put data from multiple chunks into separate records in the database. 	Mark chunks by putting 'fakeBlobType' and by storing primaryKey of the next 	chunk into 'blobType' column. The last chunk contains the real record type."	| originalDef prevChunk newChunk |	originalDef := blobData.		[ self setData: chunks removeLast.	self putIntoDatabase.	prevChunk := self.	chunks reverseDo: 		[ :chunk | 		newChunk := self class privateNewPrimed.		newChunk setData: chunk; chainTo: prevChunk.		newChunk putIntoDatabase.		prevChunk := newChunk		].	self primaryKey: prevChunk primaryKey	] ensure: [ blobData := originalDef ]</body><body package="Store-DB-BaseObjects" selector="putIntoDatabase">putIntoDatabase	"Put data into database."	self preDatabaseInstall.	self broker getAnswerFromSession: [self class writeSession]		bindInput: [:session | session bindInput: self].	self postDatabaseInstall.</body><body package="Store-DB-BaseObjects" selector="setBlobType:">setBlobType: aValue	blobType := aValue</body><body package="Store-DB-BaseObjects" selector="setData:">setData: aValue	blobData := aValue</body></methods><methods><class-id>Store.Blob</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="binData">binData	^blobData isNil		ifTrue: [#[]]		ifFalse: [blobData]</body><body package="Store-DB-BaseObjects" selector="binData:">binData: aByteArray	"Store binary data."	blobData := aByteArray.	self beData.</body><body package="Store-DB-BaseObjects" selector="definition">definition	(self isString or: [self isTwoByteString]) ifFalse: 		[self error: #AccessingStringsInsteadOfBinaryData &lt;&lt; #store &gt;&gt; 'Accessing strings instead of binary data.'].	^blobData isNil		ifTrue: ['']		ifFalse: [blobData]</body><body package="Store-DB-BaseObjects" selector="definition:">definition: aString 	"Store a definition string."	| isSingleByte |	aString isNil ifTrue: [blobData := nil. ^self beString].	isSingleByte := [aString asByteArrayEncoding: #'iso-8859-1'. true] 		on: UnsupportedCharacterError 		do: [:ex | ex return: false].	isSingleByte		ifTrue: [			self beString.			blobData := aString]		ifFalse: [			self beTwoByteString.			blobData := aString asTwoByteString].</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	"Answer the receiver's primaryKey."	^primaryKey</body><body package="Store-DB-BaseObjects" selector="primaryKey:">primaryKey: newPrimaryKey	"Set the receiver's primaryKey to newPrimaryKey."	primaryKey := newPrimaryKey</body><body package="Store-DB-BaseObjects" selector="rawData">rawData	^blobData </body><body package="Store-DB-BaseObjects" selector="rawData:">rawData: aByteArray	"Store binary data with no conversions."	blobData := aByteArray.	self beByteArray.</body></methods><methods><class-id>Store.Blob</class-id> <category>accessing-types</category><body package="Store-DB-BaseObjects" selector="beByteArray">beByteArray	blobType := 4.</body><body package="Store-DB-BaseObjects" selector="beData">beData	blobType := 1.</body><body package="Store-DB-BaseObjects" selector="beString">beString	blobType := 2.</body><body package="Store-DB-BaseObjects" selector="beTwoByteString">beTwoByteString	blobType := 3.</body><body package="Store-DB-BaseObjects" selector="isByteArray">isByteArray	^blobType = 4</body><body package="Store-DB-BaseObjects" selector="isData">isData	^blobType = 1.</body><body package="Store-DB-BaseObjects" selector="isString">isString	^blobType = 2</body><body package="Store-DB-BaseObjects" selector="isTwoByteString">isTwoByteString	^blobType = 3.</body></methods><methods><class-id>Store.Blob</class-id> <category>private-two byte strings</category><body package="Store-DB-BaseObjects" selector="byteOrder">byteOrder	| test null chara |	test := 'abc' asTwoByteString.	null := 0.	chara := $a asInteger.	((test basicAt: 1) = chara and: [(test basicAt: 2) = null]) 		ifTrue: [^#(0 1)].	((test basicAt: 2) = chara and: [(test basicAt: 1) = null]) 		ifTrue: [^#(1 0)].	self error: #CanNotDetermineByteOrderForTwoByteString &lt;&lt; #store &gt;&gt; 'Can not determine byte order for TwoByteString'</body><body package="Store-DB-BaseObjects" selector="decodeTwoByteDefinitionStream:">decodeTwoByteDefinitionStream: strm	| string2Byte order inx |	string2Byte := TwoByteString new: strm size.	order := self byteOrder.	inx := 1.	[strm atEnd]		whileFalse: 			[string2Byte basicAt: inx + order first put: (self readDecodedByteFrom: strm).			string2Byte basicAt: inx + order last put: (self readDecodedByteFrom: strm).			inx := inx + 2].	^string2Byte copyFrom: 1 to: ((inx - 1)//2)</body><body package="Store-DB-BaseObjects" selector="encodeTwoByteDefinition:">encodeTwoByteDefinition: aString	| strm order |	strm := WriteStream on: (String new: (aString size * 4)).	order := self byteOrder.	1 to: aString basicSize by: 2 do: [:inx|		self writeByte: (aString basicAt: inx + order first) encodedOn: strm.		self writeByte: (aString basicAt: inx + order last) encodedOn: strm].	^strm contents asByteArray</body><body package="Store-DB-BaseObjects" selector="readDecodedByteFrom:">readDecodedByteFrom: aStream 	| code |	code := aStream next asInteger.	^(code &gt;= 16 and: [code &lt;= 127]) 		ifTrue: [code]		ifFalse: 			[code = 1 				ifTrue: [0]				ifFalse: 					[(code &gt;= 2 and: [code &lt;= 5]) 						ifTrue: [aStream next asInteger - 32 + ((code - 2) * 64)]						ifFalse: 							[self error: #InvalidEncodingOfTwoByteString &lt;&lt; #store &gt;&gt; 'Invalid encoding of TwoByteString'.							0]]]</body><body package="Store-DB-BaseObjects" selector="writeByte:encodedOn:">writeByte: aByte encodedOn: aStream 	(aByte &gt;= 16 and: [aByte &lt;= 127])		ifTrue: [aStream nextPut: (Character value: aByte)]		ifFalse: [aByte = 0				ifTrue: [aStream nextPut: (Character value: 1)]				ifFalse: 					[aStream nextPut: (Character value: 2 + (aByte // 64)).					aStream nextPut: (Character value: 32 + (aByte \\ 64))]]</body></methods><methods><class-id>Store.Blob class</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="defaultBlockFactor">defaultBlockFactor	^5</body><body package="Store-DB-BaseObjects" selector="new">new	self error: #InstancesOfBlobShouFromBinMessages &lt;&lt; #store &gt;&gt; 'Instances of Blob should be created using "fromString:" or "fromBin:" messages.'</body><body package="Store-DB-BaseObjects" selector="privateNewPrimed">privateNewPrimed	| baby |	baby := super new.	baby prime.	^baby</body></methods><methods><class-id>Store.Blob class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="defReferenceColumnNames">defReferenceColumnNames	"Answer the columns used when linking directly to sources in a view."	^Array 		with: ( self broker columnName: 'blobType' for: self )		with: ( self broker columnName: 'blobData' for: self )</body><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'primaryKey' put: #PrimaryKey.	aDict at: 'blobType' put: #Integer.	aDict at: 'blobData' put: #BinData.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="fromStoredDefinition:">fromStoredDefinition: aDefinition		| newDBDefinition |	newDBDefinition := self privateNewPrimed.	newDBDefinition primaryKey: aDefinition primaryKey.	newDBDefinition definition:  aDefinition definition.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE ', self tableSpaceName, ' STORAGE(INITIAL 1M NEXT 256K)'</body><body package="Store-DB-BaseObjects" selector="needsSequence">needsSequence	^true</body><body package="Store-DB-BaseObjects" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 25M NEXT 2M PCTINCREASE 1) '</body><body package="Store-DB-BaseObjects" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy blobTableSpace</body></methods><methods><class-id>Store.Blob class</class-id> <category>private-db-utilities</category><body package="Store-DB-BaseObjects" selector="aRecordWithID:session:">aRecordWithID: anID session: aSession 	"Given a record ID (primary key) and a database session 	answer an instance of TT_Blob. 	Check for definitions that are stored in multiple chunks and 	combine multiple DB records into one definition."	"self aRecordWithID: 1"	| res |	res := self getRecordWithID: anID session: aSession.	res isNil ifTrue: [^nil].	self retrieveSources: res session: aSession.	res convertData.	^res</body><body package="Store-DB-BaseObjects" selector="createDefinitionSession">createDefinitionSession	"Given a connection answer a session suitable 	for retriving definition records by thier 	primary keys."	| session |	session :=  self broker getNewSession.	session bindOutput: self privateNewPrimed; 			bindInput: self privateNewPrimed; 			prepare: 				( self newSQL					selectAll;					where;					column: #primaryKey equalTo: ':primaryKey').	^session</body><body package="Store-DB-BaseObjects" selector="definitionSession">definitionSession	"Answer a session for retrieving definition records 	by the primary key."	( self isSessionValid: DefinitionSession)		ifFalse: 			[DefinitionSession :=  self createDefinitionSession].	^DefinitionSession</body><body package="Store-DB-BaseObjects" selector="getRecordWithID:session:">getRecordWithID: anID session: aSession 	"Given a record ID (primary key) and a database session	answer an instance of TT_Blob.	This is low level access method which does not combine	records."	"self aRecordWithID: 1"	| res ans |	aSession bindInput primaryKey: anID.	aSession execute.		[ans := aSession answer.	ans == #noMoreAnswers] 			whileFalse: [ans == #noAnswerStream ifFalse: [res := ans upToEnd]].	^res isEmpty 		ifTrue: [nil]		ifFalse: 			[res size &gt; 1 				ifTrue: 					[self error: #DuplicateMethodDefinition &lt;&lt; #store &gt;&gt; 'Duplicate method definition'.					nil]				ifFalse: 					[| rec |					rec := res first.					rec						unprime;						processFields.					rec]]</body><body package="Store-DB-BaseObjects" selector="resetSession">resetSession	DefinitionSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: DefinitionSession].		DefinitionSession := nil].	WriteSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: WriteSession].		WriteSession := nil]</body><body package="Store-DB-BaseObjects" selector="retrieveSources:session:">retrieveSources: aBlob session: aSession	"If the sources of aBlob are chunks, then read and concat. all the chunks."	aBlob hasFakeType 		ifTrue:			[ | dataList record data dataSize index |			 "Use a LinkedList to collect all the chunks to defer allocating the result			 until the total size is known, avoiding n squared concatenation overhead."			dataList := LinkedList new.			record := aBlob.		dataList addLast: (LinkValue value: record binData).				[record := self getRecordWithID: record nextChunk session: aSession.		dataList addLast: (LinkValue value: record binData).		record hasFakeType]			whileTrue.		aBlob setBlobType: record getBlobType.		dataSize := dataList inject: 0 into: [:sz :dataLink| sz + dataLink value size].		data := dataList first value class new: dataSize.		index := 1.		dataList do:			[:dataLink| | binData binDataSize |			binData := dataLink value.			binDataSize := binData size.			data replaceFrom: index to: index + binDataSize - 1 with: binData startingAt: 1.			index := index + binDataSize].		aBlob setData: data].	^aBlob</body><body package="Store-DB-BaseObjects" selector="writeSession">writeSession	"Answer a session for storing blobs"	( self isSessionValid: WriteSession)			ifFalse: 				[WriteSession := self broker getNewSession.				WriteSession bindOutput: self privateNewPrimed; 								prepare: 									( self newSQL									insertColumns: #( primaryKey blobType blobData )									values: #( ':primaryKey'  ':getBlobType'  ':getBlobData' )).				].	^WriteSession</body></methods><methods><class-id>Store.Blob class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB."	"self aRecordWithID: 1"	( anID isNil or: [ anID = 0 ] )  ifTrue: [ ^self fromString: nil ].	^[ self broker safelyExecuteBlock: 		[ self aRecordWithID: anID session: self definitionSession ]	] 	on: self errorSignals 	do: 	[:ex |  ex outer. 			self fromString: nil ]</body><body package="Store-DB-BaseObjects" selector="fromBinData:">fromBinData: aByteArray	"Create a new DB record from a string,	fill in user name and time stamp.	If aString is nil answer a record with key = 0."	| newDBDefinition |	newDBDefinition := self privateNewPrimed.	newDBDefinition binData: aByteArray.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="fromDocumentView:">fromDocumentView: aDocumentView	"Answer an instance from a view that includes the comment"	"Note, that this is a temporary guy used for converting sources. The primaryKey is not known. Also note that there may be no comment"	| blob |	aDocumentView documentBlobType isNil ifTrue: [ ^self basicNew beString ].	( blob := self basicNew )		setBlobType: aDocumentView documentBlobType;		setData: aDocumentView documentBlobData.	self retrieveSources: blob session: self definitionSession.	blob convertData.	^blob.</body><body package="Store-DB-BaseObjects" selector="fromRawData:">fromRawData: aByteArray	"Create a new DB record from a bytearray, fill in user name and time stamp.	If aByteArray is nil answer a record with key = 0."	| newDBDefinition |	newDBDefinition := self privateNewPrimed.	newDBDefinition rawData: aByteArray.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="fromString:">fromString: aString	"Create a new DB record from a string,	fill in user name and time stamp.	If aString is nil answer a record with key = 0."	| newDBDefinition string |	string := aString == nil ifTrue: [ aString ] ifFalse: [ aString asString ].	newDBDefinition := self privateNewPrimed.	newDBDefinition definition: string.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="fromView:">fromView: aSourcesView	"Answer an instance from a view that includes sources"	"Note, that this is a temporary guy used for converting sources. The primaryKey is not known."	| blob |	( blob := self basicNew )		setBlobType: aSourcesView blobType;		setData: aSourcesView blobData.	self retrieveSources: blob session: self definitionSession.	blob convertData.	^blob.</body></methods><methods><class-id>Store.Blob class</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="allIdsForID:">allIdsForID: anID	"Answer a collection of all ids chained to anID"	| session list record |	session := self definitionSession.	record := self getRecordWithID: anID session: session.	record isNil ifTrue: [ ^#( ) ].	list := OrderedCollection new.	[ record hasFakeType ] whileTrue:		[ list addLast: record nextChunk.			record := self getRecordWithID: record nextChunk session: session.		].	^list</body><body package="Store-DB-BaseObjects" selector="removeAllDBRecordsForID:">removeAllDBRecordsForID: anID 	"Remove a record with a primary key, anID AND all the linked records."	( self allIdsForID: anID ) do:		[ :id | self removeFromDBRecordWithID: id ].	self removeFromDBRecordWithID: anID.</body><body package="Store-DB-BaseObjects" selector="removeFromDBRecordWithID:">removeFromDBRecordWithID: anID	"Remove a record with primary key = anID from the database.	Note that this method can only be sent by the database	system administrator, since it requires privileges	that are not given to the regular users."	self broker process: 			( self newSQL				delete;				where;				column: #primaryKey  equalTo: anID printString)</body></methods><methods><class-id>Store.BinaryBlob class</class-id> <category>private-db-utilities</category><body package="Store-DB-BaseObjects" selector="definitionSession">definitionSession	"Answer a session for retrieving definition records 	by the primary key."	( self isSessionValid: DefinitionSession)		ifFalse: 			[DefinitionSession := self  createDefinitionSession].	^DefinitionSession</body><body package="Store-DB-BaseObjects" selector="resetSession">resetSession	DefinitionSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: DefinitionSession].		DefinitionSession := nil].	WriteSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: WriteSession].		WriteSession := nil]</body><body package="Store-DB-BaseObjects" selector="writeSession">writeSession	"Answer a session for storing blobs"	( self isSessionValid: WriteSession)		ifFalse: 			[WriteSession := self broker getNewSession.			WriteSession bindOutput: self privateNewPrimed; 						prepare: 							( self newSQL								insertColumns: #( primaryKey blobType blobData )								values: #( ':primaryKey'  ':getBlobType'  ':getBlobData' )).			].	^WriteSession</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject</class-id> <category>private - accessing</category><body package="Store-Database Model" selector="signatureObject:">signatureObject: aSignatureObject	signatureObject := aSignatureObject</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject</class-id> <category>comparing</category><body package="Store-Database Model" selector="=">= anObject	^self signatureObject equalsSignatureIn: anObject signatureObject</body><body package="Store-Database Model" selector="hash">hash	^self signatureObject signatureHash</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject</class-id> <category>accessing</category><body package="Store-Database Model" selector="signatureObject">signatureObject	^signatureObject</body></methods><methods><class-id>Store.Glorp.StoreSignatureObject class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="for:">for: aSignatureObject	^self new		signatureObject: aSignatureObject;		yourself</body></methods><methods><class-id>Store.Properties</class-id> <category>printing</category><body package="Store-DB-Records" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: pundleRef printString, ': ', propertyRef printString, '(', recType printString, ')';		nextPut: $).</body></methods><methods><class-id>Store.Properties</class-id> <category>accessing</category><body package="Store-DB-Records" selector="primaryKey">primaryKey	^OrderedCollection 		with: self packageRef		with: self propertyRef		with: self recType</body><body package="Store-DB-Records" selector="propertyRef">propertyRef	"Answer the receiver's propertyRef."	^propertyRef</body><body package="Store-DB-Records" selector="propertyRef:">propertyRef: newPropertyRef 	"Set the receiver's propertyRef to newPropertyRef."	propertyRef := newPropertyRef</body><body package="Store-DB-Records" selector="pundleRef">pundleRef	"Answer the receiver's pundleRef."	^pundleRef</body><body package="Store-DB-Records" selector="pundleRef:">pundleRef: newPundleRef 	"Set the receiver's pundleRef to newPundleRef."	pundleRef := newPundleRef</body><body package="Store-DB-Records" selector="recType">recType	"Answer the receiver's recType."	^recType</body><body package="Store-DB-Records" selector="recType:">recType: newRecType	"Set the receiver's recType to newRecType."	recType := newRecType</body><body package="Store-DB-Records" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self propertyRef</body></methods><methods><class-id>Store.Properties class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_PropertiesReverse' #('propertyRef'))		)</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn		^#propertyRef</body><body package="Store-DB-Records" selector="typeCodeForBundles">typeCodeForBundles	^0</body><body package="Store-DB-Records" selector="typeCodeForClass:">typeCodeForClass: aClass 	"self typeCodeForClass: Package"	^(aClass isKindOf: Bundle) 		ifTrue: [self typeCodeForBundles]		ifFalse: [self typeCodeForPackages]</body><body package="Store-DB-Records" selector="typeCodeForPackages">typeCodeForPackages	^1</body></methods><methods><class-id>Store.Properties class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes	"Note: recType left out here defaults correctly to VARCHAR(255)."	| aDict  |	aDict := Dictionary new.	aDict at: 'pundleRef' put: #PrimaryKey.	aDict at: 'propertyRef' put: #PrimaryKey.	aDict at: 'recType' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Properties class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="bundlesContainingProperty:">bundlesContainingProperty: anID	"Check what bundles define a given property. Return a collection of bundle IDs."	^self pundlesContainingProperty: anID type: self typeCodeForBundles</body><body package="Store-DB-Records" selector="packagesContainingProperty:">packagesContainingProperty: anID	"Check what packages define a given property. Return a collection of package IDs "	^self pundlesContainingProperty: anID type: self typeCodeForPackages</body><body package="Store-DB-Records" selector="pundlesContainingProperty:type:">pundlesContainingProperty: anID type: aRecordTypeCode	"Check what pundles define a given property. Return a collection of pundle IDs.	aRecordTypeString is part of the key, eg., 0 for bundle, 1 for package."	^[(self broker process: 			( self newSQL				select: #( pundleRef );				where;				column: #propertyRef equalTo: anID printString;				and;				column: #recType equalTo: aRecordTypeCode printString)	 ) collect: [ :each | each first ]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body><body package="Store-DB-Records" selector="removeAllConnectedTo:">removeAllConnectedTo: aPundleID	"Remove any record from the table which references aPundleID.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self deleteWhereColumn:  #pundleRef value: aPundleID printString.</body></methods><methods><class-id>Store.Reconciling</class-id> <category>accessing</category><body package="Store-Difference Management" selector="actionText">actionText	^(#Reconciling &lt;&lt; #store &gt;&gt; 'Reconciling') asString</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	^self nameSpace notNil</body><body package="Store-Change Management" selector="isForNameSpace">isForNameSpace	^true</body><body package="Store-Change Management" selector="isNameSpaceTag">isNameSpaceTag	^true</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new namespace from a definition contained in 	aRecord. Return true is the operation is successful."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag can be load into the image."	^symbol asStrictReference environment ~~ nil</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="actual">actual	"Answer the namespace in the image that the reciever applies to. nil if none."	^symbol asStrictReference ifDefinedDo: 		[ :ns | ns ].</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me."	^Registry containingPackageForSymbol: symbol</body><body package="Store-Change Management" selector="description">description	^'definition'</body><body package="Store-Change Management" selector="nameSpace">nameSpace	^symbol asStrictReference valueOrDo: [ nil ].</body><body package="Store-Change Management" selector="nameSpace:">nameSpace: aNameSpace	symbol := aNameSpace absoluteSymbol</body><body package="Store-Change Management" selector="nameSpaceName">nameSpaceName	^symbol asString</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| ns |	ns := self nameSpace.	^ns == nil		ifTrue: [ nil ]		ifFalse: [ ns definition ]</body><body package="Store-Change Management" selector="tagIndex">tagIndex	^self tagBaseIndex</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag.  Return True if	sucessful and False on failure."	| changed |	Cursor execute showWhile: 		[ changed := Object evaluatorClass 				evaluate: someText string				notifying: aController				logged: true		].	^changed ~~ nil</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self nameSpace.	actual notNil		ifTrue: [ XChangeSet current				moveNameSpaceDefinition: actual				toPackage: newPackage				]		ifFalse: [ aBlock value ]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	"Remove the receiver's definition from the image if aPackage owns it. If tolerantBoolean is false, 	display an error if the definition doesn't exist."	| ns |	ns := self nameSpace.	ns isNil 		ifTrue: 			[tolerantBoolean 				ifFalse: 					[self error: ((#NameSpace1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'NameSpace "&lt;1s&gt;" does not exist in the image.') 								expandMacrosWith: self name)]]		ifFalse: 			[(aPackage hasDefinitionFor: ns) 				ifTrue: [Override unloadClassOrNameSpace: ns from: aPackage]]</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseNameSpace: self nameSpace.</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType	^#nameSpace</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	( obj := self nameSpace ) == nil		ifFalse: 	[ obj fileOutDefinitionOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutDefinitionOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	self isMeta		ifFalse: [ aStream removeObject: symbol type: self fileOutObjectType ]</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'namespace definition'</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForNameSpaceTag: self.</body></methods><methods><class-id>Store.NameSpaceTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClass:">newClass: aClass	^self shouldNotImplement</body><body package="Store-Change Management" selector="newClassName:">newClassName: aString	^self shouldNotImplement</body><body package="Store-Change Management" selector="newClassSymbol:isMeta:">newClassSymbol: aSymbol isMeta: aBoolean	^self shouldNotImplement</body><body package="Store-Change Management" selector="newNameSpace:">newNameSpace: aNameSpace	^self new nameSpace: aNameSpace</body><body package="Store-Change Management" selector="newNameSpaceName:">newNameSpaceName: aString	^self new name: aString</body><body package="Store-Change Management" selector="newNameSpaceSymbol:">newNameSpaceSymbol: aSymbol	^self new symbol: aSymbol</body></methods><methods><class-id>Store.NameSpaceTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^8</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>testing</category><body package="Store-Change Management" selector="isNameSpaceCommentTag">isNameSpaceCommentTag	^true</body><body package="Store-Change Management" selector="isNameSpaceTag">isNameSpaceTag	^false</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new class comment from a definition contained in 	aRecord. 	Return true is the operation is successful."	| ns |	ns := aRecord nameSpace.	^ns == nil 		ifTrue: 			[self error: ((#NameSpace1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'NameSpace "&lt;1s&gt;" does not exist in the image.') expandMacrosWith: aRecord absoluteName).			false]		ifFalse: 			[aRecord loadCommentFor: ns.			true]</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="description">description	^'Namespace comment'</body><body package="Store-Change Management" selector="name">name	"Return the name as a string.."	^super name, ' comment'</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| ns |	ns := self nameSpace.	^ns == nil		ifTrue: [ nil ]		ifFalse: [ ns comment ]</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| namespace |	namespace := self nameSpace.	namespace isNil 		ifTrue: 			[Dialog 				warn: ((#TheNameSpace1sMAndApplyResolved &lt;&lt; #store &gt;&gt; 'The NameSpace "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept an edited comment.&lt;n&gt;Resolve conflicts in the NameSpace definition, if any,&lt;n&gt;and "Apply Resolved".') 						expandMacrosWith: self symbol asString).			^false].	namespace comment: someText.	^true</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	tolerantBoolean ifFalse: 		[self error: #IDoNotKnowHowToRemoveComments &lt;&lt; #store &gt;&gt; 'I do not know how to remove comments']</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self namespace ) == nil		ifFalse: [ obj fileOutCommentOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutCommentOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"don't bother to remove the comment"</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'namespace comment'</body></methods><methods><class-id>Store.NameSpaceCommentTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^9</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="addedPropertyRow:">addedPropertyRow: aPropertyBlueprint	^(SinglePropertyView new)		property: aPropertyBlueprint;		isAddition: true;		populate</body><body package="Store-Code Comparison" selector="changedPropertyRowFrom:to:">changedPropertyRowFrom: anOriginalPropertyBlueprint to: aChangedPropertyBlueprint	^PropertyComparisonView new leftProperty: anOriginalPropertyBlueprint		rightProperty: aChangedPropertyBlueprint</body><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	^self propertyRows</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| headerRow label |	super populateHeader.	self codeComponentName ifNil: [^self].	headerRow := self header.	label := Label with: self codeComponentName asText allBold.	headerRow		add: (self isBundle					ifTrue: [ComparisonIcons bundleProperties]					ifFalse: [ComparisonIcons packageProperties]);		add: label</body><body package="Store-Code Comparison" selector="propertyRows">propertyRows	| rows |	rows := OrderedCollection new.	self		enumerateOrderedPropertyAdditions: [:addedProperty | rows add: (self addedPropertyRow: addedProperty)]		removals: [:removedProperty | rows add: (self removedPropertyRow: removedProperty)]		changes: [:removedProperty :addedProperty | rows add: (self changedPropertyRowFrom: removedProperty to: addedProperty)].	^rows</body><body package="Store-Code Comparison" selector="removedPropertyRow:">removedPropertyRow: aPropertyBlueprint	^(SinglePropertyView new)		property: aPropertyBlueprint;		isAddition: false;		populate</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>private</category><body package="Store-Code Comparison" selector="enumerateOrderedPropertyAdditions:removals:changes:">enumerateOrderedPropertyAdditions: additionBlock removals: removalBlock changes: changeBlock	| additionStack removalStack |	additionStack := OrderedCollection withAll: rightProperties.	removalStack := OrderedCollection withAll: leftProperties.	[additionStack isEmpty and: [removalStack isEmpty]] whileFalse: 			[additionStack isEmpty				ifTrue: [removalBlock value: removalStack removeFirst]				ifFalse: 					[removalStack isEmpty						ifTrue: [additionBlock value: additionStack removeFirst]						ifFalse: 							[(additionStack first key = removalStack first key)								ifTrue: [changeBlock value: removalStack removeFirst value: additionStack removeFirst]								ifFalse: 									[additionStack first &lt;= removalStack first										ifTrue: [additionBlock value: additionStack removeFirst]										ifFalse: [removalBlock value: removalStack removeFirst]]]]]</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="codeComponentName">codeComponentName	^leftProperties isEmpty		ifTrue: 			[rightProperties isEmpty				ifTrue: [nil]				ifFalse: [rightProperties any codeComponentName]]		ifFalse: [leftProperties any codeComponentName]</body><body package="Store-Code Comparison" selector="isBundle">isBundle	^leftProperties isEmpty		ifTrue: 			[rightProperties isEmpty				ifTrue: [nil]				ifFalse: [rightProperties any isBundle]]		ifFalse: [leftProperties any isBundle]</body><body package="Store-Code Comparison" selector="leftProperties:">leftProperties: aSequenceOfPropertyBlueprints	leftProperties := aSequenceOfPropertyBlueprints.	self populate</body><body package="Store-Code Comparison" selector="rightProperties:">rightProperties: aSequenceOfPropetyBlueprints	rightProperties := aSequenceOfPropetyBlueprints.	self populate</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="initialize">initialize	super initialize.	rightProperties := leftProperties := Array new</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>displaying</category><body package="Store-Code Comparison" selector="drawDetailsBackroundOn:">drawDetailsBackroundOn: aGC	"not for me"</body><body package="Store-Code Comparison" selector="drawDetailsBorderOn:">drawDetailsBorderOn: aGC	"not for me"</body></methods><methods><class-id>Tools.CodeComponentPropertiesComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	| sampleProperty |	sampleProperty := leftProperties isEmpty				ifTrue: 					[rightProperties isEmpty ifTrue: [^nil] ifFalse: [rightProperties any]]				ifFalse: [leftProperties any].	^Array		with: #codeComponentProperties		with: sampleProperty codeComponentName		with: sampleProperty isBundle</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken 	^element relatedBy: relToken</body><body package="Store-UI-Graphs" selector="relatedBy:">relatedBy: relToken 	^related at: relToken		ifAbsent: 			[| bag relElems |			relElems := self elementRelatedBy: relToken.			bag := Set new.			relElems do: [:elem | bag add: (self class element: elem cache: cache)].			related at: relToken put: bag]</body><body package="Store-UI-Graphs" selector="stringKey:">stringKey: hints	^element stringKey: hints</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="element:cache:">element: anElement cache: aCache	element := anElement.	cache := aCache.	related := IdentityDictionary new.</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="element">element	^element</body><body package="Store-UI-Graphs" selector="itemString">itemString	^element itemString</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>printing</category><body package="Store-UI-Graphs" selector="printOn:">printOn: aStream	aStream nextPut: ${.	element printOn: aStream.	aStream nextPut: $}.	^self</body></methods><methods><class-id>Store.ElementProxy class</class-id> <category>instance creation</category><body package="Store-UI-Graphs" selector="element:cache:">element: anElement cache: aCache 	^aCache at: anElement ifAbsent: [aCache at: anElement put: (self new element: anElement cache: aCache)]</body></methods><methods><class-id>Store.GroupElement</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken		relToken == #tt_containsRel ifTrue: 		[^StoreUserGroup userNamesInGroupNamed: element].	relToken == #tt_containsRRel ifTrue: 		[^StoreUserGroup groupNamesForUserNamed: element].	^super relatedBy: relToken</body><body package="Store-UI-Graphs" selector="stringKey:">stringKey: hints	^element</body></methods><methods><class-id>Store.GroupElement</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="itemString">itemString	^element</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management" selector="addAlternative:">addAlternative: aDefinition	alternatives add: aDefinition</body><body package="Store-Merge Management" selector="alternatives">alternatives	^alternatives</body><body package="Store-Merge Management" selector="applied">applied	^applied</body><body package="Store-Merge Management" selector="applied:">applied: anObject	applied := anObject</body><body package="Store-Merge Management" selector="base">base	^base</body><body package="Store-Merge Management" selector="base:">base: anObject	base := anObject</body><body package="Store-Merge Management" selector="containingPackageModel">containingPackageModel	| resolution |	resolution := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	^resolution key storeModel</body><body package="Store-Merge Management" selector="original">original	^original</body><body package="Store-Merge Management" selector="original:">original: anObject	original := anObject</body><body package="Store-Merge Management" selector="ownerName">ownerName	^ownerName</body><body package="Store-Merge Management" selector="ownerName:">ownerName: aString	ownerName := aString</body><body package="Store-Merge Management" selector="proposed">proposed	^proposed</body><body package="Store-Merge Management" selector="proposed:">proposed: anObject	proposed := anObject</body><body package="Store-Merge Management" selector="proposedResolutions">proposedResolutions	^Array with: self</body><body package="Store-Merge Management" selector="resolutions">resolutions	^Array with: self</body><body package="Store-Merge Management" selector="sortedListResolutionValues:">sortedListResolutionValues: aSymbol	(aSymbol = #unresolved and: [self isResolved]) ifTrue: [^#()].	(aSymbol = #conflicts and: [self hasNoConflicts]) ifTrue: [^#()].	^Array with: self</body><body package="Store-Merge Management" selector="sortedTreeResolutionValues:">sortedTreeResolutionValues: aSymbol	^#()</body><body package="Store-Merge Management" selector="standardResolutionAlternative">standardResolutionAlternative		^alternatives detect: [:each | each isStandardResolution] ifNone: [nil]</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^true</body><body package="Store-Merge Management" selector="displaysProtocolStatus">displaysProtocolStatus	^false</body><body package="Store-Merge Management" selector="hasBeenApplied">hasBeenApplied	^applied</body><body package="Store-Merge Management" selector="hasNoConflicts">hasNoConflicts	^alternatives size &lt; 3</body><body package="Store-Merge Management" selector="hasPotentialOverride">hasPotentialOverride		applied ifTrue: [^false].	self existingOverrides notEmpty ifTrue: [^true].	^self potentialOverride 		ifNil: [false]		ifNotNil:			[:value |			(proposed isNil or: [proposed isDoNothingResolution])				ifTrue: [false]				ifFalse: 					[proposed 						ifNil: [false]						ifNotNil: [value name ~= (proposed key ifNotNil: [:package | package name])]]]</body><body package="Store-Merge Management" selector="isAbsentResolution">isAbsentResolution	^false</body><body package="Store-Merge Management" selector="isApplyable">isApplyable	^applyable</body><body package="Store-Merge Management" selector="isBundleStructureResolver">isBundleStructureResolver	^false</body><body package="Store-Merge Management" selector="isClassDefintionResolver">isClassDefintionResolver	^false</body><body package="Store-Merge Management" selector="isCommentResolver">isCommentResolver	^false</body><body package="Store-Merge Management" selector="isDefintionResolver">isDefintionResolver	^false</body><body package="Store-Merge Management" selector="isMethodResolver">isMethodResolver	^false</body><body package="Store-Merge Management" selector="isMove">isMove	^false</body><body package="Store-Merge Management" selector="isNameSpaceDefinitionResolver">isNameSpaceDefinitionResolver	^false</body><body package="Store-Merge Management" selector="isNoOp">isNoOp	^self isNoResolve or: [self proposed notNil and: [self proposed isNoOpResolution]]</body><body package="Store-Merge Management" selector="isNoResolve">isNoResolve	^self proposed notNil and: [self proposed isAbsentResolution]</body><body package="Store-Merge Management" selector="isPropertyResolver">isPropertyResolver	^false</body><body package="Store-Merge Management" selector="isProposedForRemoval">isProposedForRemoval	^proposed isRemovalResolution</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	self subclassResponsibility</body><body package="Store-Merge Management" selector="isResolved">isResolved	^self proposed notNil</body><body package="Store-Merge Management" selector="isResolver">isResolver	^true</body><body package="Store-Merge Management" selector="isSharedResolver">isSharedResolver	^false</body><body package="Store-Merge Management" selector="sameDefinitionAs:">sameDefinitionAs: anObject	"If we get here, it can not be the same, because the resolver is not comparable to the image"	^false</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="className">className	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^#Unknown &lt;&lt; #store &gt;&gt; 'Unknown'].	^alternative value className</body><body package="Store-Merge Management" selector="createModificationDisplayRecords">createModificationDisplayRecords	| list collector |	list := List new.	collector := Set new.	self collectResolutionsInto: collector.	list addAll: (collector asSortedCollection: [:each :other | each sortKey &lt; other sortKey]).	^list</body><body package="Store-Merge Management" selector="owningEnvironment">owningEnvironment	"When parsing classes, the owningEnvironment is the nil class"	^nil class</body><body package="Store-Merge Management" selector="parseDefinition:in:">parseDefinition: aString in: anEnvironment		^[Compiler new 		parseWithSignalling: aString asString 		in: anEnvironment 		noPattern: self usePatternWhenParsing 		notifying: (SignallingCompilerErrorHandler handler: SilentCompilerErrorHandler new)]			on: CompilerError			do: 				[:exception |				exception return: (self raiseNoticeFor: exception)].</body><body package="Store-Merge Management" selector="parseText:">parseText: aString		| nodeHolder |	self owningEnvironment ifNil: [^self unavailableOwnerNotice].	nodeHolder := self parseDefinition: aString in: self owningEnvironment.	(nodeHolder isKindOf: Boolean) ifTrue: [^nodeHolder].	nodeHolder ifNotNil: [nodeHolder := self validateParse: nodeHolder].	^nodeHolder notNil</body><body package="Store-Merge Management" selector="raiseNoticeFor:">raiseNoticeFor: aCompilerError	aCompilerError type = #syntax ifTrue: 		[Dialog warn: #SyntaxError &lt;&lt; #dialogs &gt;&gt; 'Syntax Error'.		^nil].	^Dialog confirm: (#UnableToValidateChange &lt;&lt; #store &gt;&gt; 'Unable To Validate Change&lt;n&gt;Accept Change?') expandMacros</body><body package="Store-Merge Management" selector="unavailableOwnerNotice">unavailableOwnerNotice	Dialog warn: ((#TheClass1sMustAndApplyResolved &lt;&lt; #store &gt;&gt; 'The class "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept edited code.&lt;n&gt;Resolve conflicts in the class definition, if any,&lt;n&gt;and "Apply Resolved".') expandMacrosWith: self className).	^false</body><body package="Store-Merge Management" selector="usePatternWhenParsing">usePatternWhenParsing		^true</body><body package="Store-Merge Management" selector="validateParse:">validateParse: aNodeHolder	"Answer nil if there is a problem, otherwise, answer the NodeHolder"	self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="absentFromPackageString">absentFromPackageString		^(#AbsentFromThisPackage &lt;&lt; #store &gt;&gt; '*** Absent from this package ***') asString</body><body package="Store-Merge Management" selector="applyableString">applyableString	^self isApplyable not		ifTrue: [(#SpaceParenInformationalColonNotResolvableParen &lt;&lt; #store &gt;&gt; ' (Informational: Not Resolvable)') asString]		ifFalse: ['']</body><body package="Store-Merge Management" selector="baseDefinitionText">baseDefinitionText	base ifNil: [^nil].	^self definitionTextFor: base</body><body package="Store-Merge Management" selector="baseLabel">baseLabel	^base ifNotNil: [base key displayString]</body><body package="Store-Merge Management" selector="browseVersions">browseVersions	self subclassResponsibility</body><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value definitionString</body><body package="Store-Merge Management" selector="definitionTextFrom:">definitionTextFrom: aResolutionPackageItem	(self alternatives 		detect: [:each | each = aResolutionPackageItem alternative]		ifNone: [nil]) ifNotNil: [:value | ^self definitionTextFor: value].	^self absentFromPackageString.</body><body package="Store-Merge Management" selector="explanationText">explanationText		| stream description |	stream := WriteStream on: String new.	description := self mergeDisplayName.	description first = $[ ifFalse: [stream nextPut: $[].	stream nextPutAll: description.	description first = $[ ifFalse: [stream nextPut: $]].	applyable		ifTrue:			[stream nextPutAll: (#Has1qNotHadAResolutionSelected &lt;&lt; #store &gt;&gt; ' has &lt;1?:not &gt;had a resolution selected.' expandMacrosWith: self isResolved)]		ifFalse: [stream nextPutAll: self unapplyableString].	^stream contents</body><body package="Store-Merge Management" selector="imageLabel">imageLabel	^original ifNotNil: [original key displayString]</body><body package="Store-Merge Management" selector="labelInView:nameStyle:">labelInView: aView nameStyle: aSymbol 	^(LabelAndIcon with: (self perform: aSymbol) attributes: aView textStyle) 		icon: (VisualRow withAll: (Array with: self resolutionIcon with: self typeIcon with: self listIcon))</body><body package="Store-Merge Management" selector="listIcon">listIcon	^Behavior toolListIcon</body><body package="Store-Merge Management" selector="longListName">longListName	| string |	string := self longTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="longTreeName">longTreeName	| string |	string := self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName		^self class name</body><body package="Store-Merge Management" selector="moveFromPackage:">moveFromPackage: aString	^(#starsThisDefinitionIsBeingMovedFromPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition is being moved from package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management" selector="moveToPackage:">moveToPackage: aString	^(#starsThisDefinitionIsBeingMovedToPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition is being moved to package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management" selector="movedFromPackage:">movedFromPackage: aString	^(#starsThisDefinitionIsMovedFromPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition was moved from package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management" selector="movedToPackage:">movedToPackage: aString	^(#starsThisDefinitionIsWasMovedToPacakge1sstars &lt;&lt; #store &gt;&gt; '*** This definition was moved to package "&lt;1s&gt;" ***') expandMacrosWith: aString</body><body package="Store-Merge Management" selector="originalDefinitionText">originalDefinitionText	original ifNil: [^nil].	^self definitionTextFor: original</body><body package="Store-Merge Management" selector="overrideEmpahsis">overrideEmpahsis		^Array with: #bold with: #color -&gt; ColorValue orange</body><body package="Store-Merge Management" selector="proposedDefinitionText">proposedDefinitionText	proposed ifNil: [^nil].	^self definitionTextFor: proposed</body><body package="Store-Merge Management" selector="removeFromImageString">removeFromImageString		^(#RemoveFromImage &lt;&lt; #store &gt;&gt; '*** Remove from image ***') asString</body><body package="Store-Merge Management" selector="resolutionIcon">resolutionIcon	^self isResolved		ifFalse: [self class unresolvedImage]		ifTrue: 			[self hasBeenApplied				ifTrue: 					[(self isApplyable and: [self isNoOp not])						ifTrue: [self class appliedImage]						ifFalse: [self class unappliedImage]]				ifFalse: 					[self isApplyable 						ifTrue: [self class resolvedImage]						ifFalse: [self class unapplyableImage]]].</body><body package="Store-Merge Management" selector="resolutionLabel">resolutionLabel	^proposed ifNotNil: [proposed key displayString]</body><body package="Store-Merge Management" selector="shortListName">shortListName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management" selector="typeIcon">typeIcon	applyable ifFalse: [^GeneralIcons padlock].	(proposed notNil and: [proposed isNoOpResolution]) ifTrue: [^MergeIcons doNotResolve].	(base isNil and: [original isNil and: [proposed notNil and: [proposed isAbsentResolution]]]) ifTrue: [^GeneralIcons warning].	self isMove ifTrue: 		[^self isProposedForRemoval			ifTrue: [self class moveOutImage]			ifFalse: [self class moveImage]].	(base isNil and: [original isNil or: [proposed value = original value]]) ifTrue: [^MergeIcons add].	(proposed notNil and: [proposed isRemovalResolution]) ifTrue: [^MergeIcons remove].	^MergeIcons modify</body><body package="Store-Merge Management" selector="unapplyableString">unapplyableString		^(#IsForInformationOnlyGeneral &lt;&lt; #store &gt;&gt; ' is for information purposes only, and is not resolvable.') asString</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	self subclassResponsibility</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	self subclassResponsibility</body><body package="Store-Merge Management" selector="doNotResolve">doNotResolve	| possibleNoOp |	possibleNoOp := alternatives detect: [:each | each isNoOpResolution] ifNone: [nil].	proposed := proposed isNil		ifTrue: [possibleNoOp ifNil: [NoOpResolution new]]		ifFalse: [proposed isNoOpResolution ifTrue: [proposed] ifFalse: [possibleNoOp ifNil: [NoOpResolution new]]].	alternatives detect: [:each | each isNoOpResolution] ifNone: [self addAlternative: proposed].</body><body package="Store-Merge Management" selector="existingOverrides">existingOverrides	^#()</body><body package="Store-Merge Management" selector="makeProposalForAbsentInImageAndAllRemovals">makeProposalForAbsentInImageAndAllRemovals		| alternativesWithoutBaseOrOriginal |	applied ifTrue: [^self].	alternativesWithoutBaseOrOriginal := alternatives select: [:each | each ~= original and: [each ~= base]].	(applied not and: 		[self original isNil and: 		[alternativesWithoutBaseOrOriginal allSatisfy: [:each | each isRemovalResolution]]])			ifTrue: [applied := true]</body><body package="Store-Merge Management" selector="makeResolutionProposals">makeResolutionProposals	"It is possible to get 0 alternatives, we'll just empty those out later"		| alternativesWithoutBase alternativesWithoutImage alternativeSameAsImage |	proposed ifNotNil: [^self].	alternativesWithoutBase := self alternatives reject: [:each | each = self base].	alternativesWithoutBase size = 1 ifTrue: [proposed := alternativesWithoutBase any].	proposed ifNotNil: [proposed key isImageObject ifTrue: [original := proposed]].	original notNil ifTrue:		[alternativesWithoutImage := alternativesWithoutBase reject: [:each | each = original].		alternativeSameAsImage := alternativesWithoutImage 			detect: [:each | each package name = original package name and: [(self definitionTextFor: each) = (self definitionTextFor: original) and: [(self protocolStringFor: each) = (self protocolStringFor: original)]]] 			ifNone: [nil].		alternativeSameAsImage notNil ifTrue:			[proposed := alternativeSameAsImage.			applied := true]].	(proposed notNil and: 		[original notNil and: 		[proposed isRemovalResolution not and: 		[proposed key = original key]]]) 			ifTrue: [applied := true].	(proposed notNil and: 		[original isNil and: 		[base notNil and: 		[base isStandardResolution and: 		[proposed isRemovalResolution and: 		[base sameAsImageUsing: self]]]]])		 ifTrue: [original := base].	self makeProposalForAbsentInImageAndAllRemovals</body><body package="Store-Merge Management" selector="markApplied">markApplied	applied := true</body><body package="Store-Merge Management" selector="markUnapplyable">markUnapplyable	applyable := false.	proposed := NoOpResolution new.	applied := false</body><body package="Store-Merge Management" selector="potentialOverride">potentialOverride	^nil</body><body package="Store-Merge Management" selector="protocolStringFor:">protocolStringFor: aResolution	^nil</body><body package="Store-Merge Management" selector="resolution:">resolution: aResolutionPackageItemOrNil	applied := false.	aResolutionPackageItemOrNil ifNil: [^proposed := nil].	(aResolutionPackageItemOrNil isAbsentResolution and: [aResolutionPackageItemOrNil alternative isNil]) ifTrue: 		[^original isNil			ifTrue: 				[proposed := AbsentResolution new.				aResolutionPackageItemOrNil proposed: true]			ifFalse: 				[proposed := alternatives detect: [:each | each isAbsentResolution] ifNone: [^self]]].	aResolutionPackageItemOrNil isForGeneralResolution		ifTrue: [proposed := alternatives detect: [:each | each package = aResolutionPackageItemOrNil package] ifNone: [^self]]		ifFalse: [proposed := alternatives detect: [:each | each = aResolutionPackageItemOrNil alternative] ifNone: [^self]].</body><body package="Store-Merge Management" selector="unApply">unApply	applied := false</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	alternatives := OrderedSet new.	applied := false.	applyable := true</body></methods><methods><class-id>Store.Glorp.ChangeResolver</class-id> <category>visiting</category><body package="Store-Merge Management" selector="collectResolutionsInto:">collectResolutionsInto: aSet	| item resolution |	(base isNil and: [original isNil])		ifTrue: 			[item := ResolutionPackageItem forAbsentBaseAndImage.			item proposed: (proposed notNil and: [proposed isAbsentResolution]).			"item alternative: proposed."			(item proposed and: [applied]) ifTrue: [item applied: true].			aSet add: item]		ifFalse: 			[(alternatives anySatisfy: #isRemovalResolution) ifFalse: 				[base ifNil: 					[resolution := ResolutionPackageItem forAbsentBase.					(proposed notNil and: [proposed isAbsentResolution or: [proposed isRemovalResolution]]) ifTrue: [resolution proposed: true].					aSet add: resolution].				original ifNil: [aSet add: ResolutionPackageItem forAbsentImage]]].	aSet addAll: (alternatives collect: [:each | ResolutionPackageItem on: each in: self]).	(aSet allSatisfy: [:each | each image not]) ifTrue: 		[(aSet detect: #base ifNone: [nil])			ifNil: [aSet add: ResolutionPackageItem forAbsentImage]			ifNotNil: [:value | value image: true]]</body><body package="Store-Merge Management" selector="execute:ifTrueAddTo:">execute: aBlock ifTrueAddTo: anOrderedCollection	(aBlock value: self) ifTrue: [anOrderedCollection add: self]</body></methods><methods><class-id>Store.Glorp.ChangeResolver class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.ChangeResolver class</class-id> <category>resources</category><body package="Store-Merge Management" selector="appliedImage">appliedImage	^MergeIcons applied</body><body package="Store-Merge Management" selector="doNotResolveImage">doNotResolveImage	^MergeIcons doNotResolve</body><body package="Store-Merge Management" selector="moveImage">moveImage	^MergeIcons move</body><body package="Store-Merge Management" selector="moveOutImage">moveOutImage	MoveOutIcon ifNil: [#{ChangeResolver.MoveOutIcon} initialize].	^MoveOutIcon</body><body package="Store-Merge Management" selector="resolvedImage">resolvedImage	^MergeIcons resolved</body><body package="Store-Merge Management" selector="unappliedImage">unappliedImage	^MergeIcons unapplied</body><body package="Store-Merge Management" selector="unapplyableImage">unapplyableImage	^MergeIcons unapplyable</body><body package="Store-Merge Management" selector="unresolvedImage">unresolvedImage	^MergeIcons unresolved</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="isClassDefintionResolver">isClassDefintionResolver	^true</body><body package="Store-Merge Management" selector="isDefintionResolver">isDefintionResolver	^true</body><body package="Store-Merge Management" selector="isMove">isMove	^movePair notNil</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	| reference |	proposed ifNil: [^false].	proposed isRemovalResolution ifFalse: [^false].	(reference := (self environmentString asString, '.' , self definitionName) asQualifiedReference) ifNil: [^true].	reference valueOrDo: [^true].	^((Registry containingPackageForClass: reference value) name = proposed package name) not</body><body package="Store-Merge Management" selector="sameDefinitionAs:">sameDefinitionAs: aString	| reference |	(reference := self ownerName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value definitionString = aString</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	| result |	applyable ifFalse: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isAbsentResolution ifTrue: [^true].	proposed isNoOpResolution ifTrue: [^true].	self hasOverrideAndShouldApply ifFalse: [^false].	Policies packagePolicy 		forcePackage: proposed key storeModel		while: 			[result := [[[Compiler evaluate: proposed value logged: true]				on: RedefinitionNotification				do: 					[:notification | 					notification currentPackage name = proposed key storeModel name ifFalse: [notification override install].					notification resume]]						on: ClassConstructionError						do: [:exception | exception resume: true]]							on: Error							do:								[:exception | 								Transcript show: (#nApplyingClassChangeFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Class Change Failed &lt;2s&gt; : &lt;1s&gt;' 									expandMacrosWith: exception messageText									with: self definitionName).								exception return: nil]].	^result notNil</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	| reference result |	(reference := (self environmentString asString, '.' , self definitionName) asQualifiedReference) ifNil: [^true].	result := [Override				unloadClassOrNameSpace: reference value				from: proposed package storeModel]		on: Error		do: 			[:exception | 			Transcript show: (#nApplyingClassChangeFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Class Change Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self definitionName).			exception return: #failed].	^result ~= #failed</body><body package="Store-Merge Management" selector="definitionName">definitionName	| methodNodeHolder target |	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	target isAbsentResolution ifTrue: [^''].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first arguments first value asString</body><body package="Store-Merge Management" selector="environmentString">environmentString	| methodNodeHolder target |	proposed isAbsentResolution ifTrue: [^'Root'].	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^'Root'].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first receiver name asString</body><body package="Store-Merge Management" selector="existingOverrides">existingOverrides	^(Override overridesForClassOrNameSpace: (self longOwnerName asStrictReference valueOrDo: [^#()])) ifNil: [^#()]</body><body package="Store-Merge Management" selector="hasOverrideAndShouldApply">hasOverrideAndShouldApply		self potentialOverride ifNotNil:		[:value | 		value name = proposed key name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed key name) ifFalse: 				[Transcript show: (#nDidNotApplyOverrideClass1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of Class &lt;1s&gt; in &lt;2s&gt;' 					expandMacrosWith: self longOwnerName					with: proposed key name).				^false]]].	^true</body><body package="Store-Merge Management" selector="ownerNameForLoadOrdering">ownerNameForLoadOrdering	| methodNodeHolder target |	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	target isAbsentResolution ifTrue: [^''].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^(methodNodeHolder node block body statements first arguments at: 2) value asString</body><body package="Store-Merge Management" selector="potentialOverride">potentialOverride		^Store.Registry containingPackageForClassNamed: self longOwnerName</body><body package="Store-Merge Management" selector="proceedWithPossibleOverrideFrom:to:">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingChange1sIn2nsOveride3snn &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;Class "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longOwnerName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="raiseNoticeFor:">raiseNoticeFor: aCompilerError	aCompilerError type = #undeclared ifTrue: 		[Dialog warn: (#UnknownVariableSpaceColonSpace1s &lt;&lt; #dialogs &gt;&gt; 'Unknown Variable : &lt;1s&gt;' expandMacrosWith: aCompilerError parameter key).		^nil].	^super raiseNoticeFor: aCompilerError</body><body package="Store-Merge Management" selector="validateParse:">validateParse: aNodeHolder	"We make sure of the following:		1) The superclass hasn't changed		2) The ClassName hasn't changed		3) Someone defines the define method"		| selector methodCollector filter receiver alternative oldNode superclass mainStatementNode oldStatementNode value |	mainStatementNode := aNodeHolder node block body statements first.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	oldNode := self parseDefinition: alternative value in: self owningEnvironment.	oldStatementNode := oldNode node block body statements first.	receiver := mainStatementNode receiver name.	oldStatementNode receiver name = receiver ifFalse:		[Dialog warn: #NamespaceMustNotChange &lt;&lt; #store &gt;&gt; 'NameSpace must not change'.		^nil].	selector := mainStatementNode selector.	methodCollector := MethodCollector new.	filter := methodCollector implementorsOf: selector.	(methodCollector select: filter) isEmpty ifTrue:		[Dialog warn: #BadDefinitionMessage &lt;&lt; #store &gt;&gt; 'Bad Definition Message'.		^nil].	oldStatementNode selector = selector ifFalse:		[Dialog warn: #DefinitionMessageMustNotChange &lt;&lt; #store &gt;&gt; 'Definition message must not change'.		^nil].	('defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:*' match: selector asString) ifTrue: 		[((mainStatementNode arguments at: 3) value isSymbol) ifFalse:			[Dialog warn: #ParameterForIndexedTypeMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #indexedType: must be a Symbol'.			^nil].		superclass := (mainStatementNode arguments at: 2) value asString.		(oldStatementNode arguments at: 2) value asString = superclass ifFalse:			[Dialog warn: #SuperclassMustNotChange &lt;&lt; #store &gt;&gt; 'Superclass must not change'.			^nil].		((mainStatementNode arguments at: 4) value isKindOf: Boolean) ifFalse:			[Dialog warn: #ParameterForPrivateMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #private: must be a Boolean'.			^nil].		((value := (mainStatementNode arguments at: 7) value) isString and: [value isSymbol not]) ifFalse:			[Dialog warn: #ParameterForImportsMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #imports: must be a String'.			^nil].		((value := (mainStatementNode arguments at: 8) value) isString and: [value isSymbol not]) ifFalse:			[Dialog warn: #ParameterForCategoryMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #category: must be a String'.			^nil]].	^aNodeHolder</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="browseVersions">browseVersions	| list session |	(Gathering for: self definitionName) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value key session].	list := Store.Glorp.StoreClassDefinitionInPackage				allVersionsWithName: self definitionName				in: session.	(Gathering for: self definitionName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self definitionName)].	Store.Glorp.DefinitionForListTool forClasses: list</body><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[movePair notNil ifTrue: 			[^applied 				ifTrue: [self movedToPackageString]				ifFalse: [self moveToPackageString]].		^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management" selector="longListName">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="longOwnerName">longOwnerName	| name |	name := self ownerName.	(name includes: $.) ifTrue: 		[^('Root.*' match: name)			ifTrue: [name]			ifFalse: ['Root.', name]].	^'Root.Smalltalk.' , name</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName		^(#BracketClassDefinition &lt;&lt; #store &gt;&gt; '[Class Definition]') asString</body><body package="Store-Merge Management" selector="moveFromPackageString">moveFromPackageString	^self moveFromPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="moveToPackageString">moveToPackageString	^self moveToPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="movedFromPackageString">movedFromPackageString	^self movedFromPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="movedToPackageString">movedToPackageString	^self movedToPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="shortListName">shortListName	| string |	string := self ownerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.Glorp.ClassChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management" selector="movePair">movePair	^movePair</body><body package="Store-Merge Management" selector="movePair:">movePair: aClassChangeResolver	movePair := aClassChangeResolver</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="differenceName">differenceName	^self selectorListName</body><body package="Store-Difference Management" selector="firstTextFragments">firstTextFragments	^self mainDefinition asText wordAndWhitespaceFragments</body><body package="Store-Difference Management" selector="mainDefinition">mainDefinition	^mainObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management" selector="mainPackage:comment:">mainPackage: aPackage comment: aString	self mainPackage: aPackage object: aString</body><body package="Store-Difference Management" selector="mainProtocol">mainProtocol	^''</body><body package="Store-Difference Management" selector="otherDefinition">otherDefinition	^otherObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management" selector="otherPackage:comment:">otherPackage: aPackage comment: aString	self otherPackage: aPackage object: aString</body><body package="Store-Difference Management" selector="otherProtocol">otherProtocol	^''</body><body package="Store-Difference Management" selector="resolutionClass">resolutionClass	^ClassCommentChangeResolver</body><body package="Store-Difference Management" selector="secondTextFragments">secondTextFragments	^self otherDefinition asText wordAndWhitespaceFragments</body><body package="Store-Difference Management" selector="selectorListIcon">selectorListIcon	^GeneralIcons gear</body><body package="Store-Difference Management" selector="selectorListName">selectorListName	^(#BracketClassCommentBracket &lt;&lt; #store &gt;&gt; '[Class Comment]') asString</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>loading</category><body package="Store-Difference Management" selector="loadMainDefinitionFrom:">loadMainDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageClass comment: self mainObject</body><body package="Store-Difference Management" selector="loadOtherDefinitionFrom:">loadOtherDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageClass comment: self otherObject</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream comment: commentObject value: mainObject</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream comment: commentObject value: otherObject</body></methods><methods><class-id>Store.PseudoClassCommentDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="isMeta">isMeta	^true</body><body package="Store-Difference Management" selector="isMethod">isMethod	^true</body><body package="Store-Difference Management" selector="isNotMeta">isNotMeta	^self isMeta</body><body package="Store-Difference Management" selector="isStandin">isStandin	^true</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>actions</category><body package="Store-UI" selector="compareSelectionWith">compareSelectionWith	| method target |	method := self itemsInList selections first.	target := StoreMethodInPackage 		selectStoreVersionOf: method name 		inClass: method classNameWithMeta 		in: method package session.	target ifNotNil: [MethodDifferenceBrowser 		compare: method definitionString 		with: target definitionString 		protocol: method protocol 		with: target protocol]</body><body package="Store-UI" selector="compareVersions">compareVersions	| method target |	method := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	MethodDifferenceBrowser compare: method definitionString with: target definitionString protocol: method protocol with: target protocol</body><body package="Store-UI" selector="compareWithImage">compareWithImage	| method target |	method := self itemsInList selections first.	target := method definition correspondingImageMethod.	target ifNotNil: [MethodDifferenceBrowser 		compare: method definitionString 		with: target getSource asString 		protocol: method protocol 		with: target protocol]</body><body package="Store-UI" selector="containingPackages">containingPackages	| method packages |	method := self itemsInList selections first.	[(Gathering for: method name) started.	packages := StoreMethodInPackage allPackagesContaining: method.	(Gathering for: method name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: method signature</body><body package="Store-UI" selector="fileOut">fileOut	| method fileName fileManager |	method := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (method longNameFromSmalltalk, '-', method name replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: method package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			method fileOutOn: fileManager]				ensure: [fileManager close].			(FilingOut for: method package) finished].</body><body package="Store-UI" selector="loadMethod">loadMethod		| package method |	method := self itemsInList selections first.	package := method package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: (package storeModel  ifNil: [Registry packageNamed: package name])				while: 					[method loadSource].			(Loading for: package) finished].</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText nextPutAllText: (each definitionString asText makeSelectorBoldIn: each classOrNameSpace).				updateText cr.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body><body package="Store-UI" selector="setUpForRemovedMethodsIn:">setUpForRemovedMethodsIn: aClass	| methodNames list className skip session |		[((methodNames := Store.Glorp.StoreMethod				chooseAvailableMethodMatching: '*'				notIn: aClass) == nil		or: [methodNames isEmpty]) ifTrue: [^nil].	list := List new: methodNames size * 2.	className := aClass absoluteName.	skip := 100.	session := StoreLoginFactory currentStoreSession.	(Gathering for: aClass) started.	1 to: methodNames size		by: skip		do: 			[:index |			| subList |			subList := methodNames copyFrom: index						to: index + (methodNames size - index + 1 min: skip) - 1.			list addAll: (StoreMethodInPackage						allVersionsWithNameIn: subList						inClass: className						in: session)].	list := list asSortedCollection: 					[:each :other |					each name &lt; other name or: 							[each name = other name								and: [each definition timestamp &gt; other definition timestamp]]].	(Gathering for: aClass) finished]			withStoreFeedbackOn: self mainWindow.	self itemsInList list: list asList</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>accessing</category><body package="Store-UI" selector="fillInFor:">fillInFor: aMethod	| methodsInPackage finalMethodsInPackage |	(Gathering for: aMethod name) started.	methodsInPackage := (StoreMethodInPackage		allVersionsWithName: aMethod name		inClass: aMethod classNameWithMeta		in: (aMethod package ifNotNil: [:value | value session])) asList.	finalMethodsInPackage := methodsInPackage reject: [:each | each package isNil].	finalMethodsInPackage size ~= methodsInPackage size		ifTrue: [self reportUnpackagedDefinitionNamed: '#', aMethod name].	self fillListWith: finalMethodsInPackage.	(Gathering for: aMethod name) finished.</body><body package="Store-UI" selector="listTitle">listTitle	self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title.</body><body package="Store-UI" selector="title">title	^title ifNil: [(#VersionsOfMethod1s &lt;&lt; #store &gt;&gt; 'Versions of method &lt;1s&gt;' expandMacrosWith: self itemsInList list first signature)]</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>menu</category><body package="Store-UI" selector="existsInImage">existsInImage	| method |	^self onlyOneItemSelected and: 		[method := self itemsInList selections first.		method definition correspondingImageMethod notNil]</body><body package="Store-UI" selector="oneItemAndInImage">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection definition correspondingImageClass notNil]</body><body package="Store-UI" selector="onlyOneItemSelected">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI" selector="onlyTwoItemsSelected">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.MethodListPane</class-id> <category>interface opening</category><body package="Store-UI" selector="compositeViewUsing:nameSize:protocolSize:longestTimestamp:longestUsername:in:selected:">compositeViewUsing: aMethod nameSize: longestName protocolSize: longestProtocol longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView selected: aBoolean	|  currentStart nameLabel timestampLabel mainThing protocolLabel emphasis usernameLabel packageNameLabel |	currentStart := 4.	nameLabel := Label with: aMethod selector asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	emphasis := aBoolean 		ifTrue: [#bold]		ifFalse: [Array with: #bold with: #color -&gt; ColorValue darkGreen].	protocolLabel := Label with: (('"', aMethod protocol , '"') asText emphasizeAllWith: emphasis) attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestProtocol + 8.	timestampLabel := Label with: aMethod definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aMethod definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: (aMethod package name, ' ') asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing		add: nameLabel;		add: protocolLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestProtocol longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestProtocol := longestTimestamp := longestUsername := 0.	items do:		[:each | 		longestName := (Label with: each selector asText allBold attributes: widget textStyle) width max: longestName.		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestProtocol := (Label with: (each protocol , '""') asText allBold attributes: widget textStyle) width max: longestProtocol].	widget visualBlock:		[:view :index | 		| compositeView |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestName			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: false.		BoundedWrapper on: compositeView].	widget selectedVisualBlock:		[:view :index | 		| compositeView wrapper |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestName			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: true.		wrapper := ReversingWrapper on: compositeView.		wrapper reverse setValue: true.		BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.Glorp.MethodVersionsListPane</class-id> <category>interface opening</category><body package="Store-UI" selector="compositeViewUsing:nameSize:protocolSize:longestTimestamp:longestUsername:in:selected:">compositeViewUsing: aMethod nameSize: longestPackage protocolSize: longestProtocol longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView selected: aBoolean	| currentStart timestampLabel mainThing protocolLabel emphasis usernameLabel packageNameLabel |	currentStart := 4.	timestampLabel := Label with: aMethod definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aMethod definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	emphasis := aBoolean 		ifTrue: [#bold]		ifFalse: [Array with: #bold with: #color -&gt; ColorValue darkGreen].	protocolLabel := Label with: (('"', aMethod protocol , '"') asText emphasizeAllWith: emphasis) attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestProtocol + 8.	packageNameLabel := Label with: (aMethod package name, ' ') asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: timestampLabel;		add: usernameLabel;		add: protocolLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestPackage longestProtocol longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestPackage := longestProtocol := longestTimestamp := longestUsername := 0.	items do:		[:each | 		longestPackage := (Label with: each package name asText allBold attributes: widget textStyle) width max: longestPackage.		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestProtocol := (Label with: (each protocol , '""') asText allBold attributes: widget textStyle) width max: longestProtocol].	widget visualBlock:		[:view :index | 		| compositeView |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestPackage			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: false.		BoundedWrapper on: compositeView].	widget selectedVisualBlock:		[:view :index | 		| compositeView wrapper |		compositeView := self			compositeViewUsing: (view sequence at: index)			nameSize: longestPackage			protocolSize: longestProtocol			longestTimestamp: longestTimestamp			longestUsername: longestUsername			in: view			selected: true.		wrapper := ReversingWrapper on: compositeView.		wrapper reverse setValue: true.		BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.MismatchedDatabaseError</class-id> <category>printing</category><body package="Store-Base" selector="defaultMessageText">defaultMessageText	| databasesString |	^parameter isNil 		ifTrue: 			[(#TheImageIsNotReconTheCurrentDatabase &lt;&lt; #store &gt;&gt; 'The image is not reconciled with the current database.') asString]		ifFalse: 			[databasesString := parameter allDatabases isEmpty				ifTrue: [(#noDatabase &lt;&lt; #store &gt;&gt; 'no database') asString]				ifFalse: [parameter allDatabases printString].			#_1sIsReconciledTo2sTheEntDatabaseIs3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is reconciled to (&lt;2s&gt;). The current database is &lt;3s&gt;.' 					expandMacrosWith: parameter name					with: databasesString					with: DbRegistry databaseIdentifier]</body></methods><methods><class-id>Store.Package</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="containedItems">containedItems	"Answer a collection of components."	^#()			"don't got none."</body><body package="Store-DB-Pundles" selector="hasExtensions">hasExtensions	"Answer true if the receiver extends a class/namespace not in the package."	| extended defined |	defined := self classes collect: [ :class | class absoluteName ].	extended := ( self methods collect: [:method | method className] ) asSet.	extended := extended reject: [:mName | mName includes: $ ].	defined addAll: ( self nameSpaces collect: [ :ns | ns absoluteName ] ).	extended addAll: ( self data collect: [ :elem | elem environmentString ] ).	defined do: [:each | extended remove: each ifAbsent: nil ].	^extended isEmpty not.</body><body package="Store-DB-Pundles" selector="includesDataKey:className:">includesDataKey: dataKey className: aClassName	data == nil ifTrue: [ ^false ].	^( self data detect: 		[:datum | datum className = aClassName 					and: [ datum dataKey = dataKey ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDataKey:nameSpaceName:">includesDataKey: dataKey nameSpaceName:  aName	data == nil ifTrue: [ ^false ].	^( self data detect: 		[:datum | datum dataKey = dataKey   					and: [ datum nameSpaceName = aName ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDataKey:owner:">includesDataKey: dataKey owner: aName	data == nil ifTrue: [ ^false ].	^( self data detect: 		[:datum | datum environmentString = aName 					and: [ datum dataKey = dataKey ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName	^( self data detect: 		[:datum | datum environmentString = aName 					and: [ datum dataKey = dataKey ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDatum:">includesDatum: aDataDescriptor	"Answer true if the receiver contains a definition of aDataDescriptor. 	Since this is for package comparisons, include overrides."	^self includesDataKey: aDataDescriptor dataKey ownerName: aDataDescriptor absoluteOwnerName</body><body package="Store-DB-Pundles" selector="includesMethod:">includesMethod: aMethodDescriptor	^self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor absoluteClassName asClassNameOnly		meta: aMethodDescriptor isMeta</body><body package="Store-DB-Pundles" selector="includesSelector:class:">includesSelector: aSelector class: aClass	^self 		includesSelector: aSelector 		className: aClass absoluteName asClassNameOnly 		meta: aClass isMeta</body><body package="Store-DB-Pundles" selector="includesSelector:className:meta:">includesSelector: aSelector className: aClassName meta: isMeta	^( self method: aSelector forClassNamed: aClassName meta: isMeta ) ~~ nil</body><body package="Store-DB-Pundles" selector="isDataEmpty">isDataEmpty	^self data size = 0</body><body package="Store-DB-Pundles" selector="isLeaf">isLeaf	^true</body><body package="Store-DB-Pundles" selector="isPackage">isPackage	^true</body><body package="Store-DB-Pundles" selector="isUpdating">isUpdating	^self properties at: #updating ifAbsent: [ false ].</body></methods><methods><class-id>Store.Package</class-id> <category>private-file out</category><body package="Store-DB-Pundles" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the image version of the receiver - creating, if neccessary."	^'( Store.Registry packageNamedOrCreate: ', self name printString, ' ) '.</body><body package="Store-DB-Pundles" selector="fileNameForBinVersion">fileNameForBinVersion	"Answer a file name for storing the binary version of the package.	Create a file name from the primary key and db identity."	^nil.			"For now""  	| fileName |	fileName := ConnectionTool connectionDefaults packageDir value.	fileName isEmpty ifTrue: [^nil].	fileName := fileName asFilename.	^fileName construct: self primaryKey printString."</body><body package="Store-DB-Pundles" selector="fileOutClassesOn:">fileOutClassesOn: aFileManager 	"New classes or classes with new definitions."	self classesWithSource	do: 		[ :each | each fileOutDifferencesBetween: nil on: aFileManager ].	aFileManager cr; cr</body><body package="Store-DB-Pundles" selector="fileOutDataKeys:in:on:">fileOutDataKeys: aCollection in: anOwner on: aFileManager 	"file out a collection of datakeys in anOwner. Order is not important."	| cname |	cname := anOwner absoluteName.	( aCollection collect: [ :key | self datum: key forOwnerNamed: cname ] ) 		do: [ :dd | dd fileOutOn: aFileManager ].	aFileManager cr; cr.</body><body package="Store-DB-Pundles" selector="fileOutDataOn:">fileOutDataOn: aFileManager 	self dataWithSource do:		[:dd |			dd fileOutOn: aFileManager.			aFileManager cr		].	self dataWithSource notEmpty ifTrue: [aFileManager cr]</body><body package="Store-DB-Pundles" selector="fileOutMethodsOn:">fileOutMethodsOn: aFileManager 	"File out the receiver's methods to aFileManager"	self fileOutMethods: self methodsWithSource on: aFileManager.</body><body package="Store-DB-Pundles" selector="fileOutNameSpacesOn:">fileOutNameSpacesOn: aFileManager 	"New namespaces or namespaces with new definitions."	( self nameSpacesWithSource )		"filed out in order"		do: [ :each | each fileOutDifferencesBetween: nil on: aFileManager ].	aFileManager cr; cr</body><body package="Store-DB-Pundles" selector="fileOutOn:">fileOutOn: aFileManager 	"When saving a Package to a aFileManager we need to ensure that there is a change to	create the package, this is why ComponentCreatedChange is used.  Also, to ensure	 that the aFileManager stores the package ownership information for any definitions	this package has. "	(ComponentCreatedChange new component: self) fileOutOn: aFileManager.	aFileManager sourceFormatter attributeFor: #package compute: [:obj | self name].	aFileManager sourceFormatter attributeForMethods: #package compute: [:cls :sel |self name].	aFileManager addComment: 'Package ' , self itemString.	self fileOutPropertiesOn: aFileManager.	self fileOutNameSpacesOn: aFileManager.	self fileOutClassesOn: aFileManager.	self fileOutDataOn: aFileManager.	self fileOutMethodsOn: aFileManager.	aFileManager cr.</body><body package="Store-DB-Pundles" selector="fileOutSelectors:in:on:">fileOutSelectors: aCollection in: aClass on: aFileManager 	"First group methods by protocol and the ask aFileManager to do the job."	| meths cname |	cname := aClass absoluteName.	meths := aCollection collect: [ :sel | self method: sel forClassNamed: cname meta: aClass isMeta ]. 	self fileOutMethods: meths on: aFileManager.</body></methods><methods><class-id>Store.Package</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="classIntersectionWith:">classIntersectionWith: aPackage	"Answer a collection of classes that are	common to the receiver and aPackage."	| other common |	other := aPackage classes collect: [:aClass| aClass primaryKey].	common := classes select: [:mineClass| other includes: mineClass primaryKey].	^common</body><body package="Store-DB-Pundles" selector="metaclassIntersectionWith:">metaclassIntersectionWith: aPackage	"Answer a collection of classes that are	common to the receiver and aPackage."	| other common |	other := aPackage metaclasses collect: [:aClass| aClass primaryKey].	common := metaclasses select: [:mineClass| other includes: mineClass primaryKey].	^common</body><body package="Store-DB-Pundles" selector="superclassOrder:">superclassOrder: dbClasses	"Sort all of the classes in the list into a collection where no class is 	preceded by a subclass or by its metaclass.	I cannot use method in the chage set since the classes are not in 	the image"	^self class superclassOrder: dbClasses</body></methods><methods><class-id>Store.Package</class-id> <category>private-accessing</category><body package="Store-DB-Pundles" selector="recordForClassTag:">recordForClassTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^( aTag isMeta		ifTrue: [ self metaclasses ]		ifFalse: [ self classes ] 	) detect: 		[ :dbClass | 		dbClass absoluteName asClassNameOnly = aTag className		] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="recordForDataTag:">recordForDataTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there." 	^data isNil		ifTrue: 			[ DataView				datumWithKey: aTag dataKey asString				ownerName: aTag ownerName asString				package: self primaryKey			]		ifFalse: 			[ data detect: 				[ :datum | 				datum environmentString = aTag ownerName asString 					and: [ datum dataKey = aTag dataKey ]				] ifNone: [ nil ]			]</body><body package="Store-DB-Pundles" selector="recordForMethodTag:">recordForMethodTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there." 	^methods isNil		ifTrue: [ MethodsView					methodNamed: aTag selector asString					class: aTag className					package: self primaryKey				]		ifFalse: 			[ methods detect: 				[ :method | 				method className = aTag className and: [ method selector = aTag selector ]				] ifNone: [ nil ]			]</body><body package="Store-DB-Pundles" selector="recordForNameSpaceTag:">recordForNameSpaceTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^self nameSpaces detect: 		[ :dbNs | 		dbNs absoluteName = aTag name		] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^nil</body><body package="Store-DB-Pundles" selector="recordForTag:">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' 	or nil if not there."	^aTag recordForPackage: self.</body><body package="Store-DB-Pundles" selector="recordOrPseudoForClassTag:">recordOrPseudoForClassTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoClass if not there."	^( aTag isMeta		ifTrue: [ self metaclasses ]		ifFalse: [ self classes ] 	) detect: 		[ :dbClass | 		dbClass absoluteName asClassNameOnly = aTag className		] ifNone: [ PseudoClass named: aTag className meta: aTag isMeta ]</body><body package="Store-DB-Pundles" selector="recordOrPseudoForDataTag:">recordOrPseudoForDataTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoSubdef if not there." 		| dm |	dm := data == nil		ifTrue: 			[ DataView				datumWithKey: aTag dataKey asString				ownerName: aTag ownerName				package: self primaryKey			]		ifFalse: 			[ data detect: 				[ :datum | 				datum environmentString = aTag environmentString 					and: [ datum dataKey = aTag dataKey ]				] ifNone: [  PseudoSubdef dataKey: aTag dataKey owner: aTag ownerName  ]			].	^dm == nil		ifTrue: [ PseudoSubdef dataKey: aTag dataKey owner: aTag ownerName ]		ifFalse: [ dm ].</body><body package="Store-DB-Pundles" selector="recordOrPseudoForMethodTag:">recordOrPseudoForMethodTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoSubdef if not there." 	| meth |	meth := methods ==  nil		ifTrue: [ MethodsView					methodNamed: aTag selector asString					class: aTag classNameWithMeta					package: self primaryKey				]		ifFalse: 			[ methods detect: 				[ :method | 				method className = aTag classNameWithMeta and: [ method selector = aTag selector ]				] ifNone: [ nil ]			].		^meth == nil		ifTrue: [  PseudoSubdef selector: aTag selector owner: aTag classNameWithMeta ]		ifFalse: [ meth ].</body><body package="Store-DB-Pundles" selector="recordOrPseudoForNameSpaceTag:">recordOrPseudoForNameSpaceTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoNameSpace if not there."	^self nameSpaces detect: 		[ :dbNs | 		dbNs absoluteName = aTag name		] ifNone: [ PseudoNameSpace named: aTag name ]</body><body package="Store-DB-Pundles" selector="recordOrPseudoForTag:">recordOrPseudoForTag: aTag 	"Answer the item in this package corresponding to 'aTag' or a pseudo record if not there."	aTag isForMethod ifTrue: [^self recordOrPseudoForMethodTag: aTag].	aTag isForData ifTrue: [^self recordOrPseudoForDataTag: aTag].	aTag isForClass | aTag isClassCommentTag 		ifTrue: [^self recordOrPseudoForClassTag: aTag].	aTag isForNameSpace | aTag isNameSpaceCommentTag 		ifTrue: [^self recordOrPseudoForNameSpaceTag: aTag].	self error: #UnknownTagType &lt;&lt; #store &gt;&gt; 'Unknown tag type.'</body></methods><methods><class-id>Store.Package</class-id> <category>private-differences calculation</category><body package="Store-DB-Pundles" selector="classesAndNameSpacesFromChanges:">classesAndNameSpacesFromChanges: changeSet	| list |	list := OrderedCollection new.	changeSet keysAndValuesDo:		[ :symbol :cc | 		( cc isForClass			ifTrue: 				[ list add: 					( self classes 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: false ]					).				list add: 					( self metaclasses 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: true ]					).				]				ifFalse:					[ list add: 						( self nameSpaces 							detect: 	[ :cls | cls absoluteName = symbol asString ] 							ifNone: [ PseudoNameSpace newNamed: symbol ]						)					]			)		].	^list</body><body package="Store-DB-Pundles" selector="classesNamed:">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of TT_Classes or TT_PseudoClasses."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self classes do: 		[ :cl | ( names includes: cl absoluteName )			ifTrue: 				[names remove: cl absoluteName.				selected add: cl				]		].	self metaclasses do: 		[ :cl | ( names includes: cl absoluteName, ' class'  )			ifTrue: 				[ names remove: cl absoluteName, ' class'.				selected add: cl				]		].	names do: 		[ :nm |  selected add: (PseudoClass newNamed: nm ) ].	^selected</body><body package="Store-DB-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aPackage into: diffHolder	^aPackage computeDiffsBetweenDBPackage: self into: diffHolder</body><body package="Store-DB-Pundles" selector="computeDiffsBetweenDBPackage:into:">computeDiffsBetweenDBPackage: aBDPackage into: diff	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number2 since this method	is called with arguments reversed."	diff methodsSide: 2 put: (Method allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff methodsSide: 1 put: (Method allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff dataSide: 2 put: (DataElement allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff dataSide: 1 put: (DataElement allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff nameSpacesSide: 2 put: (NameSpaceRecord allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff nameSpacesSide: 1 put: (NameSpaceRecord allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff classesSide: 2 put: (ClassRecord allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff classesSide: 1 put: (ClassRecord allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff metaSide: 2 put: (ClassRecord allMetaclassesInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff metaSide: 1 put: (ClassRecord allMetaclassesInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	^diff</body><body package="Store-DB-Pundles" selector="nameSpacesNamed:">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of NameSpaceRecords or PseudoNameSpaces."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self nameSpaces do: 		[ :ns | ( names includes: ns absoluteName )			ifTrue: 				[names remove: ns absoluteName.				selected add: ns				]		].	names do: 		[ :nm |  selected add: ( PseudoNameSpace newNamed: nm ) ].	^selected</body></methods><methods><class-id>Store.Package</class-id> <category>utilities-repository</category><body package="Store-DB-Pundles" selector="conflictsWithImage">conflictsWithImage	"Answer a collection of package elements that describe entities that 	already exists in the image."	| conflicts |	conflicts := OrderedCollection new.	conflicts addAll: (self nameSpaces select: [:each | each conflictsWithImage]).	conflicts addAll: (self classes select: [:each | each conflictsWithImage]).	conflicts addAll: (self methods select: [:each | each conflictsWithImage]).	conflicts addAll: (self data select: [:each | each conflictsWithImage]).	^conflicts</body><body package="Store-DB-Pundles" selector="itemCount">itemCount	^( Methods  itemCountForPackage: primaryKey ) +		( PkgClasses  itemCountForPackage: primaryKey ) +		( PkgNameSpaces  itemCountForPackage: primaryKey ) +		( Data  itemCountForPackage: primaryKey )</body><body package="Store-DB-Pundles" selector="loadClasses:into:">loadClasses: dbClasses into: imgPackage 	"Load the dbClasses and their meta classes. Supress errors for second try. 	Answer the list of failed classes."	| failed |	failed := OrderedCollection new.	dbClasses do: 		[ :cls |  		[ cls loadSrcInto: imgPackage ] on: UnhandledException do:			[ :ex | 			failed add: cls.			ex return			]  		].	^failed</body><body package="Store-DB-Pundles" selector="loadData:ownerName:intoPackage:ifNone:">loadData: dataKey ownerName: fullName intoPackage: destPackage ifNone: noneBlock	"Load the data specified from the database."	| element |	self deprecated: #(#version '7.8' #sunset '8.0' #use 'StorePackage objects').	element := self datum: dataKey forOwnerNamed: fullName.	element isNil ifTrue: [ ^noneBlock value ].	element loadSrcIntoPackage: destPackage confirm: false.</body><body package="Store-DB-Pundles" selector="loadMethod:className:intoPackage:ifNone:">loadMethod: selector className: fullClassName intoPackage: destnPackage ifNone: noneBlock	"Load the method specified from the database.		aSelector		Symbol		fullClassName	String  		destnPackage	TT_PackageModel		noneBlock		Block - execute if there is no such method in the package	"	| aTtMethod |	self deprecated: #(#version '7.8' #sunset '8.0' #use 'StorePackage objects').	aTtMethod := self method: selector					forClassNamed: fullClassName asClassNameOnly							"remove 'a Class' in metaclass names"					meta: fullClassName namesMetaClass.	aTtMethod isNil ifTrue: [^noneBlock value].	aTtMethod loadSrcIntoPackage: destnPackage confirm: false.</body><body package="Store-DB-Pundles" selector="loadNameSpaces:imagePackage:">loadNameSpaces: dbNamespaces imagePackage: imgPackage	"Load the dbNamespaces and their meta classes. "	dbNamespaces do: 	[ :ns | ns loadSrcInto: imgPackage ].</body><body package="Store-DB-Pundles" selector="loadSrcWithin:warnReplace:">loadSrcWithin: parentBundle warnReplace: warnReplace	"Load the package from DB. 	Return the image package or nil on error."		| storePackage |	DbRegistry useAtomicLoader		ifTrue: 			[(storePackage := self glorpReconciledVersion) ifNil: [^nil].			^storePackage loadSource]		ifFalse: [self checkPrerequisites ifFalse: [^nil]].	self runPreRead ifFalse: [^nil].	^self		loadWithin: parentBundle		useBinIfAvailable: Policies publishPolicy allowBinaryLoading		warnReplace: warnReplace</body><body package="Store-DB-Pundles" selector="loadWithin:useBinIfAvailable:warnReplace:">loadWithin: parentBundle useBinIfAvailable: binOK warnReplace: warnReplace	"Load the package."	| imPkg |	( binOK not or: [ ( imPkg := self binLoadWithin: parentBundle ) isNil ] )		ifTrue: [ imPkg := self sourceLoadFromDBloadWithin: parentBundle warnReplace: warnReplace ].	Root allNameSpaces do: [ :ns | ns organization removeEmptyCategories ].	^imPkg</body><body package="Store-DB-Pundles" selector="postLoad:">postLoad: imPkg 	"Do post load clean up"	imPkg isNil		ifFalse: 			["self checkContentWith: imPkg."			imPkg 				dbTrace: self primaryKey;								runPostLoad;				markNotModified.			]</body><body package="Store-DB-Pundles" selector="preLoadCheckWith:within:">preLoadCheckWith: imPkg within: aBundle	"Verify the receiver can be loaded."	^LoadAnalyzer		preDBLoadOverlapCheckOf: imPkg		within: aBundle		classes: self classesWithSource		nameSpaces: self nameSpacesWithSource		methods: self methodsWithSource		data: self dataWithSource</body><body package="Store-DB-Pundles" selector="tableOfContents">tableOfContents	"Answer a string describing the content of the receiver"	| aStream |	aStream := WriteStream on: (String new: 200).	aStream nextPutAll: ((#Package1sN &lt;&lt; #store &gt;&gt; 'Package: &lt;1s&gt;&lt;n&gt;') expandMacrosWith: self name).	aStream		nextPutAll: (#Clasess &lt;&lt; #store &gt;&gt; 'Clasess:') asString;		cr.	classes := self superclassOrder: self classes.	classes do: 			[:each | 			aStream				nextPutAll: each name;				cr].	aStream		nextPutAll: (#MethodsC &lt;&lt; #store &gt;&gt; 'Methods:') asStrings;		cr.	self methods do: 			[:each | 			aStream				nextPutAll: each className , '&gt;&gt;' , each protocolName , '&gt;&gt;' , each name;				cr].	^aStream contents</body><body package="Store-DB-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForPackages</body></methods><methods><class-id>Store.Package</class-id> <category>private-loading</category><body package="Store-DB-Pundles" selector="binLoadWithin:">binLoadWithin: parentBundle	"Supress unloadable code dialog in the intial load.	Handle redefininitions by short-circutting the bundle/package handler."	| packageModel record unloadable |	(record := self binaryVersion) ifNil: [^nil].	unloadable := OrderedCollection new.	packageModel := Registry packageNamed: name.	[[[packageModel isNil		ifTrue:			[packageModel := (Registry packageNamedOrCreate: name)				dbTrace: self primaryKey;				loadFrom: record using: CodeReader new;				yourself]		ifFalse: [packageModel updateFrom: record within: parentBundle]]			on: CodeReader requestWarningSuppressionSignal			do: [:exception | exception resume: true]]				on: RedefinitionNotification				do: [:notification | notification resume]]					on: self class imageClass fileFormatSignal					do: [:exception | exception return: nil].	packageModel ifNil: [^nil].	[self checkUninstalledClasses: packageModel]		on: UnloadableDefinitionError		do:			[:exception | 			exception package: packageModel.			unloadable add: exception.			exception resume].	unloadable isEmpty ifFalse:		[ Store.UnloadableDefinitionsViewer openOnExceptions: unloadable ].	packageModel ifNotNil:		[packageModel			dbTrace: self primaryKey;			markNotModified].	^packageModel</body><body package="Store-DB-Pundles" selector="binaryVersion">binaryVersion	"Answer a ParcelRecord if one exists for the receiver. Answer nil otherwise."	^parcelID == nil		ifFalse: 			[ ( self class parcelRecordClass aRecordWithID: parcelID )				pundle: self;				yourself			]</body><body package="Store-DB-Pundles" selector="checkUninstalledClasses:">checkUninstalledClasses: imgPackage	"Determine if there are any uninstalled classes or methods and deal with them appropriately."	| uninstalledClasses uninstalledMethods uninstalledBindings |	uninstalledClasses := imgPackage propertyAt: #uninstalledClasses ifAbsent: [ OrderedCollection new ].	uninstalledMethods := imgPackage propertyAt: #uninstalledMethods ifAbsent: [ OrderedCollection new ].	uninstalledBindings :=  imgPackage propertyAt: #uninstalledBindings ifAbsent: [ OrderedCollection new ].	uninstalledMethods isEmpty &amp; uninstalledClasses isEmpty &amp; uninstalledBindings isEmpty		ifFalse: [ self checkUninstalledClasses: uninstalledClasses methods: uninstalledMethods bindings: uninstalledBindings ].	imgPackage propertyAt: #uninstalledClasses put: nil.			imgPackage propertyAt: #uninstalledMethods put: nil.	imgPackage propertyAt: #uninstalledBindings put: nil.</body><body package="Store-DB-Pundles" selector="checkUninstalledClasses:methods:bindings:">checkUninstalledClasses: uninstalledClasses methods: uninstalledMethods bindings: uninstalledBindings	"Determine why the uninstalled can't be installed and display a message box informing the user.	Signal the unloadable exception for the browser."	| clsRecords methRecords dataRecords |	clsRecords := self classesNamed: ( uninstalledClasses collect: [ :uc | uc absoluteName ] ).	methRecords :=  ( uninstalledMethods collect:		[ :um | MethodsView					methodNamed: um selector asString					class: um implementingClass classNameWithMeta					package: self primaryKey		] ) asOrderedCollection.	dataRecords := OrderedCollection new.	"uninstalled classes methods are not seperate records, so convert them."	uninstalledClasses do:		[ :uc | uc selectors do:				[ :sel | methRecords add: 						( MethodsView							methodNamed: sel asString							class: uc absoluteName							package: self primaryKey						)				].			uc class selectors do:				[ :sel | methRecords add: 						( MethodsView							methodNamed: sel asString							class: uc class absoluteName							package: self primaryKey						)				].			dataRecords addAll: 				( uc asNameSpace keys collect:					[ :key | 					DataView datumWithKey: key asString					ownerName: uc absoluteName					package: self primaryKey					]				).		].	uninstalledBindings do:		[ :ubc |  		ubc asNameSpace keys do:			[ :key |			dataRecords add:				( DataView datumWithKey: key ownerName: ubc absoluteName package: self primaryKey ) 			]		].	LoadAnalyzer checkUninstalledForPackage: self classes: clsRecords methods: methRecords data: dataRecords.	clsRecords asOrderedCollection, methRecords, dataRecords		 do: [ :rec | UnloadableDefinitionError signalWith: rec ].</body><body package="Store-DB-Pundles" selector="doDiffSourceLoad:within:">doDiffSourceLoad: imPkg within: parentBundle 	"Load source code of the packge. Make sure that only defintions that 	are different are loaded. Remove definitions that are in the image but are not present 	in the parentBundle."	| diffs unloadable |	diffs := PackageDifferences with: self with: imPkg.	(diffs preLoadCheckWithin: parentBundle) ifFalse: [^false].	unloadable := OrderedCollection new.	imPkg runPreUnload: true.	parentBundle == nil 		ifTrue: 			[Notice 				showProgress: (#LoadingPackage1s &lt;&lt; #store &gt;&gt; 'Loading package &lt;1s&gt;' 						expandMacrosWith: self name)				complete: diffs itemCount				while: 					[[diffs loadFromDBWithin: parentBundle] on: UnloadableDefinitionError						do: 							[:exp | 							exp package: imPkg.							unloadable add: exp.							exp resume]]				title: #Store &lt;&lt; #store &gt;&gt; 'Store']		ifFalse: 			[MessageNotification raiseSignal: self name.			ResetIncrementNotification signalWith: diffs itemCount.			[ diffs loadFromDBWithin: parentBundle ] 				on: UnloadableDefinitionError 				do:					[ :exp | 					exp package: imPkg.					unloadable add: exp.					exp resume.					]].	"Set comment and initalization string."	imPkg comment: self commentOrNil.	imPkg properties: self properties.	"Execute initialization string."	"imPkg runPostLoad."	unloadable isEmpty 		ifFalse: 			[ Store.UnloadableDefinitionsViewer openOnExceptions: unloadable ].	^true</body><body package="Store-DB-Pundles" selector="doSourceLoad:within:">doSourceLoad: imPkg within: parentBundle	"Load source code of the packge. Make sure that only methods and classes that 	are different are loaded. ImgPkg should be empty."	| dbClasses dbNamespaces retry unloadable |	"To display what the error is. In the future, we can pass back the message itself 	and display it in the unloadable definition browser."	self preLoadCheckWith: imPkg  within: parentBundle. 		self runPreLoad.	dbClasses := self classes.	dbNamespaces := self nameSpaces.	unloadable := OrderedCollection new.	[ SystemUtils modifySystem:		[ self loadNameSpaces: dbNamespaces imagePackage: imPkg.		retry := self loadClasses: dbClasses into: imPkg.		self doSourceLoadData: imPkg.		retry := self loadClasses: retry into: imPkg		].	retry do: [ :rec | UnloadableDefinitionError signalWith: rec ].	"Remove classes that were defined in the loaded package"	self doSourceLoadMethods.	] on: UnloadableDefinitionError do:		[ :exp | 		exp package: imPkg.		unloadable add: exp.		exp resume.		].	imPkg removeEmptyProtocols.	self initializeData: self data.	self initializeClasses: dbClasses.	"Set comment and initalization string."	imPkg comment: self commentOrNil; 		properties: self properties.	"Execute initialization string."	"imPkg runPostLoad."	unloadable isEmpty		ifFalse: [ Store.UnloadableDefinitionsViewer openOnExceptions: unloadable ].	^true</body><body package="Store-DB-Pundles" selector="doSourceLoadData:">doSourceLoadData: imPkg	"Load the data of the package 'imPkg'. Make sure that only data that 	are different are loaded. Remove definitions that are in the image but are not present 	in this package."	| toRemove dbData toLoad affectedClasses |	toLoad := List new. 	toRemove := imPkg data asOrderedCollection.	toRemove removeAllSuchThat: 		[ :dataDescriptor | | binding |		( binding := dataDescriptor binding ) == nil			ifTrue: [ true ] 			ifFalse: [ binding value class == ExternalDictionary ]		].	dbData := self data.	dbData do: 		[ :each | | idx imMt |		"Find if a datum is in the system." 		imMt := nil.		idx := toRemove findFirst: [ :mt | mt fullName  = each fullName ].		idx &gt; 0 ifTrue: 			[imMt := toRemove at: idx.			toRemove removeAtIndex: idx].		(imMt isNil or: [(imMt sameAsDBThing: each) not])			ifTrue: [toLoad add: each]].	toLoad do: [ :each | each loadSrc ].	"Remove data."	affectedClasses := Set new.		toRemove do: 		[ :imMt |  		imMt myClass unloadDataKey: imMt dataKey.		affectedClasses add: imMt myClass		].	affectedClasses do: [:aClass | aClass organization removeEmptyCategories].</body><body package="Store-DB-Pundles" selector="doSourceLoadMethods">doSourceLoadMethods	"Load the methods of the receiver. Called when the  image package	is empty."	(  Method sortForLoading: self methodsWithSource package: self ) do: 		[ :each | each loadAsNewWithCommittingSource: false ].	[ self methodsWithSource do: 		[ :method |		method myClass ifNotNil: 			[ :class|  | cm source |			cm := class compiledMethodAt: method selector.			source := cm sourcePointer.			source isInteger ifFalse:				[ cm sourcePointer: ( SourceFileManager default					storeMethodSources: source					class: method myClass 										selector: method selector					category: method protocol 					safely: false )				]."			cm stDocumentation: method stDocumentation.  "			]		]	] ensure: [ SourceFileManager default targetFile commit ]</body><body package="Store-DB-Pundles" selector="initializeClasses:">initializeClasses: dbClasses	"Send #postLoad to all newly instantiated classes and #initialize to all classes whose 	initialize method was modified."	| toPostLoad toInit |	toPostLoad := dbClasses collect: 		[ :cls |  | obj | 		( obj := cls object ) == nil			ifFalse: [ obj postLoad: self ].		obj		].	"hack - but got to execute new versions of #initialize"	toInit := OrderedCollection new.	self methods do:		[ :meth |  | cls |		( ( meth isMeta and: [ meth selector == #initialize ] ) and: [ ( cls := meth myClass ) ~~ nil ] )			ifTrue: 				[ ( toPostLoad includes: cls instanceBehavior ) 					ifFalse: [ toInit add: cls instanceBehavior ]				].		].	( SystemUtils  sortForLoading: toInit ) do: 		[ :cls | cls initialize ].</body><body package="Store-DB-Pundles" selector="initializeData:">initializeData: dbData	"Initialize all the statics"	| ns bind |	[ ( DataElement sortStaticsForLoading: dbData ) do: 		[ :each |		( ns := each owner ) == nil			ifFalse: 				[ ns := ns asNameSpace.				( bind := ns bindingFor: each dataKey ) == nil					ifFalse: [ bind reinitializeValue ]				]		].	] on: UnloadableDefinitionError do: [ :exp | exp resume ].</body><body package="Store-DB-Pundles" selector="sourceLoadFromDBloadWithin:warnReplace:">sourceLoadFromDBloadWithin: parentBundle warnReplace: warnReplace 	"Load the package from DB. 	If the user does not want to replace the loaded version answer the	existing image package. Note: catch errors during the load."	| imPkg loadRes |	imPkg := self createImagePundle.	imPkg dbIdentifier: self dbIdentifier.	(warnReplace and: [imPkg canReplaceVersions not]) ifTrue: [^imPkg].	Policies packagePolicy forcePackage: imPkg		while: 			[XMainChangeSet ignoreMainChangesWhile: 					[loadRes := imPkg isCompletelyEmpty 								ifTrue: 									[parentBundle == nil 										ifTrue: 											[Notice 												showProgress: (#LoadingPackage1s &lt;&lt; #store &gt;&gt; 'Loading package &lt;1s&gt;' 														expandMacrosWith: self itemString)												complete: self itemCount												while: [self doSourceLoad: imPkg within: parentBundle]												title: #Store &lt;&lt; #store &gt;&gt; 'Store']										ifFalse: 											[MessageNotification raiseSignal: self itemString.											ResetIncrementNotification signalWith: self itemCount.											self doSourceLoad: imPkg within: parentBundle]]								ifFalse: [self doDiffSourceLoad: imPkg within: parentBundle]].			loadRes ifTrue: [self postLoad: imPkg]].	^loadRes ifTrue: [imPkg] ifFalse: [nil]</body></methods><methods><class-id>Store.Package</class-id> <category>private</category><body package="Store-DB-Pundles" selector="addClasses:andMetaclasses:">addClasses: aCollectionOfClasses andMetaclasses: aCollectionOfMetaclasses 	"Convert collection of classes into collection of DB classes and add 	classes to the receiver. 	Note that if the trace is not null then check the classes from the trace and 	create new records only for classes that are different."	| newDBClasses newDBMetaclasses traceClasses traceClassesLookup |	traceClasses := self hasTrace ifTrue: [ self getTrace classes ] ifFalse: [ #() ].	traceClassesLookup := Dictionary new: traceClasses size.	traceClasses do:		[:each |			traceClassesLookup				at: each absoluteName				put: each		].	newDBClasses := OrderedCollection new.	aCollectionOfClasses do: 		[ :each |  | aDBClass |		aDBClass := traceClassesLookup at: each absoluteName ifAbsent: [nil].		newDBClasses add: ( ClassRecord recordFor: each trace: aDBClass ).		IncrementNotification raiseSignal.		].	traceClasses := self hasTrace ifTrue: [self getTrace metaclasses] ifFalse: [#()].	traceClassesLookup := Dictionary new: traceClasses size.	traceClasses do:		[:each |			traceClassesLookup				at: each absoluteName				put: each		].	newDBMetaclasses := OrderedCollection new.	aCollectionOfMetaclasses do: 		[:each | 		| aDBClass |		aDBClass := traceClassesLookup at: each absoluteName ifAbsent: [nil].		newDBMetaclasses add: (ClassRecord recordFor: each trace: aDBClass)		].	self addDBClasses: newDBClasses andMetaclasses: newDBMetaclasses</body><body package="Store-DB-Pundles" selector="addDBClasses:andMetaclasses:">addDBClasses: aCollectionOfDBClasses andMetaclasses: aCollectionOfDBMetaclasses 	"Create new entries in a table which binds classes to packages."	| aClass index |	index := classes size + 1.	aCollectionOfDBClasses with: aCollectionOfDBMetaclasses do: 		[ :each :meta | 		aClass := (PkgClasses new) 					packageRef: self primaryKey; 					classRef: each primaryKey; 					metaclassRef: meta primaryKey;					definitionOrder: index.		index := index + 1.		aClass install.		]</body><body package="Store-DB-Pundles" selector="addDBData:">addDBData: aCollectionOfDBData 	"Create new entries in a table which binds data to packages."	aCollectionOfDBData do: [:each | self addNewDBDatum: each]</body><body package="Store-DB-Pundles" selector="addDBMethods:">addDBMethods: aCollectionOfDBMethods 	"Create new entries in a table which binds methods to packages."	aCollectionOfDBMethods do: [:each | self addNewDBMethod: each]</body><body package="Store-DB-Pundles" selector="addDBNameSpaces:">addDBNameSpaces: aCollectionOfDBNameSpaces 	"Create new entries in a table which binds namespaces to packages."	| namespace index |	index := classes size + 1.	aCollectionOfDBNameSpaces do: 		[ :each | 		( namespace := PkgNameSpaces new ) 			packageRef: self primaryKey; 			nameSpaceRef: each primaryKey; 			definitionOrder: index.		index := index + 1.		namespace install		]</body><body package="Store-DB-Pundles" selector="addData:">addData: aCollectionOfData 	"Convert a collection of method descriptors into a collection of DB data. 	Install the new collection in the DB. 	Note that if the trace is not null then check the data from the trace and 	create a new record only for a datum that is different then the one in 	database."	| newDBData traceData |	traceData := self hasTrace ifTrue: [ self getTrace data ] ifFalse: [ #() ].	newDBData := aCollectionOfData collect: 		[ :dd |  | owner dataKey aTraceDatum |		owner := dd owner.		dataKey := dd dataKey asString.		aTraceDatum := traceData detect: 				[:dbDatum | dbDatum name = dataKey and: 						[dbDatum environmentString = owner absoluteName ]				] ifNone: [ nil ].		IncrementNotification raiseSignal.		DataElement recordFromDescriptor: dd trace: aTraceDatum package: self		].	self addDBData: newDBData.	^newDBData</body><body package="Store-DB-Pundles" selector="addMethods:">addMethods: aCollectionOfMethods 	"Convert a collection of method descriptors into a collection of DB methods. 	Install the new collection in the DB. 	Note that if the trace is not null then check the methods from the trace and 	create a new record only for a method that is different then the one in 	database."	| newDBMethods traceMethods |	traceMethods := self hasTrace ifTrue: [ self getTrace methods ] ifFalse: [ #() ].	newDBMethods := aCollectionOfMethods collect: 		[ :md |  | selector cls aTraceMethod  |			selector := md selector asString.		cls := md implementingClass.		aTraceMethod := traceMethods detect: 			[ :dbMethod | dbMethod name = selector and: [ dbMethod className = cls name asString ] ] 				ifNone: [ nil ].		IncrementNotification raiseSignal.		Method	recordFromDescription: md	trace: aTraceMethod package: self.		].	self addDBMethods: newDBMethods.	^newDBMethods</body><body package="Store-DB-Pundles" selector="addNewDBDatum:">addNewDBDatum: aDBDatum	"Create new entry in a table which binds data to packages."	Data new		packageRef: self primaryKey; 		dataRef: aDBDatum primaryKey;		install</body><body package="Store-DB-Pundles" selector="addNewDBMethod:">addNewDBMethod: aDBMethod	"Create new entry in a table which binds methods to packages."	| baby |	baby := (Methods new) packageRef: self primaryKey; methodRef: aDBMethod primaryKey.	baby install</body><body package="Store-DB-Pundles" selector="descriptionClass">descriptionClass	^PackageDescription</body><body package="Store-DB-Pundles" selector="installSqlString">installSqlString	"Column names must be String, for consistency with #columnNames"	^ self newSQL		insertColumnsValues:  #( 'primaryKey' 'name' 'timeStamp' 'version' 'userName' 'trace' 'commentID' 'propertiesID' 'parcelID' 'binFile' ).</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	namespaces := Object new.	classes := Object new.	metaclasses := Object new.	methods := Object new.	data := Object new.	overrides := Object new.</body><body package="Store-DB-Pundles" selector="processFields">processFields	"Do any necessary data conversions following retrieval"</body><body package="Store-DB-Pundles" selector="removeDBDatum:">removeDBDatum: aDBDatum 	"Replace an entry in a table which binds methods to packages."	Data		removeDatum: aDBDatum primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="removeDBMethod:">removeDBMethod: aDBMethod 	"Replace an entry in a table which binds methods to packages."	Methods		removeMethod: aDBMethod primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="replaceDBDatum:with:">replaceDBDatum: aDBDatum with: newDBDatum	"Replace an entry in a table which binds data to packages."	Data		replaceDatum: aDBDatum primaryKey		with: newDBDatum primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="replaceDBMethod:with:">replaceDBMethod: aDBMethod with: newDBMethod	"Replace an entry in a table which binds methods to packages."	Methods		replaceMethod: aDBMethod primaryKey		with: newDBMethod primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.		namespaces := nil.	classes := nil.	metaclasses := nil.	methods := nil.	data := nil.	overrides := nil.</body></methods><methods><class-id>Store.Package</class-id> <category>comparing</category><body package="Store-DB-Pundles" selector="sameAsImThing:">sameAsImThing: aPkg	^false</body></methods><methods><class-id>Store.Package</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="actualClassInPackageNamed:">actualClassInPackageNamed: aString 	"Answer an instance class from package or nil if 	the package does not contain definition of the class. "	^( self classes 		detect: [ :dbClass | dbClass name = aString ] ifNone: [ ^nil ] 	) myClass</body><body package="Store-DB-Pundles" selector="allClasses">allClasses	"Answer a collection of classes. The collection contains classes that are defined in the 	package and  pseudo-classes (i.e., extended) for which only methods 	or data are defined."	| defined extended mc |	defined := self classes collect: [:class | class absoluteName].	extended := (self methods collect: [:method | method fullClassName]) asSet.	extended addAll: ( ( self data select: [ :elem | elem isInClass ] )				collect: [ :elem | elem environmentString ] ).	mc := extended asOrderedCollection select: [:mName | mName namesMetaClass ].	extended := extended asOrderedCollection reject: [:mName | mName namesMetaClass ]. 	mc do: 		[ :c | ( extended includes: c asClassNameOnly ) 					ifFalse: [ extended add: c asClassNameOnly ].		].	defined do: [:each | extended remove: each ifAbsent: []].	extended := extended collect: [:cName| PseudoClass newNamed: cName].	^self classes, extended</body><body package="Store-DB-Pundles" selector="allMetaclasses">allMetaclasses	"Answer a collection of metaclasses. The collection contains metaclasses that are defined 	in the package and metaclasses for which methods are defined."	| defined extended |	defined := self metaclasses collect: [:class | class absoluteName, ' class'].	extended := (self methods collect: [:method | method className]) asSet.	extended := extended select: [:mName | mName includes: $ ].	defined do: [:each | extended remove: each ifAbsent: [nil]].	extended := extended collect: [:cName| PseudoClass newNamed: cName].	^self metaclasses , extended asOrderedCollection.</body><body package="Store-DB-Pundles" selector="allNameSpaces">allNameSpaces	"Answer a collection of namespaces. The collection contains name spaces	that are defined in the package and pseudo-name spaces (i.e., extended)	for which only data is defined."	| defined extended |	defined := self nameSpaces collect: [: ns | ns absoluteName].	extended := ((self data select: [:elem | elem isInNameSpace])		collect: [:elem | elem nameSpaceName]) asSet.	defined do: [:each | extended remove: each ifAbsent: [nil]].	extended := extended asOrderedCollection.	extended := extended collect: [:ns | PseudoNameSpace newNamed: ns].	^self nameSpaces, extended</body><body package="Store-DB-Pundles" selector="asDBDescription">asDBDescription	^self class partClass new		packageRef: self primaryKey		yourself</body><body package="Store-DB-Pundles" selector="binFile">binFile	^binFile</body><body package="Store-DB-Pundles" selector="binFile:">binFile: aString	binFile := aString</body><body package="Store-DB-Pundles" selector="classInPackageNamed:">classInPackageNamed: aString 	"Answer a class from package or nil if 	the package does not contain definition of the class. 	aString is either a class name or a class name followed by ' class'. 	Answer the class or metaclass it names."	^aString namesMetaClass		ifTrue: [self metaclasses detect: [:dbClass | dbClass name = aString]				ifNone: [nil]]		ifFalse: [self classes detect: [:dbClass | dbClass name = aString]				ifNone: [nil]]</body><body package="Store-DB-Pundles" selector="classInPackageNamed:meta:">classInPackageNamed: aString meta: aBoolean	"Answer a class or metaclass from package or nil if the package 	does not contain a definition of the class. "	^( aBoolean 			ifTrue: [ self metaclasses ] 			ifFalse: [ self classes ] 	) detect: [ :dbClass | dbClass absoluteName = aString ] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="classes">classes	| dbClasses |	classes isNil 		ifTrue: 		[ [ 			  dbClasses := self broker getAnswerFromSession: [ PkgClassesView classesSession ]			  bindInput: [:session | session bindInput primaryKey: self primaryKey].			  classes := ( dbClasses collect: 					[ :each | ( ClassRecord fromView: each ) package: self ] ) asOrderedCollection.		   ] 		   on: self errorSignals 		   do:	[:ex |  					dbClasses := OrderedCollection new.					^dbClasses				].		].	^classes</body><body package="Store-DB-Pundles" selector="classes:">classes: aCollection	classes := aCollection</body><body package="Store-DB-Pundles" selector="classesDefinedInPackage">classesDefinedInPackage	^self classes</body><body package="Store-DB-Pundles" selector="classesWithSource">classesWithSource	| dbClasses |	classes == nil 		ifFalse: [ ^classes].		"if already there.... source may be there too." 	[ dbClasses := PkgClassesAndSourcesView recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^classes := dbClasses.</body><body package="Store-DB-Pundles" selector="componentType">componentType	"Answer a symbol representing the class of the receiver."	^#package</body><body package="Store-DB-Pundles" selector="data">data	"Returns a Collection of records, one for each shared variable defined in the package."	| dbData |	data == nil ifFalse: [ ^data ].	[ dbData := self broker getAnswerFromSession: [ DataView dataSession ]						bindInput: [:session | session bindInput primaryKey: self primaryKey].	dbData := dbData collect: [:each | ( DataElement fromView: each ) package: self ].	data := dbData asSortedCollection: [:x :y | x name &lt; y name]	] 	on: self  errorSignals 	do: 	[:ex | 			dbData := OrderedCollection new.			^dbData		].	^data</body><body package="Store-DB-Pundles" selector="data:">data: aCollection	data := aCollection</body><body package="Store-DB-Pundles" selector="dataForNamed:">dataForNamed: aFullName 	"Answer a collection of data belonging to the class or namespace aFullName."	^self data select: [ :datum | datum environmentString = aFullName ]. "	^data notNil		ifTrue: [ self data select: [ :datum | datum environmentString = aFullName ] ]		ifFalse: 			[ | inp coll |			inp := DataView new.			inp primaryKey: self primaryKey; fullName: aFullName.			coll := inp dataForNameSpace.			coll asSortedCollection: [ :x :y | x name &lt; y name ]			]"</body><body package="Store-DB-Pundles" selector="dataForNamed:andProtocol:">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of data."	^( self dataForNamed: aFullName ) select:		[ : datum | datum protocolName asSymbol = aSymbol asSymbol ].</body><body package="Store-DB-Pundles" selector="dataProtocolsForNamed:">dataProtocolsForNamed: aName 	^( ( self dataForNamed: aName )			collect: [ :d | d protocolName asSymbol ]	 ) asSet asSortedCollection." if no data.....?????			[| inp |			inp := TT_DataView new.			inp primaryKey: self primaryKey; nameSpaceName: aString.			^inp protocols]"</body><body package="Store-DB-Pundles" selector="dataWithSource">dataWithSource	| dbData |	data == nil 		ifFalse: [ ^data].		"if already there.... source may be there too." 	[ dbData := DataAndSourcesView recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^data := dbData.</body><body package="Store-DB-Pundles" selector="datum:forNameSpaceNamed:">datum: dataKey forNameSpaceNamed: aFullName	"Answer a datum with 'dataKey' defined in the namespace 	named aFullName."	^data notNil		ifTrue: [self data 			detect: [:datum | datum fullName = aFullName 								and: [datum dataKey = dataKey]]				ifNone: [nil]]		ifFalse: 			[DataView datumWithKey: dataKey asString					ownerName: aFullName					package: self primaryKey]</body><body package="Store-DB-Pundles" selector="datum:forNamed:">datum: dataKey forNamed: aFullName	"Answer a datum with 'dataKey' defined in the namespace 	named aFullName."	^data notNil		ifTrue: [self data 			detect: [:datum | datum environmentString = aFullName 								and: [datum dataKey = dataKey]]				ifNone: [nil]]		ifFalse: 			[DataView datumWithKey: dataKey asString					ownerName: aFullName					package: self primaryKey]</body><body package="Store-DB-Pundles" selector="datum:forOwnerNamed:">datum: dataKey forOwnerNamed: aFullName	"Answer a datum with 'dataKey' defined in the namespace 	named aFullName."	^data notNil		ifTrue: 			[ self data detect: 				[ :datum | datum environmentString = aFullName and: [ datum dataKey = dataKey ] ] 					ifNone: [ nil ]			]		ifFalse: 			[ DataView datumWithKey: dataKey asString				ownerName: aFullName				package: self primaryKey			]</body><body package="Store-DB-Pundles" selector="environmentFor:in:">environmentFor: aSelector in: aClass	"Return the environment for the method in question (which we assume we own). If we should not define its scope, return nil"	(self includesDefinitionOf: aClass instanceBehavior absoluteName) ifTrue: [^nil].	^self environment.</body><body package="Store-DB-Pundles" selector="flushCashes">flushCashes	classes := nil.	metaclasses := nil.	methods := nil.	data := nil</body><body package="Store-DB-Pundles" selector="getImagePundle">getImagePundle	"Check if there if already loaded versions of a package and answer it"	^Registry packageNamed: self name.</body><body package="Store-DB-Pundles" selector="includesClassNamed:">includesClassNamed: aName 	| className |	className := aName asClassNameOnly.	^( self classes anySatisfy: [ :class | class absoluteName = className ] )</body><body package="Store-DB-Pundles" selector="includesDefinitionOf:">includesDefinitionOf: aName  	"Answer whether the receiver contains something represented by	aName . Note that only defined NameSpace/Classes are saved." 	^( self includesClassNamed: aName ) or: [ self includesNameSpaceNamed: aName ]</body><body package="Store-DB-Pundles" selector="includesNameSpaceNamed:">includesNameSpaceNamed: aName 	^self nameSpaces anySatisfy: [:ns |  ns absoluteName = aName]</body><body package="Store-DB-Pundles" selector="leafItems">leafItems	"I'm a leaf item."	^Array with: self</body><body package="Store-DB-Pundles" selector="metaclassNamed:">metaclassNamed: aString	^self metaclasses detect: [:dbClass| dbClass name = aString] ifNone: [nil]</body><body package="Store-DB-Pundles" selector="metaclasses">metaclasses 	| dbClasses |	metaclasses isNil ifTrue: 		[			[ dbClasses := self broker getAnswerFromSession: [PkgMetaclassesView metaclassesSession ]			bindInput: [:session | session bindInput primaryKey: self primaryKey ].			metaclasses := ( dbClasses collect: [ :each | ( ClassRecord fromView: each ) package: self ] ) asOrderedCollection.			] 			on: self  errorSignals 			do: 	[ :ex | 					dbClasses := OrderedCollection new.					^dbClasses				]		].	^metaclasses</body><body package="Store-DB-Pundles" selector="metaclasses:">metaclasses: aCollection	metaclasses := aCollection</body><body package="Store-DB-Pundles" selector="metaclassesDefinedInPackage">metaclassesDefinedInPackage	^self metaclasses</body><body package="Store-DB-Pundles" selector="method:forClassNamed:meta:">method: aSelector forClassNamed: aClassName meta: isMeta 	"Answer a method with selector aSelector defined in the class 	named aClassName."	| cName |	cName := ( isMeta and: [ aClassName namesMetaClass not ] )				ifTrue: [aClassName , ' class' ]				ifFalse: [ aClassName ].	^methods notNil		ifTrue: 			[ self methods detect: 				[ :method | method classNameWithMeta = cName and: [ method selector = aSelector ] ]						ifNone: [ nil ]			]		ifFalse: 			[MethodsView methodNamed: aSelector asString					class: cName					package: self primaryKey]</body><body package="Store-DB-Pundles" selector="methods">methods	"Returns a Collection of records, one for each method defined in the package."	| dbMethods |	methods == nil ifFalse: [ ^methods]. 	[ dbMethods := self broker 						getAnswerFromSession: [ MethodsView methodsSession ]						bindInput: [ :session | session bindInput primaryKey: self primaryKey].	methods := dbMethods collect: [ :each | Method fromView: each ].	] 	on: self  errorSignals 	do: 	[ :ex | 			dbMethods := OrderedCollection new.			^dbMethods		].	^methods</body><body package="Store-DB-Pundles" selector="methods:">methods: aCollection	methods := aCollection</body><body package="Store-DB-Pundles" selector="methodsForClass:">methodsForClass: aClass	| aClassName |	aClassName := aClass isMeta		ifTrue: [aClass absoluteName, ' class'] ifFalse: [ aClass absoluteName ].	^self methodsForClassNamed: aClassName.</body><body package="Store-DB-Pundles" selector="methodsForClass:andProtocol:">methodsForClass: aClassName andProtocol: aProtocolName 	"Answer a collection of method names."	| pname |	pname := aProtocolName asString.	^methods notNil		ifTrue: 			[ self methods select: 				[ :method | 				method className = aClassName and: [ method protocolName = pname ]				]			]		ifFalse: 			[ | inp coll|			inp := MethodsView new.			inp primaryKey: self primaryKey; className: aClassName; protocolName: pname.			coll := inp methodsForClassAndProtocol.			coll asSortedCollection: [:x :y | x name &lt; y name]			]</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:">methodsForClassNamed: aClassName 	"Answer a collection of methods."	^methods notNil		ifTrue: [self methods select: [:method | method className = aClassName]]		ifFalse: 			[| inp coll |			inp := MethodsView new.			inp primaryKey: self primaryKey; className: aClassName.			coll := inp methodsForClass.			coll asSortedCollection: [:x :y | x name &lt; y name]]</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:andProtocol:meta:">methodsForClassNamed: aClassName andProtocol: aProtocolName meta: isMeta	^self 		methodsForClass: (isMeta ifTrue: [aClassName, ' class'] ifFalse: [aClassName]) 		andProtocol: aProtocolName</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:meta:">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of methods."	| cname | 	cname := isMeta		ifTrue: [ aClassName, ' class'] 		ifFalse: [ aClassName ].	^methods notNil		ifTrue: [self methods select: [:method | method className = cname]]		ifFalse: 			[| inp coll |			inp := MethodsView new.			inp primaryKey: self primaryKey; className: cname.			coll := inp methodsForClass.			coll asSortedCollection: [:x :y | x name &lt; y name]]</body><body package="Store-DB-Pundles" selector="methodsWithSource">methodsWithSource	| dbMethods |	methods == nil 		ifFalse: [ ^methods].		"if already there.... source may be there too." 	[ dbMethods := Method sourcesViewClass recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^methods := dbMethods.</body><body package="Store-DB-Pundles" selector="nameSpaceInPackageNamed:">nameSpaceInPackageNamed: aName 	^self nameSpaces		detect: [ :dbNS | dbNS absoluteName = aName ] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="nameSpaces">nameSpaces	"Returns a Collection of records, one for each name space defined in the package."	| dbNamespaces |	namespaces isNil 		ifTrue: 		[	[ 			  dbNamespaces := self broker getAnswerFromSession: [ PkgNameSpacesView nameSpacesSession ]			  bindInput: [:session | session bindInput primaryKey: self primaryKey].			  namespaces := ( dbNamespaces collect: [:each | ( NameSpaceRecord fromView: each ) package: self ] ) asOrderedCollection.			] 			on: self  errorSignals 			do: 	[:ex | 					dbNamespaces := OrderedCollection new.					^dbNamespaces				]		].	^namespaces</body><body package="Store-DB-Pundles" selector="nameSpaces:">nameSpaces: aCollection	namespaces := aCollection</body><body package="Store-DB-Pundles" selector="nameSpacesDefinedInPackage">nameSpacesDefinedInPackage	^self nameSpaces</body><body package="Store-DB-Pundles" selector="nameSpacesWithSource">nameSpacesWithSource	| dbNameSpaces |	namespaces == nil 		ifFalse: [ ^namespaces].		"if already there.... source may be there too." 	[ dbNameSpaces := PkgNameSpacesAndSourcesView recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^namespaces := dbNameSpaces.</body><body package="Store-DB-Pundles" selector="package">package	^self</body><body package="Store-DB-Pundles" selector="parcelID">parcelID	^parcelID</body><body package="Store-DB-Pundles" selector="parcelID:">parcelID: aNumber	parcelID := aNumber</body><body package="Store-DB-Pundles" selector="protocolsForClass:">protocolsForClass: aString 	"Answer a collection of protocol names."	| mtds |	methods notNil		ifTrue: 			[mtds := self methods select: [:method | method className = aString].			^(mtds collect: [:method | method protocolName asSymbol]) asSet asSortedCollection]		ifFalse: 			[| inp |			inp := MethodsView new.			inp primaryKey: self primaryKey; className: aString.			^inp protocols]</body><body package="Store-DB-Pundles" selector="protocolsForClassNamed:meta:">protocolsForClassNamed: aClassName meta: isMeta	^self protocolsForClass: (isMeta ifTrue: [aClassName, ' class'] ifFalse: [aClassName])</body><body package="Store-DB-Pundles" selector="protocolsForDataIn:">protocolsForDataIn: anObject	^( ( self dataForNamed: anObject absoluteName )			collect: [ :d | d protocolName asSymbol ]	 ) asSet asSortedCollection.</body><body package="Store-DB-Pundles" selector="pundleChangesClass">pundleChangesClass	^PackageChanges</body><body package="Store-DB-Pundles" selector="sourceForTag:">sourceForTag: aTag 	"Answer the source code in this package corresponding to 'aTag' 	or nil if not there."	| rec |	rec := self recordForTag: aTag.	^rec textRepresentationForTag: aTag</body></methods><methods><class-id>Store.Package</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="loadSrc">loadSrc	"Load the package from DB.	Return the image package or nil on error."	^self asStorePundle loadSource.	"	| packageModel |	self noteLoad.	self class useShadowLoader ifTrue:		[^self asStorePundle loadSource].	[(packageModel := self loadSrcWithin: nil warnReplace: true) ifNotNil:		[ChangeSet loadPundle: self.		SourceFileManager default loadPundle: self.		packageModel cleanUpOverrides]]			on: RedefinitionNotification			do:				[:notification | 				self name = notification currentPackage name ifFalse: [notification override install].				notification resume].	Undeclared purgeUnusedBindings.	self prerequisiteRecursionReset.	^packageModel"</body></methods><methods><class-id>Store.Package</class-id> <category>shadow loading</category><body package="Atomic Compiling and Loading" selector="defaultCompileManager">defaultCompileManager	^ShadowPackageCompileManager</body></methods><methods><class-id>Store.Package</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="sourceOrBinaryString">sourceOrBinaryString	^self parcelID isNil ifTrue: [#source &lt;&lt; #store &gt;&gt; 'source'] ifFalse: [#binary &lt;&lt; #store &gt;&gt; 'binary']</body></methods><methods><class-id>Store.Package</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="storeForGlorpPundleClass">storeForGlorpPundleClass	^self class storeDatabaseClass</body></methods><methods><class-id>Store.Package class</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="nameSpaceOrder:">nameSpaceOrder: dbNameSpaces	"Sort all of the namespace in the list into a collection where no namespace is preceded by 	it's environment.	I cannot use method in SystemUtils since the classes are not in the image"	| oc new names |	oc := dbNameSpaces copy.	new := OrderedCollection new.	[ oc isEmpty ] whileFalse: 		[		names := oc  collect: [ :each | each absoluteName ].		oc copy do: 			[ :each |			( names includes: each environmentString ) 				ifFalse: [ new add: each.  oc remove: each ]			]	].	^new</body><body package="Store-DB-Pundles" selector="objectionsToPublishing:atBlessing:">objectionsToPublishing: imPkg atBlessing: level 	"Answer true if there are no bojections to publishing 	the imPkg at blessing level 'level'"	^Policies publishPolicy objectionsToPublishingPackage: imPkg atBlessingLevel: level.</body><body package="Store-DB-Pundles" selector="sortForLoading:">sortForLoading: aCollection	"Sort aCollection of classes and namespaces in environment and superclass order."	| sorted |	sorted := self nameSpaceOrder: ( aCollection select: [ :obj | obj isForNameSpace ] ).	sorted addAll: ( self superclassOrder: ( aCollection select: [ :obj | obj isForClass] ) ).	^sorted.</body><body package="Store-DB-Pundles" selector="superclassOrder:">superclassOrder: dbClasses	"Sort all of the classes in the list into a collection where no class is preceded by a subclass or 	by its metaclass. I cannot use method in SystemUtils since the classes are not in the image"	| oc newDBClasses classNames |	oc := dbClasses copy.	newDBClasses := OrderedCollection new.	[ oc isEmpty ] whileFalse: 		[		classNames := oc  collect: [ :each | each absoluteName ].		oc copy do: 			[ :each |			( each isPseudo not and: [  classNames includes: each superclass ] ) 				ifFalse: [ newDBClasses add: each.  oc remove: each ]			]	].	^newDBClasses</body></methods><methods><class-id>Store.Package class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="fromPackage:">fromPackage: aPackage	"Create a new instance and install in DB. "	"dialog calls back to: #publishPackage:userData:"	^PublishPackageDialog publishPackage: aPackage</body><body package="Store-DB-Pundles" selector="newFrom:userData:pundleFragments:">newFrom: aPackage userData: userData pundleFragments: aCollection	^self newFrom: aPackage userData: userData</body></methods><methods><class-id>Store.Package class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="allPackages">allPackages	"Answer a SortedCollection of TT_Packages"	"self allPackages"	^self allPackagesOrBundles</body><body package="Store-DB-Pundles" selector="allVersionsWithTrace:">allVersionsWithTrace: anInteger 	"Answer a colection of Packages	self allVersionsWithTrace: 458"	| packages |	[packages := self doPostLoadProcessingOn: (self broker 		process: ((self newSQL)			selectAll;			where;			column: #trace equalTo: anInteger printString)		bindOutput: self newPrimed).	packages := packages collect: [:each | self cachedItemFor: each].		] 				on: self errorSignals				do: 					[:exception | 					exception outer.					packages := self table select: [:each | each dbTrace = anInteger]].	^packages asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]</body><body package="Store-DB-Pundles" selector="alterTablesPctincrease">alterTablesPctincrease	"Fix for databases created with 5i.2. Alter STORAGE PSTINCREASE from 0 to 1"	self dbTables do: 		[ :aClass | aClass alterTablePctincrease ]</body><body package="Store-DB-Pundles" selector="defaultBlockFactor">defaultBlockFactor	^100</body><body package="Store-DB-Pundles" selector="knownPackages">knownPackages	"Answer a SelectionInList containing names of 	all packages stored in DB."	"self knownPackages"	^self knownPackagesOrBundles</body><body package="Store-DB-Pundles" selector="update5i2">update5i2	self deprecated: #(#initial '5i.2' #sunset '7.0').	"self broker alterTableFor: self addColumn: #parcelID."</body></methods><methods><class-id>Store.Package class</class-id> <category>private</category><body package="Store-DB-Pundles" selector="fromView:">fromView: aPackageView  	| aPackage |	aPackage := self new.	aPackage primaryKey: aPackageView primaryKey;			name: aPackageView name;			timeStamp: aPackageView timeStamp;			version: aPackageView version;			userName: aPackageView userName;			dbTrace: aPackageView dbTrace;			longField: aPackageView longField;			commentID: aPackageView commentID;			propertiesID: aPackageView propertiesID;			binFile: aPackageView binFile;			processFields.	^aPackage</body></methods><methods><class-id>Store.Package class</class-id> <category>class initalization</category><body package="Store-DB-Pundles" selector="initialize">initialize	"TT_Package initialize"	self initializeCache.</body></methods><methods><class-id>Store.Package class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames		"self columnNames"	^super columnNames		remove: 'namespaces';		remove: 'classes';		remove: 'metaclasses';		remove: 'methods';		remove: 'data';		remove: 'overrides';		yourself.</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes		" self fieldTypes "	^super fieldTypes		at: 'parcelID' put: #Integer;		yourself.</body><body package="Store-DB-Pundles" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 256K NEXT 256K PCTINCREASE 1) '</body></methods><methods><class-id>Store.Package class</class-id> <category>installation-pkgs</category><body package="Store-DB-Pundles" selector="allComponents">allComponents	"Answer a string containing the name of all tables and views.	Below each table name put column names."	"self allComponents"	| stream |	stream := WriteStream on: (String new: 8192).	stream nextPutAll: 'TABLES:';cr.	self printNamesOf: self dbTables on: stream.	stream cr; cr; nextPutAll: 'VIEWS:';cr.	self printNamesOf: ( self dbViews, self dbSourcesViews ) on: stream.	^stream contents</body><body package="Store-DB-Pundles" selector="createPkgTables">createPkgTables	self dbTables do: 		[ :aClass | aClass createDatabaseTable ]</body><body package="Store-DB-Pundles" selector="createPkgViews">createPkgViews	self dbViews do: 		[ :aClass | aClass createViewForClass: aClass ].	self dbSourcesViews do: 		[ :aClass | self broker createSourcesViewForClass: aClass ]</body><body package="Store-DB-Pundles" selector="createTableIndexes">createTableIndexes		Cursor execute showWhile: 		[self dbTables do: [:each | each createDatabaseIndex]].	Transcript cr;		show: (#DoneCreatingIndexesBang &lt;&lt; #store &gt;&gt; 'Done Creating Indexes!') asString</body><body package="Store-DB-Pundles" selector="dbSessions">dbSessions	"Answer an ordered collection of classes that maintain sessions in the db."	^OrderedCollection new		add: MethodsView; 		add: PkgClassesView; 		add: PkgMetaclassesView; 		add: PkgNameSpacesView; 		add: Blob; 		add: BinaryBlob; 		add: BundlesView; 		add: PackagesView; 		add: DataView;		add: MethodsAndSourcesView;		add: DataAndSourcesView;		add: PkgClassesAndSourcesView;		add: PkgNameSpacesAndSourcesView;		yourself</body><body package="Store-DB-Pundles" selector="dbSourcesViews">dbSourcesViews	"Answer an ordered collection of classes that are represented by OB views"	"Note, supplements dbViews with three way views including sources."	^OrderedCollection new		add: MethodsAndSourcesView;		add: DataAndSourcesView;		add: PkgClassesAndSourcesView;		add: PkgNameSpacesAndSourcesView;		yourself</body><body package="Store-DB-Pundles" selector="dbTables">dbTables	"Answer an ordered collection of classes that are represented by DB tables."	^OrderedCollection new		add: ClassRecord; 		add: NameSpaceRecord; 		add: Package; 		add: ParcelRecord; 		add: PkgClasses; 		add: PkgNameSpaces; 		add: Method; 		add: Methods; 		add: Blob; 		add: BinaryBlob; 		add: Blessing;		add: Bundle; 		add: Bundles; 		add: Packages;		add: DataElement; 		add: Data; 		add: DatabaseIdentifier;		add: Files;		add: FileRecord;		add: Properties;		add: PropertyRecord;		yourself</body><body package="Store-DB-Pundles" selector="dbViews">dbViews	"Answer an ordered collection of classes that are represented by OB views"	"Note, these are only the two table views. Other views are #dbSourcesViews."	^OrderedCollection new		add: MethodsView; 		add: PkgClassesView; 		add: PkgMetaclassesView; 		add: PkgNameSpacesView;		add: DataView;		add: PropertiesView;		yourself.</body><body package="Store-DB-Pundles" selector="deinstallPkgs">deinstallPkgs	"self deinstallPkgs "	Method dropMethodRetrievalIndex.	self dropPkgViews.	self dropPkgTables.	Transcript		cr;		show: (#DoneBang &lt;&lt; #store &gt;&gt; 'Done!') asString</body><body package="Store-DB-Pundles" selector="dropPkgTables">dropPkgTables	self dbTables reverseDo: 		[ :aClass | aClass dropTableForClass ]</body><body package="Store-DB-Pundles" selector="dropPkgViews">dropPkgViews	self dbViews , self dbSourcesViews reverseDo: 		[:each | 		each resetSession.		each dropViewForClass]</body><body package="Store-DB-Pundles" selector="installPkgs">installPkgs	"self installPkgs "	self createPkgTables.	self createPkgViews.	self createTableIndexes.	Transcript		cr;		show: (#DoneBang &lt;&lt; #store &gt;&gt; 'Done!') asString</body><body package="Store-DB-Pundles" selector="printNamesOf:on:">printNamesOf: aComponentList on: aStream 	"Print the names of views and all column names"	aComponentList do: 		[:eachClass | 		aStream			cr;			nextPutAll: 'Table: ' , (self broker tableNameWithPrefix: eachClass);			cr;			nextPutAll: '-----';			cr.		eachClass columnNames do: 			[:eachName | 			| columnType |			columnType := eachClass fieldTypes at: eachName ifAbsent: [#String].			aStream				nextPutAll: (self broker columnName: eachName for: eachClass);				tab;				nextPutAll: columnType asString;				cr]]</body><body package="Store-DB-Pundles" selector="resetPkgViews">resetPkgViews	self dbViews , self dbSourcesViews reverseDo: [:each | each resetSession]</body><body package="Store-DB-Pundles" selector="resetSessions">resetSessions	"self resetSessions"	self dbSessions reverseDo: [:each | each resetSession].	self resetPkgViews.	Package initializeCache.	Bundle initializeCache.</body></methods><methods><class-id>Store.Package class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="imageClass">imageClass	^PackageModel</body><body package="Store-DB-Pundles" selector="parcelRecordClass">parcelRecordClass	"Answer a class which is used when publishing binary to db."	^ParcelRecord</body><body package="Store-DB-Pundles" selector="partClass">partClass	^Packages</body><body package="StoreForGlorpVWUI" selector="storeDatabaseClass">storeDatabaseClass	^Store.Glorp.StorePackage</body></methods><methods><class-id>Store.Package class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="allNonBinaryNames">allNonBinaryNames	| names |	names := super allNonBinaryNames.	^Notice 		show: #GettingTheListOfPackages &lt;&lt; #dialogs &gt;&gt; 'Getting the list of packages...'		while: [names select: [:each | (self allVersionsWithName: each) allSatisfy: [:eachPackage | eachPackage parcelID isNil]]]</body><body package="Store-DB-Pundles" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_PackageName' #('name'))		#('ST_PackageTimestamp' #('timeStamp'))		#('ST_PackageVersion' #('version'))		#('ST_PackageProperties' #('propertiesID'))		#('ST_PackageGCSupport' #('trace'))		)</body></methods><methods><class-id>Store.BundlesView</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="bundleComment">bundleComment	^bundleComment</body><body package="Store-DB-Pundles" selector="bundleComment:">bundleComment: aValue	bundleComment := aValue</body><body package="Store-DB-Pundles" selector="bundleRef">bundleRef	^bundleRef</body><body package="Store-DB-Pundles" selector="bundleRef:">bundleRef: aValue	bundleRef := aValue</body><body package="Store-DB-Pundles" selector="expression">expression	^expression</body><body package="Store-DB-Pundles" selector="expression:">expression: aValue	expression := aValue</body><body package="Store-DB-Pundles" selector="seqNumber">seqNumber	^seqNumber</body><body package="Store-DB-Pundles" selector="seqNumber:">seqNumber: aValue	seqNumber := aValue</body></methods><methods><class-id>Store.BundlesView class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="childReference">childReference		^'subBundleRef'</body><body package="Store-DB-Pundles" selector="parentReference">parentReference	^'bundleRef'</body><body package="Store-DB-Pundles" selector="referencedClass">referencedClass	^Bundle</body><body package="Store-DB-Pundles" selector="subCollectionClass">subCollectionClass	^Bundles</body></methods><methods><class-id>Store.BundlesView class</class-id> <category>session</category><body package="Store-DB-Pundles" selector="bundleSession">bundleSession	"BundleSession := nil "	( self isSessionValid: BundleSession)		ifFalse: 			[BundleSession := self broker  getNewSession.			BundleSession bindOutput: self newPrimed.			BundleSession bindInput: Bundle new.			BundleSession prepare: 					( self newSQL						selectAll;						where;						column: #bundleRef equalTo: ':primaryKey') ].	^BundleSession</body><body package="Store-DB-Pundles" selector="resetSession">resetSession	BundleSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: BundleSession].		BundleSession := nil]</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="cleanUpOverrides">cleanUpOverrides	pundleModel ifNotNil: [pundleModel cleanUpOverrides]</body><body package="Atomic Compiling and Loading" selector="completedAnalysis">completedAnalysis	^completedAnalysis</body><body package="Atomic Compiling and Loading" selector="hasRunPrerequisites">hasRunPrerequisites	^hasRunPrerequisites</body><body package="Atomic Compiling and Loading" selector="hasRunPrerequisites:">hasRunPrerequisites: aBoolean		hasRunPrerequisites := aBoolean</body><body package="Atomic Compiling and Loading" selector="installed">installed	^installed</body><body package="Atomic Compiling and Loading" selector="installed:">installed: aBoolean	installed := aBoolean</body><body package="Atomic Compiling and Loading" selector="owningComponent">owningComponent	^parentInstallObject ifNotNil: [:value | value pundle]</body><body package="Atomic Compiling and Loading" selector="parentInstallObject">parentInstallObject	^parentInstallObject</body><body package="Atomic Compiling and Loading" selector="parentInstallObject:">parentInstallObject: aPundleInstall		parentInstallObject := aPundleInstall</body><body package="Atomic Compiling and Loading" selector="pundle">pundle	^pundle</body><body package="Atomic Compiling and Loading" selector="pundle:">pundle: aStoreBundleOrPackage	pundle := aStoreBundleOrPackage</body><body package="Atomic Compiling and Loading" selector="pundleModel">pundleModel	^pundleModel</body><body package="Atomic Compiling and Loading" selector="pundleModel:">pundleModel: aPundleModel	pundleModel := aPundleModel</body><body package="Atomic Compiling and Loading" selector="smartMarkInstalled">smartMarkInstalled		completedAnalysis ifTrue: [self installed: true]</body><body package="Atomic Compiling and Loading" selector="topComponent">topComponent	parentInstallObject ifNil: [^self].	^parentInstallObject topComponent</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="runPostLoadUsing:">runPostLoadUsing: anAtomicAnalysisLoader	self subclassResponsibility</body><body package="Atomic Compiling and Loading" selector="runPreLoad">runPreLoad	self subclassResponsibility</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="isBundle">isBundle	^false</body><body package="Atomic Compiling and Loading" selector="isPackage">isPackage	^false</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading" selector="initialize">initialize	super initialize.	installed := false.	hasRunPostload := hasRunPrerequisites := completedAnalysis := hasRunPreload := false</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: ${.	aStream nextPutAll: pundle name.	aStream nextPutAll: '} '</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>analysis</category><body package="Atomic Compiling and Loading" selector="analyzeUsing:">analyzeUsing: anAtomicAnalysisLoader	self subclassResponsibility</body></methods><methods><class-id>Store.PundleInstall</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="visit:">visit: aBlock	aBlock value: self</body></methods><methods><class-id>Store.PundleInstall class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="new">new	^super new initialize</body><body package="Atomic Compiling and Loading" selector="pundle:">pundle: aStoreBundleOrPackage	| instance |	instance := self new.	instance pundle: aStoreBundleOrPackage.	^instance</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>analysis</category><body package="Atomic Compiling and Loading" selector="addClass:">addClass: aStoreClass	| classes |	classes := loadingDictionary at: #classes ifAbsentPut: [OrderedCollection new].	classes add: (aStoreClass asShadowedObjectIn: pundle)</body><body package="Atomic Compiling and Loading" selector="addMethod:">addMethod: aStoreMethod	| methods shadowedMethod |	shadowedMethod := (aStoreMethod asShadowedObjectIn: pundle).	methods := shadowedMethod ctype 		ifTrue: [loadingDictionary at: #ctypes ifAbsentPut: [OrderedCollection new]]		ifFalse: 			[shadowedMethod extension				ifTrue: [loadingDictionary at: #extensions ifAbsentPut: [OrderedCollection new]]				ifFalse: [loadingDictionary at: #methods ifAbsentPut: [OrderedCollection new]]].	methods add: shadowedMethod</body><body package="Atomic Compiling and Loading" selector="addNamespace:">addNamespace: aStoreNamespace	| namespaces |	namespaces := loadingDictionary at: #namespaces ifAbsentPut: [OrderedCollection new].	namespaces add: (aStoreNamespace asShadowedObjectIn: pundle)</body><body package="Atomic Compiling and Loading" selector="addShared:">addShared: aStoreSharedVariable	| shareds |	shareds := loadingDictionary at: #shareds ifAbsentPut: [OrderedCollection new].	shareds add: (aStoreSharedVariable asShadowedObjectIn: pundle)</body><body package="Atomic Compiling and Loading" selector="analyzeUsing:">analyzeUsing: anAtomicAnalysisLoader	(Analyzing for: pundle) started.	anAtomicAnalysisLoader lastPundleWorkedOn: pundle.	(pundle binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]) ifTrue: 		[EarlyInstallNotice raiseSignal.		pundle runPreLoad.		(Analyzing for: pundle) finished.		pundle binLoadWithin: self owningComponent using: nil.		^installed := completedAnalysis := true].	self gatherDefinitionsInto: anAtomicAnalysisLoader.	completedAnalysis := true.	(pundle propertyAt: #postLoadBlock) ifNotNil: [needsEarlyInstall := true].	(Analyzing for: pundle) finished.	(((pundle propertyAt: #installBeforeContinuing ifAbsent: [self]) == self) not  or: [needsEarlyInstall]) ifTrue: 		[EarlyInstallNotice raiseSignal].</body><body package="Atomic Compiling and Loading" selector="copyLocalInstallTo:">copyLocalInstallTo: anAtomicAnalysisLoader	| definitions |	definitions := loadingDictionary at: #namespaces ifAbsent: [OrderedCollection new].	anAtomicAnalysisLoader addAllNamespaces: definitions.	definitions := loadingDictionary at: #classes ifAbsent: [OrderedCollection new].	anAtomicAnalysisLoader addAllClasses: definitions.	definitions := loadingDictionary at: #shareds ifAbsent: [OrderedCollection new].	anAtomicAnalysisLoader addAllShareds: definitions.	definitions := loadingDictionary at: #ctypes ifAbsent: [OrderedCollection new].	anAtomicAnalysisLoader addAllCTypeMethods: definitions.	definitions := loadingDictionary at: #extensions ifAbsent: [OrderedCollection new].	anAtomicAnalysisLoader addAllExtensionMethods: definitions.	definitions := loadingDictionary at: #methods ifAbsent: [OrderedCollection new].	anAtomicAnalysisLoader addAllMethods: definitions</body><body package="Atomic Compiling and Loading" selector="gatherAndAnalyzeClass:using:">gatherAndAnalyzeClass: aStoreClass using: anAtomicAnalysisLoader	"The analysis loader holds a world of namespaces and owners that we are going to install in the world.	We look and see, if there is a definition in the real world, OR in the analysis world that we are about to redefine.	If so, that means we're about to cause an early install. None the less, we have to continue gathering things"	(hasInstalledEarly not and: [anAtomicAnalysisLoader redefinesClass: aStoreClass]) ifTrue: 		[EarlyInstallNotice raiseSignal.		hasInstalledEarly := true].	needsEarlyInstall ifFalse:		[(self classCausesEarlyInstall: aStoreClass using: anAtomicAnalysisLoader) ifTrue: 			[needsPackageRecompile := needsEarlyInstall := true]].	self addClass: aStoreClass.</body><body package="Atomic Compiling and Loading" selector="gatherAndAnalyzeMethod:using:">gatherAndAnalyzeMethod: aStoreMethod using: anAtomicAnalysisLoader	"We set needsEarlyInstall to true if there are scanner/compiler/externalInterface methods"	anAtomicAnalysisLoader dllccLoaded ifFalse:		[(self needsDLLCC: aStoreMethod) ifTrue: [NoDLLCCNotification raiseRequestWith: self pundle]].	needsEarlyInstall ifFalse:		[(self methodCausesEarlyInstall: aStoreMethod using: anAtomicAnalysisLoader) ifTrue: [needsEarlyInstall := true]].	self addMethod: aStoreMethod</body><body package="Atomic Compiling and Loading" selector="gatherAndAnalyzeNamespace:using:">gatherAndAnalyzeNamespace: aStoreNamespace using: anAtomicAnalysisLoader	"The analysis loader holds a world of namespaces and owners that we are going to install in the world.	We look and see, if there is a definition in the real world, OR in the analysis world that we are about to redefine.	If so, that means we're about to cause an early install. None the less, we have to continue gathering things"	(hasInstalledEarly not and: [anAtomicAnalysisLoader redefinesNamespace: aStoreNamespace]) ifTrue:		[EarlyInstallNotice raiseSignal.		hasInstalledEarly := true].	self addNamespace: aStoreNamespace.</body><body package="Atomic Compiling and Loading" selector="gatherAndAnalyzeShared:using:">gatherAndAnalyzeShared: aStoreSharedVariable using: anAtomicAnalysisLoader	self addShared: aStoreSharedVariable.</body><body package="Atomic Compiling and Loading" selector="gatherDefinitionsInto:">gatherDefinitionsInto: anAtomicAnalysisLoader	pundle getImagePundle isNil		ifTrue: [self gatherNewDefinitionsInto: anAtomicAnalysisLoader]		ifFalse: [self gatherDeltaDefinitionsInto: anAtomicAnalysisLoader].	self copyLocalInstallTo: anAtomicAnalysisLoader</body><body package="Atomic Compiling and Loading" selector="gatherDeltaDefinitionsInto:">gatherDeltaDefinitionsInto: anAtomicAnalysisLoader	(pundle primaryKey = (pundleModel := pundle getImagePundle) dbTrace and: [pundleModel hasBeenModified not]) ifTrue: [^self].	packageComparitor := PackageComparitor differencesBetween: pundle and: pundleModel.	packageComparitor hasDifferences ifFalse: [^self].	packageComparitor mainPackageNamespaces do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	packageComparitor mainPackageClasses do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	packageComparitor mainPackageShareds do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	packageComparitor mainPackageMethods do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	self willClassRemovalAffectAnotherPackage ifTrue: [needsEarlyInstall := true].</body><body package="Atomic Compiling and Loading" selector="gatherNewDefinitionsInto:">gatherNewDefinitionsInto: anAtomicAnalysisLoader		pundle namespaces do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	pundle classDefinitions do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	pundle sharedVariables do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader].	pundle methods do: [:each | each gatherAndAnalyzeInto: self using: anAtomicAnalysisLoader]</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="hasSomethingAnalyzed">hasSomethingAnalyzed	^completedAnalysis</body><body package="Atomic Compiling and Loading" selector="isPackage">isPackage	^true</body><body package="Atomic Compiling and Loading" selector="willClassRemovalAffectAnotherPackage">willClassRemovalAffectAnotherPackage	"Are there classes NOT in my package that are subclasses of any class that I need to remove from myself"		^packageComparitor sortedClassesToRemoveAfterLoad anySatisfy:		[:each | 		each correspondingImageClass notNil and: 			[each correspondingImageClass subclasses anySatisfy: 				[:eachSubclass | (Registry packageForClass: eachSubclass) name ~= pundleModel name]]]</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="loadingDictionaryClasses">loadingDictionaryClasses	^loadingDictionary at: #classes ifAbsent: [#()]</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="classCausesEarlyInstall:using:">classCausesEarlyInstall: aStoreClass using: anAtomicAnalysisLoader	"If the class is in the image then this must be an override, 	none the less, we can simply ask if it is of one of the gotcha classes"	| gotchaClassNames |	aStoreClass correspondingImageClass ifNotNil: [:value |		^(value nonMeta includesBehavior: Scanner) or: 			[value nonMeta includesBehavior: SmalltalkCompiler]].	gotchaClassNames := anAtomicAnalysisLoader earlyInstallClassNames.	^gotchaClassNames includes: aStoreClass superclassName</body><body package="Atomic Compiling and Loading" selector="methodCausesEarlyInstall:using:">methodCausesEarlyInstall: aStoreMethod using: anAtomicAnalysisLoader	"If the class is in the image, we can simply ask if it is of one of the gotcha classes or ExternalInterface"	| gotchaClassNames shadowedClassObject |	aStoreMethod correspondingImageClass ifNotNil: [:value |		^(value nonMeta includesBehavior: Scanner) or: 			[(value nonMeta includesBehavior: SmalltalkCompiler) or: 			[value nonMeta class = ExternalInterface]]].	"If we get here, the class is not in the image, so we ask the analysis world if the class's superclass is a gotcha class"	gotchaClassNames := anAtomicAnalysisLoader earlyInstallClassNames.	shadowedClassObject := self loadingDictionaryClasses 		detect: [:each | each longName = aStoreMethod className]		ifNone: [nil].	shadowedClassObject ifNil:		[shadowedClassObject := anAtomicAnalysisLoader loadingDictionaryClasses 			detect: [:each | each longName = aStoreMethod className]			ifNone: [^false]].	^gotchaClassNames includes: shadowedClassObject superclassName</body><body package="Atomic Compiling and Loading" selector="needsDLLCC:">needsDLLCC: aStoreMethod	| result index |	result := [Scanner new scanTokens: aStoreMethod definitionString]		on: Error		do: [:exception | exception return: #()].	index := result indexOf: #C:.	^index isZero		ifTrue: [false]		ifFalse: [(result at: index - 1) = #&lt;].</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading" selector="initialize">initialize	super initialize.	loadingDictionary := Dictionary new.	needsEarlyInstall := false.	hasInstalledEarly := false.	needsPackageRecompile := false</body></methods><methods><class-id>Store.PackageInstall</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="gatherDefinitionsToRemoveInto:">gatherDefinitionsToRemoveInto: aDictionary		packageComparitor ifNotNil:		[self insertRemovals: packageComparitor nameSpacesToRemoveAfterLoad ofType: #nameSpaces into: aDictionary.		self insertRemovals: packageComparitor methodsToRemoveAfterLoad ofType: #methods into: aDictionary.		self insertRemovals: packageComparitor sharedsToRemoveAfterLoad ofType: #shareds into: aDictionary.		self insertRemovals: packageComparitor sortedClassesToRemoveAfterLoad ofType: #classes into: aDictionary]</body><body package="Atomic Compiling and Loading" selector="insertRemovals:ofType:into:">insertRemovals: aCollection ofType: aSymbol into: aDictionary		| deletions |	^aCollection isEmpty ifFalse:		[deletions := aDictionary at: aSymbol ifAbsentPut: [OrderedCollection new].		deletions addAll: (aCollection collect: [:each | each -&gt; pundleModel])]</body><body package="Atomic Compiling and Loading" selector="runPostLoadUsing:">runPostLoadUsing: anAtomicAnalysisLoader	(installed not and: [hasRunPostload not and: [completedAnalysis]]) ifTrue: 		[pundle postLoad: pundleModel.		anAtomicAnalysisLoader hasUnloadableDefinitions			ifTrue: [pundleModel reconcileWithDbVersion: pundle]			ifFalse: [pundleModel markNotModified].		hasRunPostload := true].</body><body package="Atomic Compiling and Loading" selector="runPreLoad">runPreLoad	(completedAnalysis and: [hasRunPreload not]) ifTrue: 		[pundle runPreLoad ifFalse: [^false].		pundleModel := [pundle createImagePundle]			on: MessageNotUnderstood			do: [:exception | exception return: pundle storeModel].		hasRunPreload := true].	^true</body><body package="Atomic Compiling and Loading" selector="updateForPackageRecompile">updateForPackageRecompile	needsPackageRecompile ifTrue: 		[ | sortedClasses |		sortedClasses := SystemUtils sortForLoading: pundleModel definedClasses.		sortedClasses do:			[:each | 			pundleModel recompileMethodsFor: each class.			pundleModel recompileMethodsFor: each]]</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;=">&lt;= aStoreBlessing 	^self hasNoticeBlessingLevel 		ifTrue: 			[aStoreBlessing hasNoticeBlessingLevel 				ifTrue: [self timeStamp &gt;= aStoreBlessing timeStamp]				ifFalse: [false]]		ifFalse: 			[aStoreBlessing hasNoticeBlessingLevel				ifTrue: [true]				ifFalse: [self timeStamp &gt;= aStoreBlessing timeStamp]].</body><body package="Store-Database Model" selector="=">= aStoreBlessing	self class = aStoreBlessing class ifFalse: [^false].	self timestamp = aStoreBlessing timestamp ifFalse: [^false].	self username = aStoreBlessing username ifFalse: [^false].	self blessingLevel = aStoreBlessing blessingLevel ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>accessing</category><body package="Store-Database Model" selector="basicComment">basicComment	^comment.</body><body package="Store-Database Model" selector="basicComment:">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model" selector="basicSource">basicSource	^comment.</body><body package="Store-Database Model" selector="basicSource:">basicSource: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model" selector="blessingLevel">blessingLevel	^blessingLevel</body><body package="Store-Database Model" selector="blessingLevel:">blessingLevel: anInteger	anInteger isNil ifTrue: [self error: 'Invalid blessing level. Try running Glorp.ObsoleteBlessingPolicyManager initialize'].	blessingLevel := anInteger.</body><body package="Store-Database Model" selector="blessingName">blessingName	^((Dialect smalltalkAt: #Store ifAbsent: [^blessingLevel printString])		at: #Policies		ifAbsent: [blessingLevel printString]) blessingPolicy		blessingName: blessingLevel.</body><body package="Store-Database Model" selector="comment">comment	self basicComment yourSelf isNil ifTrue: [^''].	^self basicComment source</body><body package="Store-Database Model" selector="comment:">comment: aString	comment := StoreBlob forString: aString.</body><body package="Store-Database Model" selector="localTimestamp">localTimestamp	^TimeZone default universalToLocal: timestamp</body><body package="Store-Database Model" selector="printOn:">printOn: aStream	self printWideOn: aStream.</body><body package="Store-Database Model" selector="printTallOn:">printTallOn: aStream	| blessingName |	blessingName := self blessingName.	aStream		nextPutAll: '--- Blessed: ' , blessingName;		cr.	aStream		nextPutAll: '--- By: ' , self username;		cr.	aStream		nextPutAll: '--- On ';		print: timestamp;		cr.	comment yourSelf isNil ifFalse: [aStream nextPutAll: comment source].	aStream cr.</body><body package="Store-Database Model" selector="printWideOn:">printWideOn: aStream	aStream nextPutAll: '--- Blessed: ', self blessingName.	aStream nextPutAll: ' --- By: ', self username.	aStream 		nextPutAll: ' --- On ';		print: timestamp; cr.	comment yourSelf isNil ifFalse: [		aStream nextPutAll: comment source].	aStream cr.</body><body package="Store-Database Model" selector="timeStamp">timeStamp	^timestamp.</body><body package="Store-Database Model" selector="timestamp">timestamp	^timestamp.</body><body package="Store-Database Model" selector="timestamp:">timestamp: aTimestamp	timestamp := aTimestamp.</body><body package="Store-Database Model" selector="trace">trace	^trace</body><body package="Store-Database Model" selector="trace:">trace: aStoreBlessing	trace := aStoreBlessing.</body><body package="Store-Database Model" selector="username">username	^(username isNil ifTrue: ['unknown user'] ifFalse: [username])</body><body package="Store-Database Model" selector="username:">username: aString	username := aString.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize	super initialize.	username := self currentUsername.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>reconciling</category><body package="Store-Database Model" selector="unreconcile">unreconcile	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	comment := comment isNil ifTrue: [nil] ifFalse: [comment glorpCopyIn: aDictionary].	trace := nil.</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>testing</category><body package="Store-Database Model" selector="hasNoticeBlessingLevel">hasNoticeBlessingLevel	"Return true if we are a notice blessing, and should thus sort behind everything else. It would be more polite to ask Store for the numeric level, but less portable"	^self blessingLevel = -1</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>printing</category><body package="Store-Database Model" selector="printMergeCommentHistoryOn:">printMergeCommentHistoryOn: aStream 	| commentStream character |	aStream		nextPutAll: (#BlessedBy &lt;&lt; #store &gt;&gt; 'Blessed by: ') asString;		nextPutAll: self username;		nextPutAll: (#AtLevel &lt;&lt; #store &gt;&gt; ' at level: ') asString;		nextPutAll: self blessingName;		nextPutAll: (#On &lt;&lt; #store &gt;&gt; ' on: ') asString;		nextPutAll: self timeStampString.	commentStream := self comment readStream.	commentStream atEnd ifFalse: 		[aStream			cr;			tab].	[commentStream atEnd] whileFalse: 		[character := commentStream next.		aStream nextPut: character.		character = Character cr ifTrue: [aStream tab]]</body><body package="Store-Database Model" selector="timeStampString">timeStampString	^self localTimestamp printString</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="fullDisplayString">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self displayString		with: self timeStampString		with: self username</body></methods><methods><class-id>Store.Comparing</class-id> <category>accessing</category><body package="Store-Difference Management" selector="actionText">actionText	^(#Comparing &lt;&lt; #store &gt;&gt; 'Comparing') asString</body></methods><methods><class-id>Store.Publishing</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="actionText">actionText	^(#Publishing &lt;&lt; #store &gt;&gt; 'Publishing') asString</body><body package="Store-IMG-Configurations" selector="componentName">componentName	^'&lt;1s&gt;(&lt;2s&gt;)' expandMacrosWith: subject pundle name with: subject version</body></methods><methods><class-id>Store.Gathering</class-id> <category>accessing</category><body package="Store-Difference Management" selector="actionText">actionText	^(#Gathering &lt;&lt; #store &gt;&gt; 'Gathering') asString</body><body package="Store-Difference Management" selector="componentName">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Core.RequestNilSuperClassNotification</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="defaultResumeValue">defaultResumeValue	^Class</body></methods><methods><class-id>Store.PseudoNamespaceCommentDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace definition].	aStream comment: commentObject value: mainObject</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	| commentObject |	commentObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace definition].	aStream comment: commentObject value: otherObject</body></methods><methods><class-id>Store.PseudoNamespaceCommentDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="resolutionClass">resolutionClass	^NamespaceCommentChangeResolver</body><body package="Store-Difference Management" selector="selectorListName">selectorListName	^(#BracketNameSpaceCommentBracket &lt;&lt; #store &gt;&gt; '[NameSpace Comment]') asString</body></methods><methods><class-id>Store.PseudoNamespaceCommentDifference</class-id> <category>loading</category><body package="Store-Difference Management" selector="loadMainDefinitionFrom:">loadMainDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageNamespace comment: self mainObject</body><body package="Store-Difference Management" selector="loadOtherDefinitionFrom:">loadOtherDefinitionFrom: aStoreClassOrNamespace	aStoreClassOrNamespace correspondingImageNamespace comment: self otherObject</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>event driven</category><body package="Store-Code Comparison" selector="getEventHandler">getEventHandler		^self</body><body package="Store-Code Comparison" selector="handleEvent:">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-Code Comparison" selector="handlerForMouseEvent:">handlerForMouseEvent: anEvent	"Give subparts a chance first, and then if I contain it, I'll take them."		^(super handlerForMouseEvent: anEvent)		ifNil:			[(self containsMouseEvent: anEvent)				ifTrue: [self]				ifFalse: [nil]]</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>scrolling</category><body package="Store-Code Comparison" selector="scrollOffsetHolder:">scrollOffsetHolder: aScrollOffsetHolder	aScrollOffsetHolder grid: 1 @ 18</body><body package="Store-Code Comparison" selector="scroller">scroller	^self findParent: [:each | each isKindOf: ScrollWrapper]</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="comparisonSource">comparisonSource	^comparisonSource</body><body package="Store-Code Comparison" selector="comparisonSource:">comparisonSource: anObject	comparisonSource := anObject.	self populate</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="initialize">initialize	super initialize.	expansionMemory := Dictionary new</body><body package="Store-Code Comparison" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	self beFullColumn</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="newBundleRollup:">newBundleRollup: aBundleName	| propertiesView |	propertiesView := CodeComponentPropertiesComparisonView new.	propertiesView rightProperties: (comparisonSource addedBundleProperties at: aBundleName ifAbsent: [Array new]).	propertiesView leftProperties: (comparisonSource removedBundleProperties at: aBundleName ifAbsent: [Array new]).	^propertiesView</body><body package="Store-Code Comparison" selector="newClassRollup:">newClassRollup: aBindingReference	| classView |	classView := ClassBlueprintComparisonView new.	classView		leftClass: (comparisonSource removedClasses at: aBindingReference ifAbsent: [nil])		leftMethods: (comparisonSource removedMethods at: aBindingReference ifAbsent: [Array new])		rightClass: (comparisonSource addedClasses at: aBindingReference ifAbsent: [nil])		rightMethods: (comparisonSource addedMethods at: aBindingReference ifAbsent: [Array new]).	^classView</body><body package="Store-Code Comparison" selector="newNamespaceRollup:">newNamespaceRollup: aBindingReference	| namespaceView |	namespaceView := NamespaceBlueprintComparisonView new.	namespaceView leftNamespace: (comparisonSource removedNamespaces at: aBindingReference ifAbsent: [nil])		rightNamespace: (comparisonSource addedNamespaces at: aBindingReference ifAbsent: [nil]).	^namespaceView</body><body package="Store-Code Comparison" selector="newPackageRollup:">newPackageRollup: aPackageName	| propertiesView |	propertiesView := CodeComponentPropertiesComparisonView new.	propertiesView rightProperties: (comparisonSource addedPackageProperties at: aPackageName ifAbsent: [Array new]).	propertiesView leftProperties: (comparisonSource removedPackageProperties at: aPackageName ifAbsent: [Array new]).	^propertiesView</body><body package="Store-Code Comparison" selector="newSharedVariableRollup:">newSharedVariableRollup: aBindingReference	| sharedVariableView |	sharedVariableView := SharedVariableBlueprintComparisonView new.	sharedVariableView leftSharedVariable: (comparisonSource removedSharedVariables at: aBindingReference ifAbsent: [nil])		rightSharedVariable: (comparisonSource addedSharedVariables at: aBindingReference ifAbsent: [nil]).	^sharedVariableView</body><body package="Store-Code Comparison" selector="populate">populate	| views classKeys namespaceKeys sharedVariableKeys packageKeys bundleKeys |	self updateExpansionMemory.	views := OrderedCollection new.	classKeys := comparisonSource allClassReferences.	namespaceKeys := comparisonSource allNamespaceReferences.	sharedVariableKeys := comparisonSource allSharedVariableReferences.	(((Set withAll: classKeys)		addAll: namespaceKeys;		addAll: sharedVariableKeys;		yourself) sorted: [:a :b | a path last &lt;= b path last])		do: 			[:each |			(namespaceKeys includes: each)				ifTrue: [views add: (self newNamespaceRollup: each)].			(classKeys includes: each)				ifTrue: [views add: (self newClassRollup: each)].			(sharedVariableKeys includes: each)				ifTrue: [views add: (self newSharedVariableRollup: each)]].	packageKeys := comparisonSource allPropertyPackageNames.	bundleKeys := comparisonSource allPropertyBundleNames.	((Set withAll: packageKeys)		addAll: bundleKeys;		yourself) sorted do: 			[:each |			(bundleKeys includes: each)				ifTrue: [views add: (self newBundleRollup: each)].			(packageKeys includes: each)				ifTrue: [views add: (self newPackageRollup: each)]].	self releaseAllComponents.	self addAll: views.	self recallExpansionMemory</body><body package="Store-Code Comparison" selector="recallExpansionMemory">recallExpansionMemory	self childrenDo: [:each | each restoreExpandedIn: expansionMemory].	self relayout</body><body package="Store-Code Comparison" selector="updateExpansionMemory">updateExpansionMemory	"Assumes all my children are Rollup views."	self childrenDo: 			[:each |			each				rememberIfExpandedIn: expansionMemory;				forgetIfCollapsedIn: expansionMemory]</body></methods><methods><class-id>Store.LoadOrSaveCompilationError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog warn: (#_1sCompilationErrorIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: Compilation error in &lt;2s&gt;' 		expandMacrosWith: messageText first 		with: messageText last)</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopy">postCopy	super postCopy.	definition := definition copy.	comment := comment copy.</body><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	definition := definition glorpCopyIn: aDictionary.	comment := comment glorpCopyIn: aDictionary.	(comment notNil and: [comment source isEmpty]) ifTrue: [comment := nil].</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>printing</category><body package="Store-Database Model" selector="printOn:">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self environmentName;		nextPut: $.;		nextPutAll: self name;		nextPut: $)</body><body package="StoreForGlorpVWUI" selector="shortItemString">shortItemString	^self name</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;">&lt; aStoreDefinitionObject	^self definition &lt; aStoreDefinitionObject definition.</body><body package="Store-Database Model" selector="&lt;=">&lt;= aStoreDefinitionObject	^self definition &lt;= aStoreDefinitionObject definition.</body><body package="Store-Database Model" selector="=">= aStoreDefinitionObject	^self class == aStoreDefinitionObject class and: [self reconcilesWith: aStoreDefinitionObject].</body><body package="Store-Database Model" selector="hash">hash	^self class hash hashMultiply bitXor: name hash</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteSymbol">absoluteSymbol	^self longName asSymbol</body><body package="Store-Database Model" selector="asText">asText	^self source asText.</body><body package="Store-Database Model" selector="basicDefinition">basicDefinition	^definition.</body><body package="Store-Database Model" selector="basicDefinition:">basicDefinition: aStoreBlob	definition := aStoreBlob.</body><body package="Store-Database Model" selector="comment:">comment: aString	comment := StoreBlob forString: aString.</body><body package="Store-Database Model" selector="definition">definition	^definition source</body><body package="Store-Database Model" selector="definition:">definition: aString	definition := StoreBlob forString: aString.</body><body package="Store-Database Model" selector="definitionAndComment">definitionAndComment	"ummmm"	^self definition, 'COMMENT:', self comment.</body><body package="StoreForGlorpVWUI" selector="definitionObject">definitionObject	^self</body><body package="Store-Database Model" selector="definitionString">definitionString	^definition source.</body><body package="Store-Database Model" selector="environmentName">environmentName	^environmentName</body><body package="Store-Database Model" selector="environmentName:">environmentName: aString	environmentName := aString.</body><body package="Store-Database Model" selector="environmentNameFromSmalltalk">environmentNameFromSmalltalk		| index startingFromSmalltalk |	index := self environmentName findString: '.Smalltalk' startingAt: 1.	startingFromSmalltalk := self environmentName copyFrom: index + 1 to: self environmentName size.	index isZero ifTrue: [(self environmentName findString: 'Root' startingAt: 1) isZero ifFalse: [index := 1]].	index isZero ifFalse: [index := startingFromSmalltalk indexOf: $.].	^startingFromSmalltalk copyFrom: index + 1 to: startingFromSmalltalk size</body><body package="Store-Database Model" selector="environmentString">environmentString	^self environmentName.</body><body package="Store-Database Model" selector="fullName">fullName	^self longName.</body><body package="Store-Database Model" selector="longName">longName	| env |	env := self environmentName.	^(env isNil or: [env isEmpty]) ifTrue: [self name] ifFalse: [env, '.', self name].</body><body package="Store-Database Model" selector="source">source	^self definition.</body><body package="Store-Database Model" selector="symbol">symbol	^self absoluteSymbol</body><body package="Store-Database Model" selector="versionString">versionString	^(#definitionObjectVersionString &lt;&lt; #store &gt;&gt; ' &lt;1s&gt;, &lt;2s&gt; ' expandMacrosWith: self timestamp printString with: self userName)</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreDefinitionObject	(super reconcilesWith: aStoreDefinitionObject) ifFalse: [^false].	self comment = aStoreDefinitionObject comment ifFalse: [^false].	self definition = aStoreDefinitionObject definition ifFalse: [^false].	self environmentName = aStoreDefinitionObject environmentName ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="unreconcile">unreconcile	super unreconcile.	comment isNil ifFalse: [comment unreconcile].	definition unreconcile.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>private</category><body package="Store-Database Model" selector="basicComment">basicComment	^comment</body><body package="Store-Database Model" selector="basicComment:">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model" selector="basicSource">basicSource	^definition.</body><body package="Store-Database Model" selector="basicSource:">basicSource: aStoreBlob	definition := aStoreBlob.</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>testing</category><body package="Store-Database Model" selector="isExtension">isExtension	^false</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>filling out</category><body package="Store-Database Model" selector="fileOutDefinitionOn:">fileOutDefinitionOn: aStream	aStream storeObjectDefinition: self.</body><body package="Store-Database Model" selector="fileOutOn:">fileOutOn: aSourceFileManager		aSourceFileManager storeObjectDefinition: self.	(self comment notNil and: [self comment notEmpty]) ifTrue:		[aSourceFileManager comment: self value: self comment]</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="fullDisplayString">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self longNameFromSmalltalk		with: self timeStampString		with: self username</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject</class-id> <category>fileIn/Out</category><body package="Store-Database Model" selector="fileOutDifferencesBetween:on:">fileOutDifferencesBetween: aStoreDefinitionObject on: aSourceCodeStream	self definitionString = aStoreDefinitionObject definitionString ifFalse:		[self fileOutSourceOn: aSourceCodeStream].	self comment = aStoreDefinitionObject comment ifFalse:		[aSourceCodeStream comment: self value: self comment]</body></methods><methods><class-id>Store.Glorp.StoreDefinitionObject class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="allNamesMatching:">allNamesMatching: aString		^self allNamesMatching: aString in: nil</body><body package="Store-Database Model" selector="allNamesMatching:in:">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copy replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body><body package="Store-Database Model" selector="allVersionsNamed:in:">allVersionsNamed: aString in: aSessionOrNil		| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model" selector="selectVersionNamed:">selectVersionNamed: aString	^self selectVersionNamed: aString in: nil</body><body package="Store-Database Model" selector="selectVersionNamed:in:">selectVersionNamed: aName in: aSessionOrNil		| versions |	versions := self allVersionsNamed: aName in: aSessionOrNil.	versions isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	versions size == 1 ifTrue: [^versions first].	^Dialog 		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (versions collect: [:m | m fullDisplayString])		values: versions		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>testing</category><body package="Store-Database Model" selector="isClass">isClass	^true.</body><body package="Store-Database Model" selector="isForClass">isForClass	^true</body><body package="Store-Database Model" selector="isForClassOrExtension">isForClassOrExtension	^true</body><body package="Store-Database Model" selector="isMeta">isMeta	^false</body><body package="Store-Database Model" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version."	| theClass |	theClass := self correspondingImageClass.	theClass isNil ifTrue: [^false].	^self = theClass asStoreClassDefinition.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreClassDefinition	"Return true if we appear to be the same entry, but potentially in a different database"	(super reconcilesWith: aStoreClassDefinition) ifFalse: [^false].	self superclassName = aStoreClassDefinition superclassName ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteClassName">absoluteClassName	^self environmentName , '.' , self name</body><body package="Store-Database Model" selector="actual">actual	^self correspondingImageClass</body><body package="Store-Database Model" selector="allInstVarNames">allInstVarNames	"Parse our class definition to extract the instance variable names. For compatibility with code highlighting. Probably VW-specific, both in use of throughAll: and in class definition format"	| stream names |	stream := self definition readStream.	stream throughAll: 'instanceVariableNames: '''.	names := stream upTo: $'.	^(Dialect tokensBasedOn: ' ' in: names) reject: [:each | each isEmpty].</body><body package="Store-Database Model" selector="correspondingImageClass">correspondingImageClass	"Return the image class that corresponds to our name. Note that they may not have the same information"	^(Dialect smalltalkAt: self longName ifAbsent: [nil])</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineClass:... version of this, not the #defineClass: version,	because the standard version calls link system too soon and also will create change objects too soon.	We support all old style class creation methods also: #subclass:... #variableByteSubclass:... and #variableSubclass:..	if there is something else, we just go with whatever there is"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineClass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'].	insertPoint := definitionString indexOfSubCollection: 'subclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadS'].	insertPoint := definitionString indexOfSubCollection: 'variableByteSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	insertPoint := definitionString indexOfSubCollection: 'variableSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	^definitionString</body><body package="Store-Database Model" selector="superclassName">superclassName	^superclassName</body><body package="Store-Database Model" selector="superclassName:">superclassName: aString	superclassName := aString.</body><body package="Store-Database Model" selector="xmlDefinition">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	^self</body><body package="Store-Database Model" selector="asStoreObjectInPackage:">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage classDefinitions		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: Store.Glorp.StoreClassDefinitionInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="StoreForGlorpVWUI" selector="asTag">asTag	^Store.ClassTag newClassName: self longName.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>comparing</category><body package="StoreForGlorpVWUI" selector="comparesTo:">comparesTo: anObject	^self class == anObject class and: [		self absoluteName = anObject absoluteName].</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver		startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineClass:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'super' value: (self convertVariableNodeToXML: (data at: 'superclass:')).	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'indexed-type' value: (data at: 'indexedType:') value asString.	self sax: driver tag: 'inst-vars' value: (data at: 'instanceVariableNames:') value.	self sax: driver tag: 'class-inst-vars' value: (data at: 'classInstanceVariableNames:') value.	self sax: driver tag: 'imports' value: (data at: 'imports:') value asString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	(data includesKey: 'attributes:') ifTrue:		[driver startElement: 'attributes' atts: nil.		(data at: 'attributes:') value do: [:attr |			(attr last isKindOf: Array)				ifTrue:					[driver startElement: attr first atts: nil.					attr last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: attr first value: attr last displayString]].		driver endElement].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>fileIn/Out</category><body package="Store-Database Model" selector="fileOutObjectType">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#class</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>IDE-support</category><body package="Store-Database Model" selector="instanceBehavior">instanceBehavior	^self</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource	| newClass |	newClass := [[[Object evaluatorClass evaluate: self definitionString notifying: nil logged: false]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: ClassBuilder buildFailureSignal			do:				[:exception | 				exception proceed]]					on: Error					do: 						[:exception | 						exception return: nil].	newClass ifNotNil: 		[(self comment notNil and: [self comment notEmpty]) ifTrue:			[newClass comment: self comment]].	^newClass</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	^self loadSource</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeClass: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedClassObject</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition</class-id> <category>printing</category><body package="Store-Database Model" selector="displayString">displayString	^self longNameFromSmalltalk</body></methods><methods><class-id>Store.Glorp.StoreClassDefinition class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="allNamesMatching:in:">allNamesMatching: aString in: aSessionOrNil	"For this, we only answer those that don't have the 'class' suffix (ie 'Class class')"	| results |	results := super allNamesMatching: aString in: aSessionOrNil.	^results reject: [:each | '* class' match: each]</body></methods><methods><class-id>Store.Subdef</class-id> <category>support</category><body package="Store-DB-Subdefs" selector="textForItem">textForItem	^self itemString asText</body></methods><methods><class-id>Store.Subdef</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="=">= aThing	^self sameAs: aThing</body><body package="Store-DB-Subdefs" selector="hash">hash	^self symbolKey hash</body><body package="Store-DB-Subdefs" selector="sameAsImThing:">sameAsImThing: aThing 	^aThing sameAsDBThing: self</body></methods><methods><class-id>Store.Subdef</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="creatorPackage">creatorPackage	^creatorPackage isNil		ifTrue: [ 0 ]		ifFalse: [	creatorPackage ]</body><body package="Store-DB-Subdefs" selector="creatorPackage:">creatorPackage: aPrimaryKey	creatorPackage := aPrimaryKey</body><body package="Store-DB-Subdefs" selector="creatorPackageVersion">creatorPackageVersion	| pkg |	^[creatorPackageVersion isNil		ifTrue: [self creatorPackage &gt; 0				ifTrue: 					[pkg := Package aRecordWithID: self creatorPackage.					pkg isNil ifTrue: [self error: #PackageNotFound &lt;&lt; #store &gt;&gt; 'Package not found.'].					creatorPackageVersion := pkg version]				ifFalse: [nil]]		ifFalse: [creatorPackageVersion]	]	on: self errorSignals	do: [ :ex | ex outer. nil]</body><body package="Store-DB-Subdefs" selector="creatorPackageVersion1">creatorPackageVersion1	^creatorPackageVersion isNil 		ifTrue: 			[self creatorPackage &gt; 0 				ifTrue: 					[| pkg user |					pkg := Package aRecordWithID: self creatorPackage.					pkg isNil 						ifTrue: 							[self error: #PackageNotFound &lt;&lt; #store &gt;&gt; 'Package not found.'].					user := self userName.					user isNil ifTrue: [user := (#unknown &lt;&lt; #store &gt;&gt; 'unknown') asString].					creatorPackageVersion := pkg name , '(' , pkg version , ',' , user , ')']				ifFalse: [nil]]		ifFalse: [creatorPackageVersion]</body><body package="Store-DB-Subdefs" selector="sourceCode">sourceCode	^sourceCodeString isNil		ifTrue: [sourceCodeString := self getDefinitionID: self sourceCodeID]		ifFalse: [sourceCodeString]</body><body package="Store-DB-Subdefs" selector="sourceCode:">sourceCode: bytes	sourceCodeString := bytes</body><body package="Store-DB-Subdefs" selector="sourceCodeID">sourceCodeID	^sourceCodeID</body><body package="Store-DB-Subdefs" selector="sourceCodeID:">sourceCodeID: anID	sourceCodeID := anID</body><body package="Store-DB-Subdefs" selector="symbolKey">symbolKey	^self name asSymbol</body></methods><methods><class-id>Store.Subdef</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="displayString">displayString	^self itemString</body><body package="Store-DB-Subdefs" selector="versionString">versionString	| str |	str := self creatorPackageVersion.	^str isNil		ifTrue: [super versionString]		ifFalse: 			[| un |			un := self userName.			un isNil ifTrue: [un := (#unknown &lt;&lt; #store &gt;&gt; 'unknown') asString].			' (' , str , ',' , un , ')']</body><body package="Store-DB-Subdefs" selector="versionString1">versionString1	| vstr |	vstr := self creatorPackageVersion.	^vstr isNil		ifTrue: [super versionString]		ifFalse: [vstr]</body></methods><methods><class-id>Store.Subdef</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="prepareInstallation">prepareInstallation	"Create first a record for the definition string."	self sourceCodeID isNil 		ifTrue: [self sourceCodeID: self definitionRecord primaryKey].</body><body package="Store-DB-Subdefs" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"	super prime.	sourceCodeString := Object new.	creatorPackageVersion := Object new.	creatorPackage := Object new.		"only used for version strings."</body><body package="Store-DB-Subdefs" selector="unprime">unprime	"Nil out the slots that do not map to table columns"	super unprime.	creatorPackageVersion := nil.	sourceCodeString := nil.	creatorPackage := nil</body></methods><methods><class-id>Store.Subdef class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>accessing</category><body package="Store-UI" selector="fillInFor:">fillInFor: aNameSpace	| namespacesInPackage finalNamespacesInPackage |	(Gathering for: aNameSpace name) started.	namespacesInPackage := (StoreNamespaceInPackage 		allVersionsWithName: aNameSpace name		in: (aNameSpace package ifNotNil: [:value | value session])) asList.	finalNamespacesInPackage :=  namespacesInPackage reject: [:each | each package isNil].	finalNamespacesInPackage size ~= namespacesInPackage size		ifTrue: [self reportUnpackagedDefinitionNamed: aNameSpace name].	self fillListWith: finalNamespacesInPackage.	(Gathering for: aNameSpace name) finished.</body><body package="Store-UI" selector="listTitle">listTitle		self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title</body><body package="Store-UI" selector="title">title		^title ifNil: [#VersionsOfNameSpace1s &lt;&lt; #store &gt;&gt; 'Versions of namespace &lt;1s&gt;' expandMacrosWith: self itemsInList list first name]</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>interface opening</category><body package="Store-UI" selector="compositeViewUsing:nameSize:longestTimestamp:longestUsername:in:">compositeViewUsing: aNamespace nameSize: longestName longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView	| iconPart currentStart nameLabel timestampLabel mainThing usernameLabel packageNameLabel |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aNamespace toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aNamespace longNameFromSmalltalk asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	timestampLabel := Label with: aNamespace definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aNamespace definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: aNamespace package name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestTimestamp := longestUsername :=  0.	items do:		[:each | 		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestName := (Label with: each longNameFromSmalltalk asText allBold attributes: widget textStyle) width max: longestName].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>menu</category><body package="Store-UI" selector="oneItemAndInImage">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection definition correspondingImageNamespace notNil]</body><body package="Store-UI" selector="onlyOneItemSelected">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI" selector="onlyTwoItemsSelected">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane</class-id> <category>actions</category><body package="Store-UI" selector="compareSelectionWith">compareSelectionWith	| nameSpace target |	nameSpace := self itemsInList selections first.	target := nameSpace class selectStoreVersionOf: nameSpace name in: nameSpace package session.	target ifNotNil: [TextDifferenceBrowser compare: nameSpace definitionString with: target definitionString]</body><body package="Store-UI" selector="compareVersions">compareVersions	| nameSpace target |	nameSpace := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	TextDifferenceBrowser compare: nameSpace definitionString with: target definitionString</body><body package="Store-UI" selector="containingPackages">containingPackages	| nameSpace packages |	nameSpace := self itemsInList selections first.	[(Gathering for: nameSpace name) started.	packages := StoreNamespaceInPackage allPackagesContaining: nameSpace.	(Gathering for: nameSpace name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: nameSpace longNameFromSmalltalk</body><body package="Store-UI" selector="fileOut">fileOut	| nameSpace fileName fileManager |	nameSpace := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (nameSpace longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: nameSpace package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			nameSpace fileOutOn: fileManager]				ensure: [fileManager close].			(FilingOut for: nameSpace package) finished].</body><body package="Store-UI" selector="loadNameSpace">loadNameSpace		| package nameSpace |	nameSpace := self itemsInList selections first.	package := nameSpace package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: [nameSpace loadSource].			(Loading for: package) finished].</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText emphasis: #bold.				updateText nextPutAll: each longName.				updateText emphasis: #none.				updateText cr.				updateText nextPutAll: each definition definitionString.				updateText cr.				updateText cr.				updateText emphasis: (Array with: #color-&gt; ColorValue navy).				updateText nextPutAll: each definition comment.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>aspects</category><body package="Store-UI" selector="afterDate">afterDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^afterDate isNil		ifTrue:			[afterDate := (Core.Date readFromString: '3/10/2010') asValue]		ifFalse:			[afterDate]</body><body package="Store-UI" selector="afterDateCheck">afterDateCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^afterDateCheck isNil		ifTrue:			[afterDateCheck := false asValue]		ifFalse:			[afterDateCheck]</body><body package="Store-UI" selector="beforeDate">beforeDate	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^beforeDate isNil		ifTrue:			[beforeDate := (Core.Date readFromString: '3/10/2010') asValue]		ifFalse:			[beforeDate]</body><body package="Store-UI" selector="beforeDateCheck">beforeDateCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^beforeDateCheck isNil		ifTrue:			[beforeDateCheck := false asValue]		ifFalse:			[beforeDateCheck]</body><body package="Store-UI" selector="blessingGreaterThan">blessingGreaterThan	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingGreaterThan isNil		ifTrue:			[blessingGreaterThan := nil asValue]		ifFalse:			[blessingGreaterThan]</body><body package="Store-UI" selector="blessingGreaterThanCheck">blessingGreaterThanCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingGreaterThanCheck isNil		ifTrue:			[blessingGreaterThanCheck := false asValue]		ifFalse:			[blessingGreaterThanCheck]</body><body package="Store-UI" selector="blessingLessThan">blessingLessThan	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLessThan isNil		ifTrue:			[blessingLessThan := nil asValue]		ifFalse:			[blessingLessThan]</body><body package="Store-UI" selector="blessingLessThanCheck">blessingLessThanCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLessThanCheck isNil		ifTrue:			[blessingLessThanCheck := false asValue]		ifFalse:			[blessingLessThanCheck]</body><body package="Store-UI" selector="blessingMenu">blessingMenu	^Policies blessingPolicy blessingLevelsMenu</body><body package="Store-UI" selector="nameLikeCheck">nameLikeCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameLikeCheck isNil		ifTrue:			[nameLikeCheck := false asValue]		ifFalse:			[nameLikeCheck]</body><body package="Store-UI" selector="pundleName">pundleName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleName isNil		ifTrue:			[pundleName := String new asValue]		ifFalse:			[pundleName]</body><body package="Store-UI" selector="versionLike">versionLike	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^versionLike isNil		ifTrue:			[versionLike := String new asValue]		ifFalse:			[versionLike]</body><body package="Store-UI" selector="versionLikeCheck">versionLikeCheck	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^versionLikeCheck isNil		ifTrue:			[versionLikeCheck := false asValue]		ifFalse:			[versionLikeCheck]</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>actions</category><body package="Store-UI" selector="enableAfterDate">enableAfterDate	(self widgetAt: #AfterDate) isEnabled: self afterDateCheck value</body><body package="Store-UI" selector="enableBeforeDate">enableBeforeDate	(self widgetAt: #BeforeDate) isEnabled: self beforeDateCheck value</body><body package="Store-UI" selector="enableBlessingGreater">enableBlessingGreater	(self widgetAt: #BlessingGreaterThan) isEnabled: self blessingGreaterThanCheck value</body><body package="Store-UI" selector="enableBlessingLess">enableBlessingLess	(self widgetAt: #BlessingLessThan) isEnabled: self blessingLessThanCheck value</body><body package="Store-UI" selector="enablePundleName">enablePundleName	(self widgetAt: #PundleName) isEnabled: self nameLikeCheck value</body><body package="Store-UI" selector="enableVerionLike">enableVerionLike	(self widgetAt: #VersionLike) isEnabled: self versionLikeCheck value</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>private</category><body package="Store-UI" selector="fillFilter">fillFilter	filter ifNil: [filter := DeletionToolFilter new].	filter pundleName: (self nameLikeCheck value ifTrue: [self pundleName value]).	filter versionLike: (self versionLikeCheck value ifTrue: [self versionLike value]).	filter beforeDate: (self beforeDateCheck value ifTrue: [self beforeDate value]).	filter afterDate: (self afterDateCheck value ifTrue: [self afterDate value]).	filter blessingGreater: (self blessingGreaterThanCheck value ifTrue: [self blessingGreaterThan value]).	filter blessingLess: (self blessingLessThanCheck value ifTrue: [self blessingLessThan value])</body><body package="Store-UI" selector="fillFrom:">fillFrom: aDeletionToolFilter	filter := aDeletionToolFilter.	filter pundleName ifNotNil:		[self pundleName value: filter pundleName.		self nameLikeCheck value: true].	filter versionLike ifNotNil:		[self versionLike value: filter versionLike.		self versionLikeCheck value: true].	filter beforeDate ifNotNil:		[self beforeDate value: filter beforeDate.		self beforeDateCheck value: true].	filter afterDate ifNotNil:		[self afterDate value: filter afterDate.		self afterDateCheck value: true].	filter blessingGreater ifNotNil:		[self blessingGreaterThan value: filter blessingGreater.		self blessingGreaterThanCheck value: true].	filter blessingLess ifNotNil:		[self blessingLessThan value: filter blessingLess.		self blessingLessThanCheck value: true].</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>accessing</category><body package="Store-UI" selector="filter">filter	^filter</body><body package="Store-UI" selector="filter:">filter: aDeletionToolFilter	filter := aDeletionToolFilter</body></methods><methods><class-id>Store.DeletionToolFilterTool</class-id> <category>interface opening</category><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self afterDateCheck onChangeSend: #enableAfterDate to: self.	self beforeDateCheck onChangeSend: #enableBeforeDate to: self.	self blessingGreaterThanCheck onChangeSend: #enableBlessingGreater to: self.	self blessingLessThanCheck onChangeSend: #enableBlessingLess to: self.	self nameLikeCheck onChangeSend: #enablePundleName to: self.	self versionLikeCheck onChangeSend: #enableVerionLike to: self.	self accept onChangeSend: #fillFilter to: self.	self fillFrom: filter</body></methods><methods><class-id>Store.PkgNameSpacesView</class-id> <category>private</category><body package="Store-DB-Records" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Records" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.PkgNameSpacesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="commentID">commentID	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: aValue	commentID := aValue</body><body package="Store-DB-Records" selector="definitionID">definitionID	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: aValue	definitionID := aValue</body><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: anInteger	"Set the receiver's definitionOrder."	definitionOrder := anInteger</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: aValue	environmentString := aValue</body><body package="Store-DB-Records" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: anObject	packageRef := anObject</body></methods><methods><class-id>Store.PkgNameSpacesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'nameSpaceRef'</body><body package="Store-DB-Records" selector="parentReference">parentReference	^'packageRef'</body><body package="Store-DB-Records" selector="referencedClass">referencedClass	^NameSpaceRecord</body><body package="Store-DB-Records" selector="subCollectionClass">subCollectionClass	^PkgNameSpaces</body></methods><methods><class-id>Store.PkgNameSpacesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="nameSpacesSession">nameSpacesSession	"NameSpacesSession := nil"	( self isSessionValid: NameSpacesSession)		ifFalse:			[NameSpacesSession := self broker getNewSession.			NameSpacesSession bindOutput: self newPrimed.			NameSpacesSession bindInput: NameSpaceRecord new.			NameSpacesSession prepare: 						(self newSQL							selectAll;							where;							column: #packageRef  equalTo: ':primaryKey';							orderBy: #definitionOrder) ].	^NameSpacesSession</body><body package="Store-DB-Records" selector="resetSession">resetSession	NameSpacesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: NameSpacesSession].		NameSpacesSession := nil]</body></methods><methods><class-id>Store.PkgNameSpacesView class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>initialize-release</category><body package="Store-Database" selector="initialize">initialize	classes := IdentitySet new.	nameSpaces := IdentitySet new.	methodDict := IdentityDictionary new.	classesWithoutSuper := IdentitySet new.	classesWithNoEnvironment := IdentitySet new.	overrides := OrderedCollection new.	nameSpacesWithNoEnvironment := IdentitySet new.	wholePackage := true.</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>load preparation</category><body package="Store-Database" selector="removeClasses">removeClasses	classes do: [:cls | cls removeFromSystem]</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>dialog</category><body package="Store-Database" selector="classEnvironmentProblemWarning:">classEnvironmentProblemWarning: warnStream 	classesWithNoEnvironment isEmpty ifTrue: [^self].	warnStream		nextPutAll: (#WarningPackage1sNnotBeLoadedNN &lt;&lt; #store 					&gt;&gt; 'Warning: Package "&lt;1s&gt;" cannot be loaded.&lt;n&gt;&lt;n&gt;' 						expandMacrosWith: toPackage name);		nextPutAll: (#TheFollowingClassesCkageBeingLoaded &lt;&lt; #store 					&gt;&gt; 'The following classes cannot be loaded because their environment is not in the image nor in the package being loaded:  ') 						asString;		cr.	classesWithNoEnvironment do: 			[:cls | 			warnStream 				nextPutAll: (#_1sEnvironmentPath2sN &lt;&lt; #store 						&gt;&gt; '    &lt;1s&gt; (environment path: &lt;2s&gt;)&lt;n&gt;' expandMacrosWith: cls name							with: cls environmentString)].	warnStream cr</body><body package="Store-Database" selector="classWarning:">classWarning: warnStream 	classes isEmpty ifTrue: [^self].	classes do: 			[:cls | 			| pkg |			pkg := Registry containingPackageForClass: cls.			warnStream				nextPutAll: '    ';				nextPutAll: cls name.			pkg isNil 				ifTrue: 					[warnStream 						nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store								&gt;&gt; ' (already loaded but not packaged)') asString]				ifFalse: 					[warnStream 						nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name)].			warnStream cr].	warnStream cr</body><body package="Store-Database" selector="dataWarning:">dataWarning: warnStream 	"Write to the warnStream a message describing which data overlap."	| writeHeader |	writeHeader := true.	dataDict keysAndValuesDo: 			[:ns :meths | 			( nameSpaces includes: ns ) 				ifFalse: 					[| pkgDict unpkg |					writeHeader 						ifTrue: 							[warnStream								nextPutAll: (#AffectedData &lt;&lt; #store &gt;&gt; 'Affected Data') asString;								cr;								nextPutAll: '-------------';								cr.							writeHeader := false].					pkgDict := IdentityDictionary new.					unpkg := OrderedCollection new.					meths do: 							[:dataKey | 							| pkg keys |							pkg := Registry containingPackageForDataKey: dataKey nameSpace: ns.							keys := pkg isNil 										ifTrue: [unpkg]										ifFalse: 											[pkgDict at: pkg ifAbsent: [pkgDict at: pkg put: OrderedCollection new]].							keys add: dataKey].					warnStream 						nextPutAll: (#DataFromClass1pN &lt;&lt; #store &gt;&gt; '    data from class &lt;1p&gt;:&lt;n&gt;' 								expandMacrosWith: ns).					pkgDict keysAndValuesDo: 							[:pkg :keys | 							keys do: 									[:aKey | 									warnStream										nextPutAll: '        ';										nextPutAll: aKey.									warnStream 										nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name); cr]].					unpkg do: 							[:aKey | 							warnStream								nextPutAll: '        ';								nextPutAll: aKey.							warnStream 								nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store 										&gt;&gt; ' (already loaded but not packaged)') asString.							warnStream cr]]].	writeHeader ifFalse: [warnStream cr]</body><body package="Store-Database" selector="methodWarning:">methodWarning: warnStream 	"Write to the warnStream a message describing which methods overlap."	| writeHeader |	writeHeader := true.	methodDict keysAndValuesDo: 			[:cls :meths | 			( classes includes: (cls isMeta ifTrue: [ cls soleInstance ] ifFalse: [ cls ] ) ) 				ifFalse: 					[| pkgDict unpkg |					writeHeader 						ifTrue: 							[warnStream								nextPutAll: (#AffectedMethods &lt;&lt; #store &gt;&gt; 'Affected Methods') asString;								cr;								nextPutAll: '----------------';								cr.							writeHeader := false].					pkgDict := IdentityDictionary new.					unpkg := OrderedCollection new.					meths do: 							[:selector | 							| pkg sels |							pkg := Registry containingPackageForSelector: selector class: cls.							sels := (pkg == nil or: [pkg isNullPackage]) 										ifTrue: [unpkg]										ifFalse: 											[pkgDict at: pkg ifAbsent: [pkgDict at: pkg put: OrderedCollection new]].							sels add: selector].					warnStream 						nextPutAll: (#MethodsFromClass1pN &lt;&lt; #store &gt;&gt; '    methods from class &lt;1p&gt;:&lt;n&gt;' expandMacrosWith: cls).					pkgDict keysAndValuesDo: 							[:pkg :sels | 							sels do: 									[:aSel | 									warnStream										nextPutAll: '        ';										nextPutAll: aSel.									warnStream 										nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name).									warnStream cr]].					unpkg do: 							[:aSel | 							warnStream								nextPutAll: '        ';								nextPutAll: aSel.							warnStream 								nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store										&gt;&gt; ' (already loaded but not packaged)') asString.							warnStream cr]]].	methodDict isEmpty ifFalse: [warnStream cr]</body><body package="Store-Database" selector="nameSpaceEnvironmentProblemWarning:">nameSpaceEnvironmentProblemWarning: warnStream 	nameSpacesWithNoEnvironment isEmpty ifTrue: [^self].	warnStream		nextPutAll: ((#WarningPackage1sNnotBeLoadedNN &lt;&lt; #store &gt;&gt; 'Warning: Package "&lt;1s&gt;" cannot be loaded.&lt;n&gt;&lt;n&gt;') 					expandMacrosWith: toPackage name);		nextPutAll: (#TheFollowingNamespacCkageBeingLoaded &lt;&lt; #store &gt;&gt; 'The following namespaces cannot be loaded because their environment&lt;n&gt; is not in the image nor in the package being loaded:  ') 					expandMacros;		cr.	nameSpacesWithNoEnvironment do: 			[:ns | 			warnStream				nextPutAll: ((#_1sEnvironmentOf2s &lt;&lt; #store &gt;&gt; '    &lt;1s&gt; (environment of &lt;2s&gt;)') expandMacrosWith: ns name							with: ns environmentString);				cr].	warnStream cr</body><body package="Store-Database" selector="nameSpaceWarning:">nameSpaceWarning: warnStream 	nameSpaces isEmpty ifTrue: [^self].	nameSpaces do: 			[:ns | 			| pkg |			pkg := Registry containingPackageForNameSpace: ns.			warnStream				nextPutAll: '    ';				nextPutAll: ns fullName.			pkg == nil 				ifTrue: 					[warnStream nextPutAll: (#AlreadyLoadedButNotPackaged &lt;&lt; #store &gt;&gt; ' (already loaded but not packaged)') asString]				ifFalse: 					[warnStream 						nextPutAll: ((#DefinedInPackage1s &lt;&lt; #store &gt;&gt; ' (defined in package "&lt;1s&gt;")') expandMacrosWith: pkg name)].			warnStream cr].	warnStream cr</body><body package="Store-Database" selector="overlapWarning:">overlapWarning: warnStream 	warnStream		nextPutAll: (#WarningOverlappingPackages &lt;&lt; #store 					&gt;&gt; 'Warning: Overlapping packages') asString;		cr;		nextPutAll: '-----------------------';		cr.	warnStream 		nextPutAll: (#_1sThePackageToErThan2sNN &lt;&lt; #store 				&gt;&gt; '"&lt;1s&gt;", the package to be loaded, contains method and/or class definitions which already exist in the image, but in packages other than "&lt;2s&gt;".&lt;n&gt;&lt;n&gt;' 					expandMacrosWith: toPackage name					with: toPackage name).	warnStream 		nextPutAll: (#ProceedingWillDeleteRomPackage1s &lt;&lt; #store 				&gt;&gt; 'Proceeding will delete the overlapping classes along with their methods and load the classes and methods from package "&lt;1s&gt;".  ' 				expandMacrosWith: toPackage name).	warnStream 		nextPutAll: (#ThePackagesCurrentlyPackage1sNN &lt;&lt; #store 				&gt;&gt; 'The packages currently containing the definitions will be modified and the newly loaded definitions will be in package "&lt;1s&gt;".&lt;n&gt;&lt;n&gt;' 					expandMacrosWith: toPackage name)</body><body package="Store-Database" selector="stopDialog">stopDialog	| warnStream theText |	warnStream := WriteStream on: (String new: 300).	self superclassProblemWarning: warnStream.	self classEnvironmentProblemWarning: warnStream.	self nameSpaceEnvironmentProblemWarning: warnStream.	theText := warnStream contents.	^LoadAnalysisError raiseRequestErrorString: theText</body><body package="Store-Database" selector="superclassProblemWarning:">superclassProblemWarning: warnStream 	classesWithoutSuper isEmpty ifTrue: [^self].	warnStream		nextPutAll: (#WarningPackage1sNnotBeLoadedNN &lt;&lt; #store 					&gt;&gt; 'Warning: Package "&lt;1s&gt;" cannot be loaded.&lt;n&gt;&lt;n&gt;' 						expandMacrosWith: toPackage name);		nextPutAll: (#TheFollowingClassesAckageBeingLoaded &lt;&lt; #store 					&gt;&gt; 'The following classes cannot be loaded because their superclasses are neither in the image nor in the package being loaded: ') 						asString;		cr.	classesWithoutSuper do: 			[:cls | 			warnStream 				nextPutAll: (#_1sSubclassOf2sN &lt;&lt; #store 						&gt;&gt; '    &lt;1s&gt; (subclass of &lt;2s&gt;)&lt;n&gt;' expandMacrosWith: cls name							with: cls superclass)].	warnStream cr</body><body package="Store-Database" selector="warnDialog">warnDialog	| warnStream theText dialog |	warnStream := WriteStream on: (String new: 300).	self overlapWarning: warnStream.	self nameSpaceWarning: warnStream.	self classWarning: warnStream.	self methodWarning: warnStream.	self dataWarning: warnStream.	theText := warnStream contents asValue.	dialog := SimpleDialog new.	dialog builder aspectAt: #text put: theText.	^dialog openFrom: (UISpecification from: self class warningSpec)</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>accessing</category><body package="Store-Database" selector="classes:">classes: aClassList 	"Given a list of non-meta class definitions to be loaded (in the form of classes 	not  connected to the system (alien classes) or ClassDescriptions). 	Filter this list for classes which are loaded and in a different package. 	Set 'classes' to be these loaded classes. 	Also, into classesWithoutSuper put all classes to be loaded whose 	superclass is not in the image and is not in the package to be loaded."	"Contains hack 	Contrary to the comment, this method is sometimes given a list 	of MetaClasses. In this case we check if the class side is in the 	image."	self needsMoreWork.	classes := IdentitySet new.	classesWithoutSuper := IdentitySet new.	aClassList do: 		[ :each | 		self checkClassOrNameSpace: each absoluteName asClassNameOnly asSymbol.		each isMeta			ifFalse: 				[ self checkSuperClass: each against: aClassList.				self checkEnvironment: each against: #()				]			].</body><body package="Store-Database" selector="classes:nameSpaces:">classes: aClassList nameSpaces: aNameSpaceList	"Given a list of non-meta class definitions to be loaded (in the form of classes 	not  connected to the system (alien classes) or ClassDescriptions).  And	NameSpaceDescriptions.	Filter these lists for classes/namespaces which are loaded and in a different package. 	Set 'classes' / 'namespaces' to be these loaded classes. 	Also, into classesWithoutSuper put all classes to be loaded whose 	superclass is not in the image and is not in the package to be loaded.	Into classesWithoutNameSpaces, namespaceWithoutNameSpaces-	all the classes/namespaces whose namespace is not in the image or the	package to be loaded."	"Contains hack 	Contrary to the comment, this method is sometimes given a list 	of MetaClasses. In this case we check if the class side is in the 	image. (??)"	self needsMoreWork. 	aClassList do: 		[ :each |		self checkClassOrNameSpace: each absoluteName asClassNameOnly asSymbol.		each isMeta			ifFalse: 				[ self checkSuperClass: each against: aClassList.				self checkEnvironment: each against: aNameSpaceList.				]		].	aNameSpaceList do:		[ : each | 			self checkClassOrNameSpace: each absoluteSymbol.		self checkEnvironment: each against: aNameSpaceList		].</body><body package="Store-Database" selector="dataTT:">dataTT: aCollectionOfDBData 	"Given a list of data definitions to be loaded (in the form of 	a collection of DataElements).	Set 'dataDict' to be a dictionary mapping classes to	a collection of dataKeys which are already loaded. We already 	know they are in a different package, since this one is empty."self needsMoreWork. "ripple clone"	dataDict := IdentityDictionary new.	aCollectionOfDBData do: 		[:each | 		| dataKey ownerName |		dataKey := each dataKey.		ownerName := each environmentString.		( toPackage includesDataKey: dataKey ownerName: ownerName )			ifFalse: 				[ | owner |				owner := each owner.				owner notNil ifTrue: [self add: owner dataKey: dataKey ]				]		].</body><body package="Store-Database" selector="datumArrays:">datumArrays: aCollectionOfDatumArrays 	self needsMoreWork.  "ripple clone"</body><body package="Store-Database" selector="leafItems">leafItems	leafItems == nil		ifTrue: 			[ leafItems := withinBundle == nil				ifTrue: [ Set new ]				ifFalse: [ withinBundle leafItems collect: [ :p | p name ] ]			].	^leafItems</body><body package="Store-Database" selector="methodArrays:">methodArrays: aCollectionOfMethodArrays 	"Given a list of method definitions to be loaded (in the form of 	selector/compiledMethod/protocol triples).	Set 'methodDict' to be a dictionary mapping classes to	a collection of selectors which are already loaded. We already 	know they are in a different package, since this one is empty."	aCollectionOfMethodArrays do: 		[ :each |   | selector cName cls tcls |		selector := each at: 1.		tcls := (each at: 2) mclass.		cName := ( tcls isMeta						ifTrue: [ tcls soleInstance ]						ifFalse: [ tcls ]					) name.		cls := cName asStrictReference valueOrDo: [nil].		cls notNil			ifTrue: 				[ cls := tcls isMeta							ifTrue: [ cls class ]							ifFalse: [ cls ].				( cls includesSelector: selector )					ifTrue: 						[ | meths |						meths := methodDict at: cls ifAbsent: [ methodDict at: cls put: OrderedCollection new ].						meths add: selector						]				]		]</body><body package="Store-Database" selector="methodsTT:">methodsTT: aCollectionOfDBMethods 	"Given a list of method definitions to be loaded (in the form of 	a collection of Method).	Set 'methodDict' to be a dictionary mapping classes to	a collection of selectors which are already loaded. We already 	know they are in a different package, since this one is empty."	aCollectionOfDBMethods		do: 			[:each | 			| selector cName |			selector := each selector.			cName := each className.			(toPackage				includesSelector: selector				className: cName				meta: each isMeta)				ifFalse: 					[| cls |					cls := each myClass.					cls notNil ifTrue: [self addClass: cls selector: selector ]]].</body><body package="Store-Database" selector="nameSpaces:">nameSpaces: aNameSpaceList	"Given a list of namespaces to be loaded produce a list of alien ns 	NameSpaceDescriptions.	Filter this list for namespaces which are loaded and in a different package. 	Set 'namespaces' to be these loaded namespaces. 	Also, into namespaceWithoutNameSpaces-	all the namespaces whose namespace is not in the image or the	package to be loaded."	aNameSpaceList do: 		[ : each | 	self checkEnvironment: each against: aNameSpaceList ].</body><body package="Store-Database" selector="toPackage:">toPackage: aPackageModel	toPackage := aPackageModel</body><body package="Store-Database" selector="wholePackage:">wholePackage: aBoolean	wholePackage := aBoolean</body><body package="Store-Database" selector="withinBundle:">withinBundle: aBundle	withinBundle := aBundle</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>public</category><body package="Store-Database" selector="loadCanProceed">loadCanProceed	^self loadCanProceed: false.</body><body package="Store-Database" selector="loadCanProceed:">loadCanProceed: queryBoolean	( classesWithoutSuper isEmpty ) &amp; ( classesWithNoEnvironment isEmpty ) &amp;				( nameSpacesWithNoEnvironment isEmpty )		ifFalse: 	[ self stopDialog.  ^false ].	^self checkOverrides: queryBoolean</body><body package="Store-Database" selector="loadWarnings">loadWarnings	"Answer true if user appoved load depite warnings."	"obsoleted  by overrides"	| result |	( ( classes isEmpty ) &amp; ( nameSpaces isEmpty )			&amp; ( methodDict isEmpty ) &amp; ( dataDict isEmpty ) )		ifTrue: [ ^true ].	result := self warnDialog.	result  		ifTrue: [ self removeClasses ]. 	^result</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>private</category><body package="Store-Database" selector="add:dataKey:">add: owner dataKey: dataKey 	( owner includesDataKey: dataKey )		ifTrue: 			[ | data |			data := dataDict at: owner ifAbsent: [ dataDict at: owner put: OrderedCollection new ].			data add: dataKey			]</body><body package="Store-Database" selector="addClass:selector:">addClass: cls selector: selector 	 | meths pkg |	( cls includesSelector: selector )		ifTrue: 			[ pkg := Registry containingPackageForSelector: selector class: cls.			( ( pkg == nil ) or: [ self leafItems includes: pkg name ] )				ifFalse:					[ meths := methodDict at: cls ifAbsent: 						[ methodDict at: cls put: OrderedCollection new ].					meths add: selector					].			]</body><body package="Store-Database" selector="checkClassOrNameSpace:">checkClassOrNameSpace: aName		"Add classes to classes (and namespaces namespaces ) that: 		1) are not contained in toPackage and 2) are in the image"	( toPackage includesDefinitionOf: aName )		ifFalse: 			[ | obj pkg |			pkg := Registry containingPackageForSymbol: aName asSymbol.			pkg == nil				ifFalse: [ ( self leafItems includes: pkg name ) ifTrue: [ ^self ] ].			obj := aName asStrictReference valueOrDo: [ nil ].			obj == nil 				ifFalse: 	[ obj isForNameSpace ifTrue: [ nameSpaces add: obj ] ifFalse: [ classes add: obj ] ]			].</body><body package="Store-Database" selector="checkEnvironment:against:">checkEnvironment: model against: aNameSpaceList		"Check the superclass of the class. If it exists, or is in the image, ok.		Otherwise put the class into classesWithoutSuper."	| envName |	envName := model environmentString.	( envName == nil or: [ envName isEmpty ] )		ifTrue: [ ^self ].	( toPackage includesNameSpaceNamed: envName )		ifTrue: [ ^self ].	( ( envName asStrictReference isDefined ) or: 		[ aNameSpaceList contains: [ :ns | ns absoluteName = envName ] ]	) ifFalse: 		[ model isForNameSpace			ifTrue: [  nameSpacesWithNoEnvironment add: model ]			ifFalse: [ classesWithNoEnvironment add: model ].		].</body><body package="Store-Database" selector="checkSuperClass:against:">checkSuperClass: classModel against: aClassList		"Check the superclass of the class. If it exists, or is in the image, ok.		Otherwise put the class into classesWithoutSuper."	| superName |	superName := classModel superclass.	( superName = 'nil' or: 			[ ( superName asStrictReference isDefined ) or: 				[ aClassList contains: [ : clsRecord | clsRecord absoluteName = superName ] ]			] )  ifFalse: [ classesWithoutSuper add: classModel ].</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>overrides</category><body package="Store-Database" selector="checkOverrides:">checkOverrides: queryBoolean	"Answer true if ok to continue, or false if the user canceled.	If queryBoolean is true,  the user will be queried, otherwise, all will be overriden.""	( self validateClassAndNameSpaceOverlaps: queryBoolean )		ifFalse: [ ^false ].	( self validateMethodOverlaps: queryBoolean )		ifFalse: [ ^false ].	( self validateStaticOverlaps: queryBoolean )		ifFalse: [ ^false ].	self registerOverrides."	^true</body><body package="Store-Database" selector="registerOverrides">registerOverrides	"Load is continuing.... register the packages overrides."	overrides do:		[ :assoc | Override installOverride: assoc value for: assoc key ].</body><body package="Store-Database" selector="validateClassAndNameSpaceOverlaps:">validateClassAndNameSpaceOverlaps: queryBoolean	"Answer true if user validates class redefinitions."	| coll pname |	( coll := nameSpaces copy ) addAll: classes.     	coll do: 		[ :obj | |  action |		action := queryBoolean			ifTrue: 				[ | pkg message |				pkg := Registry containingPackageForSymbol: obj absoluteSymbol.				pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].				message := (#_1sIsAlreadyDefinedIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is already defined in &lt;2s&gt;')					expandMacrosWith: obj fullName with: pname.				Override overrideReplaceOrCancel: message 				]			ifFalse: 				[ pname = Registry nullPackageName 							ifTrue: [ #replace ] ifFalse: [ #override ].				].		action == #cancel  			ifTrue: [ ^false ].		action == #override			ifTrue: [ overrides add: ( obj -&gt; ( Override forClassOrNameSpace: obj ) ) ]		].	^true.</body><body package="Store-Database" selector="validateMethodOverlaps:">validateMethodOverlaps: queryBoolean	"Answer true if user validates method redefinitions."	| action |	methodDict keysAndValuesDo: 		[ :cls :meths | 		( classes includes: ( cls instanceBehavior ) )			ifFalse: 				[ | pkgDict pname |				pkgDict := IdentityDictionary new.				meths do: 					[ :selector | 	| pkg sels |					pkg := Registry containingPackageForSelector: selector class: cls.					pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].					sels := pkgDict at: pname ifAbsent: [ pkgDict at: pname put: OrderedCollection new ].					sels add: selector					].				pkgDict keysAndValuesDo: 					[ :pkgName :sels | 					sels do: 						[:aSel | 						action := queryBoolean							ifTrue: 								[ | message |								message := (#_1s2sIsAlreadyDefinedIn3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&gt;&gt;&lt;2s&gt; is already defined in &lt;3s&gt;')									expandMacrosWith: cls fullName with: aSel with: pkgName.								Override overrideReplaceOrCancel: message 								]							ifFalse: 								[ pkgName = Registry nullPackageName 										ifTrue: [ #replace ] ifFalse: [ #override ].								].					action == #cancel  						ifTrue: [ ^false ].					action == #override						ifTrue: [ overrides add: ( aSel -&gt; ( Override forSelector: aSel class: cls ) ) ].						 ]					].			]		].	^true</body><body package="Store-Database" selector="validateStaticOverlaps:">validateStaticOverlaps: queryBoolean	"Answer true if user validates method redefinitions."	| action |	dataDict keysAndValuesDo: 		[ :owner :keys |  | pkgDict pname |		pkgDict := IdentityDictionary new.		keys do: 			[ :key | 	| pkg coll |			pkg := Registry containingPackageForDataKey: key symbol: owner absoluteSymbol.			pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].			coll := pkgDict at: pname ifAbsent: [ pkgDict at: pname put: OrderedCollection new ].			coll add: key			].		pkgDict keysAndValuesDo: 			[ :pkgName :coll | 			coll do: 				[:key | 				action := queryBoolean					ifTrue: 						[ | message |						message := (#S_1s2sIsAlreadyDefinedIn3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; is already defined in &lt;3s&gt;')							expandMacrosWith: owner fullName with: key with: pkgName.						Override overrideReplaceOrCancel: message 						]					ifFalse: 						[ pkgName = Registry nullPackageName 								ifTrue: [ #replace ] ifFalse: [ #override ].						].			action == #cancel  				ifTrue: [ ^false ].				action == #override			ifTrue: [ overrides add: ( key -&gt; ( Override forDataKey: key in: owner ) ) ].				 ]			].		].	^true</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>analysis</category><body package="Store-Database" selector="canLoadClass:from:">canLoadClass: aClassRecord from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: ( Array with: aClassRecord );		nameSpaces: Array new;		methodsTT: Array new;		dataTT: Array new.	^la loadCanProceed</body><body package="Store-Database" selector="canLoadClass:methods:data:from:">canLoadClass: aClass methods: aTTMethodList data: aTTDatumList from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: (aClass isNil ifTrue: [Array new] ifFalse: [Array with: aClass]);		methodsTT: aTTMethodList;		dataTT: aTTDatumList.	^la loadCanProceed</body><body package="Store-Database" selector="canLoadDatum:from:">canLoadDatum: aTTDatum from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: (Array new);		methodsTT: (Array new);		dataTT: (Array with: aTTDatum).	^la loadCanProceed</body><body package="Store-Database" selector="canLoadMethod:from:">canLoadMethod: aTTMethod from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: (Array new);		methodsTT: (Array with: aTTMethod);		dataTT: (Array new).	^la loadCanProceed</body><body package="Store-Database" selector="canLoadNameSpace:data:from:">canLoadNameSpace: aNameSpace data: aTTDatumList from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		nameSpaces: (aNameSpace isNil ifTrue: [Array new] ifFalse: [Array with: aNameSpace]);		dataTT: aTTDatumList.	^la loadCanProceed</body><body package="Store-Database" selector="canLoadNameSpace:from:">canLoadNameSpace: aNameSpaceRecord from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: Array new;		nameSpaces: ( Array with: aNameSpaceRecord );		methodsTT: Array new;		dataTT: Array new.	^la loadCanProceed</body><body package="Store-Database" selector="checkUninstalledForPackage:classes:methods:data:">checkUninstalledForPackage: aPackage classes: uninstalledClasses methods: uninstalledMethods data: uninstalledData	"Determine why the uninstalled can't be installed and display a message box informing the user."	| la |	la := self new.	la 	toPackage: aPackage; 		wholePackage: false;		classes: uninstalledClasses;		nameSpaces: Array new;		methodsTT: uninstalledMethods;		dataTT: uninstalledData.	^la loadCanProceed</body><body package="Store-Database" selector="preDBLoadOverlapCheckOf:classes:nameSpaces:methods:data:">preDBLoadOverlapCheckOf: aPackage classes: aTTClassList nameSpaces: aTTNameSpaceList methods: aTTMethodList data: aTTDatumList	^self new		toPackage: aPackage; 		classes:  aTTClassList nameSpaces: aTTNameSpaceList; 		methodsTT: aTTMethodList;		dataTT: aTTDatumList;		loadCanProceed</body><body package="Store-Database" selector="preDBLoadOverlapCheckOf:within:classes:nameSpaces:methods:data:">preDBLoadOverlapCheckOf: aPackage within: aBundle classes: aTTClassList nameSpaces: aTTNameSpaceList methods: aTTMethodList data: aTTDatumList	^self new	 	toPackage: aPackage; 		withinBundle: aBundle;		classes:  aTTClassList nameSpaces: aTTNameSpaceList; 		methodsTT: aTTMethodList;		dataTT: aTTDatumList;		loadCanProceed</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>instance creation</category><body package="Store-Database" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.Method</class-id> <category>testing</category><body package="Store-DB-Subdefs" selector="isForMethod">isForMethod	^true</body><body package="Store-DB-Subdefs" selector="isMeta">isMeta	( meta == nil or: [ meta isKindOf: Object])		ifTrue: [ self metaString: metaString ].	^meta</body></methods><methods><class-id>Store.Method</class-id> <category>converting</category><body package="Store-DB-Subdefs" selector="asDescriptor">asDescriptor	"Answer an instance of DatumDescriptor."	^self asMethodDescriptor</body><body package="Store-DB-Subdefs" selector="asMethodDescriptor">asMethodDescriptor	^MethodDescriptor fromSelector: self selector className: self className meta: meta</body><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinition">asStoreMethodDefinition	| method |	method := Store.Glorp.StoreMethod new name: self selector asString.	method privateSetPrimaryKey: primaryKey.	method timestamp: timeStamp.	method username: userName.	method className: className.	method isMetaclass: meta.	method basicSource: (Glorp.AdHocProxy 				readBlock: [Store.Glorp.StoreBlob forString: self sourceCode asString]).	method protocol: (self protocol isNil ifTrue: [''] ifFalse: [self protocol]) asString.	method setVersionTo: self version.	^method</body><body package="Store-DB-Subdefs" selector="asTag">asTag	"Answer an instance of TT_MethodTag."	^MethodTag 		newClassName: self className 		meta: self isMeta		selector: self selector		protocol: self protocol.</body></methods><methods><class-id>Store.Method</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="asMethodString">asMethodString	| string |	string := ( SystemUtils convertAbsoluteNameToFull: className ), ' '.	^string, self itemString.</body><body package="Store-DB-Subdefs" selector="displayString">displayString	^self name</body><body package="Store-DB-Subdefs" selector="fullDisplayString">fullDisplayString	^self asMethodString</body><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	className isNil 		ifTrue: [ aStream nextPutAll: String new]		ifFalse: [ aStream nextPutAll: className].	aStream nextPutAll: '&gt;&gt;'.	self protocolName isNil 		ifTrue: [ aStream nextPutAll: String new]		ifFalse: [aStream nextPutAll: self protocolName].	aStream nextPutAll: '&gt;&gt;'.	self name isNil 		ifTrue: [ aStream nextPutAll: String new]		ifFalse: [aStream nextPutAll: self name].</body><body package="Store-UI-Comparitors" selector="statusLineString">statusLineString	^self protocolName</body></methods><methods><class-id>Store.Method</class-id> <category>public interface</category><body package="Store-DB-Subdefs" selector="loadAsNew">loadAsNew	"Catch the RedefinitionNotification to resolve any overrides."		^[self		loadAsNewIn: Policies packagePolicy forcedPackage		withCommittingSource: true]		on: RedefinitionNotification		do:			[:ex | 			self resolveOverride: ex.			true]</body><body package="Store-DB-Subdefs" selector="loadAsNewWithCommittingSource:">loadAsNewWithCommittingSource: commitSourceStream	"Load the method and skip the checking since the method is new. 	Answer true if the compilation was successful.  If commitSourceStream is false, then it is the	the client's responsibility to ensure that the changes log file is flushed."	^self loadAsNewIn: Policies packagePolicy forcedPackage withCommittingSource: commitSourceStream.</body><body package="Store-DB-Subdefs" selector="loadInClass:protocol:package:">loadInClass: class protocol: aProtocol package: imgPackage	"Check also for correct protocol"		| selector tracePackage |	selector := self selector.	((class includesSelector: selector)		and: [(class organization categoryOfElement: selector) = aProtocol 		and: [(self class sourceCodeAt: selector forClass: class) = self sourceCode]])			ifTrue: [imgPackage ifNotNil: [XChangeSet current moveSelector: selector class: class toPackage: imgPackage]]			ifFalse:				[| environment |				environment := imgPackage					environmentFor: selector					in: class.				class					compile: self sourceCode					classified: aProtocol					notifying: nil					environment: environment].	tracePackage := (Registry containingPackageForSelector: selector class: class) tracePackage.	(tracePackage notNil 		and: [self sameAs: (tracePackage			method: selector			forClassNamed: self className asClassNameOnly			meta: self className namesMetaClass)]) 				ifTrue: [XChangeSet current removeSelectorChanges: selector class: class]</body><body package="Store-DB-Subdefs" selector="loadSrc">loadSrc	"Load the method."	^self loadSrcInto: Policies packagePolicy forcedPackage.</body><body package="Store-DB-Subdefs" selector="loadSrcInto:">loadSrcInto: imgPackage	"Load the method."	| class protocol |	class := self myClass.	class isNil 		ifTrue: 			[ ^UnloadableDefinitionError new					definitionRecord: self;					package: imgPackage;					raise 			].	protocol := self protocol.	self loadInClass: class protocol: protocol  package: imgPackage.	IncrementNotification raiseSignal.</body><body package="Store-DB-Subdefs" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean 	"Load the method. Make sure that it goes to the imPkg. and it does not	overwrites existing definition from another package."	aBoolean ifTrue: 		[(Dialog confirm: #DoYouWantToLoadTheSelectedMethod &lt;&lt; #store &gt;&gt; 'Do you want to load the selected method?') ifFalse: [^self]].	(LoadAnalyzer canLoadMethod: self from: imPkg) ifTrue: 		[Policies packagePolicy forcePackage: imPkg while: [self loadSrc]]</body><body package="Store-DB-Subdefs" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveSelector: self selector		className: self className asClassNameOnly		meta: self isMeta		package: aPackage</body></methods><methods><class-id>Store.Method</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="absoluteClassName">absoluteClassName	^className</body><body package="Store-DB-Subdefs" selector="className">className	^className</body><body package="Store-DB-Subdefs" selector="className:">className: anObject	className := anObject.	self meta: anObject namesMetaClass</body><body package="Store-DB-Subdefs" selector="classNameWithMeta">classNameWithMeta	^className</body><body package="Store-DB-Subdefs" selector="classSymbol">classSymbol 	^self className asClassNameOnly asSymbol</body><body package="Store-DB-Subdefs" selector="definition">definition	^self sourceCode</body><body package="Store-DB-Subdefs" selector="environment">environment	^nil.</body><body package="Store-DB-Subdefs" selector="fullClassName">fullClassName	^className</body><body package="Store-DB-Subdefs" selector="implementingClass">implementingClass	^self myClass</body><body package="Store-DB-Subdefs" selector="loadAsNewIn:">loadAsNewIn: imgPackage 	"Load the method and skip the checking since the method is new. 	Since this is new... any existing method should be considered an override....	Answer true if the compilation was successful.	Note: even though the package is passed in, assumes that the current package is forced"	^self loadAsNewIn: imgPackage withCommittingSource: true</body><body package="Store-DB-Subdefs" selector="loadAsNewIn:withCommittingSource:">loadAsNewIn: imgPackage withCommittingSource: commitSourceStream	"Load the method and skip the checking since the method is new. 	Since this is new... any existing method should be considered an override....	Answer true if the compilation was successful.	Note: even though the package is passed in, assumes that the current package is forced"	| class protocol ret | 	class := self myClass.	class == nil 		ifTrue: 			[UnloadableDefinitionError signalWith: self.			^false].	protocol := self protocolName asSymbol.	ret :=  commitSourceStream 			ifTrue: [(class compile: self sourceCode						classified: protocol						notifying: nil						environment: (imgPackage environmentFor: self)) notNil]			ifFalse: [(class compileWithoutUsingChangeFile: self sourceCode						classified: protocol						notifying: nil						environment: (imgPackage environmentFor: self)						attributes: nil ) notNil].	IncrementNotification raiseSignal.	^ret</body><body package="Store-DB-Subdefs" selector="meta">meta	^meta</body><body package="Store-DB-Subdefs" selector="meta:">meta: aBoolean	meta := aBoolean.	metaString := meta textRepresentation.</body><body package="Store-DB-Subdefs" selector="metaString">metaString	^metaString</body><body package="Store-DB-Subdefs" selector="metaString:">metaString: aString	metaString := aString.	meta := Boolean fromText: aString.</body><body package="Store-DB-Subdefs" selector="methodSources">methodSources	^MethodSourceCollection source: self sourceCode</body><body package="Store-DB-Subdefs" selector="myClass">myClass	"Answer the class containing the receiver. " 	| class |	class := self className asClassNameOnly asStrictReference valueOrDo: [ ^nil ].	^self isMeta 		ifTrue: [ class class]		ifFalse: [ class ]</body><body package="Store-DB-Subdefs" selector="ownerName">ownerName	^className</body><body package="Store-DB-Subdefs" selector="protocol">protocol	^protocolName isNil		ifTrue: [#unknown]		ifFalse: [protocolName asSymbol]</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body><body package="Store-DB-Subdefs" selector="selector">selector	^self symbolKey</body><body package="Store-DB-Subdefs" selector="stDocumentation">stDocumentation	^''"	| dbComment |	documentStr isNil ifFalse: [ ^documentStr ].	dbComment := self broker		getAnswerFromSession: [ MethodsSourcesDocumentView documentSession ]		bindInput:			[:session | | bindObject |			bindObject := session bindInput.			bindObject primaryKey: self primaryKey].	dbComment isEmpty		ifTrue: [ documentStr := '' ]		ifFalse:			[ [ documentStr := ( Blob fromDocumentView: dbComment first ) definition ]				on: self errorSignals				do: [ :ex | documentStr := '' ]			].	^documentStr."</body><body package="Store-DB-Subdefs" selector="stDocumentation:">stDocumentation: aString	documentStr := aString.</body><body package="Store-DB-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self sourceCode</body></methods><methods><class-id>Store.Method</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="conflictsWithImage">conflictsWithImage	"Answer true if a method with the same selector 	exists in the image."	| class selector |	class := self myClass.	class isNil ifTrue: [^false].	selector := self name asSymbol.	^class includesSelector: selector</body><body package="Store-DB-Subdefs" selector="containingPackages">containingPackages	| packages |	packages := [( Methods packagesContainingMethod: self primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].	^packages sort: [:a :b | a timeStamp &gt; b timeStamp].</body><body package="Store-DB-Subdefs" selector="definitionRecord">definitionRecord	"Create a new record in the database that holds the source code."	^self class definitionClass fromString: sourceCodeString</body></methods><methods><class-id>Store.Method</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="fileOutOn:">fileOutOn: aSourceCodeStream		| d |	d := Dictionary new.	d at: self protocol put: (Set with: self).	aSourceCodeStream fileOutTTMessages: d for: self className logging: false.</body><body package="Atomic Compiling and Loading" selector="fileOutSourceOn:">fileOutSourceOn: aSourceCodeStream		^self fileOutOn: aSourceCodeStream</body><body package="Store-DB-Subdefs" selector="invalidClassMessage">invalidClassMessage	^(#TheMethod1pCannotClassNotInImage &lt;&lt; #store &gt;&gt; 'The method &lt;1p&gt; cannot be loaded. Class not in image.') expandMacrosWith: self</body><body package="Store-DB-Subdefs" selector="prime">prime	super prime.	meta := Object new.	documentStr := Object new.</body><body package="Store-DB-Subdefs" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	self metaString: metaString.	"Set meta flag"</body><body package="Store-DB-Subdefs" selector="sameAsSelector:class:">sameAsSelector: aSelector class: aClass 	"Answer true if I'm the same as method aSelector in class aClass."	| protocol key |	protocol := aClass organization categoryOfElement: aSelector.	protocol == nil ifTrue: [ protocol := 'As yet unclassified' ].	aClass isMeta = self isMeta ifFalse: [ ^false ].	self className = aClass absoluteName ifFalse: [ ^false ].	self name = aSelector asString ifFalse: [ ^false ].	self protocolName = protocol asString ifFalse: [^false].	key := self class sourcePointerFor: aSelector inClass: aClass.	key isNil ifTrue: [ ^false ].	self sourceCode = ( self class sourceCodeAt: aSelector forClass: aClass )		ifFalse: [ ^false ].	^self stDocumentation = ( aClass compiledMethodAt: aSelector ) stDocumentation.</body><body package="Store-DB-Subdefs" selector="unprime">unprime	super unprime.	meta := nil.	documentStr := nil.</body></methods><methods><class-id>Store.Method</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^( anObject selector = self  selector ) and:		[ anObject classNameWithMeta = self classNameWithMeta ]</body><body package="Store-DB-Subdefs" selector="hash">hash	^self className hash + self symbolKey hash</body><body package="Store-DB-Subdefs" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForMethod</body><body package="Store-DB-Subdefs" selector="quickComparesTo:">quickComparesTo: anObject		"Answer true if anObject could be another version of the receiver."		"For comparing differenct db versions."	self  class == anObject class		ifFalse: [ ^false ].	^( ( self selector = anObject selector )  and:  [ self isMeta = anObject isMeta ] )			and: [ self ownerName = anObject ownerName ]	</body><body package="Store-DB-Subdefs" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version."	^self sameAsImThing: self asDescriptor</body><body package="Store-DB-Subdefs" selector="sourceMatches:">sourceMatches: aMethod	"Answer whether the source match"		^self protocol = aMethod protocol		and: [self sourceCode equalsAcrossPlatforms: aMethod sourceCode]</body></methods><methods><class-id>Store.Method</class-id> <category>change list support</category><body package="Store-DB-Subdefs" selector="systemCategory">systemCategory	"Return the category of the corresponding method the system, if any"	| class |	^( class := self myClass ) == nil		ifFalse: [ class whichCategoryIncludesSelector: self selector ]</body><body package="Store-DB-Subdefs" selector="text">text	"Asnwer the text to display in a text window."	^self definition</body></methods><methods><class-id>Store.Method</class-id> <category>shadow support</category><body package="Atomic Compiling and Loading" selector="belongsToClass">belongsToClass	"Answer true if the receiver depends on a class (ie method or shared in a class)"		^true</body></methods><methods><class-id>Store.Method</class-id> <category>fileIn/Out</category><body package="Store-DB-Subdefs" selector="fileOutDefinitionOn:">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	self fileOutOn: aStream</body><body package="Store-DB-Subdefs" selector="patchOverride:with:">patchOverride: anOverride with: aCompiledMethod	"modify anOverride to refer to aCompiledMethod, leave package information unchanged"	"We have to ensure that the packages registered as sources in anOverride stay the same,	after we exchanged the compiledMethod anOverride points to the new aCompiledMethod.	This way we ensure that the package we currently change stays in place, because aCompiledMethod is contained in it.	anOverride does not know about this, so we have to enforce this."	| savedSources |	savedSources := anOverride sources copy.	anOverride		from: aCompiledMethod		selector: self selector.	anOverride sources removeAll; addAll: savedSources</body><body package="Store-DB-Subdefs" selector="privateCompile">privateCompile	"Compile my code into a CompiledMethod, but do not install into a Class."		| class compiler imgPackage methodNode compiledMethod srcs |	imgPackage := Policies packagePolicy forcedPackage.	class := self myClass.	compiler := class compilerClass new.	compiler environment: (imgPackage environmentFor: self).	methodNode := compiler		compile: self sourceCode		in: class		notifying: nil		ifFail: [^nil].	compiledMethod := methodNode generate.	srcs := MethodSourceCollection new.	srcs source: self sourceCode.	compiledMethod		sourcePointer:			(SourceFileManager default				storeMethodSources: srcs				class: class				selector: self selector				category: self protocolName asSymbol				safely: true).	^compiledMethod</body><body package="Store-DB-Subdefs" selector="resolveOverride:">resolveOverride: aRedefinitionNotification	"Handle overrides during the installation of a method version. There are three cases:		1. the method already belong to this package -&gt; do not create an override		2. the method definition of this package was overriden -&gt; change the override		3. the method exists only in other package(s) -&gt; create an override"		| existingOverrides myPackage compiledMethod |	existingOverrides := Override		overrideCollectionForSelector: self selector		class: self implementingClass.	myPackage := Policies packagePolicy forcedPackage.	(aRedefinitionNotification override sources includes: myPackage)		ifTrue: [aRedefinitionNotification resume 	"case 1"].	existingOverrides isNil		ifFalse: [			(compiledMethod := self privateCompile) ifNil: [^ self ]. "This should never happen"			existingOverrides				do:					[:eachOverride | 					(eachOverride sources includes: myPackage)						ifTrue: [^self patchOverride: eachOverride with: compiledMethod	"case 2"]]].	aRedefinitionNotification override install.	aRedefinitionNotification resume	"case 3"</body></methods><methods><class-id>Store.Method class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="commentFor:in:">commentFor: aSelector in: aClass 	^( aClass compiledMethodAt: aSelector asSymbol ifAbsent: [ ^'' ] ) 		stDocumentation</body><body package="Store-DB-Subdefs" selector="fileOutMethod:">fileOutMethod: aMethod	"Prompt the user for the name of the file-out file; make a reasonable 	suggestion first"	| selector sel fileName fileManager |	aMethod isNil ifTrue: [^self].	(selector := aMethod selector) isKeyword		ifTrue: 			[sel := WriteStream on: (String new: 20).			selector keywords do: [:each | sel nextPutAll: (each copyFrom: 1 to: each size - 1)].			sel := sel contents]		ifFalse: [sel := selector].	fileName := Filename defaultClass suggest: 			(Filename defaultClass filterSeps: aMethod className , '-' , sel , '.st').	fileName := Dialog requestNewFileName: #FileOutAsDots &lt;&lt; #store &gt;&gt; 'File Out As...' default: fileName.	fileName = '' ifTrue: [^nil].		"File it out"	fileManager := SourceCodeStream  write: fileName.		[fileManager timeStamp.	aMethod fileOutOn: fileManager]		ensure: [fileManager close]</body><body package="Store-DB-Subdefs" selector="moveMethod:">moveMethod: aMethod 	"Ask for destination package and move selector."	| dPkg  selector |	(aMethod isNil or: [aMethod isLoaded not])		ifTrue: [^false].	selector := aMethod selector.	(dPkg := PackageChooser chooseOrAdd) isNil ifTrue: [^false].	XChangeSet current 		moveSelector: selector		class: aMethod myClass		toPackage: dPkg.	^true</body><body package="Store-DB-Subdefs" selector="protocolNameFor:in:">protocolNameFor: aMethod in: aClass 	| protocolName |	protocolName := aClass organization categoryOfElement: aMethod asSymbol.	^protocolName isNil		ifTrue: ['unclassified']		ifFalse: [protocolName asString]</body><body package="Store-DB-Subdefs" selector="simpleSortForLoading:">simpleSortForLoading: aCollectionOfMethods	"Basic sort methods by class order."		| orderedMethods classesWithMethods orderedClasses |	classesWithMethods := Dictionary new.	orderedMethods := OrderedCollection new.	aCollectionOfMethods do:		[:each | 		[(classesWithMethods			at: each implementingClass			ifAbsentPut: [OrderedCollection new]) add: each]				on: UnhandledException				do:					[:exception | 					UnloadableDefinitionError new						originalError: exception;						parameter: each;						raise.					exception return]].	orderedClasses := SystemUtils metaclassesFirst: (SystemUtils sortForLoading: classesWithMethods keys).	orderedClasses do: [:each | orderedMethods addAll: (classesWithMethods at: each)].	^orderedMethods</body><body package="Store-DB-Subdefs" selector="simpleSortForLoading:package:">simpleSortForLoading: aCollectionOfMethods package: aPackage	"Basic sort methods by class order, with extension methods last."		| orderedMethods classesWithMethods orderedClasses definitions extensions absoluteClassNames |	classesWithMethods := Dictionary new.	orderedMethods := OrderedCollection new.	aCollectionOfMethods do:		[:each | 		[(classesWithMethods			at: each implementingClass			ifAbsentPut: [OrderedCollection new]) add: each]				on: UnhandledException				do:					[:exception | 					UnloadableDefinitionError new						originalError: exception;						parameter: each;						raise.					exception return]].	absoluteClassNames := aPackage classes collect: [:each | each absoluteName asClassNameOnly].	definitions := Set new: 23.	extensions := Set new: 23.	classesWithMethods keys do:		[:each | 		| absoluteName |		absoluteName := each instanceBehavior absoluteName.		(absoluteClassNames includes: absoluteName)			ifTrue: [definitions add: each]			ifFalse: [extensions add: each]].	orderedClasses := (SystemUtils metaclassesFirst: (SystemUtils sortForLoading: definitions))		addAll: (SystemUtils metaclassesFirst: (SystemUtils sortForLoading: extensions));		yourself.	orderedClasses do: [:each | orderedMethods addAll: (classesWithMethods at: each)].	^orderedMethods</body><body package="Store-DB-Subdefs" selector="sortForLoading:package:">sortForLoading: aCollectionOfDBMethods package: aPackage	"Make sure that all method that contain c type declaration 	are moved to the front and extenstion methods are moved to the end."	| cmeths other |	cmeths := aCollectionOfDBMethods select: [ :meth | meth version = 'CTYPE' ].	other := aCollectionOfDBMethods select: [ :meth | ( meth version = 'CTYPE' ) not ].	^( self simpleSortForLoading: cmeths )		addAll: ( self simpleSortForLoading: other package: aPackage );		yourself</body><body package="Store-DB-Subdefs" selector="sourcePointerFor:inClass:">sourcePointerFor: aSelector inClass: aClass	| method |	method := aClass compiledMethodAt: aSelector.	^method sourcePointer</body></methods><methods><class-id>Store.Method class</class-id> <category>instance creation</category><body package="Store-DB-Subdefs" selector="allMethodVersionsNamed:inClass:meta:">allMethodVersionsNamed: aMethodName inClass: aClassName meta: aBoolean 	| dbMethods classNameString |	classNameString := (aBoolean and: [aClassName namesMetaClass not]) 		ifTrue: [aClassName , ' class'] 		ifFalse: [aClassName].	dbMethods := 		[self processList: (self broker 			process: ((self newSQL)				selectAll;				where;				column: #name equalTo: aMethodName asString printString;				and;				column: #className equalTo: classNameString asString printString)			bindOutput: Method newPrimed)] 				on: self errorSignals				do: 					[:exception | 					exception outer.					(Method table 						select: [:each | each name = aMethodName asString]) 							select: [:each | each className = aClassName asString]].	^dbMethods asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]</body><body package="Store-DB-Subdefs" selector="commentClass">commentClass	^BinaryBlob.</body><body package="Store-DB-Subdefs" selector="fromClass:named:timeStamp:trace:">fromClass: class named: aName timeStamp: timeStamp trace: oldDBMethod 	^(self new) name: aName asString;		 timeStamp: timeStamp; 		className: class absoluteName;		meta: class isMeta;		protocolName: (self protocolNameFor: aName in: class); 		sourceCode: (self sourceCodeAt: aName forClass: class);"		stDocumentation: ( class compiledMethodAt: aName ) stDocumentation;  "		setTrace: oldDBMethod</body><body package="Store-DB-Subdefs" selector="fromView:">fromView: aMethodView 	| aMethod |	aMethod := self new.	aMethod primaryKey: aMethodView primaryKey;			name: aMethodView name;			meta: aMethodView isMeta;			timeStamp: aMethodView timeStamp;			version: aMethodView version;			userName: aMethodView userName;			dbTrace: aMethodView dbTrace;			className: aMethodView className;			sourceCodeID: aMethodView sourceCodeID;			protocolName: aMethodView protocolName;			processFields.	^aMethod</body></methods><methods><class-id>Store.Method class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="associationClass">associationClass	^Methods</body><body package="Store-DB-Subdefs" selector="columnNames">columnNames	| columnNames |	columnNames := super columnNames.	columnNames 		remove: 'sourceCodeString';		remove: 'creatorPackageVersion';		remove: 'creatorPackage';		remove: 'meta';		remove: 'documentStr';		yourself.	^columnNames</body><body package="Store-DB-Subdefs" selector="defaultBlockFactor">defaultBlockFactor	^1000</body><body package="Store-DB-Subdefs" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_MethodNameClassName' #('name' 'className'))		#('ST_MethodTimestamp' #('timeStamp'))		#('ST_MethodProtocolname' #('protocolName'))		#('ST_MethodClassname' #('className'))		#('ST_MethodGCSupport' #('trace'))		)</body><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn	^#methodRef</body><body package="Store-DB-Subdefs" selector="sourcesViewClass">sourcesViewClass	^MethodsAndSourcesView</body></methods><methods><class-id>Store.Method class</class-id> <category>performance tuning</category><body package="Store-DB-Subdefs" selector="createMethodRetrievalIndex">createMethodRetrievalIndex	"self createMethodRetrievalIndex"	self broker createIndexForClass: self 				index: 'TT_MethodRetrievalIndex' 				columns: (Array with: 'name' with: 'className').</body><body package="Store-DB-Subdefs" selector="dropMethodRetrievalIndex">dropMethodRetrievalIndex	"self dropMethodRetrievalIndex"	self broker dropIndexForClass: self 				index: 'TT_MethodRetrievalIndex' .</body></methods><methods><class-id>Store.Method class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="allNamesMatching:in:">allNamesMatching: aString in: cname	"Wildcard search within a class"	"Method allNamesMatching: 'a*' in: 'Root.Smalltalk.Core.Object'"	| answer |	answer := 		[ self broker process:			( self newSQL 				selectDistinct: #( name );				where;				column: #name wildcard: aString printString;				and;				column: #className equalTo: cname asString printString			 ) 		] on: self  errorSignals  do: [:ex |  ex outer. ^#() ].	^answer isEmpty		ifTrue: [ answer ]		ifFalse: [ answer collect: [ :array | array first ] ].</body><body package="Store-DB-Subdefs" selector="chooseAvailableMethodMatching:in:">chooseAvailableMethodMatching: aString in: aClass 	"Wildcard search and select for methods not currently in the image for a particular class"	"Method chooseAvailableMethodMatching: '*' in: Store.Method "	| list names |	(list := self allNamesMatching: aString in: aClass absoluteName) isEmpty 		ifTrue: 			[^Dialog 				warn: (#NoSelectorsMatching1s &lt;&lt; #store &gt;&gt; 'No selectors matching &lt;1s&gt;' 						expandMacrosWith: aString)].	names := list reject: [:each | aClass includesSelector: each asSymbol].	names := names asSortedCollection.	names isEmpty 		ifTrue: 			[^Dialog 				warn: (#NoRemovedMethodsIn1s &lt;&lt; #store &gt;&gt; 'No removed methods in &lt;1s&gt;' 						expandMacrosWith: aClass fullName)].	^SimpleDialog new 		chooseMultiple: #ChooseSelectors &lt;&lt; #store &gt;&gt; 'Choose selectors...'		fromList: names		values: names		buttons: #()		values: #()		lines: 12		cancel: nil		for: nil</body><body package="Store-DB-Subdefs" selector="selectVersionNamed:in:meta:">selectVersionNamed: aName in: ownerName meta: aBoolean 	| list |	list := self 				allMethodVersionsNamed: aName				inClass: ownerName				meta: aBoolean.	list isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	list size == 1 ifTrue: [^list first].	^Dialog 		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (list collect: [:m | m itemString])		values: list		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.Method class</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="fromDescription:trace:package:">fromDescription: aMethodDescription trace: anExistingMethodDescriptor package: aPackageModel		| instance variableAssociation class selector sourceCode className |	class := aMethodDescription owner.	className := class isNil		ifTrue: [aMethodDescription fullClassName]		ifFalse: [class absoluteName].	selector := aMethodDescription selector asString.	sourceCode := aMethodDescription myClass isNil		ifTrue: [self sourceCodeFor: aMethodDescription inParcelRelatedTo: aPackageModel]		ifFalse: [aMethodDescription sourceCode].	instance := (self new)		name: selector;		timeStamp: self timeStamp;		className: className;		meta: aMethodDescription isMeta;		protocolName: aMethodDescription protocol;		sourceCode: sourceCode;		setTrace: anExistingMethodDescriptor;		yourself.	anExistingMethodDescriptor notNil ifTrue: 		[anExistingMethodDescriptor sourceCode = instance sourceCode ifTrue: 			[instance sourceCodeID: anExistingMethodDescriptor sourceCodeID]].	instance creatorPackage: aPackageModel primaryKey.	instance install.	(class isKindOf: ExternalInterface class)		ifTrue:			[((variableAssociation := (class compiledMethodAt: selector asSymbol) returnsStaticVariable) notNil and: [variableAssociation value isKindOf: CType])				ifTrue: [instance setVersionTo: 'CTYPE']].	^instance</body><body package="Store-DB-Subdefs" selector="newNamed:inClass:trace:package:">newNamed: aName inClass: class trace: oldDBMethod package: aDBPackage 	| newDBMethod variableAssociation |	"Transcript show: 'Creating new method: ' , class name, '&gt;&gt;', aName; cr; flush."	newDBMethod := self				fromClass: class				named: aName				timeStamp: self timeStamp				trace: oldDBMethod.	(oldDBMethod notNil and: [oldDBMethod sourceCode = newDBMethod sourceCode])		ifTrue: [newDBMethod sourceCodeID: oldDBMethod sourceCodeID].	newDBMethod creatorPackage: aDBPackage primaryKey.	newDBMethod install.	(class isKindOf: ExternalInterface class)		ifTrue: [((variableAssociation := (class compiledMethodAt: aName asSymbol) returnsStaticVariable) notNil and: [variableAssociation value isKindOf: CType])				ifTrue: [newDBMethod setVersionTo: 'CTYPE']].	^newDBMethod</body><body package="Store-DB-Subdefs" selector="recordFromDescription:trace:package:">recordFromDescription: methodDescription trace: oldDBMethod package: aDBPackage 	"Answer a record for aMethod. If the trace is identical as aMethod 	answer the trace instead creating a new record."	^oldDBMethod isNil		ifTrue: 			[ self				fromDescription: methodDescription				trace: nil				package: aDBPackage			]		ifFalse: 			[ ( oldDBMethod sameAsSelector: methodDescription selector class: methodDescription owner )				ifTrue: [ oldDBMethod ]				ifFalse: 					[ self						fromDescription: methodDescription						trace: oldDBMethod						package: aDBPackage					]			]</body><body package="Store-DB-Subdefs" selector="recordNamed:inClass:trace:package:">recordNamed: aMethod inClass: class trace: oldDBMethod package: aDBPackage 	"Answer a record for aMethod. If the trace is identical as aMethod 	answer the trace instead creating a new record."	^oldDBMethod isNil		ifTrue: [self				newNamed: aMethod				inClass: class				trace: nil				package: aDBPackage]		ifFalse: [(oldDBMethod sameAsSelector: aMethod class: class)				ifTrue: [oldDBMethod]				ifFalse: [self						newNamed: aMethod						inClass: class						trace: oldDBMethod						package: aDBPackage]]</body><body package="Store-DB-Subdefs" selector="sourceCodeFor:inParcelRelatedTo:">sourceCodeFor: aMethodDescription inParcelRelatedTo: aPackageModel	"Here is a last stop chance to find out if there is uninstalled code in a Parcel related to the passed in package,	and if so, get the source from that Parcel's uninstalled code property"	| imagePackage parcel uninstalledMethod |	imagePackage := aPackageModel getImagePundle.	(parcel := imagePackage relatedParcel) ifNil: [^aMethodDescription sourceCode].	uninstalledMethod := (parcel properties at: #uninstalledMethods ifAbsent: [#()])		detect: [:each | each selector = aMethodDescription selector]		ifNone: [^aMethodDescription sourceCode].	^uninstalledMethod method hasSource 		ifTrue: [uninstalledMethod method getSource string]		ifFalse: [aMethodDescription sourceCode]</body></methods><methods><class-id>Store.Method class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'sourceCodeID' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE ', self tableSpaceName, ' STORAGE(INITIAL 1M NEXT 256K) '</body><body package="Store-DB-Subdefs" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 5M NEXT 512K PCTINCREASE 1) '</body><body package="Store-DB-Subdefs" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy methodsTableSpace</body></methods><methods><class-id>Store.Method class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on methodRef to speed up	garbage collection process."	^self broker createIndexForClass: self.</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on methodRef to speed up	garbage collection process."	^self broker dropIndexForClass: self.</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames	^ Array with: 'sourceCodeID'</body><body package="Store-DB-Subdefs" selector="indexName">indexName	^ '_DEF_IDX '</body><body package="Store-DB-Subdefs" selector="methodsReferingToDefinitionID:">methodsReferingToDefinitionID: aDefinitionID 	"Collect TT_Methods that 	refer to a given definition record. 	Answer a collection of IDs."	"self methodsReferingToDefinitionID: 154335"	|ids|	ids := self broker process: 					( self newSQL							select: #( primaryKey );							where;							column: #sourceCodeID equalTo: aDefinitionID printString).	^ids collect: [:each| each first]</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	| shared owningPackage |	proposed ifNil: [^false].	proposed isRemovalResolution ifFalse: [^false].	shared := proposed value value.	shared correspondingImageBinding ifNil: [^true].	(owningPackage := Registry containingPackageForDataKey: shared correspondingImageBinding key symbol: shared owner absoluteSymbol) ifNil: [^true].	^(owningPackage name = proposed package name) not</body><body package="Store-Merge Management" selector="isSharedResolver">isSharedResolver	^true</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	| result |	applyable ifFalse: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isUserInputResolution ifTrue: [^proposed applyUsing: self].	proposed isAbsentResolution ifTrue: [^true].	proposed isNoOpResolution ifTrue: [^true].	self hasOverrideAndShouldApply ifFalse: [^false].	(Undeclared includesKey: proposed resolver dataKey)		ifTrue: [Undeclared removeKey: proposed resolver dataKey ifAbsent: [nil]].	Policies packagePolicy 		forcePackage: proposed key storeModel		while: 			[[ | shared |			result := [(shared := proposed value) loadSource]				on: RedefinitionNotification				do: 					[:notification | 					notification currentPackage name = proposed key storeModel name ifFalse: [notification override install].					notification resume].			result ifNotNil: [shared correspondingImageBinding ifNotNil: 				[:value | 				(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]]]					on: UnloadableDefinitionError					do: [:exception | exception return]].	^result notNil</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	| shared result |	shared := proposed value value.	shared correspondingImageBinding ifNil: [^true].	result := [Override				unloadStatic: shared correspondingImageBinding				in: shared owner				from: proposed package storeModel]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingRemovalSharedFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Shared Variable &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self mergeDisplayName).			exception return: #failed].	^result ~= #failed</body><body package="Store-Merge Management" selector="askToReinitializeSharedVariable:">askToReinitializeSharedVariable: aVariableBinding		^Dialog confirm: (#ReInitializeSharedVariable &lt;&lt; #store &gt;&gt; '(Re)Initialize Shared Variable : ''&lt;1s&gt;''?' expandMacrosWith: aVariableBinding absoluteName)</body><body package="Store-Merge Management" selector="existingOverrides">existingOverrides	^(Override overridesForDataKey: self mergeDisplayName asSymbol in: (self longOwnerName asStrictReference valueOrDo: [^#()])) ifNil: [^#()]</body><body package="Store-Merge Management" selector="hasOverrideAndShouldApply">hasOverrideAndShouldApply		self potentialOverride ifNotNil:		[:value | 		value name = proposed key name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed key name) ifFalse: 				[Transcript show: (#nDidNotApplyOverrideSharedVariable1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of Shared Variable &lt;1s&gt; in &lt;2s&gt;' 					expandMacrosWith: self longName					with: proposed key name).				^false]]].	^true</body><body package="Store-Merge Management" selector="potentialOverride">potentialOverride	^Store.Registry containingPackageForDataKey: self mergeDisplayName asSymbol symbol: self longOwnerName asSymbol</body><body package="Store-Merge Management" selector="proceedWithPossibleOverrideFrom:to:">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingShared1sn2sOveride3snn &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;Shared Variable "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="browseVersions">browseVersions	| alternative list session |	alternative := self standardResolutionAlternative.	alternative		ifNil: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: alternative value name)].	session := alternative key session.	(Gathering for: self longName) started.	list := StoreSharedVariableInPackage				allVersionsWithName: alternative value name				inOwner: alternative value environmentName				in: session.	(Gathering for: self longName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: alternative value name)].	DefinitionForListTool forSharedVariables: list</body><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value ifNotNil: 		[:value | 		value isString			ifTrue: [value]			ifFalse: [	value definitionString]]</body><body package="Store-Merge Management" selector="listIcon">listIcon	^VisualStack with: BehaviorIcons Object with: BehaviorIcons SharedVariableOverlay</body><body package="Store-Merge Management" selector="longName">longName	| storeObject |	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value absoluteName</body><body package="Store-Merge Management" selector="longOwnerName">longOwnerName	| storeObject |	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value environmentName</body><body package="Store-Merge Management" selector="longTreeName">longTreeName	| string |	string := self longName, self applyableString.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName	| storeObject |	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value name</body><body package="Store-Merge Management" selector="shortListName">shortListName	| string |	string := self ownerName, ' [Shared] ' , self shortTreeName.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName	| string |	string := self mergeDisplayName, self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.Glorp.SharedChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="loadSourceUsing:">loadSourceUsing: aUserInputResolution	"Answer true if it is OK, or false if something bad happened"	| bindingReference |	self hasOverrideAndShouldApply ifFalse: [^false].	Policies packagePolicy 		forcePackage: aUserInputResolution package		while: 			[[[bindingReference := Compiler evaluate: aUserInputResolution value]				on: VariableConfirmation				do: [:exception | exception resume: false]]					on: UnhandledException					do:						[:exception | 						^false]].	(Undeclared includesKey: bindingReference name) ifTrue:		[^false].	bindingReference ifNotNil: [bindingReference bindingOrNil ifNotNil:		[:value | 		[(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]			on: UnloadableDefinitionError			do: [:exception | exception return]]].	^bindingReference notNil</body><body package="Store-Merge Management" selector="validateParse:">validateParse: aNodeHolder	| selector methodCollector filter receiver alternative oldNode mainStatementNode oldStatementNode name value |	mainStatementNode := aNodeHolder node block body statements first.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	oldNode := self parseDefinition: alternative value definition in: self owningEnvironment.	oldStatementNode := oldNode node block body statements first.	receiver := mainStatementNode receiver name.	oldStatementNode receiver name = receiver ifFalse:		[Dialog warn: (#Class1BooleanNameSpaceMustNotChange &lt;&lt; #store &gt;&gt; '&lt;1?Class:NameSpace&gt; must not change' expandMacrosWith: alternative value isClassVariable).		^nil].	name := (mainStatementNode arguments first) value asString.	(oldStatementNode arguments first) value asString = name ifFalse:		[Dialog warn: #SharedVariableNameMustNotChange &lt;&lt; #store &gt;&gt; 'Shared variable name must not change'.		^nil].	selector := mainStatementNode selector.	methodCollector := MethodCollector new.	filter := methodCollector implementorsOf: selector.	(methodCollector select: filter) isEmpty ifTrue:		[Dialog warn: #BadDefinitionMessage &lt;&lt; #store &gt;&gt; 'Bad Definition Message'.		^nil].	oldStatementNode selector = selector ifFalse:		[Dialog warn: #DefinitionMessageMustNotChange &lt;&lt; #store &gt;&gt; 'Definition message must not change'.		^nil].	((mainStatementNode arguments at: 2) value isKindOf: Boolean) ifFalse:		[Dialog warn: #ParameterForPrivateMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #private: must be a Boolean'.		^nil].	((mainStatementNode arguments at: 3) value isKindOf: Boolean) ifFalse:		[Dialog warn: #ParameterForConstantMustBeBoolean &lt;&lt; #store &gt;&gt; 'Parameter for #constant: must be a Boolean'.		^nil].	((mainStatementNode arguments at: 4) value isString) ifFalse:		[Dialog warn: #ParameterForCategoryMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #category: must be a String'.		^nil].	((value := (mainStatementNode arguments at: 5) value) isString and: [value isSymbol not]) ifFalse:		[Dialog warn: #ParameterForInitializerMustBeString &lt;&lt; #store &gt;&gt; 'Parameter for #initializer: must be a String'.		^nil].	^aNodeHolder</body></methods><methods><class-id>Store.InstallingDatabaseTables</class-id> <category>accessing</category><body package="Store-Base" selector="actionText">actionText	^(#InstallingDatabaseTables &lt;&lt; #store &gt;&gt; 'Installing Database Tables') asString</body><body package="Store-Base" selector="componentName">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>publishing</category><body package="Store-Ownership" selector="allowedBlessingLevelsForPundle:">allowedBlessingLevelsForPundle: aPundle 	"*** adapted from Philippe F. Monnet ***"	"Returns the list of allowed blessing levels for this pundle and the current 	owner"	| disallowedBlessings |	disallowedBlessings := OrderedCollection new.	self isImageAdministrator		ifFalse: 	[ disallowedBlessings addAll: self administratorBlessings ].	disallowedBlessings addAll: ( self disallowedBlessingsForPundle: aPundle ).	^self blessings reject: [ :b | disallowedBlessings includes: b level ].</body><body package="Store-Ownership" selector="basicCanPublish:atBlessing:">basicCanPublish: aPundle atBlessing: aBlessing	(self allowedBlessingLevelsForPundle: aPundle) do:		[ :bless | bless level = aBlessing 			ifTrue: [ ^true ] 		].	^false</body><body package="Store-Ownership" selector="disallowedBlessingsForPundle:">disallowedBlessingsForPundle: aPundle	self isImageAdministrator	      ifTrue:[ ^#( ) ].	self shouldValidateOwnership	ifFalse: [ ^#( ) ].	( Policies ownershipPolicy currentUserHasOwnershipPrivilegesFor: aPundle )		ifTrue:[ ^self administratorBlessings ].	^( Policies ownershipPolicy currentUserHasPublishingPrivilegesFor: aPundle )		ifTrue: [ self administratorBlessings, self ownerBlessings ]		ifFalse: [ self blessingNumbers ]</body><body package="Store-Ownership" selector="objectionsToPublishingBundle:atBlessingLevel:">objectionsToPublishingBundle: aBundle atBlessingLevel: aBlessingLevel 	"Return a string specifying why this bundle may 	not be published.  Return nil if it may."	^self objectionsToPublishingPundle: aBundle atBlessingLevel: aBlessingLevel</body><body package="Store-Ownership" selector="objectionsToPublishingPackage:atBlessingLevel:">objectionsToPublishingPackage: aPackage atBlessingLevel: aBlessingLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^self objectionsToPublishingPundle: aPackage atBlessingLevel: aBlessingLevel</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="initialize">initialize	"OwnerBlessingPolicy blessingPolicy initialize"	super initialize.	( blessings at: #Integrated ) beOwnerOnly.	( blessings at: #ReadyToMerge ) beOwnerOnly.	( blessings at: #Merged ) beOwnerOnly.	( blessings at: #Release ) beAdminOnly.	( blessings at: #Tested ) beQaOnly.</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>administrator</category><body package="Store-Ownership" selector="isImageAdministrator">isImageAdministrator	"Returns a boolean indicating whether or not the user is the Image Administrator"	^DbRegistry isSystemAdministrator</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>private</category><body package="Store-Ownership" selector="currentUserName">currentUserName	^DbRegistry currentUserName</body><body package="Store-Ownership" selector="isOwnershipOn">isOwnershipOn	^true</body><body package="Store-Ownership" selector="objectionsToPublishingPundle:atBlessingLevel:">objectionsToPublishingPundle: aPundle atBlessingLevel: aBlessingLevel 	"Return a string specifying why this Pundle may not be published.  Return nil if it may.	PRIVATE - public access through package/bundle versions of this method."	^self shouldValidateOwnership		ifTrue: 			[ | res1 res2 |			res1 := self validateOwnershipForPundle: aPundle blessingLevel: aBlessingLevel.			res2 := super objectionsToPublishingPundle: aPundle atBlessingLevel: aBlessingLevel.			( res1 notNil and: [ res2 notNil ] )				ifTrue: [ res1 , res2 ]				ifFalse: [ res1 notNil							ifTrue: [ res1 ]							ifFalse: [  res2 ]						]			]		ifFalse: [ nil ]</body><body package="Store-Ownership" selector="shouldValidateOwnership">shouldValidateOwnership		^self isOwnershipOn and: [#{Store.Glorp.StoreAccessPrivilege} isDefined]</body><body package="Store-Ownership" selector="validateOwnershipForPundle:blessingLevel:">validateOwnershipForPundle: aPundle blessingLevel: aBlessingLevel 	^(self basicCanPublish: aPundle atBlessing: aBlessingLevel) 		ifTrue: [nil]		ifFalse: 			[#YouDoNotHaveTheRiLessingLevelOf2s &lt;&lt; #store 				&gt;&gt; 'You do not have the rights to publish &lt;1s&gt; at a blessing level of &lt;2s&gt;' 					expandMacrosWith: aPundle name					with: (self blessingName: aBlessingLevel)]</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>blessings</category><body package="Store-Ownership" selector="administratorBlessings">administratorBlessings	"Returns a list of priviledged blessing numbers that should only be used by the Administrator"	^( self blessings select: [ :bless | bless isAdminOnly ] )		collect: [ :bless | bless level ]</body><body package="Store-Ownership" selector="ownerBlessings">ownerBlessings	"Returns a list of priviledged blessing numberss that should only be used by the pundle owner."	" OwnerBlessingPolicy new ownerBlessings"	^( self blessings select: [ :bless | bless isOwnerOnly ] )		collect: [ :bless | bless level ]</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>blessing menus</category><body package="Store-Ownership" selector="blessingLevelsMenu">blessingLevelsMenu	"Answer a menu with all existing blessing names and levels."	| menu labels values list |	list := self blessings.	self isImageAdministrator		ifFalse: 			[ | adminBlessings |			adminBlessings := self administratorBlessings.			list  := list reject: [ :x | adminBlessings includes: x level ]			].	list := list asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body><body package="Store-Ownership" selector="blessingLevelsMenuForPundle:">blessingLevelsMenuForPundle: aPundle	"*** from 9 January 1995 at 3:44:13 pm by PHM (Philippe F. Monnet	) in B941220 ***"	"Modified to filter out the privileged values for users other than the image administrator"	| list menu labels values  |	list := ( self allowedBlessingLevelsForPundle: aPundle ) asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body></methods><methods><class-id>Store.EnvyStyleBlessingPolicy</class-id> <category>blessing names</category><body package="Store-Ownership" selector="integrationReadyBlessing">integrationReadyBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"		^(blessings at: #Development) level</body></methods><methods><class-id>Store.EnvyStyleBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="initialize">initialize	"Policies blessingPolicy initializeBlessings"	self initializeBlessings.	self defaultBlessing: self developmentBlessing.	( blessings at: #Development ) beOwnerOnly.	( blessings at: #Integrated ) beOwnerOnly.	( blessings at: #Merged ) beOwnerOnly.	( blessings at: #Release ) beAdminOnly.</body><body package="Store-Ownership" selector="initializeBlessings">initializeBlessings	"Policies blessingPolicy initializeBlessings"	blessings := IdentityDictionary new		at: #Broken put: ( BlessingLevel name: 'Broken' level: 10 );		at: #WorkInProgress put: ( BlessingLevel name: 'Scratch' level: 15 );	 	at: #Development put: ( BlessingLevel name:  'Edition' level: 20 );		at: #Integrated put: ( BlessingLevel name:  'Version' level: 50 );		at: #Merged put: ( BlessingLevel name:  'Release'  level: 60 );		at: #Release put: ( BlessingLevel name:  'Product' level:  99 );		yourself.</body></methods><methods><class-id>Store.Glorp.StoreLoadRecord</class-id> <category>accessing</category><body package="Store-Database Model" selector="pundleName">pundleName	^pundleName</body><body package="Store-Database Model" selector="pundleName:">pundleName: anObject	pundleName := anObject</body><body package="Store-Database Model" selector="timestamp">timestamp	^timestamp</body><body package="Store-Database Model" selector="timestamp:">timestamp: anObject	timestamp := anObject</body><body package="Store-Database Model" selector="type">type	^type</body><body package="Store-Database Model" selector="type:">type: anObject	type := anObject</body><body package="Store-Database Model" selector="username">username	^username</body><body package="Store-Database Model" selector="username:">username: anObject	username := anObject</body><body package="Store-Database Model" selector="version">version	^version</body><body package="Store-Database Model" selector="version:">version: anObject	version := anObject</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="binarySave">binarySave	^self first binarySave</body><body package="Store-IMG-Configurations" selector="parcelSave">parcelSave	^self first parcelSave</body><body package="Store-IMG-Configurations" selector="pundle">pundle	^self first pundle</body><body package="Store-IMG-Configurations" selector="version">version	^self first version</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>publishing</category><body package="Store-IMG-Configurations" selector="applySpec:">applySpec: aPublishSpecification	| blessing commentString pundle |	aPublishSpecification publish ifFalse: [^self].	self copyPundleIfNecessaryIn: aPublishSpecification.	pundle := aPublishSpecification pundle.	pundle version: aPublishSpecification version.	(pundle isPackage and: [aPublishSpecification binarySave])		ifTrue: [self prepareBinaryIn: pundle].	blessing := StoreBlessing new.	blessing blessingLevel: aPublishSpecification blessing.	commentString := aPublishSpecification comment asString.	commentString isEmpty ifFalse: [blessing comment: commentString].	pundle bless: blessing.	pundle timestamp: (Dialect storeTimestampIn: publisher targetSession).</body><body package="Store-IMG-Configurations" selector="copyPundleIfNecessaryIn:">copyPundleIfNecessaryIn: aPublishSpecification	"If the image pundle wasn't modified, then we will have a reference to an existing database record, rather than something new to publish. Now we're being told to publish it anyway, so make a new version and replace it in any containing bundle"	| oldPundle newPundle |	aPublishSpecification pundle primaryKey isNil ifTrue: [^self].	oldPundle := aPublishSpecification pundle.	newPundle := oldPundle storeModel asNewStorePundleIn: oldPundle session.	self replacePundle: oldPundle with: newPundle in: aPublishSpecification.</body><body package="Store-IMG-Configurations" selector="prepareBinaryIn:">prepareBinaryIn: aStorePackage		| packageModel |	aStorePackage isBundle ifTrue: [^self].	packageModel := aStorePackage storeModel.	packageModel propertyAt: #packageName put: packageModel name.	aStorePackage binFile: ''</body><body package="Store-IMG-Configurations" selector="publishBlessing">publishBlessing	"Create new blessing/comment records for each item marked for publication."		| published session |	published := IdentitySet new.	publisher := StorePundleWriter new.	session := self first pundle isGlorpObject		ifTrue: [self first pundle session]		ifFalse: [StoreLoginFactory currentStoreSession].	publisher targetSession: session.	publisher splitPundles: false.	[self reverseDo:		[:eachSpecification | 		| pundle |		pundle := eachSpecification pundle.		(published includes: pundle) ifFalse:			[published add: pundle.			eachSpecification setPublisher: publisher.			eachSpecification publishBlessing ifFalse: [^false]]]] 				on: Error 				do: [:exception | exception return: false].	^true</body><body package="Store-IMG-Configurations" selector="publishParcel">publishParcel	self pundle storeModel saveAsParcelFromSpecs: self first</body><body package="Store-IMG-Configurations" selector="publishPundle">publishPundle	| pundle |	(Publishing for: self) started.	pundle := self publishSilently.	(Publishing for: self) finished.	^pundle</body><body package="Store-IMG-Configurations" selector="publishPundleAsParts">publishPundleAsParts	| session |	session := StoreLoginFactory currentStoreSession.	self reverseDo: 		[:each |		(Publishing for: each) started.		each publishSilentlyUsingSession: session.		(Publishing for: each) finished]</body><body package="Store-IMG-Configurations" selector="publishSilently">publishSilently	"Publish the list in reverse order. Answer true if all went well." 	| newPundle targetPundles |	publisher := self first publisher.	DbRegistry clearPundleCaches.	publisher ifNil: 		[publisher := StorePundleWriter new.		publisher targetSession: StoreLoginFactory currentStoreSessionForPublishing.		publisher splitPundles: false].	self do: 		[:each | 		| pundleModel |		pundleModel := each pundleModel.		each binarySave ifFalse:			[pundleModel runPreSave.			pundleModel isBundle ifFalse:				[pundleModel allDefinedClasses do: [:eachClass | eachClass preSave: pundleModel]]]].	Dialect reset.	^[targetPundles := self updateStorePundleItems.	newPundle := [publisher writePundle: self pundle withChangesBasedOn: self pundle storeModel using: targetPundles]		on: GlorpDatabaseWriteError		do: 			[:exception |			StorePublishingError raiseErrorString: exception messageText.			exception return: nil].	newPundle ifNil: [^nil].	newPundle applyPundleVersionsToTheImage.	self parcelSave ifTrue: [self publishParcel].	newPundle ifNotNil: [newPundle storeModel markNotModified].	newPundle] value</body><body package="Store-IMG-Configurations" selector="replace:with:in:">replace: oldPundle with: newPundle in: containingPundle	containingPundle isBundle ifFalse: [^self].	containingPundle isImageModel ifTrue: [^self].	containingPundle bundles		keysAndValuesDo:			[:eachKey :eachValue | 			eachValue storeModel = newPundle storeModel				ifTrue: [containingPundle bundles at: eachKey put: newPundle]].	containingPundle packages		keysAndValuesDo:			[:eachKey :eachValue | 			eachValue storeModel = newPundle storeModel				ifTrue: [containingPundle packages at: eachKey put: newPundle]].</body><body package="Store-IMG-Configurations" selector="replacePundle:with:in:">replacePundle: oldPundle with: newPundle in: aPublishSpecification	aPublishSpecification privateSetDbPundle: newPundle.	aPublishSpecification binarySave ifTrue: [self prepareBinaryIn: aPublishSpecification pundle].	self do:		[:each | 		self			replace: oldPundle			with: newPundle			in: each pundle].</body><body package="Store-IMG-Configurations" selector="updatePundleIn:to:">updatePundleIn: aPublishSpecification to: newPundle	"Update our pundles just in case anything changed in the image since they were created."	| oldPundle |	oldPundle := aPublishSpecification dbPundle asStorePundleIn: publisher targetSession.	self replacePundle: oldPundle with: newPundle in: aPublishSpecification.</body><body package="Store-IMG-Configurations" selector="updateStorePundleItems">updateStorePundleItems	| currentPundle currentPundleItems targetPundles |	currentPundle := self pundle storeModel asStorePundleIn: publisher targetSession.	currentPundleItems := currentPundle withAllContainedItems.	targetPundles := OrderedCollection new.	self do: 		[:eachSpec |		| eachPundle |		eachSpec publish ifTrue: 			[eachPundle := currentPundleItems 				detect: [:each | each storeModel = eachSpec dbPundle storeModel] 				ifNone: [nil].			eachPundle ifNotNil: 				[targetPundles add: eachPundle.				eachSpec binarySave 					ifTrue: [self prepareBinaryIn: eachPundle]					ifFalse: [eachPundle isPackage ifTrue: [eachPundle binFile: nil]].				self updatePundleIn: eachSpec to: eachPundle]]].	self do: [:each | self applySpec: each].	^targetPundles</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>testing</category><body package="Store-IMG-Configurations" selector="isConsistentForPublishing">isConsistentForPublishing	^self allSatisfy: #isConsistentForPublishing</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="filesFromBundle:">filesFromBundle: imageOrDatabaseBundle	| list specs |	list := self new.	imageOrDatabaseBundle fileDescriptions do: 		[:fileRec| 		specs := PublishFileSpecification new file: fileRec.		specs level: 2. 		list add: specs].	^list</body><body package="Store-IMG-Configurations" selector="fromBundle:">fromBundle: aBundleModel	| topLevelSpecification instance binaryPublishedPackages |	(topLevelSpecification := self specClass pundle: aBundleModel)		publish: true;		modified: true.	instance := self with: topLevelSpecification.	binaryPublishedPackages := self getBinaryPublishedPackagesIn: aBundleModel.	aBundleModel descriptionsAndLevels do: 			[:eachDescriptionAndLevel |			| pundleModel pundleDescription publishSpecification |			pundleDescription := eachDescriptionAndLevel at: 1.			pundleModel := pundleDescription component.			(Gathering for: pundleModel) started.			publishSpecification := self specClass pundle: pundleModel						binary: (binaryPublishedPackages includes: pundleModel).			publishSpecification description: pundleDescription.			publishSpecification level: eachDescriptionAndLevel last.			instance add: publishSpecification.			(Gathering for: pundleModel) finished].	((instance allButFirst: 1) allSatisfy: [:each | each binarySave])		ifTrue: [instance do: [:each | each binarySave: true]].	^instance</body><body package="Store-IMG-Configurations" selector="fromDbBundle:">fromDbBundle: aBundleOrStoreBundle	| list trace traceItems masterPublishSpecification |	list := self with: (masterPublishSpecification := self specClass pundle: aBundleOrStoreBundle).	masterPublishSpecification		publish: true;		modified: true.	(trace := aBundleOrStoreBundle parentRecord) isNil		ifTrue: [traceItems := Set new]		ifFalse: [traceItems := trace allItems].	aBundleOrStoreBundle uniqueItemsAndLevels do: 		[:pair |		| pundle publishSpecification |		pundle := pair first.		publishSpecification := self specClass pundle: pundle.		publishSpecification			modified: (traceItems contains: [:each | each primaryKey = aBundleOrStoreBundle primaryKey]);			description: pundle;			version: pundle version;			parentVersion: pundle version;			level: pair last;			yourself.		list add: publishSpecification].	^list</body><body package="Store-IMG-Configurations" selector="getBinaryPublishedPackagesIn:">getBinaryPublishedPackagesIn: aBundleModel	| packagesPublishedBinary session packageKeys results |	session := StoreLoginFactory currentStoreSession.	packageKeys := (aBundleModel descriptionsAndLevels				collect: [:each | each first isPackage ifTrue: [each first id] ifFalse: [nil]])					select: #notNil.	results := OrderedCollection new: packageKeys size.	1 to: packageKeys size		by: 100		do: 			[:index |			| subsetKeys query |			subsetKeys := packageKeys copyFrom: index						to: (index + 99 min: packageKeys size).			query := Query read: Store.Glorp.StorePackage						where: [:eachPundle | (eachPundle id in: subsetKeys) &amp; eachPundle parcel asOuterJoin id notNil].			query retrieve: [:each | each id].			results addAll: (session execute: query)].	packagesPublishedBinary := Set new: packageKeys size * 2.	aBundleModel descriptionsAndLevels do: 			[:each |			| pundleDesc |			pundleDesc := each first.			pundleDesc isPackage				ifTrue: 					[(results includes: pundleDesc id)						ifTrue: [packagesPublishedBinary add: pundleDesc component]]].	^packagesPublishedBinary</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>constants</category><body package="Store-IMG-Configurations" selector="specClass">specClass	^PublishSpecification</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>private</category><body package="Store-Change Management" selector="addDataChanges">addDataChanges	"Add data changes to the change sets."			| chg datum2 |	pundle2 isLoaded		ifFalse: [ pundle2 dataWithSource ].	"cache sources"	pundle1 dataWithSource do:		[ :datum | 		chg := Change new dataKey: datum dataKey.		datum isInClass			ifTrue: [ chg classSymbol: datum absoluteOwnerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: datum absoluteOwnerName asSymbol ].		chg dataKey: datum dataKey.		( self pundle2 includesDatum:  datum )			ifTrue:				[ datum2 := self pundle2 datum: datum dataKey forOwnerNamed: datum absoluteOwnerName.				( datum sourceMatches: datum2 )					ifFalse: 						[ changeSet1 doSubdefChange: chg change.						changeSet2 doSubdefChange: chg change.						].				]			ifFalse: 				[ changeSet1 doSubdefChange: chg add.				changeSet2 doSubdefChange: chg remove.				].		IncrementNotification raiseSignal.		].	pundle2 data do:		[ :datum |  | ownerName |		ownerName := datum ownerName.		( pundle1 includesDatum: datum )			ifFalse: 				[ chg := Change new dataKey: datum dataKey.				datum isInClass					ifTrue: [ chg classSymbol: ownerName ]					ifFalse: [ chg nameSpaceSymbol: ownerName ].				changeSet2 doSubdefChange: chg add.				changeSet1 doSubdefChange: chg remove.				].		]</body><body package="Store-Change Management" selector="addDefClassChanges">addDefClassChanges	"Add def class changes to the change sets."	| chg cls2 |	pundle2 isLoaded		ifFalse: [ pundle2 classesWithSource ].		"cache definitions"	pundle1 classesWithSource do:		[ : cls1 |		chg := Change new classSymbol: cls1 absoluteName.		( pundle2 includesClassNamed: cls1 absoluteName )			ifFalse: 				[ changeSet1 doClassChange: chg add.				changeSet2 doClassChange: chg removeDefinition.				]			ifTrue: 				[ cls2 := pundle2 classInPackageNamed: cls1 absoluteName meta: false. 				( cls1 primaryKey = cls2 primaryKey )					ifFalse:						[ cls1 definition =  cls2 definition							ifFalse: 								[ changeSet1 doClassChange: chg change.								changeSet2 doClassChange: chg change.								].						( cls1 comment string equalsAcrossPlatforms:  cls2 comment string )							ifFalse: 								[ changeSet1 doClassChange: chg comment.								changeSet2 doClassChange: chg comment.								].						]				].		IncrementNotification raiseSignal.		].	pundle2 classesDefinedInPackage do:		[ : cls |		( pundle1 includesClassNamed: cls absoluteName )			ifFalse: 				[ chg := Change new classSymbol: cls absoluteName.				changeSet2 doClassChange: chg add.				changeSet1 doClassChange: chg removeDefinition.				].		].</body><body package="Store-Change Management" selector="addDefClassChangesPublished">addDefClassChangesPublished	"Add def class changes to the change sets from two published packages."	| chg cls2 classes1 classes2 |	classes1 := ( ClassRecord allInPackage: pundle1 primaryKey butNotIn: pundle2 primaryKey ).	classes2 := ( ClassRecord allInPackage: pundle2 primaryKey butNotIn: pundle1 primaryKey ).	classes1 do:		[ : cls1 |		chg := Change new classSymbol: cls1 absoluteName.		( cls2 := classes2 detect: [ :cls | cls1 quickComparesTo: cls ] ifNone: [ nil] ) == nil			ifTrue: 				[ changeSet1 doClassChange: chg add.				changeSet2 doClassChange: chg removeDefinition.				]			ifFalse:				[ classes2 remove: cls2.				cls1 definition =  cls2 definition					ifFalse: 						[ changeSet1 doClassChange: chg change.						changeSet2 doClassChange: chg.						].				cls1 comment string =  cls2 comment string					ifFalse: 						[ changeSet1 doClassChange: chg comment.						changeSet2 doClassChange: chg.						].				].		IncrementNotification raiseSignal.		].	classes2 do:		[ : cls |		chg := Change new classSymbol: cls absoluteName.		changeSet2 doClassChange: chg add.		changeSet1 doClassChange: chg removeDefinition.		IncrementNotification raiseSignal.		].</body><body package="Store-Change Management" selector="addDefNameSpaceChanges">addDefNameSpaceChanges	"Add def namespace changes to the change sets."	| chg ns2 |	pundle2 isLoaded		ifFalse: [ pundle2 nameSpacesWithSource ].		"cache definitions"	pundle1 nameSpacesWithSource do:		[ : ns1 |		chg := Change new nameSpaceSymbol: ns1 absoluteName.		( ns2 := pundle2 nameSpaceInPackageNamed: ns1 absoluteName ) ~~ nil			ifTrue: 				[ ns1 definition =  ns2 definition					ifFalse: 						[ changeSet1 doNameSpaceChange: chg change.						changeSet2 doNameSpaceChange: chg change.						].				( ns1 comment equalsAcrossPlatforms:  ns2 comment )					ifFalse: 						[ changeSet1 doNameSpaceChange: chg comment.						changeSet2 doNameSpaceChange: chg comment.						].				]			ifFalse: 				[ changeSet1 doNameSpaceChange: chg add.				changeSet2 doNameSpaceChange: chg removeDefinition.				].		IncrementNotification raiseSignal.		].	pundle2 nameSpacesDefinedInPackage do:		[ : cls |		( pundle1 includesNameSpaceNamed: cls absoluteName )			ifFalse: 				[ chg := Change new nameSpaceSymbol: cls absoluteName.				changeSet2 doNameSpaceChange: chg add.				changeSet1 doNameSpaceChange: chg removeDefinition.				].		].</body><body package="Store-Change Management" selector="addDefNameSpaceChangesPublished">addDefNameSpaceChangesPublished	"Add def class changes to the change sets from two published packages."	| chg ns2 namespaces1 namespaces2 |	namespaces1 := ( NameSpaceRecord allInPackage: pundle1 primaryKey butNotIn: pundle2 primaryKey ).	namespaces2 := ( NameSpaceRecord allInPackage: pundle2 primaryKey butNotIn: pundle1 primaryKey ).	namespaces1 do:		[ : ns1 |		chg := Change new classSymbol: ns1 absoluteName.		( ns2 := namespaces2 detect: [ :ns | ns1 quickComparesTo: ns ] ifNone: [ nil] ) == nil			ifTrue: 				[ changeSet1 doNameSpaceChange: chg add.				changeSet2 doNameSpaceChange: chg removeDefinition.				]			ifFalse:				[ namespaces2 remove: ns2.				ns1 definition =  ns2 definition					ifFalse: 						[ changeSet1 doNameSpaceChange: chg change.						changeSet2 doNameSpaceChange: chg.						].				( ns1 comment string equalsAcrossPlatforms: ns2 comment string )					ifFalse: 						[ changeSet1 doNameSpaceChange: chg comment.						changeSet2 doNameSpaceChange: chg.						].				].		IncrementNotification raiseSignal.		].	namespaces2 do:		[ : ns |		chg := Change new classSymbol: ns absoluteName.		changeSet2 doClassChange: chg add.		changeSet1 doClassChange: chg removeDefinition.		IncrementNotification raiseSignal.		].</body><body package="Store-Change Management" selector="addMethodChanges">addMethodChanges	"Add method changes to the change sets."			| chg meth2 |	pundle2 isLoaded		ifFalse: [ pundle2 methodsWithSource ].		"to cache sources"	pundle1 methodsWithSource do:		[ :meth |		chg := Change new classSymbol: meth classNameWithMeta; selector: meth selector.		( pundle2 includesMethod: meth )			ifFalse: 				[ changeSet1 doSubdefChange: chg add.				changeSet2 doSubdefChange: chg remove.				]			ifTrue:				[ meth2 := pundle2 method: meth selector forClassNamed: meth absoluteClassName meta: meth isMeta.				( meth primaryKey = meth2 primaryKey )					ifFalse:						[ ( meth sourceMatches: meth2 )							ifFalse: 								[ changeSet1 doSubdefChange: chg change.								changeSet2 doSubdefChange: chg change.								].						]				].		IncrementNotification raiseSignal.		].	pundle2 methods do:		[ :meth |		( pundle1 includesMethod: meth )			ifFalse: 				[ chg := Change new classSymbol: meth className; selector: meth selector.				changeSet2 doSubdefChange: chg add.				changeSet1 doSubdefChange: chg remove.				].		]</body><body package="Store-Change Management" selector="calculateChanges">calculateChanges	 ( pundle1 isLoaded or: [ pundle2 isLoaded ] )		ifTrue: 			[ self addDefClassChanges.			self addDefNameSpaceChanges.			self addMethodChanges.				self  addDataChanges.			self addOtherChanges			] 		ifFalse: [ self fromPackageDifferences: ( PackageDifferences with: pundle1 with: pundle2 ) ]</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="calcItemCount">calcItemCount	"Answer a count for time to calculate changes."	^pundle1 itemCount.</body><body package="Store-Change Management" selector="itemCount">itemCount	^changeSet1 itemCount.</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>fileout</category><body package="Store-Change Management" selector="fileOutChangesFor:within:on:">fileOutChangesFor: anInteger within: aBundle on: aStream		| package |	package := self pundleFor: anInteger.	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[(aStream sourceFormatter)			attributeFor: #package compute: [:ignore | package name];			attributeForMethods: #package compute: [:ignore :moreIgnore | package name].		package fileOutProperties: (self changedPropertiesFor: anInteger) on: aStream].	(self changeSetFor: anInteger) fileOutOn: aStream for: package within: aBundle</body></methods><methods><class-id>Store.PackageChanges class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="fromPackageDifferences:">fromPackageDifferences: pkgDiffs	^self basicNew fromPackageDifferences: pkgDiffs.</body></methods><methods><class-id>Tools.PackageComparisonTool</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="addHeaderBand:">addHeaderBand: aComparison	| headerView |	headerView := PackageComparisonHeaderView new.	headerView comparison: aComparison.	self add: headerView</body><body package="Store-Code Comparison" selector="addHelpButton">addHelpButton	| clicker |	clicker := ClickableGraphic new.	clicker idleGraphic: GeneralIcons help.	clicker when: Clicked do: [ComparisonUsersManual open].	clicker		tooltip: #OpenComparisonToolHelpReference				&gt;&gt; 'Open Comparison Tool Help Reference' &lt;&lt; #IDE.	self add: clicker</body><body package="Store-Code Comparison" selector="addMainComparisonArea:">addMainComparisonArea: aComparison	| scrolled particularsPanel |	particularsPanel := ScrolledComparisonShell new.	particularsPanel comparisonSource: aComparison.	scrolled := (BorderDecorator on: particularsPanel)				useVerticalScrollBar;				noBorder.	self add: scrolled</body><body package="Store-Code Comparison" selector="populateWith:">populateWith: aComparison	self addHeaderBand: aComparison.	self addMainComparisonArea: aComparison.	self addHelpButton.	self updateLayoutAlgorithm</body><body package="Store-Code Comparison" selector="resizeWindowFrom:">resizeWindowFrom: anOriginalWindowOrigin	| window windowBox oldHeight |	window := self topComponent.	windowBox := window bounds.	oldHeight := windowBox height.	windowBox		bottom: windowBox top + ((self mainArea component preferredHeight * 2 min: Screen default bounds height - 50)						max: Screen default bounds height half).	windowBox moveTo: (anOriginalWindowOrigin upBy: (windowBox height - oldHeight) half).	window displayBox: (windowBox translatedBy: (windowBox amountToTranslateWithin: Screen default bounds)).	window label: self headerBand summaryLabel</body></methods><methods><class-id>Tools.PackageComparisonTool</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="headerBand">headerBand	^self children first</body><body package="Store-Code Comparison" selector="mainArea">mainArea	^self children at: 2</body><body package="Store-Code Comparison" selector="openInWindow">openInWindow	| window |	window := ScheduledWindow new useDisplayBuffer.	window label: #ComparingCodeDots &gt;&gt; 'Comparing Code...' &lt;&lt; #IDE.	window component: self.	window openWithExtent: 800 @ Screen default bounds height half.	Screen default sync</body><body package="Store-Code Comparison" selector="swapSides">swapSides	self headerBand swapSides</body><body package="Store-Code Comparison" selector="updateLayoutAlgorithm">updateLayoutAlgorithm	"We don't do this with initializeLayoutAlgorithm, because it would get called by initialize before we've added our 3 main children, so we call this by a different name after we've made sure that's happened."	self layoutAlgorithm: 			[:rect :parts |			| headerBand mainArea helpButton |			headerBand := rect origin						extent: rect width @ (parts first preferredHeight min: rect height half).			mainArea := headerBand bottomLeft corner: rect corner.			helpButton := (rect topRight leftBy: GeneralIcons help width)						extent: GeneralIcons help extent.			Array with: headerBand with: mainArea with: helpButton]</body></methods><methods><class-id>Tools.PackageComparisonTool class</class-id> <category>instance creation</category><body package="Store-Code Comparison" selector="compareFromAll:toAll:">compareFromAll: aCodeComponentCollection toAll: bCodeComponentCollection	| view originalOrigin comparison |	view := self new.	view openInWindow.	Screen default sync.	originalOrigin := view topComponent globalOrigin.	comparison := CodeComponentComparison new.	Store.DbRegistry doIfOnlineImage: 			[			[comparison leftCodeComponents: aCodeComponentCollection				rightCodeComponents: bCodeComponentCollection.			comparison compute]					withStoreFeedbackOn: view topComponent].	view populateWith: comparison.	view resizeWindowFrom: originalOrigin.	^view</body></methods><methods><class-id>Store.LoadDialog class</class-id> <category>public utilities</category><body package="Store-UI" selector="okToLoadBundle:">okToLoadBundle: aDBBundle	"Answer true if it is acceptable to lose changes to modified	 pundles in aDBBundle."	^self okToLoadLeafItems: aDBBundle allUniqueItems.</body></methods><methods><class-id>Store.LoadDialog class</class-id> <category>private</category><body package="Store-UI" selector="okToLoadLeafItems:">okToLoadLeafItems: pundleCollection	| modifiedPundleModels imPundle |	modifiedPundleModels := OrderedCollection new.	pundleCollection do: [:aPundle |		((imPundle := aPundle getImagePundle) notNil 				and: [imPundle hasItselfBeenModified])			ifTrue: [modifiedPundleModels add: imPundle]].	^self okToReplaceModifiedPundles: modifiedPundleModels</body><body package="Store-UI" selector="okToReplaceModifiedPundles:">okToReplaceModifiedPundles: pundleModelCollection	| dialog builder |	pundleModelCollection isEmpty ifTrue: [^true].	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #text put: (self warningForModifiedPundles: pundleModelCollection) asValue.	^dialog openFrom: (self interfaceSpecFor: #loadDialogSpec).</body><body package="Store-UI" selector="warningForModifiedPundles:">warningForModifiedPundles: aPundleCollection 	| warnStream writeItemList |	warnStream := WriteStream on: (String new: 300).	warnStream		nextPutAll: (#TheFollowingItemsHaEmWithNewVersions &lt;&lt; #store &gt;&gt; 'The following items have been modified.  Replace them with new versions?') 						asString;		cr;		cr.	writeItemList := 			[:label :pundles | 			pundles isEmpty 				ifFalse: 					[warnStream						tab;						nextPutAll: label;						cr.					pundles do: 							[:aPundle | 							warnStream								tab;								tab;								nextPutAll: aPundle name;								cr]]].	writeItemList 		value: (#ModifiedPackages &lt;&lt; #store &gt;&gt; 'Modified Packages:') asString		value: (aPundleCollection select: [:aPundle | aPundle isPackage]).	writeItemList 		value: (#ModifiedBundles &lt;&lt; #store &gt;&gt; 'Modified Bundles:') asString		value: (aPundleCollection select: [:aPundle | aPundle isBundle]).	^warnStream contents</body></methods><methods><class-id>Store.Glorp.StoreRBInitializerDefinition</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="fullName">fullName	^nameSpace fullName</body><body package="StoreForGlorpBrowserUI" selector="protocol">protocol	| result |	result := self classOrNameSpace package sharedVariables		detect: [:each | each name = self variableName asString]		ifNone: [^nil].	^result protocol</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>name style</category><body package="Store-Merge Management" selector="setShowLongNames">setShowLongNames	self subclassResponsibility</body><body package="Store-Merge Management" selector="setShowShortNames">setShowShortNames	self subclassResponsibility</body><body package="Store-Merge Management" selector="showCompressedNamesAction">showCompressedNamesAction	mergeTool showCompressedNamesAction</body><body package="Store-Merge Management" selector="showLongNames">showLongNames	self setShowLongNames.	self updateResolutions</body><body package="Store-Merge Management" selector="showLongNamesAction">showLongNamesAction	mergeTool showLongNamesAction</body><body package="Store-Merge Management" selector="showShortNames">showShortNames	self setShowShortNames.	self updateResolutions</body><body package="Store-Merge Management" selector="showShortNamesAction">showShortNamesAction	mergeTool showShortNamesAction</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>testing</category><body package="Store-Merge Management" selector="canApplyResolution">canApplyResolution	^mergeTool canApplyResolution</body><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^mergeTool canBrowseVersions</body><body package="Store-Merge Management" selector="canChooseDoNotResolve">canChooseDoNotResolve	^mergeTool canChooseDoNotResolve</body><body package="Store-Merge Management" selector="canExpandHierarchy">canExpandHierarchy	^mergeTool canExpandHierarchy</body><body package="Store-Merge Management" selector="canUnresolve">canUnresolve	^mergeTool canUnresolve</body><body package="Store-Merge Management" selector="isResolutionSelected">isResolutionSelected	^mergeTool isResolutionSelected</body><body package="Store-Merge Management" selector="isShowAll">isShowAll	^mergeTool isShowAll</body><body package="Store-Merge Management" selector="isShowConflicts">isShowConflicts	^mergeTool isShowConflicts</body><body package="Store-Merge Management" selector="isShowLongNames">isShowLongNames	^mergeTool isShowLongNames</body><body package="Store-Merge Management" selector="isShowShortNames">isShowShortNames	^mergeTool isShowShortNames</body><body package="Store-Merge Management" selector="isShowUnresolved">isShowUnresolved	^mergeTool isShowUnresolved</body><body package="Store-Merge Management" selector="isShowingCodeDifferences">isShowingCodeDifferences	^mergeTool isShowingCodeDifferences.</body><body package="Store-Merge Management" selector="isShowingSourceDifferences">isShowingSourceDifferences	^mergeTool isShowingSourceDifferences.</body><body package="Store-Merge Management" selector="methodSelected">methodSelected	^mergeTool methodSelected</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>menu actions</category><body package="Store-Merge Management" selector="applyResolution">applyResolution	^mergeTool applyResolution</body><body package="Store-Merge Management" selector="browseImplementors">browseImplementors	^mergeTool browseImplementors</body><body package="Store-Merge Management" selector="browseSenders">browseSenders	^mergeTool browseSenders</body><body package="Store-Merge Management" selector="browseVersions">browseVersions	^mergeTool browseVersions</body><body package="Store-Merge Management" selector="doNotResolve">doNotResolve	mergeTool doNotResolve</body><body package="Store-Merge Management" selector="expandHierarchy">expandHierarchy	^mergeTool expandHierarchy</body><body package="Store-Merge Management" selector="showAll">showAll	^mergeTool showAll</body><body package="Store-Merge Management" selector="showConflicts">showConflicts	^mergeTool showConflicts</body><body package="Store-Merge Management" selector="showUnresolved">showUnresolved	^mergeTool showUnresolved</body><body package="Store-Merge Management" selector="toggleFullNames">toggleFullNames	^mergeTool toggleFullNames</body><body package="Store-Merge Management" selector="unresolve">unresolve	^mergeTool unresolve</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>updating</category><body package="Store-Merge Management" selector="finishOpening">finishOpening</body><body package="Store-Merge Management" selector="updateResolutions">updateResolutions	self subclassResponsibility</body><body package="Store-Merge Management" selector="updateResolutionsWithoutRebuild">updateResolutionsWithoutRebuild	self updateResolutions</body><body package="Store-Merge Management" selector="updateSelection">updateSelection	self widget updateAt: self list selectionIndex.</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>accessing</category><body package="Store-Merge Management" selector="mergeTool:">mergeTool: aMergeTool	mergeTool := aMergeTool.</body><body package="Store-Merge Management" selector="resolutionSelectionChanged">resolutionSelectionChanged	mergeTool selectedResolution: list selection</body><body package="Store-Merge Management" selector="selectionIndex">selectionIndex	^list selectionIndex</body><body package="Store-Merge Management" selector="selectionIndex:">selectionIndex: anInteger	list selectionIndex: anInteger.</body><body package="Store-Merge Management" selector="widget">widget	^(self builder componentAt: #ModSet) widget</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="doInitialExpansion">doInitialExpansion</body><body package="Store-Merge Management" selector="release">release	list := nil.	builder := nil.	super release.</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>aspects</category><body package="Store-Merge Management" selector="list">list	self subclassResponsibility</body><body package="Store-Merge Management" selector="modificationMenu">modificationMenu	^mergeTool modificationMenu</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>interface opening</category><body package="Store-Merge Management" selector="preBuildWith:">preBuildWith: aBuilder	super preBuildWith: aBuilder.	self list selectionIndexHolder onChangeSend: #resolutionSelectionChanged to: self.</body></methods><methods><class-id>Store.ResolutionsPane</class-id> <category>private</category><body package="Store-Merge Management" selector="setListWidgetDisplayStringSelector">setListWidgetDisplayStringSelector		builder isNil ifTrue: [^self].	self widget displayStringSelector: nameStyle</body></methods><methods><class-id>Store.ResolutionsPane class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>aspects</category><body package="Store-Merge Management" selector="list">list	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^list isNil		ifTrue:			[list := SelectionInList new]		ifFalse:			[list]</body><body package="Store-Merge Management" selector="reset">reset	self list list: List new.</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>interface opening</category><body package="Store-Merge Management" selector="labelForConflictAtIndex:inView:nameStyle:">labelForConflictAtIndex: anIndex inView: aView  nameStyle: aSymbol	^(self list list at: anIndex)		labelInView: aView		nameStyle: aSymbol</body><body package="Store-Merge Management" selector="postBuildWith:">postBuildWith: aBuilder	| widget |	super postBuildWith: aBuilder.	widget := self widget.	widget selectedVisualBlock: 		[ :view :index | self reverseLabel: (self labelForConflictAtIndex: index inView: view  nameStyle: nameStyle) ].	widget visualBlock: 		[ :view :index | BoundedWrapper on: (self labelForConflictAtIndex: index inView: view  nameStyle: nameStyle) ].</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>accessing</category><body package="Store-Merge Management" selector="tabLabel">tabLabel	^(#ModificationList &lt;&lt; #store &gt;&gt; 'Modification List') asString</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>name style</category><body package="Store-Merge Management" selector="setShowLongNames">setShowLongNames	nameStyle := #longListName.</body><body package="Store-Merge Management" selector="setShowShortNames">setShowShortNames	nameStyle := #shortListName.</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>private</category><body package="Store-Merge Management" selector="reverseLabel:">reverseLabel: aLabel 	"Build the wrappers needed to reverse the label to show it selected."	| rw |	rw := ReversingWrapper on: aLabel.	rw reverse setValue: true.	^BoundedWrapper on: rw</body></methods><methods><class-id>Store.ResolutionsListPane</class-id> <category>updating</category><body package="Store-Merge Management" selector="updateResolutions">updateResolutions		| currentResolution |	currentResolution := mergeTool selectedResolution.	self setListWidgetDisplayStringSelector.	self list list: (mergeTool filteredResolutions sorted: [:each :other | each shortListName &lt;= other shortListName]).	self list selection: currentResolution</body></methods><methods><class-id>Store.ResolutionsListPane class</class-id> <category>accessing</category><body package="Store-Merge Management" selector="tabLabel">tabLabel	^(#ModificationList &lt;&lt; #store &gt;&gt; 'Modification List') asString</body></methods><methods><class-id>Store.Glorp.StoreLoginFactory class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="convertStoreLogin:">convertStoreLogin: aStoreConnectionProfile	"Convert a regular store connection login into a Glorp Login object"	| login |	aStoreConnectionProfile isNil ifTrue: [^nil].	login := StoreLogin new.	"Since we're converting this from something with a stored password anyway, don't worry about discarding the password after use."	login secure: false.	login username: aStoreConnectionProfile userName.	login password: aStoreConnectionProfile password.	login name: aStoreConnectionProfile name.	login connectString: aStoreConnectionProfile environment.	login database: (self databaseFor: aStoreConnectionProfile driverClassName asString) new.	login driverClassName: aStoreConnectionProfile driverClassName asString.	"Postgres doesn't use the table owner"	login schema: (login database supportsTableOwners ifFalse: [''] ifTrue: [aStoreConnectionProfile tableOwner]).	^login</body><body package="Store-Database Model" selector="currentStoreSession">currentStoreSession	"Return a glorp session connected to the current store database and using its connection.  #doIfOnlineImage returns self, not nil, if we are not connected and fail to become so (which is the wrong choice as it returns the block's value, not self, if we are connected or become so).  We code this to ensure we return nil if we cannot ensure being online."	| session |	Store.DbRegistry doIfOnlineImage:		[session := self			currentStoreSessionFromProfile: Store.DbRegistry connectedProfile			andItsConnection: Store.DbRegistry connection].	^session</body><body package="Store-Database Model" selector="currentStoreSessionForPublishing">currentStoreSessionForPublishing	"Return a (new) GlorpSession connected to the current store database, using the same connection.	Use the default session with slight optimizations for faster publishing.	Prevent from fetching source code of unmodified packages."	| newSession methodQuery |	newSession := self currentStoreSession.	methodQuery := ((newSession system descriptorFor: StorePackage)				mappingForAttributeNamed: #methods) query.	methodQuery		tracing: methodQuery defaultTracing;		alsoFetch: #definition.	^newSession</body><body package="Store-Database Model" selector="currentStoreSessionFromProfile:andItsConnection:">currentStoreSessionFromProfile: aConnectionProfile andItsConnection: aConnection	"Return a glorp session connected to store database of the supplied profile and using the connection (which will normally have been obtained from that profile and should always be compatible with it)."	| session login |	login := self convertStoreLogin: aConnectionProfile.	login isNil ifTrue: [^nil].	session := GlorpSession fromLogin: login.	session accessor connection: aConnection.	StoreDescriptorSystem checkConnectionFor: login using: session accessor.	self setPostgresqlSessionToUnicode: session.	login schema isNil ifFalse:		[session system allTables do: [:each | each schema: login schema]].	self setupSessionForSQLServer: session.	^session</body><body package="Store-Database Model" selector="sessionForLogin:">sessionForLogin: aLogin	"Return a glorp session connected to the indicated database"	| session |	session := GlorpSession fromLogin: aLogin.	self setPostgresqlSessionToUnicode: session.	aLogin schema isNil		ifFalse:			[session system allTables do: [:each | each schema: aLogin schema]].	self setupSessionForSQLServer: session.	self tweakForPublicStore: session.	^session.</body><body package="Store-Database Model" selector="sessionForStoreLogin:">sessionForStoreLogin: aStoreConnectionProfile	"Return a glorp session connected to the indicated database"	| aLogin |	aLogin := self convertStoreLogin: aStoreConnectionProfile.	^self sessionForLogin: aLogin.</body><body package="Store-Database Model" selector="setPostgresqlSessionToUnicode:">setPostgresqlSessionToUnicode: session		"We're going to force the encoding, but if it can't tell us which one it's using, then this is so old that it won't let us set the encoding, and we really can't do much about it;  just hope that the encodings match well enough for the characters in use."	| encoding |	(session accessor platform class == PostgreSQLPlatform) ifTrue:		[encoding := session accessor executeSQLString: 'SHOW CLIENT_ENCODING'.		encoding isEmpty			ifTrue: [session accessor encoding: #'iso-8859-1']			ifFalse:				[session accessor encoding: #'utf-8'.				session accessor executeSQLString: 'SET CLIENT_ENCODING TO ''UNICODE''']].</body><body package="Store-Database Model" selector="setupSessionForSQLServer:">setupSessionForSQLServer: session	| blobTable binaryBlobTable methodTable methodsTable skipTables userGroupTable privilegesTable |	(session system platform class == SQLServerPlatform) ifTrue: [		blobTable := session system tableNamed: 'TW_Blob'.		binaryBlobTable := session system tableNamed: 'TW_BinaryBlob'.		(Array with: blobTable with: binaryBlobTable) do: [:each | 		(each schema isNil or: [each schema isEmpty]) 			ifTrue: [each schema: Store.Policies tableSpacePolicy blobTableSpace]			ifFalse: [each schema: Store.Policies tableSpacePolicy blobTableSpace, '.', each schema]].		methodTable := session system tableNamed: 'TW_Method'.		methodsTable := session system tableNamed: 'TW_Methods'.		(Array with: methodTable with: methodsTable) do: [:each | 		(each schema isNil or: [each schema isEmpty]) 			ifTrue: [each schema: Store.Policies tableSpacePolicy methodsTableSpace]			ifFalse: [each schema: Store.Policies tableSpacePolicy methodsTableSpace, '.', each schema]].		userGroupTable := session system tableNamed: 'TW_DBUserGroup'.		privilegesTable := session system tableNamed: 'TW_DBPundlePrivileges'.		(Array with: userGroupTable with: privilegesTable) do: [:each | 		(each schema isNil or: [each schema isEmpty]) 			ifTrue: [each schema: Store.Policies tableSpacePolicy userAndOwnershipTableSpace]			ifFalse: [each schema: Store.Policies tableSpacePolicy userAndOwnershipTableSpace, '.', each schema]].		skipTables := OrderedCollection new			add: blobTable;			add: binaryBlobTable;			add: methodTable;			add: methodsTable;			add: userGroupTable;			add: privilegesTable;			yourself.		session system allTables do: 			[:each |			(skipTables includes: each) ifFalse: 				[(each schema isNil or: [each schema isEmpty]) 					ifTrue: [each schema: Store.Policies tableSpacePolicy defaultTableSpace]					ifFalse: [each schema: Store.Policies tableSpacePolicy defaultTableSpace, '.', each schema]]]].</body><body package="Store-Database Model" selector="tweakForPublicStore:">tweakForPublicStore: aSession	| mapping |	aSession system databaseIdentifier = #psql_public_cst		ifTrue: [			mapping := (aSession system descriptorFor: StorePackage) mappingForAttributeNamed: #propertiesRecordDictionary.			mapping isNil ifTrue: [^self].			mapping shouldUseFilteredRead: false.			mapping := (aSession system descriptorFor: StoreBundle) mappingForAttributeNamed: #propertiesRecordDictionary.			mapping shouldUseFilteredRead: false].</body></methods><methods><class-id>Store.Glorp.StoreLoginFactory class</class-id> <category>constants</category><body package="Store-Database Model" selector="databaseFor:">databaseFor: aDriverString	aDriverString = 'PostgreSQLEXDIConnection' ifTrue: [^PostgreSQLPlatform].	aDriverString = 'OracleConnection' ifTrue: [^OraclePlatform].	aDriverString = 'OracleThreadedConnection' ifTrue: [^OraclePlatform].	aDriverString = 'ODBCConnection' ifTrue: [^AccessPlatform].	aDriverString = 'MS_SQLServerConnection' ifTrue: [^SQLServerPlatform].	aDriverString = 'InterBaseConnection' ifTrue: [^FirebirdPlatform].	aDriverString = 'MSAccessConnection' ifTrue: [^AccessPlatform].	aDriverString = 'SQLite3Connection' ifTrue: [^SQLite3Platform].	aDriverString = 'DB2Connection72' ifTrue: [^DB2Platform].	aDriverString = 'DB2Connection' ifTrue: [^DB2Platform].	^DatabasePlatform</body></methods><methods><class-id>Store.PkgClasses</class-id> <category>accessing</category><body package="Store-DB-Records" selector="classRef">classRef	"Answer the receiver's classRef."	^classRef</body><body package="Store-DB-Records" selector="classRef:">classRef: newClassRef	"Set the receiver's classRef to newClassRef."	classRef := newClassRef</body><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: newClassOrder	"Set the receiver's definitionOrder to newClassOrder."	definitionOrder := newClassOrder</body><body package="Store-DB-Records" selector="metaclassRef">metaclassRef	"Answer the receiver's metaclassRef."	^metaclassRef</body><body package="Store-DB-Records" selector="metaclassRef:">metaclassRef: newMetaclassRef	"Set the receiver's metaclassRef to newMetaclassRef."	metaclassRef := newMetaclassRef</body><body package="Store-DB-Records" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Records" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self classRef with: self metaclassRef</body><body package="Store-DB-Records" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self classRef</body></methods><methods><class-id>Store.PkgClasses</class-id> <category>printing</category><body package="Store-DB-Records" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: packageRef printString, ': ', classRef printString, ' ', metaclassRef printString;		nextPut: $).</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>private-utilities</category><body package="Store-DB-Records" selector="copyClassesFromTrace:to:">copyClassesFromTrace: oldPkgID to: newPkgID 	"Copy all methods present in oldPkgID 	into newPkgID."	self broker process: 		( self newSQL				insert:  #( packageRef classRef metaclassRef classOrder );				select: 	( Array with: newPkgID printString with: #classRef with: #metaclassRef with: #classOrder );				where;				column: #packageRef equalTo: oldPkgID printString).</body><body package="Store-DB-Records" selector="removeClass:meta:inPackage:">removeClass: oldID meta: oldMetaID  inPackage: pkgID 	"Remove the row: pkgID, mID"	self broker process: (self newSQL						delete;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #classRef equalTo: oldID printString;						and;						column: #metaclassRef equalTo: oldMetaID printString).</body><body package="Store-DB-Records" selector="replaceClass:meta:with:meta:inPackage:">replaceClass: oldID meta: oldMetaID with: newID meta: newMetaID inPackage: pkgID 	"Replace the row: pkgID, oldID with a row: pkgID, newID"	self broker process: (self newSQL						update;						column: #classRef equalTo: newID printString;						column: #metaclassRef equalTo:newMetaID printString;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #classRef equalTo: oldID printString;						and;						column: #metaclassRef equalTo: oldMetaID printString)</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes	| dict |	( dict := Dictionary new )		at: 'packageRef' put: #PrimaryKey;	 	at: 'classRef' put: #PrimaryKey;		at: 'metaclassRef' put: #PrimaryKey;		at: 'definitionOrder' put: #Integer.	self checkFieldsWith: dict.	^dict</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="allMetaclassesInAndOnlyIn:">allMetaclassesInAndOnlyIn: packageKeys	"Send to a concrete subclass. Answer a collection of ids of instance records 	that is in the set of packages and no others." 	"Already obsolete :-). But I need it for old packages."	| rows out in |	rows := self allPackagesCrossReferenced: packageKeys refColumn: #metaclassRef.	out := Set new: rows size.	in := Set new: rows size.	rows do:		[ :row |		( packageKeys includes: row packageRef )			ifTrue: 				[ ( out includes: row metaclassRef )					ifFalse: [ in add: row metaclassRef ]				]			ifFalse: 				[ out add: row metaclassRef.				in remove: row metaclassRef ifAbsent: nil.				]		].	^in asOrderedCollection</body><body package="Store-DB-Records" selector="packagesContainingClass:">packagesContainingClass: aClassID	"Check what packages define a given class.	Return a collection of package IDs "	"self packagesContainingClass: 2978"	^[(self broker process: 				( self newSQL					select: #( packageRef );					where;					column: #classRef equalTo: aClassID printString)	 ) collect: [:each| each first]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer.  OrderedCollection new].</body><body package="Store-DB-Records" selector="packagesContainingMetaclass:">packagesContainingMetaclass: aClassID	"Check what packages define a given class.	Return a collection of package IDs "	"self packagesContainingMetaclass: 2982"	^[(self broker process: 					( self newSQL						select: #( packageRef );						where;						column: #metaclassRef equalTo: aClassID printString)	 )  collect: [:each| each first]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_PkgClsReverse' #('classRef'))		)</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn		^#classRef</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	| canvas |	canvas := builder componentAt: #notebook.	canvas isNil ifTrue: [^self].	canvas widget		client: self		spec: #activeAreaSpec		builder: builder.	builder window keyboardProcessor keyboardHook: [:ev :ctrlr | self disturb. ev].	self updatePreferences</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>private</category><body package="Store-UI" selector="disturb">disturb	disturbed value: true.	^true</body><body package="Store-UI" selector="enableButtons">enableButtons	| button |	(button := subBuilder namedComponents at: #resetButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]].	(button := subBuilder namedComponents at: #acceptButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]]</body><body package="Store-UI" selector="helpAction">helpAction	| sh |	sh := SimpleHelp helpString: self helpString.	sh class  openOn: sh</body><body package="Store-UI" selector="helpString">helpString	^self perform: (self class tabSpecsAndHelpSelectors at: list selectionIndex) last.</body><body package="Store-UI" selector="masterList">masterList	^self class masterList.</body><body package="Store-UI" selector="rebuild">rebuild	| canvas next |	canvas := builder componentAt: #activeComponents.	next := (self class tabSpecsAndHelpSelectors at: list selectionIndex) first.	canvas widget		client: self		spec: next		builder: (subBuilder := self builder newSubBuilder)</body><body package="Store-UI" selector="requestSliceChange">requestSliceChange	| win |	builder notNil ifTrue: [win := builder window].	self disturbed		ifTrue:			[(Dialog					confirm: (#alteredNotAccepted &lt;&lt; #dialogs &gt;&gt; 'Settings have been altered but not accepted.Do you wish to discard the changes?')					for: win)				ifTrue: [self resetForSlice. ^true]				ifFalse: [^false]]		ifFalse: [^true]</body><body package="Store-UI" selector="resetForSlice">resetForSlice	(subBuilder componentAt: #resetButton) widget model value: true.	self undisturb</body><body package="Store-UI" selector="setFocus">setFocus	"Set the keyboard input focus to be the first text input widget on the focus chain."	builder keyboardProcessor keyboardConsumers do: 			[:aWidget |			(aWidget isKindOf: ComposedTextView)				ifTrue: 					[builder keyboardProcessor focusedView: aWidget.					(aWidget isKindOf: TextEditorView)						ifTrue: [aWidget controller selectEntireText].					^aWidget invalidate]]</body><body package="Store-UI" selector="undisturb">undisturb	disturbed value: false</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>top level</category><body package="Store-UI" selector="preferenceMasterList">preferenceMasterList	^list</body><body package="Store-UI" selector="updatePreferences">updatePreferences	"Update the subcanvas for the currently selected preference item. Answer the receiver."	self rebuild.	self setFocus</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>events</category><body package="Store-UI" selector="requestForWindowClose">requestForWindowClose	^self requestSliceChange</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>accessing</category><body package="Store-UI" selector="disturbed">disturbed	^disturbed value</body></methods><methods><class-id>Store.StorePublishDialog</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	list := SelectionInList new.	list list: self masterList.	list selectionIndexHolder value: 1.	list selectionIndexHolder onChangeSend: #updatePreferences to: self.	(disturbed := false asValue) onChangeSend: #enableButtons to: self</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>constants</category><body package="Store-UI" selector="windowLabel">windowLabel	"Answer a string for the window label."	self subclassResponsibility</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	^self windowNotebookSpec</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>accessing</category><body package="Store-UI" selector="developmentTabLabels">developmentTabLabels	^developmentTabLabels</body><body package="Store-UI" selector="masterList">masterList	^DeploymentOptionsSystem isDevelopment 		ifTrue: [self developmentTabLabels]		ifFalse: [self runtimeTabLabels]</body><body package="Store-UI" selector="runtimeTabLabels">runtimeTabLabels	^runtimeTabLabels</body><body package="Store-UI" selector="tabSpecsAndHelpSelectors">tabSpecsAndHelpSelectors	^tabSpecsAndHelpSelectors</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private-visual blocks</category><body package="Store-UI" selector="computeLabelsForView:">computeLabelsForView: aView 	"Compute all the labels right away so that we know 	what offsets to use. Store the labels so that extra 	database accesses are not needed to recompute them."	| max1 max2 max3 |	max1 := max2 := max3 := 0.	labelDict := Dictionary new: self currentItems list size.	self currentItems list do: 		[ :anItem |  | publishFlag pndl label1 label2 label3 label4 level levelOffset |		publishFlag := anItem publish.		label1 := LabelAndIcon with: ''.		publishFlag ifTrue: [label1 beCheckMark].		levelOffset := 10.		level := levelOffset * (anItem level).		pndl := anItem pundle.		label2 := pndl elementLabel: #().		label2 text: pndl name asText.		label2 attributes: aView textStyle.		label3 := Label with: (publishFlag					ifTrue: [anItem version]					ifFalse: [anItem parentVersion]).		label3 attributes: aView textStyle.		label4 := Label with: (publishFlag					ifTrue: [Policies blessingPolicy blessingName: (anItem blessing)]					ifFalse: ['']).		label4 attributes: aView textStyle.		labelDict at: anItem put: 			( Array				with: label1				with: (Array with: label2 with: level)				with: label3				with: label4).		max1 := label1 width max: max1.		max2 := label2 width + level max: max2.		max3 := label3 width max: max3		].	offsets := Array				with: 6				with: max1 + 16				with: max2 + max1 + 26				with: max3 + max2 + max1 + 56.</body><body package="Store-UI" selector="labelForItem:view:">labelForItem: anItem view: aView	| cp labels |	cp := CompositePart new.	(labelDict == nil or: [(labelDict at: anItem ifAbsent: nil) == nil])		ifTrue: [self computeLabelsForView: aView].	labels := labelDict at: anItem.	cp		add: (labels at: 1)		at: (offsets at: 1) @ 0.	cp		add: (labels at: 2) first		at: ((offsets at: 2) + (labels at: 2) last) @ 0.	cp		add: (labels at: 3)		at: (offsets at: 3) @ 0.	^cp</body><body package="Store-UI" selector="listVisualBlock">listVisualBlock	""	^	[:view :index | 	| arr label | 	arr := view sequence at: index.	label := self labelForItem: arr view: view.	BoundedWrapper on: label]</body><body package="Store-UI" selector="selectedListVisualBlock">selectedListVisualBlock	""	^	[:view :index | 	| arr label rw|	arr := view sequence at: index.	label := self labelForItem: arr view: view.	rw := ReversingWrapper on: label.	rw reverse setValue: true.	BoundedWrapper on: rw]</body><body package="Store-UI" selector="setVisualBlocks">setVisualBlocks	| itemList |	( itemList := self subComponentAt: #itemsList ) == nil		ifFalse:			[ itemList widget visualBlock: self listVisualBlock.			itemList widget selectedVisualBlock: self selectedListVisualBlock.			].	( itemList := self subComponentAt: #fileList ) == nil		ifFalse:			[ itemList widget visualBlock: self listVisualBlock.			itemList widget selectedVisualBlock: self selectedListVisualBlock.			].</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"Publish a pundle.  	It's possible there have been changes to the bundle since we opened the dialog, 	so tell the user to retry and close the UI without publishing, because otherwise the 	pundles will/can get nil blessing levels and versions."	| navigatorClass |	self validateParcelOptions ifFalse: [^self].	self validateFileOptions ifFalse: [^self].	self validatePublishStateIsConsistent ifFalse: [^self].	(self canPublish: self pundle atBlessingLevel: self blessingLevel value) ifFalse: [^self].	self newGlobalState.	self fillEmptyComments.	self updateFiles.	StoreProgressOverlay 		subsume: builder window		while: 			[self specList publishPundle.			callBackBlock ifNotNil: [callBackBlock value: items list]].	navigatorClass := #{Refactory.Browser.BrowserNavigator} valueOrDo: [^self].	navigatorClass updatePackageListsInOpenWindows.	self closeAndUnschedule</body><body package="Store-UI" selector="addFile">addFile	| dialog result fileSpec |	dialog := OpenFileDialog new.	dialog 		windowTitle: 'Select File Attachment For Bundle';		acceptButtonLabel: 'Add File';		addFilterForAllFiles;		fileCondition: #any.	result := dialog open		ifTrue: [dialog selection]		ifFalse: [nil].	result ifNil: [^nil].	fileSpec := (Store.PublishFileSpecification new)			file: (FileModel from: result);			publish: true;			yourself.	self fileList add: fileSpec</body><body package="Store-UI" selector="allBlessings">allBlessings	"Use current blessinglevel/comment for all items."		self forAllItemsDo:		[:each | 		each blessing: self blessingLevel value.		each comment: self blessingComment value].	labelDict := nil.	self newSelection</body><body package="Store-UI" selector="allVersions">allVersions	"Mark all items for publishing."	self versionString value isEmpty		ifFalse: [ self setAllVersionsTo: versionString value ].	self newSelection</body><body package="Store-UI" selector="canPublish:atBlessingLevel:">canPublish: aPundle atBlessingLevel: aNumber	| objections |	objections := Policies publishPolicy objectionsToPublishingPundle: aPundle atBlessingLevel: aNumber.	objections ifNil: [^true].	Dialog warn: (#YourPolicyPreventsTLessingLevelN1s &lt;&lt; #store &gt;&gt; 			'The publish policy prevents the publication at this blessing level:&lt;n&gt;&lt;1s&gt;' 			expandMacrosWith: objections).	^false</body><body package="Store-UI" selector="cancel">cancel	"Disconnect us from the database, so if our background operations are still in progress they will error out."	self closeAndUnschedule</body><body package="Store-UI" selector="copyFromPackage">copyFromPackage	self parcelVersionString value: (self versionString value).	(subBuilder componentAt: #VersionString) ifNotNil: [:value | value widget controller accept]</body><body package="Store-UI" selector="publishAllNo">publishAllNo	self forAllItemsDo: 		[ :ar | ar publish: ar modified  ].	labelDict := nil.	self newSelection</body><body package="Store-UI" selector="publishAllYes">publishAllYes	self forAllItemsDo: 		[ :ar | 		( ar modified )			ifFalse: [ ar publish: true ]		].	labelDict := nil.	self newSelection</body><body package="Store-UI" selector="removeFile">removeFile	| selectedFile |	selectedFile := self files selection.	self files list remove: selectedFile ifAbsent: [self halt]</body><body package="Store-UI" selector="updateFiles">updateFiles	| targetPundleModel fileDescriptions |	targetPundleModel := self specList first dbPundle.	fileDescriptions := targetPundleModel fileDescriptions.	self fileList do:		[:each |		each publish ifTrue:			[(fileDescriptions contains: [:eachFile | eachFile portableFilename asString = each name])				ifTrue:					[targetPundleModel removeFile: each name.					targetPundleModel addFile: each name]				ifFalse: [targetPundleModel addFile: each name]]].	fileDescriptions := targetPundleModel fileDescriptions copy.	fileDescriptions do:		[:each |		(self fileList anySatisfy: [:eachFile | eachFile name = each portableFilename asString]) ifFalse:			[targetPundleModel removeFile: each portableFilename asString]]</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>aspects</category><body package="Store-UI" selector="binarySave">binarySave		binarySave ifNil: 		[binarySave := false asValue.		binarySave onChangeSend: #binarySaveChanged to: self].	^binarySave</body><body package="Store-UI" selector="binarySaveChanged">binarySaveChanged	"If the globalOptions (the bundle) is the selection item, then all items get the same value.	However, if the current item is NOT the global (bundle) AND the global (bundle) says no to binary, then this one can be either or"	self items selection = self globalOptions		ifFalse: 			[self globalOptions binarySave value ifFalse: 				[self items selection binarySave: binarySave value]]		ifTrue: [self items list do: [:each | each binarySave: self binarySave value]].</body><body package="Store-UI" selector="blessingComment">blessingComment	blessingComment == nil		ifTrue: [ blessingComment := String new asValue ].	^blessingComment</body><body package="Store-UI" selector="blessingLevel">blessingLevel	blessingLevel == nil		ifTrue:			[blessingLevel := self initialBlessingLevel asValue.			blessingLevel onChangeSend: #blessingLevelChanged to: self].	^blessingLevel</body><body package="Store-UI" selector="bundleStructure">bundleStructure	bundleStructure == nil		ifTrue: [ bundleStructure := false asValue ].	^bundleStructure</body><body package="Store-UI" selector="bundleStructureChanged">bundleStructureChanged	"Enable the database links depending on whether the structure will be saved."	self enableComponentAt: #databaseLinks enable: self bundleStructure value.	self databaseLinks value: ( self databaseLinks value  &amp;  self bundleStructure value ).</body><body package="Store-UI" selector="databaseLinks">databaseLinks	databaseLinks == nil		ifTrue: [ databaseLinks := false asValue ].	^databaseLinks</body><body package="Store-UI" selector="files">files	files == nil		ifTrue: [ files := SelectionInList new list: PublishSpecificationList new ].	^files</body><body package="Store-UI" selector="globalOptions">globalOptions	^self items list first.</body><body package="Store-UI" selector="items">items	items == nil		ifTrue: [ items := SelectionInList new ].	^items</body><body package="Store-UI" selector="parcelBackup">parcelBackup	parcelBackup == nil		ifTrue: [ parcelBackup := false asValue ].	^parcelBackup</body><body package="Store-UI" selector="parcelDetails">parcelDetails	^#( parcelDirectory 		parcelOverwrite 		parcelRepublish		parcelSaveSource 		parcelBackup		VersionString		CopyFromPackage		), self parcelSaveSourceDetails</body><body package="Store-UI" selector="parcelDirectory">parcelDirectory		parcelDirectory ifNil: 		[parcelDirectory := (self pundle storeModel ifNotNil: [:value | value parcelDirectory]) isNil			ifTrue: [(PundleAccess parcelDirectory asFilename construct: self pundle parcelName) asString asValue]			ifFalse: [self pundle storeModel parcelDirectory asString asValue]].	^parcelDirectory</body><body package="Store-UI" selector="parcelHideSource">parcelHideSource	parcelHideSource == nil		ifTrue: [ parcelHideSource := false asValue ].	^parcelHideSource</body><body package="Store-UI" selector="parcelOverwrite">parcelOverwrite	parcelOverwrite == nil		ifTrue: [ parcelOverwrite := false asValue ].	^parcelOverwrite</body><body package="Store-UI" selector="parcelPadded">parcelPadded	parcelPadded == nil		ifTrue: [ parcelPadded := false asValue ].	^parcelPadded</body><body package="Store-UI" selector="parcelRepublish">parcelRepublish	parcelRepublish == nil		ifTrue: [ parcelRepublish := false asValue ].	^parcelRepublish</body><body package="Store-UI" selector="parcelSave">parcelSave	parcelSave == nil		ifTrue: [ parcelSave := false asValue ].	^parcelSave</body><body package="Store-UI" selector="parcelSaveChanged">parcelSaveChanged	"Enable the parcel directory depending on whether parcel will be published."	| shouldSave |	shouldSave := self parcelSave value.	self parcelDetails do: [:each | self enableComponentAt: each enable: shouldSave].	self enableComponentAt: #bundleStructure enable: (shouldSave and: [self pundle isBundle]).	self bundleStructure value: (parcelSave value and: [bundleStructure value]).	self bundleStructureChanged.	self parcelSaveSourceChanged</body><body package="Store-UI" selector="parcelSaveSource">parcelSaveSource	parcelSaveSource == nil		ifTrue: [ parcelSaveSource := true asValue ].	^parcelSaveSource</body><body package="Store-UI" selector="parcelSaveSourceChanged">parcelSaveSourceChanged	"Enable/disable the subcheck boxes depending on sources."	| save |	save := self parcelSaveSource value &amp;  ( self parcelSave value ).	self parcelSaveSourceDetails do:		[ :sym | self enableComponentAt: sym enable: save ].	self parcelRepublish value: ( self parcelRepublish value &amp; save ).	self enableComponentAt: #parcelRepublish enable: save.</body><body package="Store-UI" selector="parcelSaveSourceDetails">parcelSaveSourceDetails	^#( parcelHideSource 		parcelPadded 		)</body><body package="Store-UI" selector="parcelVersionString">parcelVersionString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelVersionString isNil		ifTrue:			[parcelVersionString := String new asValue]		ifFalse:			[parcelVersionString]</body><body package="Store-UI" selector="parcelWarningMessage">parcelWarningMessage	parcelWarningMessage == nil		ifTrue: [ parcelWarningMessage := self validateParcelSaveString ].	^parcelWarningMessage</body><body package="Store-UI" selector="publish">publish	publish == nil		ifTrue: 			[ 			publish := false asValue.			self disableDetails.			].	^publish</body><body package="Store-UI" selector="publishFile">publishFile	publishFile == nil		ifTrue: [ publishFile := false asValue ].	^publishFile</body><body package="Store-UI" selector="versionString">versionString	versionString == nil		ifTrue: [ versionString := String new asValue ].	^versionString</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private</category><body package="Store-UI" selector="blessingLevelChanged">blessingLevelChanged	self specList do: [:each | each blessing: self blessingLevel value]</body><body package="Store-UI" selector="connectionLabel">connectionLabel		^self class connectionLabel</body><body package="Store-UI" selector="detailHolders">detailHolders	^OrderedCollection		with: self publish		with: self blessingComment		with: self versionString</body><body package="Store-UI" selector="details">details	"Answer a list of ids for individual pundle settings."	^#( blessingLevelButton blessingComment vStringLabel 		bCommentLabel versionStringBox )</body><body package="Store-UI" selector="disableDetails">disableDetails	| comp |	self details do: 		[ :sym | 		( comp := self subComponentAt: sym ) == nil 			ifFalse: [ comp disable ]		]</body><body package="Store-UI" selector="disablePublishBox">disablePublishBox	self enableComponentAt: #publishSelectedCheck enable: false.</body><body package="Store-UI" selector="enableDetails">enableDetails	self currentItems selection notNil		ifTrue: 			[ ( self currentItems selection modified )				ifTrue: [ self disablePublishBox ]				ifFalse: [ self enablePublishBox ].			self publish value 				ifTrue: 					[ self details do: 						[:sym | self enableComponentAt: sym enable: true ] 					]			]</body><body package="Store-UI" selector="enablePublishBox">enablePublishBox	self enableComponentAt: #publishSelectedCheck enable: true.</body><body package="Store-UI" selector="forAllItemsDo:">forAllItemsDo: aBlock	| alist |	alist := self currentItems list.	1 to: alist size do: 		[ :i | | ar |		ar := alist at: i.		aBlock value: ar.		alist at: i put: ar		]</body><body package="Store-UI" selector="newDetailState">newDetailState	| sel duplicates |	sel := self currentItems selection.	duplicates := self currentItems list		select: [:each | each pundle == sel pundle].	duplicates		do:			[:each | 			| index sub |			each publish: self publish value.			each comment: self blessingComment value.			each version: self versionString value.			index := self currentItems list indexOf: each.			(sub := self subComponentAt: #itemsList) == nil				ifFalse: [sub widget updateAt: index].			(sub := self subComponentAt: #fileList) == nil				ifFalse: [sub widget updateAt: index]].	labelDict := nil</body><body package="Store-UI" selector="newGlobalState">newGlobalState	"Update the global (belonging to the outer bundle) state.	Note: We don't update binarySave since that is now package by package"	^self globalOptions		parcelSave: self parcelSave value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelPadded: self parcelPadded value;		parcelVersionString: self parcelVersionString value;		yourself.</body><body package="Store-UI" selector="newItemSelection">newItemSelection	self newSelection.	self items selection ifNil: [^self].	self binarySave setValue: (self items list at: self items selectionIndex) binarySave.	self builder window component invalidate</body><body package="Store-UI" selector="newPublishState">newPublishState	"Publish selected. If an pundle is marked for publish, mark containing bundles as well."	self publish value		ifFalse: [ ^self ].	self publishState: self currentItems selection pundle.</body><body package="Store-UI" selector="newSelection">newSelection		self currentItems selection isNil		ifFalse:			[self setDetailState.			self enableDetails]		ifTrue:			[self disableDetails.			self disablePublishBox]</body><body package="Store-UI" selector="publishState:">publishState: aPundle	"aPundle has been marked for publication. Mark all bundles containing it as well, except those in the DB (not in image)"	self forAllItemsDo: 		[:each |		| pundle |		pundle := each pundle.		(pundle isLoaded and: [pundle isImageObject]) ifFalse: [^self].			((pundle := each pundle) isBundle and: [pundle containsItem: aPundle])			ifTrue: 				[each publish: self publish value.				self publishState: pundle]]</body><body package="Store-UI" selector="retractDetailInterest">retractDetailInterest	self publish retractInterestsFor: self.	self detailHolders do: 		[ :dh | dh retractInterestsFor: self ].</body><body package="Store-UI" selector="setAllVersionsTo:">setAllVersionsTo: aString	self forAllItemsDo: [ :ar | ar version: aString ].	labelDict := nil.</body><body package="Store-UI" selector="setDetailInterest">setDetailInterest	self publish onChangeSend: #newPublishState to: self.	self detailHolders do: [:dh| dh onChangeSend: #newDetailState to: self].</body><body package="Store-UI" selector="setDetailState">setDetailState	| sel |	sel := self currentItems selection.	self retractDetailInterest.	self publish value: sel publish.	self blessingComment value: sel comment.	self versionString value: sel version.	self setDetailInterest</body><body package="Store-UI" selector="setDetailState:">setDetailState: selection	self retractDetailInterest.	self publish value: selection publish.	self blessingComment value: selection comment.	self versionString value: selection version.	self setDetailInterest</body><body package="Store-UI" selector="trapForEsc:">trapForEsc: anEvent	"If the event is an escape then 'press' the cancel button"		^anEvent keyValue = Character esc		ifTrue:			[(self widgetAt: #cancelButton) model value: true.			nil]		ifFalse: [anEvent]</body><body package="Store-UI" selector="updateFilePreferences">updateFilePreferences	| indx |	indx := self files selectionIndex.	( self subComponentAt: #filesList ) widget updateAt: indx</body><body package="Store-UI" selector="updateItemList">updateItemList	( self subComponentAt: #itemsList ) widget updateModel.	labelDict := nil.</body><body package="Store-UI" selector="updateSelectedItem">updateSelectedItem	| indx |	indx := self currentItems selectionIndex.	( self subComponentAt: #itemsList ) widget updateAt: indx</body><body package="Store-UI" selector="userNameLabel">userNameLabel		^self class userNameLabel</body><body package="Store-UI" selector="validateFileOptions">validateFileOptions	| msg1 msg2 |	msg1 := #File1sDoesNotExist &lt;&lt; #store &gt;&gt; 'File: &lt;1s&gt; does not exist.'.	msg2 :=  #File1snDoesNotExistInDB &lt;&lt; #store &gt;&gt; 'File: &lt;1s&gt;&lt;n&gt; does not exist in the database and is not being published.'.	self fileList do:		[ :fspec | 		fspec publish 			ifTrue: 				[ ( fspec file portableFilename exists )					ifFalse: 						[ Dialog warn: ( msg1 expandMacrosWith: fspec file name ).					^false 					]				] 			ifFalse: 				[ ( fspec file dbTrace isNil )					ifTrue: 						[ Dialog warn:  ( msg2  expandMacrosWith: fspec file name ).						^false						]				].		].	^true</body><body package="Store-UI" selector="validateParcelOptions">validateParcelOptions		| filename |	self parcelSave value ifFalse: [^true].	((filename := self basePath , Parcel fileExtension) asFilename exists and: [self parcelOverwrite value not])		ifTrue:			[(Dialog confirm: (#_n1sExistsnnOverwriteFiles &lt;&lt; #store &gt;&gt; '&lt;n&gt;&lt;1s&gt; exists: &lt;n&gt;&lt;n&gt;Overwrite files?&lt;n&gt;' expandMacrosWith: filename))				ifTrue: [self parcelOverwrite value: true]				ifFalse: [^false]].	self pundle parcelDirectory: filename.	^true</body><body package="Store-UI" selector="validatePublishStateIsConsistent">validatePublishStateIsConsistent	"We look at all the specs and validate that ALL pass #isConsistentForPublishing	The result is to make sure that no package has been changed behind the back of this dialog.	If it has, we disable the 'Publish' button as a way of saying 'You Can Go No Further!'"	(self items list isConsistentForPublishing)		ifTrue: [^true].	Dialog warn: (#AtLeastOneBuckageHasBeenModifiednRetry &lt;&lt; #store &gt;&gt; 'At least one Package or Bundle has been modifed since the Publish Dialog was opened.&lt;n&gt;Please cancel this publish, and retry') expandMacros.	(self builder componentAt: #publishButton) isEnabled: false.	^false</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="buildInSubCanvas:withBuilder:">buildInSubCanvas: spec withBuilder: aBuilder 	"Reimplement to ensure that visualBlocks are set up on the subcanvas if was installed."	super buildInSubCanvas: spec withBuilder: aBuilder.	"subBuilder will not be nil if we are building a page on the notebook."	subBuilder isNil ifFalse: 		[self setVisualBlocks].	^aBuilder</body><body package="Store-UI" selector="localPostOpenWith:">localPostOpenWith: aBuilder	[(Gathering for: (pundleModel ifNil: [self pundle])) started.	self mainWindow label: ''.	(pundleModel notNil and: [pundleModel isBundle]) ifTrue: 		[self items list: (self class publishSpecsFrom: pundleModel).		self files list: (self class publishFileSpecsFrom: pundleModel)].	self mainWindow label: self windowLabel.	self items selectionIndexHolder onChangeSend: #newItemSelection to: self.	self files selectionIndexHolder onChangeSend: #newSelection to: self.	self setVisualBlocks.	self items selectionIndex: 1.	self copyFromPackage.	self parcelSaveChanged.	self setGlobalEnablement.	(Gathering for: (pundleModel ifNil: [self pundle])) finished] withStoreFeedbackOn: self mainWindow</body><body package="Store-UI" selector="localRebuild">localRebuild		self setVisualBlocks.	self setGlobalEnablement.	self parcelSaveChanged.	self newSelection</body><body package="Store-UI" selector="openOnPundleModel:">openOnPundleModel: aPundleModel	pundleModel := aPundleModel.	labelDict := nil.	self open</body><body package="Store-UI" selector="openWith:">openWith: userData	self items list: userData.	labelDict := nil.	self open</body><body package="Store-UI" selector="openWith:ifSucessfulDo:">openWith: userData ifSucessfulDo: aOneArgumentBlock	callBackBlock := aOneArgumentBlock.		self openWith: userData.</body><body package="Store-UI" selector="openWith:with:">openWith: userData with: fileData	( ( fileData notEmpty ) &amp; ( DbRegistry isDb73Enabled not ) )		ifTrue: [ Dialog warn: 'Your database does not support external files.&lt;n&gt;Publishing will cause your image to forget attatched external files.' expandMacros ].	self items list: userData.	self files list: fileData.	labelDict := nil.	self open</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	aBuilder keyboardProcessor keyboardHook: [:event :controller | self trapForEsc: event]</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	super postOpenWith: aBuilder.	self localPostOpenWith: aBuilder.</body><body package="Store-UI" selector="preBuildWith:">preBuildWith: aBuilder 	"This message is sent by the builder prior to beginning construction 	of either a SubCanvas or a complete window."	aBuilder 		aspectAt: #blessingLevelMenu 		put: Policies blessingPolicy blessingLevelsMenu.</body><body package="Store-UI" selector="rebuild">rebuild		super rebuild.	self localRebuild.</body><body package="Store-UI" selector="requestSliceChange">requestSliceChange	^true</body><body package="Store-UI" selector="resetForSlice">resetForSlice</body><body package="Store-UI" selector="setGlobalEnablement">setGlobalEnablement	self enableComponentAt: #parcelSave enable: true.	self enableComponentAt: #binarySave enable: true.</body><body package="Store-UI" selector="windowLabel">windowLabel		^#PublishingPackageOrBundleC2S &lt;&lt; #labels &gt;&gt; 'Publishing &lt;1?Package:Bundle&gt; &lt;2s&gt; on: &lt;3s&gt; for: &lt;4s&gt;'		expandMacrosWith: self pundle isPackage		with: self pundle name		with: self connectionLabel		with: self userNameLabel</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>subcomponents</category><body package="Store-UI" selector="enableComponentAt:enable:">enableComponentAt: aSymbol enable: aBoolean	| comp |	( comp := subBuilder componentAt: aSymbol ) == nil		ifFalse: [ comp isEnabled: aBoolean ]</body><body package="Store-UI" selector="subComponentAt:">subComponentAt: aSymbol	^subBuilder componentAt: aSymbol</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private-publishing</category><body package="Store-UI" selector="fillEmptyComments">fillEmptyComments	"Look at the spec list and determine any publish spec which have empty comments where there is also a spec for the containing bundle that does have comment. When found, copy said bundle comment down."	| modifiedSpecs bundleSpecs subSpecs |	modifiedSpecs := self specList select: [:each | each modified].	bundleSpecs := modifiedSpecs select: [:each | each pundle isBundle].	bundleSpecs isEmpty ifTrue: [^self].	bundleSpecs		reverseDo:			[:eachBundleSpec | 			eachBundleSpec comment isEmpty				ifFalse:					[subSpecs := modifiedSpecs						select:							[:eachSpec | eachBundleSpec pundle allContainedItems includes: eachSpec pundle].					subSpecs						do:							[:eachSpec | eachSpec comment isEmpty ifTrue: [eachSpec comment: eachBundleSpec comment]]]]</body><body package="Store-UI" selector="validateParcelSaveString">validateParcelSaveString	"This used to check for uninstalled and overridden methods.  Which are now safe to save. We now answer	 no warning string. We leave this here to support some future change where a warning might be needed." 	^String new</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>binding</category><body package="Store-UI" selector="labelFor:">labelFor: aKey 	"Return an instance of a non-abstract subclass of CharacterArray, 	that will be used as a label for a component."	^[ self perform: aKey ] on: MessageNotUnderstood do:		[ : e | e return: aKey ].</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>help</category><body package="Store-UI" selector="fileHelp">fileHelp^#fileHelp &lt;&lt; #store &gt;&gt;'Select Publish All to publish all of the files listed.Select Publish None to reset the default, which does not publish any files.Publish and Do not Publish allow you to change the setting to the currently selected file.'</body><body package="Store-UI" selector="mainHelp">mainHelp^'The Blessing Level and Blessing Comment can be set individually for each component. It will apply to the selected item. Set Current Blessing Level and Comment for All, sets the same level and comment for all published items.Publish Binary - saves the packages in the database in parcel formal. This is good for faster initial loading and for cases where the individual packages may not compile cleanly. If this option is diabled, it means that the parcel is invalid. See the Parcel Options tab for details.'</body><body package="Store-UI" selector="parcelHelp">parcelHelp	^self class parcelHelp</body><body package="Store-UI" selector="publishHelp">publishHelp^'All modified components will be published. Select Publish All to publish all unmodified components.Select Publish Only Modified to reset the default, which does not publish any unmodified components.Publish and Do not Publish allow you to change the setting to the currently selected unmodfied component.'</body><body package="Store-UI" selector="versionHelp">versionHelp^'Change the version string for the selected component, or Set the Global Version for all the components.'</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>accessing</category><body package="Store-UI" selector="basePath">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: ( self parcelDirectory value ) ) asString</body><body package="Store-UI" selector="callBackBlock:">callBackBlock: aOneArgumentBlock	"Having an accessor saves us from adding this to every class side open... method.  Normally, this would be called immediately after some open... method, before the quickest fingered user could hit accept."	callBackBlock := aOneArgumentBlock.</body><body package="Store-UI" selector="currentItems">currentItems	^self isPaneForFiles		ifTrue: [ self files ]		ifFalse: [ self items ].</body><body package="Store-UI" selector="fileList">fileList	^self files list</body><body package="Store-UI" selector="initialBlessingLevel">initialBlessingLevel	| candidates |	candidates := ((self specList select: [:each | each modified])		collect: [:each | each blessing]) asSet.	candidates size = 1 ifTrue: [^candidates any].	candidates size &gt; 1 ifTrue: [^nil].	"now try again with all specs, modified or not"	candidates := (self specList collect: [:each | each blessing]) asSet.	candidates size = 1 ifTrue: [^candidates any].	candidates size &gt; 1 ifTrue: [^nil].	^Policies blessingPolicy defaultBlessing</body><body package="Store-UI" selector="pundle">pundle	^items list first pundle</body><body package="Store-UI" selector="specList">specList	^items list</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	retry := false.</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>testing</category><body package="Store-UI" selector="fileIsSelected">fileIsSelected	^files selection notNil</body><body package="Store-UI" selector="isPaneForFiles">isPaneForFiles	^( subBuilder componentAt: #fileList ) ~~ nil</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>private</category><body package="Store-UI" selector="connectionLabel">connectionLabel		| connectionName profile |	profile := DbRegistry connectedProfile.	connectionName :=  profile name.	(connectionName notNil and: [connectionName notEmpty]) ifTrue: [^connectionName].	connectionName :=  profile environment.	(connectionName notNil and: [connectionName notEmpty]) ifTrue: [^connectionName].	^(#aRepository &lt;&lt; #labels &gt;&gt; 'a Repository') asString</body><body package="Store-UI" selector="publishFileSpecsFrom:">publishFileSpecsFrom: imageOrDatabaseBundle  	^PublishSpecificationList filesFromBundle: imageOrDatabaseBundle</body><body package="Store-UI" selector="publishSpecsFrom:">publishSpecsFrom: aBundleModel  	"For incredibly bizarre reasons to do with the #component message, 	we need to go through this and make sure the objects are the pundleModels"	| publishSpecs |	publishSpecs := PublishSpecificationList fromBundle: aBundleModel.	publishSpecs do: 		[:each |		(each dbPundle isNil and: [each description notNil]) ifTrue: 			[(Gathering for: each pundle) started.			each pundle: each description component.			(Gathering for: each pundle) finished]].	^publishSpecs.</body><body package="Store-UI" selector="publishSpecsFromPackages:comments:defaultBlessing:">publishSpecsFromPackages: aCollectionOfPundleModel comments: aCollectionOfComments defaultBlessing: anInteger		| publishSpecificationList |	publishSpecificationList := PublishSpecificationList new: aCollectionOfPundleModel size.	1 to: aCollectionOfPundleModel size do:		[:index | 		| publishSpecification |		publishSpecification := PublishSpecification pundle: (aCollectionOfPundleModel at: index).		Policies mergePolicy shouldPublishAll ifTrue: [publishSpecification publish: true].		publishSpecification blessing: anInteger.		publishSpecification comment: (aCollectionOfComments at: index).		publishSpecificationList add: publishSpecification].	^publishSpecificationList</body><body package="Store-UI" selector="userData:forPundle:">userData: anUserData forPundle: aPundle 	"Set the common items in the user data."	| mod vString pvString |	 mod := aPundle hasBeenModified or: [ aPundle hasTrace not ].	pvString := aPundle parentVersionString.	vString := pvString isEmpty			ifTrue: [ Policies versionPolicy initialVersionForPundle: aPundle ]			ifFalse: [ Policies versionPolicy nextVersion: pvString forPundle: aPundle ].	anUserData 		at: #publish put: mod;		at: #pundle put: aPundle;		at: #comment put: '';		at: #parentVersion put: pvString;		at: #version put: vString;		at: #level put: 0;		at: #modified put: mod;		at: #description put: nil;		at: #blessing put: Policies blessingPolicy defaultBlessing.</body><body package="Store-UI" selector="userDataFrom:">userDataFrom: anImageBundle  	| dict coll |	dict := Dictionary new.	self userData: dict forPundle: anImageBundle.	dict 		at: #publish put: true;		at: #modified put: true;		at: #binarySave put: false;		at: #parcelSave put: false;		at: #bundleStructure put: false;		at: #databaseLinks put: false;		at: #parcelDirectory put: '';		at: #parcelRepublish put: false;		at: #parcelBackup put: false;		at: #parcelOverwrite put: false;		at: #parcelSaveSource put: true;		at: #parcelHideSource put: false;		at: #parcelPadded put: true.	coll := List with: dict.	anImageBundle descriptionsAndLevels do: 		[ :pair | 	| pndl descr |		descr := pair at: 1.		pndl := descr component.		dict := Dictionary new.		self userData: dict forPundle: pndl.		dict at: #description put: descr.		dict at: #level put: ( pair at: 2 ).		coll add: dict		].	^coll</body><body package="Store-UI" selector="userNameLabel">userNameLabel	^DbRegistry connectedProfile userName</body><body package="Store-UI" selector="validateForPublishing:">validateForPublishing: aCollection 	(self validateSourcesIn: aCollection) ifFalse: [^false].	aCollection do: 		[:each | 		each canBePublishedToCurrentDatabase ifFalse: 			[| message |			message := #x1sIsNotLinkedProceedByReconciling &lt;&lt; #store 						&gt;&gt; '&lt;1s&gt; is not linked to an existing version with the same name in the current database.&lt;n&gt; Proceed by reconciling?' 							expandMacrosWith: each name.			(Dialog confirm: message) 				ifFalse: [^false] 				ifTrue: [each reconcileWithDb ifNil: [^false]]]].	^true</body><body package="Store-UI" selector="validateLoadOrder:">validateLoadOrder: imageBundle	| errorString |	(imageBundle propertyAt: #isLoadOrderWarningSuppressed) == true		ifTrue: [^true].	errorString := imageBundle validateLoadOrder.	^errorString isEmpty		ifTrue: [true]		ifFalse: 			[Dialog				choose: (#InvalidBundleLoadOrder &lt;&lt; #store &gt;&gt; 'Bundle load order is invalid.')				labels: (Array with: (#PublishAnyway &lt;&lt; #store &gt;&gt; 'Publish Anyway') with: (#Cancel &lt;&lt; #store &gt;&gt; 'Cancel'))				values: (Array with: true with: false)				default: #false]</body><body package="Store-UI" selector="validateSourcesIn:">validateSourcesIn: aCollection	"Validate that we're not publishing decompiled code from the image."	| invalid |	"If any of these aren't the image versions, then we're probably republishing or otherwise doing database operations where decompiled source isn't possible."	(aCollection anySatisfy: [:each | each getImagePundle ~~ each]) ifTrue: [^true].	aCollection		anySatisfy:			[:each | 			each changeSet modifiedMethodDescriptors				anySatisfy:					[:eachMethodDescriptor | 					| methodIsInvalid |					methodIsInvalid := eachMethodDescriptor compiledMethod getSource isNil.					methodIsInvalid ifTrue: [invalid := eachMethodDescriptor].					methodIsInvalid]].	invalid isNil		ifTrue: [^true]		ifFalse:			[^Dialog				confirm:					(#x1saboutToPublishDecompiled &lt;&lt; #store &gt;&gt;							'Some code, including &lt;1s&gt; is about to publish as decompiled (missing sources).&lt;n&gt;Proceed with publish?'						expandMacrosWith: invalid printString)]</body><body package="Store-UI" selector="windowLabel">windowLabel	^(#PublishingBundleOnly &lt;&lt; #labels &gt;&gt; 'Publish Bundle on: &lt;1s&gt; for: &lt;2s&gt;')		expandMacrosWith: self connectionLabel		with: self userNameLabel</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	| complexList |	complexList := 		OrderedCollection new			add: 'Blessing' -&gt; #(#mainSpec #mainHelp);			add: 'Version Names' -&gt; #(#versionSpec #versionHelp);			add: 'Items to Publish' -&gt; #(#publishSpec #publishHelp);			add: 'Parcel Options' -&gt; #(#parcelSpec #parcelHelp);			add: 'File Options'-&gt;#(#filesSpec #fileHelp);			asArray.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new: 1.</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="publishBundle:">publishBundle: aBundleModel	"Present a dialog and let user set parameters for the new published bundle and its contents.	Just in case some tool hooks into new, we call that here"		| instance |	(self validateForPublishing: aBundleModel withContainedItems) ifFalse: [^self].	instance := self new.	(self validateLoadOrder: aBundleModel) ifFalse: [^self].	instance openOnPundleModel: aBundleModel.	^instance</body><body package="Store-UI" selector="publishPackages:comments:defaultBlessing:ifSuccessfulDo:">publishPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: anInteger ifSuccessfulDo: aOneArgumentBlock 	"Open a publish dialog on aCollectionOfPackages. If everything is okay, exececute a block 	with the list of user data for each package. " 	| publishSpecificationList |	publishSpecificationList := self		publishSpecsFromPackages: aCollectionOfPackages		comments: aCollectionOfComments		defaultBlessing: anInteger.	self new openWith: publishSpecificationList ifSucessfulDo: aOneArgumentBlock.	^publishSpecificationList</body><body package="Store-UI" selector="publishPundle:">publishPundle: aPundle	^self publishBundle: aPundle.</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>help</category><body package="Store-UI" selector="parcelHelp">parcelHelp	^'The parcel will be saved in the Parcel Path + .pcl, the sources in Parcel Path +.pst.Include Bundle Structure if you would like the bundle to be recreated when loading the parcel into a Store image.  Saving Database Links will hook the components to a particular database. This saves the loader from needing to reconcile source before publishing a new version to the same database.Save source file will create the parcel sources (.pst) file.Hide sources on load will not effect the current image, but will supress sources when it is loaded into a another image. This is for deployment parcels and should not be used during development.Select republish to save with sources to a parcel that is currently loaded to the same file name.  Republishing does not hide sources. Republishing will invalidate other images that point to the original file.'</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>accessing</category><body package="Store-UI" selector="masterList">masterList	"For the VisualWorks tools use case we only want to use the development lables.	 In other words, we do not encourage deployment of our tools."	^self developmentTabLabels</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>private</category><body package="StoreForGlorpVWUI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self logout</body><body package="StoreForGlorpVWUI" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self login</body><body package="StoreForGlorpVWUI" selector="preBuildWith:">preBuildWith: aBuilder	super preBuildWith: aBuilder.	self replaceAllTextPagesWith: self class examplesPage."	self addPage: self class storeExamplesPage."</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>actions</category><body package="StoreForGlorpVWUI" selector="logging:">logging: aBoolean	session accessor logging: aBoolean</body><body package="StoreForGlorpVWUI" selector="login">login	session reset.	self privateLogin.	builder window label: (self class workbookLabel,' (&lt;1s&gt;)' expandMacrosWith: session accessor currentLogin name).</body><body package="StoreForGlorpVWUI" selector="logout">logout	session accessor logout.		session reset.	builder window label: (self class workbookLabel,  ' (&lt;1s&gt; - not connected)' expandMacrosWith: session accessor currentLogin name)</body><body package="StoreForGlorpVWUI" selector="privateLogin">privateLogin	#{Database.StatementCachingNotSupported} 		ifDefinedDo: 			[:errorClass |			[session accessor storeLoginIfError: [:ex | ex return: nil]]				on: errorClass				do: [:exception | exception resume: nil]]		elseDo: [session accessor storeLoginIfError: [:ex | ex return: nil]].</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>initialize-release</category><body package="StoreForGlorpVWUI" selector="on:">on: aConnectionProfile	session := Store.Glorp.StoreLoginFactory sessionForStoreLogin: aConnectionProfile .	self addLocal: #session value: session</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>aspects</category><body package="StoreForGlorpVWUI" selector="isLogging">isLogging	^session accessor logging</body><body package="StoreForGlorpVWUI" selector="loggedIn">loggedIn	^session accessor isLoggedIn</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook class</class-id> <category>examples</category><body package="StoreForGlorpVWUI" selector="exampleHeader">exampleHeader	^'"This page contains some useful examples of Glorp expressions you can use or modify"'.</body><body package="StoreForGlorpVWUI" selector="examplesOneByOne">examplesOneByOne	"Return a list of alternating comments and examples for the workspace. Do this so we can automatically emphasize the text to make them stand out."^#( '"Find all bundle versions published within the last 30 days whose name starts with G (either upper or lower case) and which were published by someone whose username starts with lowercase a"''session read: StoreBundle where: [:each |	((each name asUppercase like: ''G%'') AND: [each username like: ''a%'']) AND: [each timestamp &gt; (Date today subtractDays: 30)]].''"Find all packages in the system." ''session read: StoreVersionlessPackage.''"Find all packages for which any version has a blessing level of ''Internal Release'' or higher"''session read: StoreVersionlessPackage where: [:each |	each versions anySatisfy: [:eachVersion |		eachVersion currentBlessingLevel &gt; Store.Access defaultBlessingPolicy internalReleaseBlessing]].''"Find all the packages that define the method #yourself. Note this can be slow on a large database." ''session read: StorePackage where: [:each |	each methods anySatisfy: [:eachMethod | 		eachMethod definition name = ''yourself'']].''"Find all the packages that define the class Object. Note this can be slow on a large database." ''session read: StorePackage where: [:each |	each classDefinitions anySatisfy: [:eachClass | 		eachClass definition name = ''Object'']].''"Find all the packages that define less than 5 classes"''session read: StorePackage where: [:each |	each classDefinitions sqlCount &lt; 5].''"Find the latest version of all bundles in the system. Restrict to those where the latest version is published by user aknight. Also does this by creating a separate query object and executing it, rather than using the session convenience protocol."''| query |query := Query read: StoreBundle where: [:each |	| q |	q := Query read: StoreBundle where: [:eachBundle |		eachBundle name = each name].	q retrieve: [:x | x primaryKey max].	each username = ''aknight''  &amp; (each primaryKey = q)].query orderBy: [:each | each timestamp descending].session execute: query.''"Empty out all of our caches"''session reset.''"The expressions above are safe, because they only read from the database. Those below this point can modify the database. This is ***DANGEROUS!!!***. Inserting something incorrect can add invalid packages or other structures to your database. Deleting or updating can cause you to lose data. By default, the ability to update or delete is disabled in the Store workbook, to prevent accidental damage to the database. Any attempt to do that will cause an ''Illegal Command'' error or will fail validation in the StoreDescriptorSystem, which checks for updates and deletes, which are not normally valid Store operations. In order to allow the session to delete or update rows, evaluate the following expression."''session accessor permitEverything.''"Stop the session from deleting or updating rows. This restore the default setting in the Store workbook, to prevent accidental damage to the database"''session accessor insertOnly.''"Delete version 1.0 of the package named Foo. Note that this just deletes the package record, it won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the package disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	query := Query 		readOneOf: StorePackage 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	thePackage := session execute: query.	thePackage isNil 		ifTrue: [self error: ''No such package''] 		ifFalse: [thePackage delete].	(session execute: query) isNil ifFalse: [self error: ''Package was not deleted''].''"Delete version 1.0 of the bundle named Foo. Note that this is recursive - it will delete the bundle record, and the packages/sub-bundles that it contains, if they aren''t used as part of any other bundles. But it only deletes the bundle/package record. It won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the bundle disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	query := Query 		readOneOf: StoreBundle 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	theBundle := session execute: query.	theBundle isNil 		ifTrue: [self error: ''No such bundle'']		ifFalse: [theBundle delete].	(session execute: query) isNil ifFalse: [self error: ''Bundle was not deleted''].''"Change the name of the package Foo (all versions) to Bar. Again, you might want to think twice before doing this to a real live database with important source code in it. Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level."''	oldName := ''Foo''.	newName := ''Bar''.	versions := session read: StorePackage where: [:each | each name = oldName].	versions isEmpty ifTrue: [self error: ''No such package''].	session modify: versions in: [		versions do: [:each | each name: newName]].	newVersions := session read: StorePackage where: [:each | each name = oldName].	newVersions isEmpty ifFalse: [self error: ''Package was not properly renamed''].	newVersions := session read: StorePackage where: [:each | each name = newName].	newVersions isEmpty ifTrue: [self error: ''Package was not properly renamed''].''"Create the indexes that StoreGlorp defines into the database. Useful if you want to set up some indexes into a default Store setup database. Requires permissions, and will probably have problems if some of them already exist."''session system allTables do: [:each |			session accessor createTableIndexes: each ifError: [self halt]]. ').</body><body package="StoreForGlorpVWUI" selector="examplesPage">examplesPage	^WorkspacePage		labeled: self workbookLabel		on: (WorkspacePage cautiousAdaptorOn: self examplesText asValue).</body><body package="StoreForGlorpVWUI" selector="examplesText">examplesText	| text examples |	text := TextStream on: String new.	text nextPutAllText: self exampleHeader asText allBold.	text cr; cr.	examples := self examplesOneByOne.	1 to:  examples size by: 2 do: [:i |		text nextPutAllText: (examples at: i) asText allBold.		text cr.		text nextPutAllText: (examples at: i + 1).		text cr; cr].	^text contents.</body><body package="StoreForGlorpVWUI" selector="workbookLabel">workbookLabel	^'Glorp Examples'.</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook class</class-id> <category>instance creation</category><body package="StoreForGlorpVWUI" selector="on:">on: aConnectionProfile	^#{Database.StatementCachingNotSupported} 		ifDefinedDo: 			[:errorClass |			[self new on: aConnectionProfile]				on: errorClass				do: [:exception | exception resume: nil]]		elseDo: [self new on: aConnectionProfile]</body><body package="StoreForGlorpVWUI" selector="openRequestingDatabase">openRequestingDatabase	| login |	login := self requestDatabase.	login isNil ifFalse: [(self on: login) open].</body><body package="StoreForGlorpVWUI" selector="requestDatabase">requestDatabase	self subclassResponsibility.</body></methods><methods><class-id>Glorp.UI.StoreWorkbook</class-id> <category>actions</category><body package="StoreForGlorpVWUI" selector="privateLogin">privateLogin	"By this point in initial set up, we have already logged in to check the Store version, setting the platform encoding from the accessor in the process, so do not login again.  If we have logged out and are now logging in again, reapply the encoding from the platform as the new connection will have lost it.	(Later, drop the guard against resetting any other than postgres in favour of having the initial login set the encoding from the connection in all cases.)"	session isLoggedIn ifFalse:		[super privateLogin.		(session accessor platform class == PostgreSQLPlatform) ifTrue:			[session accessor encoding: session accessor platform characterEncoding]].</body></methods><methods><class-id>Glorp.UI.StoreWorkbook class</class-id> <category>examples</category><body package="StoreForGlorpVWUI" selector="exampleHeader">exampleHeader	^'"This page contains some useful examples of Store expressions you can use or modify"'.</body><body package="StoreForGlorpVWUI" selector="examplesOneByOne">examplesOneByOne	"Return a list of alternating comments and examples for the workspace. Do this so we can automatically emphasize the text to make them stand out."^#( '"Find all bundle versions published within the last 30 days whose name starts with G (either upper or lower case) and which were published by someone whose username starts with lowercase a"''session read: StoreBundle where: [:each |	((each name asUppercase like: ''G%'') AND: [each username like: ''a%'']) AND: [each timestamp &gt; (Date today subtractDays: 30)]].''"Find all packages in the system." ''session read: StoreVersionlessPackage.''"Find all packages for which any version has a blessing level of ''Internal Release'' or higher"''session read: StoreVersionlessPackage where: [:each |	each versions anySatisfy: [:eachVersion |		eachVersion currentBlessingLevel &gt; Store.Access defaultBlessingPolicy internalReleaseBlessing]].''"Find all the packages that define the method #yourself. Note this can be slow on a large database." ''session read: StorePackage where: [:each |	each methods anySatisfy: [:eachMethod | 		eachMethod definition name = ''yourself'']].''"Find all the packages that define the class Object. Note this can be slow on a large database." ''session read: StorePackage where: [:each |	each classDefinitions anySatisfy: [:eachClass | 		eachClass definition name = ''Object'']].''"Find all the packages that define less than 5 classes"''session read: StorePackage where: [:each |	each classDefinitions sqlCount &lt; 5].''"Find if/where a particular package was renamed"''renamed := session read: StorePackage where: [:each |	each name = ''X'' &amp; (each trace name ~= ''X'')].''"Find the latest version of all bundles in the system. Restrict to those where the latest version is published by user aknight. Also does this by creating a separate query object and executing it, rather than using the session convenience protocol."''| query |query := Query read: StoreBundle where: [:each |	| q |	q := Query read: StoreBundle where: [:eachBundle |		eachBundle name = each name].	q retrieve: [:x | x primaryKey max].	each username = ''aknight''  &amp; (each primaryKey = q)].query orderBy: [:each | each timestamp descending].session execute: query.''"Empty out all of our caches"''session reset.''"The expressions above are safe, because they only read from the database. Those below this point can modify the database. This is ***DANGEROUS!!!***. Inserting something incorrect can add invalid packages or other structures to your database. Deleting or updating can cause you to lose data. By default, the ability to update or delete is disabled in the Store workbook, to prevent accidental damage to the database. Any attempt to do that will cause an ''Illegal Command'' error or will fail validation in the StoreDescriptorSystem, which checks for updates and deletes, which are not normally valid Store operations. In order to allow the session to delete or update rows, evaluate the following expression."''session accessor permitEverything.''"Stop the session from deleting or updating rows. This restore the default setting in the Store workbook, to prevent accidental damage to the database"''session accessor insertOnly.''"Delete version 1.0 of the package named Foo. Note that this just deletes the package record, it won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the package disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	query := Query 		readOneOf: StorePackage 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	thePackage := session execute: query.	thePackage isNil 		ifTrue: [self error: ''No such package''] 		ifFalse: [thePackage delete].	(session execute: query) isNil ifFalse: [self error: ''Package was not deleted''].''"Delete version 1.0 of the bundle named Foo. Note that this is recursive - it will delete the bundle record, and the packages/sub-bundles that it contains, if they aren''t used as part of any other bundles. But it only deletes the bundle/package record. It won''t clean up definitions that are only referenced in this version, or link table references the way that Store garbage collection will. But it effectively makes the bundle disappear from the database, and the dangling rows aren''t normally a problem.  Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level. Or you may want to think twice before removing something permanently from the database"''	query := Query 		readOneOf: StoreBundle 		where: [:each | each name = ''Foo'' &amp; (each version = ''1.0'')].	theBundle := session execute: query.	theBundle isNil 		ifTrue: [self error: ''No such bundle'']		ifFalse: [theBundle delete].	(session execute: query) isNil ifFalse: [self error: ''Bundle was not deleted''].''"Change the name of the package Foo (all versions) to Bar. Again, you might want to think twice before doing this to a real live database with important source code in it. Note that by default, you won''t have permission to do this from the session. See examples above. You also may not have permission at the database level."''	oldName := ''Foo''.	newName := ''Bar''.	versions := session read: StorePackage where: [:each | each name = oldName].	versions isEmpty ifTrue: [self error: ''No such package''].	session modify: versions in: [		versions do: [:each | each name: newName]].	newVersions := session read: StorePackage where: [:each | each name = oldName].	newVersions isEmpty ifFalse: [self error: ''Package was not properly renamed''].	newVersions := session read: StorePackage where: [:each | each name = newName].	newVersions isEmpty ifTrue: [self error: ''Package was not properly renamed''].''"Create the indexes that StoreGlorp defines into the database. Useful if you want to set up some indexes into a default Store setup database. Requires permissions, and will probably have problems if some of them already exist."''session system allTables do: [:each |			session accessor createTableIndexes: each ifError: [self halt]]. ').</body><body package="StoreForGlorpVWUI" selector="workbookLabel">workbookLabel	^'Store Examples'.</body></methods><methods><class-id>Glorp.UI.StoreWorkbook class</class-id> <category>instance creation</category><body package="StoreForGlorpVWUI" selector="requestDatabase">requestDatabase	| logins login |	logins := Store.RepositoryManager repositories.	login := Dialog			choose: 'Select repository'			fromList: (logins collect: [ :l | l name ])			values: logins			lines: logins size			cancel: [^nil].	^login.</body></methods><methods><class-id>Store.Packages</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDBComponent">asDBComponent	"Answer a corresponding TT_Bundle."	| rec |	[rec := Package aRecordWithID: packageRef.]	on: self errorSignals	do: [ :ex | ex outer. ^nil].		rec isNil ifTrue: [ Pundle componentNotFoundSignal raiseWith: self].	^rec</body><body package="Store-DB-Pundles" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Pundles" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body></methods><methods><class-id>Store.Packages</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $ .	packageRef printOn: aStream.	aStream nextPut: $&gt;.</body></methods><methods><class-id>Store.Packages</class-id> <category>private</category><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription		| baby |	baby := PackageDescription new.	baby id: packageRef.	^baby</body></methods><methods><class-id>Store.Packages class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'packageRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Packages class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_PackagesReverse' #('packageRef'))		)</body><body package="Store-DB-Pundles" selector="viewColumnNames">viewColumnNames	"Answer a collection of column names that should be included 	into a view table."	| coll |	coll := OrderedCollection withAll: super viewColumnNames.	coll add: 'expression'; add: 'seqNumber'.	^coll</body></methods><methods><class-id>Store.Packages class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="enclosingComponentsOfId:">enclosingComponentsOfId: aPackageID	"Answer a collection of bundleIds that comprises the containers of a package, aPackageID."	^ self select: #bundleRef column: #packageRef  value: aPackageID printString.</body><body package="Store-DB-Pundles" selector="select:column:value:">select: column column: aCol value: aVal	"Answer a collection of bundles that comprise the containers of a bundle, aBundleID."	| sql items |	sql := ( self newSQL			select: ( Array with: column );			where;			column: aCol equalTo: aVal ).	items := [ ( self broker process: sql ) collect: [ :array | Bundle aRecordWithID: array first ] ] 		on: self  errorSignals 		do: [:ex | ex outer.  OrderedCollection new ].	^items asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp].</body></methods><methods><class-id>Store.Glorp.StoreBrowserOverviewTool</class-id> <category>methods</category><body package="StoreForGlorpBrowserUI" selector="textHolder">textHolder	| stream |	stream := TextStream on: String new.	stream		nextPutAll: 'The ';		emphasis: #italic;		nextPutAll: 'Store Browser';		emphasis: nil;		nextPutAll:				' presents a read-only view of source published to a Store database. Use it for browsing specific versions of bundles and/or packages, with their contained classes and methods. Because this browser works with static representations of method source as opposed to operating in a "live" code environment, you cannot perform some of the operations common to the System Browser, such as searching senders/receivers of selectors in the method source, or any of the refactoring actions.'.	^stream contents asValue</body></methods><methods><class-id>Store.LoadRecord</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="pundleName">pundleName	^pundleName</body><body package="Store-DB-Pundles" selector="pundleName:">pundleName: aString	pundleName := aString</body><body package="Store-DB-Pundles" selector="pundleType">pundleType	^pundleType</body><body package="Store-DB-Pundles" selector="pundleType:">pundleType: aString	pundleType := aString</body><body package="Store-DB-Pundles" selector="pundleVersion">pundleVersion	^pundleVersion</body><body package="Store-DB-Pundles" selector="pundleVersion:">pundleVersion: aString	pundleVersion := aString</body><body package="Store-DB-Pundles" selector="timeStamp">timeStamp	^timeStamp</body><body package="Store-DB-Pundles" selector="timestamp">timestamp	^timeStamp</body><body package="Store-DB-Pundles" selector="timeStamp:">timeStamp: aTimestamp	timeStamp := aTimestamp</body><body package="Store-DB-Pundles" selector="timestamp:">timestamp: aTimestamp	timeStamp := aTimestamp</body><body package="Store-DB-Pundles" selector="username">username	^username</body><body package="Store-DB-Pundles" selector="username:">username: aString	username := aString</body></methods><methods><class-id>Store.LoadRecord</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: (' &lt;1p&gt; loaded &lt;2p&gt;' expandMacrosWith: username with: pundleName )</body></methods><methods><class-id>Store.LoadRecord class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="fieldType">fieldType	"Primary key choice is fairly arbitrary. Make the timestamp be a primary key so it will be indexed and we can easily do an existence test against the table using it. Make username and pundleName primary keys so they will be indexed and we can reasonably do searches against them. Also, we expect the likelihood of the same user simultaneously loading the same pundle to be low."	| aDict |	aDict := Dictionary new.	aDict at: 'username' put: #PrimaryKeyString.	aDict at: 'pundleName' put: #PrimaryKeyString.	aDict at: 'pundleType' put: #Char.	aDict at: 'pundleVersion' put: #String.	aDict at: 'timeStamp' put: #PrimaryKey.	^aDict</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'username' put: #PrimaryKeyString.	aDict at: 'pundleName' put: #PrimaryKeyString.	aDict at: 'pundleType' put: #Char.	aDict at: 'pundleVersion' put: #String.	aDict at: 'timeStamp' put: #PrimaryKey.	^aDict</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="asTag">asTag	^Store.MethodTag 		newClassName: self className 		meta: self isMeta		selector: self selector asSymbol		protocol: self protocol.</body><body package="Store-Database Model" selector="owner">owner		| class |	class := self fullClassName asStrictReference valueOrDo: [^nil].	^self isMeta		ifTrue: [class class]		ifFalse: [class]</body><body package="Store-Database Model" selector="selector">selector	selector isNil ifTrue: [selector := self name asSymbol].	^selector.</body><body package="StoreForGlorpVWUI" selector="setCTypeForPre77StoreFrom:">setCTypeForPre77StoreFrom: aCompiledMethod	"Pre-Glorp Store ensured that C type definitions were loaded first in ExternalInterface classes by a hack:  they put 'CTYPE' into an old, unused (and inappropriately-named but available) instVar called 'version' which had a mapping to a column of the same name in the store schema.  In old Store (i.e. as released in VW7.6 and earlier), look at #fromDescription:trace:package: and #newNamed:inClass:trace:package: to see this being set, and #sortForLoading:package: and #sortMethodModifications: to see it being used in load ordering.	Glorp-using Store has another solution to this, but any ExternalInterface-subclass-containing packages that it publishes will not load into 7.6 and earlier unless 'CTYPE' is set in their CType-defining StoreMethods before publishing.  Thus we must call this when creating StoreMethods for publishing, at least until compatibility with 7.6 and earlier becomes unimportant (or sufficiently so that an in-place-rewriting Glorp script run periodically on the database will do instead)."	aCompiledMethod isNil ifTrue: [^nil].		"to simplify calling code"	(aCompiledMethod mclass isKindOf: ExternalInterface class) ifTrue:		[aCompiledMethod returnsStaticVariable ifNotNil:			[:variableAssoc |			(variableAssoc value isKindOf: CType) ifTrue:				[version := 'CTYPE']]].	"otherwise version is nil"</body><body package="StoreForGlorpVWUI" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self source</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;">&lt; aStoreMethod	| n1 n2 sel |	n1 := self classNameWithMeta.	n2 := aStoreMethod classNameWithMeta.	^n1 = n2		ifTrue:			[(self selector isString					ifTrue: [self selector]					ifFalse: [self selector printString])				&lt; ((sel := aStoreMethod selector) isString						ifTrue: [sel]						ifFalse: [sel printString])]		ifFalse: [n1 &lt; n2]</body><body package="Store-Database Model" selector="&lt;=">&lt;= aStoreMethod	^self = aStoreMethod or: [self &lt; aStoreMethod].</body><body package="Store-Database Model" selector="=">= aStoreMethod	^self class = aStoreMethod class and: [self reconcilesWith: aStoreMethod]</body><body package="Store-Database Model" selector="displayString">displayString	^self selector.</body><body package="Store-Database Model" selector="equalsSignatureIn:">equalsSignatureIn: aStoreMethod	self class = aStoreMethod class ifFalse: [^false].	self classNameWithMeta = aStoreMethod classNameWithMeta ifFalse: [^false].	self selector = aStoreMethod selector ifFalse: [^false].	self isMeta = aStoreMethod isMeta ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="hash">hash	"Just hash on the presumably most selective of the equality criteria, which is anything but PK"	^self classNameWithMeta hash bitXor: self name hash.</body><body package="Store-Database Model" selector="sameAsImage">sameAsImage	| method |	method := self correspondingImageMethod.	method isNil ifTrue: [^false].	^self = method asStoreMethodDefinition.</body><body package="Store-Database Model" selector="signatureHash">signatureHash	^(self classNameWithMeta hash		bitXor: self selector stringhash)			bitXor: self isMeta hash</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>accessing</category><body package="Store-Database Model" selector="basicComment">basicComment	^comment.</body><body package="Store-Database Model" selector="basicComment:">basicComment: aStoreBlob	comment := aStoreBlob.</body><body package="Store-Database Model" selector="basicSource">basicSource	^source.</body><body package="Store-Database Model" selector="basicSource:">basicSource: aStoreBlob	source := aStoreBlob.</body><body package="Store-Database Model" selector="className">className	^self classNameWithoutMeta.</body><body package="Store-Database Model" selector="className:">className: aString	className := aString.</body><body package="Store-Database Model" selector="classNameWithMeta">classNameWithMeta	^className.</body><body package="Store-Database Model" selector="classNameWithoutMeta">classNameWithoutMeta	^isMetaclass		ifTrue: [className copyFrom: 1 to: (className size - ' class' size)]		ifFalse: [className].</body><body package="Store-Database Model" selector="comment">comment	^comment isNil ifTrue: [nil] ifFalse: [comment source].</body><body package="Store-Database Model" selector="comment:">comment: aString	comment := StoreBlob forString: aString.</body><body package="Store-Database Model" selector="correspondingImageClass">correspondingImageClass	"Return the image class that corresponds to our name. Note that they may not have the same information"	| basicClass |	basicClass := Dialect smalltalkAt: self className ifAbsent: [^nil].	^self isMetaclass ifTrue: [basicClass class] ifFalse: [basicClass].</body><body package="Store-Database Model" selector="definition">definition	^self source.</body><body package="StoreForGlorpVWUI" selector="definitionObject">definitionObject	^self</body><body package="Store-Database Model" selector="definitionString">definitionString	^self definition</body><body package="Store-Database Model" selector="environment">environment	"This isn't right, but our real environment may not even exist in the image"	^Smalltalk.</body><body package="Store-Database Model" selector="environmentString">environmentString	^self classNameWithoutMeta</body><body package="Store-Database Model" selector="fullClassName">fullClassName	^self className.</body><body package="Store-Database Model" selector="getSource">getSource	^self source.</body><body package="Store-Database Model" selector="longName">longName	^self classNameWithoutMeta</body><body package="Store-Database Model" selector="methodSources">methodSources	^MethodSourceCollection source: self definitionString</body><body package="Store-Database Model" selector="name:">name: aString	super name: aString.	selector := nil.</body><body package="Store-Database Model" selector="protocol">protocol	^protocol isNil ifTrue: ['unknown protocol'] ifFalse: [protocol].</body><body package="Store-Database Model" selector="protocol:">protocol: aString	protocol := aString.</body><body package="Store-Database Model" selector="setVersionTo:">setVersionTo: aString	"We appear not to have been capturing CTypes, very bad when ExternalInterface methods are loaded as their ordering matters and is controlled by this inside sortForLoading:package:."	version := aString.</body><body package="Store-Database Model" selector="signature">signature	^self longNameWithMetaFromSmalltalk, ' &gt;&gt; ', self name</body><body package="Store-Database Model" selector="source">source	^source source</body><body package="Store-Database Model" selector="source:">source: aString	source := StoreBlob forString: aString.</body><body package="Store-Database Model" selector="version">version	^version</body><body package="Store-Database Model" selector="xmlDefinition">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>testing</category><body package="Store-Database Model" selector="belongsToClass">belongsToClass	^true.</body><body package="Store-Database Model" selector="isMeta">isMeta	^self isMetaclass.</body><body package="Store-Database Model" selector="isMetaclass">isMetaclass	^isMetaclass</body><body package="Store-Database Model" selector="isMetaclass:">isMetaclass: aBoolean	isMetaclass := aBoolean.</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreMethod	"Return true if we appear to be the same entry, but potentially in a different database	Leave out the timestamp. Leave out version, since that is only used for External Methods and is not really a compare thing"	| mySource otherSource |	self classNameWithMeta = aStoreMethod classNameWithMeta ifFalse: [^false].	self selector asString = aStoreMethod selector asString ifFalse: [^false].	self protocol asString = aStoreMethod protocol asString ifFalse: [^false].	self isMeta = aStoreMethod isMeta ifFalse: [^false].	"This is tricky. If we have no proxy for our source - that is, we're created from in-memory data, and the other method has an uninstantiated proxy, then we treat that as meaning that it has been read in such a way that only those methods in the change set have had source read. Therefore, we say that we match"	((self basicSource isGlorpProxy not or: [self basicSource class == AdHocProxy and: [self basicSource isInstantiated not]]) 			and: [aStoreMethod basicSource isGlorpProxy and: [aStoreMethod basicSource class ~~ AdHocProxy and: [aStoreMethod basicSource isInstantiated not]]])		ifTrue: [^true]		ifFalse: [			"And as a special bonus, apparently when things are put into parcel sources they may, but don't necessarily, get an extra newline appended to the end. So ignore those."			mySource := self source.			otherSource := aStoreMethod source.			(mySource isEmpty not and: [mySource last = Character cr and: [mySource size - 1 = otherSource size]])					ifTrue: [mySource := mySource copyFrom: 1 to: mySource size - 1].			(otherSource isEmpty not and: [otherSource last = Character cr and: [otherSource size - 1 = mySource size]])					ifTrue: [otherSource := otherSource copyFrom: 1 to: otherSource size - 1].			mySource = otherSource ifFalse: [^false].			self comment = aStoreMethod comment ifFalse: [^false]].	^true.</body><body package="Store-Database Model" selector="unreconcile">unreconcile	super unreconcile.	(comment yourSelf notNil and: [comment source isEmpty]) ifTrue: [comment := nil].</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	source := source glorpCopyIn: aDictionary.	comment := comment glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource	| mySelector class myProtocol result currentPackage |	(class := self correspondingImageClass) ifNil: 		[Store.UnloadableDefinitionError signalWith: self.		^nil].	mySelector := self selector.	myProtocol := self protocol.	currentPackage := Store.Policies packagePolicy forcedPackage.	((class includesSelector: mySelector)		and: [(class organization categoryOfElement: mySelector) = myProtocol 		and: [(class compiledMethodAt: selector) getSource string = self definitionString]])			ifTrue: 				[result := class compiledMethodAt: selector.				currentPackage ifNotNil: [Store.XChangeSet current moveSelector: mySelector class: class toPackage: currentPackage]]			ifFalse:				[| environment |				environment := currentPackage					environmentFor: mySelector					in: class.				result := class					compile: self definitionString					classified: myProtocol					notifying: nil					environment: environment].	^result</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	^self loadSource</body><body package="Store-Database Model" selector="removeFromImage">removeFromImage	self correspondingImageClass ifNotNil: [:value | value removeSelector: self selector]</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>printing</category><body package="Store-Database Model" selector="printOn:">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self classNameWithMeta.	aStream		nextPutAll: '&gt;&gt;';		nextPutAll: self name;		nextPut: $)</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinition">asStoreMethodDefinition	^self</body><body package="Store-Database Model" selector="asStoreObjectInPackage:">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage methods		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: Store.Glorp.StoreMethodInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="StoreForGlorpVWUI" selector="asText">asText	^self source asText.</body><body package="Store-Database Model" selector="correspondingImageMethod">correspondingImageMethod	| class |	class := (Dialect smalltalkAt: self className ifAbsent: [^nil]).	^(self isMeta 		ifTrue: [class class]		ifFalse: [class]) compiledMethodAt: self selector asSymbol ifAbsent: [nil].</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>fileIn/Out</category><body package="Store-Database Model" selector="fileOutDefinitionOn:">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	| dictionary |	dictionary := Dictionary new.	dictionary at: self protocol put: (Set with: self).	aStream fileOutTTMessages: dictionary for: self classNameWithMeta logging: false.</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeMethod: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedMethodObject</body></methods><methods><class-id>Store.Glorp.StoreMethod</class-id> <category>displaying</category><body package="Store-Database Model" selector="fullDisplayString">fullDisplayString	^'&lt;1s&gt; (&lt;2s&gt;, &lt;3s&gt;)' 		expandMacrosWith: self signature		with: self timeStampString		with: self username</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>database utility</category><body package="Store-Database Model" selector="allNamesMatching:">allNamesMatching: aString		^self allNamesMatching: aString in: nil</body><body package="Store-Database Model" selector="allNamesMatching:in:">allNamesMatching: aString in: aSessionOrNil		| session query likeString |	likeString := aString copy replaceAll: $* with: $%.	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name like: likeString].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query</body><body package="Store-Database Model" selector="allNamesMatching:inClassNamed:">allNamesMatching: aString inClassNamed: aClassName	"Wildcard search and select for methods that are in a class in the image"	| query session likeString |	likeString := aString copy replaceAll: $* with: $%.	session := StoreLoginFactory currentStoreSession.	query := Query		read: self		where: [:eachMethod | (eachMethod name like: likeString) AND: [eachMethod className = aClassName]].	query retrieve: [:each | each name distinct].	query orderBy: [:each | each name].	^session execute: query.</body><body package="Store-Database Model" selector="chooseAvailableMethodMatching:notIn:">chooseAvailableMethodMatching: aString notIn: aClass	"Wildcard search and select for methods not currently in the image for a particular class"	"StoreMethodInPackage chooseAvailableMethodMatching: '*' notIn: Store.Method "	| list names |	(Gathering for: aClass) started.	list := self allNamesMatching: aString inClassNamed: aClass absoluteName.	(Gathering for: aClass) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#NoSelectorsMatching1s &lt;&lt; #store &gt;&gt; 'No selectors matching &lt;1s&gt;'						expandMacrosWith: aString)].	names := list reject: [:each | aClass includesSelector: each asSymbol].	names := names asSortedCollection.	names isEmpty		ifTrue: 			[^Dialog				warn: (#NoRemovedMethodsIn1s &lt;&lt; #store &gt;&gt; 'No removed methods in &lt;1s&gt;'						expandMacrosWith: aClass fullName)].	^SimpleDialog new		chooseMultiple: #ChooseSelectors &lt;&lt; #store &gt;&gt; 'Choose selectors...'		fromList: names		values: names		buttons: #()		values: #()		lines: 12		cancel: nil		for: nil</body></methods><methods><class-id>Store.Glorp.StoreMethod class</class-id> <category>installation</category><body package="Store-Database Model" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy methodsTableSpace</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private</category><body package="Store-Change Management" selector="formatStructure:">formatStructure: structure	"Answers a formatted print string for the bundle structure."		| stream |	stream := (String new: 256) writeStream.	structure do:		[ :array |		stream 			nextPutAll: array first printString; tab; tab;			nextPutAll: array last; cr		].	^stream contents</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:into:">applyDefinitionFrom: dbPackage into: imgPackage	"Load the change. Answer true is the operation is successful."	dbPackage isLoaded		ifTrue: [ ^true ].		"already the in image version"	imgPackage structure: dbPackage structure.	^true.</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	tolerantBoolean 		ifFalse: 			[Dialog 				warn: (#CannotRemoveBundleStructure &lt;&lt; #store 						&gt;&gt; 'Cannot remove bundle structure') asString]</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	 ^self containingPackage ~~ nil</body><body package="Store-Change Management" selector="is:meaningfulChangeOf:">is: dbPackage meaningfulChangeOf: imgPackage 	^imgPackage == nil | (dbPackage == nil) 		or: [imgPackage structure ~= dbPackage structure]</body><body package="Store-Change Management" selector="isStructureTag">isStructureTag	^true</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me, nil if none."	^package == nil		ifFalse: [ Registry bundleNamed: package name]</body><body package="Store-Change Management" selector="description">description	^self name</body><body package="Store-Change Management" selector="name">name	^'&lt;1s&gt; structure' 		expandMacrosWith: self packageName</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	^self sourceTextForImage: self containingPackage</body><body package="Store-Change Management" selector="sourceTextForImage:">sourceTextForImage: aPackage	aPackage == nil		ifTrue: [ ^'' ].	^self formatStructure: aPackage structure.</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^#BundleStructure</body><body package="Store-Change Management" selector="text">text	package == nil 		ifTrue: [ ^'' ].	^self formatStructure: package structure.</body><body package="Store-Change Management" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^self text.</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| pkg |	^( pkg := self containingPackage ) == nil		ifTrue: [ false ]		ifFalse: [ pkg structure: package structure ].</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch. Answer nil if it's someone elses structure"	^( ( package isNil )  or: [ package comparesTo: aPackage ] )		ifTrue: [ 	aPackage recordForStructureTag: self ]</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	BundleSpecEditor openOnBundle: package</body><body package="Store-Change Management" selector="definition">definition	^self text</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	package == nil		ifFalse: [ aStream bundleStructure: package ].</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aStream bundleStructure: aRecord</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"nonsense"	^self shouldNotImplement</body><body package="Store-Change Management" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: aPackage confirm: aBoolean	"Load the receiver by setting its bundle structure."	aBoolean 		ifTrue: 			[ ( Dialog confirm: ( (#Reset1sBundleStructure &lt;&lt; #store &gt;&gt; 'Reset &lt;1s&gt; bundle structure?') expandMacrosWith: aPackage name ) )				ifFalse: [ ^self ].			].	aPackage structure: package structure</body></methods><methods><class-id>Store.BundleStructureTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="bundle:">bundle: aBundle	^self new		package: aBundle;		yourself</body></methods><methods><class-id>Store.BundleStructureTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^11</body></methods><methods><class-id>Store.Compiling</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="actionText">actionText	^(#Compiling &lt;&lt; #store &gt;&gt; 'Compiling') asString</body></methods><methods><class-id>Store.ObsoleteBrowserContent</class-id> <category>accessing</category><body package="Store-Base" selector="session">session	^session</body><body package="Store-Base" selector="session:">session: aGlorpSession	session := aGlorpSession</body><body package="Store-Base" selector="wasUsed">wasUsed	^wasUsed</body><body package="Store-Base" selector="wasUsed:">wasUsed: anObject	wasUsed := anObject</body></methods><methods><class-id>Store.ObsoleteBrowserContent</class-id> <category>initialize-release</category><body package="Store-Base" selector="initialize">initialize	super initialize.	wasUsed := false.</body></methods><methods><class-id>Store.ObsoleteBrowserContent class</class-id> <category>instance creation</category><body package="Store-Base" selector="new">new	^super new initialize.</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>accessing</category><body package="Store-Database Model" selector="basicContents">basicContents	^contents.</body><body package="Store-Database Model" selector="basicContents:">basicContents: aStoreBlob	contents := aStoreBlob.</body><body package="Store-Database Model" selector="basicFilename">basicFilename	^filename</body><body package="Store-Database Model" selector="basicFilename:">basicFilename: aByteArray	filename := aByteArray.</body><body package="Store-Database Model" selector="basicSource">basicSource	^self basicContents.</body><body package="Store-Database Model" selector="bossDecode:">bossDecode: aByteArray		| stream bos result |	Dialect isVisualWorks ifFalse: [self error: 'Requires BOSS'].	aByteArray ifNil: [^nil].	stream := ReadStream on: aByteArray asByteArray.	bos := (Dialect smalltalkAt: #BinaryObjectStorage) onOld: stream.	result := bos next.	bos close.	^result</body><body package="Store-Database Model" selector="bossEncode:">bossEncode: anObject		| stream bos |	Dialect isVisualWorks ifFalse: [self error: 'Requires BOSS'].	stream := WriteStream on: ByteArray new.	bos := (Dialect smalltalkAt: #BinaryObjectStorage) onNew: stream.	bos nextPut: anObject.	bos close.	^stream contents</body><body package="Store-Database Model" selector="bundle:">bundle: aBundleModel	"For compatibility. I think we can just ignore it"	^self.</body><body package="Store-Database Model" selector="contents">contents	^contents binaryData.</body><body package="Store-Database Model" selector="contents:">contents: aByteArray	contents := StoreBinaryBlob forByteArray: aByteArray.</body><body package="Store-Database Model" selector="fileRef">fileRef	^self primaryKey</body><body package="Store-Database Model" selector="fileSize">fileSize	^fileSize</body><body package="Store-Database Model" selector="fileSize:">fileSize: anObject	fileSize := anObject</body><body package="Store-Database Model" selector="filename">filename	^Dialect isVisualWorks		ifTrue: [(Dialect smalltalkAt: #LogicalFilename) fromComponents: (self bossDecode: filename)]		ifFalse: [self error: 'VisualWorks specific code'].</body><body package="Store-Database Model" selector="filename:">filename: aFilename	filename := self bossEncode: (aFilename asLogicalFileSpecification componentStrings).</body><body package="StoreForGlorpVWUI" selector="md5Value">md5Value	^self basicContents binaryData md5Value</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	contents := contents glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreFile	self fileSize = aStoreFile fileSize ifFalse: [^false].	self filename = aStoreFile filename ifFalse: [^false].	self contents = aStoreFile contents ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="unreconcile">unreconcile	super unreconcile.	contents unreconcile.</body></methods><methods><class-id>Store.Glorp.StoreFile</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="asComponentDescription">asComponentDescription		| fileModel |	fileModel := Store.FileModel new.	fileModel dbTrace: primaryKey.	primaryKey notNil ifTrue: [fileModel portableFilename: self filename].	^fileModel</body><body package="StoreForGlorpVWUI" selector="asComponentDescriptionForReal">asComponentDescriptionForReal	"Return a representation of ourselves as a store component description, used to update the image after a publish."	| baby |	baby := Store.FileModel new.	baby dbTrace: primaryKey.	primaryKey notNil		ifTrue: [ baby portableFilename: self filename ].	^baby</body><body package="Store-Database Model" selector="download">download	"Download the file. Answer whether we did so successfully."	^self downloadTo: self filename</body><body package="Store-Database Model" selector="downloadTo:">downloadTo: aFilename	"Download the file. Answer whether we did so successfully."		| fileContents validFIlename stream |	(fileContents := self contents) ifNil:		[Dialog warn: (#IsEmpty &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is empty' expandMacrosWith: self filename).		^false].	(validFIlename := self validateFilenameForDownload: aFilename) ifNil: 		[^false].	stream := validFIlename writeStream binary.	[stream nextPutAll: fileContents] ensure: [stream close].	^true</body><body package="Store-Database Model" selector="validateFilenameForDownload:">validateFilenameForDownload: aFilename	"Validate that a file can be written. Answer the filename to be used."		| targetFilename |	targetFilename := aFilename.	[targetFilename canBeWritten]		whileFalse:			[targetFilename := (Dialog				request: #PleaseEnterAValidFAmeForThisPlatform &lt;&lt; #store &gt;&gt; 'Please enter a valid filename for this platform'				initialAnswer: targetFilename asString				onCancel: [^nil]) asFilename].	^targetFilename</body></methods><methods><class-id>Store.Glorp.StoreFile class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="fromFileRecord:">fromFileRecord: aFileRecord	"We can't rely on FileRecord actually existing in this image, so convert it from this end and assume we know the right instance variables"	| result |	result := self new.	result privateSetPrimaryKey: aFileRecord primaryKey.	result name: aFileRecord name.	result filename: aFileRecord name.	result filename exists ifTrue: [		| stream bits |		[			stream := result filename readStream.		stream binary.		bits := stream upToEnd.		result contents: bits.		result fileSize: bits size]			ensure: [stream close]].	^result</body><body package="Store-Database Model" selector="named:bits:">named: aString bits: bits	^self new name: aString; filename: aString; contents: bits; fileSize: bits size.</body></methods><methods><class-id>Store.PreReadActionConfirmation</class-id> <category>constants</category><body package="Store-Base" selector="defaultResumeValue">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="Store-Base" selector="defaultReturnValue">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.PreReadActionConfirmation</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		^Dialog confirm: (#PreReadActionFor1IledNttttContinue &lt;&lt; #store &gt;&gt; 'Pre-read action for &lt;1s&gt; failed.&lt;ntttt&gt;Continue?' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^false</body><body package="Store-Merge Management" selector="isPropertyResolver">isPropertyResolver	^true</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	^false</body><body package="Store-Merge Management" selector="sameDefinitionAs:">sameDefinitionAs: anAssociation	| alternative |	alternative := self standardResolutionAlternative ifNil: [^false].	alternative package pseudoPackage ifTrue: [^false].	^(alternative package propertyAt: anAssociation key) = anAssociation value</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	| newValue |	applyable ifFalse: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isAbsentResolution ifTrue: [^true].	proposed isNoOpResolution ifTrue: [^true].	newValue := proposed isUserInputResolution		ifTrue: [proposed value]		ifFalse: [proposed value value].	(newValue isKindOf: Text) ifTrue: [newValue := newValue asString].	proposed key storeModel propertyAt: propertyKey put: newValue.	^true</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	proposed key storeModel propertyAt: propertyKey put: nil.	^true</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management" selector="propertyKey">propertyKey	^propertyKey</body><body package="Store-Merge Management" selector="propertyKey:">propertyKey: aSymbol	propertyKey := aSymbol</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="parseText:">parseText: aString	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^false].	alternative value value isString ifFalse: [^false].	^aString notNil</body></methods><methods><class-id>Store.Glorp.PropertyChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value isString		ifTrue: [anAlternative value]		ifFalse: 			[(anAlternative value value isKindOf: CompiledMethod)				ifFalse: [anAlternative value value printString]				ifTrue: [anAlternative value value method getSource]]</body><body package="Store-Merge Management" selector="listIcon">listIcon	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^PackageModel toolListIcon].	^alternative key toolListIcon</body><body package="Store-Merge Management" selector="longListName">longListName	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [nil].	^(alternative isNil		ifTrue: ['Unkown']		ifFalse: [alternative key name]) , (#SpaceBracketPropertyBracketSpace &lt;&lt; #store &gt;&gt; ' [Property] ') asString, self propertyKey printString, self applyableString.</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName	| storeObject |	storeObject := ((base notNil and: [base isRemovalResolution]) ifTrue: [base base] ifFalse: [base ifNil: [original ifNil: [proposed]]]).	storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	^storeObject value key printString</body><body package="Store-Merge Management" selector="shortListName">shortListName	^self longListName</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName	| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.StorePublishingError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog warn:		(#AnErrorOccuredPublishingn1snNoChanges &lt;&lt; #store &gt;&gt;			'An error occured when writing to the database.&lt;n&gt;&lt;1s&gt;&lt;n&gt;No changes to the database have been commited' 				expandMacrosWith: self messageText).	^nil</body></methods><methods><class-id>Store.UserCancelledPublish</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog warn:		(#UserHasChosenToCancelPublishing &lt;&lt; #store &gt;&gt;			'User has chosen to cancel publishing instead of entering a new version string.&lt;n&gt;No changes to the database have been commited') asString.	^nil</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>private</category><body package="Store-User Management" selector="initialVersionOf:fromList:version:">initialVersionOf: reqName fromList: pundleList version: reqVersion	"Answer the inital version for testing. nil means user cancelled."		| versionToUse |	self versionSelection == #ask ifFalse: 		[versionToUse := pundleList detect: [:aPundle | self isSatisfiedBy: aPundle] ifNone: [nil]].	versionToUse ifNil: 		[versionToUse := self selectPrereqVersionOf: reqName fromList: pundleList version: reqVersion.		versionToUse isSymbol ifTrue: [^self processPrereqResultFor: versionToUse]].	^versionToUse</body><body package="Store-User Management" selector="isSatisfiedBy:">isSatisfiedBy: p		^p blessingLevelNumber &gt;= self blessingLevel.</body><body package="Store-User Management" selector="processPrereqResultFor:">processPrereqResultFor: aSymbol	aSymbol == #quitLoading ifTrue: [^LoadCanceled raiseSignal].	aSymbol == #tryParcel ifTrue: [^nil].	SkipPrerequisite raiseSignal</body><body package="Store-User Management" selector="selectPrereqVersionOf:fromList:version:">selectPrereqVersionOf: aPundleName fromList: aList version: aString	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."		^PrerequisiteSelector openWith: aList</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="blessingLevel">blessingLevel	blessingLevel == nil		ifTrue: [ blessingLevel := Policies blessingPolicy defaultBlessing ].	^blessingLevel</body><body package="Store-User Management" selector="blessingLevel:">blessingLevel: anInteger	blessingLevel := anInteger</body><body package="Store-User Management" selector="searchOrder">searchOrder	searchOrder == nil		ifTrue: [ searchOrder := #parcelsFirst ].	^searchOrder</body><body package="Store-User Management" selector="searchOrder:">searchOrder: aSymbol		searchOrder := aSymbol</body><body package="Store-User Management" selector="versionSelection">versionSelection	versionSelection == nil		ifTrue: [ versionSelection := #ask ].	^versionSelection</body><body package="Store-User Management" selector="versionSelection:">versionSelection: aSymbol	versionSelection := aSymbol</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>selecting</category><body package="Store-User Management" selector="getPrereq:from:version:for:">getPrereq: reqName from: pundleList version: reqVersion for: aPundle 	"Removed loop. Enabled to enforce loading of differing package version"	| pundle |	( pundle := self 				initialVersionOf: reqName				fromList: pundleList				version: reqVersion ) == nil 		ifTrue: [ ^ nil ].	"user cancelled selection"	( pundle == nil or: 			[ aPundle 				checkPrerequisiteNamed: reqName				withVersion: pundle version				requiredVersion: reqVersion ] ) 		ifTrue: [ ^pundle ].	( Dialog confirm: ( (#_1sRequiresNt2sAdNt4sNInstead &lt;&lt; #store &gt;&gt; '&lt;1s&gt; requires&lt;nt&gt;&lt;2s&gt; version: &lt;3s&gt;&lt;n&gt;Do you want to load&lt;nt&gt;&lt;4s&gt;&lt;n&gt;instead?') 						expandMacrosWith: aPundle displayString with: reqName with: reqVersion with: pundle displayString ) )			ifTrue: [ ^pundle ].	^self selectPrereqVersionOf: reqName fromList: pundleList version: reqVersion.</body></methods><methods><class-id>Store.PseudoNamespaceDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="changedMethodsSharedAndProperties">changedMethodsSharedAndProperties		^self classNamespaceDifferences , self sortedSharedDifferences</body><body package="Store-Difference Management" selector="classListIcon">classListIcon	^NameSpace toolListIcon</body><body package="Store-Difference Management" selector="classListName">classListName	^mainObject isNil 		ifTrue: 			[otherObject isNil				ifTrue: [self sharedDifferences first mainObject longNameFromSmalltalk]				ifFalse: [otherObject longNameFromSmalltalk]]		ifFalse: [mainObject longNameFromSmalltalk]</body><body package="Store-Difference Management" selector="classNamespaceDifferences">classNamespaceDifferences	| pseudoDefinition pseudoComment |	pseudoDefinition := PseudoNamespaceDefinitionDifference new.	pseudoDefinition mainPackage: mainPackage definition: self mainDefinition.	pseudoDefinition otherPackage: otherPackage definition: self otherDefinition.	pseudoComment := PseudoNamespaceCommentDifference new.	pseudoComment mainPackage: mainPackage comment: mainComment.	pseudoComment otherPackage: otherPackage comment: otherComment.	^OrderedCollection with: pseudoDefinition with: pseudoComment</body><body package="Store-Difference Management" selector="mainClass">mainClass	^self mainNamespace ifNotNil: [:value | self mainPackage objectNamed: value asString]</body><body package="Store-Difference Management" selector="mainClassLongName">mainClassLongName	self mainNamespace ifNotNil: [:value | ^value absoluteName].	self sharedDifferences notEmpty ifTrue:		[self sharedDifferences first mainObject ifNotNil: [:value | ^value classNameWithoutMeta]].	^''</body><body package="Store-Difference Management" selector="mainClassStoreObject">mainClassStoreObject	| targetObject |	mainObject ifNotNil: [^self mainPackage objectNamed: self mainClassLongName].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleMainSharedDifference.		targetObject ifNotNil: [^targetObject mainPackage objectNamed: targetObject mainObject classNameWithoutMeta]].	^nil</body><body package="Store-Difference Management" selector="mainComment">mainComment	^mainComment ifNil: [^'']</body><body package="Store-Difference Management" selector="mainDefinition">mainDefinition	^mainDefinition ifNil: [^'']</body><body package="Store-Difference Management" selector="mainNamespace">mainNamespace	^mainObject ifNil:		[(self sharedDifferences 			detect: [:each | each mainObject notNil]			ifNone: [nil]) ifNotNil: [:value | value mainPackage objectNamed: value mainObject environmentName]]</body><body package="Store-Difference Management" selector="mainPackage:namespace:">mainPackage: aPackage namespace: aNamespace	self mainPackage: aPackage object: aNamespace</body><body package="Store-Difference Management" selector="mainPackage:namespace:comment:definition:">mainPackage: aPackage namespace: aNamespace comment: aString definition: aDefinitionString	self mainPackage: aPackage object: aNamespace.	mainComment := aString.	mainDefinition := aDefinitionString</body><body package="Store-Difference Management" selector="mainPackage:shared:">mainPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference mainPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference mainPackage: aPackage shared: aStoreSharedVariable]</body><body package="Store-Difference Management" selector="methodDifferences">methodDifferences	^OrderedCollection new</body><body package="Store-Difference Management" selector="modifiedClassNamespaceDifferences">modifiedClassNamespaceDifferences	| pseudoDefinition pseudoComment trueDifferences |	trueDifferences := OrderedCollection new.	self mainDefinition = self otherDefinition ifFalse:		[pseudoDefinition := PseudoNamespaceDefinitionDifference new.		pseudoDefinition mainPackage: mainPackage definition: self mainDefinition.		pseudoDefinition otherPackage: otherPackage definition: self otherDefinition.		trueDifferences add: pseudoDefinition].	self mainComment = self otherComment ifFalse: 		[pseudoComment := PseudoNamespaceCommentDifference new.		pseudoComment mainPackage: mainPackage comment: mainComment.		pseudoComment otherPackage: otherPackage comment: otherComment.		trueDifferences add: pseudoComment].	^trueDifferences</body><body package="Store-Difference Management" selector="modifiedMethodsSharedAndProperties">modifiedMethodsSharedAndProperties		^self modifiedClassNamespaceDifferences , self sortedSharedDifferences</body><body package="Store-Difference Management" selector="otherClass">otherClass	^self otherNamespace ifNotNil: [:value | self otherTargetPackage objectNamed: value asString]</body><body package="Store-Difference Management" selector="otherClassLongName">otherClassLongName	self otherNamespace ifNotNil: [:value | ^value absoluteName].	self sharedDifferences notEmpty ifTrue:		[self sharedDifferences first otherObject ifNotNil: [:value | ^value classNameWithoutMeta]].	^''</body><body package="Store-Difference Management" selector="otherClassStoreObject">otherClassStoreObject	| targetObject |	otherObject ifNotNil: [^self otherPackage objectNamed: self otherClassLongName].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleOtherSharedDifference.		targetObject ifNotNil: [^targetObject otherPackage objectNamed: targetObject otherObject classNameWithoutMeta]].	^nil</body><body package="Store-Difference Management" selector="otherComment">otherComment	^otherComment ifNil: [^'']</body><body package="Store-Difference Management" selector="otherDefinition">otherDefinition	^otherDefinition ifNil: [^'']</body><body package="Store-Difference Management" selector="otherNamespace">otherNamespace	^otherObject ifNil:		[(self sharedDifferences 			detect: [:each | each otherObject notNil]			ifNone: [nil]) ifNotNil: [:value | value otherPackage objectNamed: value otherObject environmentName]]</body><body package="Store-Difference Management" selector="otherPackage:justNamespace:">otherPackage: aPackage justNamespace: aNamespace	self otherPackage: aPackage object: aNamespace fullName asQualifiedReference</body><body package="Store-Difference Management" selector="otherPackage:namespace:">otherPackage: aPackage namespace: aNamespace	self  otherPackage: aPackage namespace: aNamespace fullName asQualifiedReference comment: aNamespace comment definition: aNamespace definition</body><body package="Store-Difference Management" selector="otherPackage:namespace:comment:definition:">otherPackage: aPackage namespace: aNamespace comment: aString definition: aDefinitionString	self otherPackage: aPackage object: aNamespace.	otherComment := aString.	otherDefinition := aDefinitionString</body><body package="Store-Difference Management" selector="otherPackage:shared:">otherPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference otherPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference otherPackage: aPackage shared: aStoreSharedVariable]</body><body package="Store-Difference Management" selector="otherTargetPackage">otherTargetPackage	^otherPackage ifNil:		[ | target |		target := self sharedDifferences 			detect: [:each | each otherPackage notNil]			ifNone: [nil].		target ifNotNil: [target otherPackage]]</body><body package="Store-Difference Management" selector="referencesHolderClass">referencesHolderClass 	^NamespaceResolutions</body><body package="Store-Difference Management" selector="sampleMainSharedDifference">sampleMainSharedDifference		^self sharedDifferences detect: [:each | each mainObject notNil] ifNone: [nil]</body><body package="Store-Difference Management" selector="sampleOtherSharedDifference">sampleOtherSharedDifference		^self sharedDifferences detect: [:each | each otherObject notNil] ifNone: [nil]</body><body package="Store-Difference Management" selector="sharedDifferences">sharedDifferences	sharedDifferences ifNil: [sharedDifferences := OrderedCollection new].	^sharedDifferences</body></methods><methods><class-id>Store.PseudoNamespaceDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="hasMainDifferences">hasMainDifferences	self mainNamespace ifNotNil: [^true].	(self sharedDifferences 		detect: [:each | each mainObject notNil]		ifNone: [nil]) ifNotNil: [^true].	^false</body><body package="Store-Difference Management" selector="hasOtherDifferences">hasOtherDifferences	self otherNamespace ifNotNil: [^true].	(self sharedDifferences 		detect: [:each | each otherObject notNil]		ifNone: [nil]) ifNotNil: [^true].	^false</body><body package="Store-Difference Management" selector="isMainDefinedInPackage">isMainDefinedInPackage	mainPackage isImageModel ifTrue: 		[ | imageObject |		imageObject := self mainClassStoreObject isImageObject			ifTrue: [self mainClassStoreObject]			ifFalse: [self mainClassStoreObject correspondingImageClass].		imageObject  ifNil: [^false].		^mainPackage definesObject: imageObject].	^mainPackage definesObject: (self mainClassStoreObject ifNil: [^false])</body><body package="Store-Difference Management" selector="isNamespace">isNamespace	^true</body><body package="Store-Difference Management" selector="isOtherDefinedInPackage">isOtherDefinedInPackage	^otherPackage definesObject: (self otherClassStoreObject ifNil: [^false])</body></methods><methods><class-id>Store.PseudoNamespaceDifference</class-id> <category>private</category><body package="Store-Difference Management" selector="sortedSharedDifferences">sortedSharedDifferences		^(self sharedDifferences collect: [:each | each selectorListName -&gt; each])		asSortedCollection collect: [:each | each value]</body></methods><methods><class-id>Store.PseudoNamespaceDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:fromShared:">mainPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference mainPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		mainPackage: aPackage namespace: namespace fullName asQualifiedReference comment: namespace comment definition: namespace definitionString;		yourself</body><body package="Store-Difference Management" selector="mainPackage:namespace:">mainPackage: aPackage namespace: aNamespace	| instance |	instance := self new.	^instance		mainPackage: aPackage namespace: aNamespace fullName asQualifiedReference comment: aNamespace comment definition: aNamespace definitionString;		yourself</body><body package="Store-Difference Management" selector="otherPackage:fromShared:">otherPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference otherPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		otherPackage: aPackage namespace: namespace fullName asQualifiedReference comment: namespace comment definition: namespace definitionString;		yourself</body><body package="Store-Difference Management" selector="otherPackage:namespace:">otherPackage: aPackage namespace: aNamespace	| instance |	instance := self new.	^instance		otherPackage: aPackage namespace: aNamespace fullName asQualifiedReference comment: aNamespace comment definition: aNamespace definitionString;		yourself</body></methods><methods><class-id>Store.PseudoNamespaceExtensionDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="classListName">classListName	^mainObject isNil 		ifTrue: 			[otherObject isNil				ifTrue: [self sharedDifferences first classListName]				ifFalse: [otherObject]]		ifFalse: [mainObject]</body><body package="Store-Difference Management" selector="classNamespaceDifferences">classNamespaceDifferences	| pseudoDefinition pseudoComment |	pseudoDefinition := PseudoNamespaceDefinitionDifference new.	pseudoDefinition mainPackage: mainPackage definition: nil.	pseudoDefinition otherPackage: otherPackage definition: nil.	pseudoComment := PseudoNamespaceCommentDifference new.	pseudoComment mainPackage: mainPackage comment: nil.	pseudoComment otherPackage: otherPackage comment: nil.	^OrderedCollection with: pseudoDefinition with: pseudoComment</body><body package="Store-Difference Management" selector="correspondingImageNamespace">correspondingImageNamespace	| sharedDifference |	Dialect reset.	(mainPackage notNil and: [mainObject notNil])		ifTrue: [^Dialect smalltalkAt: 'Root.Smalltalk.', mainObject ifAbsent: [nil]].	(otherPackage notNil and: [otherObject notNil])		ifTrue: [^Dialect smalltalkAt: 'Root.Smalltalk.', otherObject ifAbsent: [nil]].	sharedDifference := sharedDifferences first.	^mainObject isNil		ifTrue: [Dialect smalltalkAt: 'Root.Smalltalk.', sharedDifference otherObject environmentNameFromSmalltalk ifAbsent: [nil]]		ifFalse: [Dialect smalltalkAt: 'Root.Smalltalk.', sharedDifference mainObject environmentNameFromSmalltalk ifAbsent: [nil]]</body><body package="Store-Difference Management" selector="mainClassStoreObject">mainClassStoreObject	^self</body><body package="Store-Difference Management" selector="modifiedClassNamespaceDifferences">modifiedClassNamespaceDifferences	^OrderedCollection new</body><body package="Store-Difference Management" selector="otherClassStoreObject">otherClassStoreObject	^self</body></methods><methods><class-id>Store.PseudoNamespaceExtensionDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="hasMainDifferences">hasMainDifferences	^mainObject notNil</body><body package="Store-Difference Management" selector="hasOtherDifferences">hasOtherDifferences	^otherObject notNil</body><body package="Store-Difference Management" selector="isForClassOrExtension">isForClassOrExtension	^false</body><body package="Store-Difference Management" selector="isNamespaceExtension">isNamespaceExtension	^true</body></methods><methods><class-id>Store.PseudoNamespaceExtensionDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:fromShared:">mainPackage: aPackage fromShared: aSharedVariable	| instance |	instance := self new.	instance mainObject: aSharedVariable environmentNameFromSmalltalk.	instance mainPackage: aPackage.	^instance</body><body package="Store-Difference Management" selector="otherPackage:fromShared:">otherPackage: aPackage fromShared: aSharedVariable	| instance |	instance := self new.	instance otherObject: aSharedVariable environmentNameFromSmalltalk.	instance otherPackage: aPackage.	^instance</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	resolutions := Dictionary new.</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>accessing</category><body package="Store-Merge Management" selector="baseLabel">baseLabel	^''</body><body package="Store-Merge Management" selector="bundleStructureDisplayString">bundleStructureDisplayString	^(#BracketBundleStructureBracket &lt;&lt; #store &gt;&gt; '[Bundle Structure]') asString</body><body package="Store-Merge Management" selector="imageLabel">imageLabel	^''</body><body package="Store-Merge Management" selector="longTreeName">longTreeName	^self shortTreeName</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName		^name</body><body package="Store-Merge Management" selector="name">name		^name</body><body package="Store-Merge Management" selector="named:">named: aString	name := aString</body><body package="Store-Merge Management" selector="rejectBlockFor:">rejectBlockFor: aSymbol		^aSymbol = #all 		ifTrue: [[:each | false]] 		ifFalse: 			[aSymbol = #conflicts 				ifTrue: [[:each | each hasNoConflicts]] 				ifFalse: [[:each | each isResolved]]]</body><body package="Store-Merge Management" selector="resolutionForDifference:fromVersion:">resolutionForDifference: aPseudoDifference fromVersion: aPackage	| resolver resolution |	aPseudoDifference differenceName = self bundleStructureDisplayString ifTrue: [^self].	resolver := resolutions 		at: aPseudoDifference differenceName 		ifAbsentPut: [aPseudoDifference resolutionClass new].	resolver ownerName: name.	aPseudoDifference mainObject ifNotNil: 		[:value | 		| originalResolver |		aPseudoDifference mainPackage isVersionLoaded ifTrue:			[(resolver original isNil or: [aPseudoDifference mainPackage isImageModel]) ifTrue: 				[(aPseudoDifference otherPackage isNil or: [aPseudoDifference otherPackage pseudoPackage not]) ifTrue:					[resolver original: (originalResolver := StandardResolution 						package: aPseudoDifference mainPackage 						resolver: value)]].			(aPseudoDifference otherPackage notNil and: [aPseudoDifference otherPackage pseudoPackage not and: [aPseudoDifference otherObject isNil]]) ifTrue: 				[resolution := RemovalResolution 					fromBaseResolution: aPseudoDifference otherPackage -&gt; value 					fromPackage: aPackage.				resolver base: resolution.				resolver addAlternative: resolution]].		resolver addAlternative: (originalResolver ifNil: [StandardResolution 			package: aPseudoDifference mainPackage 			resolver: value]).		resolver isPropertyResolver ifTrue: [resolver propertyKey: aPseudoDifference mainObject key]].	aPseudoDifference otherObject ifNotNil: 		[:value | 		| target |		resolver addAlternative: (target := StandardResolution 			package: aPseudoDifference otherPackage 			resolver: value).		resolver base: target.		aPseudoDifference mainObject isNil			ifTrue: 				[resolution := RemovalResolution 					fromBaseResolution: aPackage -&gt; value 					fromPackage: aPackage.				resolver addAlternative: resolution.				resolver original: (aPseudoDifference otherPackage isVersionLoaded 					ifTrue: 						[aPackage isImageObject 							ifTrue: [resolution] 							ifFalse: [target]] 					ifFalse: [(target package isVersionLoaded and: [target sameAsImageUsing: resolver]) ifTrue: [target]])]			ifFalse: 					[aPseudoDifference otherPackage isVersionLoaded					ifTrue: [(resolver original isNil or: [aPseudoDifference otherPackage isImageModel]) ifTrue: [resolver original: target]]					ifFalse: [(resolver original isNil and: [target sameAsImageUsing: resolver]) ifTrue: [resolver original: target]]].		resolver isPropertyResolver ifTrue: [resolver propertyKey: aPseudoDifference otherObject key]].	^resolver</body><body package="Store-Merge Management" selector="resolutionIcon">resolutionIcon	^self isResolved		ifFalse: [self class unresolvedImage]		ifTrue: 			[self hasBeenApplied				ifTrue: 					[self isApplyable						ifTrue: [self class appliedImage]						ifFalse: [self class unappliedImage]]				ifFalse: 					[self isApplyable 						ifTrue: [self class resolvedImage]						ifFalse: [self class unapplyableImage]]].</body><body package="Store-Merge Management" selector="resolutionLabel">resolutionLabel	^''</body><body package="Store-Merge Management" selector="resolutions">resolutions	^resolutions</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName		^self mergeDisplayName , self applyableString</body><body package="Store-Merge Management" selector="sortedListResolutionValues:">sortedListResolutionValues: aSymbol	| result |	result := OrderedCollection new.	resolutions values 		inject: result 		into: 			[:sum :each | 			sum addAll: (each sortedListResolutionValues: aSymbol).			sum].	^result</body><body package="Store-Merge Management" selector="sortedTreeResolutionValues:">sortedTreeResolutionValues: aSymbol	| rejectBlock |	rejectBlock := self rejectBlockFor: aSymbol.	^resolutions values reject: rejectBlock</body><body package="Store-Merge Management" selector="standardResolutionAlternative">standardResolutionAlternative		self resolutions do: [:each | each standardResolutionAlternative ifNotNil: [:value | ^value]].	^nil</body><body package="Store-Merge Management" selector="typeIcon">typeIcon	^nil</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^true</body><body package="Store-Merge Management" selector="displaysProtocolStatus">displaysProtocolStatus	^false</body><body package="Store-Merge Management" selector="hasBeenApplied">hasBeenApplied	^resolutions values allSatisfy: #hasBeenApplied</body><body package="Store-Merge Management" selector="hasNoConflicts">hasNoConflicts	resolutions isEmpty ifTrue: [^false].	^resolutions values allSatisfy: #hasNoConflicts</body><body package="Store-Merge Management" selector="isApplyable">isApplyable	^true</body><body package="Store-Merge Management" selector="isBundleStructureResolver">isBundleStructureResolver	^false</body><body package="Store-Merge Management" selector="isForClass">isForClass	^false</body><body package="Store-Merge Management" selector="isForNamespace">isForNamespace	^false</body><body package="Store-Merge Management" selector="isForProperties">isForProperties	^false</body><body package="Store-Merge Management" selector="isMethodResolver">isMethodResolver	^false</body><body package="Store-Merge Management" selector="isResolved">isResolved	resolutions isEmpty ifTrue: [^false].	^resolutions values allSatisfy: #isResolved</body><body package="Store-Merge Management" selector="isResolver">isResolver	^false</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>visiting</category><body package="Store-Merge Management" selector="collectResolutionsInto:">collectResolutionsInto: aSet	resolutions do: [:each | each collectResolutionsInto: aSet].</body><body package="Store-Merge Management" selector="execute:ifTrueAddTo:">execute: aBlock ifTrueAddTo: anOrderedCollection		resolutions do: [:each | each execute: aBlock ifTrueAddTo: anOrderedCollection]</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="doNotResolve">doNotResolve	resolutions do: [:each | each doNotResolve]</body><body package="Store-Merge Management" selector="makeResolutionProposals">makeResolutionProposals		self resolutions do: [:each | each makeResolutionProposals]</body><body package="Store-Merge Management" selector="proposedResolutions">proposedResolutions	| proposedResolutions |	proposedResolutions := OrderedCollection new.	self resolutions do: [:each | proposedResolutions addAll: each proposedResolutions].	^proposedResolutions</body><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	self resolutions do: [:each | each removeEmptyResolvers].	self resolutions copy do:		[:each |		each resolutions isEmpty ifTrue: [resolutions removeKey: each name ifAbsent: [nil]].		each isBundleStructureResolver and: [each alternatives isEmpty ifTrue: 			[resolutions size = 1 ifTrue: [resolutions := Dictionary new]]]]</body><body package="Store-Merge Management" selector="resolution:">resolution: aResolutionPackageItem	resolutions do: [:each | each resolution: aResolutionPackageItem].</body><body package="Store-Merge Management" selector="unApply">unApply	resolutions do: [:each | each unApply].</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>displaying</category><body package="Store-Merge Management" selector="applyableString">applyableString	^self isApplyable not		ifTrue: [(#SpaceParenInformationalColonNotResolvableParen &lt;&lt; #store &gt;&gt; ' (Informational: Not Resolvable)') asString]		ifFalse: ['']</body><body package="Store-Merge Management" selector="browseVersions">browseVersions	self subclassResponsibility</body><body package="Store-Merge Management" selector="createModificationDisplayRecords">createModificationDisplayRecords	| list collector |	list := List new.	collector := Set new.	resolutions do: [:each | each collectResolutionsInto: collector].	collector := collector reject: #isAbsentResolution.	collector do:		[:each |		(list contains: [:eachDisplayRecord | eachDisplayRecord package = each package])			ifFalse: [list add: each]].	(list allSatisfy: [:each | each image not]) ifTrue: [list add: ResolutionPackageItem forAbsentImage].	list := (list asSortedCollection: [:each :other | each sortKey &lt; other sortKey]).	^list</body><body package="Store-Merge Management" selector="explanationText">explanationText	| stream |	stream := WriteStream on: String new.	stream 		nextPut: $[;		nextPutAll: name;		nextPut: $].	self isApplyable		ifTrue: [stream nextPutAll: ((#Does1qHaveQllProposedResolutions &lt;&lt; #store &gt;&gt; ' has &lt;1?:not &gt;been fully resolved.') expandMacrosWith: self isResolved)]		ifFalse: [stream nextPutAll: ((#IsForInformationOnlyAndIsNotResolvable &lt;&lt; #store &gt;&gt; ' is for information purposes only, and is not resolvable.&lt;n&gt;The object this is resolved to was a Class (&lt;1s&gt;) and is now a Shared Variable representing another class (&lt;2s&gt;)&lt;n&gt;To see all modifications, it is important that this package be reconciled with the database.') 			expandMacrosWith: self name			with: self name asQualifiedReference value name)].	stream cr.	(self isApplyable and: [self isResolved]) ifTrue:		[stream nextPutAll: ((#ResolutionHas1qBeenApplied &lt;&lt; #store &gt;&gt; 'Resolutions have&lt;1?: not yet&gt; been applied to the image') expandMacrosWith: self hasBeenApplied)].	^stream contents</body></methods><methods><class-id>Store.Glorp.AbstractResolutions</class-id> <category>private - accessing</category><body package="Store-Merge Management" selector="sortedResolutionsSelectedBy:">sortedResolutionsSelectedBy: aSelectBlock	"Aggressively cache shortTreeName, and sort the results only once"	| selectedResolutions sortKeys sortedKeys answer |	selectedResolutions := OrderedCollection new.	resolutions do: [:each | (aSelectBlock value: each) ifTrue: [selectedResolutions add: each]].	sortKeys := (1 to: selectedResolutions size) collect: [:each | (selectedResolutions at: each) shortTreeName -&gt; each].	sortedKeys := sortKeys asSortedCollection: [:x :y | x key &lt; y key].	answer := Array new: sortedKeys size.	sortedKeys doWithIndex:		[:each :eachWriteIndex |			answer				at: eachWriteIndex				put: (selectedResolutions at: each value)		].	^answer</body></methods><methods><class-id>Store.Glorp.AbstractResolutions class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="named:">named: aString	| instance |	instance := self new.	instance named: aString.	^instance</body><body package="Store-Merge Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.AbstractResolutions class</class-id> <category>resources</category><body package="Store-Merge Management" selector="appliedImage">appliedImage	^MergeIcons applied</body><body package="Store-Merge Management" selector="resolvedImage">resolvedImage	^MergeIcons resolved</body><body package="Store-Merge Management" selector="unappliedImage">unappliedImage	^MergeIcons unapplied</body><body package="Store-Merge Management" selector="unapplyableImage">unapplyableImage	^MergeIcons unapplyable</body><body package="Store-Merge Management" selector="unresolvedImage">unresolvedImage	^MergeIcons unresolved</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>testing</category><body package="Store-Merge Management" selector="isApplyable">isApplyable	^classInImage</body><body package="Store-Merge Management" selector="isForClass">isForClass	^true</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>accessing</category><body package="Store-Merge Management" selector="longTreeName">longTreeName	(name includes: $.) ifTrue: 		[('Root.*' match: name) ifTrue: [^name , self applyableString]].	^'Root.Smalltalk.' , name, self applyableString</body><body package="Store-Merge Management" selector="simpleName">simpleName	| index |	index := name lastIndexOf: $..	^name copyFrom: index + 1 to: name size.</body><body package="Store-Merge Management" selector="sortedTreeResolutionValues:">sortedTreeResolutionValues: aSymbol	| result resolution values rejectBlock |	rejectBlock := self rejectBlockFor: aSymbol.	result := OrderedCollection new.	resolution := resolutions detect: [:each | each isDefintionResolver] ifNone: [nil].	resolution ifNotNil: [result add: resolution].	resolution := resolutions detect: [:each | each isCommentResolver] ifNone: [nil].	resolution ifNotNil: [result add: resolution].	result := result reject: rejectBlock.	values := self sortedResolutionsSelectedBy: [:each | (each isMethodResolver and: [each isMeta]) and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | (each isMethodResolver and: [each isMeta not]) and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | each isSharedResolver and: [(rejectBlock value: each) not]].	result addAll: values.	^result</body><body package="Store-Merge Management" selector="typeIcon">typeIcon	classInImage ifFalse: [^GeneralIcons padlock].	^Behavior toolListIcon</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="makeResolutionProposals">makeResolutionProposals		self resolutions do: [:each | each makeResolutionProposals].	name asStrictReference bindingOrNil ifNotNil:		[:value | 		resolutions at: name ifAbsent: [classInImage := value isForClass]].	classInImage ifFalse: [resolutions do: [:each | each markUnapplyable]].</body><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copy.	resolutions keysAndValuesDo:		[:key :value |		value isProposedRemovalNotInPackage ifTrue: [newResolutions removeKey: key ifAbsent: [nil]].		value alternatives isEmpty ifTrue: [newResolutions removeKey: key ifAbsent: [nil]].		value applied ifTrue: [newResolutions removeKey: key ifAbsent: [nil]]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	super initialize.	classInImage := true.</body></methods><methods><class-id>Store.Glorp.ClassResolutions</class-id> <category>displaying</category><body package="Store-Merge Management" selector="browseVersions">browseVersions	| list session |	(Gathering for: self simpleName) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value key session].	list := Store.Glorp.StoreClassDefinitionInPackage				allVersionsWithName: self simpleName				in: session.	(Gathering for: self simpleName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: name)].	Store.Glorp.DefinitionForListTool forClasses: list</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>testing</category><body package="Store-Change Management" selector="isEmpty">isEmpty		^classes1 isEmpty and: 		[classes2 isEmpty and: 		[meta1 isEmpty and: 		[meta2 isEmpty and: 		[ nameSpaces1 isEmpty and:		[ nameSpaces2 isEmpty and:		[methods1 isEmpty and: 		[methods2 isEmpty and: 		[data1 isEmpty and: 		[data2 isEmpty]]]]]]]]]</body><body package="Store-Change Management" selector="isNewClassDefinition:">isNewClassDefinition: aClass	"Anser true if aClass is in one of the class lists."	^(IdentitySet withAll: (classes1, classes2, meta1, meta2)) includes: aClass</body><body package="Store-Change Management" selector="isNewNameSpaceDefinition:">isNewNameSpaceDefinition: aNameSpace	"Anser true if aNameSpace is in one of the nameSpace lists."	^(IdentitySet withAll: (nameSpaces1, nameSpaces2)) includes: aNameSpace</body><body package="Store-Change Management" selector="isPackageComparitor">isPackageComparitor	^false</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>filing out</category><body package="Store-Change Management" selector="classesToRemove">classesToRemove	^classes2 select: 		[ :each | 		( classes1 detect: [:cl1 | cl1 absoluteName = each absoluteName] ifNone: [ nil] ) 				isNil		]</body><body package="Store-Change Management" selector="dataToRemove">dataToRemove	^data2 		select: [:each | 			(data1 detect: [:m1 | m1 name = each name 							and: [m1 environmentString = each environmentString]]						ifNone: [nil]) isNil]</body><body package="Store-Change Management" selector="fileDiffsOn:">fileDiffsOn: fileManager	"Create a file containing differences between package1 and package2. 	If the package2 is currently loaded into an image, filing in the 	differences will change it into package1"	| class2  nameSpace2 toFileOut  classNamesToRemove nameSpacesToRemove |	fileManager deferInitializations.	"New namespaces or namespaces with new definitions."	nameSpaces1 do: 		[ :each | 		nameSpace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName] ifNone: [ nil ].		each fileOutDifferencesBetween: nameSpace2 on: fileManager		].	"New classes or classes with new definitions."	classes1 do: 		[ :each | 		class2 := classes2 detect: [:cl2 | cl2 absoluteName = each absoluteName] ifNone: [nil].		each fileOutDifferencesBetween: class2 on: fileManager		].	"Removed classes."	classNamesToRemove := self classesToRemove collect: [ :cls | cls absoluteName ].	classNamesToRemove reverseDo: 		[ :className | fileManager removeObject: className type: #class ].	classNamesToRemove := classNamesToRemove, 		( classNamesToRemove collect: [ :cn | cn fullMetaName ] ).		"Removed namespaces."	nameSpacesToRemove := self nameSpacesToRemove collect: [ :ns | ns absoluteName ].	nameSpacesToRemove reverseDo:		[ :nsname | fileManager removeObject: nsname type: #nameSpace	].	"New method definitions."	toFileOut := self modifiedMethods.	toFileOut keysAndValuesDo: 		[ :k :v | fileManager fileOutTTMessages: v for: k logging: false ].	"Removed methods."	self methodsToRemove do: 		[ :method | 		( classNamesToRemove includes: method className )			ifFalse: [ fileManager storeExpression: 						method className , ' removeSelector: ' , method selector storeString 					  ]		].</body><body package="Store-Change Management" selector="isNotLoaded">isNotLoaded	^LoadAnalyzer		preDBLoadOverlapCheckOf: pkg2		classes: classes1		nameSpaces: nameSpaces1		methods: methods1		data: data1</body><body package="Store-Change Management" selector="loadFromDBWithin:">loadFromDBWithin: parentBundle	"Convert a loaded package2 into package1 Don't remove anything defined in parentBundle.	Order of Battle:		New namespaces or namespaces with new definitions.		New classes or classes with new definitions.		Inline Bundle&gt;&gt;#includesDefinitionOf: for speed. Compute the leaf items just once and inline the Bundle queries.		Removed classes.		Load new data.		Load new methods		Removed methods.		Removed data.		remove empty protocols perhaps created by removing and moving methods"		| classesToLoad affected classesNeedingInitialize parentLeafItems |	nameSpaces1 do: [:each | each loadSrcInto: pkg2].	classesToLoad := Package superclassOrder: classes1.	classesToLoad do: [:each | each loadSrcInto: pkg2].	parentLeafItems := parentBundle		ifNil: [Array new]		ifNotNil: [:value | value leafItems].	self classesToRemove , self nameSpacesToRemove do:		[:each | 		| actualObject |		(actualObject := each actual) ifNotNil:			[(parentLeafItems anySatisfy: [:eachPackage | eachPackage includesDefinitionOf: actualObject absoluteName]) not 				ifTrue: [Override unloadClassOrNameSpace: actualObject from: pkg2]]].	data1 do: [:each | each loadSrc].	classesNeedingInitialize := Set new.	methods1 do:		[:each | 		each loadAsNew.		(each isMeta and: [each selector == #initialize]) ifTrue: [classesNeedingInitialize add: each myClass instanceBehavior]].	affected := Set new.	self methodsToRemove do:		[:each | 		| implementingClass |		(implementingClass := each myClass) ifNotNil:			[Override unloadSelector: each selector class: implementingClass from: pkg2 logged: true.			(parentLeafItems anySatisfy: [:eachPackage | eachPackage includesSelector: each selector class: implementingClass]) not				ifTrue: [affected add: implementingClass]				ifFalse: [pkg2 relinquishSelector: each selector class: implementingClass]]].	self dataToRemove do:		[:each | 		| owner |		(owner := each owner) ifNotNil:			[(parentLeafItems anySatisfy: [:eachPackage | eachPackage includesDataKey: each dataKey owner: owner]) not				ifTrue:					[Override unloadStatic: each in: owner from: pkg2 logged: #(#changes #file).					affected add: owner]]].	(DataElement sortStaticsForLoading: data1) do: [:each | (each owner asNameSpace bindingFor: each dataKey) reinitializeValue].	classes1 do:		[:each | 		| object |		((object := each object) class includesSelector: #initialize) ifTrue:			[(classes2 includes: each)				ifTrue: [classesNeedingInitialize add: object]				ifFalse: [object postLoad: pkg1]]].	classesNeedingInitialize do: [:each | each initialize].	affected do: [:each | each organization removeEmptyCategories].	pkg2 removeEmptyProtocols</body><body package="Store-Change Management" selector="methodsToRemove">methodsToRemove	^methods2 select: 		[ :each | 		( methods1 detect: 			[ :m1 | 			( ( m1 isMeta = each isMeta ) and:				[ m1 name = each name ] ) and:				[ m1 className asClassNameOnly = each className asClassNameOnly ] 			] ifNone: [ nil] ) isNil		]</body><body package="Store-Change Management" selector="nameSpacesToRemove">nameSpacesToRemove	^nameSpaces2 select: 		[:each | (nameSpaces1 					detect: [:ns1 | ns1 absoluteName = each absoluteName ]					ifNone: [nil]					) isNil 		]</body><body package="Store-Change Management" selector="preLoadCheckWithin:">preLoadCheckWithin: aBundle	^LoadAnalyzer		preDBLoadOverlapCheckOf: pkg2		within: aBundle		classes: classes1		nameSpaces: nameSpaces1		methods: methods1		data: data1</body><body package="Atomic Compiling and Loading" selector="sortedClassesToRemove">sortedClassesToRemove	| namedClassesToRemove sortedClasses sortedObjects |	namedClassesToRemove := self classesToRemove.	sortedClasses := SystemUtils sortForLoading: (namedClassesToRemove collect: [:each | each actual]).	sortedObjects := OrderedCollection new: namedClassesToRemove size.	1 to: sortedClasses size do:		[:index |		sortedObjects add: (namedClassesToRemove detect: [:each | each absoluteName = (sortedClasses at: index) absoluteName])].	^(sortedObjects reject: [:each | each isNil]) reverse</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing - diff browser</category><body package="Store-Change Management" selector="diffClasses">diffClasses	"Answer an array contianing collection of classes that are either modified in one package	or contain methods that are modified.  Note that meta side is included in the answer."	| names1 aditionalClasses1 names2 aditionalClasses2 allClasses answ1 answ2 names |	names1 := Set new.	methods1 do: [ :m| names1 add: m className ].	data1 do: [ :m | m  isInClass ifTrue: [ names1 add: m ownerName ] ].	allClasses := classes1, meta1.	(allClasses) do: [:cl| names1 remove: cl absoluteName ifAbsent: []].	aditionalClasses1 := pkg1 classesNamed: names1.	answ1 := (allClasses, aditionalClasses1) asSortedCollection: [:x :y | x name &lt; y name].	names2 := Set new.	methods2 do: [:m| names2 add: m classNameWithMeta].	data2 do: [ :m| m  isInClass ifTrue: [names2 add: m ownerName] ].	allClasses := classes2, meta2.	(allClasses) do: [:cl| names2 remove: cl absoluteName ifAbsent: []].	aditionalClasses2 := pkg2 classesNamed: names2.	answ2 := (allClasses, aditionalClasses2) asSortedCollection: [:x :y | x name &lt; y name].	"Check if additional classes are in both packages."	names := names1 - names2.	answ2 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ2 addAll: (pkg2 classesNamed: names).	names := names2 - names1.	answ1 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ1 addAll: (pkg1 classesNamed: names).	^Array with: answ1 with: answ2</body><body package="Store-Change Management" selector="diffNameSpaces">diffNameSpaces	"Answer an array contianing collection of namespaces that are either modified in one package	or contain methods that are modified. "	| names1 aditional1 names2 aditional2 allNameSpaces answ1 answ2 names |	names1 := Set new.	data1 do: [ :m| m  isInNameSpace ifTrue: [ names1 add: m ownerName ] ].	allNameSpaces := nameSpaces1.	allNameSpaces do: [:ns | names1 remove: ns absoluteName ifAbsent: []].	aditional1 := pkg1 nameSpacesNamed: names1.	answ1 := (allNameSpaces, aditional1) asSortedCollection: [:x :y | x absoluteName &lt; y absoluteName].	names2 := Set new.	data2 do: [:m| m  isInNameSpace ifTrue: [ names2 add: m ownerName] ].	allNameSpaces := nameSpaces2.	(allNameSpaces) do: [:ns| names2 remove: ns absoluteName ifAbsent: []].	aditional2 := pkg2 nameSpacesNamed: names2.	answ2 := (allNameSpaces, aditional2) asSortedCollection: [:x :y | x name &lt; y name].	"Check if additional namespaces are in both packages."	names := names1 - names2.	answ2 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ2 addAll: (pkg2 nameSpacesNamed: names).	names := names2 - names1.	answ1 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ1 addAll: (pkg1 nameSpacesNamed: names).	^Array with: answ1 with: answ2</body><body package="Store-Change Management" selector="methodsAndDataSide:forClassNamed:andProtocol:">methodsAndDataSide: side forClassNamed: cName andProtocol: pName 	"If 'pName' is a method protocol select from methods	only those that are from a class named 'cName' and 	classified under protocol 'pName'.  If 'pName' is a data	protocol (*data*) select from data only those that	are from a class named 'cName'."	^(pName = '*data*'		ifTrue: [(self dataSide: side) 				select: [:datum | datum ownerName = cName]]		ifFalse: [(self methodsSide: side) 				select: [:method | method className = cName 					and: [method protocolName = pName]]])		asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-Change Management" selector="methodsSide:remove:">methodsSide: side remove: aMethodDescriptor		(self methodsSide: side) remove: aMethodDescriptor</body><body package="Store-Change Management" selector="newMethods">newMethods	^methods1 asList, methods2 asList</body><body package="Store-Change Management" selector="protocolsSide:forClassNamed:">protocolsSide: side forClassNamed: cName 	"Answer a collection of protocol names (strings)	that are from a class named cName"	| protocols mthds |	protocols := Set new: (self methodsSide: side) size.	mthds := (self methodsSide: side) select: [:method | method classNameWithMeta = cName].	mthds do: [:method| protocols add: method protocolName].	((self dataSide: side) 		detect: [:datum | datum ownerName = cName] 		ifNone: [nil]) notNil ifTrue: [			protocols add: '*data*'].	^protocols asSortedCollection</body><body package="Store-Change Management" selector="reverse">reverse	"Swap pkg1 with pkg2"	| tmp |	tmp := pkg1.	pkg1 := pkg2.	pkg2 := tmp.	tmp := classes1.	classes1 := classes2.	classes2 := tmp.	tmp := meta1.	meta1 := meta2.	meta2 := tmp.	tmp := methods1.	methods1 := methods2.	methods2 := tmp.	tmp := data1.	data1 := data2.	data2 := tmp.</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing</category><body package="Store-Change Management" selector="classesSide:">classesSide: side	^side = 1 		ifTrue: [classes1] 		ifFalse: [classes2]</body><body package="Store-Change Management" selector="classesSide:put:">classesSide: side put: aValue 	side = 1		ifTrue: [classes1 := aValue asOrderedCollection]		ifFalse: [classes2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="dataSide:">dataSide: side	^side = 1 ifTrue: [data1] ifFalse: [data2]</body><body package="Store-Change Management" selector="dataSide:put:">dataSide: side put: aValue 	side = 1		ifTrue: [data1 := aValue asOrderedCollection]		ifFalse: [data2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="hasDifferences">hasDifferences	"*** adapted from 17 November 1994 at 1:35:56 pm by IA (Image Administrator	) in b940919 ***"	"Returns a boolean indicating whether or not some differences were found"	^(self classesSide: 1)	isEmpty not or: [	 (self classesSide: 2) 	isEmpty not or: [	 (self metaSide: 1) 		isEmpty not or: [	 (self metaSide: 2)		isEmpty not or: [	(self nameSpacesSide:  1) isEmpty not or: [	(self nameSpacesSide:  2) isEmpty not or: [	 (self methodsSide: 1) 	isEmpty not or: [	 (self methodsSide: 2) 	isEmpty not or: [	 (self dataSide: 1) 	isEmpty not or: [	 (self dataSide: 2) 	isEmpty not]]]]]]]]]</body><body package="Store-Change Management" selector="itemCount">itemCount	^classes1 size + nameSpaces1 size + methods1 size +  data1 size</body><body package="StoreForGlorpVWUI" selector="makeEmpty">makeEmpty	classes1 := classes2 := meta1 := meta2 := nameSpaces1 := nameSpaces2 := methods1 := methods2 := data1 := data2 := #().</body><body package="Store-Change Management" selector="metaSide:">metaSide: side	^side = 1 ifTrue: [meta1] ifFalse: [meta2]</body><body package="Store-Change Management" selector="metaSide:put:">metaSide: side put: aValue 	side = 1		ifTrue: [meta1 := aValue asOrderedCollection]		ifFalse: [meta2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="methodsSide:">methodsSide: side	^side = 1 ifTrue: [methods1] ifFalse: [methods2]</body><body package="Store-Change Management" selector="methodsSide:put:">methodsSide: side put: aValue 	side = 1		ifTrue: [methods1 := aValue asOrderedCollection]		ifFalse: [methods2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="nameSpacesSide:">nameSpacesSide: side	^side = 1 		ifTrue: [ nameSpaces1 ] 		ifFalse: [ nameSpaces2 ]</body><body package="Store-Change Management" selector="nameSpacesSide:put:">nameSpacesSide: side put: aValue 	side = 1		ifTrue: [nameSpaces1 := aValue asOrderedCollection]		ifFalse: [nameSpaces2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="pkgSide:">pkgSide: side	^side = 1 ifTrue: [pkg1] ifFalse: [pkg2]</body><body package="Store-Change Management" selector="pkgSide:put:">pkgSide: side put: aValue 	side = 1		ifTrue: [pkg1 := aValue]		ifFalse: [pkg2 := aValue]</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>private</category><body package="Store-Change Management" selector="asConflictHolder">asConflictHolder	| baby |	baby := PackageConflicts new.	baby fromDiffHolder: self.	^baby</body><body package="Store-Change Management" selector="cleanUpClassDiffsIn:and:">cleanUpClassDiffsIn: cls1 and: cls2	"Check if classes are really 	different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	cls1 do: 		[:cl1 |		| idx cl2 |		idx := cls2 findFirst: [:cl| cl absoluteName = cl1 absoluteName].		idx isZero 			ifFalse:				[cl2 := cls2 at: idx.				cl2 definitionAndComment = cl1 definitionAndComment					ifTrue: 						[toRemove1 add: cl1.						cls2 removeAtIndex: idx]]].	cls1 removeAll: toRemove1.</body><body package="Store-Change Management" selector="cleanUpDiffs">cleanUpDiffs	"Check if method and classes are really 	different or just came from different sources."	methods1 := methods1 asOrderedCollection.	methods2 := methods2 asOrderedCollection.	self cleanUpSubdefDiffsIn: methods1 and: methods2.	data1 := data1 asOrderedCollection.	data2 := data2 asOrderedCollection.	self cleanUpSubdefDiffsIn: data1 and: data2.	classes1 := classes1 asOrderedCollection.	classes2 := classes2 asOrderedCollection.	self cleanUpClassDiffsIn: classes1 and: classes2.	nameSpaces1 := nameSpaces1 asOrderedCollection.	nameSpaces2 := nameSpaces2 asOrderedCollection.	self cleanUpNameSpaceDiffsIn: nameSpaces1 and: nameSpaces2.</body><body package="Store-Change Management" selector="cleanUpNameSpaceDiffsIn:and:">cleanUpNameSpaceDiffsIn: namespaces1 and: namespaces2	"Check if namespaces are really different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	namespaces1 do: 		[ :ns1 |		| idx ns2 |		idx := namespaces2 findFirst: [ :ns | ns absoluteName = ns1 absoluteName ].		idx isZero 			ifFalse:				[ ns2 := namespaces2 at: idx.				ns2 definitionAndComment = ns1 definitionAndComment					ifTrue: 						[ toRemove1 add: ns1.						namespaces2 removeAtIndex: idx						]				]		].	namespaces1 removeAll: toRemove1.</body><body package="Store-Change Management" selector="cleanUpSubdefDiffsIn:and:">cleanUpSubdefDiffsIn: subdefs1 and: subdefs2	"Check if method/data are really 	different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	subdefs1 do: 		[:m1 | 		| idx m2|		idx := m1 isForData			ifTrue: [ subdefs2 findFirst: [:m | m absoluteName = m1 absoluteName ] ]			ifFalse: 				[ subdefs2 findFirst: 					[ :d | d selector = m1 selector and: 							[ d classNameWithMeta = m1 classNameWithMeta ] 					]				].		idx isZero ifFalse: 			[m2 := subdefs2 at: idx.			(m2 sourceMatches: m1)				ifTrue: 					[toRemove1 add: m1.					subdefs2 removeAtIndex: idx]]].	subdefs1 removeAll: toRemove1.</body><body package="Store-Change Management" selector="combineDiffsFrom:">combineDiffsFrom: aDiffHolder	"Add differences from aDiffHolder into my differences."	1 to: 2 do: 		[ :side | 		self methodsSide: side 			put: ((self methodsSide: side) , (aDiffHolder methodsSide: side)).		self dataSide: side 			put: ((self dataSide: side) , (aDiffHolder dataSide: side)).		self classesSide: side 			put: ((self classesSide: side) , (aDiffHolder classesSide: side)).		self metaSide: side 			put: ((self metaSide: side) , (aDiffHolder metaSide: side)).		self nameSpacesSide: side 			put: ((self nameSpacesSide: side) , (aDiffHolder nameSpacesSide: side))		].	"Remove differences that are in both."	self removeDuplicateDifferencesIn: methods1 and: methods2.	self removeDuplicateDifferencesIn: data1 and: data2.	self removeDuplicateDifferencesIn: classes1 and: classes2.	self removeDuplicateDifferencesIn: meta1 and: meta2.	self removeDuplicateDifferencesIn: nameSpaces1 and: nameSpaces2.</body><body package="Store-Change Management" selector="computeDiffs">computeDiffs		pkg1 computeDiffsBetween: pkg2 into: self. 	pkg2 pseudoPackage ifFalse: [self cleanUpDiffs].</body><body package="Store-Change Management" selector="removeDuplicateDifferencesIn:and:">removeDuplicateDifferencesIn: defs1 and: defs2 	"Remove differences that are in both."	| toRemove |	toRemove := List new.	defs1 do: 		[:each | 		| idx |		(idx := defs2 indexOf: each ifAbsent: [nil]) notNil			ifTrue: 				[defs2 removeAtIndex: idx.				toRemove add: each]].	defs1 removeAll: toRemove</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>change set</category><body package="Store-Change Management" selector="changeSet">changeSet	"Answer a change set reflecting differences between package1 and package2. 	If package2 is currently loaded into an image, this change set reflects changes since	package1."	| cset |	cset := XChangeSet new.	self defClassChanges do:		[ :change | cset doClassChange: change ].	self defNameSpaceChanges do:		[ :change | cset doNameSpaceChange: change ].	self subdefChanges do:		[ :change | cset doSubdefChange: change ].	self propertyChanges do:		[ :change | cset addPropertyChange: change ].	self otherChanges do:		[ :change | cset addOtherChange: change ].	^cset.</body><body package="Store-Change Management" selector="defClassChanges">defClassChanges	"Answer a collection of definition changes for all Classes."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	classes1 do:		[ :cls |  | sym c2 |		sym := cls absoluteName.		( c2 := classes2 detect: [ :c | c comparesTo: cls ] ifNone: nil ) notNil			ifTrue: 				[ cls definition = c2 definition  					ifFalse: [ changes add: ( Change new classSymbol: sym ) change ].				( cls comment string equalsAcrossPlatforms:  c2 comment string )					ifFalse: [ changes add: ( Change new classSymbol: sym ) comment ]				]			ifFalse: 				[ changes add: ( Change new classSymbol: sym ) removeDefinition ].		].	classes2 do:		[ :cls | 		( classes1 contains: [ :c | c comparesTo: cls ] )			ifFalse: 				[ changes add: ( Change new classSymbol: cls absoluteName ) add.				cls comment isEmpty					ifFalse: [ changes add: ( Change new classSymbol: cls absoluteName ) comment ]				].		].	^changes</body><body package="Store-Change Management" selector="defNameSpaceChanges">defNameSpaceChanges	"Answer a collection of definition changes for all NameSpaces."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	nameSpaces1 do:		[ :ns |  | sym n2 |		sym := ns absoluteName.		( n2 := nameSpaces2 detect: [ :c | c comparesTo: ns ] ifNone: nil ) notNil			ifTrue: 				[ ns definition = n2 definition  					ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) change ].				( ns comment string equalsAcrossPlatforms:  n2 comment string )					ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) comment ]				]			ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) removeDefinition ].		].	nameSpaces2 do:		[ :ns | 		( nameSpaces1 contains: [ :c | c comparesTo: ns ] )			ifFalse: 				[ changes add: ( Change new nameSpaceSymbol: ns absoluteName ) add.				ns comment isEmpty					ifFalse: [ changes add: ( Change new nameSpaceSymbol: ns absoluteName ) comment ]				].		].	^changes</body><body package="Store-Change Management" selector="otherChanges">otherChanges	"Answer a collection of 'other' changes. Compare bundle structures"	"The changes should move from pkg1 to pkg2"	pkg1 isBundle		ifFalse: [ ^#() ].	^pkg1 structure = pkg2 structure		ifTrue: [ #() ]		ifFalse: [ BundleModel structureMark ]." nice thought, but not what we need right now		ifFalse: [ Array with: ( BundleStructureChange new component: pkg1 ) ]."</body><body package="Store-Change Management" selector="propertyChanges">propertyChanges	"Answer a collection of 'other' changes. Compare properties."	"The changes should move from pkg1 to pkg2"	| changes props1 props2 |	changes := Set new.	props1 := pkg1 propertiesForFileOut.	props2 := pkg2 propertiesForFileOut.	props1 associationsDo:		[ :assoc |		( props2 includesKey: assoc key )			ifTrue: 				[ ( assoc value = ( props2 at: assoc key ) )					ifFalse: [ changes add: assoc key ]				]			ifFalse: [ changes add: assoc key ].		].	props2 associationsDo:		[ :assoc |		( props1 includesKey: assoc key )			ifTrue: 				[ ( assoc value = ( props1 at: assoc key ) )					ifFalse: [ changes add: assoc key ]				]			ifFalse: [ changes add: assoc key ].		].	^changes asOrderedCollection.</body><body package="Store-Change Management" selector="subdefChanges">subdefChanges	"Answer a collection of subdef changes."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	methods1 do:		[ :meth |  | chg |		chg := Change new classSymbol: meth className; selector: meth selector.		( methods2 includes: meth )			ifTrue: [ chg change ]			ifFalse: [ chg remove ].		changes add: chg.		].	methods2 do:		[ :meth |  | chg |		chg := Change new classSymbol: meth className; selector: meth selector.		( methods1 includes: meth )			ifTrue: [ chg change ]			ifFalse: [ chg add ].		changes add: chg.		].	data1 do:		[ :data |  | chg |		chg := Change new.		data isInClass			ifTrue: [ chg classSymbol: data ownerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: data ownerName asSymbol ].		chg dataKey: data dataKey.		( data2 includes: data )			ifTrue: [ chg change ]			ifFalse: [ chg remove ].		changes add: chg.		].	data2 do:		[ :data |  | chg |		chg := Change new.		data isInClass			ifTrue: [ chg classSymbol: data ownerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: data ownerName asSymbol ].		chg dataKey: data dataKey.		( data1 includes: data )			ifTrue: [ chg change ]			ifFalse: [ chg add ].		changes add: chg.		].	^changes</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing-merge tool</category><body package="Store-Change Management" selector="modifiedClassComment">modifiedClassComment	"Answer a collection of classes that have modified comment."	|coll class2|	coll := List new.	classes1 do: 		[:each | 		class2 := classes2 			detect: [ :cl2 | cl2 name = each name ] ifNone: [ nil ].		( class2 isNil or: [ each comment ~= class2 comment ] )			ifTrue: [coll add: each]].	^coll</body><body package="Store-Change Management" selector="modifiedClassDefinitions">modifiedClassDefinitions	"Answer a collection of classes that have modified definition."	| coll class2 |	coll := List new.	classes1 do: 		[ :each | 		class2 := classes2 			detect: [:cl2 | cl2 name = each name ] ifNone: [ nil ].		(class2 isNil or: [ each definition ~= class2 definition ] )				ifTrue: [ coll add: each ]		]." we don't do metaclasses no more ....	meta1		do: 			[:each | 			class2 := meta2 detect: [:cl2 | cl2 name = each name]						ifNone: [nil].			(class2 isNil or: [each definition ~= class2 definition])				ifTrue: [coll add: each]]."	^coll</body><body package="Store-Change Management" selector="modifiedData">modifiedData	"Added by Philippe F. Monnet of Andersen Consulting 	New data definitions."	| modified byClass |	modified := Dictionary new.	data1 		do: 			[:each | 			byClass := modified at: each className ifAbsent: [Set new].			byClass add: each.			modified at: each className put: byClass].	^modified</body><body package="Store-Change Management" selector="modifiedMethods">modifiedMethods	"New method definitions."	| modified byClass byProtocol |	modified := Dictionary new.	methods1		do: 			[:each | 			byClass := modified at: each className ifAbsent: [Dictionary new].			byProtocol := byClass at: each protocolName ifAbsent: [Set new].			byProtocol add: each.			byClass at: each protocolName put: byProtocol.			modified at: each className put: byClass].	^modified</body><body package="Store-Change Management" selector="modifiedNameSpaceComment">modifiedNameSpaceComment	"Answer a collection of namespaces that have modified comment."	|coll namespace2|	coll := List new.	nameSpaces1 do: 		[:each | 		namespace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName ] ifNone: [ nil ].		( namespace2 isNil or: [ each comment ~= namespace2 comment ] )			ifTrue: [coll add: each]].	^coll</body><body package="Store-Change Management" selector="modifiedNameSpaceDefinitions">modifiedNameSpaceDefinitions	"Answer a collection of namespaces that have modified definitions."	| coll namespace2 |	coll := List new.	nameSpaces1 do: 		[ :each | 		namespace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName ] ifNone: [ nil ].		( namespace2 isNil or: [ each definition ~= namespace2 definition ] )				ifTrue: [ coll add: each ]		].	^coll</body><body package="Store-Change Management" selector="modifiedProperties">modifiedProperties	"Answer a collection of property symbols that have been modified."	| coll  |	coll := Set new.	pkg1 propertiesForSave keys asOrderedCollection, 		pkg2 propertiesForSave keys asOrderedCollection do:		[ :prop |		( ( pkg1 propertyAt: prop ifAbsent: nil ) = ( pkg2 propertyAt: prop ifAbsent: nil ) )			ifFalse: [ coll add: prop ].		].	^coll asOrderedCollection asList</body><body package="Store-Change Management" selector="modifiedStructures">modifiedStructures	"Answer a collection of bundles whose structure has changed."	| list |	list := OrderedCollection new.	pkg1 isBundle		ifFalse: [ ^list ].	pkg1 structure = pkg2 structure		ifFalse: [ list add: pkg1 ].	^list</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing - loader</category><body package="Atomic Compiling and Loading" selector="classesToLoad">classesToLoad		^classes1</body><body package="Atomic Compiling and Loading" selector="dataToLoad">dataToLoad	^data1</body><body package="Atomic Compiling and Loading" selector="methodsToLoad">methodsToLoad	^methods1</body><body package="Atomic Compiling and Loading" selector="nameSpacesToLoad">nameSpacesToLoad		^nameSpaces1</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>glorp faking</category><body package="StoreForGlorpVWUI" selector="mainPackageClasses:">mainPackageClasses: aCollection	self classesSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI" selector="mainPackageMethods:">mainPackageMethods: aCollection	self methodsSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI" selector="mainPackageNamespaces:">mainPackageNamespaces: aCollection	self nameSpacesSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI" selector="mainPackageShareds:">mainPackageShareds: aCollection	self dataSide: 1 put: aCollection</body><body package="StoreForGlorpVWUI" selector="otherPackageClasses:">otherPackageClasses: aCollection	self classesSide: 2 put: aCollection</body><body package="StoreForGlorpVWUI" selector="otherPackageMethods:">otherPackageMethods: aCollection	self methodsSide: 2 put: aCollection</body><body package="StoreForGlorpVWUI" selector="otherPackageNamespaces:">otherPackageNamespaces: aCollection	self nameSpacesSide: 2 put: aCollection</body><body package="StoreForGlorpVWUI" selector="otherPackageShareds:">otherPackageShareds: aCollection	self dataSide: 2 put: aCollection</body></methods><methods><class-id>Store.PackageDifferences class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="with:with:">with: pkg1 with: pkg2	^(self new) pkgSide: 1 put: pkg1; pkgSide: 2 put: pkg2; computeDiffs; yourself</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^false</body><body package="Store-Merge Management" selector="isCommentResolver">isCommentResolver	^true</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	| nameSpace |	proposed ifNil: [^false].	proposed isRemovalResolution ifFalse: [^false].	nameSpace := self longOwnerName asQualifiedReference valueOrDo: [^true].	^((Registry containingPackageForNameSpace: nameSpace) name = proposed package name) not</body><body package="Store-Merge Management" selector="sameDefinitionAs:">sameDefinitionAs: aString	| reference |	(reference := self ownerName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value comment = aString</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	"Make sure we don't apply the text, just the text asString"	| class result |	applyable ifFalse: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isAbsentResolution ifTrue: [^true].	proposed isNoOpResolution ifTrue: [^true].	class := self longOwnerName asQualifiedReference valueOrDo: 		[Transcript show: (#nFailedChangeCommentOnNS1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Failed when trying to change comment on a removed NameSpace : &lt;1s&gt;&lt;n&gt;' expandMacrosWith: ownerName).		^false].	self hasOverrideAndShouldApply ifFalse: [^false].	result := [class comment: proposed value asString]		on: Error		do: 			[:exception | 			Transcript show: (#nApplyingRemovalCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: nil].	^result notNil</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	| nameSpace result |	nameSpace := self longOwnerName asQualifiedReference valueOrDo: [^true].	result := [nameSpace comment: '']		on: Error		do:			[:exception | 			Transcript show: (#nApplyingRemovalCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: #failed].	^result ~= #failed</body><body package="Store-Merge Management" selector="existingOverrides">existingOverrides	^(Override overridesForClassOrNameSpace: (self longOwnerName asStrictReference valueOrDo: [^#()])) ifNil: [^#()]</body><body package="Store-Merge Management" selector="hasOverrideAndShouldApply">hasOverrideAndShouldApply		self potentialOverride ifNotNil:		[:value | 		value name = proposed key name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed key name) ifFalse: 				[Transcript show: (#nDidNotApplyCommentChangeToNameSpace1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply comment change to NameSpace &lt;1s&gt;' expandMacrosWith: self longOwnerName).				^false]]].	^true</body><body package="Store-Merge Management" selector="potentialOverride">potentialOverride	^Store.Registry containingPackageForNameSpaceSymbol: self longOwnerName asSymbol</body><body package="Store-Merge Management" selector="proceedWithPossibleOverrideFrom:to:">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingLoss1sn2sOverideNS3snn &lt;&lt; #store &gt;&gt; 'Applying this change may cause a loss of information because &lt;n&gt;NameSpace "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;may later be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longOwnerName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="parseText:">parseText: aString		^aString notNil</body></methods><methods><class-id>Store.Glorp.NamespaceCommentChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management" selector="listIcon">listIcon	^NameSpace toolListIcon</body><body package="Store-Merge Management" selector="longListName">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="longOwnerName">longOwnerName	| name |	name := self ownerName.	(name includes: $.) ifTrue: 		[^('Root.*' match: name)			ifTrue: [name]			ifFalse: ['Root.', name]].	^'Root.Smalltalk.' , name</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName		^(#BracketNameSpaceCommentBracket &lt;&lt; #store &gt;&gt; '[NameSpace Comment]') asString</body><body package="Store-Merge Management" selector="shortListName">shortListName	| string |	string := self ownerName, ' ' , self shortTreeName.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.WasConvertedFromParcelWithUndeclaredError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog		warn: (#_1sWasConvertedFroIthUninstalledCode &lt;&lt; #store &gt;&gt; '&lt;1s&gt; was converted from a Parcel with uninstalled code.' expandMacrosWith: messageText).	^false</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinition</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="method">method	"Answer the method referenced by the receiver, or nil if none."	^(self implementingClass isForClassOrExtension	and: [self implementingClass includesSelector: self selector])		ifTrue: [self implementingClass compiledMethodAt: self selector]		ifFalse: [nil]</body><body package="StoreForGlorpBrowserUI" selector="name">name	^selector asString</body><body package="StoreForGlorpBrowserUI" selector="protocol">protocol	"Answer the protocol for the receiver's method definition."	^self implementingClass organization categoryOfItem: self selector asSymbol</body></methods><methods><class-id>Store.Glorp.StoreMethodDefinition</class-id> <category>icons</category><body package="StoreForGlorpBrowserUI" selector="toolListIcon">toolListIcon	"None of the icons is computable based on what a text only code representation immediately offers us."	^nil</body></methods><methods><class-id>Store.ReplaceModifiedPackageNotice</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		^(Dialog		choose:			(#ImagePackage1sWasTWithANewVersion &lt;&lt; #store &gt;&gt; 'Image package &lt;1s&gt; was modified.&lt;n&gt;Replace it with a new version?' expandMacrosWith: messageText)		labels: (Array with: (#Replace &lt;&lt; #store &gt;&gt; 'Replace') asString with: (#Cancel &lt;&lt; #store &gt;&gt; 'Cancel') asString)		values: #(#replace #cancel)		default: #replace) = #replace</body></methods><methods><class-id>Store.ReplaceModifiedPackageNotice class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>aspects</category><body package="Store-Merge Management" selector="mergeList">mergeList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mergeList isNil		ifTrue:			[mergeList := MultiSelectionInList new]		ifFalse:			[mergeList]</body><body package="Store-Merge Management" selector="pundleList">pundleList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleList isNil		ifTrue:			[pundleList := SelectionInTree new]		ifFalse:			[pundleList]</body><body package="Store-Merge Management" selector="pundleVersions">pundleVersions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleVersions isNil		ifTrue:			[pundleVersions := MultiSelectionInList new]		ifFalse:			[pundleVersions]</body><body package="Store-Merge Management" selector="pundles">pundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleList isNil		ifTrue:			[pundleList := SelectionInTree new]		ifFalse:			[pundleList]</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>interface opening</category><body package="Store-Merge Management" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #VersionList) displayStringSelector: #mergeDisplayString.</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>private</category><body package="Store-Merge Management" selector="buttonEnablement">buttonEnablement	(builder componentAt: #AcceptButton) widget isEnabled: mergeList list isNotEmpty</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>actions</category><body package="Store-Merge Management" selector="accept">accept	| items |	items := mergeList list asArray.	self closeRequest.	[(Delay forMilliseconds: 250) wait.	[mergeTool mergeSelectedPundleVersions: items] uiEventFor: mergeTool builder window.] fork.</body><body package="Store-Merge Management" selector="add">add	| mergeSet |	mergeSet := mergeList list asSet.	mergeSet addAll: pundleVersions selections.	mergeList list: (SortedCollection withAll: mergeSet sortBlock: [:a :b | a displayString &gt;= b displayString]) asList.	self buttonEnablement.</body><body package="Store-Merge Management" selector="remove">remove	mergeList list removeAll: mergeList selections.	self buttonEnablement.</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>accessing</category><body package="Store-Merge Management" selector="mergeTool:">mergeTool: anObject	mergeTool := anObject</body><body package="Store-Merge Management" selector="storeRegistry">storeRegistry	^#{Store.Registry} valueOrDo: [nil]</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	super initialize.	self pundleList list: (TreeModel 		on: (Refactory.Browser.PackageListRoot environment: Refactory.Browser.BrowserEnvironment new)		displayRoot: false		childrenWith: [:each | each children]).	self pundleList selectionIndexHolder onChangeSend: #pundleSelected to: self.</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector</class-id> <category>selecting</category><body package="Store-Merge Management" selector="pundleSelected">pundleSelected		| pundleModel list |	Store.DbRegistry connection notNil ifFalse: [^self].	pundleModel := self pundleList selection ifNotNil: #codeComponent.	list := pundleModel isNil		ifTrue: [List new]		ifFalse: [(pundleModel storeVersionsIn: mergeTool databaseSession) asList].	self pundleVersions list: list</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="openOn:">openOn: aMergeTool	| me |	me := self new.	me mergeTool: aMergeTool.	me open.</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject 	"Answer true if anObject could be another version of the receiver.	Update to compare this property key, (ie., name) with that of the other."	(self objectIsForSelf: anObject) ifFalse: [^false].	^anObject property = self property</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForProperty</body><body package="Store-DB-Records" selector="property">property	"To be consistent with PropertyTag semantics and for other reasons,	this method serves as an accessor to the corresponding property name,	i.e., the key in the a Pundle's properties dictionary."	^self name</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="containingBundles">containingBundles	^[( Properties bundlesContainingProperty: self primaryKey )		collect: [ :id | Bundle aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body><body package="Store-DB-Records" selector="containingPackages">containingPackages	^[( Properties packagesContainingProperty: self primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body><body package="Store-DB-Records" selector="definitionRecord">definitionRecord	"Create a new record in the database that holds the property object."	^self class definitionClass fromBinData: self definitionObject</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="displayString">displayString	^self name</body><body package="Store-DB-Records" selector="printOn:">printOn: aStream	aStream nextPutAll: 'Property{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>testing</category><body package="Store-DB-Records" selector="isForProperty">isForProperty			^true</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="definition">definition	"Overridden to behave like the original Property Dictionary, which doesn't process the property."	^self definitionObject</body><body package="Store-DB-Records" selector="definitionObject">definitionObject	"Return the property value."	^self definitionStr</body><body package="Store-DB-Records" selector="definitionObject:">definitionObject: aPropertyValue	"Return the property value."	^self definitionStr: aPropertyValue</body><body package="Store-DB-Records" selector="searchString">searchString	^searchString</body><body package="Store-DB-Records" selector="searchString:">searchString: anObject	searchString := anObject</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="getDefinitionID:">getDefinitionID: anID 	"This method is ultimately called for commentStr and definitionStr.	Superclass implementation thinks the types are always string-based.	But definitionStr is binary (un-BOSSed object), so we must override."	| record def |	def := (record := self getDefinitionRecordID: anID) notNil 				ifTrue: 					[record isData ifTrue: [record binData] ifFalse: [record definition]]				ifFalse: [def := String new].	^def</body><body package="Store-DB-Records" selector="prepareInstallation">prepareInstallation	"Create first records for both definition object and comment string."	self definitionID == nil 		ifTrue: [self definitionID: (self class definitionClass fromBinData: self definitionObject) primaryKey].	self commentID == nil 		ifTrue: [self commentID: (self class definitionClass fromString: commentStr) primaryKey]</body><body package="Store-DB-Records" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	commentStr notNil 		ifTrue: [self commentStr: (self processString: self commentStr)]</body></methods><methods><class-id>Store.PropertyRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="associationClass">associationClass	^Properties</body><body package="Store-DB-Records" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_PropertyName' #('name'))		#('ST_PropertyTimestamp' #('timeStamp'))		#('ST_PropertyDefinition' #('definitionID'))		#('ST_PropertySearch' #('searchString'))		#('ST_PropertyGCSupport' #('trace'))		)</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn	^#propertyRef</body><body package="Store-DB-Records" selector="searchStringFrom:">searchStringFrom: anObject	"Return a search string for anObject, or empty string.  To prevent db encoding complaints, convert to ascii, or use empty string."	| aString bytes |	^(anObject isKindOf: String)		ifTrue:			[| max |			max := (self brokerOrNil ifNil: [SQLBroker]) maxPropertySearchStringSize.			aString := anObject copyFrom: 1 to: (max min: anObject size).			bytes := [aString asByteArrayEncoding: #ascii]						on: Error do: [:ex | ex return: #[]].			bytes asString]		ifFalse: ['']</body></methods><methods><class-id>Store.PropertyRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="from:timeStamp:trace:">from: prop timeStamp: timeStamp trace: oldDB	| env |	env := nil. ":= prop environment."	^self new		name: prop name asString;		timeStamp: timeStamp;		environmentString: ( env == nil ifTrue: [ '' ] ifFalse: [ env absoluteName ] );		definitionObject:  prop definitionObject;		commentStr: prop comment;		searchString: prop searchString;		setTrace: oldDB;		yourself.</body><body package="Store-DB-Records" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord 	super moveFieldsFrom: aView to: aDBRecord.	aDBRecord searchString: aView searchString</body><body package="Store-DB-Records" selector="newName:definition:">newName: aName definition: aPropertyValue 	"Create a new property record from name and definition."	| rec |	rec := self new.	rec name: aName.	rec definitionObject: aPropertyValue.	rec searchString: (self searchStringFrom: aPropertyValue).	^rec</body></methods><methods><class-id>Store.PropertyRecord class</class-id> <category>private</category><body package="Store-DB-Records" selector="newOrExistingFrom:trace:">newOrExistingFrom: aProperty trace: aPropertyRecord	"Answer an instance of the receiver, if a trace is the same as an object answer the trace class.	If either definition or comment for a trace class is the same reuse it."		| instance |	instance := self		from: aProperty		timeStamp: self timeStamp		trace: aPropertyRecord.	aPropertyRecord definitionObject = instance definitionObject ifTrue: 		[instance definitionID: aPropertyRecord definitionID].	aPropertyRecord commentStr string = instance commentStr string ifTrue: 		[instance commentID: aPropertyRecord commentID].	^(instance commentID = aPropertyRecord commentID and: [instance definitionID = aPropertyRecord definitionID])		ifTrue: [aPropertyRecord]		ifFalse:			[instance install.			instance]</body></methods><methods><class-id>Store.PropertyRecord class</class-id> <category>db-accessing</category><body package="Store-DB-Records" selector="allVersionsNamed:">allVersionsNamed: aName 	"Given a name of a Property answer a collection of all versions of that property in the database.	PropertyRecord allVersionsNamed: 'Smalltalk'"	| versions |	versions := self 		executeSQL: ((self newSQL)			selectAll;			where;			column: #name equalTo: aName asString printString)		onError: [self table select: [:each | each name = aName asString]].	^versions asSortedCollection: [:each :other | each timeStamp &gt; other timeStamp]</body></methods><methods><class-id>Store.Glorp.StoreCodeModel</class-id> <category>navigator accessing</category><body package="StoreForGlorpBrowserUI" selector="binding">binding	^self state ifNotNil: #binding</body><body package="StoreForGlorpBrowserUI" selector="navigatorStateClass">navigatorStateClass	^StoreForGlorpNavigatorState</body><body package="StoreForGlorpBrowserUI" selector="selector">selector	"A selector from StoreForGlorpNavigatorState is always a String"	^self state ifNotNil: [:object | object selector ifNotNil: [:value | value asSymbol]]</body></methods><methods><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="iconFor:">iconFor: aMethodCategory	^nil</body></methods><methods><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="showIcons">showIcons		^false</body></methods><methods><class-id>Store.Glorp.StoreSelectorProtocolNavigatorPart</class-id> <category>private-selectors</category><body package="StoreForGlorpBrowserUI" selector="allMethodDefinitionsFor:in:">allMethodDefinitionsFor: aProtocol in: class	| selectors |	selectors := OrderedCollection new.	self inheritedClassesOf: class		do: 			[:each |			selectors				addAll: ((navigator environment selectorsFor: aProtocol in: each) collect: 							[:eachSelector |							StoreMethodDefinition 								class: class 								implementor: each 								selector: eachSelector])].	^selectors</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>aspects</category><body package="Store-UI" selector="fromVersionLabel">fromVersionLabel	^self printText: from</body><body package="Store-UI" selector="swapButton">swapButton	| button |	button := ClickableGraphic new.	button		idleGraphic: ComparisonIcons swapFileoutDirection;		mouseOverGraphic: ComparisonIcons swapFileoutDirectionActive;		mouseDownGraphic: ComparisonIcons swapFileoutDirectionPressed.	button		tooltip: #FileoutDialogSwapButtonTooltip				&gt;&gt; 'Toggle direction of the fileout (switch from with to).' &lt;&lt; #IDE.	button when: Clicked send: #swap to: self.	^button</body><body package="Store-UI" selector="toVersionLabel">toVersionLabel	^self printText: to</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>private</category><body package="Store-UI" selector="computePreferredWidth">computePreferredWidth	^50 + ((Label with: (self printText: from)) width				max: (Label with: (self printText: to)) width)		+ 10 + 35		max: 280</body><body package="Store-UI" selector="printText:">printText: aStorePundleObject	| versionString |	versionString := aStorePundleObject isImageModel		ifTrue: [aStorePundleObject traceVersion]		ifFalse: [aStorePundleObject version].	^versionString asText allBold</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="fixAnnotationLabels">fixAnnotationLabels	(self widgetAt: #FromLabel) label text emphasizeAllWith: nil.	(self widgetAt: #ToLabel) label text emphasizeAllWith: nil</body><body package="Store-UI" selector="interfaceSpecFor:">interfaceSpecFor: aSymbol	| spec |	spec := super interfaceSpecFor: aSymbol.	spec window bounds: (Point zero				corner: self computePreferredWidth @ spec window bounds height).	^spec</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self fixAnnotationLabels</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>accessing</category><body package="Store-UI" selector="from">from	^from</body><body package="Store-UI" selector="from:">from: anObject	from := anObject</body><body package="Store-UI" selector="to">to	^to</body><body package="Store-UI" selector="to:">to: anObject	to := anObject</body></methods><methods><class-id>Store.FileoutDifferencesDialog</class-id> <category>actions</category><body package="Store-UI" selector="swap">swap	| swap |	swap := from.	from := to.	to := swap.	(self widgetAt: #fromVersionLabel) labelString: (self printText: from).	(self widgetAt: #toVersionLabel) labelString: (self printText: to)</body></methods><methods><class-id>Store.FileoutDifferencesDialog class</class-id> <category>instance creation</category><body package="Store-UI" selector="from:to:">from: anOriginal to: aTarget	^(self new)		from: anOriginal;		to: aTarget;		yourself</body></methods><methods><class-id>Store.DeletionToolFilter</class-id> <category>accessing</category><body package="Store-UI" selector="afterDate">afterDate	^afterDate</body><body package="Store-UI" selector="afterDate:">afterDate: aDate	afterDate := aDate</body><body package="Store-UI" selector="beforeDate">beforeDate	^beforeDate</body><body package="Store-UI" selector="beforeDate:">beforeDate: aDate	beforeDate := aDate</body><body package="Store-UI" selector="blessingGreater">blessingGreater	^blessingGreater</body><body package="Store-UI" selector="blessingGreater:">blessingGreater: anInteger	blessingGreater := anInteger</body><body package="Store-UI" selector="blessingLess">blessingLess	^blessingLess</body><body package="Store-UI" selector="blessingLess:">blessingLess: anInteger	blessingLess := anInteger</body><body package="Store-UI" selector="pundleName">pundleName	^pundleName</body><body package="Store-UI" selector="pundleName:">pundleName: aString	pundleName := aString</body><body package="Store-UI" selector="versionLike">versionLike	^versionLike</body><body package="Store-UI" selector="versionLike:">versionLike: aString	versionLike := aString</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableProtocolNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="fillInListFor:">fillInListFor: aNavigatorState		| classes protocols |	classes := aNavigatorState classesAndNameSpaces.	(classes size = 1 and: [aNavigatorState pundles notEmpty])		ifTrue:			[protocols := Set new.			self 				inheritedClassesOf: classes asArray first 				do: [:each | protocols addAll: (self environment sharedVariableProtocolsFor: each)]]		ifFalse: [protocols := #()].	self updateListWith: protocols</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="changedMethodsSharedAndProperties">changedMethodsSharedAndProperties	"We call classPseudoDifferences, which answers a definition and comment without regard to if they are different"	^self classPseudoDifferences , self sharedAndMethodDifferences.</body><body package="Store-Difference Management" selector="classListIcon">classListIcon	^Class toolListIcon</body><body package="Store-Difference Management" selector="classListName">classListName	^mainObject isNil 		ifTrue: 			[otherObject isNil				ifTrue: 					[self methodDifferences isEmpty						ifTrue: [self sharedDifferences first classListName]						ifFalse: [self methodDifferences first classListName]]				ifFalse: [otherObject longNameFromSmalltalk]]		ifFalse: [mainObject longNameFromSmalltalk]</body><body package="Store-Difference Management" selector="classPseudoDifferences">classPseudoDifferences		| pseudoDefinition pseudoComment |	pseudoDefinition := PseudoClassDefinitionDifference new.	pseudoDefinition mainPackage: mainPackage definition: self definitionForMainClass.	pseudoDefinition otherPackage: otherPackage definition: (self otherObject ifNotNil: [:value | value definitionString]).	pseudoComment := PseudoClassCommentDifference new.	pseudoComment mainPackage: mainPackage comment: self commentForMainClass.	pseudoComment otherPackage: otherPackage comment: self commentForOtherClass.	^OrderedCollection with: pseudoDefinition with: pseudoComment</body><body package="Store-Difference Management" selector="commentForMainClass">commentForMainClass		^self mainObject ifNotNil: 		[:value | 		value isImageObject 			ifTrue: [(mainPackage definesClassOrNameSpace: value) ifTrue: [value comment]]			ifFalse: 				[| comment |				comment := value comment.				comment asString = ((#CommentNotVisible &lt;&lt; #store &gt;&gt; 'Comment not visible') asString) ifTrue: [nil] ifFalse: [comment]]]</body><body package="Store-Difference Management" selector="commentForOtherClass">commentForOtherClass		^self otherObject ifNotNil: 		[:value | 		| comment |		comment := value comment.		comment asString = ((#CommentNotVisible &lt;&lt; #store &gt;&gt; 'Comment not visible') asString) ifTrue: [nil] ifFalse: [comment]]</body><body package="Store-Difference Management" selector="definitionForMainClass">definitionForMainClass		^self mainObject ifNotNil: 		[:value | 		value isImageObject 			ifTrue: [(mainPackage definesClassOrNameSpace: value) ifTrue: [value definitionString]]			ifFalse: [value definitionString]]</body><body package="Store-Difference Management" selector="definitionForOtherClass">definitionForOtherClass		^self otherObject ifNotNil: 		[:value | 		value isImageObject 			ifTrue: [(otherPackage definesClassOrNameSpace: value) ifTrue: [value definitionString]]			ifFalse: [value definitionString]]</body><body package="Store-Difference Management" selector="mainClass">mainClass	^self mainNonImageObject ifNil:		[(self methodDifferences 			detect: [:each | each mainObject notNil and: [each mainObject owner notNil]]			ifNone: [nil]) ifNotNil: [:value | value mainObject owner nonMeta asStoreClassDefinition]]</body><body package="Store-Difference Management" selector="mainClassLongName">mainClassLongName	mainObject ifNotNil: [^mainObject longName].	self methodDifferences notEmpty ifTrue:		[self sampleMainMethodDifference ifNotNil: [:value | ^value mainObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[self sampleMainSharedDifference ifNotNil: [:value | ^value mainObject classNameWithoutMeta]].	^''</body><body package="Store-Difference Management" selector="mainClassStoreObject">mainClassStoreObject	| targetObject |	self mainNonImageObject ifNotNil: [^mainObject].	self methodDifferences notEmpty ifTrue:		[targetObject := self sampleMainMethodDifference.		^targetObject ifNotNil: [targetObject mainPackage objectNamed: targetObject mainObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleMainSharedDifference.		^targetObject mainPackage objectNamed: targetObject mainObject classNameWithoutMeta].	^nil</body><body package="Store-Difference Management" selector="mainNonImageObject">mainNonImageObject	^mainObject ifNotNil: [mainObject isImageObject ifTrue: [nil] ifFalse: [mainObject]]</body><body package="Store-Difference Management" selector="mainPackage:class:">mainPackage: aPackage class: aStoreClassDefinition	self mainPackage: aPackage object: aStoreClassDefinition</body><body package="Store-Difference Management" selector="mainPackage:method:">mainPackage: aPackage method: aStoreMethod	| newMethodDifference targetDifference |	newMethodDifference := PseudoMethodDifference mainPackage: aPackage method: aStoreMethod.	targetDifference := self methodDifferences 		detect: 			[:each | 			each isMeta = newMethodDifference isMeta and: [each selectorListName = newMethodDifference selectorListName]]		ifNone: [nil].	targetDifference isNil		ifTrue: [self methodDifferences add: newMethodDifference]		ifFalse: [targetDifference mainPackage: aPackage method: aStoreMethod]</body><body package="Store-Difference Management" selector="mainPackage:shared:">mainPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference mainPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference mainPackage: aPackage shared: aStoreSharedVariable]</body><body package="Store-Difference Management" selector="methodDifferences">methodDifferences	methodDifferences ifNil: [methodDifferences := OrderedCollection new].	^methodDifferences</body><body package="Store-Difference Management" selector="modifiedClassPseudoDifferences">modifiedClassPseudoDifferences	| pseudoDefinition pseudoComment trueDifferences otherDefinition |	trueDifferences := OrderedCollection new: 2.	self definitionForMainClass = (otherDefinition := self otherObject ifNotNil: [:value | value definitionString]) ifFalse:		[pseudoDefinition := PseudoClassDefinitionDifference new.		pseudoDefinition mainPackage: mainPackage definition: self definitionForMainClass.		pseudoDefinition otherPackage: otherPackage definition: otherDefinition.		trueDifferences add: pseudoDefinition].	self commentForMainClass = self commentForOtherClass ifFalse:		[pseudoComment := PseudoClassCommentDifference new.		pseudoComment mainPackage: mainPackage comment: self commentForMainClass.		pseudoComment otherPackage: otherPackage comment: self commentForOtherClass.		trueDifferences add: pseudoComment].	^trueDifferences</body><body package="Store-Difference Management" selector="modifiedMethodsSharedAndProperties">modifiedMethodsSharedAndProperties	"Answer the truly modified differences."	^self modifiedClassPseudoDifferences , self sharedAndMethodDifferences.</body><body package="Store-Difference Management" selector="otherClass">otherClass	^otherObject ifNil:		[(self methodDifferences 			detect: [:each | each otherObject notNil and: [each otherObject owner notNil]]			ifNone: [nil]) ifNotNil: [:value | value otherObject owner nonMeta asStoreClassDefinition]]</body><body package="Store-Difference Management" selector="otherClassLongName">otherClassLongName	otherObject ifNotNil: [^otherObject longName].	self methodDifferences notEmpty ifTrue:		[self sampleOtherMethodDifference ifNotNil: [:value | ^value otherObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[self sampleOtherSharedDifference ifNotNil: [:value | ^value otherObject classNameWithoutMeta]].	^''</body><body package="Store-Difference Management" selector="otherClassStoreObject">otherClassStoreObject	| targetObject |	otherObject ifNotNil: [^otherObject].	self methodDifferences notEmpty ifTrue:		[targetObject := self sampleOtherMethodDifference.		targetObject ifNotNil: [^targetObject otherPackage objectNamed: targetObject otherObject classNameWithoutMeta]].	self sharedDifferences notEmpty ifTrue:		[targetObject := self sampleOtherSharedDifference.		targetObject ifNotNil: [^targetObject otherPackage objectNamed: targetObject otherObject classNameWithoutMeta]].	^nil</body><body package="Store-Difference Management" selector="otherPackage:class:">otherPackage: aPackage class: aStoreClassDefinition	self otherPackage: aPackage object: aStoreClassDefinition</body><body package="Store-Difference Management" selector="otherPackage:method:">otherPackage: aPackage method: aStoreMethod	| newMethodDifference targetDifference |	newMethodDifference := PseudoMethodDifference otherPackage: aPackage method: aStoreMethod.	targetDifference := self methodDifferences 		detect: 			[:each | 			each isMeta = newMethodDifference isMeta and: [each selectorListName = newMethodDifference selectorListName]]		ifNone: [nil].	targetDifference isNil		ifTrue: [self methodDifferences add: newMethodDifference]		ifFalse: [targetDifference otherPackage: aPackage method: aStoreMethod]</body><body package="Store-Difference Management" selector="otherPackage:shared:">otherPackage: aPackage shared: aStoreSharedVariable	| newSharedDifference targetDifference |	newSharedDifference := PseudoSharedDifference otherPackage: aPackage shared: aStoreSharedVariable.	targetDifference := self sharedDifferences 		detect: 			[:each | 			each selectorListName = newSharedDifference selectorListName]		ifNone: [nil].	targetDifference isNil		ifTrue: [self sharedDifferences add: newSharedDifference]		ifFalse: [targetDifference otherPackage: aPackage shared: aStoreSharedVariable].	otherPackage ifNil: [otherPackage := aPackage].</body><body package="Store-Difference Management" selector="referencesHolderClass">referencesHolderClass 	^ClassResolutions</body><body package="Store-Difference Management" selector="sampleMainMethodDifference">sampleMainMethodDifference		^self methodDifferences detect: [:each | each mainObject notNil] ifNone: [nil]</body><body package="Store-Difference Management" selector="sampleMainSharedDifference">sampleMainSharedDifference		^self sharedDifferences detect: [:each | each mainObject notNil] ifNone: [nil]</body><body package="Store-Difference Management" selector="sampleOtherMethodDifference">sampleOtherMethodDifference		^self methodDifferences detect: [:each | each otherObject notNil] ifNone: [nil]</body><body package="Store-Difference Management" selector="sampleOtherSharedDifference">sampleOtherSharedDifference		^self sharedDifferences detect: [:each | each otherObject notNil] ifNone: [nil]</body><body package="Store-Difference Management" selector="sharedDifferences">sharedDifferences	sharedDifferences ifNil: [sharedDifferences := OrderedCollection new].	^sharedDifferences</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="hasBothDefinitions">hasBothDefinitions	^(mainObject isNil and: [otherObject isNil])		ifTrue: [self sharedDifferences, self methodDifferences anySatisfy: [:each | each hasBothDefinitions]]		ifFalse: [super hasBothDefinitions]</body><body package="Store-Difference Management" selector="hasMainDifferences">hasMainDifferences		self mainClass ifNotNil: [^true].	self sampleMainMethodDifference ifNotNil: [^true].	self sampleMainSharedDifference ifNotNil: [^true].	^false</body><body package="Store-Difference Management" selector="hasOtherDifferences">hasOtherDifferences		self otherClass ifNotNil: [^true].	self sampleOtherMethodDifference ifNotNil: [^true].	self sampleOtherSharedDifference ifNotNil: [^true].	^false</body><body package="Store-Difference Management" selector="isClass">isClass	^true</body><body package="Store-Difference Management" selector="isClassExtension">isClassExtension	^(self isMainDefinedInPackage or: [self isOtherDefinedInPackage]) not</body><body package="Store-Difference Management" selector="isMainDefinedInPackage">isMainDefinedInPackage	mainPackage ifNil: [^false].	mainPackage isImageModel ifTrue: 		[ | imageObject |		imageObject := self mainClassStoreObject isImageObject			ifTrue: [self mainClassStoreObject]			ifFalse: [self mainClassStoreObject correspondingImageClass].		imageObject  ifNil: [^false].		^mainPackage definesClass: imageObject].	^mainPackage definesClass: (self mainClassStoreObject ifNil: [^false]).</body><body package="Store-Difference Management" selector="isOtherDefinedInPackage">isOtherDefinedInPackage	otherPackage ifNil: [^false].	^otherPackage definesClass: (self otherClassStoreObject ifNil: [^false])</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>printing</category><body package="Store-Difference Management" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: self classListName;		nextPut: $)</body></methods><methods><class-id>Store.PseudoClassDifference</class-id> <category>private</category><body package="Store-Difference Management" selector="sharedAndMethodDifferences">sharedAndMethodDifferences	^(self sharedDifferences collect: [:each | each selectorListName -&gt; each]),		(self methodDifferences collect: [:each | each selectorListName -&gt; each])			asSortedCollection collect: [:each | each value]</body></methods><methods><class-id>Store.PseudoClassDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:class:">mainPackage: aPackage class: aStoreClassDefinition	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: aStoreClassDefinition;		yourself</body><body package="Store-Difference Management" selector="otherPackage:class:">otherPackage: aPackage class: aStoreClassDefinition	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: aStoreClassDefinition;		yourself</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteName">absoluteName	^self longName.</body><body package="Store-Database Model" selector="absoluteSymbol">absoluteSymbol	^self longName asSymbol.</body><body package="Store-Database Model" selector="allInstVarNames">allInstVarNames	^#().</body><body package="Store-Database Model" selector="allSubclasses">allSubclasses	^#()</body><body package="StoreForGlorpVWUI" selector="allSubclassesDo:">allSubclassesDo: aBlock	"I Do Nothing"	^self</body><body package="Store-Database Model" selector="allSuperclasses">allSuperclasses	^Array with: Object.</body><body package="StoreForGlorpVWUI" selector="binding">binding	^self</body><body package="StoreForGlorpVWUI" selector="bindingOrNil">bindingOrNil	^self</body><body package="Store-Database Model" selector="browserIcon">browserIcon	^nil.</body><body package="Store-Database Model" selector="classDefinition">classDefinition	self subclassResponsibility.</body><body package="Store-Database Model" selector="classNameWithMeta">classNameWithMeta	^self absoluteName</body><body package="Store-Database Model" selector="comment">comment	| definition |	definition := self classDefinition.	^definition isNil ifTrue: [(#CommentNotVisible &lt;&lt; #store &gt;&gt; 'Comment not visible') asString] ifFalse: [definition comment].</body><body package="Store-Database Model" selector="compiledMethodAt:">compiledMethodAt: aSelector	^self compiledMethodAt: aSelector ifAbsent: [nil]</body><body package="Store-Database Model" selector="compiledMethodAt:ifAbsent:">compiledMethodAt: aSelector ifAbsent: aBlock	| selectorString |	aSelector ifNil: [^aBlock value].	selectorString := aSelector asString.	^self instanceMethods detect: [:each | each name = selectorString]		ifNone: aBlock</body><body package="Store-Database Model" selector="compilerClass">compilerClass	"Answer a compiler class appropriate for source methods of this class."	^Compiler</body><body package="Store-Database Model" selector="correspondingImageClass">correspondingImageClass	"Return the image class that corresponds to our name. Note that they may not have the same information"	^(Dialect smalltalkAt: self longName ifAbsent: [nil])</body><body package="Store-Database Model" selector="definition">definition	^self definitionString.</body><body package="Store-Database Model" selector="definitionObject">definitionObject	^self classDefinition</body><body package="Store-Database Model" selector="definitionString">definitionString	^self classDefinition isNil ifTrue: [''] ifFalse: [self classDefinition definitionString].</body><body package="Store-Database Model" selector="editionStampFrom:">editionStampFrom: aPundle	^aPundle version.</body><body package="Store-Database Model" selector="fullName">fullName	^self longName.</body><body package="Store-Database Model" selector="instVarNames">instVarNames	| def |	def := self classDefinition.	def isNil ifTrue: [^#()].	^def instVarNames</body><body package="Store-Database Model" selector="instanceMethods">instanceMethods	^self subclassResponsibility.</body><body package="Store-Database Model" selector="longName">longName	^self subclassResponsibility.</body><body package="Store-Database Model" selector="mainClass">mainClass	^self</body><body package="StoreForGlorpVWUI" selector="organization">organization	organization isNil ifTrue: [organization := ClassOrganizer new.		self instanceMethods do: [:each | organization classify: each selector under: each protocol asSymbol]].	^organization.</body><body package="Store-Database Model" selector="parserClass">parserClass	^self compilerClass preferredParserClass</body><body package="Store-Database Model" selector="protocols">protocols	^(self instanceMethods collect: [:each |  each protocol]) asSet.</body><body package="StoreForGlorpVWUI" selector="selectorsAndMethodsDo:">selectorsAndMethodsDo: aBlock	self instanceMethods do: [:each | aBlock value: each selector value: each]</body><body package="StoreForGlorpVWUI" selector="simpleName">simpleName	^self name</body><body package="Store-Database Model" selector="simpleNameWithMeta">simpleNameWithMeta	^self name</body><body package="Store-Database Model" selector="subclasses">subclasses	^#()</body><body package="Store-Database Model" selector="superclass">superclass	^nil.</body><body package="Store-Database Model" selector="timestamp">timestamp	^self subclassResponsibility.</body><body package="Store-Database Model" selector="withAllSubclasses">withAllSubclasses	^Array with: self.</body><body package="Store-Database Model" selector="withAllSuperclasses">withAllSuperclasses	^Array with: self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>image compatibility</category><body package="Store-Database Model" selector="canUnderstand:">canUnderstand: aSelector	"If we're browsing the database, we don't really know what we can and can't understand. Just say we do."	^true.</body><body package="Store-Database Model" selector="classBehavior">classBehavior	"StoreClassExtension overrides this to provide its corresponding StoreMetaClassExtension"	^self</body><body package="Store-Database Model" selector="fullRootName">fullRootName	^self longName.</body><body package="Store-Database Model" selector="instanceBehavior">instanceBehavior	"StoreMetaclassExtension overrides this to provide its corresponding StoreClassExtension."	^self</body><body package="Store-Database Model" selector="key">key	^self name.</body><body package="Store-Database Model" selector="value">value	^self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>testing</category><body package="Store-Database Model" selector="includesBehavior:">includesBehavior: aClass	^false.</body><body package="Store-Database Model" selector="inheritsFrom:">inheritsFrom: aClass	^false.</body><body package="Store-Database Model" selector="isClass">isClass	^true.</body><body package="Store-Database Model" selector="isExtension">isExtension	^self classDefinition isNil</body><body package="Store-Database Model" selector="isForClass">isForClass	^false.</body><body package="Store-Database Model" selector="isForClassOrExtension">isForClassOrExtension	^true</body><body package="Store-Database Model" selector="isForNameSpace">isForNameSpace	^false</body><body package="Store-Database Model" selector="isForSharedVariable">isForSharedVariable	^false</body><body package="Store-Database Model" selector="isImageObject">isImageObject	^false</body><body package="Store-Database Model" selector="isMeta">isMeta	^false.</body><body package="StoreForGlorpVWUI" selector="isPatched">isPatched	^false</body><body package="Store-Database Model" selector="isPseudo">isPseudo	^false</body><body package="Store-Database Model" selector="isStoreDefinitionInPackage">isStoreDefinitionInPackage	^false</body><body package="Store-Database Model" selector="needsComment">needsComment	^false.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>printing</category><body package="Store-Database Model" selector="asString">asString	^self displayString.</body><body package="Store-Database Model" selector="fileOutMethodsOn:">fileOutMethodsOn: aSourceFileManager	| allMethods |	allMethods := self instanceMethods copy.	allMethods addAll: self classMethods.	allMethods do:		[:each | each fileOutSourceOn: aSourceFileManager]</body><body package="Store-Database Model" selector="fileOutOn:">fileOutOn: aSourceFileManager		aSourceFileManager addComment: 'Class ' , self longName.	self fileOutSourceOn: aSourceFileManager.	aSourceFileManager cr</body><body package="Store-Database Model" selector="fileOutSourceOn:">fileOutSourceOn: aSourceFileManager	"My class definition object knows how to do this, if it exists"	self classDefinition 		ifNil: [self fileOutMethodsOn: aSourceFileManager]		ifNotNil: [:value | value fileOutSourceOn: aSourceFileManager]</body><body package="Store-Database Model" selector="printMethod:on:">printMethod: selector on: aStream	"Print the source code for the method associated with the argument selector onto	the stream."	| source emphasis range |	aStream cr; cr.	source := (self sourceCodeAt: selector) asString.	emphasis := aStream emphasis.	range := self parserClass new parseSelectorInterval: source.	aStream nextPutAll: (source copyFrom: 1 to: range first - 1).	aStream emphasis: #bold.	aStream nextPutAll: (source copyFrom: range first to: range last).	aStream emphasis: emphasis.	aStream nextPutAll: (source copyFrom: range last + 1  to: source size)</body><body package="Store-Database Model" selector="printOn:">printOn: aStream	aStream nextPutAll: self name.</body><body package="Store-Database Model" selector="printOutCategory:on:">printOutCategory: aSymbol on: aStream 	"File a description of the receiver's category, aSymbol, onto aStream."	|saved|	saved := aStream emphasis.	aStream emphasis: #bold.	aStream cr.	aStream nextPutAll: self simpleNameWithMeta; nextPutAll: ' methodsFor: ' , aSymbol.	aStream emphasis: saved.	(self organization listAtCategoryNamed: aSymbol)		do: [:each | self printMethod: each on: aStream].	aStream cr</body><body package="Store-Database Model" selector="printOutOn:">printOutOn: aStream	"Print me out on a textStream"	|saved definitionString commentString |	definitionString := self definition.	commentString := self comment.	definitionString isEmpty ifTrue: 		[definitionString := self longName.		commentString := String new].	saved := aStream emphasis.	aStream emphasis: #bold.	aStream nextPutAll: definitionString.	commentString notEmpty ifTrue:		[aStream cr.		aStream emphasis: #italic.		aStream cr.		aStream nextPutAll: commentString].	aStream emphasis: saved.	aStream cr.	self organization categories do: 		[:heading | self printOutCategory: heading on: aStream].	self classBehavior organization categories do: 		[:heading | self classBehavior printOutCategory: heading on: aStream].	aStream cr.	aStream cr</body><body package="Store-Database Model" selector="shortName">shortName	^self displayString.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;">&lt; aStoreClassExtension	^self timestamp &gt; aStoreClassExtension timestamp.</body><body package="Store-Database Model" selector="&lt;=">&lt;= aStoreClassExtension	^self timestamp &gt;= aStoreClassExtension timestamp.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>browser support</category><body package="Store-Database Model" selector="valueOrDo:">valueOrDo: aBlock	^self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>accessing method dictionary</category><body package="Store-Database Model" selector="sourceCodeAt:">sourceCodeAt: messageSelector 	"Answer the string corresponding to the source code for the argument."	| method |	method := self instanceMethods detect: [:each | each selector asString = messageSelector asString].	^(self sourceCodeForMethod: method at: messageSelector) asText.</body><body package="Store-Database Model" selector="sourceCodeForMethod:at:">sourceCodeForMethod: aMethod at: aSelector	^aMethod source</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="bindingFor:">bindingFor: aKey	^VariableBinding key: aKey</body><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self longName</body><body package="StoreForGlorpVWUI" selector="shortItemString">shortItemString	^self longNameFromSmalltalk</body><body package="Store-Database Model" selector="sourceCodeTemplate">sourceCodeTemplate	^Object sourceCodeTemplate.</body><body package="StoreForGlorpVWUI" selector="toolListDisplayString">toolListDisplayString	^self displayString.</body><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	^self class toolListIcon.</body><body package="StoreForGlorpVWUI" selector="unambiguousName">unambiguousName	^self longName</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>testing method dictionary</category><body package="Store-Database Model" selector="includesSelector:">includesSelector: aSelector	^self instanceMethods anySatisfy: [:each | each name = aSelector asString].</body><body package="Store-Database Model" selector="whichClassIncludesSelector:">whichClassIncludesSelector: aSelector	^self</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension</class-id> <category>converting</category><body package="Store-Database Model" selector="asQualifiedReference">asQualifiedReference	^self.</body></methods><methods><class-id>Store.Glorp.StoreAbstractClassExtension class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="new">new	^super new initialize.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>comparing</category><body package="Store-Database Model" selector="isTheSameAs:">isTheSameAs: aStoreClassExtension	"Return true if the set of methods, the definition, and so forth, are exactly the same"	| myInstanceMethods otherInstanceMethods myClassMethods otherClassMethods |	aStoreClassExtension isNil ifTrue: [^false].	name = aStoreClassExtension name ifFalse: [^false].	longName = aStoreClassExtension longName ifFalse: [^false].	(aStoreClassExtension classDefinition = nil and: [self classDefinition ~= nil]) ifTrue: [^false].	(self classDefinition = nil and: [aStoreClassExtension classDefinition ~= nil]) ifTrue: [^false].	self classDefinition = nil ifFalse: [		aStoreClassExtension classDefinition definition yourSelf == self classDefinition definition yourSelf ifFalse: [^false]].	myInstanceMethods := IdentitySet withAll: instanceMethods.	otherInstanceMethods := IdentitySet withAll: aStoreClassExtension instanceMethods.	(self methodsFrom: myInstanceMethods areIncludedIn: otherInstanceMethods) ifFalse: [^false].	(self methodsFrom: otherInstanceMethods areIncludedIn: myInstanceMethods) ifFalse: [^false].	myClassMethods := IdentitySet withAll: classMethods.	otherClassMethods := IdentitySet withAll: aStoreClassExtension classMethods.	(self methodsFrom: myClassMethods areIncludedIn: otherClassMethods) ifFalse: [^false].	(self methodsFrom: otherClassMethods areIncludedIn: myClassMethods) ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="matchesWith:">matchesWith: aStoreClassExtension	"Return true if the set of methods, the definition, and so forth, are exactly the same"	^self isTheSameAs: aStoreClassExtension.</body><body package="Store-Database Model" selector="methodsFrom:areIncludedIn:">methodsFrom: aMethodList areIncludedIn: otherMethodList	^aMethodList allSatisfy: [:eachSource |		otherMethodList anySatisfy: [:eachTarget |			eachSource definition = eachTarget definition]].</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteOwnerName">absoluteOwnerName	^classDefinition environmentName</body><body package="Store-Database Model" selector="asNameSpace">asNameSpace	"hack"	^StoreNameSpace new</body><body package="Store-Database Model" selector="classDefinition">classDefinition	"Bad sneakiness here. Use special symbol as a marker to indicate that the class definition IS nil, and we don't need to lazy evaluate for it"	classDefinition == #thereIsNoClassDefinitionUseTheAccessorMethod ifTrue: [^nil].	classDefinition isNil ifTrue: [		classDefinition := self package classDefinitions detect: [:each | each longName = self longName] ifNone: [nil]].	^classDefinition.</body><body package="Store-Database Model" selector="classDefinition:">classDefinition: aStoreClassDefinitionInPackage	aStoreClassDefinitionInPackage yourSelf isNil		ifTrue: [classDefinition := #thereIsNoClassDefinitionUseTheAccessorMethod. ^self].	classDefinition := aStoreClassDefinitionInPackage.</body><body package="Store-Database Model" selector="classMethods">classMethods	^classMethods</body><body package="Store-Database Model" selector="classMethods:">classMethods: aCollection	classMethods := aCollection</body><body package="Store-Database Model" selector="commentKey">commentKey	| comment |	self classDefinition isNil ifTrue: [^nil].	comment := self classDefinition comment.	comment isEmpty ifTrue: [^nil].	^comment.</body><body package="Store-Database Model" selector="instanceMethods">instanceMethods	^instanceMethods</body><body package="Store-Database Model" selector="instanceMethods:">instanceMethods: aCollection	instanceMethods := aCollection</body><body package="Store-Database Model" selector="longName">longName	^longName.</body><body package="Store-Database Model" selector="longName:">longName: aString	longName := aString.	name isNil ifTrue: [name := (longName tokensBasedOn: $.) last].</body><body package="Store-Database Model" selector="name">name	^name</body><body package="Store-Database Model" selector="name:">name: aString	name := aString</body><body package="Store-Database Model" selector="package">package	^package</body><body package="Store-Database Model" selector="package:">package: aStorePackage	package := aStorePackage</body><body package="Store-Database Model" selector="primaryKey">primaryKey	^self package primaryKey</body><body package="Store-Database Model" selector="storeMetaClass">storeMetaClass	metaclass isNil ifTrue: [metaclass := StoreMetaclassExtension on: self].	^metaclass.</body><body package="Store-Database Model" selector="superclassName">superclassName	^classDefinition superclassName</body><body package="Store-Database Model" selector="timestamp">timestamp	^self package timestamp.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize	super initialize.	classMethods := IdentitySet new.	instanceMethods := IdentitySet new.	sharedVariables := IdentitySet new.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>adding</category><body package="Store-Database Model" selector="addClassMethod:">addClassMethod: aStoreMethodInPackage	classMethods add: aStoreMethodInPackage yourSelf.</body><body package="Store-Database Model" selector="addInstanceMethod:">addInstanceMethod: aStoreMethodInPackage	self instanceMethods add: aStoreMethodInPackage yourSelf.</body><body package="Store-Database Model" selector="addMethod:">addMethod: aStoreMethodInPackage	(self includesMethod: aStoreMethodInPackage) ifFalse: [		aStoreMethodInPackage isMetaclass			ifTrue: [self addClassMethod: aStoreMethodInPackage]			ifFalse: [self addInstanceMethod: aStoreMethodInPackage]].</body><body package="Store-Database Model" selector="includesMethod:">includesMethod: aStoreMethodInPackage	^aStoreMethodInPackage isMetaclass		ifTrue: [classMethods includes: aStoreMethodInPackage yourSelf]		ifFalse: [self instanceMethods includes: aStoreMethodInPackage yourSelf].</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>non-namespace</category><body package="Store-Database Model" selector="sharedVariables">sharedVariables	^self classDefinition 		ifNotNil: [self package sharedVariablesForClass: self classDefinition]		ifNil: [sharedVariables]</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource		| allMethods |	self classDefinition ifNotNil: [self classDefinition loadSource].	allMethods := self instanceMethods copy.	allMethods addAll: self classMethods.	allMethods do: [:each | each loadSource].	self sharedVariables do: [:each | each loadSource].</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect		^self classDefinition ifNotNil: [self classDefinition loadSource].</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>testing</category><body package="Store-Database Model" selector="isAbstract">isAbstract	^false.</body><body package="Store-Database Model" selector="isForGeneral">isForGeneral	^false.</body><body package="Store-Database Model" selector="isInClass">isInClass	^false.</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="initialMethodCategory">initialMethodCategory	^Symbol new</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="anyStoreObjectInPackage">anyStoreObjectInPackage	| session query |	session := package isNil		ifTrue: [Store.Glorp.StoreLoginFactory currentStoreSession]		ifFalse: [package session].	query := Query		readOneOf: Store.Glorp.StoreClassDefinitionInPackage		where: [:eachClass | eachClass definition name = self name].	query alsoFetch: #definition.	^session execute: query</body><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	^self classDefinition ifNotNil: [:value | value definition]</body><body package="Store-Database Model" selector="asStoreObjectInPackage:">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage classDefinitions		detect: [:each | each definition = self classDefinition]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: Store.Glorp.StoreClassDefinitionInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self classDefinition primaryKey)].	^result</body></methods><methods><class-id>Store.Glorp.StoreClassExtension</class-id> <category>image compatibility</category><body package="Store-Database Model" selector="classBehavior">classBehavior	"Override this to provide my corresponding StoreMetaClassExtension"	metaclass isNil ifTrue: [metaclass := StoreMetaclassExtension on: self].	^metaclass.</body></methods><methods><class-id>Store.DataTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	| own |	^( own := self owner ) ~~ nil		and: [ own includesDataKey: self dataKey ]</body><body package="Store-Change Management" selector="isDataTag">isDataTag	^true</body><body package="Store-Change Management" selector="isForData">isForData	^true</body><body package="Store-Change Management" selector="isInClass">isInClass	^( forClass == nil ) | forClass</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^true</body></methods><methods><class-id>Store.DataTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new data."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body></methods><methods><class-id>Store.DataTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="actual">actual	^self bindingReference</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the data described by me."	^ Registry containingPackageForDataKey: self dataKey symbol: symbol.</body><body package="Store-Change Management" selector="dataKey">dataKey	^dataKey asSymbol</body><body package="Store-Change Management" selector="dataKey:">dataKey: aSymbol	dataKey := aSymbol</body><body package="Store-Change Management" selector="description">description	^dataKey , ' (shared variable)'</body><body package="Store-Change Management" selector="environmentString">environmentString	^symbol asString</body><body package="Store-Change Management" selector="forClass:">forClass: aBoolean	forClass := aBoolean.</body><body package="Store-Change Management" selector="isMeta">isMeta	^false</body><body package="Store-Change Management" selector="name">name	^symbol, '.', dataKey</body><body package="Store-Change Management" selector="owner">owner		"Answers the owning class/namespace"	^self actualClass</body><body package="Store-Change Management" selector="ownerName">ownerName		"Answers the owning class/namespace"	^symbol</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| owner |	^( owner := self owner ) == nil		ifTrue: [ nil ]		ifFalse: [ owner asNameSpace definitionOf: self dataKey ifAbsent: [ nil ] ]</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^dataKey</body></methods><methods><class-id>Store.DataTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag.  Return True if sucessful and False on failure."	| changed |	Cursor execute showWhile: 		[ changed := Object evaluatorClass 				evaluate: someText string				notifying: aController				logged: true		].	^changed ~~ nil"  was...	Dialog warn: 'The text representation of data cannot be used to generate data.'.	^false"</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| owner | 	owner := self owner.	( owner notNil and: [ owner includesDataKey: self dataKey ] )		ifTrue: [ XChangeSet current					moveDataKey: self dataKey					owner: owner					toPackage: newPackage				]		ifFalse: [ aBlock value ]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage 	| owner |	owner := self owner.	owner isNil 		ifTrue: 			[tolerantBoolean 				ifFalse: 					[self 						error: (#_1sDoesNotExistInTheImage &lt;&lt; #store 								&gt;&gt; '&lt;1s&gt; does not exist in the image.' expandMacrosWith: symbol)]]		ifFalse: 			[(aPackage hasDataKey: self dataKey in: owner) 				ifTrue: 					[((Override 						unloadDataKey: self dataKey						in: owner						from: aPackage) not 						and: [tolerantBoolean not]) 							ifTrue: 								[(owner asNameSpace includesKey: self dataKey) 									ifFalse: 										[self 											error: (#Quotes1sDoesNotExistInTheImage &lt;&lt; #store 													&gt;&gt; '"&lt;1s&gt;" does not exist in the image.' expandMacrosWith: self name)]]]]</body></methods><methods><class-id>Store.DataTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="bindingReference">bindingReference	^BindingReference pathString: self owner fullName, '.', self dataKey.</body><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Open a browser on the system version of this shared variable definition."	|bindingReference|	bindingReference := self bindingReference.	bindingReference isDefined ifFalse: [^self].	SmalltalkWorkbench browseBindingReference: bindingReference</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType	^#variable</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream	"Fileout the change onto aStream."	| owner obj |	( owner := self owner ) == nil		ifTrue: [ ^nil ].	obj := owner asNameSpace fullyQualifiedReferenceOf: dataKey.	aStream storeObjectDefinition: obj.	obj fileOutInitializerOn: aStream.</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	aStream removeObject: symbol, '.', dataKey type: self fileOutObjectType</body></methods><methods><class-id>Store.DataTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForDataTag: self.</body></methods><methods><class-id>Store.DataTag</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aTag	^super = aTag and:		[dataKey == aTag dataKey and: [self isInClass == aTag isInClass]]</body></methods><methods><class-id>Store.DataTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClassName:dataKey:">newClassName: aString dataKey: dataKey	^self new 		className: aString; 		isMeta: false; 		dataKey: dataKey;		forClass: true.</body><body package="Store-Change Management" selector="newClassSymbol:dataKey:">newClassSymbol: aSymbol dataKey: dataKey	^self new 		classSymbol: aSymbol; 		isMeta: false; 		dataKey: dataKey;		forClass: true.</body><body package="Store-Change Management" selector="newNameSpaceName:dataKey:">newNameSpaceName: aString dataKey: dataKey	^self new 		name: aString; 		isMeta: false; 		dataKey: dataKey;		forClass: false.</body><body package="Store-Change Management" selector="newNameSpaceSymbol:dataKey:">newNameSpaceSymbol: aSymbol dataKey: dataKey	^self new 		symbol: aSymbol; 		isMeta: false; 		dataKey: dataKey;		forClass: false.</body></methods><methods><class-id>Store.DataTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^4</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="isDefintionResolver">isDefintionResolver	^true</body><body package="Store-Merge Management" selector="isMove">isMove	^movePair notNil</body><body package="Store-Merge Management" selector="isNameSpaceDefinitionResolver">isNameSpaceDefinitionResolver	^true</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	| reference |	proposed ifNil: [^false].	proposed isRemovalResolution ifFalse: [^false].	(reference := self definitionName asQualifiedReference) ifNil: [^true].	reference valueOrDo: [^true].	^((Registry containingPackageForNameSpace: reference value) name = proposed package name) not</body><body package="Store-Merge Management" selector="sameDefinitionAs:">sameDefinitionAs: aString	| reference |	(reference := self definitionName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value definitionString = aString</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	| result |	applyable ifFalse: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isAbsentResolution ifTrue: [^true].	proposed isNoOpResolution ifTrue: [^true].	self hasOverrideAndShouldApply ifFalse: [^false].	Policies packagePolicy 		forcePackage: proposed key storeModel		while: 			[result := [[Compiler evaluate: proposed value logged: true]				on: RedefinitionNotification				do: 					[:notification | 					notification currentPackage name = proposed key storeModel name ifFalse: [notification override install].					notification resume]]						on: Error						do:							[:exception | 							Transcript show: (#nApplyingRemovalNamespaceFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of NameSpace &lt;2s&gt; Failed: &lt;1s&gt;' 								expandMacrosWith: exception messageText								with: self definitionName).							exception return: nil]].	^result notNil</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	| reference result |	(reference := self definitionName asQualifiedReference) ifNil: [^true].	result := [Override				unloadClassOrNameSpace: reference value				from: proposed package storeModel]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingRemovalNamespaceFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of NameSpace &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self definitionName).			exception return: #failed].	^result ~= #failed</body><body package="Store-Merge Management" selector="existingOverrides">existingOverrides	^(Override overridesForClassOrNameSpace: (self longOwnerName asStrictReference valueOrDo: [^#()])) ifNil: [^#()]</body><body package="Store-Merge Management" selector="hasOverrideAndShouldApply">hasOverrideAndShouldApply		self potentialOverride ifNotNil:		[:value | 		value name = proposed key name ifFalse:			[(self proceedWithPossibleOverrideFrom: value name to: proposed key name) ifFalse:				[Transcript					show:						(#nDidNotApplyOverrideNamespace1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of NameSpace &lt;1s&gt; in &lt;2s&gt;'							expandMacrosWith: self longOwnerName							with: proposed key name).				^false]]].	^true</body><body package="Store-Merge Management" selector="ownerNameForLoadOrdering">ownerNameForLoadOrdering	^self environmentString</body><body package="Store-Merge Management" selector="potentialOverride">potentialOverride		^Store.Registry containingPackageForNameSpaceSymbol: self longOwnerName asSymbol</body><body package="Store-Merge Management" selector="proceedWithPossibleOverrideFrom:to:">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingChangeNS1sn2sOveride3snn &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;NameSpace "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longOwnerName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="raiseNoticeFor:">raiseNoticeFor: aCompilerError	aCompilerError type = #undeclared ifTrue: 		[Dialog warn: (#UnknownVariableSpaceColonSpace1s &lt;&lt; #dialogs &gt;&gt; 'Unknown Variable : &lt;1s&gt;' expandMacrosWith: aCompilerError parameter key).		^nil].	^super raiseNoticeFor: aCompilerError</body><body package="Store-Merge Management" selector="validateParse:">validateParse: aNodeHolder	| mainStatementNode selector methodCollector filter alternative oldNode oldStatementNode receiver name |	mainStatementNode := aNodeHolder node block body statements first.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	oldNode := self parseDefinition: alternative value in: self owningEnvironment.	oldStatementNode := oldNode node block body statements first.	receiver := mainStatementNode receiver name.	oldStatementNode receiver name = receiver ifFalse:		[Dialog warn: #NamespaceMustNotChange &lt;&lt; #store &gt;&gt; 'NameSpace must not change'.		^nil].	name := (mainStatementNode arguments first) value asString.	(oldStatementNode arguments first) value asString = name ifFalse:		[Dialog warn: #NameOfTheNameSpaceMustNotChange &lt;&lt; #store &gt;&gt; 'Name of the NameSpace must not change'.		^nil].	selector := mainStatementNode selector.	methodCollector := MethodCollector new.	filter := methodCollector implementorsOf: selector.	(methodCollector select: filter) isEmpty ifTrue:		[Dialog warn: #BadDefinitionMessage &lt;&lt; #store &gt;&gt; 'Bad Definition Message'.		^nil].	oldStatementNode selector = selector ifFalse:		[Dialog warn: #DefinitionMessageMustNotChange &lt;&lt; #store &gt;&gt; 'Definition message must not change'.		^nil].	^aNodeHolder</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="browseVersions">browseVersions	| alternative list session |	alternative := self standardResolutionAlternative.	alternative		ifNil: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self definitionName)].	session := alternative key session.	(Gathering for: self definitionName) started.	list := StoreNamespaceInPackage allVersionsWithName: self definitionName				in: session.	(Gathering for: self definitionName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self definitionName)].	DefinitionForListTool forNameSpaces: list</body><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[movePair notNil 	ifTrue: 			[^applied 				ifTrue: [self movedToPackageString]				ifFalse: [self moveToPackageString]].		^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management" selector="listIcon">listIcon	^NameSpace toolListIcon</body><body package="Store-Merge Management" selector="longListName">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="longOwnerName">longOwnerName	| name |	name := self ownerName.	(name includes: $.) ifTrue: 		[^('Root.*' match: name)			ifTrue: [name]			ifFalse: ['Root.', name]].	^'Root.Smalltalk.' , name</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName		^(#BracketNameSpaceDefinition &lt;&lt; #store &gt;&gt; '[NameSpace Definition]') asString</body><body package="Store-Merge Management" selector="moveFromPackageString">moveFromPackageString	^self moveFromPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="moveToPackageString">moveToPackageString	^self moveToPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="movedFromPackageString">movedFromPackageString	^self movedFromPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="movedToPackageString">movedToPackageString	^self movedToPackage: movePair proposed package name</body><body package="Store-Merge Management" selector="shortListName">shortListName	| string |	string := self ownerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>applying</category><body package="Store-Merge Management" selector="definitionName">definitionName	| methodNodeHolder target |	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^''].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first arguments first value asString</body><body package="Store-Merge Management" selector="environmentString">environmentString	| methodNodeHolder target |	proposed isAbsentResolution ifTrue: [^'Root'].	target := alternatives detect: [:each | each isStandardResolution] ifNone: [^'Root'].	methodNodeHolder := Compiler new 		parse: target value		in: nil class		noPattern: true		notifying: nil.	^methodNodeHolder node block body statements first receiver name asString</body></methods><methods><class-id>Store.Glorp.NamespaceChangeResolver</class-id> <category>accessing</category><body package="Store-Merge Management" selector="movePair">movePair	^movePair</body><body package="Store-Merge Management" selector="movePair:">movePair: aNamespaceChangeResolver	movePair := aNamespaceChangeResolver</body></methods><methods><class-id>Store.Renaming</class-id> <category>accessing</category><body package="Store-Base" selector="actionText">actionText	^(#Renaming &lt;&lt; #store &gt;&gt; 'Renaming') asString</body><body package="Store-Base" selector="componentName">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.Renaming class</class-id> <category>instance creation</category><body package="Store-Base" selector="for:from:to:">for: aPundleClass from: aString to: anotherString	^self for: (#_1sFrom2sTo3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; from: &lt;2s&gt; to: &lt;3s&gt;'		expandMacrosWith: aPundleClass name		with: aString		with: anotherString)</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="commentComparisonRow">commentComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyComment		name: 'Comment'		leftText: leftBlueprint comment		rightText: rightBlueprint comment</body><body package="Store-Code Comparison" selector="commentSingularRow">commentSingularRow	^self singularBlueprint comment size isZero		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self annotateIconWithDisposition: ComparisonIcons modifyComment)				name: 'Comment'				text: self singularBlueprint comment]</body><body package="Store-Code Comparison" selector="importsStringComparisonRow">importsStringComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyImports		name: 'Imports'		leftText: leftBlueprint importsString		rightText: rightBlueprint importsString</body><body package="Store-Code Comparison" selector="importsStringSingularRow">importsStringSingularRow	^self singularBlueprint importsString isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self annotateIconWithDisposition: ComparisonIcons modifyImports)				name: 'Imports'				text: self singularBlueprint importsString]</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="defaultIcon">defaultIcon	^BehaviorIcons Namespace</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="leftNamespace:rightNamespace:">leftNamespace: aNamespaceBlueprint rightNamespace: bNamespaceBlueprint	leftBlueprint := aNamespaceBlueprint.	rightBlueprint := bNamespaceBlueprint.	self populate</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison" selector="bindingTest">bindingTest	^#isForNameSpace</body></methods><methods><class-id>Tools.NamespaceBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison" selector="versionListPaneClass">versionListPaneClass	^Store.Glorp.NameSpaceListPane</body></methods><methods><class-id>Store.LoadingParcel</class-id> <category>accessing</category><body package="Store-UI" selector="actionText">actionText	^(#Loading &lt;&lt; #store &gt;&gt; 'Loading') asString</body><body package="Store-UI" selector="componentName">componentName	^self parcelName , ' (Parcel)'</body><body package="Store-UI" selector="parcelName">parcelName	^subject</body></methods><methods><class-id>Store.LoadingParcel class</class-id> <category>instance creation</category><body package="Store-UI" selector="named:">named: aString	^self new codeComponent: aString</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="augmentTextFieldController:">augmentTextFieldController: aController	"Provide additional tuning of the text controller used in the '#text' widget (the widget where we display the selected object's printStrings)."		| menu copyItem |	aController		initializeMenuForCode;		autoAccept: false.	menu := aController menu copy.	copyItem := menu menuItemWithValue: #copySelection.	menu := Menu new.	menu addItem: copyItem.	aController menuHolder value: menu</body><body package="StoreForGlorpBrowserUI" selector="refresh">refresh		propertyParts := object		ifNil: [List new]		ifNotNil:			[(object properties keys asList				collect: [:each | StoreCodeComponentInspectorField named: each in: object]) sorted].	super refresh</body><body package="StoreForGlorpBrowserUI" selector="textAcceptAllowed:">textAcceptAllowed: aController	^false</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>actions-drag/drop</category><body package="StoreForGlorpBrowserUI" selector="wantToDrag:">wantToDrag: aController	^false</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>actions</category><body package="StoreForGlorpBrowserUI" selector="changeRequest">changeRequest	^true</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>decomposing</category><body package="StoreForGlorpBrowserUI" selector="partAt:">partAt: anIndex	^propertyParts at: anIndex</body><body package="StoreForGlorpBrowserUI" selector="partCount">partCount	^object		ifNil: [0]		ifNotNil: [propertyParts size]</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>properties</category><body package="StoreForGlorpBrowserUI" selector="dragControllerClass">dragControllerClass	^Tools.Trippy.ReplaceOnlyDragController</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector</class-id> <category>menu management</category><body package="StoreForGlorpBrowserUI" selector="buildFieldListMenu">buildFieldListMenu	"Build the popup menu for the field list. Besides the usual things,	it should include items for actions published by the currently selected	object, if there is one."		| menu |	menu := self class fieldListMenu.	(menu atNameKey: #dive) enabled: [self canDive].	(menu atNameKey: #spawn) enabled: [self canDive].	(menu atNameKey: #back) enabled: [self container canGoBack].	(self hasSingleSelection and: [self selection hasValue])		ifTrue: [self addSelectionActionsToFieldMenu: menu].	menu		augmentFrom: PartListAbstractInspector		to: PartListAbstractInspector		menuName: #fieldList		for: self.	^menu</body></methods><methods><class-id>Store.SubdefView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="className">className	^className</body><body package="Store-DB-Subdefs" selector="className:">className: anObject	className := anObject</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Subdefs" selector="packageRef:">packageRef: anObject	packageRef := anObject</body><body package="Store-DB-Subdefs" selector="sourceCodeID">sourceCodeID	^sourceCodeID</body><body package="Store-DB-Subdefs" selector="sourceCodeID:">sourceCodeID: anObject	sourceCodeID := anObject</body></methods><methods><class-id>Store.SubdefView class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="parentReference">parentReference	^'packageRef'</body></methods><methods><class-id>Store.SubdefView class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="definitionReferenceColumn">definitionReferenceColumn	"Answer the column symbol of the column that contains the definition id."	^#sourceCodeID</body></methods><methods><class-id>Store.MethodsView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="isMeta">isMeta	^className namesMetaClass</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body></methods><methods><class-id>Store.MethodsView</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="methodNamedInClass">methodNamedInClass	"Answer a method named :name in class :className."	| res |	res := (self broker 				process: ((self newSQL)						selectAll;						where;						column: #packageRef equalTo: ':primaryKey';						and;						column: #className equalTo: ':className';						and;						column: #name equalTo: ':name')				bindInput: self				bindOutput: self class newPrimed) collect: [:each | Method fromView: each].	res size &gt; 1 		ifTrue: 			[self error: #DuplicateMethodDefinition &lt;&lt; #store &gt;&gt; 'Duplicate method definition'].	^res isEmpty ifTrue: [nil] ifFalse: [res first]</body><body package="Store-DB-Subdefs" selector="methodsForClass">methodsForClass	^(self broker		process: 			( self newSQL				selectAll;				where;				column: #packageRef  equalTo: ':primaryKey';				and;				column: #className equalTo: ':className') 		bindInput: self		bindOutput: self class newPrimed) collect: [:each | Method fromView: each]</body><body package="Store-DB-Subdefs" selector="methodsForClassAndProtocol">methodsForClassAndProtocol	^(self broker		process: 			( self newSQL				selectAll;				where;				column: #packageRef equalTo: ':primaryKey';				and;				column: #className equalTo: ':className';				and;				column: #protocolName equalTo: ':protocolName')		bindInput: self		bindOutput: self class newPrimed ) collect: [:each | Method fromView: each]</body><body package="Store-DB-Subdefs" selector="protocols">protocols	^(self broker process: 					( self newSQL						selectDistinct: #( protocolName );						where;						column: #packageRef  equalTo: ':primaryKey';						and;						column: #className equalTo: ':className')				bindInput: self )		collect: [:each | each first]</body></methods><methods><class-id>Store.MethodsView class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="childReference">childReference	^'methodRef'</body><body package="Store-DB-Subdefs" selector="referencedClass">referencedClass	^Method</body><body package="Store-DB-Subdefs" selector="subCollectionClass">subCollectionClass	^Methods</body><body package="Store-DB-Subdefs" selector="subCollectionClasses">subCollectionClasses	^Array with: self subCollectionClass.</body></methods><methods><class-id>Store.MethodsView class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="classNamesInPackages:">classNamesInPackages: pkgIds	| allClasses |	pkgIds isEmpty		ifTrue: [ ^OrderedCollection new ].	allClasses := self broker process:		( self newSQL  classNamesInPackages: pkgIds	).	^( allClasses collect: [ :array | array first asClassNameOnly ] ) asSet</body><body package="Store-DB-Subdefs" selector="methodNamed:class:package:">methodNamed: aSelector class: aClassName package: aPackageID 	"Answer a TT_Method or nil."	"self methodNamed: 'methodNamed:class:package:'		  class: 'Root.Smalltalk.Store.MethodsView class' 		  package: ( Registry packageNamed: 'Store-DB-Subdefs' ) parentRecord primaryKey"	| res |	res := self broker getAnswerFromSession: [ MethodsView methodInClassSession ]							bindInput: [ :session | 								( session bindInput ) 								primaryKey: aPackageID; 								className: aClassName; 								name: aSelector asString].	^(res isNil or: [ res isEmpty])		ifTrue: [ nil ]		ifFalse: 			[ res size &gt; 1				ifTrue: 					[ Transcript show: ( (#NWarningDuplicateInPackageId3s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Warning: Duplicate method definition: &lt;1s&gt;&gt;&gt;&lt;2s&gt; in package id: &lt;3s&gt;')						expandMacrosWith: aClassName with: aSelector with: aPackageID printString ) .					].			Method fromView: res last			]</body><body package="Store-DB-Subdefs" selector="protocolsForClassNamed:package:">protocolsForClassNamed: aString package: aDBpackage 	^ self broker 			process: 				( self newSQL					selectDistinct: #( classname );					where;					column: #packageRef equalTo: ':primaryKey'					and;					column: #className equalTo: ':className')			bindInput: aDBpackage</body></methods><methods><class-id>Store.MethodsView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="defaultBlockFactor">defaultBlockFactor	^1000</body><body package="Store-DB-Subdefs" selector="methodInClassSession">methodInClassSession	( self isSessionValid: MethodInClassSession)		ifFalse:			[MethodInClassSession := self broker getNewSession.			MethodInClassSession bindOutput: self newPrimed.			MethodInClassSession bindInput: self new.			MethodInClassSession prepare: 						( self newSQL							selectAll;							where;							column: #packageRef  equalTo: ':primaryKey';							and;							column: #className equalTo: ':className';							and;							column: #name  equalTo: ':name') ].	^MethodInClassSession</body><body package="Store-DB-Subdefs" selector="methodsSession">methodsSession	"MethodsSession := nil"	( self isSessionValid: MethodsSession )		ifFalse:			[ MethodsSession := self broker getNewSession				blockFactor: self blockFactor;				bindOutput: self newPrimed;				bindInput: self new;				prepare: 					( self newSQL						selectAll;						where;						column: #packageRef equalTo: ':primaryKey' 					);				yourself. 			].	^MethodsSession</body><body package="Store-DB-Subdefs" selector="resetSession">resetSession	MethodsSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: MethodsSession].		MethodsSession := nil].	MethodInClassSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: MethodInClassSession].		MethodInClassSession := nil]</body></methods><methods><class-id>Store.MethodsAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="blobData">blobData	^blobData</body><body package="Store-DB-Subdefs" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.MethodsAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="resetSession">resetSession	MethodsWithSourcesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: MethodsWithSourcesSession].		MethodsWithSourcesSession := nil]</body><body package="Store-DB-Subdefs" selector="sourcesSession">sourcesSession	"MethodsWithSourcesSession := nil"	( self isSessionValid: MethodsWithSourcesSession )		ifFalse: 	[ MethodsWithSourcesSession := self createSourcesSession ].	^MethodsWithSourcesSession</body></methods><methods><class-id>Store.MethodsAndSourcesView class</class-id> <category>instance creation</category><body package="Store-DB-Subdefs" selector="fromSourcesView:">fromSourcesView: aSourcesView	^self referencedClass fromSourcesView: aSourcesView.</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="allLoadingDictionaryMethods">allLoadingDictionaryMethods	^self loadingDictionaryMethods , self loadingDictionaryCTypeMethods, self loadingDictionaryExtensionMethods</body><body package="Atomic Compiling and Loading" selector="dllccLoaded">dllccLoaded	^dllccLoaded</body><body package="Atomic Compiling and Loading" selector="dllccLoaded:">dllccLoaded: aBoolean		dllccLoaded := aBoolean</body><body package="Atomic Compiling and Loading" selector="earlyInstallClassNames">earlyInstallClassNames	^earlyInstallClassNames</body><body package="Atomic Compiling and Loading" selector="fullLoadClasses">fullLoadClasses	^fullLoadClasses , self loadingDictionaryClasses</body><body package="Atomic Compiling and Loading" selector="lastPundleWorkedOn">lastPundleWorkedOn	^lastPundleWorkedOn</body><body package="Atomic Compiling and Loading" selector="lastPundleWorkedOn:">lastPundleWorkedOn: aStorePundle	lastPundleWorkedOn := aStorePundle</body><body package="Atomic Compiling and Loading" selector="loadingDictionary">loadingDictionary	^loadingDictionary</body><body package="Atomic Compiling and Loading" selector="loadingDictionaryCTypeMethods">loadingDictionaryCTypeMethods	^loadingDictionary at: #ctypes ifAbsent: [#()]</body><body package="Atomic Compiling and Loading" selector="loadingDictionaryClasses">loadingDictionaryClasses	^loadingDictionary at: #classes ifAbsent: [#()]</body><body package="Atomic Compiling and Loading" selector="loadingDictionaryExtensionMethods">loadingDictionaryExtensionMethods	^loadingDictionary at: #extensions ifAbsent: [#()]</body><body package="Atomic Compiling and Loading" selector="loadingDictionaryMethods">loadingDictionaryMethods	^loadingDictionary at: #methods ifAbsent: [#()]</body><body package="Atomic Compiling and Loading" selector="loadingDictionaryNamespaces">loadingDictionaryNamespaces	^loadingDictionary at: #namespaces ifAbsent: [#()]</body><body package="Atomic Compiling and Loading" selector="loadingDictionaryShareds">loadingDictionaryShareds	^loadingDictionary at: #shareds ifAbsent: [#()]</body><body package="Atomic Compiling and Loading" selector="overrides">overrides	^overrides</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitions">unloadableDefinitions	^unloadableDefinitions</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitionsForBrowsing">unloadableDefinitionsForBrowsing	"We created these UnloadableError objects with ShadowedObjects in them, 	now we have to make them have their generic objects"	| objectInPackage shadowedObject |	unloadableDefinitions do:		[:each |		shadowedObject := each parameter.		objectInPackage := shadowedObject storeObject asStoreObjectInPackage: shadowedObject package.		each parameter: objectInPackage.		each package: shadowedObject package storeModel].	^unloadableDefinitions</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>analyze</category><body package="Atomic Compiling and Loading" selector="analyze">analyze		| shadowRootNameSpace |	Glorp.Dialect reset.	DbRegistry clearPundleCaches.	self runPrerequisites.	self initializeEarlyInstallClassNames.	shadowRootNameSpace := ShadowNameSpaceBuilder new createShadowRoot.	compilationManager := AtomicCompilationManager root: shadowRootNameSpace pundle: nil.	shadowCompiler := ShadowCompiler root: shadowRootNameSpace.	[[installObjects do: [:each | each analyzeUsing: self]]		on: EarlyInstallNotice		do:			[:notification | 			self compileAndInstall.			self resetCompilationEnvironment.			notification resume]]				on: NoDLLCCNotification				do:					[:notification | 					(Parcel parcelNamed: 'DLLCC') ifNotNil: 						[dllccLoaded := true.						notification resume].					Parcel loadParcelByName: 'DLLCC'.					(Parcel parcelNamed: 'DLLCC') ifNil: [LoadCanceled raiseWith: notification parameter].					dllccLoaded := true.					self compileAndInstall.					self resetCompilationEnvironment.					notification resume].	self finalCompileAndInstall.	unloadableDefinitions notEmpty ifTrue: 		[(ignoreUnloadables or: [AtomicLoader loadFailOption ~~ #load]) ifTrue:			[UnloadableDefinitionsViewer openOnExceptions: self unloadableDefinitionsForBrowsing]].	pundlesNeedPostInstallReconcile ifTrue: 		[pundles do: [:each | each storeModel reconcileWithDbVersion: each]]</body><body package="Atomic Compiling and Loading" selector="cleanUpOverrides">cleanUpOverrides		installObjects do: [:each | each cleanUpOverrides]</body><body package="Atomic Compiling and Loading" selector="compileAndInstall">compileAndInstall	"Always when we come in here first, we run the preCompile (prereqs)."		self runPreLoads.	self compileToShadow.	unloadableDefinitions notEmpty ifTrue: 		[(AtomicLoader loadFailOption = #load or: [self proceedToLoad]) ifFalse: 			[LoadCanceled raiseWith: (lastPundleWorkedOn ifNil: [pundles first])]].	self installFromShadow.	self recompileExternalObjects.	self recompileOverriddenClasses.	self initializeBindingsAndClasses.	self runPostLoads.	(Installing for: (lastPundleWorkedOn ifNil: [pundles first])) finished.	self markInstalled</body><body package="Atomic Compiling and Loading" selector="compileToShadow">compileToShadow	(Compiling for: (lastPundleWorkedOn ifNil: [pundles first])) started.	SystemUtils modifySystem: 		[self sortedNamespaces do: [:each | each compileWith: self].		self sortedClasses do: [:each | each compileWith: self].		self loadingDictionaryShareds do: [:each | each compileWith: self].		self sortedCTypeMethods do: [:each | each compileWith: self].		self sortedDefinedMethods do: [:each | each compileWith: self].		self sortedExtensionMethods do: [:each | each compileWith: self].		self compileUnloadables: self unloadableDefinitions].	(Compiling for: (lastPundleWorkedOn ifNil: [pundles first])) finished.</body><body package="Atomic Compiling and Loading" selector="compileUnloadables:">compileUnloadables: aCollectionOfUnloadableDefinitionErrors	"Atttempt to compile the unloadableDefinitions definitions into shadow space"		| localUnloadableDefinitions |	localUnloadableDefinitions := OrderedCollection new.	unloadableDefinitions := OrderedCollection new.	[[aCollectionOfUnloadableDefinitionErrors do:		[:each | 		| definitionRecord |		definitionRecord := each definitionRecord.		definitionRecord compileWith: self]]			on: UnloadableDefinitionError			do:				[:exception | 				localUnloadableDefinitions add: exception.				exception resume]]					on: VariableConfirmation					do: [:notification | notification resume: false].	unloadableDefinitions addAll: localUnloadableDefinitions</body><body package="Atomic Compiling and Loading" selector="finalCompileAndInstall">finalCompileAndInstall	"Always when we come in here first, we run the preCompile (prereqs)."		self runPreLoads.	self compileToShadow.	unloadableDefinitions notEmpty ifTrue: 		[(AtomicLoader loadFailOption = #load or: [self proceedToLoad]) ifFalse: 			[LoadCanceled raiseWith: (lastPundleWorkedOn ifNil: [pundles first])]].	self installFromShadow.	SystemUtils modifySystem: 		[self updateDeltaDefinitionsAndPackageRecompile.		overrides do: [:each | each override cleanUpAfterLoad]].	self recompileExternalObjects.	self recompileOverriddenClasses.	self initializeBindingsAndClasses.	self runPostLoads.	self cleanUpOverrides.	(Installing for: (lastPundleWorkedOn ifNil: [pundles first])) finished.	self markInstalled</body><body package="Atomic Compiling and Loading" selector="installFromShadow">installFromShadow	(Installing for: (lastPundleWorkedOn ifNil: [pundles first])) started.	SystemUtils modifySystem: 		[self loadingDictionaryNamespaces do: [:each | each installWith: self].		self loadingDictionaryClasses do: [:each | each installWith: self].		self loadingDictionaryShareds do: [:each | each installWith: self].		self loadingDictionaryCTypeMethods do: [:each | each installWith: self].		self loadingDictionaryMethods do: [:each | each installWith: self].		self loadingDictionaryExtensionMethods do: [:each | each installWith: self]].</body><body package="Atomic Compiling and Loading" selector="markInstalled">markInstalled		installObjects do: [:each | each installed not ifTrue: [each smartMarkInstalled]]</body><body package="Atomic Compiling and Loading" selector="runPostLoads">runPostLoads		installObjects do: [:each | each runPostLoadUsing: self]</body><body package="Atomic Compiling and Loading" selector="runPreLoads">runPreLoads		installObjects do:		[:each | 		(each installed not and: [each isBundle or: [each isPackage and: [each completedAnalysis]]]) ifTrue:			[(Preloading for: each pundle) started.			[each runPreLoad ifFalse: [LoadCanceled raiseWith: each pundle]] ensure: [(Preloading for: each pundle) finished]]]</body><body package="Atomic Compiling and Loading" selector="runPrerequisites">runPrerequisites		installObjects do:		[:each | 		each hasRunPrerequisites ifFalse:			[(Preloading for: each pundle) started.			each pundle preCompileWith: nil.			each hasRunPrerequisites: true.			(Preloading for: each pundle) finished]]</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-compiling</category><body package="Atomic Compiling and Loading" selector="allExternalInterfaceMethods">allExternalInterfaceMethods		^self allLoadingDictionaryMethods select: 		[:each | 		each mclass notNil and: [(self realFromShadow: each mclass) includesBehavior: ExternalInterface]]</body><body package="Atomic Compiling and Loading" selector="allExternalMethodMethods">allExternalMethodMethods		^self allLoadingDictionaryMethods select: [:each | each isExternalMethod]</body><body package="Atomic Compiling and Loading" selector="compilerMethodInShadow:orRealClassDefinesCompiler:">compilerMethodInShadow: aShadowClassOrMetaClass orRealClassDefinesCompiler: aClassOrMetaClass	| compilerMethod |	aShadowClassOrMetaClass ifNotNil: 		[aShadowClassOrMetaClass nonMeta == Object ifFalse:			[compilerMethod := aShadowClassOrMetaClass isMeta				ifTrue: 					[(aShadowClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: 						[(aShadowClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]				ifFalse: 					[(aShadowClassOrMetaClass class selectors includes: #compilerClass) ifTrue: 						[(aShadowClassOrMetaClass class compiledMethodAt: #compilerClass) copy]]]].	compilerMethod ifNotNil: [^compilerMethod].	aClassOrMetaClass ifNil: [^nil].	^aClassOrMetaClass isMeta		ifTrue: [(aClassOrMetaClass selectors includes: #classCompilerClass) ifTrue: [(aClassOrMetaClass compiledMethodAt: #classCompilerClass) copy]]		ifFalse: [(aClassOrMetaClass class selectors includes: #compilerClass) ifTrue: [(aClassOrMetaClass class compiledMethodAt: #compilerClass) copy]].</body><body package="Atomic Compiling and Loading" selector="extractCompilerFrom:andPutInto:">extractCompilerFrom: aClassOrMetaClass andPutInto: aShadowClass	"If aClassOrMetaClass (the real not shadowed class) is NOT nil, then we don't have to touch it."	| workingShadow realOrNil method |	workingShadow := aShadowClass.	[realOrNil := self realFromShadow: workingShadow.	workingShadow := workingShadow ifNotNil: [:value | value superclass].	(realOrNil isNil and: [workingShadow isNil]) ifTrue: [^self].	(self leaveCompilerAloneWithRegardTo: realOrNil) ifTrue: [^self].	(method := self compilerMethodInShadow: workingShadow orRealClassDefinesCompiler: realOrNil) notNil] whileFalse.	aShadowClass isMeta		ifTrue: [aShadowClass replaceMethodAt: #classCompilerClass withMethod: method]		ifFalse: [aShadowClass class replaceMethodAt: #compilerClass withMethod: method]</body><body package="Atomic Compiling and Loading" selector="leaveCompilerAloneWithRegardTo:">leaveCompilerAloneWithRegardTo: realOrNil		^(realOrNil notNil and: 		[realOrNil nonMeta == Object]) or: 		[realOrNil notNil and: [realOrNil nonMeta includesBehavior: SmalltalkCompiler]]</body><body package="Atomic Compiling and Loading" selector="orderedExternalInterfaceClasses">orderedExternalInterfaceClasses		| classes externalClasses externalMethodClasses |	classes := self loadingDictionaryClasses collect: [:each | each shadowCompiledDefinition].	classes := classes collect: [:each | self realFromShadow: each].	externalClasses := classes select: [:each | each notNil and: [each isMeta not and: [each includesBehavior: ExternalInterface]]].	externalMethodClasses := (self allExternalMethodMethods collect: [:each | self realFromShadow: each mclass]) asSet.	externalMethodClasses addAll: (self allExternalInterfaceMethods collect: [:each | self realFromShadow: each mclass]).	externalMethodClasses addAll: externalClasses.	^SystemUtils sortForLoading: externalMethodClasses</body><body package="Atomic Compiling and Loading" selector="raiseUnloadableError:">raiseUnloadableError: aStoreDbRecord	Store.UnloadableDefinitionError new		definitionRecord: aStoreDbRecord;		raise.	^nil</body><body package="Atomic Compiling and Loading" selector="realFromShadow:">realFromShadow: aShadowedObject	"Looks up aShadowedObject in the real world and answers it, or nil if it doesn't exist. 		Works for NameSpaces and Classes."	| real shadowObject |	aShadowedObject ifNil: [^nil].	shadowObject := aShadowedObject isBehavior		ifTrue: [aShadowedObject instanceBehavior]		ifFalse: [aShadowedObject].	real := shadowObject absoluteName asStrictReference 		ifDefinedDo: [:value | value]		elseDo: [^nil].	^(aShadowedObject isBehavior and: [aShadowedObject isMeta])		ifTrue: [real class]		ifFalse: [real]</body><body package="Atomic Compiling and Loading" selector="resetCompilationEnvironment">resetCompilationEnvironment		self initializeEarlyInstallClassNames.	compilationManager newShadowRoot.	shadowCompiler shadowRoot: compilationManager root.	fullLoadClasses addAll: self loadingDictionaryClasses.	loadingDictionary := Dictionary new.	sortedFullClasses := nil.	overriddenClasses := OrderedCollection new.	classesToInitialize := OrderedCollection new.	overrides := OrderedCollection new.	bindingsToInitialize := OrderedCollection new.	Glorp.Dialect reset.</body><body package="Atomic Compiling and Loading" selector="root">root	^shadowCompiler shadowRoot</body><body package="Atomic Compiling and Loading" selector="shadowAt:">shadowAt: aPath	^(self root		bindingForPath: aPath		modifiers: NameSpaceSearchRules new		onMiss: [:env :aName | | bnd |			bnd := VariableBinding new.			bnd key: aName.			bnd value: (NameSpace new name: aName).			bnd setReservedFlag: true.			env simpleAddBinding: bnd.			bnd]) value</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>install objects</category><body package="Atomic Compiling and Loading" selector="addAllCTypeMethods:">addAllCTypeMethods: anOrderedCollection	| methods |	anOrderedCollection isEmpty ifTrue: [^self].	methods := loadingDictionary at: #ctypes ifAbsentPut: [OrderedCollection new].	methods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading" selector="addAllClasses:">addAllClasses: anOrderedCollection	| classes |	anOrderedCollection isEmpty ifTrue: [^self].	classes := loadingDictionary at: #classes ifAbsentPut: [OrderedCollection new].	classes addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading" selector="addAllExtensionMethods:">addAllExtensionMethods: anOrderedCollection	| methods |	anOrderedCollection isEmpty ifTrue: [^self].	methods := loadingDictionary at: #extensions ifAbsentPut: [OrderedCollection new].	methods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading" selector="addAllMethods:">addAllMethods: anOrderedCollection	| methods |	anOrderedCollection isEmpty ifTrue: [^self].	methods := loadingDictionary at: #methods ifAbsentPut: [OrderedCollection new].	methods addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading" selector="addAllNamespaces:">addAllNamespaces: anOrderedCollection	| namespaces |	anOrderedCollection isEmpty ifTrue: [^self].	namespaces := loadingDictionary at: #namespaces ifAbsentPut: [OrderedCollection new].	namespaces addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading" selector="addAllShareds:">addAllShareds: anOrderedCollection	| shareds |	anOrderedCollection isEmpty ifTrue: [^self].	shareds := loadingDictionary at: #shareds ifAbsentPut: [OrderedCollection new].	shareds addAll: anOrderedCollection</body><body package="Atomic Compiling and Loading" selector="addNamespace:">addNamespace: aShadowedStoreNamespace	| namespaces |	namespaces := loadingDictionary at: #namespaces ifAbsentPut: [OrderedCollection new].	namespaces add: aShadowedStoreNamespace</body><body package="Atomic Compiling and Loading" selector="buildInstallObjects">buildInstallObjects	pundles do:		[:each | 		each runPreRead ifTrue: [installObjects add: each asAtomicInstallObject]]</body><body package="Atomic Compiling and Loading" selector="redefinesClass:">redefinesClass: aStoreClassDefinition	| classes |	aStoreClassDefinition correspondingImageClass ifNotNil: [^true].	classes := loadingDictionary at: #classes ifAbsent: [^false].	classes 		detect: [:each | each longName = aStoreClassDefinition longName]		ifNone: [^false].	^true</body><body package="Atomic Compiling and Loading" selector="redefinesNamespace:">redefinesNamespace: aStoreNamespace	| namespaces |	aStoreNamespace correspondingImageNamespace ifNotNil: [^true].	namespaces := loadingDictionary at: #namespaces ifAbsent: [^false].	namespaces 		detect: [:each | each longName = aStoreNamespace longName]		ifNone: [^false].	^true</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>private-definition sorting</category><body package="Atomic Compiling and Loading" selector="sortedCTypeMethods">sortedCTypeMethods		| methods |	(methods := self loadingDictionaryCTypeMethods) isEmpty ifTrue: [^#()].	loadingDictionary at: #ctypes put: (self sortedMethods: methods).	^self loadingDictionaryCTypeMethods</body><body package="Atomic Compiling and Loading" selector="sortedClasses">sortedClasses	| classes orderedClasses workingClasses names |	(classes := self loadingDictionaryClasses) isEmpty ifTrue: [^#()].	(Gathering for: (classes first package name), ' - Classes') started.	orderedClasses := OrderedCollection new: classes size.	workingClasses := classes copy.	[workingClasses isEmpty] whileFalse:		[names := (workingClasses collect: [:each | each longName]) asSet.		workingClasses copy do:			[:each |			(names contains: [:eachName | eachName = each superclassName]) ifFalse:				[orderedClasses add: each.				workingClasses remove: each]]].	loadingDictionary at: #classes put: orderedClasses.	(Gathering for: (classes first package name), ' - Classes') finished.	^orderedClasses</body><body package="Atomic Compiling and Loading" selector="sortedDefinedMethods">sortedDefinedMethods		| methods |	(methods := self loadingDictionaryMethods) isEmpty ifTrue: [^#()].	loadingDictionary at: #methods put: (self sortedMethods: methods).	^self loadingDictionaryMethods</body><body package="Atomic Compiling and Loading" selector="sortedExtensionMethods">sortedExtensionMethods		| methods |	(methods := self loadingDictionaryExtensionMethods) isEmpty ifTrue: [^#()].	loadingDictionary at: #extensions put: (self sortedMethods: methods).	^self loadingDictionaryExtensionMethods</body><body package="Atomic Compiling and Loading" selector="sortedFullClasses">sortedFullClasses	| classes workingClasses names |	sortedFullClasses ifNotNil: [^sortedFullClasses].	(classes := self fullLoadClasses) isEmpty ifTrue: [^#()].	sortedFullClasses := OrderedCollection new: classes size.	workingClasses := classes copy.	[workingClasses isEmpty] whileFalse:		[names := workingClasses collect: [:each | each longName].		workingClasses copy do:			[:each |			(names contains: [:eachName | '*.', eachName match: each superclassName ignoreCase: false]) ifFalse:				[sortedFullClasses add: each.				workingClasses remove: each]]].	^sortedFullClasses</body><body package="Atomic Compiling and Loading" selector="sortedMethods:">sortedMethods: anOrderedCollection	"We go through three phases here to get everything in Hierarchy order as much as we can:	1) Gather all methods that are for superclasses of all known defined classes	2) Gather all methods that are for classes of all known defined classes	3) For the rest, gathered based on the known classes in the system (mostly extension methods)"			| workingMethods names orderedMethods sortedClasses orderedClassMethods |	(Gathering for: anOrderedCollection first package name , ' - Methods') started.	orderedMethods := OrderedSet new: anOrderedCollection size.	orderedClassMethods := OrderedSet new: anOrderedCollection size.	workingMethods := anOrderedCollection copy.	sortedClasses := self sortedFullClasses.	sortedClasses do:		[:eachClass |		names := (workingMethods collect: [:each | each className]) asSet.		(names contains: [:eachName | eachName = eachClass superclassName]) ifTrue:			[workingMethods copy do:				[:eachMethod |				eachMethod className = eachClass superclassName ifTrue:					[eachMethod isMeta						ifTrue: [orderedClassMethods add: eachMethod]						ifFalse: [orderedMethods add: eachMethod].					workingMethods remove: eachMethod]]]].	sortedClasses do:		[:eachClass |		names := (workingMethods collect: [:each | each className]) asSet.		(names contains: [:eachName | eachName = eachClass longName]) ifTrue:			[workingMethods copy do:				[:eachMethod |				eachMethod className = eachClass longName ifTrue:					[eachMethod isMeta						ifTrue: [orderedClassMethods add: eachMethod]						ifFalse: [orderedMethods add: eachMethod].					workingMethods remove: eachMethod]]]].	[workingMethods isEmpty] whileFalse:		[names := (workingMethods collect: [:each | each className]) asSet.		workingMethods copy do:			[:each | 			(names contains: [:eachName | eachName = (each superclassNameFrom: sortedClasses)]) ifFalse:				[each isMeta					ifTrue: [orderedClassMethods add: each]					ifFalse: [orderedMethods add: each].				workingMethods remove: each ifAbsent: [nil].				workingMethods copy do: 					[:eachMethod |					eachMethod className = each className ifTrue:						[eachMethod isMeta							ifTrue: [orderedClassMethods add: eachMethod]							ifFalse: [orderedMethods add: eachMethod].						workingMethods remove: eachMethod]]]]].	(Gathering for: anOrderedCollection first package name , ' - Methods') finished.	^orderedClassMethods asOrderedCollection		addAll: orderedMethods;		yourself</body><body package="Atomic Compiling and Loading" selector="sortedNamespaces">sortedNamespaces	| namespaces orderedNamespaces workingNamespaces names |	(namespaces := self loadingDictionaryNamespaces) isEmpty ifTrue: [^#()].	orderedNamespaces := OrderedCollection new: namespaces size.	workingNamespaces := namespaces copy.	[workingNamespaces isEmpty] whileFalse:		[names := workingNamespaces collect: [:each | each longName].		workingNamespaces copy do:			[:each |			(names contains: [:eachName | '*.', eachName match: each ownerName ignoreCase: false]) ifFalse:				[orderedNamespaces add: each.				workingNamespaces remove: each]]].	loadingDictionary at: #namespaces put: orderedNamespaces.	^orderedNamespaces</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading" selector="initialize">initialize		pundles := OrderedCollection new.	installObjects := OrderedCollection new.	loadingDictionary := Dictionary new.	dllccLoaded := (Registry packageNamed: 'DLLCC') notNil.	fullLoadClasses := OrderedCollection new.	self initializeEarlyInstallClassNames.	unloadableDefinitions := OrderedCollection new.	pundlesNeedPostInstallReconcile := false.	classesToInitialize := OrderedCollection new.	classesToNotify := OrderedCollection new.	overrides := OrderedCollection new.	overriddenClasses := OrderedCollection new.	bindingsToInitialize := OrderedCollection new.	ignoreUnloadables := false</body><body package="Atomic Compiling and Loading" selector="initializeEarlyInstallClassNames">initializeEarlyInstallClassNames		earlyInstallClassNames := Scanner withAllSubclasses collect: [:each | each longName].	earlyInstallClassNames addAll: (SmalltalkCompiler withAllSubclasses collect: [:each | each longName])</body><body package="Atomic Compiling and Loading" selector="pundle:">pundle: aStorePackageOrBundle	pundles add: aStorePackageOrBundle.	self buildInstallObjects</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="collectRedefinedClasses:">collectRedefinedClasses: aClassOverride	overriddenClasses add: aClassOverride</body><body package="Atomic Compiling and Loading" selector="fixMClass:to:">fixMClass: aMethod to: aNewClass	"Scans blocks to update references to the new (not in shadow) class."	| originalClass |	originalClass := aMethod mclass.	aMethod mclass: aNewClass.	aMethod withAllBlockMethodsDo:		[:method |		1 to: method basicSize do:			[:index |			originalClass  == (method basicAt: index) ifTrue:				[method basicAt: index put: aNewClass]]].	^aMethod</body><body package="Atomic Compiling and Loading" selector="initializeBindings">initializeBindings	"Keep trying until there are either none to do, or the number to do doesn't change"	| workingBindings workingSize copyBindings |	bindingsToInitialize isEmpty ifTrue: [^self].	workingBindings := bindingsToInitialize copy.	copyBindings := workingBindings copy.	workingSize := -1.	[workingSize ~= workingBindings size and: [workingBindings notEmpty]] whileTrue:		[workingSize := workingBindings size.		workingBindings do:			[:each |			[each recompile.			each initialize.			each ifNotNil: [copyBindings remove: each]]				on: MessageNotUnderstood				do: [:exception | exception resume]].			workingBindings := copyBindings copy]</body><body package="Atomic Compiling and Loading" selector="initializeBindingsAndClasses">initializeBindingsAndClasses	"In the Atomic loader we try to recompile all classes that have shareds first. We'll try not doing this"	SystemUtils modifySystem: 		[self initializeBindings.		classesToInitialize do: [:each | each key postCopyFromShadow: each value].		self initializeClasses.		classesToNotify do: [:each | each instanceMethodsChanged]]</body><body package="Atomic Compiling and Loading" selector="initializeClasses">initializeClasses	"Keep trying until there are either none to do, or the number to do doesn't change.	If there are any still unable to be initialized, go and raise MNU on each after setting doNotMarkClean to true"		| sortedClasses workingClasses packageDictionary workingSize |	classesToInitialize isEmpty ifTrue: [^self].	sortedClasses := SystemUtils sortForLoading: (classesToInitialize collect: [:each | each key]).	workingClasses := sortedClasses copy.	workingSize := -1.	[workingSize ~= sortedClasses size and: [sortedClasses notEmpty]] whileTrue:		[workingSize := sortedClasses size.		packageDictionary := Dictionary new.		self putClasses: sortedClasses intoDictionary: packageDictionary.		self installFromPackagesIn: packageDictionary removingFrom: workingClasses.		sortedClasses := workingClasses copy].	(self loadingDictionaryExtensionMethods select: [:each | each isMeta and: [each selector = #initialize]])		do:			[:each | 			[(self realFromShadow: each mclass) nonMeta postLoad: each packageModel]				on: InitializerFailedError , MessageNotUnderstood				do: [:exception | exception return: nil]].	workingClasses notEmpty		ifTrue:			[pundlesNeedPostInstallReconcile := true.			workingClasses				do:					[:each | 					[each postLoad: (Registry containingPackageForClass: each)]						on: InitializerFailedError						do: [:exception | exception resignalAs: MessageNotUnderstood new]]]</body><body package="Atomic Compiling and Loading" selector="installClass:">installClass: aShadowedObject	"The KISS approach: 		execute the new class definition to install or replace the existing one."		| realWorldHomeEnvironment realWorldClass knownOverrides target shadowedClass |	(shadowedClass := aShadowedObject shadowCompiledDefinition) ifNil: [^self].	realWorldHomeEnvironment := self realFromShadow: shadowedClass environment.	(shadowedClass strictReference valueOrDo: [nil]) ifNotNil:		[:value |		knownOverrides := Override overridesForClassOrNameSpace: value.		knownOverrides ifNotNil: [target := knownOverrides detect: [:eachOverride | eachOverride sources includes: aShadowedObject packageModel] ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: ((shadowedClass definitionMessage) receiver: realWorldHomeEnvironment)]].	Policies packagePolicy		forcePackage: aShadowedObject packageModel		while:			[realWorldClass := [(shadowedClass definitionMessage)				receiver: realWorldHomeEnvironment;				value]					on: ClassConstructionError					do: [:exception | exception resume].			(shadowedClass comment notNil and: [shadowedClass comment notEmpty]) ifTrue:				[realWorldClass comment: shadowedClass comment].			realWorldClass addToSuper].	classesToInitialize add: realWorldClass -&gt; shadowedClass</body><body package="Atomic Compiling and Loading" selector="installFromPackagesIn:removingFrom:">installFromPackagesIn: packageDictionary removingFrom: workingClasses		installObjects do:		[:eachTopLevelPundle | 		eachTopLevelPundle visit:			[:eachPundle | 			eachPundle installed ifFalse:				[(packageDictionary at: eachPundle pundleModel ifAbsent: [nil]) ifNotNil:					[:classesInThePackage | 					classesInThePackage do:						[:eachClass | 						[eachClass postLoad: eachPundle pundleModel.						workingClasses remove: eachClass] 							on: InitializerFailedError , MessageNotUnderstood 							do: [:exception | exception return: nil]]]]]]</body><body package="Atomic Compiling and Loading" selector="installMethod:">installMethod: aShadowedObject	"If the new method is already in the REAL class, then throw a RedefinitionNotification	If this is a new method, just move it directly to the package we want. 	The system will think it's in the package of the class definition, since no other packages have information about it yet.	If the shadowCompiledDefinition is nil, then it had to be a unloadable definition.	If the method is NOT new, then this is an override. We need to move it to the package we want in a way that modifies other change sets."	| shadowClass realClass category selector existingMethod knownOverride compiledMethod |	(compiledMethod := aShadowedObject shadowCompiledDefinition) ifNil: [^self].	shadowClass := compiledMethod mclass.	realClass := self realFromShadow: shadowClass.	selector := compiledMethod selector.	category := shadowClass whichCategoryIncludesSelector: selector.	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: 		[ | methodNodeHolder |		methodNodeHolder := Compiler new 			parse: compiledMethod getSource			in: realClass			notifying: nil.		methodNodeHolder notNil ifTrue:			[selector := aShadowedObject selector.			category := aShadowedObject protocol]].	(existingMethod := realClass compiledMethodAt: selector ifAbsent: nil) ifNotNil:		[knownOverride := Override 			overrideForSelector: selector 			class: realClass 			in: aShadowedObject packageModel.		knownOverride ifNotNil: 			[knownOverride setOverriddenDefinition: (self fixMClass: compiledMethod to: realClass).			^knownOverride setOverriddenProtocol: category].		RedefinitionNotification			redefinedSelector: selector			class: realClass			attributes: existingMethod attributes].	(category isNil or: ['unboundMethod*' match: selector]) ifTrue: [^self].	self fixMClass: compiledMethod to: realClass.	realClass needsSafeRebinding ifTrue:		[compiledMethod literalsDo: [:each | (each isVariableBinding and: [each isDeferred]) ifTrue: [each resolveBinding]]]. 	(realClass		justAddSelectorUnsafe: selector		withMethod: compiledMethod		category: category) ifTrue: 			[classesToNotify add: realClass].	existingMethod ifNotNil:		[| sourcePackage |		sourcePackage := Registry containingPackageForSelector: compiledMethod selector class: realClass.		sourcePackage doSubdefChange: (Change new remove selector: compiledMethod selector; class: realClass)].	aShadowedObject packageModel doSubdefChange:		((Change new add)			selector: compiledMethod selector;			class: realClass).	(realClass isMeta and: [selector = #initialize and: [(classesToInitialize anySatisfy: [:each | each key = realClass instanceBehavior]) not]])		ifTrue: [classesToInitialize add: realClass instanceBehavior -&gt; shadowClass instanceBehavior].	compiledMethod sourcePointer:		(SourceFileManager default			storeMethodSources: compiledMethod methodSources			class: realClass			selector: selector			category: category			safely: false)</body><body package="Atomic Compiling and Loading" selector="installNameSpace:">installNameSpace: aShadowedObject	"The KISS approach: 		execute the new namespace definition to install or replace the existing one."		| environment namespace knownOverrides target shadowedNamepace |	(shadowedNamepace := aShadowedObject shadowCompiledDefinition) ifNil: [^self].	environment := self realFromShadow: shadowedNamepace environment.	(shadowedNamepace strictReference valueOrDo: [nil]) ifNotNil:		[:value |		knownOverrides := Override overridesForClassOrNameSpace: value.		knownOverrides ifNotNil: [target := knownOverrides detect: [:eachOverride | eachOverride sources includes: aShadowedObject packageModel] ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: ((shadowedNamepace definitionMessage) receiver: environment)]].	Policies packagePolicy		forcePackage: aShadowedObject packageModel		while:			[namespace := (shadowedNamepace shadowLoadDefinitionMessage)				receiver: environment;				value.			(shadowedNamepace comment notNil and: [shadowedNamepace comment notEmpty]) ifTrue:				[namespace comment: shadowedNamepace comment]]</body><body package="Atomic Compiling and Loading" selector="installSharedBinding:">installSharedBinding: aShadowedObject	"At the end, we try to initialize the binding now... If we can't, we queue it up to try later"		| owningClassOrNamespace binding messageSend target knownOverrides bindingReference |	(bindingReference := aShadowedObject shadowCompiledDefinition) ifNil: [^self].	owningClassOrNamespace := self realFromShadow: bindingReference environment.	messageSend := bindingReference environment asNameSpace definitionMessageOfStatic: bindingReference binding.	(bindingReference environment strictReference valueOrDo: [nil]) ifNotNil:		[:value |		knownOverrides := Override overridesForStatic: bindingReference binding in: value.		knownOverrides ifNotNil: [target := knownOverrides 			detect: [:eachOverride | eachOverride sources includes: aShadowedObject packageModel] 			ifNone: [nil]].		target ifNotNil: [^target setOverriddenDefinition: (messageSend receiver: owningClassOrNamespace)]].	Policies packagePolicy		forcePackage: aShadowedObject packageModel		while:			[binding := 				messageSend receiver: owningClassOrNamespace;				value].	binding needsInitialization ifTrue: 		[[binding initialize] on: Error do: [:exception | exception return].		bindingsToInitialize add: binding]</body><body package="Atomic Compiling and Loading" selector="proceedToLoad">proceedToLoad		#fail = AtomicLoader loadFailOption ifTrue: [^false].	^(ignoreUnloadables not and: [#displayDialog = AtomicLoader loadFailOption])		ifTrue: [ignoreUnloadables := Dialog confirm: (#LoadingErrorsContinueQuestion &lt;&lt; #store &gt;&gt; 'Loading errors were encountered, continue installation?')]		ifFalse: [true]</body><body package="Atomic Compiling and Loading" selector="putClasses:intoDictionary:">putClasses: sortedClasses intoDictionary: packageDictionary		sortedClasses do:		[:each | 		| package classesInPackage |		package := Registry containingPackageForClass: each.		classesInPackage := packageDictionary at: package ifAbsentPut: [OrderedCollection new].		classesInPackage add: each]</body><body package="Atomic Compiling and Loading" selector="updateDeltaDefinitionsAndPackageRecompile">updateDeltaDefinitionsAndPackageRecompile	| definitionsToRemove targetPackages |	definitionsToRemove := Dictionary new.	installObjects do: [:each | each gatherDefinitionsToRemoveInto: definitionsToRemove].	(definitionsToRemove at: #methods ifAbsent: [#()]) do:		[:eachPair | Override unloadSelector: eachPair key selector class: eachPair key correspondingImageClass from: eachPair value logged: true].	(definitionsToRemove at: #shareds ifAbsent: [#()]) do:		[:eachPair | Override unloadStatic: eachPair key in: eachPair key owner from: eachPair value logged: #(#changes #file)].	(definitionsToRemove at: #classes ifAbsent: [#()]) do:		[:eachPair | Override unloadClassOrNameSpace: eachPair key actual from: eachPair value].	(definitionsToRemove at: #nameSpaces ifAbsent: [#()]) do:		[:eachPair | Override unloadClassOrNameSpace: eachPair key actual from: eachPair value].	installObjects do: [:each | each updateForPackageRecompile].	Override cleanseLists.	Override cleanseLists.	targetPackages := Set new.	definitionsToRemove do:		[:eachGroup |		eachGroup do: [:eachPair | targetPackages add: eachPair value]].	targetPackages do: [:each | each markNotModified].</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>compiling</category><body package="Atomic Compiling and Loading" selector="recompileAllExternals:">recompileAllExternals: anOrderedCollection		anOrderedCollection do:		[:each | 		| failed |		failed := OrderedCollection new.		each selectors do:			[:eachSelector | 			[each recompile: eachSelector]				on: Error , UserNotification				do:					[:error | 					failed add: eachSelector.					error isResumable 						ifTrue: [error resume] 						ifFalse: [error return]]].		failed do: [:eachFailed | (each selectors includes: eachFailed) ifFalse: [each recompile: eachFailed]]]</body><body package="Atomic Compiling and Loading" selector="recompileExternalObjects">recompileExternalObjects		| orderedClasses ctypeClasses |	orderedClasses := self orderedExternalInterfaceClasses.	self recompileAllExternals: orderedClasses.	ctypeClasses := (self loadingDictionaryCTypeMethods collect: [:each | self realFromShadow: each mclass]) asSet.	(SystemUtils sortForLoading: ctypeClasses) do: [:each | each recompileMethods]</body><body package="Atomic Compiling and Loading" selector="recompileOverriddenClasses">recompileOverriddenClasses	| allClassesWithSubclasses classesToRecompile |	overriddenClasses isEmpty ifTrue: [^self].	allClassesWithSubclasses := Set new.	classesToRecompile := overriddenClasses collect: [:each | each actual].	classesToRecompile := classesToRecompile select: [:each | each notNil and: [each isBehavior]].	classesToRecompile do: [:each | allClassesWithSubclasses addAll: each withAllSubclasses].	(SystemUtils sortForAtomicLoading: allClassesWithSubclasses)		do: [:each | (Store.Registry containingPackageForClass: each) recompileMethodsFor: each].</body><body package="Atomic Compiling and Loading" selector="shadowDbMethod:">shadowDbMethod: aMethodRecord	"Convert aMethodRecord into an object in shadow root."		| realWorldClass selector shadowClass |	realWorldClass := aMethodRecord correspondingImageClass.	(shadowClass := shadowCompiler findInShadow: aMethodRecord className asClassNameOnly asStrictReference) ifNil:		[realWorldClass ifNil: [^self raiseUnloadableError: aMethodRecord].		shadowClass := shadowCompiler createShadowClassFor: realWorldClass instanceBehavior].	aMethodRecord isMeta ifTrue: [shadowClass := shadowClass class].	self extractCompilerFrom: realWorldClass andPutInto: shadowClass.	selector := [[shadowClass		compileForShadow: aMethodRecord definitionString		classified: aMethodRecord protocol		notifying: nil		environment: (aMethodRecord package environmentFor: aMethodRecord selector in: shadowClass)		attributes: nil]			on: Error			do: [:exception | exception return: nil]]				on: UserNotification				do: 					[:exception | 					exception isResumable						ifTrue: [exception resume: nil]						ifFalse: [exception return: nil]].	selector ifNil: [^self raiseUnloadableError: aMethodRecord].	aMethodRecord className asClassNameOnly = shadowClass longName asClassNameOnly ifFalse:		[pundlesNeedPostInstallReconcile := true].	^shadowClass compiledMethodAt: selector</body><body package="Atomic Compiling and Loading" selector="shadowDefinedRecord:">shadowDefinedRecord: aStoreDefinitionInPackage	"Convert aDbRecord into an object in shadow root."	"First make sure that a class dependant has a class in shadow to be installed into"		| newDefinitionObject |	aStoreDefinitionInPackage isString ifTrue: [self halt].	aStoreDefinitionInPackage isForData ifTrue:		[(shadowCompiler findInShadow: aStoreDefinitionInPackage environmentString asStrictReference) ifNil:			[| definitionOwnerClass |			(definitionOwnerClass := aStoreDefinitionInPackage owner) ifNil: [^self raiseUnloadableError: aStoreDefinitionInPackage].			shadowCompiler createShadowClassOrNameSpaceFor: definitionOwnerClass.			shadowCompiler addShadowedClassToEnvironment: definitionOwnerClass]].	(newDefinitionObject := shadowCompiler evaluate: aStoreDefinitionInPackage shadowLoadDefinition with: Object evaluatorClass new using: self) isNil		ifTrue: 			[(aStoreDefinitionInPackage isForNameSpace and: [aStoreDefinitionInPackage name = 'Root']) ifFalse: 				[self raiseUnloadableError: aStoreDefinitionInPackage]]		ifFalse:			[newDefinitionObject isBindingReference ifFalse: 				[(aStoreDefinitionInPackage comment notNil and: [aStoreDefinitionInPackage comment notEmpty]) ifTrue: 					[newDefinitionObject comment: aStoreDefinitionInPackage comment]]].	^newDefinitionObject</body></methods><methods><class-id>Store.AtomicAnalysisLoader</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="hasUnloadableDefinitions">hasUnloadableDefinitions	^unloadableDefinitions notEmpty</body></methods><methods><class-id>Store.AtomicAnalysisLoader class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="new">new	^super new initialize</body><body package="Atomic Compiling and Loading" selector="pundle:">pundle: aStorePackageOrBundle	| instance |	instance := self new.	instance pundle: aStorePackageOrBundle.	^instance</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>accessing</category><body package="Store-Database Model" selector="groupName">groupName	^groupName</body><body package="Store-Database Model" selector="groupName:">groupName: aString	groupName := aString</body><body package="Store-Database Model" selector="name">name	"Answer the receiver's userName."	^self userName</body><body package="Store-Database Model" selector="session">session	^session</body><body package="Store-Database Model" selector="session:">session: anObject	session := anObject</body><body package="Store-Database Model" selector="type">type	^type</body><body package="Store-Database Model" selector="type:">type: aString	type := aString</body><body package="Store-Database Model" selector="userName">userName	^userName</body><body package="Store-Database Model" selector="userName:">userName: aString	userName := aString</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;=">&lt;= aStoreUserGroup		aStoreUserGroup class == self class ifFalse: 		[^userName &lt;= aStoreUserGroup name].	^self isGroup = aStoreUserGroup isGroup 		ifTrue: [userName &lt;= aStoreUserGroup userName] 		ifFalse: [self isGroup]</body><body package="Store-Database Model" selector="=">= aStoreUserGroup		aStoreUserGroup class == self class ifFalse: [^false].	^type = aStoreUserGroup type and: 		[userName = aStoreUserGroup userName and: 		[groupName = aStoreUserGroup groupName]]</body><body package="Store-Database Model" selector="hash">hash		^type hash bitXor: (userName hash bitXor: groupName hash)</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>printing</category><body package="Store-Database Model" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: userName;		nextPut: $~;		nextPutAll: type;		nextPutAll: ') '</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>testing</category><body package="Store-Database Model" selector="isGroup">isGroup	^type = 'G'</body></methods><methods><class-id>Store.Glorp.StoreUserGroup</class-id> <category>relationships</category><body package="Store-Database Model" selector="relatedBy:">relatedBy: relToken	"Anwer set of relations. Main relationship is owner-&gt;pundle."		relToken == #tt_ownsRel ifTrue: 		[^(self class pundlePrivilegesClass pundlesUser: self privilege: #owner) asSet].	relToken == #readRel ifTrue: 		[^(self class pundlePrivilegesClass pundlesUser: self privilege: #read) asSet].	relToken == #publishRel ifTrue: 		[^(self class pundlePrivilegesClass pundlesUser: self privilege: #publish) asSet].	^super relatedBy: relToken</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="newGroupNamed:">newGroupNamed: aGroupName	^self newGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="newGroupNamed:in:">newGroupNamed: aGroupName in: aSessionOrNil	| session instance |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	instance := self new.	session inUnitOfWorkDo:		[session register: instance.		instance groupName: aGroupName.		instance userName: aGroupName.		instance type: self groupType].</body><body package="Store-Database Model" selector="newUserNamed:inGroupNamed:">newUserNamed: aUserName inGroupNamed: aGroupName	^self newUserNamed: aUserName inGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="newUserNamed:inGroupNamed:in:">newUserNamed: aUserName inGroupNamed: aGroupName in: aSessionOrNil	| session instance |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	instance := self new.	session inUnitOfWorkDo:		[session register: instance.		instance groupName: aGroupName.		instance userName: aUserName.		instance type: self userType].</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>query</category><body package="Store-Database Model" selector="allDistinctUserGroups">allDistinctUserGroups	^self allDistinctUserGroupsIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allDistinctUserGroupsIn:">allDistinctUserGroupsIn: aSessionOrNil	| session groupNames userNames result |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	userNames := self allUserNamesIn: session.	groupNames := self allGroupNamesIn: session.	result := OrderedCollection new: userNames size + groupNames size.	result addAll: (userNames collect:		[:each | 		(self new)			userName: each;			session: session;			type: 'U']).	result addAll: (groupNames collect:		[:each | 		(self new)			userName: each;			session: session;			type: 'G']).	^result</body><body package="Store-Database Model" selector="allGroupNames">allGroupNames	^self allGroupNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allGroupNamesIn:">allGroupNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each type = 'G'].	query retrieve: [:each | each groupName distinct].	query orderBy: #groupName.	^session execute: query</body><body package="Store-Database Model" selector="allUserNames">allUserNames	^self allUserNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allUserNamesIn:">allUserNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each type = 'U'].	query retrieve: [:each | each userName distinct].	query orderBy: #userName.	^session execute: query</body><body package="Store-Database Model" selector="dbHasAdmin">dbHasAdmin	"self dbHasAdmin"		^self tableExists and: [(self userNamesInGroupNamed: self adminGroupName) notEmpty]</body><body package="Store-Database Model" selector="groupNamesForUserNamed:">groupNamesForUserNamed: aString	^self groupNamesForUserNamed: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="groupNamesForUserNamed:in:">groupNamesForUserNamed: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each userName = aString AND: (each type = 'U')].	query retrieve: [:each | each groupName distinct].	^session execute: query</body><body package="Store-Database Model" selector="groupsForUser:">groupsForUser: aStoreUser	| groupNames result session |	session := aStoreUser session ifNil: [StoreLoginFactory currentStoreSession].	groupNames := self groupNamesForUserNamed: aStoreUser userName in: session.	result := OrderedCollection new: groupNames size.	result addAll: (groupNames collect:		[:each | 		(self new)			userName: each;			session: session;			type: 'G']).	^result</body><body package="Store-Database Model" selector="isInAdmin:">isInAdmin: aString		^self isInAdmin: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="isInAdmin:in:">isInAdmin: aString in: aSession		^(self userNamesInGroupNamed: self adminGroupName in: aSession) includes: aString</body><body package="Store-Database Model" selector="tableExists">tableExists	^self tableExistsIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="tableExistsIn:">tableExistsIn: aSessionOrNil	| session schema tableName |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	schema := (session schema isNil or: [session schema isEmpty]) 		ifTrue: [''] 		ifFalse: [session schema].	(session platform isSQLServerPlatform and: [session platform isAccessPlatform not]) ifTrue: 		[schema := Store.Policies tableSpacePolicy userAndOwnershipTableSpace , '.' , schema].	(session platform isPostgreSQLPlatform and: [schema isEmpty])		ifTrue: [schema := 'public'].	tableName := 'TW_DBUserGroup'.	^(session accessor isExistingTable: tableName inSchema: schema)</body><body package="Store-Database Model" selector="userNamed:">userNamed: aString	^self userNamed: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="userNamed:in:">userNamed: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: [:each | each userName = aString AND: (each type = 'U')].	^session execute: query</body><body package="Store-Database Model" selector="userNamed:inGroupNamed:">userNamed: aUserName inGroupNamed: aGroupName	^self userNamed: aUserName inGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="userNamed:inGroupNamed:in:">userNamed: aUserName inGroupNamed: aGroupName in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readOneOf: self where: 		[:each | 		each groupName = aGroupName AND: (each userName = aUserName) AND: (each type = 'U')].	^session execute: query</body><body package="Store-Database Model" selector="userNamesInGroupNamed:">userNamesInGroupNamed: aString	^self userNamesInGroupNamed: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="userNamesInGroupNamed:in:">userNamesInGroupNamed: aString in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each groupName = aString AND: (each type = 'U')].	query retrieve: [:each | each userName distinct].	^session execute: query</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>database utility</category><body package="Store-Database Model" selector="removeUserNamed:inGroupNamed:">removeUserNamed: aUserName inGroupNamed: aGroupName	self removeUserNamed: aUserName inGroupNamed: aGroupName in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="removeUserNamed:inGroupNamed:in:">removeUserNamed: aUserName inGroupNamed: aGroupName in: aSessionOrNil	| session instance deniedCommands |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	instance := self userNamed: aUserName inGroupNamed: aGroupName in: session.	deniedCommands := 	session accessor deniedCommands.	[session accessor permitEverything.	session inUnitOfWorkDo: 		[session delete: instance]]			ensure: [session accessor deniedCommands: deniedCommands].</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>installation</category><body package="Store-Database Model" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy userAndOwnershipTableSpace</body></methods><methods><class-id>Store.Glorp.StoreUserGroup class</class-id> <category>accessing</category><body package="Store-Database Model" selector="adminGroupName">adminGroupName	^'ADMINISTRATOR'</body><body package="Store-Database Model" selector="groupType">groupType	^'G'</body><body package="Store-Database Model" selector="pundlePrivilegesClass">pundlePrivilegesClass	^StoreAccessPrivilege</body><body package="Store-Database Model" selector="userType">userType	^'U'</body></methods><methods><class-id>Store.InitializerFailedError class</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="enabledExceptForShared:">enabledExceptForShared: aNavigator	('Implementors of*' match:aNavigator environment label) ifTrue: [^false].	^(aNavigator definitions allSatisfy: [:each | each isKindOf: RBInitializerDefinition]) not</body></methods><methods><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="selectors">selectors	selectors isNil 		ifTrue: 			[selectors := StoreNameSpaceItemTabNavigatorPart new.			navigator notNil ifTrue: [selectors navigator: navigator]].	(self componentNamed: #selectors) isNil 		ifTrue: [self componentNamed: #selectors put: selectors].	^selectors</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="convertFromXML:">convertFromXML: aString	| p element out attr value i |	p := XML.XMLParser on: aString readStream.	element := p validate: false; getNextChar; element.	out := (String new: 128) writeStream.	out nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'environment') characterData			quoted: false).	out nextPutAll: ' defineNameSpace: ';		store: (element elementNamed: 'name') characterData asSymbol.	out crtab; nextPutAll: 'private: ';		nextPutAll: (element elementNamed: 'private') characterData.	out crtab; nextPutAll: 'imports: ';		store: (element elementNamed: 'imports') characterData.	out crtab; nextPutAll: 'category: ';		store: (element elementNamed: 'category') characterData.	attr := [element elementNamed: 'attributes'] on: Error do: [:ex | ex return: nil].	attr == nil ifFalse:		[out crtab; nextPutAll: 'attributes: #('.		attr elements do: [:elm |			elm isElement ifTrue:				[out crtab: 3; nextPutAll: '#('; store: elm tag type asSymbol; space.				((elm elements contains: [:e | e isElement]) or: [elm elements isEmpty])					ifTrue: [value := (elm elements select: [:e | e isElement])							collect: [:e | e characterData]]					ifFalse:						[value := elm characterData.						i := #('nil' 'true' 'false') indexOf: value.						value := i = 0 ifTrue: [value asSymbol] ifFalse: [#(nil true false) at: i]].				out store: value; nextPutAll: ')']].		out nextPutAll: ')'].	^out contents</body><body package="Store-DB-Records" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineNameSpace:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'imports' value: (data at: 'imports:') value.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body><body package="Store-DB-Records" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean 	"Load the method. Make sure that it goes to the imPkg. and it does not	overwrites existing definition from another package."	aBoolean ifTrue: 		[(Dialog confirm: #DoYouWantToLoadTheSelectedNamespace &lt;&lt; #store &gt;&gt; 'Do you want to load the selected namespace?') ifFalse: [^self]].	(LoadAnalyzer canLoadNameSpace: self from: imPkg) ifTrue:		[Policies packagePolicy forcePackage: imPkg while: [self loadSrc]]</body><body package="Store-DB-Records" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	XChangeSet current moveNameSpaceDefinition: obj toPackage: imgPackage</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="displayString">displayString	^SystemUtils convertAbsoluteNameToFull: self absoluteName</body><body package="Store-DB-Records" selector="printOn:">printOn: aStream	aStream nextPutAll: 'NameSpace{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>testing</category><body package="Store-DB-Records" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>browser support</category><body package="Store-DB-Records" selector="binding">binding		"No such thing"	^self</body><body package="Store-DB-Records" selector="value">value	^self fullName asStrictReference valueOrDo: [ nil ]</body><body package="Store-DB-Records" selector="valueOrDo:">valueOrDo: aBlock	^self fullName asStrictReference valueOrDo: aBlock</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>public interface</category><body package="Store-DB-Records" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #data	from aDBPackge."	| imPkg ns data |	imPkg := Registry packageNamed: aDBPackage name.	imPkg isNil 		ifTrue: 			[^Dialog 				warn: ((#Package1sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Package &lt;1s&gt; is not loaded.') expandMacrosWith: aDBPackage name)].	ns := ((aSet includes: #definition) or: [aSet includes: #comment]) 				ifTrue: [self]				ifFalse: [nil].	data := (aSet includes: #data) 				ifTrue: [aDBPackage dataForNamed: self absoluteName]				ifFalse: [Array new].	(LoadAnalyzer 		canLoadNameSpace: ns		data: data		from: imPkg) ifFalse: [^self].	(aSet includes: #definition) 		ifTrue: 			[Policies packagePolicy forcePackage: imPkg while: [self loadDefinition]].	" Namespaces don't have comments.....	(aSet includes: #comment)		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadComment]]."	(aSet includes: #data) 		ifTrue: [data do: [:m | m loadSrcIntoPackage: imPkg confirm: false]]</body><body package="Store-DB-Records" selector="loadSrc">loadSrc	"Load a class definition if necessary do not log changes."	^self loadSrcInto: nil.		"whatever the default is"</body><body package="Store-DB-Records" selector="loadSrcInto:">loadSrcInto: imgPackage	"Load a nanespace definition if necessary do not log changes."	| ns |	ns := self loadDefinition: self definition into: imgPackage logged: false.	ns == nil		ifFalse: [ self loadCommentFor: ns ].</body><body package="Store-DB-Records" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveNameSpace: self absoluteName		package: aPackage</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForNameSpace</body><body package="Store-DB-Records" selector="sameAsImThing:">sameAsImThing: aThing 	"Answer true if aThing is defined the same as the receiver."		"Ds- this compares the definition as a string--problem is, 		for non-existant ClassPools there is an error producing this		string. So... punt for now."	^[ ( aThing absoluteName = self absoluteName 			and: [ aThing definitionAndComment = self definitionAndComment ] ) 	] on: Dictionary valueNotFoundSignal do:		[ :exp | exp return: false ].</body><body package="Store-DB-Records" selector="sourceMatches:">sourceMatches: aClass	"Answer whether the source matches."	^aClass definitionAndComment equalsAcrossPlatforms: self definitionAndComment</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>converting</category><body package="Store-DB-Records" selector="asCommentTag">asCommentTag	"Answer an instance of NameSpaceCommentTag"	^NameSpaceCommentTag newNameSpaceName: self absoluteName</body><body package="Store-DB-Records" selector="asDescriptor">asDescriptor	"Answer an instance of ClassDescriptor."	^NameSpaceDescriptor fromModel: self</body><body package="Store-DB-Records" selector="asTag">asTag	"Answer an instance of TT_NameSpaceTag"	^NameSpaceTag newNameSpaceName: self absoluteName</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#namespace</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefinition">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := self definition.	insertPoint := definitionString indexOfSubCollection: 'defineNameSpace:' startingAt: 1.	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Store-DB-Records" selector="symbol">symbol	^self absoluteSymbol</body><body package="Store-DB-Records" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="containingPackages">containingPackages	^[( PkgNameSpaces packagesContainingNameSpace: primaryKey )		collect: [ :id | Package aRecordWithID: id ].	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body></methods><methods><class-id>Store.NameSpaceRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="from:timeStamp:trace:">from: nspace timeStamp: timeStamp trace: oldDB	| env |	env := nspace environment.	^self new		name: nspace name asString;		timeStamp: timeStamp;		environmentString: ( env == nil ifTrue: [ '' ] ifFalse: [ env absoluteName ] );		definitionStr:  nspace definition;		commentStr: nspace comment;		setTrace: oldDB;		yourself.</body></methods><methods><class-id>Store.NameSpaceRecord class</class-id> <category>public interface</category><body package="Store-DB-Records" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| set |	( set := aSet copy )		remove: #methods ifAbsent: [].		super loadComponents: set package: aDBPackage.</body></methods><methods><class-id>Store.NameSpaceRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="associationClass">associationClass	^PkgNameSpaces</body><body package="Store-DB-Records" selector="commentFor:">commentFor: aNS	^aNS comment</body><body package="Store-DB-Records" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_NamespaceName' #('name'))		#('ST_NamespaceTimestamp' #('timeStamp'))		#('ST_NamespaceGCSupport' #('trace'))		)</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn	^#nameSpaceRef</body><body package="Store-DB-Records" selector="sourcesViewClass">sourcesViewClass	^PkgNameSpacesAndSourcesView</body></methods><methods><class-id>Store.Methods</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="methodRef">methodRef	"Answer the receiver's methodRef."	^methodRef</body><body package="Store-DB-Subdefs" selector="methodRef:">methodRef: newMethodRef	"Set the receiver's methodRef to newMethodRef."	methodRef := newMethodRef</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Subdefs" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Subdefs" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self methodRef</body><body package="Store-DB-Subdefs" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self methodRef</body></methods><methods><class-id>Store.Methods</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: packageRef printString;		nextPutAll: ' - ';		nextPutAll: methodRef printString;		nextPut: $).</body></methods><methods><class-id>Store.Methods class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="copyMethodsFromTrace:to:">copyMethodsFromTrace: oldPkgID to: newPkgID 	"Copy all methods present in oldPkgID 	into newPkgID."	self broker process: 		( self newSQL				insert: #( packageRef methodRef );				select: 	( Array with: newPkgID printString with: #methodRef );				where;				column: #packageRef equalTo: oldPkgID printString).</body><body package="Store-DB-Subdefs" selector="removeMethod:inPackage:">removeMethod: mID inPackage: pkgID 	"Remove the row: pkgID, mID"	self broker process: (self newSQL						delete;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #methodRef equalTo: mID printString).</body><body package="Store-DB-Subdefs" selector="replaceMethod:with:inPackage:">replaceMethod: oldID with: newID inPackage: pkgID 	"Replace the row: pkgID, oldID with a row: pkgID, newID"	self broker process: (self newSQL						update;						column: #methodRef equalTo: newID printString;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #methodRef equalTo: oldID printString)</body></methods><methods><class-id>Store.Methods class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'packageRef' put: #PrimaryKey.	aDict at: 'methodRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE ', self tableSpaceName, ' STORAGE(INITIAL 3M NEXT 512K) '</body><body package="Store-DB-Subdefs" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"We need update and delete on TT_Methods to speed up publishing."	super setDatabasePrivilegesForTable.	self broker grantForClass: self permissions: #('UPDATE' 'DELETE') toUsers: #('PUBLIC')</body><body package="Store-DB-Subdefs" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 3M NEXT 512K PCTINCREASE 1) '</body><body package="Store-DB-Subdefs" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy methodsTableSpace</body></methods><methods><class-id>Store.Methods class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="allPackagesMethodsCrossReferenced:">allPackagesMethodsCrossReferenced: packageKeys	"Answer a collection of Methods that includes all the methods referenced by all the packages and	back again."	"Methods allPackagesMethodsCrossReferenced: #( 100 178 )"	| str res stringKeys |	stringKeys := packageKeys collect: [ :k | k printString ].	[ str := self newSQL			selectAll;			where;			column: #methodRef;			in: ( self newSQL					selectDistinct: #( methodRef );					where;					column: #packageRef equalToArray: stringKeys				).	res := self processList: ( self broker process: str bindOutput: self newPrimed ).	DbRegistry printDebug: 'Method&gt;&gt;allPackagesMethodsCrossReferenced:..'; printDebug: res.	] on: self errorSignals  	  do: [ :ex | ex outer. ^OrderedCollection new ].	^res</body><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on methodRef to speed up	garbage collection process."	^self broker createIndexForClass: self</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on methodRef to speed up	garbage collection process."	^self broker dropIndexForClass: self</body><body package="Store-DB-Subdefs" selector="gcSession">gcSession	"Answer a session for retriving all the rows in the methods table."	"Note: there's no point in saving it since this will only be preformed once."	^self broker getNewSession		bindOutput: self newPrimed;		blockFactor: ( self safeBlockFactor: 10000 );		prepare: self newSQL selectAll;		yourself</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames	^ Array with: 'methodRef'</body><body package="Store-DB-Subdefs" selector="indexName">indexName	^'_METHOD_IDX'</body><body package="Store-DB-Subdefs" selector="methodsInAndOnlyIn:">methodsInAndOnlyIn: aSetOfPackageIds	"Answers a set of method refs that are in the packages represented by their ids, 	but not in any other package."	"Methods methodsInAndOnlyIn: #( 100 178 )"	| keep remove |	keep := Set new: ( aSetOfPackageIds size * 500 ).	remove := Set new: ( aSetOfPackageIds size * 50 ).	( self allPackagesMethodsCrossReferenced: aSetOfPackageIds ) do:		[ :row |		( aSetOfPackageIds includes: row packageRef )			ifTrue: 				[ ( keep includes: row methodRef )					ifFalse: [ remove add: row methodRef ]				]			ifFalse: 				[ keep add: row methodRef.				remove remove: row methodRef ifAbsent: nil.				]		].	^remove</body><body package="Store-DB-Subdefs" selector="packagesContainingMethod:">packagesContainingMethod: methodID 	"Check what packages define methodID.	Return a collection of package IDs "	"self packagesContainingMethod: 15"	^ (self broker process: 			( self newSQL				select: #( packageRef );				where;				column: #methodRef equalTo: methodID printString))		collect: [:each| each first]</body></methods><methods><class-id>Store.Methods class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="defaultBlockFactor">defaultBlockFactor	^1000</body></methods><methods><class-id>Store.Methods class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_MethodsReverse' #('methodRef' 'packageRef'))		)</body><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn		^#methodRef</body></methods><methods><class-id>Store.Glorp.PackageResolutions</class-id> <category>displaying</category><body package="Store-Merge Management" selector="browseVersions">browseVersions	| list session |	(Gathering for: name) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value key session].	list := Store.Glorp.StorePackage allVersionsWithName: name in: session.	(Gathering for: name) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: name)].	Store.Glorp.DefinitionForListTool forPackages: list</body><body package="Store-Merge Management" selector="explanationText">explanationText	| values |	values := self createModificationDisplayRecords.	^(#X1shas2pversions &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has &lt;2p&gt; versions.')		expandMacrosWith: name		with: values size</body></methods><methods><class-id>Store.Glorp.PackageResolutions</class-id> <category>accessing</category><body package="Store-Merge Management" selector="pundle">pundle	^pundle</body><body package="Store-Merge Management" selector="pundle:">pundle: aStorePundleOrPundleModel	pundle := aStorePundleOrPundleModel</body><body package="Store-Merge Management" selector="resolutionForDifference:fromVersion:">resolutionForDifference: aPseudoDifference fromVersion: aPackage	| classifiedResolutions |	aPseudoDifference isBundleStructureOnly ifTrue: [^self].	classifiedResolutions := resolutions at: aPseudoDifference classListName ifAbsentPut: [aPseudoDifference referencesHolderClass named: aPseudoDifference classListName].	aPseudoDifference modifiedMethodsSharedAndProperties do:		[:each |		classifiedResolutions resolutionForDifference: each fromVersion: aPackage].</body><body package="Store-Merge Management" selector="sortedTreeResolutionValues:">sortedTreeResolutionValues: aSymbol		| values result rejectBlock |	rejectBlock := self rejectBlockFor: aSymbol.	result := OrderedCollection new.	values := self sortedResolutionsSelectedBy: [:each | each isForClass and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | each isForNamespace and: [(rejectBlock value: each) not]].	result addAll: values.	values := self sortedResolutionsSelectedBy: [:each | each isForProperties and: [(rejectBlock value: each) not]].	result addAll: values.	^result</body><body package="Store-Merge Management" selector="structureDifferenceUsing:fromVersion:">structureDifferenceUsing: aPseudoDifference fromVersion: aPackage	| resolver resolution |	(aPseudoDifference hasBothDefinitions and: [aPseudoDifference mainPackage structure isSameSequenceAs: aPseudoDifference otherPackage structure])		ifTrue: [^self].	resolver := resolutions 		at: self bundleStructureDisplayString		ifAbsentPut: [BundleStructureResolver new].	aPseudoDifference mainPackage ifNotNil: 		[:value |		aPseudoDifference mainPackage isVersionLoaded ifTrue:			[(resolver original isNil or: [aPseudoDifference mainPackage isImageModel]) ifTrue: 				[resolver original: (StandardResolution 					package: aPseudoDifference mainPackage 					resolver: value structure)]].		resolver addAlternative: (StandardResolution 			package: aPseudoDifference mainPackage 			resolver: value structure)].	aPseudoDifference otherPackage ifNotNil: 		[:value | 		| target |		aPseudoDifference otherPackage pseudoPackage ifFalse:			[resolver addAlternative: (target := StandardResolution 				package: aPseudoDifference otherPackage 				resolver: value structure).			resolver base: target.			aPseudoDifference mainPackage isNil				ifTrue: 					[resolution := RemovalResolution 						fromBaseResolution: aPackage -&gt; aPackage structure 						fromPackage: aPackage.					resolver addAlternative: resolution.					resolver original: (aPseudoDifference otherPackage isVersionLoaded 						ifTrue: 							[aPackage isImageObject 								ifTrue: [resolution] 								ifFalse: [target]] 						ifFalse: [resolution])]				ifFalse: 						[aPseudoDifference otherPackage isVersionLoaded						ifTrue: [(resolver original isNil or: [aPseudoDifference otherPackage isImageModel]) ifTrue: [resolver original: target]]						ifFalse: [resolver original isNil ifTrue: [resolver original: target]]]]].	resolver ownerName: name.	^resolver</body><body package="Store-Merge Management" selector="typeIcon">typeIcon	^pundle toolListIcon</body></methods><methods><class-id>Store.Glorp.PackageResolutions</class-id> <category>testing</category><body package="Store-Merge Management" selector="isBundle">isBundle	^pundle isBundle</body><body package="Store-Merge Management" selector="isPackage">isPackage	^self isBundle not</body></methods><methods><class-id>Store.Glorp.PackageResolutions class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="fromPundle:">fromPundle: aPundle	| instance |	instance := self named: aPundle name.	instance pundle: aPundle.	^instance</body></methods><methods><class-id>Store.Blessing</class-id> <category>support</category><body package="Store-DB-BaseObjects" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"	commentString := Object new.</body><body package="Store-DB-BaseObjects" selector="unprime">unprime	"Nil out the slots that do not map to table columns"	commentString := nil.</body></methods><methods><class-id>Store.Blessing</class-id> <category>private-db</category><body package="Store-DB-BaseObjects" selector="installSqlString">installSqlString	"Column names must be String, for consistency with #columnNames"	^ self newSQL		insertColumnsValues:  #( 'primaryKey' 'timeStamp' 'userName' 'commentID' 'blessingLevel' 'trace' 'pkgID' 'recType' ).</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	(self primaryKey isNil ) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"Create record for comment string, if necessary."	self commentID isNil ifTrue: [self commentID: (self class definitionClass fromString: commentString) primaryKey].	"Set primary key and user name."	(self class needsSequenceFor: self class) ifTrue: [self primaryKey: self nextID].	self userName: self currentUserName.</body><body package="Store-DB-BaseObjects" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	self commentString notNil ifTrue: [		self commentString: (self processString: self commentString)]</body></methods><methods><class-id>Store.Blessing</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="descriptionString">descriptionString		| stream |	stream := WriteStream on: String new.	stream		nextPutAll:			(#BlessedBy1sAtLevel2sOn3sN &lt;&lt; #store &gt;&gt; 'Blessed by: &lt;1s&gt; at level: &lt;2s&gt; on: &lt;3s&gt;&lt;n&gt;'				expandMacrosWith: self userNameString				with: self blessingLevelString				with: self timeStampString);		nextPutAll: self getCommentString;		cr.	^stream contents</body></methods><methods><class-id>Store.Blessing</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="blessingLevel">blessingLevel	"Answer the receiver's blessingLevel."	^blessingLevel</body><body package="Store-DB-BaseObjects" selector="blessingLevel:">blessingLevel: newBlessingLevel	"Set the receiver's blessingLevel to newBlessingLevel."	blessingLevel := newBlessingLevel</body><body package="Store-DB-BaseObjects" selector="blessingLevelString">blessingLevelString	| bNbr |	bNbr := blessingLevel isNil ifTrue: [0] ifFalse: [blessingLevel].	^Policies blessingPolicy blessingName: bNbr</body><body package="Store-DB-BaseObjects" selector="commentID">commentID	"Answer the receiver's commentID."	^commentID</body><body package="Store-DB-BaseObjects" selector="commentID:">commentID: newCommentID	"Set the receiver's commentID to newCommentID."	commentID := newCommentID</body><body package="Store-DB-BaseObjects" selector="commentString">commentString	"Answer the receiver's commentString."	^commentString</body><body package="Store-DB-BaseObjects" selector="commentString:">commentString: newCommentString	"Set the receiver's commentString to newCommentString."	commentString := newCommentString</body><body package="Store-DB-BaseObjects" selector="dbTrace">dbTrace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="dbTrace:">dbTrace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="getCommentString">getCommentString	| defClass |	commentString == nil		ifTrue: 			[  ( defClass := self class definitionClass aRecordWithID: self commentID ) isNil				ifTrue: [  self commentString: String new]				ifFalse: [ self commentString: defClass  definition ]			].	^commentString</body><body package="Store-DB-BaseObjects" selector="pkgID">pkgID	"Answer the receiver's pkgID."	^pkgID</body><body package="Store-DB-BaseObjects" selector="pkgID:">pkgID: newPkgID	"Set the receiver's pkgID to newPkgID."	pkgID := newPkgID</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	"Answer the receiver's primaryKey."	^primaryKey</body><body package="Store-DB-BaseObjects" selector="primaryKey:">primaryKey: newPrimaryKey	"Set the receiver's primaryKey to newPrimaryKey."	primaryKey := newPrimaryKey</body><body package="Store-DB-BaseObjects" selector="recType">recType	"Answer the receiver's recType."	^recType</body><body package="Store-DB-BaseObjects" selector="recType:">recType: newRecType	"Set the receiver's recType to newRecType."	recType := newRecType</body><body package="Store-DB-BaseObjects" selector="timeStamp">timeStamp	"Answer the receiver's timeStamp."	^timeStamp</body><body package="Store-DB-BaseObjects" selector="timeStamp:">timeStamp: newTimeStamp	"Set the receiver's timeStamp to newTimeStamp."	timeStamp := newTimeStamp</body><body package="Store-DB-BaseObjects" selector="trace">trace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="trace:">trace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="userName">userName	"Answer the receiver's userName."	^userName</body><body package="Store-DB-BaseObjects" selector="userName:">userName: newUserName	"Set the receiver's userName to newUserName."	userName := newUserName</body><body package="Store-DB-BaseObjects" selector="userNameString">userNameString	^userName isNil 		ifTrue: [(#Unknown &lt;&lt; #store &gt;&gt; 'Unknown') asString]		ifFalse: [userName]</body></methods><methods><class-id>Store.Blessing class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'primaryKey' put: #PrimaryKey.	aDict at: 'timeStamp' put: #Integer.	aDict at: 'pkgID' put: #Integer.	aDict at: 'trace' put: #Integer.	aDict at: 'commentID' put: #Integer.	aDict at: 'blessingLevel' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="needsSequence">needsSequence	^true</body><body package="Store-DB-BaseObjects" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 1M NEXT 100K PCTINCREASE 1) '</body></methods><methods><class-id>Store.Blessing class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="columnNames">columnNames	| columnNames |	columnNames := super columnNames.	columnNames remove: 'commentString'.	^columnNames</body><body package="Store-DB-BaseObjects" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_BlessingTimestamp' #('timeStamp'))		#('ST_BlessingGCSupport' #('trace'))		#('ST_BlessingPkgType' #('pkgID' 'recType'))		)</body><body package="Store-DB-BaseObjects" selector="typeStringForBundles">typeStringForBundles	^'B'</body><body package="Store-DB-BaseObjects" selector="typeStringForPackages">typeStringForPackages	^'P'</body></methods><methods><class-id>Store.Blessing class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB."	"self aRecordWithID: 1"	| dbPkgs |	anID = 0 ifTrue: [ ^nil ].	dbPkgs := [ self processList: 						(self broker process: 							( self newSQL								selectAll;								where;								column: #primaryKey equalTo: anID printString)				bindOutput: self newPrimed)	]	on:  self errorSignals	do: [ :ex |  ex outer.			self table select: [ :each | each primaryKey = anID]		].	^dbPkgs isEmpty		ifTrue: [ nil ]		ifFalse: [ dbPkgs first ]</body><body package="Store-DB-BaseObjects" selector="blessingHistoryForPackageID:">blessingHistoryForPackageID: anID 	"Answer a formattted string containing blessing history for 	a given package."	"self blessingHistoryForPackageID: 1"	| records |	anID = 0 ifTrue: [^nil].	DbRegistry isOnlineImage ifFalse: 		[^(#unknown &lt;&lt; #store &gt;&gt; 'unknown') asString].	"not important enough for a dialog."	records := self blessingsForPackageID: anID.	^Policies blessingPolicy describeBlessings: records</body><body package="Store-DB-BaseObjects" selector="blessingHistoryForPundle:">blessingHistoryForPundle: aPundle 	"Answer a formattted string containing blessing history for a given pundle."	aPundle primaryKey = 0 ifTrue: [^nil].	self isOnline ifFalse: [^(#unknown &lt;&lt; #store &gt;&gt; 'unknown') asString].	^	[Policies blessingPolicy 		describeBlessings: (self blessingsForRecordID: aPundle primaryKey				type: aPundle typeStringForBlessing)] 			on: self errorSignals			do: [:ex | (#unknown &lt;&lt; #store &gt;&gt; 'unknown') asString]</body><body package="Store-DB-BaseObjects" selector="blessingsForPackageID:">blessingsForPackageID: anID 	"Get a sorted collection DB records which define belssing levels for a package.	Sort the collection is descending order of primary key."	"self blessingsForPackageID: 3"	^self blessingsForRecordID: anID type: self typeStringForPackages</body><body package="Store-DB-BaseObjects" selector="blessingsForRecordID:type:">blessingsForRecordID: anID type: aRecordTypeString 	"Get a sorted collection DB records which define belssing levels for a package 	or a bundle. Sort the collection is descending order of primary key."	"self blessingsForRecordID: 3 type: self typeStringForPackages"	| inputObject |	inputObject := self newPrimed.	inputObject pkgID: anID; recType: aRecordTypeString.	anID = 0 ifTrue: [^nil].	^[( self processList:			( self broker process: 					(self newSQL						selectAll;						where;						column: #pkgID equalTo: ':pkgID';						and;						column: #recType equalTo: ':recType')				bindInput: inputObject				bindOutput: self newPrimed)		)  asSortedCollection: [ :x :y | x timeStamp &gt; y timeStamp ]	]	on:  self  errorSignals	do: [ :ex | ex outer.			OrderedCollection new ].</body><body package="Store-DB-BaseObjects" selector="definitionClass">definitionClass		^Blob</body></methods><methods><class-id>Store.Blessing class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="forPundle:withLevel:andComment:">forPundle: aDBPundle withLevel: anInteger andComment: aString 	| blessing |	DBObject resetServerTimestamp.	blessing := self new.	blessing		commentString: aString asString;		pkgID: aDBPundle primaryKey;		blessingLevel: anInteger;		timeStamp: self timeStamp;		recType: aDBPundle typeStringForBlessing.	self broker publishTransaction: 		[blessing install.		aDBPundle updateBlessing: anInteger].	^blessing</body></methods><methods><class-id>Store.Blessing class</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="attachedToPundle:">attachedToPundle: aPundle 	"Answer a collection of blessing records that are attached to a given pundle"	^self blessingsForRecordID: aPundle primaryKey type: aPundle typeStringForBlessing</body><body package="Store-DB-BaseObjects" selector="removeAllAttachedToPackageID:">removeAllAttachedToPackageID: aPackageID 	"Remove any record from the table which references aPackageID.	Note that this method can only be sent by the database	system administrator, since it requires privileges	that are not given to the regular users."	self deleteWhereColumn:  #pkgID value: aPackageID printString.</body><body package="Store-DB-BaseObjects" selector="removeAllAttachedToPundle:">removeAllAttachedToPundle: aPundle 	"Remove any record from the table which references aPundle.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self broker process:			( self newSQL				delete;				where;				column: #pkgID equalTo: aPundle primaryKey printString;				and;				column: #recType equalTo: aPundle typeStringForBlessing printString)</body></methods><methods><class-id>Store.Files</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDBComponent">asDBComponent	"Answer a corresponding FileRecord."	| rec |	[ rec := FileRecord aRecordWithID: fileRef.]		on: self errorSignals		do: [ :ex | ex outer. ^nil ].		rec isNil ifTrue: [ FileRecord componentNotFoundSignal raiseWith: self ].	^rec</body><body package="Store-DB-Pundles" selector="fileRef">fileRef	^fileRef</body><body package="Store-DB-Pundles" selector="fileRef:">fileRef: anObject	fileRef := anObject</body></methods><methods><class-id>Store.Files</class-id> <category>private</category><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription		| baby |	baby := FileModel new.	baby dbTrace: fileRef.	fileRef notNil		ifTrue: [ baby portableFilename: self asDBComponent filename ].	^baby</body></methods><methods><class-id>Store.Files class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'fileRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Files class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_FilesReverse' #('fileRef'))		)</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="shadowBindingAt:elseDo:">shadowBindingAt: aPath elseDo: aBlock	"Find and return the binding at aPath.  First look for the binding in the shadow 	 of Smalltalk. If no binding can be found, then use an instance of NameSpaceSearchRules	 to modify the look-up to try to find the binding in the system.   Finally, if no binding is found	 evaluate aBlock."	|modifiers|	modifiers := NameSpaceSearchRules new.	modifiers substitutions: Root.	^(self shadowRoot at: #Smalltalk)		bindingForPath: aPath		modifiers: modifiers		onMiss: [:env :aName | aBlock value]</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(';		print: self shadowRoot;		nextPutAll: ')'</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="shadowRoot">shadowRoot	^shadowRoot</body><body package="Atomic Compiling and Loading" selector="shadowRoot:">shadowRoot: aNameSpace	shadowRoot := aNameSpace</body></methods><methods><class-id>Kernel.ShadowNameSpaceHandler</class-id> <category>resolving</category><body package="Atomic Compiling and Loading" selector="resolveBindingForShadow:protection:elseDo:">resolveBindingForShadow: binding protection: protection elseDo: aBlock 	((binding isKindOf: LiteralBindingReference) and: 			[binding isAbsolute 				and: [binding method environment = (self shadowRoot)]]) 		ifTrue: [^self shadowBindingAt: binding path elseDo: aBlock].	^aBlock value</body></methods><methods><class-id>Store.TextModification</class-id> <category>testing</category><body package="Store-Change Management" selector="isTextModification">isTextModification		^true</body><body package="Store-Change Management" selector="notOriginallyInImage">notOriginallyInImage	^false</body></methods><methods><class-id>Store.TextModification</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aMod 	^aMod notNil and: [aMod isTextModification and: [aMod isMoveModification not and: [aMod text = self text and: [aMod packageName = self packageName and: [aMod tag = self tag]]]]]</body></methods><methods><class-id>Store.TextModification</class-id> <category>accessing</category><body package="Store-Change Management" selector="description">description	^((#x1sSpace &lt;&lt; #store &gt;&gt; '&lt;1s&gt; ') expandMacrosWith: self packageName)</body><body package="Store-Change Management" selector="existsInPackage">existsInPackage	^text notNil</body><body package="Store-Change Management" selector="record">record	^nil</body><body package="Store-Change Management" selector="source">source	^text</body><body package="Store-Change Management" selector="text:">text: sourceCode	text := sourceCode</body><body package="Store-Change Management" selector="timeStampString">timeStampString	^''</body></methods><methods><class-id>Store.TextModification</class-id> <category>actions</category><body package="Store-Change Management" selector="apply">apply	"Apply a modification to the image."	"| imPkg | 	imPkg := TT_Registry packageNamed: packageName.	imPkg isNil ifTrue: [self error: 'Package ' , packageName , ' not found.'].	tag existsInImage		ifTrue: 			[| oldPkg |			oldPkg := tag containingPackage.			oldPkg isNil ifTrue: [self error: 'No containing package for: ' , tag printString].			oldPkg = imPkg ifFalse: [self halt]]."	self notify: tag printString</body></methods><methods><class-id>Store.TextModification</class-id> <category>change list support</category><body package="Store-Change Management" selector="category">category	^tag isForMethod		ifTrue: [ tag category ]</body><body package="Store-Change Management" selector="sameAsSystem">sameAsSystem	"No record, so this is the system."	^true</body><body package="Store-Change Management" selector="systemCategory">systemCategory	^tag isForMethod		ifTrue: [ tag systemCategory ]</body><body package="Store-Change Management" selector="text">text	"Asnwer the text to display in a text window."	^text</body></methods><methods><class-id>Store.TextModification class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="tag:package:text:">tag: aTag package: aPackage text: sourceCode	^self new tag: aTag; package: aPackage; text: sourceCode</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreDefinitionObject	(super reconcilesWith: aStoreDefinitionObject) ifFalse: [^false].	self protocol = aStoreDefinitionObject protocol ifFalse: [^false].	self isClassVariable = aStoreDefinitionObject isClassVariable ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="absoluteOwnerName">absoluteOwnerName	^self environmentName asSymbol.</body><body package="Store-Database Model" selector="actual">actual	^self correspondingImageSharedVariable</body><body package="StoreForGlorpVWUI" selector="classNameWithoutMeta">classNameWithoutMeta	^self absoluteOwnerName, '.' , self name</body><body package="Store-Database Model" selector="dataKey">dataKey	^self name asSymbol.</body><body package="Store-Database Model" selector="key">key	^self dataKey</body><body package="StoreForGlorpVWUI" selector="ownerName">ownerName	| stream |	stream := self environmentName reverse readStream.	^(stream upTo: $.) reverse asSymbol.</body><body package="Store-Database Model" selector="protocol">protocol	^protocol</body><body package="Store-Database Model" selector="protocol:">protocol: aString	protocol := aString.</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineSharedVariable:' startingAt: 1.	insertPoint isZero ifTrue: [insertPoint := definitionString indexOfSubCollection: 'defineStatic:' startingAt: 1].	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Store-Database Model" selector="xmlDefinition">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>testing</category><body package="Store-Database Model" selector="belongsToClass">belongsToClass	^self isClassVariable.</body><body package="Store-Database Model" selector="definitionForShared:">definitionForShared: aVariableBinding		| namespace |	namespace := Root whoDefinesBinding: aVariableBinding.	^namespace isNil 		ifTrue: [''] 		ifFalse: [namespace definitionOfStatic: aVariableBinding]</body><body package="Store-Database Model" selector="isClassVariable">isClassVariable	^isClassVariable</body><body package="Store-Database Model" selector="isClassVariable:">isClassVariable: aBoolean	isClassVariable := aBoolean.</body><body package="Store-Database Model" selector="isForData">isForData	^true.</body><body package="Store-Database Model" selector="isForSharedVariable">isForSharedVariable	^true</body><body package="Store-Database Model" selector="isInClass">isInClass	^self isClassVariable</body><body package="Store-Database Model" selector="isInNameSpace">isInNameSpace	^isClassVariable not</body><body package="Store-Database Model" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version.	We compare the definition string of me vs the definition string of my binding in the image if there is one"		| theSharedVariable sharedDefinition |	theSharedVariable := self correspondingImageBinding.	theSharedVariable isNil ifTrue: [^false].	sharedDefinition := theSharedVariable isForGeneral		ifTrue: [self definitionForShared: theSharedVariable]		ifFalse: [theSharedVariable value definition].	^self definitionString = sharedDefinition</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>converting</category><body package="Store-Database Model" selector="asStoreObjectInPackage:">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage sharedVariables		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: Store.Glorp.StoreSharedVariableInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="StoreForGlorpVWUI" selector="asStoreSharedVariable">asStoreSharedVariable	^self</body><body package="Store-Database Model" selector="correspondingImageBinding">correspondingImageBinding	"Return the image binding variable that corresponds to our name. Note that they may not have the same information."	| owner |	owner := (Dialect smalltalkAt: self absoluteOwnerName asString ifAbsent: [^nil]).	^owner bindingFor: self dataKey</body><body package="Store-Database Model" selector="correspondingImageSharedVariable">correspondingImageSharedVariable	"Return the image shared variable that corresponds to our name. Note that they may not have the same information."	^(Dialect smalltalkAt: self longName ifAbsent: [nil])</body><body package="Store-Database Model" selector="removeFromImage">removeFromImage	self correspondingImageSharedVariable ifNotNil: [self longName asQualifiedReference removeFromSystem]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data sName eName init |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'shared-variable' atts: nil.	sName := (data at: 'defineSharedVariable:' ifAbsent: [data at: 'defineStatic:']) value asString.	self sax: driver tag: 'name' value: sName.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'constant' value: (data at: 'constant:') value printString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	init := ( init := (data at: 'initializer:' ) value ) == nil		ifFalse: [ self sax: driver tag: 'initializer' value: init asString ].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource	"Answer nil if there is a failure, otherwise the real thing"	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	[[binding := Compiler evaluate: self definitionString]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: UnhandledException			do:				[:exception | 				Store.UnloadableDefinitionError signalWith: self.				^nil].	Undeclared purgeUnusedBindings.	(Undeclared includesKey: binding name) ifTrue:		[Transcript show: (#NSharedVariable1pNotLoadable &lt;&lt; #dialogs &gt;&gt; '&lt;n&gt;Shared Variable &lt;1p&gt; is not loadable... Possible load order problem&lt;n&gt;' expandMacrosWith: binding name).		Store.UnloadableDefinitionError signalWith: self.		^nil].	^self</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	"Answer nil if there is a failure, otherwise the real thing"	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	[[binding := Compiler evaluate: self definitionString]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: UnhandledException			do:				[:exception | 				Store.UnloadableDefinitionError signalWith: self.				^nil].	(Undeclared includesKey: binding name) ifTrue:		[Undeclared removeKey: binding name.		self correspondingImageBinding isNil ifTrue: [^nil]].	^self</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>fileIn/Out</category><body package="Store-Database Model" selector="fileOutObjectType">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#variable</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="displayString">displayString	^self name</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>comparing</category><body package="Store-Database Model" selector="equalsSignatureIn:">equalsSignatureIn: aStoreDefinitionObject	self environmentName = aStoreDefinitionObject environmentName ifFalse: [^false].	self name = aStoreDefinitionObject name ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="signatureHash">signatureHash	^self environmentName hash bitXor: self name hash</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="owner">owner	| possibleOwner |	possibleOwner := (Dialect smalltalkAt: self environmentName ifAbsent: [^nil]).	possibleOwner isObsolete ifFalse: [^possibleOwner].	Dialect reset.	^(Dialect smalltalkAt: self environmentName ifAbsent: [nil]).</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeShared: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedSharedVariableObject</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable</class-id> <category>filling out</category><body package="Store-Database Model" selector="fileOutOn:">fileOutOn: aStream	self fileOutDefinitionOn: aStream</body></methods><methods><class-id>Store.Glorp.StoreSharedVariable class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="allVersionsNamed:inOwner:in:">allVersionsNamed: aSharedVariableName inOwner: anOwnerNameString in: aSessionOrNil		| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each name = aSharedVariableName AND: each environmentName = anOwnerNameString].	query orderBy: [:each | each timestamp descending].	^session execute: query</body><body package="Store-Database Model" selector="selectVersionNamed:inOwner:">selectVersionNamed: aSharedVariableName inOwner: anOwnerNameString	^self selectVersionNamed: aSharedVariableName inOwner: anOwnerNameString in: nil</body><body package="Store-Database Model" selector="selectVersionNamed:inOwner:in:">selectVersionNamed: aSharedVariableName inOwner: anOwnerNameString in: aSessionOrNil		| versions |	versions := self allVersionsNamed: aSharedVariableName inOwner: anOwnerNameString in: aSessionOrNil.	versions isEmpty ifTrue: 		[Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'.		^nil].	versions size == 1 ifTrue: [^versions first].	^Dialog 		choose: #ChooseVersion &lt;&lt; #store &gt;&gt; 'Choose version...'		fromList: (versions collect: [:m | m fullDisplayString])		values: versions		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.RequestImageAdministatorName</class-id> <category>constants</category><body package="Store-Base" selector="defaultResumeValue">defaultResumeValue	^DbRegistry userName</body><body package="Store-Base" selector="defaultReturnValue">defaultReturnValue	^DbRegistry userName</body></methods><methods><class-id>Store.RequestImageAdministatorName</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	| adminName |	[(adminName := Dialog 		request: #ImageAdministratorName &lt;&lt; #store &gt;&gt; 'Image Administrator Name:'								initialAnswer: DbRegistry tableOwner) notEmpty] whileFalse.	^adminName</body></methods><methods><class-id>Store.RequestImageAdministatorName class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.AbsentResolution</class-id> <category>testing</category><body package="Store-Merge Management" selector="isAbsentResolution">isAbsentResolution	^true</body><body package="Store-Merge Management" selector="isDoNothingResolution">isDoNothingResolution	^true</body><body package="Store-Merge Management" selector="proposed">proposed	^true</body><body package="Store-Merge Management" selector="value">value	^(#StarsDoNotApplyChangeStars &lt;&lt; #store &gt;&gt; '*** Do Not Apply Change ***') asString</body></methods><methods><class-id>Store.Glorp.AbsentResolution</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	applied := false</body></methods><methods><class-id>Store.Glorp.AbsentResolution</class-id> <category>accessing</category><body package="Store-Merge Management" selector="key">key 	^nil</body></methods><methods><class-id>Store.AbstractPseudo</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="isExtension">isExtension	^true</body><body package="Store-DB-BaseObjects" selector="isPseudo">isPseudo	^true.</body></methods><methods><class-id>Store.AbstractPseudo</class-id> <category>comparing</category><body package="Store-DB-BaseObjects" selector="&lt;=">&lt;= aDescriptor	^self absoluteName &lt;= aDescriptor absoluteName</body><body package="Store-DB-BaseObjects" selector="=">= aThing	^self comparesTo: aThing</body><body package="Store-DB-BaseObjects" selector="comparesTo:">comparesTo: aThing	"Answer true if anObject could be another version of the receiver."	self subclassResponsibility</body><body package="Store-DB-BaseObjects" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	self subclassResponsibility</body><body package="Store-DB-BaseObjects" selector="sameAsDBThing:">sameAsDBThing: aThing	^aThing isExtension and: [aThing name = self name]</body><body package="Store-DB-BaseObjects" selector="sameAsImThing:">sameAsImThing: aThing	^aThing isExtension and: [self name = aThing name]</body></methods><methods><class-id>Store.AbstractPseudo</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="absoluteName">absoluteName	^name</body><body package="Store-DB-BaseObjects" selector="absoluteSymbol">absoluteSymbol	^self absoluteName asSymbol</body><body package="Store-DB-BaseObjects" selector="actual">actual	^nil		"don't exist"</body><body package="Store-DB-BaseObjects" selector="comment">comment		^(#NotDefinedInThisPackage &lt;&lt; #store &gt;&gt; 'Not defined in this package') asString</body><body package="Store-DB-BaseObjects" selector="definition">definition		^(#NotDefinedInThisPackage &lt;&lt; #store &gt;&gt; 'Not defined in this package') asString</body><body package="Store-DB-BaseObjects" selector="definitionAndComment">definitionAndComment		^(#NotDefinedInThisPackage &lt;&lt; #store &gt;&gt; 'Not defined in this package') asString</body><body package="Store-DB-BaseObjects" selector="fullName">fullName	^name</body><body package="Store-DB-BaseObjects" selector="symbol">symbol	^self absoluteSymbol</body><body package="Store-DB-BaseObjects" selector="timeStampString">timeStampString		^(#NotDefinedInThisPackage &lt;&lt; #store &gt;&gt; 'Not defined in this package') asString</body><body package="Store-DB-BaseObjects" selector="version">version	^'--'</body><body package="Store-DB-BaseObjects" selector="xmlDefinition">xmlDefinition		^'&lt;do-it&gt;"Not defined in this package"&lt;/do-it&gt;'</body></methods><methods><class-id>Store.AbstractPseudo</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="displayString">displayString	^SystemUtils convertAbsoluteNameToFull: self absoluteName</body><body package="Store-DB-BaseObjects" selector="storeOn:">storeOn: aStream	"Append to the argument aStream the global names of the receiver."	aStream nextPutAll: self fullName</body><body package="Store-DB-BaseObjects" selector="versionString">versionString	^''</body></methods><methods><class-id>Store.AbstractPseudo</class-id> <category>browser support</category><body package="Store-DB-BaseObjects" selector="binding">binding		"No such thing"	^self</body><body package="Store-DB-BaseObjects" selector="containingPackages">containingPackages	^#( )</body><body package="Store-DB-BaseObjects" selector="isForClass">isForClass			^false</body><body package="Store-DB-BaseObjects" selector="isForNameSpace">isForNameSpace			^false</body><body package="Store-DB-BaseObjects" selector="valueOrDo:">valueOrDo: aBlock	"Does not exist in the image (ie. has no value), so execute the block."	^aBlock value</body></methods><methods><class-id>Store.AbstractPseudo class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="newNamed:">newNamed: aName 	^(self new)		name: aName asString;		yourself</body></methods><methods><class-id>Store.PseudoClass</class-id> <category>testing</category><body package="Store-DB-Records" selector="isForClass">isForClass	^true</body><body package="Store-DB-Records" selector="isMeta">isMeta	^name namesMetaClass</body></methods><methods><class-id>Store.PseudoClass</class-id> <category>accessing</category><body package="Store-DB-Records" selector="absoluteName">absoluteName	^name asClassNameOnly</body><body package="Store-DB-Records" selector="classNameWithMeta">classNameWithMeta	^name</body><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType	^#class</body><body package="Store-DB-Records" selector="name">name	^( name asClassNameOnly tokensBasedOn: $.) last</body><body package="Store-DB-Records" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isClassCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body></methods><methods><class-id>Store.PseudoClass</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	(self objectIsForSelf: anObject) ifFalse: [^false].	^self absoluteName = anObject absoluteName."	^name = anObject classNameWithMeta.  "</body><body package="Store-DB-Records" selector="hash">hash	^self absoluteName hash</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForClass</body></methods><methods><class-id>Store.PseudoClass class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="named:meta:">named: aName meta: isMeta	^isMeta		ifTrue: [ self newNamed: aName, ' class' ]		ifFalse: [ self newNamed: aName asString ].</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>installation</category><body package="Atomic Compiling and Loading" selector="gatherDefinitionsToRemoveInto:">gatherDefinitionsToRemoveInto: aDictionary	contents do: [:each | each gatherDefinitionsToRemoveInto: aDictionary].</body><body package="Atomic Compiling and Loading" selector="runPostLoadUsing:">runPostLoadUsing: anAtomicAnalysisLoader	contents do: [:each | each runPostLoadUsing: anAtomicAnalysisLoader].	(installed not and: [hasRunPostload not and: [contents allSatisfy: #completedAnalysis]]) ifTrue: 		[pundleModel ifNil: [pundleModel := pundle createImagePundle].		pundle postLoad: pundleModel.		anAtomicAnalysisLoader hasUnloadableDefinitions			ifFalse: [pundleModel markNotModified].		hasRunPostload := true].</body><body package="Atomic Compiling and Loading" selector="runPreLoad">runPreLoad	hasRunPreload ifFalse: 		[(contents anySatisfy: #hasSomethingAnalyzed) ifTrue:			[pundle runPreLoad.			pundleModel := [pundle createImagePundle]				on: MessageNotUnderstood				do: [:exception | exception return: pundle storeModel].			hasRunPreload := true]].	contents do: [:each | each runPreLoad ifFalse: [^false]].	^true</body><body package="Atomic Compiling and Loading" selector="updateForPackageRecompile">updateForPackageRecompile	contents do: [:each | each updateForPackageRecompile].</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="pundle:">pundle: aStoreBundle	super pundle: aStoreBundle.	aStoreBundle componentsInOrderDo: 		[:each |		| installObject |		each runPreRead ifTrue:			[installObject := contents add: each asAtomicInstallObject.			installObject parentInstallObject: self]]</body><body package="Atomic Compiling and Loading" selector="smartMarkInstalled">smartMarkInstalled		completedAnalysis ifTrue: [self installed: true].	contents do: [:each | each installed not ifTrue: [each smartMarkInstalled]]</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="visit:">visit: aBlock	super visit: aBlock.	contents do: [:each | each visit: aBlock]</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading" selector="initialize">initialize	super initialize.	contents := OrderedCollection new</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="hasSomethingAnalyzed">hasSomethingAnalyzed	^contents anySatisfy: #hasSomethingAnalyzed</body><body package="Atomic Compiling and Loading" selector="isBundle">isBundle	^true</body></methods><methods><class-id>Store.BundleInstall</class-id> <category>analysis</category><body package="Atomic Compiling and Loading" selector="analyzeUsing:">analyzeUsing: anAtomicAnalysisLoader	(Analyzing for: pundle) started.	anAtomicAnalysisLoader lastPundleWorkedOn: pundle.	contents do: [:each | each analyzeUsing: anAtomicAnalysisLoader].	completedAnalysis := true.	(Analyzing for: pundle) finished.	(pundle propertyAt: #installBeforeContinuing ifAbsent: [self]) == self ifFalse: 		[EarlyInstallNotice raiseSignal].</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>interface opening</category><body package="Store-Merge Management" selector="emptyLableAndIcon">emptyLableAndIcon 	^LabelAndIcon with: ''.</body><body package="Store-Merge Management" selector="labelForPackageAtIndex:inView:">labelForPackageAtIndex: anInteger inView: aView 	| label icon rec |	selectedResolution isNil 		ifTrue: [^self emptyLableAndIcon].	rec := self packageList list at: anInteger.	label := LabelAndIcon 		with: rec labelText		attributes: aView textStyle.	icon := rec icon.	icon isNil 		ifTrue: [label offset: 20 @ 0]		ifFalse: [label icon: icon].	^label</body><body package="Store-Merge Management" selector="postBuildWith:">postBuildWith: aBuilder 	"Replace controller with one with more sanity."	super postBuildWith: aBuilder.	(builder window)		application: self;		sendWindowEvents: #(#newGraphicsDevice #reopen).	(aBuilder componentAt: #ModTabs) widget tabBar component		displayStringSelector: #tabLabel.	self setupPackageListWidget.	self setupTextWidget.	self compareWithHolderChanged.</body><body package="Store-Merge Management" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	builder window damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	builder window toolbarVisible: ShowToolbar.	self updateToolbar.	self displayInitialList.</body><body package="Store-Merge Management" selector="reverseLabel:">reverseLabel: aLabel 	"Build the wrappers needed to reverse the label to show it selected."	| rw |	rw := ReversingWrapper on: aLabel.	rw reverse setValue: true.	^BoundedWrapper on: rw</body><body package="Store-Merge Management" selector="setupPackageListWidget">setupPackageListWidget	| listView |	listView := self packageListWidget.	listView selectedVisualBlock: 			[:view :index | 			self reverseLabel: (self labelForPackageAtIndex: index inView: view)].	listView visualBlock: 			[:view :index | 			BoundedWrapper on: (self labelForPackageAtIndex: index inView: view)]</body><body package="Store-Merge Management" selector="setupTextWidget">setupTextWidget	(builder componentAt: #displayTextID) widget controller autoAccept: false</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>aspects</category><body package="Store-Merge Management" selector="compareWithHolder">compareWithHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^compareWithHolder isNil		ifTrue:			[compareWithHolder := nil asValue]		ifFalse:			[compareWithHolder]</body><body package="Store-Merge Management" selector="conflictProtocol">conflictProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^conflictProtocol isNil		ifTrue:			[conflictProtocol := Text new asValue]		ifFalse:			[conflictProtocol]</body><body package="Store-Merge Management" selector="conflictProtocolText">conflictProtocolText		conflictType == #conflictsWithImage ifTrue: [^selectedResolution originalProtocol].	conflictType == #conflictsWithBase ifTrue: [^selectedResolution baseProtocol].	conflictType == #conflictsWithResolution ifTrue: [^selectedResolution proposedProtocol].	^''</body><body package="Store-Merge Management" selector="conflictText">conflictText	"Answer the text to display in the conflict text pane."	^conflictText</body><body package="Store-Merge Management" selector="displayText">displayText	^displayText</body><body package="Store-Merge Management" selector="isShowingCodeDifferences">isShowingCodeDifferences	^differencesType = #showCodeDifferences.</body><body package="Store-Merge Management" selector="isShowingSourceDifferences">isShowingSourceDifferences	^differencesType = #showSourceDifferences.</body><body package="Store-Merge Management" selector="packageList">packageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageList isNil		ifTrue:			[packageList := MultiSelectionInList new]		ifFalse:			[packageList]</body><body package="Store-Merge Management" selector="resolutionListTabs">resolutionListTabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^resolutionListTabs isNil		ifTrue:			[resolutionListTabs := SelectionInList new]		ifFalse:			[resolutionListTabs]</body><body package="Store-Merge Management" selector="selectionProtocol">selectionProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectionProtocol isNil		ifTrue:			[selectionProtocol := Text new asValue]		ifFalse:			[selectionProtocol]</body><body package="Store-Merge Management" selector="setConflictText">setConflictText	| selectionText compareText selectionFragments compareFragments |	selectionText := self displayText value.	(selectedResolution == nil or: 			[self packageListIndexes isEmpty				or: [selectedResolution notNil and: [selectedResolution isResolver not]]])		ifTrue: 			[selectionText emphasizeAllWith: #normal.			^conflictText value: Text new].	conflictType == #conflictsWithImage		ifTrue: [compareText := self imageText].	conflictType == #conflictsWithBase ifTrue: [compareText := self baseText].	conflictType == #conflictsWithResolution		ifTrue: [compareText := self resolutionText].	selectionFragments := selectionText smalltalkOrWordAndWhitespaceFragments.	compareFragments := compareText smalltalkOrWordAndWhitespaceFragments.	(compareFragments differences: selectionFragments)		do: #applyAnyDifferenceTextEmphases.	textMode := #internal.	displayText value: selectionText.	textMode := #external.	conflictText value: compareText</body><body package="Store-Merge Management" selector="showCodeDifferences">showCodeDifferences	differencesType := #showCodeDifferences.	self updateText</body><body package="Store-Merge Management" selector="showSourceDifferences">showSourceDifferences	differencesType := #showSourceDifferences.	self updateText.</body><body package="Store-Merge Management" selector="sourceCompareMenu">sourceCompareMenu	| menu |	menu := Menu new.	menu		addItem: ((MenuItem labeled: (#BaseColonSpace &lt;&lt; #store &gt;&gt; 'Base: ') asText							, self baseLabel asText allBold)					value: #conflictsWithBase);		addItem: ((MenuItem					labeled: (#ResolutionColonSpace &lt;&lt; #store &gt;&gt; 'Resolution: ') asText							, self resolutionLabel asText allBold)						value: #conflictsWithResolution);		addItem: ((MenuItem labeled: (#ImageColonSpace &lt;&lt; #store &gt;&gt; 'Image: ') asText							, self imageLabel asText allBold)					value: #conflictsWithImage).	^menu</body><body package="Store-Merge Management" selector="sourceCompareMenuBlock">sourceCompareMenuBlock	^[self sourceCompareMenu]</body><body package="Store-Merge Management" selector="toolbarMenuHolder">toolbarMenuHolder	toolbarMenuHolder isNil ifTrue:		[toolbarMenuHolder := self class toolbarMenu asValue].	^toolbarMenuHolder</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>testing</category><body package="Store-Merge Management" selector="areTextViewsZoomed">areTextViewsZoomed	^(self builder componentAt: #pkgListID) isVisible not</body><body package="Store-Merge Management" selector="autoSelectResolution">autoSelectResolution	^autoSelectResolution</body><body package="Store-Merge Management" selector="canApplyResolution">canApplyResolution	^selectedResolution notNil and:		[(self currentResolutionPackageItem notNil and:		[self currentResolutionPackageItem proposed and:		[selectedResolution isApplyable]]) or:		[selectedResolution isResolved]]</body><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^selectedResolution notNil and:		[selectedResolution canBrowseVersions]</body><body package="Store-Merge Management" selector="canChooseDoNotResolve">canChooseDoNotResolve	^selectedResolution notNil</body><body package="Store-Merge Management" selector="canCompareWithResolution">canCompareWithResolution		^self versionSelected and: [selectedResolution isResolved]</body><body package="Store-Merge Management" selector="canExpandHierarchy">canExpandHierarchy	^self resolutionListTabs selection isKindOf: ResolutionsTreePane</body><body package="Store-Merge Management" selector="canResolve">canResolve	^packageList selectionIndexes size = 1 and:		[selectedResolution notNil and:		[selectedResolution isApplyable]]</body><body package="Store-Merge Management" selector="canUnresolve">canUnresolve	^selectedResolution notNil and:		[selectedResolution isApplyable]</body><body package="Store-Merge Management" selector="isShowConflictsWithBase">isShowConflictsWithBase	^conflictType == #conflictsWithBase</body><body package="Store-Merge Management" selector="isShowConflictsWithImage">isShowConflictsWithImage	^conflictType == #conflictsWithImage</body><body package="Store-Merge Management" selector="isShowConflictsWithResolution">isShowConflictsWithResolution	^conflictType == #conflictsWithResolution</body><body package="Store-Merge Management" selector="isShowLongNames">isShowLongNames	^nameStyle == #showLongNames</body><body package="Store-Merge Management" selector="isShowShortNames">isShowShortNames	^nameStyle == #showShortNames</body><body package="Store-Merge Management" selector="isShowingToolbar">isShowingToolbar	^self builder window toolbarVisible</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - view</category><body package="Store-Merge Management" selector="conflictsWithBase">conflictsWithBase	self toggleConflicts: #conflictsWithBase.</body><body package="Store-Merge Management" selector="conflictsWithImage">conflictsWithImage	self toggleConflicts: #conflictsWithImage.</body><body package="Store-Merge Management" selector="conflictsWithResolution">conflictsWithResolution	self toggleConflicts: #conflictsWithResolution.</body><body package="Store-Merge Management" selector="expandHierarchy">expandHierarchy	currentResolutionsPane expandAll</body><body package="Store-Merge Management" selector="refreshResolutions">refreshResolutions	builder window sensor invalidationSuppressWhile: 		[self updateResolutions.		currentResolutionsPane doInitialExpansion].	builder window refresh</body><body package="Store-Merge Management" selector="showAll">showAll	show := #all.	self refreshResolutions</body><body package="Store-Merge Management" selector="showConflicts">showConflicts	show := #conflicts.	self refreshResolutions</body><body package="Store-Merge Management" selector="showLongNamesAction">showLongNamesAction	nameStyle := #showLongNames.	currentResolutionsPane setShowLongNames.	self updateResolutions.</body><body package="Store-Merge Management" selector="showShortNamesAction">showShortNamesAction	nameStyle := #showShortNames.	currentResolutionsPane setShowShortNames.	self updateResolutions.</body><body package="Store-Merge Management" selector="showUnresolved">showUnresolved	show := #unresolved.	self refreshResolutions</body><body package="Store-Merge Management" selector="toggleFullNames">toggleFullNames	nameStyle := nameStyle = #showLongNames		ifTrue: [#showShortNames]		ifFalse: [#showLongNames].	nameStyle = #showLongNames		ifTrue: [currentResolutionsPane setShowLongNames]		ifFalse: [currentResolutionsPane setShowShortNames].	self updateResolutions.</body><body package="Store-Merge Management" selector="toggleToolbar">toggleToolbar	| window |	window := self builder window.	window toolbarVisible: window toolbarVisible not</body><body package="Store-Merge Management" selector="toggleZoomTextViews">toggleZoomTextViews	self areTextViewsZoomed		ifTrue: [self unzoomTextViews]		ifFalse: [self zoomTextViews]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - packages</category><body package="Store-Merge Management" selector="exit">exit	self closeRequest</body><body package="Store-Merge Management" selector="publishPackages">publishPackages	self allAreApplied ifFalse: 		[(Dialog confirm: (#PublishePackagesConfirm &lt;&lt; #store &gt;&gt; 'All definitions do not have applied resolutions.&lt;n&gt;Publish anyway?') expandMacros) 			ifFalse: [^self]].	self publishModified.</body><body package="Store-Merge Management" selector="selectPackages">selectPackages	self areResolutionsPublished ifFalse: 		[(Dialog 			confirm: (#SelectPackagesConfirm &lt;&lt; #store &gt;&gt; 'Some of the modification have not been published and will be&lt;n&gt;removed from the Merge Tool if you select a new set of packages.&lt;n&gt;Are you sure that you want to proceed?') expandMacros 			for: builder window)				ifFalse: [^self]].	PundleVersionSelector openOn: self.</body><body package="Store-Merge Management" selector="showStatus">showStatus	currentResolutionsPane isResolutionSelected		ifTrue:			[currentResolutionsPane selectionIndex: 0]		ifFalse:			[(builder componentAt: #displayTextID) flash]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - browse</category><body package="Store-Merge Management" selector="browseImplementors">browseImplementors		| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect: (methodCollector implementorsOf: selectedResolution selector)</body><body package="Store-Merge Management" selector="browseSenders">browseSenders	| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect:  (methodCollector referencesTo: (selectedResolution selector ifNil: [^self]))</body><body package="Store-Merge Management" selector="browseVersions">browseVersions	selectedResolution notNil		ifTrue: [[selectedResolution browseVersions] withStoreFeedbackOn: self mainWindow]</body><body package="Store-Merge Management" selector="compare">compare	| indexes |	indexes := self packageListIndexes.	Differator 		compare: ((self packageList list at: indexes first) definitionTextFrom: selectedResolution)		and: ((self packageList list at: indexes last) definitionTextFrom: selectedResolution)</body><body package="Store-Merge Management" selector="compareWithBase">compareWithBase	Differator 		compare: self selectedPackageText		and: self baseText</body><body package="Store-Merge Management" selector="compareWithImage">compareWithImage	Differator 		compare: self selectedPackageText 		and: self imageText</body><body package="Store-Merge Management" selector="compareWithResolution">compareWithResolution	Differator 		compare: self selectedPackageText		and: self resolutionText</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menus</category><body package="Store-Merge Management" selector="augmentedMenu:named:">augmentedMenu: aMenu named: aSymbol 	^[aMenu 		augmentFrom: self class		to: Store.Glorp.MergeTool		menuName: aSymbol		for: self] 			on: Error			do: [:ex | aMenu]</body><body package="Store-Merge Management" selector="isShowAll">isShowAll	^show == #all</body><body package="Store-Merge Management" selector="isShowConflicts">isShowConflicts	^show == #conflicts</body><body package="Store-Merge Management" selector="isShowUnresolved">isShowUnresolved	^show == #unresolved</body><body package="Store-Merge Management" selector="menuBar">menuBar	| menu |	menu := self class menuBarMenu.	^self augmentedMenu: menu named: #menuBar</body><body package="Store-Merge Management" selector="modificationMenu">modificationMenu	^[self augmentedMenu: self class modificationMenu named: #modificationMenu]</body><body package="Store-Merge Management" selector="versionMenu">versionMenu	^[self augmentedMenu: self class versionMenu named: #versionMenu]</body><body package="Store-Merge Management" selector="viewMenu">viewMenu	| items values |	items := OrderedCollection new.	values := OrderedCollection new.	items add: ((MenuItem labeled: (#ShowConflicts &lt;&lt; #store &gt;&gt; 'Show Conflicts')) 		indication: [show == #conflicts]).	values add: #showConflicts.	items add: ((MenuItem labeled: (#ShowUnresolved &lt;&lt; #store &gt;&gt; 'Show Unresolved')) 		indication: [show == #unresolved]).	values add: #showUnresolved.	items add: ((MenuItem labeled: (#ShowAll &lt;&lt; #store &gt;&gt; 'Show All')) 		indication: [show == #all]).	values add: #showAll.	^Menu menuItems: items values: values</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private</category><body package="Store-Merge Management" selector="absentString">absentString	^(#SpaceDashAbsentDashSpace &lt;&lt; #store &gt;&gt; ' - absent - ') asString</body><body package="Store-Merge Management" selector="allAreApplied">allAreApplied	resolutionManager isNil ifTrue: [^false].	^resolutionManager resolutions allSatisfy: #hasBeenApplied</body><body package="Store-Merge Management" selector="areResolutionsPublished">areResolutionsPublished	"Check if all the modifications has been applied and the packages published."	resolutionManager isNil ifTrue: [^true].	self allAreApplied ifFalse: [^false].	self hasPackagesToPublish ifTrue: [^false].	^true</body><body package="Store-Merge Management" selector="askIfOkToDiscard">askIfOkToDiscard	^Dialog confirm: (#AslIfOkToDiscard &lt;&lt; #store &gt;&gt; 'The text showing has been altered.&lt;n&gt;Do you wish to discard these changes?') expandMacros</body><body package="Store-Merge Management" selector="baseLabel">baseLabel		^selectedResolution isNil 		ifTrue: [Text new] 		ifFalse: [(selectedResolution baseLabel ifNil: [self absentString]) asText]</body><body package="Store-Merge Management" selector="baseText">baseText		^selectedResolution isNil 		ifTrue: [Text new] 		ifFalse: [(selectedResolution baseDefinitionText ifNil: ['']) asText]</body><body package="Store-Merge Management" selector="clearProtocolPanes">clearProtocolPanes		self conflictProtocol value: ' '.	self selectionProtocol value: ' '</body><body package="Store-Merge Management" selector="containsResolvedAndNotApplied">containsResolvedAndNotApplied	resolutionManager isNil ifTrue: [^false].	^resolutionManager resolutions allSatisfy: #isResolved</body><body package="Store-Merge Management" selector="couldPublishPackages">couldPublishPackages	^resolutionManager notNil and: [resolutionManager packages isEmpty not]</body><body package="Store-Merge Management" selector="currentResolutionPackageItem">currentResolutionPackageItem	^packageList selections size = 1 ifTrue: [packageList selections first]</body><body package="Store-Merge Management" selector="displayInitialList">displayInitialList	self resolutionListTabs selectionIndex: 1.	builder window sensor invalidationSuppressWhile:		[self resolutionListTabsChanged.		currentResolutionsPane doInitialExpansion.].	builder window refresh.</body><body package="Store-Merge Management" selector="doMergeBy:">doMergeBy: aBlock 	"Execute 'aBlock' to set the versions to merge.	If there are no errors proceed to do the merge	and update the modification sets.	Otherwise report the error."	| notConnectedPackages |	notConnectedPackages := OrderedCollection new.	Merging new started.	aBlock 		on: NoCommonAncestor		do: 			[:exception | 			notConnectedPackages add: exception parameter.			exception proceed].	notConnectedPackages isEmpty ifTrue: 		[resolutionManager doMerge ifFalse: [self notifyNoChangesAndReset].		Merging new finished.		^self].	Merging new finished.	notConnectedPackages size &gt; 1 		ifTrue: 			[Transcript				cr;				show: #DoMergeBy &lt;&lt; #store &gt;&gt; 'The following pairs of packages do not have a common ancestor.';				cr.			notConnectedPackages do: 				[:each | 				Transcript					show: (each at: 1) itemString;					show: #And &lt;&lt; #store &gt;&gt; ' and ';					show: (each at: 2) itemString;					cr].			Transcript show: '-------------'.			Dialog 				warn: (#DoMergeByWarning &lt;&lt; #store 						&gt;&gt; 'Multiple cases of the following problem have been detected:&lt;n&gt;a package with two integration ready versions which are not &lt;n&gt;derived from a common ancestor.&lt;n&gt;The merge has been aborted.&lt;n&gt;One of each of the following pairs should have its blessing &lt;n&gt;level set to a value other than integration ready.  These &lt;n&gt;versions may first be merged using the Differences Tool.  &lt;n&gt;After this is done the merge may be retried.&lt;1s&gt;&lt;n&gt;This list is repeated in the transcript.' 					expandMacrosWith: (notConnectedPackages 						inject: ''						into: 							[:sum :each | 							#x1sn2sAnd3s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&lt;n&gt;     &lt;2s&gt; and &lt;3s&gt;' 								expandMacrosWith: sum								with: (each at: 1) itemString								with: (each at: 2) itemString]))]		ifFalse: 			[| package |			package := notConnectedPackages first.			Transcript				cr;				show: (#DoMergeByTwoPackages &lt;&lt; #store &gt;&gt; 'The two packages &lt;1s&gt; and &lt;2s&gt; do not have a common ancestor.' 					expandMacrosWith: (package at: 1) itemString					with: (package at: 2) itemString).			Dialog warn: 				(#DoMergeByAborted &lt;&lt; #store &gt;&gt; 'The two packages &lt;1s&gt; and &lt;2s&gt;&lt;n&gt;do not have a common ancestor. The merge has been aborted.&lt;n&gt;These versions may be merged using the Differences Tool.' 				expandMacrosWith: (package at: 1) itemString				with: (package at: 2) itemString)].	self reset</body><body package="Store-Merge Management" selector="environmentOrderFor:">environmentOrderFor: aCollectionOfChangeResolvers	| orderedResolvers workingResolvers names |	orderedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	workingResolvers := aCollectionOfChangeResolvers asOrderedCollection.	[workingResolvers isEmpty] whileFalse:		[names := workingResolvers collect: [:each | each definitionName].		workingResolvers copy do:			[:each |			(names contains: [:eachName | '*.', eachName match: each ownerNameForLoadOrdering ignoreCase: false]) ifFalse:				[orderedResolvers add: each.				workingResolvers remove: each]]].		^orderedResolvers</body><body package="Store-Merge Management" selector="hasPackagesToPublish">hasPackagesToPublish	^resolutionManager notNil and: [resolutionManager affectedPackages isEmpty not]</body><body package="Store-Merge Management" selector="imageBundles">imageBundles	"Answer a collection of unique bundles as loaded into the image preserving order orignially encountered."		| targets unique |	targets := ((bundles collect: [:each | Registry bundleNamed: each name]) reject: [:each | each isNil]).	unique := OrderedCollection new.	targets do: [:each | (unique includes: each) ifFalse: [unique add: each]].	^unique</body><body package="Store-Merge Management" selector="imageLabel">imageLabel	^selectedResolution isNil		ifTrue: [Text new]		ifFalse: [(selectedResolution imageLabel ifNil: [self absentString]) asText].</body><body package="Store-Merge Management" selector="imageText">imageText	^selectedResolution isNil		ifTrue: [Text new]		ifFalse: 			[((selectedResolution applied and: [selectedResolution proposed isRemovalResolution])				ifTrue: [selectedResolution removeFromImageString]				ifFalse: 					[(selectedResolution originalDefinitionText ifNil: 						[selectedResolution isMove 							ifTrue: 								[selectedResolution applied									ifTrue: [selectedResolution movedFromPackageString]									ifFalse: [selectedResolution moveFromPackageString]]							ifFalse: [(#NotInImage &lt;&lt; #store &gt;&gt; '*** Not in image ***')]])]) asText]</body><body package="Store-Merge Management" selector="isResolutionSelected">isResolutionSelected	"Answer true if a mod set has been selected"	^selectedResolution notNil</body><body package="Store-Merge Management" selector="mergeStringForPackage:">mergeStringForPackage: aPackage	| stream notLoadedVersions trunk treeRecord historyPreambleEndPosition |	notLoadedVersions := OrderedCollection new.	(resolutionManager integratedVersions at: aPackage name) do:		[:each |		each isVersionLoaded			ifTrue: [trunk := each]			ifFalse: [notLoadedVersions add: each]].	trunk isNil ifTrue: [NoTrunkToMergeError raise].	stream := WriteStream on: String new.	stream nextPutAll: (#MergedByMergeTool &lt;&lt; #store &gt;&gt; 'Merged by Merge Tool') asString; cr.	stream nextPutAll: (#ImageVersion &lt;&lt; #store &gt;&gt; 'Image version:') asString; cr; tab.	stream nextPutAll: trunk itemString;cr.	stream nextPutAll: (#BranchVersionsIntegrated &lt;&lt; #store &gt;&gt; 'Branch versions integrated:') asString; cr.	notLoadedVersions do: 		[ :each |		each isPackage = aPackage isPackage ifTrue:			[stream 				tab;				nextPutAll: each mergeItemString; cr]].	Policies mergePolicy includeBranchBlessingCommentHistory		ifFalse: [^stream contents].	historyPreambleEndPosition := stream position.	stream cr.	stream nextPutAll: (#BranchHistory &lt;&lt; #store &gt;&gt; 'Branch history:') asString; cr.	treeRecord := resolutionManager trees detect: 		[:each | 		(each at: 1) package name = aPackage name].	notLoadedVersions 		do:			[:each | 			| ancestorVersion |			ancestorVersion := (treeRecord at: 2) package version.			each printPremergeCommentHistoryOn: stream from: ancestorVersion withLeadingCR: false]		separatedBy: [stream cr;cr].	(stream position &gt; (historyPreambleEndPosition + self class maxBranchHistoryTextSize))		ifTrue:  			[stream position: (historyPreambleEndPosition + self class maxBranchHistoryTextSize).			stream nextPutAll: ' ... ' ; cr.			stream nextPutAll: (#MoreDots &lt;&lt; #store &gt;&gt; ' More...') asString; cr].	^stream contents</body><body package="Store-Merge Management" selector="methodSelected">methodSelected	"Answer true if a mod set of a method has been selected"	^selectedResolution notNil and: [selectedResolution isMethodResolver]</body><body package="Store-Merge Management" selector="notifyNoChangesAndReset">notifyNoChangesAndReset		self reset.	Dialog warn:		(#OnlyAlreadyAppliedChangesWereDetected &lt;&lt; #store &gt;&gt;		'Only already applied changes were detected.&lt;n&gt;No new changes are available for this merge session') expandMacros</body><body package="Store-Merge Management" selector="packageForAccept">packageForAccept	^selectedResolution containingPackageModel.</body><body package="Store-Merge Management" selector="packageListIndexes">packageListIndexes	^packageList selectionIndexes asArray</body><body package="Store-Merge Management" selector="promptIfNecessaryForUnpublishedChanges">promptIfNecessaryForUnpublishedChanges	^WarnBeforeAbandoningUnpublished not		or:			[Dialog				confirm:				#SomeModsNotYetPublished &lt;&lt; #store &gt;&gt; 'Some of the modifications have not been published.Are you sure that you want to quit the Merge Tool?'				for: self mainWindow]</body><body package="Store-Merge Management" selector="protocolColonLabelString">protocolColonLabelString		^(#ProtocolColonSpace &lt;&lt; #store &gt;&gt; 'Protocol: ') asString</body><body package="Store-Merge Management" selector="protocolStringOfSelectedResolutionFrom:">protocolStringOfSelectedResolutionFrom: aResolutionPackageItem		^selectedResolution protocolStringFrom: aResolutionPackageItem</body><body package="Store-Merge Management" selector="publishModified">publishModified	"Publish all modified package and other merged packages the user selects that are mentioned 	in the merge data.  Change blessing level from integration-ready to integrated."		| affected |	affected := self pundlesToPublish.	affected isEmpty ifTrue: 		[^Dialog warn: #NoChangesToPublish &lt;&lt; #store &gt;&gt; 'There are no changes to publish.'].	PublishMergeDialog		publishPackages: affected		comments: (affected collect:			[:each | 			[self mergeStringForPackage: each]				on: NoTrunkToMergeError				do: [:exception | ^Dialog warn: #NoChangesToPublish &lt;&lt; #store &gt;&gt; 'There are no changes to publish.']])		defaultBlessing: Policies mergePolicy blessingForMerged		ifSuccessfulDo:			[:pundles | 			Policies integratedBlessingChangePolicy = #change ifTrue: 				[self updateIntegrationBlessingsFor: pundles]]</body><body package="Store-Merge Management" selector="pundlesToPublish">pundlesToPublish	^self imageBundles , resolutionManager packages 		select: [:pun | pun hasBeenModified]</body><body package="Store-Merge Management" selector="resolutionLabel">resolutionLabel		^selectedResolution isNil 		ifTrue: [Text new] 		ifFalse: [(selectedResolution resolutionLabel ifNil: [self absentString]) asText]</body><body package="Store-Merge Management" selector="resolutionText">resolutionText	^selectedResolution isNil		ifTrue: [Text new]		ifFalse: [(selectedResolution proposedDefinitionText ifNil: ['']) asText]</body><body package="Store-Merge Management" selector="resolveTo:">resolveTo: aResolutionPackageItem	resolutionManager clearMoves.	selectedResolution resolution: aResolutionPackageItem.	resolutionManager detectMoves.	self updateResolutionsWithoutRebuild.	(self builder componentAt: #pkgListID) widget invalidate</body><body package="Store-Merge Management" selector="resolveToText">resolveToText	selectedResolution isNil 		ifTrue: [self packageSelectionChanged]		ifFalse: 			[| packageModel resolution textController parseSucceeded | 			selectedResolution isApplyable ifFalse: [^self packageSelectionChanged].			selectedResolution isResolver ifFalse: [^self packageSelectionChanged].			packageModel := self packageForAccept.			packageModel isNil ifTrue: [^self packageSelectionChanged].			textController := (self builder componentAt: #displayTextID) widget controller.			Policies packagePolicy 				forcePackage: packageModel 				while: [parseSucceeded := selectedResolution parseText: textController text].			parseSucceeded ifFalse: [^self packageSelectionChanged].			self text: textController text copy.			resolution := UserInputResolution				forPackage: packageModel				text: textController text copy.			selectedResolution isMethodResolver ifTrue:				[resolution protocol: (self protocolStringOfSelectedResolutionFrom: self currentResolutionPackageItem)].			selectedResolution addAlternative: resolution.			selectedResolution proposed: resolution.			selectedResolution applied: false.			self updateResolutionsWithoutRebuild]</body><body package="Store-Merge Management" selector="selectedPackageItem">selectedPackageItem	| packageItem |	packageItem := (self packageList list at: self packageListIndexes first).	self selectedResolution isResolver ifFalse:		[packageItem := packageItem asGeneralResolution].	^packageItem</body><body package="Store-Merge Management" selector="selectedPackageText">selectedPackageText	| alternative |	alternative := self currentResolutionPackageItem alternative.	alternative isRemovalResolution ifTrue: [^alternative base value].	^alternative value</body><body package="Store-Merge Management" selector="showLongNames">showLongNames	nameStyle := #showLongNames.	currentResolutionsPane showLongNames</body><body package="Store-Merge Management" selector="showShortNames">showShortNames	nameStyle := #showShortNames.	currentResolutionsPane showShortNames</body><body package="Store-Merge Management" selector="sortResolutionsForLoading:">sortResolutionsForLoading: aCollectionOfChangeResolvers	"Order of things:		1) Method removes		2) Shared removes		3) Comment removes		4) Namespace change (in hierarchy order)		5) Namespace removes (in reverse hierachy order)		6) Class changes (in hierarchy order)		7) Class removes (in reverse hierarchy order)		8) Shared changes (no order)		9) Method changes (meta before instance)		10) comment add or changes		11) Property changes		12) Bundle structure changes"	| nameSpaceResolvers classResolvers sortedResolvers |	sortedResolvers := OrderedCollection new: aCollectionOfChangeResolvers size.	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isMethodResolver and: [each isProposedForRemoval]]).	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isSharedResolver and: [each isProposedForRemoval]]).	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isCommentResolver and: [each isProposedForRemoval]]).	nameSpaceResolvers := aCollectionOfChangeResolvers select: [:each | each isNameSpaceDefinitionResolver and: [each isProposedForRemoval not]].	sortedResolvers addAll: (self environmentOrderFor: nameSpaceResolvers).	nameSpaceResolvers := aCollectionOfChangeResolvers select: [:each | each isNameSpaceDefinitionResolver and: [each isProposedForRemoval]].	sortedResolvers addAll: (self environmentOrderFor: nameSpaceResolvers) reverse.	classResolvers := aCollectionOfChangeResolvers select: [:each | each isClassDefintionResolver and: [each isProposedForRemoval not]].	sortedResolvers addAll: (self environmentOrderFor: classResolvers).	classResolvers := aCollectionOfChangeResolvers select: [:each | each isClassDefintionResolver and: [each isProposedForRemoval]].	sortedResolvers addAll: (self environmentOrderFor: classResolvers) reverse.	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isSharedResolver and: [each isProposedForRemoval not]]).	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isMethodResolver and: [each isProposedForRemoval not and: [each isMeta]]]).	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isMethodResolver and: [each isProposedForRemoval not and: [each isMeta not]]]).	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isCommentResolver and: [each isProposedForRemoval not]]).	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isPropertyResolver]).	sortedResolvers addAll: (aCollectionOfChangeResolvers select: [:each | each isBundleStructureResolver]).	^sortedResolvers</body><body package="Store-Merge Management" selector="statusString">statusString	| stream |	resolutionManager integratedVersions isEmpty		ifTrue: [^(#StatusString1 &lt;&lt; #store &gt;&gt; 'No packages selected to merge.') asString].	stream := WriteStream on: String new.	stream nextPutAll: (#VersionsBeingIntegrated &lt;&lt; #store &gt;&gt; 'Versions being integrated: ') asString; cr; cr.	resolutionManager integratedVersions do:		[:eachVersion |		eachVersion do:			[:eachPackage|			stream nextPutAll: eachPackage mergeItemString; cr]].	^stream contents</body><body package="Store-Merge Management" selector="text:">text: someText	"For our use only"	| oldTextMode |	oldTextMode := textMode.	textMode := #internal.	displayText value: someText asText.	self setConflictText.	textMode := oldTextMode.</body><body package="Store-Merge Management" selector="textChanged">textChanged 	textMode = #external ifTrue: [self resolveToText]</body><body package="Store-Merge Management" selector="toggleConflicts:">toggleConflicts: aSymbol	"Change the conflicts after aSymbol was selected."	conflictType := aSymbol.	self setConflictText.</body><body package="Store-Merge Management" selector="twoVersionsSelected">twoVersionsSelected	"Answer true if there are	exactly two packages selected"	^self packageList selectionIndexes size = 2 and: [self selectedResolution isResolver]</body><body package="Store-Merge Management" selector="updateConflictProtocolFor:into:">updateConflictProtocolFor: aResolutionPackageItem into: stream	| protocolString |	(selectedResolution notNil and: [selectedResolution displaysProtocolStatus and: [self conflictProtocolText notEmpty]])		ifTrue: 			[stream				emphasis: #bold;				nextPutAll: self protocolColonLabelString;				emphasis: #none.			protocolString := (selectedResolution protocolStringFrom: aResolutionPackageItem) ifNil: [''].			self conflictProtocolText asString = protocolString asString				ifFalse: [stream emphasis: TextFragment emphasisForChange].			stream nextPutAll: self conflictProtocolText].	self conflictProtocol value: stream contents</body><body package="Store-Merge Management" selector="updateIntegrationBlessingsFor:">updateIntegrationBlessingsFor: aCollectionOfStorePundle 	resolutionManager versionsUsedForMerge do:		[:eachPundleVersion | 		| targetPundle comment |		(Publishing for: eachPundleVersion) started.		eachPundleVersion isVersionLoaded ifFalse:			[targetPundle := aCollectionOfStorePundle 				detect: [:eachPundle | (eachPundle at: #pundle) name = eachPundleVersion name and: [eachPundle pundle isBundle = eachPundleVersion isBundle]] 				ifNone: [nil].			comment := targetPundle isNil				ifTrue: [(#IntegratedByTheMergeTool &lt;&lt; #store &gt;&gt; 'Integrated by the Merge Tool.') asString]				ifFalse: [#IntegratedByMerge1s &lt;&lt; #store &gt;&gt; 'Integrated by Merge Tool into version &lt;1s&gt;.' expandMacrosWith: (targetPundle at: #version)].			eachPundleVersion 				addBlessingLevel: (Policies mergePolicy integratedBlessingLevelForPackage: eachPundleVersion) 				andComment: comment].		(Publishing for: eachPundleVersion) finished]</body><body package="Store-Merge Management" selector="updateResolutions">updateResolutions	currentResolutionsPane updateResolutions.	self updateToolbar</body><body package="Store-Merge Management" selector="updateResolutionsWithoutRebuild">updateResolutionsWithoutRebuild	currentResolutionsPane updateResolutionsWithoutRebuild.	currentResolutionsPane resolutionSelectionChanged.	self updateToolbar</body><body package="Store-Merge Management" selector="updateSelectionProtocol">updateSelectionProtocol	| indexes item |	indexes := packageList selectionIndexes.	self clearProtocolPanes.	indexes size = 1 ifTrue:		[item := packageList list at: indexes asArray first.		self updateSelectionProtocolFrom: item]</body><body package="Store-Merge Management" selector="updateSelectionProtocolFor:into:">updateSelectionProtocolFor: aResolutionPackageItem into: stream	| protocolString |	(selectedResolution notNil and: 			[selectedResolution displaysProtocolStatus and: 					[(protocolString := self								protocolStringOfSelectedResolutionFrom: aResolutionPackageItem) notNil]])		ifTrue: 			[selectedResolution isMethodResolver				ifTrue: 					[stream						emphasis: #bold;						nextPutAll: self protocolColonLabelString;						emphasis: #none].			self conflictProtocolText asString = protocolString asString				ifFalse: [stream emphasis: TextFragment emphasisForChange].			stream nextPutAll: protocolString].	self selectionProtocol value: stream contents</body><body package="Store-Merge Management" selector="updateSelectionProtocolFrom:">updateSelectionProtocolFrom: aResolutionPackageItem		| stream |	stream := TextStream on: String new.	stream space.	self updateSelectionProtocolFor: aResolutionPackageItem into: stream.	stream := TextStream on: String new.	stream space.	self updateConflictProtocolFor: aResolutionPackageItem into: stream</body><body package="Store-Merge Management" selector="validateTextOnExit:">validateTextOnExit: aController	^self textHasChanged not or: [self askIfOkToDiscard]</body><body package="Store-Merge Management" selector="versionSelected">versionSelected	"Answer true if there are	exactly one packages selected"	^self packageList selectionIndexes size = 1 and: [self selectedResolution isResolver]</body><body package="Store-Merge Management" selector="warnAboutNotLoadedPackages:">warnAboutNotLoadedPackages: aCollectionOfPackages 	| warningStream |	warningStream := (String new: 100) writeStream.	aCollectionOfPackages size = 1		ifTrue: 			[| package |			package := aCollectionOfPackages first.			warningStream nextPut: $"; nextPutAll: package name; nextPut: $".			warningStream nextPutAll: (#WarnNotLoaded1 &lt;&lt; #store &gt;&gt; ' is being merged but is not loaded in the image.  A new&lt;n&gt;empty package named "') expandMacros.			warningStream nextPutAll: package name; nextPut: $".			warningStream nextPutAll: (#WarnNotLoaded2 &lt;&lt; #store &gt;&gt; ' has been created, and the&lt;n&gt;resolutions you apply will be placed in this package.') expandMacros]		ifFalse: 			[warningStream nextPutAll: (#TheFollowingPackages &lt;&lt; #store &gt;&gt; 'The following packages:&lt;n&gt;') expandMacros.			aCollectionOfPackages do: 				[:each | warningStream tab; nextPut: $"; nextPutAll: each name; nextPut: $"; cr].			warningStream nextPutAll: (#WarnNotLoaded3 &lt;&lt; #store &gt;&gt; 'are being merged but are not loaded in the image.  A new empty package&lt;n&gt;has been created for each of these packages, and the resolutions&lt;n&gt;you apply will be placed in these newly created packages.') expandMacros].	warningStream cr.	Dialog warn: warningStream contents</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private-toolbar</category><body package="Store-Merge Management" selector="createGuideItem">createGuideItem	"Guide item appears as the first in the toolbar, and with a text label instead of an icon.	It changes adapting to the tool state to show the next 'major step' for the current state."	| menuItem |	menuItem := resolutionManager isEmpty 		ifTrue: [(MenuItem labeled: #SelectPackages &lt;&lt; #store &gt;&gt; 'Select Packages...') value: #selectPackages]		ifFalse: 			[self allAreApplied 				ifTrue: 					[self couldPublishPackages 						ifTrue: [(MenuItem labeled: #PublishPackages &lt;&lt; #store &gt;&gt; 'Publish Packages...') value: #publishPackages]						ifFalse: [(MenuItem labeled: #SelectPackages &lt;&lt; #store &gt;&gt; 'Select Packages...') value: #selectPackages]]				ifFalse: 					[(MenuItem labeled: #ApplyAll &lt;&lt; #store &gt;&gt; 'Apply All')						enablementSelector: #containsResolvedAndNotApplied;						value: #applyResolved]].	menuItem nameKey: #guideButton.	^menuItem</body><body package="Store-Merge Management" selector="createToolbarMenuWithGuideItem:">createToolbarMenuWithGuideItem: aMenuItem	| menu |	menu := Menu new.	menu addItem: aMenuItem.	menu addLine.	menu addPart: self class toolbarMenu.	^menu</body><body package="Store-Merge Management" selector="replaceLabelOfFirstToolbarItem">replaceLabelOfFirstToolbarItem	"Make the first toolbar button show menu item text rather than the icon as the label."	| toolbarView firstButton firstMenuItem |	toolbarView := self builder componentAt: #toolbarMenuHolder.	firstButton := toolbarView components first widget.	firstMenuItem := self toolbarMenuHolder value menuItemAt: 1.	firstButton setLabel: 		(Label 			with: firstMenuItem label 			attributes:  LookPreferences widgetPolicy lookPolicyClass systemMenuTextStyle			offset: 0@3).	toolbarView		changedPreferredBounds: toolbarView preferredBounds;		bounds: toolbarView bounds;		invalidate</body><body package="Store-Merge Management" selector="setToolbarMenu:">setToolbarMenu: aMenu	self toolbarMenuHolder value: aMenu.	self replaceLabelOfFirstToolbarItem</body><body package="Store-Merge Management" selector="updateToolbar">updateToolbar	"Rebuild toolbar as needed to show the correct guide button	and also update the enablement of everything to match the tool state.	This method should be called after anything that can	potentially change the state of the tool."	| guideItem toolbar |	guideItem := self createGuideItem.	guideItem value = (self toolbarMenuHolder value menuItemAt: 1) value ifFalse:		[self setToolbarMenu: (self createToolbarMenuWithGuideItem: guideItem)].	toolbar := self builder componentAt: #toolbarMenuHolder.	self toolbarMenuHolder value menuItems do:		[:each | 		| id enablementSelector |		id := each nameKey.		enablementSelector := each enablementSelector.		enablementSelector notNil ifTrue:			[(toolbar componentAt: id) isEnabled: (self perform: enablementSelector)]]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - help</category><body package="Store-Merge Management" selector="openHelpHowToUse">openHelpHowToUse	MergeToolHelp openHowToUseHelp</body><body package="Store-Merge Management" selector="openIconHelp">openIconHelp	MergeToolHelp openIconHelp</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - resolution</category><body package="Store-Merge Management" selector="applyResolution">applyResolution	"Apply the resolution"		builder window sensor invalidationSuppressWhile:		[| index |		index := currentResolutionsPane selectionIndex.		self applyResolved: selectedResolution proposedResolutions.		currentResolutionsPane selectionIndex: index].	builder window refresh</body><body package="Store-Merge Management" selector="applyResolved">applyResolved	"Load into the image all resolved 	definitions. 	Update the status of modification set when the resolution has been successfuly loaded."	builder window sensor invalidationSuppressWhile:		[self applyResolved: resolutionManager proposedResolutions].	builder window refresh.</body><body package="Store-Merge Management" selector="applySelection">applySelection	"Apply the selection as a resolution"	builder window sensor invalidationSuppressWhile:		[self chooseAsResolution.		self applyResolution].	builder window refresh.</body><body package="Store-Merge Management" selector="chooseAsResolution">chooseAsResolution	builder window sensor invalidationSuppressWhile:		[self resolveTo: self selectedPackageItem].	builder window refresh.</body><body package="Store-Merge Management" selector="doNotResolve">doNotResolve	selectedResolution ifNotNil:		[selectedResolution doNotResolve.		self updateResolutionsWithoutRebuild]</body><body package="Store-Merge Management" selector="unresolve">unresolve	builder window sensor invalidationSuppressWhile:		[self resolveTo: nil].	builder window refresh.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>private-text zoom</category><body package="Store-Merge Management" selector="unzoomTextViews">unzoomTextViews	| splitterLayout textLayout |	self areTextViewsZoomed ifTrue:		[splitterLayout := (self builder componentAt: #mainHorizontalSplitter) component layout.		textLayout := (self builder componentAt: #textCanvas) component layout.		textLayout			topFraction: splitterLayout bottomFraction;			topOffset: splitterLayout bottomOffset.		self widgetIDsHiddenWhenZoomed do: [:each | (self builder componentAt: each) beVisible].		self builder window refresh]</body><body package="Store-Merge Management" selector="widgetIDsHiddenWhenZoomed">widgetIDsHiddenWhenZoomed	^#(ModTabs pkgListID VersionLabel mainHorizontalSplitter)</body><body package="Store-Merge Management" selector="zoomTextViews">zoomTextViews	| textLayout |	self areTextViewsZoomed ifFalse:		[textLayout := (self builder componentAt: #textCanvas) component layout.		textLayout			topFraction: 0;			topOffset: 0.		self widgetIDsHiddenWhenZoomed do: [:each | (self builder componentAt: each) beInvisible].		self builder window refresh]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	super initialize.	resolutionManager := ResolutionManager new.	bundles := OrderedCollection new.	displayText := Text new asValue.	conflictText := Text new asValue.	textMode := #external.	show := #all.	autoSelectResolution := AutoSelectResolution.	nameStyle := NameStyle.	differencesType := DifferencesType.	self compareWithHolder value: ConflictsReference.	self compareWithHolder onChangeSend: #compareWithHolderChanged to: self.	self resolutionListTabs list: (List with: (ResolutionsTreePane new mergeTool: self) with: (ResolutionsListPane new mergeTool: self)).	self packageList selectionIndexHolder onChangeSend: #packageSelectionChanged to: self.	self displayText onChangeSend: #textChanged to: self.</body><body package="Store-Merge Management" selector="mergePundleVersions:">mergePundleVersions: aCollectionOfPundleVersions 		[| packages message |	packages := self collectPackageVersionsFrom: aCollectionOfPundleVersions.	(message := self verifyAgainstImage: packages) ifNotNil: 		[Dialog warn: message].	self doMergeBy: [resolutionManager mergePackageVersions: packages]] 		on: PundleModel mismatchedDatabaseSignal		do: 			[:exception | 			self reset.			Dialog warn: ((#AbortingMergen1s &lt;&lt; #dialogs &gt;&gt; 'Aborting merge.&lt;n&gt;&lt;1s&gt;') expandMacrosWith: exception description).			^self]</body><body package="Store-Merge Management" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow 	self updateSoftSettings.	^super noticeOfWindowClose: aWindow.</body><body package="Store-Merge Management" selector="reset">reset	resolutionManager := resolutionManager copyEmpty.	resolutionListTabs list do: [:each | each reset].	bundles := OrderedCollection new.	packageList list: List new.	self updateResolutions</body><body package="Store-Merge Management" selector="updateSoftSettings">updateSoftSettings	ConflictsReference := conflictType.	AutoSelectResolution := autoSelectResolution.	NameStyle := nameStyle.	ShowToolbar := builder window toolbarVisible.	DifferencesType := differencesType.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>selecting</category><body package="Store-Merge Management" selector="compareWithHolderChanged">compareWithHolderChanged	"Selector has toggle behavior but we specifically don't want it."	| selection |	selection := self compareWithHolder value.	selection = conflictType ifFalse:		[self perform: self compareWithHolder value.		self updateSelectionProtocol]</body><body package="Store-Merge Management" selector="packageSelectionChanged">packageSelectionChanged	| indexes text item |	indexes := packageList selectionIndexes.	self clearProtocolPanes.	text := (indexes isEmpty				or: [selectedResolution notNil and: [selectedResolution isResolver not]])					ifTrue: 						[selectedResolution isNil							ifTrue: [self statusString]							ifFalse: [selectedResolution explanationText]]					ifFalse: 						[indexes size = 1							ifTrue: 								[item := packageList list at: indexes asArray first.								self updateSelectionProtocolFrom: item.								selectedResolution definitionTextFrom: item]							ifFalse: 								[#MultiplePackagesSeleted &lt;&lt; #store &gt;&gt; '*** Multiple packages selected ***']].	self text: text.	self updateToolbar</body><body package="Store-Merge Management" selector="selectedResolution:">selectedResolution: aResolutionsOrResolver	| selections idx |	selectedResolution := aResolutionsOrResolver.	packageList list: (selectedResolution isNil ifTrue: [#()] ifFalse: [selectedResolution createModificationDisplayRecords]).	selections := (autoSelectResolution and: [selectedResolution notNil])		ifTrue:			[idx := packageList list findFirst: [:ele | ele proposed].			(selectedResolution isResolved and: [idx &gt; 0])				ifTrue: [Set with: idx]				ifFalse: [Set new]]		ifFalse: [Set new].	packageList selectionIndexes: selections.</body><body package="Store-Merge Management" selector="textHasChanged">textHasChanged	"Answer true if the text view contains a definition 	and the definition has been modified. 	We distinguish definition from by the ***."	^(self builder componentAt: #displayTextID) widget controller textHasChanged		and: 			[| str |			str := displayText value asString.			str isEmpty not and: [str size &lt; 3 or: [(str copyFrom: 1 to: 3)						~= '***']]]</body><body package="Store-Merge Management" selector="updateText">updateText	self packageSelectionChanged.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>accessing</category><body package="Store-Merge Management" selector="collectPackageVersionsFrom:">collectPackageVersionsFrom: aCollectionOfPundleVersions	"Answer a collection of package versions generated by expanding the bundles in the collecion."		| pundles |	pundles := OrderedCollection new.	aCollectionOfPundleVersions do:		[:each | 		(Gathering for: each) started.		each isBundle			ifTrue:				[bundles add: each.				pundles addAll: (self collectPackageVersionsFrom: each containedItems).				pundles add: each]			ifFalse: [pundles add: each].		(Gathering for: each) finished].	^pundles</body><body package="Store-Merge Management" selector="databaseSession">databaseSession	^databaseSession ifNil: 		[databaseSession := Store.Glorp.StoreLoginFactory currentStoreSession].</body><body package="Store-Merge Management" selector="databaseSession:">databaseSession: aGlorpDatabaseSession	databaseSession := aGlorpDatabaseSession</body><body package="Store-Merge Management" selector="filteredResolutions">filteredResolutions	^resolutionManager sortedListResolutionValues: show</body><body package="Store-Merge Management" selector="mergeSelectedPundleVersions:">mergeSelectedPundleVersions: aCollectionOfPundles	| pundleNames title targetPundleForSession |	self reset.	targetPundleForSession := aCollectionOfPundles detect: [:each | each isImageModel not] ifNone: [nil].	(databaseSession isNil and: [targetPundleForSession notNil]) ifTrue: [self databaseSession: targetPundleForSession session].	StoreProgressOverlay		subsume: builder window		while: [self mergePundleVersions: (aCollectionOfPundles collect: [:each | each asStorePundleIn: self databaseSession])].	pundleNames := resolutionManager integratedPackages keys asSortedCollection.	title := pundleNames size = 1		ifTrue:			[#MergingPackage1s &lt;&lt; #store &gt;&gt; 'Merging Package &lt;1s&gt;'				expandMacrosWith: pundleNames any]		ifFalse:			[bundles size = 0				ifTrue:					[#Merging1pPackages &lt;&lt; #store &gt;&gt; 'Merging &lt;1p&gt; Packages'						expandMacrosWith: pundleNames size]				ifFalse:					[#Merging1pBundlesAnd2pPackages &lt;&lt; #store						&gt;&gt; 'Merging &lt;1p&gt; Bundles and &lt;2p&gt; Packages'						expandMacrosWith: bundles size						with: pundleNames size]].	builder window label: title.	self displayInitialList.	self updateToolbar.	self unzoomTextViews</body><body package="Store-Merge Management" selector="resolutionManager">resolutionManager	^resolutionManager</body><body package="Store-Merge Management" selector="selectedResolution">selectedResolution	^selectedResolution</body><body package="Store-Merge Management" selector="show">show	^show</body><body package="Store-Merge Management" selector="verifyAgainstImage:">verifyAgainstImage: aCollectionOfPundles 	"Verify that aPundle has an image version (that we are merging into).	If the in-image-version is itself different from the record, add it to the set of pundles to be merged as well.	Answers an error message or nil if okay."	| missingImagePundles |	missingImagePundles := OrderedCollection new.	aCollectionOfPundles do: 		[:each | 		| inImageModel |		inImageModel := each isSameAsImage 			ifTrue: [each] 			ifFalse: [each getImagePundle].		inImageModel isNil			ifTrue: [missingImagePundles add: each]			ifFalse: [	inImageModel hasBeenModified ifTrue: [aCollectionOfPundles addLast: inImageModel]]].	^missingImagePundles isEmpty ifFalse: 		[ | stream |		stream := WriteStream on: String new.		missingImagePundles			do: 				[:each | 				stream nextPutAll: (#t1QBundlePackageNamed2s &lt;&lt; #store &gt;&gt; '&lt;t&gt;&lt;1?Bundle:Package&gt; named &lt;2s&gt;' 					expandMacrosWith: each isBundle 					with: each name)]			separatedBy: [stream cr].		#x1snn2QIsAreNotLoadedMergingMayCausePublish &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&lt;nn&gt;&lt;2?Is:Are&gt; not loaded.&lt;n&gt;Merging may cause loading and republishing&lt;n&gt;of these existing Packages and/or Bundles'			expandMacrosWith: stream contents			with: missingImagePundles size = 1]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions - version</category><body package="Store-Merge Management" selector="spawnVersion">spawnVersion	| modification |	modification := packageList selections first.	modification isNil ifTrue: [^Dialog warn: (#NoResolutionToSpawn &lt;&lt; #store &gt;&gt; 'No resolution to spawn')].	ComposedTextView		edit: self selectedPackageText asValue		label: ((#x1sIn2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt; in &lt;2s&gt;')			expandMacrosWith: selectedResolution name			with: modification description)		icon: nil		extent: 400 @ 200</body><body package="Store-Merge Management" selector="toggleAutoSelectResolution">toggleAutoSelectResolution	autoSelectResolution := autoSelectResolution not.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>widget accessing</category><body package="Store-Merge Management" selector="packageListWidget">packageListWidget	^(builder componentAt: #pkgListID ) widget.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>menu actions</category><body package="Store-Merge Management" selector="applyAll:">applyAll: unApplied		| errors |	errors := false.	Cursor execute showWhile: 		[unApplied do: 			[:each | each apply 				ifTrue: [each markApplied] 				ifFalse: [errors := true]]].	^errors</body><body package="Store-Merge Management" selector="applyResolved:">applyResolved: aCollection	"Load into the image the designated definitions. 	Update the status of modification set when the resolution has been successfuly loaded."		| unApplied errors navigatorClass moveItems |	unApplied := aCollection select: [:each | each isResolved and: [each hasBeenApplied not]].	unApplied isEmpty ifTrue: [^self].	unApplied := self sortResolutionsForLoading: unApplied.	moveItems := unApplied select: [:each | each isMove].	moveItems do:		[:each | (unApplied includes: each movePair) ifFalse: [unApplied add: each movePair]].	unApplied := self sortResolutionsForLoading: unApplied.	unApplied size &lt; 2		ifTrue: 			[errors := self applyAll: unApplied]		ifFalse: 			[[errors := self applyAll: unApplied]				on: IgnorePossibleOverrideNotice				do: [:notice | notice resume: true]].	errors		ifTrue:			[Dialog				warn: (#ApplyResolvedNote &lt;&lt; #store &gt;&gt; 'Some of the resolved definitions have not been applied. &lt;n&gt;See the Transcript for details.') expandMacros].	self updateResolutionsWithoutRebuild.	navigatorClass := #{Refactory.Browser.BrowserNavigator} valueOrDo: [^self].	navigatorClass updatePackageListsInOpenWindows.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>mod tab control</category><body package="Store-Merge Management" selector="resolutionListTabsChanged">resolutionListTabsChanged	| selectedApp |	currentResolutionsPane release.	selectedApp := self resolutionListTabs selection.	selectedApp isNil		ifTrue: [^self].	currentResolutionsPane := selectedApp.	(self widgetAt: #ModTabs)		client: currentResolutionsPane		spec: #windowSpec		builder: builder newSubBuilder.	self perform: nameStyle.</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>changing</category><body package="Store-Merge Management" selector="changeRequest">changeRequest		^super changeRequest and: [self areResolutionsPublished or: [self promptIfNecessaryForUnpublishedChanges]]</body></methods><methods><class-id>Store.Glorp.MergeTool</class-id> <category>events</category><body package="Store-Merge Management" selector="windowEvent:from:">windowEvent: anEvent from: aWindow 	super windowEvent: anEvent from: aWindow.	(#(#newGraphicsDevice #reopen) includes: anEvent key) 		ifTrue: [self closeAndUnschedule]</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>support</category><body package="Store-Merge Management" selector="iconImportExpressions">iconImportExpressions"These are the helper do-its for importing the icon sources into VisualWorks.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/resolved.gif' 		toClass: ListIconLibrary		selector: #resolved16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/unresolved.gif' 		toClass: ListIconLibrary		selector: #unresolved16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/applied.gif' 		toClass: ListIconLibrary		selector: #applied16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/General/class.gif' 		toClass: ListIconLibrary		selector: #class16x16	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/General/classMethod.gif' 		toClass: ListIconLibrary		selector: #classMethod16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/General/instanceMethod.gif' 		toClass: ListIconLibrary		selector: #instanceMethod16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationAdd.gif' 		toClass: ListIconLibrary		selector: #modificationAdd16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationMove.gif' 		toClass: ListIconLibrary		selector: #modificationMove16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationChange.gif' 		toClass: ListIconLibrary		selector: #modificationChange16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/modificationRemove.gif' 		toClass: ListIconLibrary		selector: #modificationRemove16x16.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarResolve.gif' 		toClass: ToolbarIconLibrary		selector: #modificationResolve20x20.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarUnresolve.gif' 		toClass: ToolbarIconLibrary		selector: #modificationUnresolve20x20.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarApply.gif' 		toClass: ToolbarIconLibrary		selector: #modificationApply20x20.	ImageReader 		iconFromFile: '/Users/vb/Work/VisualWorks/Graphics/MergeTool/toolbarApplyAll.gif' 		toClass: ToolbarIconLibrary		selector: #modificationApplyAll20x20."	self commentOnly</body><body package="Store-Merge Management" selector="warnBeforeAbandoningUnpublished">warnBeforeAbandoningUnpublished	^WarnBeforeAbandoningUnpublished</body><body package="Store-Merge Management" selector="warnBeforeAbandoningUnpublished:">warnBeforeAbandoningUnpublished: aBoolean	WarnBeforeAbandoningUnpublished := aBoolean</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>constants</category><body package="Store-Merge Management" selector="maxBranchHistoryTextSize">maxBranchHistoryTextSize	^ 4096</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>interface opening</category><body package="Store-Merge Management" selector="openOnPundles:">openOnPundles: aCollectionOfPundles	| instance pundlesNotInImage session targetPundle |	aCollectionOfPundles isEmpty		ifTrue: [^aCollectionOfPundles emptyCollectionError].	pundlesNotInImage := aCollectionOfPundles		select: [:eachBuckage | eachBuckage getImagePundle isNil].	pundlesNotInImage isEmpty		ifFalse:			[^Dialog				warn:					(#pundle1sHasNoImageVersion						&gt;&gt; '&lt;1s&gt; has no image version to work with. Cannot proceed.'						&lt;&lt; #store expandMacrosWith: pundlesNotInImage any name)].	targetPundle := aCollectionOfPundles detect: [:each | each isImageModel not] ifNone: [nil].	session := targetPundle isNil		ifTrue: [Store.Glorp.StoreLoginFactory currentStoreSession]		ifFalse: [targetPundle session].	instance := self new.	instance databaseSession: session.	instance open.	Processor yield.	[instance mergeSelectedPundleVersions: 		(aCollectionOfPundles collect: [:each | each asStorePundleIn: session])]			uiEventFor: instance builder window.</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>private</category><body package="Store-UI" selector="checkHealth">checkHealth	timer		ifNotNil: 			[self topComponent				ifNotNil: 					[:window |					window isOpen						ifTrue: 							[| contextSample |							contextSample := observedProcess suspendedContext.							contextSample = lastContext								ifFalse: 									[progressIndex := (progressIndex + 1) \\ self frameRate.									self invalidateNow].							lastContext := contextSample]]]</body><body package="Store-UI" selector="currentProgressIcon">currentProgressIcon	^SpinnerIcons perform: ('spin' , (progressIndex ) printString) asSymbol</body><body package="Store-UI" selector="frameRate">frameRate	^24</body><body package="Store-UI" selector="isActive">isActive	^isActive value</body><body package="Store-UI" selector="startFeedback">startFeedback	observedProcess := Processor activeProcess.	lastContext := nil.	progressIndex := 0.	timer := Timer every: self frameRate reciprocal seconds				do: [self checkHealth]</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>accessing</category><body package="Store-UI" selector="isActive:">isActive: anObject	isActive := anObject.	self invalidate.	self topComponent ifNotNil: [:window | window displayPendingInvalidation]</body><body package="Store-UI" selector="observedProcess">observedProcess	^observedProcess</body><body package="Store-UI" selector="observedProcess:">observedProcess: anObject	observedProcess := anObject</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>displaying</category><body package="Store-UI" selector="displayOn:">displayOn: aGC	self isActive ifFalse: [^self stopFeedback].	timer ifNil: [self startFeedback].	self displayProgressOn: aGC</body><body package="Store-UI" selector="displayProgressOn:">displayProgressOn: aGC	| icon |	icon := self currentProgressIcon.	icon displayOn: aGC at: self bounds center - icon bounds center</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>bounds accessing</category><body package="Store-UI" selector="preferredBounds">preferredBounds	^self currentProgressIcon preferredBounds</body><body package="Store-UI" selector="preferredHeight">preferredHeight	^self currentProgressIcon preferredHeight</body><body package="Store-UI" selector="preferredWidth">preferredWidth	^self currentProgressIcon preferredWidth</body></methods><methods><class-id>Store.ProcessHealthView</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	isActive := [false].	progressIndex := 0</body><body package="Store-UI" selector="release">release	self stopFeedback.	super release</body><body package="Store-UI" selector="stopFeedback">stopFeedback	timer ifNotNil: #stop.	timer := observedProcess := lastContext := nil</body></methods><methods><class-id>Store.ProcessHealthView class</class-id> <category>example</category><body package="Store-UI" selector="example">example	"self example"	| window view |	window := ScheduledWindow new.	view := self new.	window component: view.	window openWithExtent: 25 @ 25.	view isActive: [InputState default shiftDown not]</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="displaysProtocolStatus">displaysProtocolStatus	^true</body><body package="Store-Merge Management" selector="isMeta">isMeta	| storeObject |	storeObject := (base ifNil: [original ifNil: [proposed]]).	(storeObject isNil or: [storeObject isString or: [storeObject isStandardResolution not]]) ifTrue: [storeObject := alternatives detect: [:each | each isStandardResolution] ifNone: [^false]].	^storeObject value isMeta</body><body package="Store-Merge Management" selector="isMethodResolver">isMethodResolver	^true</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	| class |	proposed ifNil: [^false].	proposed isRemovalResolution ifFalse: [^false].	(class := base value correspondingImageClass) ifNil: [^true].	(class selectors includes: self selector) ifFalse: [^true].	^((Registry containingPackageForSelector: self selector asSymbol  class: class) name = proposed package name) not</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="baseProtocol">baseProtocol	base ifNil: [^''].	^base value protocol</body><body package="Store-Merge Management" selector="browseVersions">browseVersions	| alternative list selectorName session |	alternative := self standardResolutionAlternative.	alternative		ifNil: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: self definitionName)].	selectorName := alternative value selector asString.	session := alternative key session.	(Gathering for: self ownerName , '&gt;&gt;' , self shortTreeName) started.	list := self owningEnvironment				ifNil: [StoreMethodInPackage allVersionsWithName: selectorName in: session]				ifNotNil: 					[StoreMethodInPackage						allVersionsWithName: selectorName						inClass: self owningEnvironment absoluteName						in: session].	(Gathering for: self ownerName , '&gt;&gt;' , self shortTreeName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: selectorName)].	DefinitionForListTool forMethods: list</body><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	anAlternative isUserInputResolution ifTrue: [^anAlternative value].	^anAlternative value ifNotNil: 		[:value | 		value isString			ifTrue: [value]			ifFalse: [	value definitionString]]</body><body package="Store-Merge Management" selector="listIcon">listIcon	^CompiledMethod toolListIcon</body><body package="Store-Merge Management" selector="longListName">longListName	| string |	string := self longTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="longOwnerName">longOwnerName	| name |	name := self ownerName.	(name includes: $.) ifTrue: 		[^('Root.*' match: name)			ifTrue: [name]			ifFalse: ['Root.', name]].	^'Root.Smalltalk.' , name</body><body package="Store-Merge Management" selector="longTreeName">longTreeName	| string |	string := self longOwnerName, '&gt;&gt;', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName	| storeMethod extension |	storeMethod := alternatives detect: [:each | each isStandardResolution] ifNone: [^'unknonwn'].	extension := storeMethod value isMeta		ifTrue: [' (class method)']		ifFalse: [''].	^'#', storeMethod value name , extension</body><body package="Store-Merge Management" selector="originalProtocol">originalProtocol	original ifNil: [^''].	original isRemovalResolution ifTrue: [^''].	^original value protocol</body><body package="Store-Merge Management" selector="otherString">otherString	^self isApplyable not		ifTrue: [(#MethodSpaceParenInformational1s2s &lt;&lt; #store &gt;&gt; ' (Informational: Not Resolvable)&lt;n&gt;This method was originally on class &lt;1s&gt;&lt;n&gt;That class is now a Shared Variable (&lt;2s&gt;)') expandMacrosWith: ownerName with: (ownerName asQualifiedReference value name)]		ifFalse: ['']</body><body package="Store-Merge Management" selector="proposedProtocol">proposedProtocol	proposed ifNil: [^''].	^proposed value isString		ifTrue: ['']		ifFalse: 			[proposed isRemovalResolution 				ifTrue: [proposed value value protocol] 				ifFalse: 					[proposed isUserInputResolution						ifTrue: [proposed protocol ifNil: ['']]						ifFalse: [proposed value protocol]]]</body><body package="Store-Merge Management" selector="protocolStringFrom:">protocolStringFrom: aResolutionPackageItem	(self alternatives 		detect: [:each | each = aResolutionPackageItem alternative]		ifNone: [nil]) ifNotNil: 			[:value | 			value isRemovalResolution ifTrue: [^nil].			value isDoNothingResolution ifTrue: [^nil].			^value isUserInputResolution				ifTrue: [value protocol asString]				ifFalse: [value value protocol]].	^nil</body><body package="Store-Merge Management" selector="selector">selector	| alternative |	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	^alternative value selector</body><body package="Store-Merge Management" selector="shortListName">shortListName	| string |	string := self ownerName, '&gt;&gt;', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName	| string |	string := self mergeDisplayName, self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body><body package="Store-Merge Management" selector="unapplyableString">unapplyableString	^#MethodSpaceParenInformational1s2s3s &lt;&lt; #store &gt;&gt;			' (Informational: Not Resolvable) is for information purposes only, and is not resolvable.&lt;n&gt;This method was originally on class &lt;1s&gt;&lt;n&gt;That class is now a Shared Variable (&lt;2s&gt;)&lt;n&gt;To see all modifications, it is important that this package (&lt;3s&gt;) be reconciled with the database.'		expandMacrosWith: ownerName		with: ownerName asQualifiedReference value name		with: (base ifNil: [original]) package name</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply		| result |	applyable ifFalse: [^true].	proposed isAbsentResolution ifTrue: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isNoOpResolution ifTrue: [^true].	proposed isUserInputResolution ifTrue: [^proposed applyUsing: self].	self hasOverrideAndShouldApply ifFalse: [^false].	Policies packagePolicy 		forcePackage: proposed key storeModel 		while: 			[[[result := proposed value loadSource]				on: RedefinitionNotification				do: 					[:notification | 					notification currentPackage name = proposed key storeModel name ifFalse: [notification override install].					notification resume]]						on: Error						do: 							[:exception | 							Transcript show: (#nApplyingMethodChangeFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Method Change Failed &lt;2s&gt; : &lt;1s&gt;' 									expandMacrosWith: exception messageText									with: self definitionName).								exception return: nil]].	^result notNil</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	| selector class result |	selector := base value selector.	(class := base value correspondingImageClass) ifNil: [^true].	result := [Override				unloadSelector: selector				class: class				from: proposed package storeModel				logged: true]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingRemovalMethodFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Method &lt;2s&gt; Failed: &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self ownerName, '&gt;&gt;', self shortTreeName).			exception return: #failed].	^result ~= #failed</body><body package="Store-Merge Management" selector="existingOverrides">existingOverrides	^(Override overridesForSelector: self selector class: self owningEnvironment) ifNil: [#()].</body><body package="Store-Merge Management" selector="hasOverrideAndShouldApply">hasOverrideAndShouldApply		self potentialOverride ifNotNil:		[:value | 		value name = proposed key name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed key name) ifFalse: 				[Transcript show: (#nDidNotApplyOverrideOfMethod1sin2s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply override of method &lt;1s&gt; in &lt;2s&gt;' 					expandMacrosWith: self longTreeName					with: proposed key name).				^false]]].	^true</body><body package="Store-Merge Management" selector="makeProposalForAddedAlreadyInImage">makeProposalForAddedAlreadyInImage		applied ifTrue: [^self].	(original notNil and: [proposed notNil and: [original isStandardResolution and: [proposed isStandardResolution]]])		ifTrue: 			[(proposed resolver = original resolver and: [original package ~= proposed package or: 			[original package = proposed package and: [original package hasBeenModified not]]]) 				ifTrue: [applied := true]].	(original notNil and: [base notNil and: [proposed notNil and: [base isStandardResolution and: [proposed isStandardResolution]]]])		ifTrue: [(proposed resolver = base resolver and: [base package ~= proposed package]) ifTrue: [applied := true]]</body><body package="Store-Merge Management" selector="makeProposalForMatchingMethod">makeProposalForMatchingMethod	applied ifTrue: [^self].		(original isNil and: [proposed notNil and: [proposed isStandardResolution]]) ifTrue:		[proposed value correspondingImageMethod ifNotNil:			[:value | 			(value getSource asString = proposed value definitionString and:			[value protocol asString = proposed value protocol asString and:			[proposed package name = ((Registry componentDefiningSelector: value selector class: value mclass) ifNotNil: [:component | component name])]])				ifTrue:					[applied := true.					original := proposed]]]</body><body package="Store-Merge Management" selector="makeProposalForRemovalsMatchingOrignial">makeProposalForRemovalsMatchingOrignial		applied ifTrue: [^self].	(proposed notNil and: [original notNil and: [proposed isRemovalResolution and: [original isRemovalResolution]]]) ifTrue: [applied := true]</body><body package="Store-Merge Management" selector="makeResolutionProposals">makeResolutionProposals		applied ifTrue: [^self].	super makeResolutionProposals.	self makeProposalForMatchingMethod.	self removeProposalForMismatchingPackages.	self makeProposalForRemovalsMatchingOrignial.	self makeProposalForAddedAlreadyInImage.</body><body package="Store-Merge Management" selector="potentialOverride">potentialOverride		^Registry trueContainingPackageForSelector: self selector class: (self owningEnvironment ifNil: [^nil])</body><body package="Store-Merge Management" selector="proceedWithPossibleOverrideFrom:to:">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingChangeWillCause1snIn2sAsOverideIn3snnProceed &lt;&lt; #store &gt;&gt; 'Applying this change will cause &lt;n&gt;Method "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;to be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: self longTreeName			with: aPackageName			with: anotherPackageName)</body><body package="Store-Merge Management" selector="protocolStringFor:">protocolStringFor: aResolution	^aResolution isRemovalResolution 		ifTrue: [aResolution value value protocol] 		ifFalse: 			[aResolution isUserInputResolution				ifTrue: [aResolution protocol ifNil: ['']]				ifFalse: [aResolution value protocol]]</body><body package="Store-Merge Management" selector="removeProposalForMismatchingPackages">removeProposalForMismatchingPackages		applied ifFalse: [^self].	(proposed notNil and: [proposed isStandardResolution]) ifTrue:		[proposed value correspondingImageMethod 			ifNotNil:				[:value | 				(value getSource asString = proposed value definitionString and:				[value protocol asString = proposed value protocol asString and:				[proposed package name = ((Registry componentDefiningSelector: value selector class: value mclass) ifNotNil: [:component | component name])]])					ifFalse: [applied := false]]			ifNil: [applied := false]]</body></methods><methods><class-id>Store.Glorp.MethodChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="loadSourceUsing:">loadSourceUsing: aUserInputResolution	"Answer true if it is OK, or false if something bad happened"	| class myProtocol result |	class := self owningEnvironment.	myProtocol := aUserInputResolution protocolName.	self hasOverrideAndShouldApply ifFalse: [^false].	result := class		compile: aUserInputResolution text		classified: myProtocol		notifying: nil		environment: class environment.	^result notNil</body><body package="Store-Merge Management" selector="owningEnvironment">owningEnvironment	| resolution imageClass |	ownerName asQualifiedReference bindingOrNil ifNotNil: 		[:value | value value ifNotNil: 			[:class | 				^self isMeta				ifTrue: [class class]				ifFalse: [class]]].	resolution := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	imageClass := resolution value correspondingImageClass.	^self isMeta		ifTrue: [imageClass class]		ifFalse: [imageClass]</body><body package="Store-Merge Management" selector="usePatternWhenParsing">usePatternWhenParsing		^false</body><body package="Store-Merge Management" selector="validateParse:">validateParse: aNodeHolder	| mainStatementNode alternative oldNode oldStatementNode |	self owningEnvironment ifNil:		[self unavailableOwnerNotice.		^nil].	mainStatementNode := aNodeHolder node.	alternative := alternatives detect: [:each | each isStandardResolution] ifNone: [^nil].	oldNode := self parseDefinition: alternative value definition in: self owningEnvironment.	oldStatementNode := oldNode node.	oldStatementNode selector = mainStatementNode selector ifFalse:		[Dialog warn: #SelectorDefinitionMustNotChange &lt;&lt; #store &gt;&gt; 'Selector definition must not change'.		^nil].	^aNodeHolder</body></methods><methods><class-id>Store.NullPackageCanNotBeSavedError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	Dialog warn: (#TheNullPackageCannotBeSaved &lt;&lt; #store &gt;&gt; 'The Null package cannot be saved.') asString.	^false</body></methods><methods><class-id>Store.NullPackageCanNotBeSavedError class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	self updateGroupList.	self updateUserList.	self updateGraph.	self setButtons.</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>aspects</category><body package="Store-UI-Graphs" selector="groupList">groupList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^groupList isNil		ifTrue:			[groupList := SelectionInList new]		ifFalse:			[groupList]</body><body package="Store-UI-Graphs" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="perspective">perspective	^#tt_containsAdjacent</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="addToGroup">addToGroup		| user group |	user := userList selection.	group := groupList selection.	(user isNil or: [group isNil]) ifTrue:		[^Dialog warn:			(#SelectGroupAndMemberToAdd &lt;&lt; #store &gt;&gt; 'Select a group and group member (user) that&lt;n&gt;you wish to add before pressing this button') expandMacros].	StoreUserGroup newUserNamed: user inGroupNamed: group.	self updateGraph</body><body package="Store-UI-Graphs" selector="listChange">listChange	self updateGraph.	self setButtons.</body><body package="Store-UI-Graphs" selector="newGroup">newGroup	| group |	[group := Dialog request: #NewGroupName &lt;&lt; #store &gt;&gt; 'New Group Name:'.	group isEmpty ifTrue: [^self].	self groupList list includes: group] whileTrue: 		[Dialog warn: (#Group1sAlreadyExists &lt;&lt; #store &gt;&gt; 'Group &lt;1s&gt; already exists' expandMacrosWith: group)].	StoreUserGroup newGroupNamed: group.	self updateGroupList.	self groupList selection: group.	self updateGraph</body><body package="Store-UI-Graphs" selector="newUser">newUser		| group user |	group := groupList selection.	group size = 0 ifTrue: [^Dialog warn: #PleaseSelectAGroup &lt;&lt; #store &gt;&gt; 'Please select a group'].	[user := Dialog request: #NewUserName &lt;&lt; #store &gt;&gt; 'New user name:'.	user isEmpty ifTrue: [^self].	(self userList list includes: user) or: [self groupList list includes: user]] whileTrue: 		[Dialog warn: (#UserORGroup1sAlreadyExists &lt;&lt; #store &gt;&gt; 'User or Group ''&lt;1s&gt;'' already exists' expandMacrosWith: user)].	StoreUserGroup newUserNamed: user inGroupNamed: group.	self updateUserList.	self userList selection: user.	self updateGraph</body><body package="Store-UI-Graphs" selector="removeFromGroup">removeFromGroup	| user group |	user := userList selection.	group := groupList selection.	(user isNil or: [group isNil]) ifTrue: 		[^Dialog warn: (#SelectGroupAndMemberToRemove &lt;&lt; #store &gt;&gt; 'Select a group and group member (user) that&lt;n&gt;you wish to remove before pressing this button')  expandMacros].	StoreUserGroup removeUserNamed: user inGroupNamed: group.	self updateGraph</body><body package="Store-UI-Graphs" selector="updateGraph">updateGraph	"Our graph here is Group on the left, and arrows to users on the right... only"	| focus cache |	focus := Set new.	cache := Dictionary new.	groupList selection notNil ifTrue: [focus add: (GroupElement element: groupList selection cache: cache)].	self graphView focus: focus.</body><body package="Store-UI-Graphs" selector="updateGroupList">updateGroupList	self groupList list: StoreUserGroup allGroupNames</body><body package="Store-UI-Graphs" selector="updateUserList">updateUserList	self userList list: StoreUserGroup allUserNames</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>private</category><body package="Store-UI-Graphs" selector="setButtons">setButtons	| enable |	enable := ( ( userList selection ~~ nil ) and: [ groupList selection ~~ nil ] ).	( builder componentAt: #addToGroup ) isEnabled: enable.	( builder componentAt: #removeFromGroup )  isEnabled: enable.	( builder componentAt: #newUser ) isEnabled: ( groupList selection ~~ nil ).</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs" selector="initializePerspectives">initializePerspectives	"self initializePerspectives"	^(List new) add: ((Array new: 9)			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: 	#(#(#V1 #F1 'tt_contains' true true false true true) 						   #(#F1 #V2 'tt_contains' true true false true true) );			at: 4 put: #arrLabelHints:;			at: 5 put: #();			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_contains';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue purple;					at: 5 put: 1; yourself);  yourself);			at: 8 put: #name:;			at: 9 put: #tt_containsAdjacent; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs" selector="initializeRelationships">initializeRelationships	"self initializeRelationships"	^List new 		add: #( #LDMFirstOrderRel #name: 'tt_contains' #description: 'contains' 				#reverse: nil #token: #tt_containsRel) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_containsR' #description: 'containsR' 				#reverse: nil #token: #tt_containsRRel) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="addedBundleProperties">addedBundleProperties	^addedBundleProperties</body><body package="Store-Code Comparison" selector="addedBundleProperties:">addedBundleProperties: anObject	addedBundleProperties := anObject</body><body package="Store-Code Comparison" selector="addedClasses">addedClasses	^addedClasses</body><body package="Store-Code Comparison" selector="addedClasses:">addedClasses: anObject	addedClasses := anObject</body><body package="Store-Code Comparison" selector="addedMethods">addedMethods	^addedMethods</body><body package="Store-Code Comparison" selector="addedMethods:">addedMethods: anObject	addedMethods := anObject</body><body package="Store-Code Comparison" selector="addedNamespaces">addedNamespaces	^addedNamespaces</body><body package="Store-Code Comparison" selector="addedNamespaces:">addedNamespaces: anObject	addedNamespaces := anObject</body><body package="Store-Code Comparison" selector="addedPackageProperties">addedPackageProperties	^addedPackageProperties</body><body package="Store-Code Comparison" selector="addedPackageProperties:">addedPackageProperties: anObject	addedPackageProperties := anObject</body><body package="Store-Code Comparison" selector="addedSharedVariables">addedSharedVariables	^addedSharedVariables</body><body package="Store-Code Comparison" selector="addedSharedVariables:">addedSharedVariables: anObject	addedSharedVariables := anObject</body><body package="Store-Code Comparison" selector="allClassReferences">allClassReferences	^(Set withAll: removedClasses keys)		addAll: addedClasses keys;		addAll: addedMethods keys;		addAll: removedMethods keys;		yourself</body><body package="Store-Code Comparison" selector="allNamespaceReferences">allNamespaceReferences	^(Set withAll: removedNamespaces keys)		addAll: addedNamespaces keys;		yourself</body><body package="Store-Code Comparison" selector="allPropertyBundleNames">allPropertyBundleNames	^(Set withAll: addedBundleProperties keys)		addAll: removedBundleProperties keys;		yourself</body><body package="Store-Code Comparison" selector="allPropertyPackageNames">allPropertyPackageNames	^(Set withAll: removedPackageProperties keys)		addAll: addedPackageProperties keys;		yourself</body><body package="Store-Code Comparison" selector="allSharedVariableReferences">allSharedVariableReferences	^(Set withAll: removedSharedVariables keys)		addAll: addedSharedVariables keys;		yourself</body><body package="Store-Code Comparison" selector="leftCodeComponents">leftCodeComponents	^leftCodeComponents</body><body package="Store-Code Comparison" selector="leftCodeComponents:">leftCodeComponents: anObject	leftCodeComponents := anObject</body><body package="Store-Code Comparison" selector="removedBundleProperties">removedBundleProperties	^removedBundleProperties</body><body package="Store-Code Comparison" selector="removedBundleProperties:">removedBundleProperties: anObject	removedBundleProperties := anObject</body><body package="Store-Code Comparison" selector="removedClasses">removedClasses	^removedClasses</body><body package="Store-Code Comparison" selector="removedClasses:">removedClasses: anObject	removedClasses := anObject</body><body package="Store-Code Comparison" selector="removedMethods">removedMethods	^removedMethods</body><body package="Store-Code Comparison" selector="removedMethods:">removedMethods: anObject	removedMethods := anObject</body><body package="Store-Code Comparison" selector="removedNamespaces">removedNamespaces	^removedNamespaces</body><body package="Store-Code Comparison" selector="removedNamespaces:">removedNamespaces: anObject	removedNamespaces := anObject</body><body package="Store-Code Comparison" selector="removedPackageProperties">removedPackageProperties	^removedPackageProperties</body><body package="Store-Code Comparison" selector="removedPackageProperties:">removedPackageProperties: anObject	removedPackageProperties := anObject</body><body package="Store-Code Comparison" selector="removedSharedVariables">removedSharedVariables	^removedSharedVariables</body><body package="Store-Code Comparison" selector="removedSharedVariables:">removedSharedVariables: anObject	removedSharedVariables := anObject</body><body package="Store-Code Comparison" selector="rightCodeComponents">rightCodeComponents	^rightCodeComponents</body><body package="Store-Code Comparison" selector="rightCodeComponents:">rightCodeComponents: anObject	rightCodeComponents := anObject</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>private</category><body package="Store-Code Comparison" selector="allSortedCodeComponents:">allSortedCodeComponents: aSequenceOfCodeComponents	"Given aSequenceOfCodeComponents, return a sequence which includes thos elements, plus any contained packages and bundles in the originals. Return the results in a deterministic sort order."	| coerced expanded flattened withoutDuplicates sorted session |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	coerced := aSequenceOfCodeComponents				collect: [:each | each asStoreComparisonObjectIn: session].	expanded := coerced collect: #withAllContainedItems.	flattened := self flatten: expanded.	withoutDuplicates := Set withAll: flattened.	sorted := withoutDuplicates				sorted: [:a :b | a name = b name ifTrue: [a isBundle] ifFalse: [a name &lt;= b name]].	^sorted</body><body package="Store-Code Comparison" selector="flatten:">flatten: aSequenceOfSequences	"Given an Collection of nested collections, reduce it to one single linear sequence."	^aSequenceOfSequences inject: Array new into: [:accum :each | accum , each]</body><body package="Store-Code Comparison" selector="select:matchesFrom:">select: aDictionary matchesFrom: aCodeComponentCollection	"Given aDictionary whose values are Blueprint objects, return a copy of the Dictionary which contains only Blueprints that are referenced by one of the members of aCodeComponentCollection."	^aDictionary select: 			[:eachBlueprint |			aCodeComponentCollection				anySatisfy: [:eachCodeComponent | eachBlueprint belongsToCodeComponent: eachCodeComponent]]</body><body package="Store-Code Comparison" selector="select:sequenceMatchesFrom:">select: aDictionary sequenceMatchesFrom: aCodeComponentCollection	"Given aDictionary whose values are Arrays of Blueprint objects, return a copy of the Dictionary which contains only Blueprints that are referenced by one of the members of aCodeComponentCollection."	^(aDictionary collect: 			[:eachBlueprintSequence |			eachBlueprintSequence select: 					[:eachBlueprint |					aCodeComponentCollection						anySatisfy: [:eachCodeComponent | eachBlueprint belongsToCodeComponent: eachCodeComponent]]])		reject: #isEmpty</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="cleanseUnchangedComponents">cleanseUnchangedComponents	"Remove any of members of leftCodeComponents or rightCodeComponents, for which we have no blueprints referencing them."	| toRemove filterBlock |	toRemove := leftCodeComponents , rightCodeComponents.	filterBlock :=			[:blueprint |			toRemove isEmpty				ifFalse: 					[| matches |					matches := toRemove								select: [:each | blueprint belongsToCodeComponent: each].					toRemove := toRemove reject: [:each | matches includes: each]]].	removedMethods		do: [:eachSequenceOfMethods | eachSequenceOfMethods do: filterBlock].	removedClasses do: filterBlock.	removedNamespaces do: filterBlock.	removedSharedVariables do: filterBlock.	removedPackageProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	removedBundleProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	addedMethods		do: [:eachSequenceOfMethods | eachSequenceOfMethods do: filterBlock].	addedClasses do: filterBlock.	addedNamespaces do: filterBlock.	addedSharedVariables do: filterBlock.	addedPackageProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	addedBundleProperties		do: [:eachSequenceOfProperties | eachSequenceOfProperties do: filterBlock].	rightCodeComponents := rightCodeComponents				reject: [:each | toRemove includes: each].	leftCodeComponents := leftCodeComponents				reject: [:each | toRemove includes: each]</body><body package="Store-Code Comparison" selector="cleanseUnmatchedChanges">cleanseUnmatchedChanges	"Remove all blueprints that don't reference one of the code components found in my leftCodeComponents or rightCodeComponents."	removedSharedVariables := self select: removedSharedVariables				matchesFrom: leftCodeComponents.	addedSharedVariables := self select: addedSharedVariables				matchesFrom: rightCodeComponents.	removedNamespaces := self select: removedNamespaces				matchesFrom: leftCodeComponents.	addedNamespaces := self select: addedNamespaces				matchesFrom: rightCodeComponents.	removedClasses := self select: removedClasses				matchesFrom: leftCodeComponents.	addedClasses := self select: addedClasses matchesFrom: rightCodeComponents.	removedMethods := self select: removedMethods				sequenceMatchesFrom: leftCodeComponents.	addedMethods := self select: addedMethods				sequenceMatchesFrom: rightCodeComponents.	removedPackageProperties := self select: removedPackageProperties				sequenceMatchesFrom: leftCodeComponents.	addedPackageProperties := self select: addedPackageProperties				sequenceMatchesFrom: rightCodeComponents.	removedBundleProperties := self select: removedBundleProperties				sequenceMatchesFrom: leftCodeComponents.	addedBundleProperties := self select: addedBundleProperties				sequenceMatchesFrom: rightCodeComponents</body><body package="Store-Code Comparison" selector="compute">compute	| leftMethods leftProperties rightMethods rightProperties leftSharedVariables rightSharedVariables sharedVariableDiffs namespaceDiffs classDiffs methodDiffs leftClasses leftNamespaces rightClasses rightNamespaces propertyDiffs |	leftMethods := OrderedCollection new.	leftClasses := OrderedCollection new.	leftNamespaces := OrderedCollection new.	leftSharedVariables := OrderedCollection new.	leftProperties := OrderedCollection new.	rightMethods := OrderedCollection new.	rightClasses := OrderedCollection new.	rightNamespaces := OrderedCollection new.	rightSharedVariables := OrderedCollection new.	rightProperties := OrderedCollection new.	leftCodeComponents do: 			[:each |			Store.Reading for: each				while: 					[leftMethods addAll: each methodBlueprints.					leftClasses addAll: each classBlueprints.					leftNamespaces addAll: each namespaceBlueprints.					leftSharedVariables addAll: each sharedVariableBlueprints.					leftProperties addAll: each propertyBlueprints]].	rightCodeComponents do: 			[:each |			Store.Reading for: each				while: 					[rightMethods addAll: each methodBlueprints.					rightClasses addAll: each classBlueprints.					rightNamespaces addAll: each namespaceBlueprints.					rightSharedVariables addAll: each sharedVariableBlueprints.					rightProperties addAll: each propertyBlueprints]].	leftMethods := leftMethods asArray sort.	leftClasses := leftClasses asArray sort.	leftNamespaces := leftNamespaces asArray sort.	leftSharedVariables := leftSharedVariables asArray sort.	leftProperties := leftProperties asArray sort.	rightMethods := rightMethods asArray sort.	rightClasses := rightClasses asArray sort.	rightNamespaces := rightNamespaces asArray sort.	rightSharedVariables := rightSharedVariables asArray sort.	rightProperties := rightProperties asArray sort.	sharedVariableDiffs := leftSharedVariables				differences: rightSharedVariables.	removedSharedVariables := ((self				flatten: (sharedVariableDiffs select: #isDelete)) groupedBy: #reference)				collect: #any.	addedSharedVariables := ((self				flatten: (sharedVariableDiffs select: #isInsert)) groupedBy: #reference)				collect: #any.	namespaceDiffs := leftNamespaces differences: rightNamespaces.	removedNamespaces := ((self flatten: (namespaceDiffs select: #isDelete))				groupedBy: #reference) collect: #any.	addedNamespaces := ((self flatten: (namespaceDiffs select: #isInsert))				groupedBy: #reference) collect: #any.	classDiffs := leftClasses differences: rightClasses.	removedClasses := ((self flatten: (classDiffs select: #isDelete))				groupedBy: #reference) collect: #any.	addedClasses := ((self flatten: (classDiffs select: #isInsert))				groupedBy: #reference) collect: #any.	methodDiffs := leftMethods differences: rightMethods.	removedMethods := (self flatten: (methodDiffs select: #isDelete))				groupedBy: #classReference.	addedMethods := (self flatten: (methodDiffs select: #isInsert))				groupedBy: #classReference.	propertyDiffs := (leftProperties select: #isPackage)				differences: (rightProperties select: #isPackage).	removedPackageProperties := (self				flatten: (propertyDiffs select: #isDelete)) groupedBy: #codeComponentName.	addedPackageProperties := (self flatten: (propertyDiffs select: #isInsert))				groupedBy: #codeComponentName.	propertyDiffs := (leftProperties select: #isBundle)				differences: (rightProperties select: #isBundle).	removedBundleProperties := (self				flatten: (propertyDiffs select: #isDelete)) groupedBy: #codeComponentName.	addedBundleProperties := (self flatten: (propertyDiffs select: #isInsert))				groupedBy: #codeComponentName.	self cleanseUnchangedComponents</body><body package="Store-Code Comparison" selector="leftCodeComponents:rightCodeComponents:">leftCodeComponents: aCodeComponentsCollection rightCodeComponents: bPackageSequence	"For a given set of from and to arguments, first expand them to include any contained bundles or packages, then filter out all that don't actually change between the two (e.g. when we find that Package XYZ is the exact same version as the counterpart package in the other list."	| componentDiffs |	leftCodeComponents := self				allSortedCodeComponents: aCodeComponentsCollection.	rightCodeComponents := self allSortedCodeComponents: bPackageSequence.	componentDiffs := (SequenceableCollectionDifferences new)				comparisonFunction: [:a :b | a sameVersionAs: b];				differencesFrom: leftCodeComponents to: rightCodeComponents.	leftCodeComponents := self flatten: (componentDiffs select: #isDelete).	rightCodeComponents := self flatten: (componentDiffs select: #isInsert)</body></methods><methods><class-id>Tools.CodeComponentComparison</class-id> <category>converting</category><body package="Store-Code Comparison" selector="invert">invert	"swap the left/right and added/remove values."	| temp |	temp := leftCodeComponents.	leftCodeComponents := rightCodeComponents.	rightCodeComponents := temp.	temp := addedMethods.	addedMethods := removedMethods.	removedMethods := temp.	temp := addedClasses.	addedClasses := removedClasses.	removedClasses := temp.	temp := addedNamespaces.	addedNamespaces := removedNamespaces.	removedNamespaces := temp.	temp := addedSharedVariables.	addedSharedVariables := removedSharedVariables.	removedSharedVariables := temp.	temp := addedPackageProperties.	addedPackageProperties := removedPackageProperties.	removedPackageProperties := temp.	temp := addedBundleProperties.	addedBundleProperties := removedBundleProperties.	removedBundleProperties := temp</body><body package="Store-Code Comparison" selector="withoutComponents:">withoutComponents: aCollectionOfCodeComponents	"Return a reduced copy, of me with all members of aCollectionOfCodeComponents and any blueprints that reference them, removed."	| reduced |	reduced := self copy.	reduced leftCodeComponents: (leftCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	reduced rightCodeComponents: (rightCodeComponents				reject: [:each | aCollectionOfCodeComponents includes: each]).	^reduced cleanseUnmatchedChanges</body></methods><methods><class-id>Store.Glorp.StoreSelectorNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="allMethodDefinitionsFor:in:">allMethodDefinitionsFor: aProtocol in: class		| selectors |	selectors := OrderedCollection new.	self		inheritedClassesOf: class		do:			[:each | 			selectors addAll: ((navigator environment selectorsFor: aProtocol in: each)				collect: [:eachSelector | StoreMethodDefinition class: class implementor: each selector: eachSelector])].	^selectors</body><body package="StoreForGlorpBrowserUI" selector="allSelectorsIn:">allSelectorsIn: aNavigatorState		| selectors classes class |	classes := aNavigatorState selectedClasses.	classes size ~= 1 ifTrue: [^#()].	class := classes asArray first.	selectors := self environment selectorsForClass: class.	^selectors collect: [:each | StoreMethodDefinition class: class selector: each]</body></methods><methods><class-id>Store.Glorp.StoreSelectorNavigatorPart</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="showIcons">showIcons	^false</body></methods><methods><class-id>Store.RequestInstallDatabaseTables</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	^Dialog confirm: (#StoreDatabaseTablesNotInDatabaseCreate &lt;&lt; #store &gt;&gt; 'The Store database tables do not appear to be in the current database&lt;n&gt;Install Store database tables?') expandMacros</body></methods><methods><class-id>Store.RequestInstallDatabaseTables</class-id> <category>constants</category><body package="Store-Base" selector="defaultResumeValue">defaultResumeValue	^true</body><body package="Store-Base" selector="defaultReturnValue">defaultReturnValue	^true</body></methods><methods><class-id>Store.RequestInstallDatabaseTables class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="doInitialExpansion">doInitialExpansion	self list list isEmpty		ifTrue: [^self].	self contractAll.	self expandUnresolved.	self treeModel size &gt; self policyMaxListSize		ifTrue: [^self].	self treeModel expandToLevel: 1.	self treeModel size &gt; self policyMaxListSize		ifTrue:			[self contractAll.			^self expandUnresolved].	self treeModel expandToLevel: 2.	self treeModel size &gt; self policyMaxListSize		ifTrue:			[self contractAll.			self expandUnresolved.			^self treeModel expandToLevel: 1].</body><body package="Store-Merge Management" selector="release">release	oldTree := list list.	super release.</body><body package="Store-Merge Management" selector="reset">reset	root := mergeTool resolutionManager.	self list list: TreeModel new.</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>private</category><body package="Store-Merge Management" selector="buildResolutionsTree">buildResolutionsTree	| model |	self setListWidgetDisplayStringSelector.	model := TreeModel 		on: root		displayRoot: false		childrenWith: [:item | item sortedTreeResolutionValues: mergeTool show]		testHasChildrenWith: [:item | (item sortedTreeResolutionValues: mergeTool show) notEmpty].	self list list: model</body><body package="Store-Merge Management" selector="contractAll">contractAll	| i |	i := 1.	[i &lt; list list size]		whileTrue:			[self list list contractFully: i.			i := i + 1].</body><body package="Store-Merge Management" selector="expandAll">expandAll	self list list isEmpty		ifTrue: [^self].	self list list expandToLevel: 4.</body><body package="Store-Merge Management" selector="expandTree:for:">expandTree: aTree for: anObject 	"This method replaces TreeModel&gt;&gt;expandFound: except it does not	select a found index"	| path |	path := aTree pathToObject: anObject.	path isEmpty ifTrue: [^false].	path do: 		[:each | 		aTree expand: (aTree indexOf: each)].	^true</body><body package="Store-Merge Management" selector="expandTree:toCorrespondTo:">expandTree: aTreeModel toCorrespondTo: anotherTreeModel		| same |	same := true.	anotherTreeModel do: [:each | each openedChildren ifTrue: [same := (self expandTree: aTreeModel for: each value) and: [same]]].	^same</body><body package="Store-Merge Management" selector="expandUnresolved">expandUnresolved		| index |	index := 1.	[self treeModel size &gt;= index]		whileTrue:			[(self treeModel at: index) isResolved ifFalse: [self treeModel expand: index].			index := index + 1]</body><body package="Store-Merge Management" selector="policyMaxListSize">policyMaxListSize	^Policies mergePolicy mergeToolMaxInitialTreeSize</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>updating</category><body package="Store-Merge Management" selector="finishOpening">finishOpening		self list list isEmpty ifTrue: [^self].	self list list expandToLevel: 1</body><body package="Store-Merge Management" selector="showCodeDifferences">showCodeDifferences	mergeTool showCodeDifferences.</body><body package="Store-Merge Management" selector="showSourceDifferences">showSourceDifferences	mergeTool showSourceDifferences.</body><body package="Store-Merge Management" selector="updateResolutions">updateResolutions	oldTree := nil.	root := mergeTool resolutionManager.	self buildResolutionsTree.</body><body package="Store-Merge Management" selector="updateResolutionsWithoutRebuild">updateResolutionsWithoutRebuild	| selection |	selection := mergeTool selectedResolution.	oldTree := nil.	list list expandFound: selection.</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>accessing</category><body package="Store-Merge Management" selector="mergeTool:">mergeTool: aMergeTool	super mergeTool: aMergeTool.	root := aMergeTool resolutionManager</body><body package="Store-Merge Management" selector="tabLabel">tabLabel	^(#ModificationHierarchy &lt;&lt; #store &gt;&gt; 'Modification Hierarchy') asString</body><body package="Store-Merge Management" selector="treeModel">treeModel	^self list list</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>aspects</category><body package="Store-Merge Management" selector="list">list	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^list isNil		ifTrue:			[list := SelectionInTree new]		ifFalse:			[list]</body></methods><methods><class-id>Store.ResolutionsTreePane</class-id> <category>name style</category><body package="Store-Merge Management" selector="setShowLongNames">setShowLongNames	nameStyle := #longTreeName.</body><body package="Store-Merge Management" selector="setShowShortNames">setShowShortNames	nameStyle := #shortTreeName.</body></methods><methods><class-id>Store.ResolutionsTreePane class</class-id> <category>accessing</category><body package="Store-Merge Management" selector="tabLabel">tabLabel	^(#ModificationHierarchy &lt;&lt; #store &gt;&gt; 'Modification Hierarchy') asString</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPackage</class-id> <category>comparing</category><body package="Store-Database Model" selector="precedence">precedence	^2</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPackage</class-id> <category>testing</category><body package="Store-Database Model" selector="isBundle">isBundle	^false.</body></methods><methods><class-id>Store.Glorp.StoreVersionlessPackage class</class-id> <category>constants</category><body package="Store-Database Model" selector="pundleClass">pundleClass	^StorePackage.</body></methods><methods><class-id>Store.PublishMergeDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"Publish a collection of pundles.  It's possible there have been changes to the bundle since we opened the dialog, so regenerate our model before applying the spec."	| navigatorClass |	self validateParcelOptions ifFalse: [^self].	self validateFileOptions ifFalse: [^self].	(self specList allSatisfy: [:each | self canPublish: each pundle atBlessingLevel: each blessing]) ifFalse: [^self].	self newGlobalState.	self fillEmptyComments.	StoreProgressOverlay subsume: builder window while: 		[self specList publishPundleAsParts.		callBackBlock ifNotNil: [callBackBlock value: items list].		self specList reverseDo: 			[:each |			each pundle storeModel				ifNotNil: 					[:value |					value						dbTrace: each pundle primaryKey;						markNotModified]]].	navigatorClass := #{Refactory.Browser.BrowserNavigator} valueOrDo: [^self].	navigatorClass updatePackageListsInOpenWindows.	self closeAndUnschedule</body></methods><methods><class-id>Store.PublishMergeDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	super initialize</body></methods><methods><class-id>Store.PropertiesView</class-id> <category>private</category><body package="Store-DB-Records" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Records" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.PropertiesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="commentID">commentID	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: anObject	commentID := anObject</body><body package="Store-DB-Records" selector="definitionID">definitionID	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: anObject	definitionID := anObject</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: anObject	environmentString := anObject</body><body package="Store-DB-Records" selector="pundleRef">pundleRef	^pundleRef</body><body package="Store-DB-Records" selector="pundleRef:">pundleRef: anObject	pundleRef := anObject</body><body package="Store-DB-Records" selector="recType">recType	^recType</body><body package="Store-DB-Records" selector="recType:">recType: anObject	recType := anObject</body><body package="Store-DB-Records" selector="searchString">searchString	^searchString</body><body package="Store-DB-Records" selector="searchString:">searchString: anObject	searchString := anObject</body></methods><methods><class-id>Store.PropertiesView class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.PropertiesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'propertyRef'</body><body package="Store-DB-Records" selector="parentReference">parentReference	^'pundleRef'</body><body package="Store-DB-Records" selector="referencedClass">referencedClass	^PropertyRecord</body><body package="Store-DB-Records" selector="subCollectionClass">subCollectionClass	^Properties</body></methods><methods><class-id>Store.PropertiesView class</class-id> <category>session</category><body package="Atomic Compiling and Loading" selector="loadingPropertiesSession">loadingPropertiesSession	"LoadingPropertiesSession := nil"	| list |	list := Pundle loadingProperties collect:				[ :str | str asString printString ].	( self isSessionValid: LoadingPropertiesSession)		ifFalse:			[LoadingPropertiesSession := self broker getNewSession.			LoadingPropertiesSession bindOutput: self newPrimed.			LoadingPropertiesSession bindInput: Properties new.			LoadingPropertiesSession prepare: 						(self newSQL							selectAll;							where;							column: #pundleRef  equalTo: ':pundleRef';							and;							column: #recType equalTo: ':recType';							and;							column: #name equalToArray: list )			 ].	^LoadingPropertiesSession</body><body package="Store-DB-Records" selector="propertiesSession">propertiesSession	"PropertiesSession := nil"	( self isSessionValid: PropertiesSession)		ifFalse:			[PropertiesSession := self broker getNewSession.			PropertiesSession bindOutput: self newPrimed.			PropertiesSession bindInput: Properties new.			PropertiesSession prepare: 						(self newSQL							selectAll;							where;							column: #pundleRef  equalTo: ':pundleRef';							and;							column: #recType equalTo: ':recType') ].	^PropertiesSession</body><body package="Store-DB-Records" selector="resetSession">resetSession	"self resetSession"	PropertiesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: PropertiesSession].		PropertiesSession := nil].	LoadingPropertiesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: LoadingPropertiesSession].		LoadingPropertiesSession := nil]</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^false</body><body package="Store-Merge Management" selector="displaysProtocolStatus">displaysProtocolStatus	^true</body><body package="Store-Merge Management" selector="isBundleStructureResolver">isBundleStructureResolver	^true</body><body package="Store-Merge Management" selector="isForClass">isForClass	^false</body><body package="Store-Merge Management" selector="isForNamespace">isForNamespace	^false</body><body package="Store-Merge Management" selector="isForProperties">isForProperties	^true</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	^false</body><body package="Store-Merge Management" selector="sameDefinitionAs:">sameDefinitionAs: anArray	"Best we can do"	^true</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="baseProtocol">baseProtocol	^''</body><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative		| stream |	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	stream := WriteStream on: String new.	anAlternative isNoOpResolution		ifTrue: [stream nextPutAll: anAlternative value]		ifFalse: 			[anAlternative value 				do: 					[:each | 					stream 						nextPutAll: each first;						nextPutAll: ': ';						nextPutAll: each last printString] 					separatedBy: [stream cr]].	^stream contents</body><body package="Store-Merge Management" selector="listIcon">listIcon	^BehaviorIcons Array</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName		^(#BracketBundleStructureBracket &lt;&lt; #store &gt;&gt; '[Bundle Structure]') asString</body><body package="Store-Merge Management" selector="name">name		^self mergeDisplayName</body><body package="Store-Merge Management" selector="originalProtocol">originalProtocol	^''</body><body package="Store-Merge Management" selector="proposedProtocol">proposedProtocol	^''</body><body package="Store-Merge Management" selector="protocolStringFrom:">protocolStringFrom: aResolutionPackageItem	^(#BundleStructureCannotBeEdited &lt;&lt; #store &gt;&gt; 'Bundle Structure cannot be editied') asString</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	| result |	applyable ifFalse: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isAbsentResolution ifTrue: [^true].	proposed isNoOpResolution ifTrue: [^true].	result := [proposed package storeModel structure: proposed resolver]		on: Error		do:			[:exception | 			Transcript show: (#nApplyingStructureFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Bundle Structure Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: proposed package name).			exception return: nil].	^result notNil</body><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	applied ifTrue: [alternatives := OrderedCollection new].</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>user interface</category><body package="Store-Merge Management" selector="toolListIcon">toolListIcon	^BehaviorIcons Array</body></methods><methods><class-id>Store.Glorp.BundleStructureResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="parseText:">parseText: aString		^false</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>private</category><body package="Store-UI-Browser" selector="fileOut:onFilename:">fileOut: definitions onFilename: filename 	| output |	output := SourceCodeStream write: filename.	[definitions do: 		[:definition | 		definition fileOutDefinitionOn: output]] 			ensure: [output close]</body><body package="Store-UI-Browser" selector="promptForFilenameThenFileOut:">promptForFilenameThenFileOut: list	|filename|	filename := Dialog requestNewFileName: #FileOutOnC &lt;&lt; #store &gt;&gt;'File out on:' default: 'unloadable.st'.	filename isEmpty ifTrue: [^nil].	self fileOut: list onFilename: filename</body><body package="Store-UI-Browser" selector="selectedDefinitions">selectedDefinitions	^self selectionModule selections</body><body package="Store-UI-Browser" selector="selectedDefinitionsDo:">selectedDefinitionsDo: aBlock	^self selectionModule selectionDo: aBlock</body><body package="Store-UI-Browser" selector="setTextFrom:">setTextFrom: selections 	self text value: (selections isEmpty 				ifTrue: [String new]				ifFalse: 					[selections size = 1 						ifTrue: [selections first definition asText]						ifFalse: [(#MultipleDefinitionsSelected &lt;&lt; #store &gt;&gt; 'Multiple definitions are selected') asText allBold]])</body><body package="Store-UI-Browser" selector="windowLabel">windowLabel	^(#JustUnloadableDefinitions &lt;&lt; #store &gt;&gt; 'Unloadable Definitions') asString.</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>menu actions</category><body package="Store-UI-Browser" selector="briefHelp">briefHelp	|help|	help := SimpleHelp helpString: self class briefHelpString.	SimpleHelp openOn: help</body><body package="Store-UI-Browser" selector="fileOut">fileOut	self promptForFilenameThenFileOut: self selectedDefinitions</body><body package="Store-UI-Browser" selector="fileOutAll">fileOutAll	self promptForFilenameThenFileOut: selectionModule list</body><body package="Store-UI-Browser" selector="loadAll">loadAll	selectionModule listDo: 		[:definition | definition loadSrcInto: definition package]</body><body package="Store-UI-Browser" selector="loadDefinition">loadDefinition	self selectedDefinitionsDo: 		[:definition | definition loadSrcInto: definition package storeModel]</body><body package="Store-UI-Browser" selector="removeFromPackage">removeFromPackage	self selectedDefinitionsDo: 		[:definition | definition removeFromPackage: definition package storeModel]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>interface opening</category><body package="Store-UI-Browser" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(builder window)		application: self;		sendWindowEvents: #(#newGraphicsDevice #reopen).	(aBuilder menuAt: #menuBar) ifNotNil: 		[:menu | (menu atNameKey: #definition) submenu: self class definitionMenu].</body><body package="Store-UI-Browser" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self mainWindow label: self windowLabel.	(self widgetAt: #selectionModule)		client: selectionModule		spec: selectionModule preferredWindowSpec		builder: aBuilder newSubBuilder.	selectionModule selectionHolder 		onChangeSend: #definitionSelected to: self.	self widget: #viewers when: #tabChanged send: #viewerChanged to: self.	self viewerChanged</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>testing</category><body package="Store-UI-Browser" selector="anySelected">anySelected	^self selectedDefinitions notEmpty</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>initialize-release</category><body package="Store-UI-Browser" selector="definitions:">definitions: unloadableDefinitions	self selectionModule list: unloadableDefinitions.</body><body package="Store-UI-Browser" selector="initialize">initialize	super initialize.	selectionModule := ListSelectionModule new.	selectionModule useMultiSelection: true.	selectionModule displayStringSelector: #fullDisplayString.	selectionModule menuHolder: [self class definitionMenu] performer: self.	self viewerListHolder 		list: (Array with: (#Source &lt;&lt; #store &gt;&gt; 'Source') asString				with: (#Versions &lt;&lt; #store &gt;&gt; 'Versions') asString).	self viewerListHolder selectionIndex: 1</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>notifications</category><body package="Store-UI-Browser" selector="definitionSelected">definitionSelected	| selections |	selections := self selectedDefinitions.	self viewerChanged.	Cursor database showWhile: [self setTextFrom: selections]</body><body package="Store-UI-Browser" selector="viewerChanged">viewerChanged	| viewer |	viewer := self widgetAt: #viewers.	self viewerListHolder selectionIndex = 1 		ifTrue: [viewer client: self spec: #definitionSpec]		ifFalse: 			[| versionsViewer definitions |			versionsViewer := RecordVersionsViewer new.			definitions := self selectedDefinitions.			viewer client: versionsViewer spec: #verticalWindowSpec.			definitions notEmpty ifTrue: [versionsViewer versions: definitions first versions]]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="selectionModule">selectionModule	^selectionModule</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>aspects</category><body package="Store-UI-Browser" selector="text">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body><body package="Store-UI-Browser" selector="viewerListHolder">viewerListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^viewerListHolder isNil		ifTrue:			[viewerListHolder := SelectionInList new]		ifFalse:			[viewerListHolder]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer</class-id> <category>events</category><body package="Store-UI-Browser" selector="windowEvent:from:">windowEvent: anEvent from: aWindow 	super windowEvent: anEvent from: aWindow.	(#(#newGraphicsDevice #reopen) includes: anEvent key) 		ifTrue: [self closeAndUnschedule]</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Browser" selector="windowSpec">windowSpec	^self perform: self specPreference</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="briefHelpString">briefHelpString^#UnloadableDefinitionsHelpString &lt;&lt;#store &gt;&gt; 'This is a list of definitions which could not be loaded. Your options are:Load them. If there is a problem with your prerequisites or bundle load ordering, they may be loadable now. Fix the problem and republish.  Alternatively, if the load problem can be fixed without touching this package, you may wish to simply publish the containing bundle, quit your image and reload.Remove them from the package.  Any definitions that cannot be loaded should be removed. This is because Store publishes only deltas. A definition needs to be explicitly removed or it will remain there and the same problems will occur.Fileout. If a Class or NameSpace has been moved to a different NameSpace, your extension methods may not load.  You can file them out, edit the name and file them into your package. Remember to remove these old definitions from the package as explained above.'</body><body package="Store-UI-Browser" selector="specPreference">specPreference		^specPreference</body><body package="Store-UI-Browser" selector="specPreference:">specPreference: aSymbol		specPreference := aSymbol</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>interface opening</category><body package="Store-UI-Browser" selector="openOnDefinitions:">openOnDefinitions: unloadableDefinitions	| viewer |	viewer := self new.	viewer definitions: unloadableDefinitions.	viewer open.	^viewer</body><body package="Store-UI-Browser" selector="openOnExceptions:">openOnExceptions: exceptions	^self openOnDefinitions: (exceptions collect: [:each | each definitionRecord])</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>class initialization</category><body package="Store-UI-Browser" selector="initialize">initialize	specPreference := #horizontalWindowSpec</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="classListName">classListName	^self selectorListName</body><body package="Store-Difference Management" selector="differenceName">differenceName	^self selectorListName</body><body package="Store-Difference Management" selector="mainDefinition">mainDefinition	^mainObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management" selector="mainPackage:definition:">mainPackage: aPackage definition: aString	| definition |	definition := aString ifNotNil: [aString isEmpty ifTrue: [nil] ifFalse: [aString]].	self mainPackage: aPackage object: definition</body><body package="Store-Difference Management" selector="mainProtocol">mainProtocol	^''</body><body package="Store-Difference Management" selector="otherDefinition">otherDefinition	^otherObject ifNil: [self notDefinedInThisPackage]</body><body package="Store-Difference Management" selector="otherPackage:definition:">otherPackage: aPackage definition: aString	| definition |	definition := aString ifNotNil: [aString isEmpty ifTrue: [nil] ifFalse: [aString]].	self otherPackage: aPackage object: definition</body><body package="Store-Difference Management" selector="otherProtocol">otherProtocol	^''</body><body package="Store-Difference Management" selector="resolutionClass">resolutionClass	^ClassChangeResolver</body><body package="Store-Difference Management" selector="selectorListIcon">selectorListIcon	^GeneralIcons gear</body><body package="Store-Difference Management" selector="selectorListName">selectorListName	^(#BracketClassDefinition &lt;&lt; #store &gt;&gt; '[Class Definition]') asString</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>loading</category><body package="Store-Difference Management" selector="loadMainDefinitionFrom:">loadMainDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: mainPackage storeModel		while: [aStoreClassOrNamepace classDefinition loadSource].</body><body package="Store-Difference Management" selector="loadOtherDefinitionFrom:">loadOtherDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: [aStoreClassOrNamepace classDefinition loadSource].</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="isMeta">isMeta	^true</body><body package="Store-Difference Management" selector="isMethod">isMethod	^true</body><body package="Store-Difference Management" selector="isNotMeta">isNotMeta	^self isMeta</body><body package="Store-Difference Management" selector="isStandin">isStandin	^true</body></methods><methods><class-id>Store.PseudoClassDefinitionDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	| targetObject |	targetObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream saveClassSource: targetObject</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	| targetObject |	targetObject := aStoreClassOrNamespace isImageObject		ifTrue: [aStoreClassOrNamespace]		ifFalse: [aStoreClassOrNamespace classDefinition].	aStream saveClassSource: targetObject</body></methods><methods><class-id>Store.PseudoNamespaceDefinitionDifference</class-id> <category>loading</category><body package="Store-Difference Management" selector="loadMainDefinitionFrom:">loadMainDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: mainPackage storeModel		while: [aStoreClassOrNamepace definition loadSource].</body><body package="Store-Difference Management" selector="loadOtherDefinitionFrom:">loadOtherDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: [aStoreClassOrNamepace definition loadSource].</body></methods><methods><class-id>Store.PseudoNamespaceDefinitionDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="resolutionClass">resolutionClass	^NamespaceChangeResolver</body><body package="Store-Difference Management" selector="selectorListName">selectorListName	^(#BracketNameSpaceDefinition &lt;&lt; #store &gt;&gt; '[NameSpace Definition]') asString</body></methods><methods><class-id>Store.PseudoNamespaceDefinitionDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	aStoreClassOrNamespace fileOutSourceOn: aStream</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	aStoreClassOrNamespace fileOutSourceOn: aStream</body></methods><methods><class-id>Store.ElementView</class-id> <category>private</category><body package="Store-UI-Graphs" selector="doLayout">doLayout	| pt  |	pt := 0.	self hasIn == 0		ifTrue:			[pt := pt + 9 + 2]		ifFalse: 			[| inBut inLf inWid |			inBut := self inButton.			inWid := inBut preferredBounds width + 2.			inLf := LayoutFrame new.			inLf bottomFraction: 1; topOffset: 1; leftOffset: pt; rightOffset: pt + inWid.			self add: inBut in: inLf.			pt := pt + inWid].	label := self elLabelFor: element at: pt @ 0.	label := self findTopmostWrapperFor: label.	pt := label bounds corner x.	firstPovIconX := pt + 2.	self hasOut == 0		ifFalse: 			[| outBut outLf outWid |			outBut := self outButton.			outWid := outBut preferredBounds width.			outLf := LayoutFrame new.			outLf bottomFraction: 1; topOffset: 1; leftOffset: [self outButtonXPosition]; rightOffset: [self outButtonXPosition + outWid].			self add: outBut in: outLf]</body></methods><methods><class-id>Store.ElementView</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="inButton">inButton	"creates the button for opening and closing the incoming 	relationships. cyev is self"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasIn == true]		putBlock: self inButtonPutBlock		updateBlock: [:m :a :p | false].	v := Lens.LDMArrowView model: pa fullImage: FullInArrow emptyImage: EmptyInArrow.	v controller beToggle.	v label: ''.	^v</body><body package="Store-UI-Graphs" selector="outButton">outButton	"same as inButton but for outgoing relationships"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasOut == true]		putBlock: self outButtonPutBlock		updateBlock: [:m :a :p | false].	v := Lens.LDMArrowView model: pa fullImage: FullOutArrow emptyImage: EmptyOutArrow.	v controller beToggle.	v label: ''.	^v</body></methods><methods><class-id>Store.ElementView class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"	EmptyInArrow := self emptyInImage.	EmptyOutArrow := self emptyOutImage.	FullInArrow := self fullInImage.	FullOutArrow := self fullOutImage.</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>menu</category><body package="Store-UI" selector="atLeastOneVersionSelectedAndInImage">atLeastOneVersionSelectedAndInImage	| selections |	(self itemsInList selections size &gt; 0 and: [self itemsInList selections allSatisfy: [:each | each isImageModel not]])		ifFalse: [^false].	^self itemsInList selections size &gt; 0 and: 		[selections := self itemsInList selections.		selections allSatisfy:			[:each |			(each isBundle 				ifTrue: [Registry bundleNamed: each name]				ifFalse: [Registry packageNamed: each name]) notNil]]</body><body package="Store-UI" selector="oneItemAndInImage">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		(selection isBundle 			ifTrue: [Registry bundleNamed: selection name]			ifFalse: [Registry packageNamed: selection name]) notNil]</body><body package="Store-UI" selector="onlyOneItemSelected">onlyOneItemSelected	^self itemsInList selections size = 1 and: [self itemsInList selections first isImageModel not]</body><body package="Store-UI" selector="onlyTwoItemsSelected">onlyTwoItemsSelected	^self itemsInList selections size = 2</body><body package="Store-UI" selector="publishOrderedSelectionPair">publishOrderedSelectionPair	| last selections firstTimestamp lastTimestamp first |	selections := self itemsInList selections asArray.	first := selections first.	last := selections last.	firstTimestamp := first isImageModel				ifTrue: [first storeTracePackage ifNotNil: #timestamp]				ifFalse: [first timestamp].	lastTimestamp := last isImageModel				ifTrue: [last storeTracePackage ifNotNil: #timestamp]				ifFalse: [last timestamp].	(firstTimestamp isNil		or: [lastTimestamp notNil and: [lastTimestamp &lt; firstTimestamp]])			ifTrue: [selections := selections reverse].	^selections</body><body package="Store-UI" selector="selectionIsBundle">selectionIsBundle	^self onlyOneItemSelected and: [self itemsInList selections first isBundle]</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>actions</category><body package="Store-UI" selector="browseSelectedVersion">browseSelectedVersion	| package |	package := self itemsInList selections first.	package := package isImageModel		ifTrue: [			self itemsInList list detect: [:each|				each isImageModel					ifTrue: [false]					ifFalse: [package dbTrace = each primaryKey]] ifNone: [nil]]		ifFalse: [package].	package isNil 		ifTrue: [Dialog warn: 'Loaded version is not in the currently connected Store repository'.			^self].		[(Gathering for: package) started.	package prefetchAllFromDatabase.	(Store.Glorp.StoreForGlorpBrowserEnvironment on: package) openEditor.	(Gathering for: package) finished]			withStoreFeedbackOn: self mainWindow</body><body package="Store-UI" selector="compareSelectionWith">compareSelectionWith	| pundle target older newer |	pundle := self itemsInList selections first.	target := pundle class selectStoreVersionOf: pundle name in: pundle session.	target		ifNotNil: 			[older := pundle timestamp &lt; target timestamp						ifTrue: [pundle]						ifFalse: [target].			newer := pundle timestamp &lt; target timestamp						ifTrue: [target]						ifFalse: [pundle].			ComparePackages compareFrom: older to: newer]</body><body package="Store-UI" selector="compareVersions">compareVersions	| selections |	selections := self publishOrderedSelectionPair.	ComparePackages compareFrom: selections first to: selections last</body><body package="Store-UI" selector="containedItems">containedItems	[DefinitionForListTool forBundleContents: self itemsInList selections first] withStoreFeedbackOn: tool mainWindow.</body><body package="Store-UI" selector="enclosingBundles">enclosingBundles	| package enclosingBundles |	package := self itemsInList selections first.	(enclosingBundles := package enclosingComponents) isEmpty		ifTrue: [^Dialog warn: #NoEnclosingBundles &lt;&lt; #store &gt;&gt; 'No enclosing bundles.'].	DefinitionForListTool forPackages: enclosingBundles</body><body package="Store-UI" selector="fileOutSelectedVersion">fileOutSelectedVersion	| package fileName fileManager |	package := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: package name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			package fileOutOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: package) finished].</body><body package="Store-UI" selector="graphSelectedVersion">graphSelectedVersion	| package |	package := self itemsInList selections first.	package isImageModel ifFalse: [package := StorePackage cachedItemFor: package].	VersionGraph browseVersionsOfPundle: package.</body><body package="Store-UI" selector="loadSelectedVersion">loadSelectedVersion	| package |	package := self itemsInList selections first.	package canLoadNewOrReplaceExistingVersion ifTrue:		[[package loadSource] withStoreFeedbackOn: self mainWindow]</body><body package="Store-UI" selector="mergeIntoImage">mergeIntoImage	| packages targets |	packages := self itemsInList selections.	targets := packages collect:		[:each |		each isBundle			ifTrue: [StoreBundle pundleWithName: each name version: each version in: each session]			ifFalse: [StorePackage pundleWithName: each name version: each version in: each session]].	Store.Glorp.MergeTool openOnPundles: targets</body><body package="Store-UI" selector="reconcile">reconcile	| dbVersion |	dbVersion := self itemsInList selections first.	[dbVersion getImagePundle reconcileWithDbVersion: dbVersion]		withStoreFeedbackOn: self mainWindow</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText emphasis: #bold.				updateText nextPutAll: each name.				updateText space.				updateText nextPutAll: each versionString.				updateText cr.				updateText emphasis: #none.				updateText cr.				each blessings do:					[:eachBlessing | eachBlessing blessingLevel = -1 ifFalse: [eachBlessing printWideOn: updateText]].				updateText cr.				updateText emphasis: (Array with: #color-&gt; ColorValue navy).				updateText nextPutAll: each comment.				updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body><body package="Store-UI" selector="setBlessingLevel">setBlessingLevel	| package |	package := self itemsInList selections first.	BlessingDialog setBlessingFor: package. 	(self builder componentAt: #SelectionList) widget invalidate.	self selectionsUpdated</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>interface opening</category><body package="Store-UI" selector="compositeViewUsing:nameSize:versionSize:timeSize:in:">compositeViewUsing: aPackage nameSize: longestName versionSize: longestVersion timeSize: longestTimestamp in: aSequenceView		| iconPart currentStart nameLabel versionLabel timestampLabel blessingLabel mainThing |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aPackage toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aPackage name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 12.	versionLabel := Label with: aPackage versionString asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestVersion + 12.	timestampLabel := Label with: aPackage timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestTimestamp + 8.	blessingLabel := Label with: aPackage blessingLevelString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: versionLabel;		add: blessingLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder.</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestVersion longestTimestamp |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestVersion := longestTimestamp := 0.	items		do:			[:each | 			longestName := (Label with: each name asText allBold attributes: widget textStyle) width max: longestName.			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestTimestamp := (Label with: each timeStampString asText attributes: widget textStyle) width max: longestTimestamp].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				timeSize: longestTimestamp				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				timeSize: longestTimestamp				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.Glorp.PackageListPane</class-id> <category>accessing</category><body package="Store-UI" selector="fillInFor:">fillInFor: aPackage	(Gathering for: aPackage name) started.	self fillListWith: (aPackage storeForGlorpPundleClass		allVersionsWithName: aPackage name		in: aPackage session) asList.	(Gathering for: aPackage name) finished.</body><body package="Store-UI" selector="listTitle">listTitle		self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title</body><body package="Store-UI" selector="title">title		| target |	^title ifNil: 		[target := self itemsInList list first.		#VersionsOf2BundleOrPackage1s &lt;&lt; #store &gt;&gt; 'Versions of &lt;2?Bundle:Package&gt; &lt;1s&gt;' expandMacrosWith: target name with: target isBundle]</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>private</category><body package="Store-UI-Graphs" selector="listChange">listChange	self setButtons.	self updateText.	^true.			"multi-lists  must answer true/false"</body><body package="Store-UI-Graphs" selector="perspective">perspective	^#tt_ownsAdjacent</body><body package="Store-UI-Graphs" selector="privilegeManager">privilegeManager	^StoreAccessPrivilege</body><body package="Store-UI-Graphs" selector="setButtons">setButtons	"Set the enablement of the buttons. There must be a selection in both lists."	"Enable only when both a user and package are selected. Sets if the user does not	already have rights for any package selected. Revoke only if has rights for all packages selected."		| set revoke owner |	owner := userGroupList selection.	(owner isNil or: [packageList selections size &lt; 1])		ifTrue: [set := revoke := false]		ifFalse:			[set := true.			revoke := true.			packageList selections do:			[:each | 			(self privilegeManager privilegeForUser: owner pundle: each) isNil				ifTrue:					[set := set &amp; true.					revoke := false]				ifFalse:					[revoke := revoke &amp; true.					set := false]]].	(builder componentAt: #assignOwner) widget isEnabled: set.	(builder componentAt: #grantRead) widget isEnabled: set.	(builder componentAt: #grantPublish) widget isEnabled: set.	(builder componentAt: #revokeRights) widget isEnabled: revoke</body><body package="Store-UI-Graphs" selector="setTextTo:">setTextTo: aString 	self privilegeText value: aString.</body><body package="Store-UI-Graphs" selector="updateGraph">updateGraph		| focus cache |	focus := Set new.	cache := Dictionary new.	packageList selection notNil ifTrue: 		[focus add: (PackageOwnerElement element: packageList selection cache: cache)].	userGroupList selection notNil ifTrue: 		[focus add: (PackageOwnerElement element: userGroupList selection cache: cache)].	self graphView focus: focus</body><body package="Store-UI-Graphs" selector="updateGraphPLAY">updateGraphPLAY		| focus cache |	focus := Set new.	cache := Dictionary new.	packageList selection notNil ifTrue: 		[focus add: (PackageOwnerElement element: packageList selection cache: cache)].	userGroupList selection notNil ifTrue: 		[focus add: (StoreUserGroup userNamed: userGroupList selection)].	self graphView focus: focus</body><body package="Store-UI-Graphs" selector="updatePackageList">updatePackageList		| packages |	packages := Store.Registry allPackages.	StorePackage allNames do: 		[:name | 		(packages contains: [:each | each name = name]) ifFalse: [packages add: (StorePackage newNamed: name)]].	self packageList list: (packages asSortedCollection: [:a :b | a name &lt; b name]) asOrderedCollection</body><body package="Store-UI-Graphs" selector="updateText">updateText		| stream privileges |	stream := (String new: 100) writeStream.	privileges := OrderedCollection new.	userGroupList selection notNil ifTrue: 		[privileges addAll: (self privilegeManager allPrivilegesForUser: userGroupList selection)].	packageList selections size &gt; 0 		ifTrue: [packageList selections do: [:each | privileges addAll: (self privilegeManager allPrivilegesForPundle: each)]].	privileges asSet asSortedCollection do:		[:each | 		stream			nextPutAll: each fullDescription;			cr].	self setTextTo: stream contents</body><body package="Store-UI-Graphs" selector="updateUserGroupList">updateUserGroupList	| users |	users := StoreUserGroup allDistinctUserGroups asSet.	users addAll: StoreAccessPrivilege allDistinctUserGroups.	userGroupList list: users asSortedCollection asOrderedCollection.</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="assignOwner">assignOwner	self grant: #owner</body><body package="Store-UI-Graphs" selector="grant:">grant: aSymbol		| owner |	owner := userGroupList selection.	packageList selections do: 		[:each | self privilegeManager grant: aSymbol to: owner for: each].	self updateText.	self setButtons</body><body package="Store-UI-Graphs" selector="grantPublish">grantPublish	self grant: #publish</body><body package="Store-UI-Graphs" selector="grantRead">grantRead	self grant: #read</body><body package="Store-UI-Graphs" selector="revokeRights">revokeRights		| owner |	owner := userGroupList selection.	packageList selections do: 		[:each | self privilegeManager revokeAllFor: owner for: each].	self updateText.	self setButtons</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>aspects</category><body package="Store-UI-Graphs" selector="packageList">packageList	^packageList isNil		ifTrue: [ packageList := MultiSelectionInList new ]		ifFalse: 	[ packageList ]</body><body package="Store-UI-Graphs" selector="privilegeText">privilegeText	^privilegeText isNil		ifTrue: [ privilegeText := String new asValue ]		ifFalse: 	[ privilegeText ]</body><body package="Store-UI-Graphs" selector="userGroupList">userGroupList	^userGroupList isNil		ifTrue: [ userGroupList := SelectionInList new ]		ifFalse: 	[ userGroupList ]</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postBuildWith:">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	(self widgetAt: #userGroupListID) displayStringSelector: #userName.</body><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	self updateUserGroupList.	self updatePackageList.	self setButtons.	self updateText.	self mainWindow label: #PackageUserGroupPrivliges &lt;&lt; #store &gt;&gt; 'Package - User / Group Privileges'</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs" selector="initializePerspectives">initializePerspectives	"self initializePerspectives"	^List new 		add: ( ( Array new: 9 )			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: 	#(#(#V1 #F1 'tt_owns' true true false true true) 						   #(#F1 #V2 'tt_owns' true true false true true) );			at: 4 put: #arrLabelHints:;			at: 5 put: #();			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_owns';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue purple;					at: 5 put: 1; yourself);  yourself);			at: 8 put: #name:;			at: 9 put: #tt_ownsAdjacent; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs" selector="initializeRelationships">initializeRelationships	"self initializeRelationships"	^List new 		add: #( #LDMFirstOrderRel #name: 'tt_owns'  #description: 'owns'  					#reverse: nil  #token: #tt_ownsRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_ownsR' #description: 'is owned' 					#reverse: nil #token: #tt_ownsRRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_read'  #description: 'reads'  					#reverse: nil  #token: #tt_readRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_readR' #description: 'is read' 					#reverse: nil #token: #tt_readRRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_publish'  #description: 'can publish'  					#reverse: nil  #token: #tt_publish ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_publishR' #description: 'can be published' 					#reverse: nil #token: #tt_publishRRel ) decodeAsLiteralArray; 		yourself</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	self updateUserGroupList.	self updateBundleList.	self setButtons.	self updateText.	self mainWindow label: #BundleUserGroupPrivliges &lt;&lt; #store &gt;&gt; 'Bundle - User / Group Privileges'.	(self widgetAt: #pundleLabel) labelString: (#BundleC &lt;&lt; #store &gt;&gt; 'Bundle:') asString</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>private</category><body package="Store-UI-Graphs" selector="updateBundleList">updateBundleList		| bundlesOfAllKinds |	bundlesOfAllKinds := Store.Registry allBundles.	StoreBundle allNames do: 		[:each | 		(bundlesOfAllKinds contains: [:eachBundle | eachBundle name = each]) ifFalse: 			[bundlesOfAllKinds add: (StoreBundle newNamed: each)]].	self packageList list: (bundlesOfAllKinds asSortedCollection: [:a :b | a name &lt; b name]) asOrderedCollection</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="grant:">grant: aSymbol		| owner workingBundle |	owner := userGroupList selection.	packageList selections do:		[:eachBundle | 		workingBundle := StoreBundle newestVersionWithName: eachBundle name.		workingBundle withAllItems asSet do: [:eachPundle | self privilegeManager grant: aSymbol to: owner for: eachPundle]].	self updateText.	self setButtons</body><body package="Store-UI-Graphs" selector="revokeRights">revokeRights		| owner workingBundle |	owner := userGroupList selection.	packageList selections do: 		[:each | 		workingBundle := StoreBundle newestVersionWithName: each name.		workingBundle withAllItems asSet do: [:eachItem | self privilegeManager revokeAllFor: owner for: eachItem]].	self updateText.	self setButtons</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>actions</category><body package="Store-UI" selector="atLeastOnePundleVersionSelected">atLeastOnePundleVersionSelected	^self listOfThings selections notEmpty</body><body package="Store-UI" selector="copySelection">copySelection	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller copySelection</body><body package="Store-UI" selector="find">find	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller find</body><body package="Store-UI" selector="findNext">findNext	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller findNext</body><body package="Store-UI" selector="selectEntireText">selectEntireText	(builder componentAt: #DefinitionText) widget controller activate.	(builder componentAt: #DefinitionText) widget controller selectEntireText</body><body package="Store-UI" selector="updateStatusPaneWith:">updateStatusPaneWith: aString	self status value: aString</body><body package="Store-UI" selector="updateTextPaneWith:">updateTextPaneWith: aString	self definition value: aString</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>aspects</category><body package="Store-UI" selector="definition">definition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^definition isNil		ifTrue:			[definition := String new asValue]		ifFalse:			[definition]</body><body package="Store-UI" selector="mainMenu">mainMenu	"The listPart must have a mainMenu which adds its action menu"	^[| menu item |	menu := self class mainMenu.	item := menu atNameKey: #Edit.	item submenu: self class textMenu.	item := MenuItem labeled: #Version &lt;&lt; #store &gt;&gt; '&amp;Version'.	item submenu: [listPart listMenu value].	menu addItem: item atPosition: 9.015.	menu]</body><body package="Store-UI" selector="status">status	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^status isNil		ifTrue:			[status := Text new asValue]		ifFalse:			[status]</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>accessing</category><body package="Store-UI" selector="listOfThings">listOfThings	^listPart</body><body package="Store-UI" selector="listPart:">listPart: aListPart	listPart := aListPart</body><body package="Store-UI" selector="listSpec">listSpec	^listPart class windowSpec</body><body package="Store-UI" selector="listTitle">listTitle	^listPart listTitle</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>binding</category><body package="Store-UI" selector="specificationFor:">specificationFor: aKey	^self perform: aKey</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>error handling</category><body package="Store-UI" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	"We host the listPane's menu, so enablement and actions may need to be sent to it.	This makes this tool generic in that it can host panes that have different enablement and actions"	^(listPart respondsTo: aMessage selector)		ifTrue: [listPart perform: aMessage selector withArguments: aMessage arguments]		ifFalse: [super doesNotUnderstand: aMessage]</body><body package="Store-UI" selector="glorpSession">glorpSession	"Assuming that we're being used to view a list of definitions from the database, return the Glorp session used for that. Since this involves diving down into a bunch of things that might not even be there, especially if that assumption is wrong, guard against errors comprehensively."	| list |	list := listPart itemsInList list.	list isEmpty ifTrue: [^nil].	^[list any package session] on: Error do: [:ex | ex return: nil].</body><body package="Store-UI" selector="handleGlorpError:">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self glorpSession ifNil: [^self].	"We can have multiple store sessions with the same underlying connection. Make sure that we close our browsers if there's an error on any of them."	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn:( #DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printString)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>interface opening</category><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	Glorp.GlorpError.Announcements when: Store.ObsoleteBrowserContent send: #handleGlorpError: to: self</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	listPart postOpenWith: aBuilder</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>interface closing</category><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow 	"The ApplicationWindow aWindow is in the process of closing. 	You have been notified."	Glorp.GlorpError.Announcements unsubscribe: self.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>private</category><body package="Store-UI" selector="terminateBrowser">terminateBrowser	self release.	self builder ifNotNil: [self closeAndUnschedule]</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>opening</category><body package="Store-UI" selector="browseRemovedMethodsIn:">browseRemovedMethodsIn: aClass	| instance listPart | 	instance := self new.	listPart := MethodListPane new.	listPart tool: instance.	listPart title: (#VersionsOfRemovedMethodsIn1s &lt;&lt; #store &gt;&gt; 'Versions of Removed Methods In &lt;1s&gt;' expandMacrosWith: aClass name).	(listPart setUpForRemovedMethodsIn: aClass) ifNil: [^nil].	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forBundleContents:">forBundleContents: aStoreBundle	| instance listPart | 	instance := self new.	listPart := BundleTreePane new.	listPart tool: instance.	listPart fillInFor: aStoreBundle.	listPart title: (#ContentsOfBundle1s &lt;&lt; #store &gt;&gt; 'Contents of Bundle &lt;1s&gt;' expandMacrosWith: aStoreBundle displayString).	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forClasses:">forClasses: aCollection	| instance listPart | 	instance := self new.	listPart := ClassListPane new.	listPart tool: instance.	listPart fillListWith: aCollection.	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forMethodChangesInClass:">forMethodChangesInClass: aCollection	| instance listPart | 	instance := self new.	listPart := MethodListPane new.	listPart tool: instance.	listPart fillListWith: aCollection.	listPart title: (#MethodVersionsWithChangesIn1s &lt;&lt; #store &gt;&gt; 'Method versions with changes in &lt;1s&gt;' expandMacrosWith: aCollection first longNameFromSmalltalk).	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forMethods:">forMethods: aCollection	| instance listPart | 	instance := self new.	listPart := MethodListPane new.	listPart tool: instance.	listPart fillListWith: aCollection.	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forNameSpaces:">forNameSpaces: aCollection	| instance listPart | 	instance := self new.	listPart := NameSpaceListPane new.	listPart tool: instance.	listPart fillListWith: aCollection.	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forPackages:">forPackages: aCollection	| instance listPart | 	instance := self new.	listPart := PackageListPane new.	listPart tool: instance.	listPart fillListWith: aCollection.	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forPackages:containingString:">forPackages: aCollection containingString: aString	| instance listPart | 	instance := self new.	listPart := PackageListPane new.	listPart tool: instance.	listPart fillListWith: aCollection.	listPart title: (listPart title, (#Defining1s &lt;&lt; #store &gt;&gt; ' defining: &lt;1s&gt;' expandMacrosWith: aString)).	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forSharedVariables:">forSharedVariables: aCollection	| instance listPart | 	instance := self new.	listPart := SharedVariableListPane new.	listPart tool: instance.	listPart fillListWith: aCollection.	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forVersionsOfClass:">forVersionsOfClass: aStoreClass	| instance listPart | 	instance := self new.	listPart := ClassListPane new.	listPart tool: instance.	listPart fillInFor: aStoreClass.	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forVersionsOfClassOrNameSpace:">forVersionsOfClassOrNameSpace: aStoreClassOrNameSpace	aStoreClassOrNameSpace isForNameSpace		ifTrue: [self forVersionsOfNameSpace: aStoreClassOrNameSpace]		ifFalse: [self forVersionsOfClass: aStoreClassOrNameSpace]</body><body package="Store-UI" selector="forVersionsOfMethod:">forVersionsOfMethod: aStoreMethod	| instance listPart |	aStoreMethod		ifNil: [^Dialog warn: #NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	instance := self new.	listPart := MethodVersionsListPane new.	listPart tool: instance.	listPart fillInFor: aStoreMethod.	instance listPart: listPart.	instance open.	listPart itemsInList selections: (listPart itemsInList list				select: [:each | each primaryKey = aStoreMethod primaryKey])</body><body package="Store-UI" selector="forVersionsOfNameSpace:">forVersionsOfNameSpace: aStoreNameSpace	| instance listPart | 	instance := self new.	listPart := NameSpaceListPane new.	listPart tool: instance.	listPart fillInFor: aStoreNameSpace.	instance listPart: listPart.	instance open.</body><body package="Store-UI" selector="forVersionsOfPackage:">forVersionsOfPackage: aPackage	| instance listPart |	instance := self new.	listPart := PackageListPane new.	listPart tool: instance.	listPart fillInFor: aPackage.	instance listPart: listPart.	instance open.	listPart itemsInList selections: (Array with: aPackage)</body><body package="Store-UI" selector="forVersionsOfShared:">forVersionsOfShared: aStoreSharedVariable	| instance listPart | 	instance := self new.	listPart := SharedVariableListPane new.	listPart tool: instance.	listPart fillInFor: aStoreSharedVariable.	instance listPart: listPart.	instance open.</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>private</category><body package="Store-UI" selector="cleanUpObsoleteInstances">cleanUpObsoleteInstances	"Once a repository connection is closed, any open instances are not revivable, even if the repository is connected again."	self allInstances do: [:ea | ea terminateBrowser]</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>interface opening</category><body package="Store-UI" selector="listBlock:windowTitleBlock:">listBlock: aBlock windowTitleBlock: aTitleBlock	listPart := PundleVersionPane new.	listPart tool: self.	titleBlock := aTitleBlock.	listPart title: (aTitleBlock value: self class connectionName).	listBlock := aBlock.	self setupSearcher.</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #selectionTool)		client: searchModule		spec: searchModule preferredWindowSpec		builder: aBuilder newSubBuilder</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder		super postOpenWith: aBuilder.	self refreshList.	DbRegistry when: StoreDisconnect send: #storeDisconnect to: self.	DbRegistry when: StoreConnect send: #storeConnect to: self</body><body package="Store-UI" selector="pundlesMatching:">pundlesMatching: aString	| pattern |	pattern := aString trimBlanks, '*'.	^self cachedPundles select: [:some | pattern match: some name]</body><body package="Store-UI" selector="setupSearcher">setupSearcher	searchModule := IncrementalSearchModule 		forSelectionWithSearch: [:pattern | self pundlesMatching: pattern].	searchModule		useEagerSelection: false;		pasteSelected: false;		showLabels: false;		useMultiSelection: true;		iconSelector: #toolListIcon;		menuHolder: [self class packagesMenu] performer: self.	searchModule selectionIndexHolder onChangeSend: #pundleSelectionChanged to: self</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>accessing</category><body package="Store-UI" selector="cachedPundles">cachedPundles	"Pundles last read from the database are cached to avoid re-querying when	filtering. The cache is filled by reloadVersions."	^cachedPundles isNil		ifTrue: [Array new]		ifFalse: [cachedPundles]</body><body package="Store-UI" selector="listBlock">listBlock	^listBlock</body><body package="Store-UI" selector="searchModule">searchModule	^searchModule</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>updating</category><body package="Store-UI" selector="pundleSelectionChanged">pundleSelectionChanged	| selections versions columnWidths |	self resetImageVersions.	(selections := searchModule selections) isEmpty ifTrue: 		[listPart itemsInList refreshList: #().		^self].	listPart fillListWith: #().	[versions := self retrievePundleVersionsFor: selections.	columnWidths := listPart calculateColumnWidthsFor: versions basedOn: selections.	listPart setUpListViewWith: columnWidths.	listPart fillListWith: versions]			withStoreFeedbackOn: self mainWindow.</body><body package="Store-UI" selector="refreshList">refreshList		| gatheringString |	[gatheringString := (#AllBundlesAndPackages &lt;&lt; #store &gt;&gt; 'All Bundles And Packages') asString.	(Gathering for: gatheringString) started.	searchModule list: (cachedPundles := listBlock value).	(Gathering for: gatheringString) finished] withStoreFeedbackOn: self mainWindow.	(((self builder aspectAt: #searchModule) builder aspectAt: #entryModule) builder componentAt: #entryField) takeKeyboardFocus.</body><body package="Store-UI" selector="resetImageVersions">resetImageVersions	listPart resetImageVersions</body><body package="Store-UI" selector="storeConnect">storeConnect	listPart title: (titleBlock value: self class connectionName).	self mainWindow label: self listTitle.	self refreshList.</body><body package="Store-UI" selector="storeDisconnect">storeDisconnect	listPart title: (#Disconnected &lt;&lt; #store &gt;&gt; 'Disconnected') asString.	self mainWindow label: self listTitle.	searchModule selections: OrderedCollection new.	self updateVersionsList.	cachedPundles := #().	searchModule list: cachedPundles.</body><body package="Store-UI" selector="updateVersionsList">updateVersionsList	self pundleSelectionChanged</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>interface closing</category><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	DbRegistry unsubscribe: self.	super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool</class-id> <category>aspects</category><body package="Store-UI" selector="mainMenu">mainMenu	"The listPart must have a mainMenu which adds its action menu"	^[| menu item |	menu := self class mainMenu.	item := menu atNameKey: #Comment.	item submenu: self class textMenu.	item := menu atNameKey: #Packages.	item submenu: self class packagesMenu.	item := MenuItem labeled: #_Versions &lt;&lt; #store &gt;&gt; '&amp;Versions'.	item submenu: [listPart listMenu value].	menu addItem: item atPosition: 10.015.	menu]</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>opening</category><body package="Store-UI" selector="openOnAllLoadedPundles">openOnAllLoadedPundles	| listBlock |	listBlock :=		[Registry allPundlesSorted asList].	self		openOnBlock: listBlock		windowTitleBlock: [:ignore | (#LoadedItems &lt;&lt; #store &gt;&gt; 'Loaded Items') asString]</body><body package="Store-UI" selector="openOnAllPublishedPundles">openOnAllPublishedPundles	| listBlock |	listBlock :=		[ | list connection |		connection := StoreLoginFactory currentStoreSession.		list := List new.		list addAll: ((StoreBundle allNamesSortedIn: connection) asOrderedCollection collect: [:each | StoreBundle newNamed: each]).		list addAll: ((StorePackage allNamesSortedIn: connection) asOrderedCollection collect: [:each | StorePackage newNamed: each]).		list].	self		openOnBlock: listBlock		windowTitleBlock: [:connectionName | (#PublishedItems1s &lt;&lt; #store &gt;&gt; 'Published Items &lt;1?:on&gt; &lt;2s&gt;' expandMacrosWith: connectionName isEmpty with: connectionName)]</body><body package="Store-UI" selector="openOnBlock:windowTitle:">openOnBlock: aBlock windowTitle: aString	self openOn: (self new listBlock: aBlock windowTitleBlock: aString)</body><body package="Store-UI" selector="openOnBlock:windowTitleBlock:">openOnBlock: aBlock windowTitleBlock: titleBlock	self openOn: (self new listBlock: aBlock windowTitleBlock: titleBlock)</body><body package="Store-UI" selector="openRecentPublishedItems">openRecentPublishedItems	| listBlock |	(Gathering for: (#MostRecentPublishedItems &lt;&lt; #store &gt;&gt; 'Most Recent Published Items') asString) started.	listBlock :=		[| session bundles packages list |		session := Store.Glorp.StoreLoginFactory currentStoreSession.		bundles := ((Registry allBundlesWithNewerInDBIn: session) asSortedCollection: [:a :b| a name &lt; b name]).		packages := ((Registry allPackagesWithNewerInDBIn: session) asSortedCollection: [:a :b| a name &lt; b name]).		list := List new.		list addAll: bundles;			addAll: packages;			yourself].	(Gathering for: (#MostRecentPublishedItems &lt;&lt; #store &gt;&gt; 'Most Recent Published Items') asString) finished.	self		openOnBlock: listBlock		windowTitleBlock: [:connectionName | ((#MoreRecentlyPublishedItems1s &lt;&lt; #store &gt;&gt; 'More Recently Published Items &lt;1?:on&gt; &lt;2s&gt;') 			expandMacrosWith: connectionName isEmpty 			with: connectionName)]</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>private</category><body package="Store-UI" selector="connectionName">connectionName	^DbRegistry connectedProfile 		ifNil: ['']		ifNotNil: [:profile | profile name ifNil: [DbRegistry databaseIdentifier]]</body></methods><methods><class-id>Store.StoreProgressView</class-id> <category>initialize-release</category><body package="Store-UI" selector="addActionLabel">addActionLabel	self add: (Label with: '')</body><body package="Store-UI" selector="addComponentLabel">addComponentLabel	self add: (Label with: '')</body><body package="Store-UI" selector="addHealthView">addHealthView	| view |	view := ProcessHealthView new.	view isActive: [self isActive].	self add: view</body><body package="Store-UI" selector="initialize">initialize	super initialize.	activityStack := OrderedCollection new.	self		addHealthView;		addActionLabel;		addComponentLabel</body><body package="Store-UI" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	"Exploits knowledge that the children when populated are 1) the health process spinner, 2) the code component name, 3) the action."	self layoutAlgorithm: 			[:rect :children |			children size = 3				ifFalse: [#()]				ifTrue: 					[| centerExtent rightExtent leftBox centerBox rightBox |					centerExtent := (children at: 2) preferredExtent.					rightExtent := (children at: 3) preferredExtent.					leftBox := rect topLeft extent: rect height asPoint.					centerBox := (leftBox rightCenter upBy: centerExtent y half)								extent: centerExtent.					rightBox := rect rightCenter - ((rightExtent x + 5) @ rightExtent y half)								extent: rightExtent.					rightBox left - centerBox right &gt;= 5						ifFalse: 							[| mid |							mid := rightBox left midpoint: centerBox right.							rightBox left: mid + 2.							centerBox right: mid - 3].					Array with: leftBox with: centerBox with: rightBox]]</body><body package="Store-UI" selector="release">release	notifications unsubscribe: self.	super release</body></methods><methods><class-id>Store.StoreProgressView</class-id> <category>private</category><body package="Store-UI" selector="actionLabelPart">actionLabelPart	^self children at: 3</body><body package="Store-UI" selector="componentLabelPart">componentLabelPart	^self children at: 2</body><body package="Store-UI" selector="currentActionText">currentActionText	^(self currentActivity ifNil: [''] ifNotNil: #actionText) asText allBold		emphasizeAllWith: #color -&gt; (ColorValue						red: 1 / 3						green: 1 / 3						blue: 2 / 3)</body><body package="Store-UI" selector="currentActivity">currentActivity	^activityStack isEmpty ifTrue: [nil] ifFalse: [activityStack last]</body><body package="Store-UI" selector="currentComponentName">currentComponentName	^(self currentActivity ifNil: [''] ifNotNil: #componentName) asText		allBold</body><body package="Store-UI" selector="healthPart">healthPart	^self children at: 1</body><body package="Store-UI" selector="isActive">isActive	^activityStack isEmpty not</body><body package="Store-UI" selector="noteActivity:">noteActivity: anActivity	| index |	anActivity isFinished		ifTrue: 			[index := activityStack findFirst: [:each | each isComplement: anActivity].			index isZero ifFalse: [activityStack := activityStack first: index - 1]]		ifFalse: [activityStack add: anActivity].	self updateCurrentLabels.	self invalidateNow</body><body package="Store-UI" selector="updateCurrentLabels">updateCurrentLabels	self componentLabelPart graphic: (Label with: self currentComponentName).	self actionLabelPart graphic: (Label with: self currentActionText)</body></methods><methods><class-id>Store.StoreProgressView</class-id> <category>accessing</category><body package="Store-UI" selector="notifications">notifications	^notifications</body><body package="Store-UI" selector="notifications:">notifications: anAnnouncer	notifications unsubscribe: self.	notifications := anAnnouncer.	notifications when: StoreWorkActivity send: #noteActivity: to: self</body></methods><methods><class-id>Store.StoreProgressView class</class-id> <category>instance creation</category><body package="Store-UI" selector="example">example	"self example"	| window view |	window := ScheduledWindow new.	view := self new.	view notifications: StoreWorkActivity notifications.	window component: view.	window openWithExtent: 500 @ 25</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>private</category><body package="Store-Code Comparison" selector="graphic:explanation:">graphic: aGraphic explanation: aCharacterThing	| paragraph row textWidth rowHeight |	row := Panel new.	row add: aGraphic.	paragraph := ComposedText withText: aCharacterThing asText.	row add: paragraph.	row layoutAlgorithm: 			[:rect :parts |			textWidth := rect width - 15 - aGraphic preferredWidth.			textWidth &gt; 0 ifTrue: [paragraph compositionWidth: textWidth].			rowHeight := aGraphic preferredHeight max: paragraph preferredHeight.			Array				with: ((rect left + 5)						@ (rect top + rowHeight half - aGraphic preferredHeight half)							extent: aGraphic preferredExtent)				with: ((rect left + 10 + aGraphic preferredWidth)						@ (rect top + rowHeight half - paragraph preferredHeight half)							extent: paragraph extent)].	^row</body><body package="Store-Code Comparison" selector="keyboardGraphic:">keyboardGraphic: aString	^VisualStack with: ComparisonIcons keyboardKey		with: (Label with: aString asText allBold)</body><body package="Store-Code Comparison" selector="keyboardOne:two:clickOver:">keyboardOne: aString two: bString clickOver: aGraphic	| ws |	(bString isNil and: [aString notNil])		ifTrue: [^self keyboardOne: nil two: aString clickOver: aGraphic].	ws := Array new writeStream.	ws		nextPut: (aString					ifNil: [PixelSpace width: ComparisonIcons keyboardKey width]					ifNotNil: [self keyboardGraphic: aString]);		nextPut: (bString					ifNil: [PixelSpace width: ComparisonIcons keyboardKey width]					ifNotNil: [self keyboardGraphic: bString]);		nextPut: (aGraphic					ifNil: [PixelSpace width: ComparisonIcons mouseClick width]					ifNotNil: [VisualStack with: aGraphic with: ComparisonIcons mouseClick]).	^VisualRow withAll: ws contents</body><body package="Store-Code Comparison" selector="plainParagraph:">plainParagraph: aStringThing	"Do it just like one with a graphic, so things line up nicely."	^self graphic: (PixelSpace width: 16) explanation: aStringThing</body><body package="Store-Code Comparison" selector="populationSelectors">populationSelectors	^((Pragma allNamed: #paragraph in: self class) collect: #selector) sorted</body><body package="Store-Code Comparison" selector="sectionHeader:">sectionHeader: aCharacterThing	| paragraph |	paragraph := Panel new.	paragraph beRow: 0.	paragraph		add: (PixelSpace width: 5);		add: (aCharacterThing asText emphasizeAllWith: #(#bold #large)).	^paragraph</body><body package="Store-Code Comparison" selector="subsectionHeader:">subsectionHeader: aCharacterThing	| paragraph |	paragraph := Panel new.	paragraph beRow: 0.	paragraph		add: (PixelSpace width: 26);		add: (aCharacterThing asText emphasizeAllWith: #(#bold)).	^paragraph</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="initialize">initialize	super initialize.	self populate</body><body package="Store-Code Comparison" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	self beFullColumn</body><body package="Store-Code Comparison" selector="openInWindow">openInWindow	| window scrolled |	window := ScheduledWindow new.	scrolled := (BorderDecorator on: self)				useVerticalScrollBar;				noBorder.	window component: scrolled.	window		label: #ComparisonToolManual &gt;&gt; 'Comparison Tool Reference' &lt;&lt; #IDE.	window		openWithExtent: (Screen default bounds extent * (0.5 @ 1) - ( 0 @ 30)).	self relayout</body><body package="Store-Code Comparison" selector="populate">populate	self		addAll: (self populationSelectors collect: [:each | self perform: each])</body><body package="Store-Code Comparison" selector="scrollOffsetHolder:">scrollOffsetHolder: aScrollOffsetHolder	aScrollOffsetHolder grid: 1 @ 16</body></methods><methods><class-id>Tools.ComparisonUsersManual class</class-id> <category>instance creation</category><body package="Store-Code Comparison" selector="open">open	"self open"	self new openInWindow</body></methods><methods><class-id>Store.Glorp.StoreBundlePackageRelationship</class-id> <category>accessing</category><body package="Store-Database Model" selector="bundleID">bundleID		^bundleID</body><body package="Store-Database Model" selector="bundleID:">bundleID: anObject		bundleID := anObject</body><body package="Store-Database Model" selector="expressionID">expressionID		^expressionID</body><body package="Store-Database Model" selector="expressionID:">expressionID: anObject		expressionID := anObject</body><body package="Store-Database Model" selector="packageID">packageID		^packageID</body><body package="Store-Database Model" selector="packageID:">packageID: anObject		packageID := anObject</body><body package="Store-Database Model" selector="sequence">sequence		^sequence</body><body package="Store-Database Model" selector="sequence:">sequence: anObject		sequence := anObject</body></methods><methods><class-id>Store.MethodDocs</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="documentRef">documentRef	^documentRef</body><body package="Store-DB-Subdefs" selector="documentRef:">documentRef: anInteger	documentRef := anInteger</body><body package="Store-DB-Subdefs" selector="methodRef">methodRef	^methodRef</body><body package="Store-DB-Subdefs" selector="methodRef:">methodRef: anInteger	methodRef := anInteger</body><body package="Store-DB-Subdefs" selector="primaryKey">primaryKey	^OrderedCollection with: self  methodRef with: self documentRef</body><body package="Store-DB-Subdefs" selector="referenceField">referenceField	^self documentRef</body></methods><methods><class-id>Store.MethodDocs</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: methodRef printString;		nextPutAll: ' - ';		nextPutAll: documentRef printString;		nextPut: $).</body></methods><methods><class-id>Store.MethodDocs class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="createDocumentSession">createDocumentSession	| session |	session :=  self broker getNewSession.	session bindOutput: Blob privateNewPrimed; 			bindInput: self newPrimed; 			prepare: 				( self newSQL					selectAll;					where;					column: #primaryKey equalTo: ':primaryKey').	^session</body><body package="Store-DB-Subdefs" selector="documentSession">documentSession</body><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'methodRef' put: #PrimaryKey.	aDict at: 'documentRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn	self error: #ThisClassDoesNotCrDirectlyToPackages &lt;&lt; #store &gt;&gt; 'This class does not cross-reference directly to packages'</body><body package="Store-DB-Subdefs" selector="resetSession">resetSession</body><body package="Store-DB-Subdefs" selector="sourcesSession">sourcesSession	"MethodsWithSourcesSession := nil"</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>actions</category><body package="Store-UI" selector="compareWithImage">compareWithImage	| selection imageModel |	selection := self itemsInList selections first.	imageModel := selection isBundle 		ifTrue: [Registry bundleNamed: selection name]		ifFalse: [Registry packageNamed: selection name].	self openCompareFrom: selection  to: imageModel</body><body package="Store-UI" selector="compareWithParent">compareWithParent	| selection parent |	selection := self itemsInList selections first.	parent := selection previous.	parent ifNil: [parent := selection selectStoreVersionIn: selection session].	parent ifNotNil: 		[self openCompareFrom: selection  to: parent]</body><body package="Store-UI" selector="fileOutDifferences">fileOutDifferences	| selections dialog versions fileName session |	selections := self itemsInList selectionIndexes collect: [:each | self itemsInList list at: each].	dialog := FileoutDifferencesDialog from: selections first to: selections last.	dialog open.	dialog cancel value		ifTrue: [^self].	versions := Array with: dialog from with: dialog to.		fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: selections first name)).	fileName isEmpty ifTrue: [^nil].	session := versions first session ifNil: [versions last session ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession]].	Store.StoreProgressOverlay		subsume: builder window		while:			[(Store.FilingOut for: selections first) started.			versions first isPackage 				ifTrue: [self class fileOutDifferencesBetweenPackage: versions first and: versions last into: fileName using: session]				ifFalse: [self class fileOutDifferencesBetweenBundle: versions first and: versions last into: fileName using: session].			(Store.FilingOut for: versions first) finished]</body><body package="Store-UI" selector="loadSelectedVersion">loadSelectedVersion	super loadSelectedVersion.	self updateVersionsList</body><body package="Store-UI" selector="openVersionsList">openVersionsList	DefinitionForListTool forVersionsOfPackage: self itemsInList selections first</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated	| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0		ifTrue: 			[self itemsInList selections do:				[:each |				updateText					emphasize: #(#large #bold #underline)					during: 						[updateText nextPutAll: each name.						updateText space; space].				updateText					emphasize: #(#bold #underline)					during: 						[updateText 							nextPut: $(;							nextPutAll: each version;							nextPut: $)].				updateText cr.				each isImageModel 					ifFalse:						[each blessings do:							[:eachBlessing | eachBlessing blessingLevel = -1 ifFalse: [eachBlessing printTallOn: updateText]].						updateText cr]]]		ifFalse: 			[ | initial initialComment |			self itemsInList list isEmpty ifFalse:				[initial := self itemsInList list first.				initialComment := (initial comment isNil or: [initial comment isEmpty])					ifTrue: 						[updateText emphasis: #italic.						(#LastPublishedVersionOnentHasNoComment &lt;&lt; #store &gt;&gt; 'Last published version of this component has no comment.') asString]					ifFalse: 						[updateText emphasis: (Array with: #color-&gt; ColorValue navy).						initial comment].				updateText nextPutAll: initialComment]].	self updateTextPaneWith: updateText contents</body><body package="Store-UI" selector="updateVersionsList">updateVersionsList	tool updateVersionsList</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>interface opening</category><body package="Store-UI" selector="calculateColumnWidthsFor:basedOn:">calculateColumnWidthsFor: items basedOn: selections	| columnWidths blessings |	columnWidths := Dictionary new.	items notEmpty		ifTrue: [ | versions |			versions := items select: [:each| each isImageModel not].			selections size &gt; 1				ifTrue: [columnWidths at: #name						put: (self								findColumnMaxLengthFor: selections								emphasis: #bold								columnTextBlock: [:each | each name])].			columnWidths at: #version				put: (self						calculateAppropriateColumnLengthFor: versions						emphasis: #bold						columnTextBlock: [:each | each versionString]).			blessings := (versions collect: [:each | each blessingLevelString]) asSet.			columnWidths at: #blessing				put: (self						calculateAppropriateColumnLengthFor: blessings						emphasis: #bold						columnTextBlock: [:each | each]).			columnWidths at: #publishedFormatDescription				put: ((selections allSatisfy: [:each| each isBundle])						ifTrue: [0]						ifFalse: 							[self								calculateAppropriateColumnLengthFor: self publishedFormatDescriptions								emphasis: #bold								columnTextBlock: [:ea | ea asString]])].	^columnWidths</body><body package="Store-UI" selector="compositeViewUsing:columnWidths:in:">compositeViewUsing: aPackage columnWidths: columnWidthDictionary in: aSequenceView	| currentStart versionLabel rowView emphasis sourceString longestVersion longestBlessing longestName longestPublishedFormatDescription |	longestName := columnWidthDictionary at: #name ifAbsent: [0].	aPackage isImageModel		ifTrue: 			[(columnWidthDictionary at: #version) isZero ifTrue: [^self nothingInRepositoryFor: aPackage in: aSequenceView].			^longestName &gt; 0				ifTrue: [self displayWideObjectFor: aPackage in: aSequenceView]				ifFalse: [self displayObjectFor: aPackage in: aSequenceView]].	emphasis := self selectEmphasisFor: aPackage.	rowView := CompositePart new.	currentStart := 2.	longestName &gt; 0		ifTrue: [			rowView add: (Label with: aPackage name asText attributes: aSequenceView textStyle offset: currentStart @ 0).			currentStart := currentStart + longestName + 8].	longestVersion := columnWidthDictionary at: #version.	versionLabel := self labelClass				with: (aPackage versionString asText emphasizeAllWith: emphasis)				attributes: aSequenceView textStyle				offset: 0 @ 0.	rowView add: ((BoundedWrapper on: versionLabel) setOrigin: currentStart @ 0 extent: (longestVersion @ versionLabel preferredHeight)).	currentStart := currentStart + longestVersion + 12.	longestBlessing := columnWidthDictionary at: #blessing.	rowView add: (self labelClass				with: aPackage blessingLevelString asText				attributes: aSequenceView textStyle				offset: currentStart @ 0).	currentStart := currentStart + longestBlessing + 8.	longestPublishedFormatDescription := columnWidthDictionary at: #publishedFormatDescription.	longestPublishedFormatDescription &gt; 0		ifTrue: [			sourceString := self publishedFormatStringFor: aPackage.			rowView add: (self labelClass with: sourceString asText attributes: aSequenceView textStyle offset: currentStart @ 0).			currentStart := currentStart + longestPublishedFormatDescription + 8].	rowView add: (self labelClass				with: aPackage timeStampString asText				attributes: aSequenceView textStyle				offset: currentStart @ 0).	^rowView</body><body package="Store-UI" selector="displayObjectFor:in:">displayObjectFor: aPackage in: aSequenceView	| currentStart imageFromLabel versionLabel mainThing |	currentStart := 2.	imageFromLabel := Label with: (#ImageFromC &lt;&lt; #store &gt;&gt; 'Image From:') asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + imageFromLabel width + 2.	versionLabel := Label with: aPackage traceVersionString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: imageFromLabel;		add: versionLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="displayWideObjectFor:in:">displayWideObjectFor: aPackage in: aSequenceView	| currentStart imageFromLabel nameLabel versionLabel mainThing |	currentStart := 2.	imageFromLabel := Label with: (#ImageFromC &lt;&lt; #store &gt;&gt; 'Image From:') asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + imageFromLabel width + 2.	nameLabel := Label with: aPackage name trimBlanks asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + nameLabel width + 2.	versionLabel := Label with: aPackage traceVersionString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: imageFromLabel;		add: nameLabel;		add: versionLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="labelClass">labelClass	^Label</body><body package="Store-UI" selector="nothingInRepositoryFor:in:">nothingInRepositoryFor: aPundle in: aSequenceView		| currentStart imageFromLabel mainThing |	currentStart := 2.	imageFromLabel := Label		with: (#NoVersionsArePublishedInThisRep &lt;&lt; #store &gt;&gt; 'No versions of &lt;1s&gt; are published in this repository' expandMacrosWith: aPundle name) asText		attributes: aSequenceView textStyle		offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: imageFromLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="selectEmphasisFor:">selectEmphasisFor: aPackage	| imageModel |	^((imageModel := imageVersions at: aPackage name ifAbsent: [nil]) notNil		and: [imageModel dbTrace ~~ nil and: [aPackage primaryKey &gt; imageModel dbTrace]])			ifTrue: [#bold]			ifFalse: [nil]</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: columnWidthDictionary	"First we measure 2 things... 		the largest size of the version string, 		the largest size of a blessing name"		| widget |	widget := (self builder componentAt: #SelectionList) widget.	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				columnWidths: columnWidthDictionary				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				columnWidths: columnWidthDictionary				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>accessing</category><body package="Store-UI" selector="addImageVersion:">addImageVersion: aPundleModel	imageVersions at: aPundleModel name put: aPundleModel</body><body package="Store-UI" selector="fillInFor:">fillInFor: aCollection	| fullList |	fullList := self retrievePundleVersionsFor: aCollection.	self fillListWith: fullList</body><body package="Store-UI" selector="fillListWith:">fillListWith: aCollection	| list |	list := aCollection.	listFilterBlock ifNotNil: [list := aCollection select: listFilterBlock].	self itemsInList setList: list selecting: #()</body><body package="Store-UI" selector="listTitle">listTitle	^self title</body><body package="Store-UI" selector="publishedFormatDescriptionFor:">publishedFormatDescriptionFor: aSymbol	| string |	string := publishedFormatDescriptions at: aSymbol ifAbsent: [nil].	^string notNil		ifTrue: [string]		ifFalse: [''].</body><body package="Store-UI" selector="publishedFormatDescriptions">publishedFormatDescriptions	^publishedFormatDescriptions values</body><body package="Store-UI" selector="publishedFormatStringFor:">publishedFormatStringFor: aPundle	"Note: We explictly do a == nil to keep the proxy from coming in if possible"	^aPundle isBundle		ifTrue: ['']		ifFalse: 			[aPundle isPublishedBinary				ifTrue: [self publishedFormatDescriptionFor: #binary]				ifFalse: [self publishedFormatDescriptionFor: #source]]</body><body package="Store-UI" selector="retrievePundleVersionsFor:">retrievePundleVersionsFor: aCollection	| fullList |	fullList := List new.	aCollection do: 			[:each |			| pundleModel |			(Gathering for: each name) started.			pundleModel := each isPackage						ifTrue: [Registry packageNamed: each name]						ifFalse: [Registry bundleNamed: each name].			pundleModel				ifNotNil: 					[self addImageVersion: pundleModel.					fullList add: pundleModel].			fullList				addAll: (each storeForGlorpPundleClass allVersionsInitiallyNamed: each name						in: each session).			(Gathering for: each name) finished].	^fullList</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>menu</category><body package="Store-UI" selector="compareBundleStructures">compareBundleStructures	| selections |	selections := self publishOrderedSelectionPair.	(BundleStructureComparisonView new)		left: selections first right: selections last;		openScrolledWindow</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>private</category><body package="Store-UI" selector="openCompareFrom:to:">openCompareFrom: aPundle  to: anotherPundle	| session left right leftTimestamp rightTimestamp |	session := aPundle session ifNil: [anotherPundle session ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession]].	left := aPundle asStoreComparisonObjectIn: session.	right := anotherPundle asStoreComparisonObjectIn: session.	leftTimestamp := (left isKindOf: PundleModel)				ifTrue: [left storeTracePackage ifNotNil: #timestamp]				ifFalse: [left timestamp].	rightTimestamp := (right isKindOf: PundleModel)				ifTrue: [right storeTracePackage ifNotNil: #timestamp]				ifFalse: [right timestamp].	(leftTimestamp isNil		or: [rightTimestamp notNil and: [rightTimestamp &lt; leftTimestamp]])			ifTrue: 				[| swap |				swap := left.				left := right.				right := swap].	ComparePackages compareFrom: left to: right</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	self initializePublishedFormatDescriptions.	self resetImageVersions</body><body package="Store-UI" selector="initializePublishedFormatDescriptions">initializePublishedFormatDescriptions	publishedFormatDescriptions := Dictionary new		at: #binary put: (#binary &lt;&lt; #store &gt;&gt; 'binary') asString;		at: #source put: (#source &lt;&lt; #store &gt;&gt; 'source') asString;		yourself.</body><body package="Store-UI" selector="resetImageVersions">resetImageVersions	imageVersions := Dictionary new</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>testing</category><body package="Store-UI" selector="atLeastOnePundleSelected">atLeastOnePundleSelected	^tool searchModule selections notEmpty</body><body package="Store-UI" selector="atLeastOnePundleVersionSelected">atLeastOnePundleVersionSelected	^self itemsInList selections notEmpty</body><body package="Store-UI" selector="hasTwoBundlesSelected">hasTwoBundlesSelected	| selections |	selections := self itemsInList selections.	^selections size = 2 and: [selections any isBundle]</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>text length calculation</category><body package="Store-UI" selector="calculateAppropriateColumnLengthFor:emphasis:columnTextBlock:">calculateAppropriateColumnLengthFor: aCollection emphasis: emphasisSymbol columnTextBlock: aTextBlock	| string selectedFont textMeasurer count widthCollection sum mean sumSq stdDev width widget |	aCollection isEmpty ifTrue: [^0].	widget := (self builder componentAt: #SelectionList) widget.	widget container isNil ifTrue: [^0].	selectedFont := widget fontForEmphasis: emphasisSymbol.	textMeasurer := TextMeasurer forFont: selectedFont.	widthCollection := OrderedCollection new: aCollection size.	aCollection do: 			[:each |			string := aTextBlock value: each.			string notNil				ifTrue: [widthCollection addLast: (textMeasurer measureString: string)]].	count := widthCollection size.	sum := 0.	widthCollection do: [:each | sum := sum + each].	mean := sum // count.	sumSq := 0.	widthCollection do: [:each | sumSq := sumSq + (mean - each raisedTo: 2)].	stdDev := (sumSq / count) sqrt.	width := mean + ((stdDev * 2) rounded max: 35).	^width</body><body package="Store-UI" selector="findColumnMaxLengthFor:emphasis:columnTextBlock:">findColumnMaxLengthFor: aCollection emphasis: emphasisSymbol columnTextBlock: aTextBlock	 | longestValue string selectedFont textMeasurer widget |	aCollection isEmpty ifTrue: [^0].	widget := (self builder componentAt: #SelectionList) widget.	widget container isNil ifTrue: [^0].	selectedFont := widget fontForEmphasis: emphasisSymbol.	textMeasurer := TextMeasurer forFont: selectedFont.	longestValue := 0.	aCollection do: [:each| 		string := aTextBlock value: each.		string notNil			ifTrue: [longestValue :=  (textMeasurer measureString: string) max: longestValue]].	^longestValue</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>converting</category><body package="Store-DB-Records" selector="asCommentTag">asCommentTag	"Answer an instance of ClassCommentTag"	^ClassCommentTag newClassName: self absoluteName isMeta:  self isMeta</body><body package="Store-DB-Records" selector="asDescriptor">asDescriptor	"Answer an instance of ClassDescriptor."	^ClassDescriptor fromModel: self</body><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	"Return a stub of a class definition"	^Store.Glorp.StoreClassDefinition new privateSetPrimaryKey: self primaryKey.</body><body package="Store-DB-Records" selector="asTag">asTag	"Answer an instance of TT_ClassTag"	^ClassTag newClassName: self absoluteName isMeta: self isMeta</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>testing</category><body package="Store-DB-Records" selector="isClass">isClass	^true</body><body package="Store-DB-Records" selector="isForClass">isForClass			^true</body><body package="Store-DB-Records" selector="isMeta">isMeta	^self name namesMetaClass</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="displayString">displayString	^SystemUtils convertAbsoluteNameToFull: self absoluteName</body><body package="Store-DB-Records" selector="printOn:">printOn: aStream	aStream nextPutAll: 'ClassRecord{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>public interface</category><body package="Store-DB-Records" selector="loadComment">loadComment	| cl |	(cl := self myClass) isNil ifFalse: [self loadCommentFor: cl]</body><body package="Store-DB-Records" selector="loadComponents:meta:package:">loadComponents: aSet meta: isMeta package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| imPkg methods cls data cname |	imPkg := Registry packageNamed: aDBPackage name.	imPkg isNil 		ifTrue: 			[^Dialog 				warn: ((#Package1sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Package &lt;1s&gt; is not loaded.') expandMacrosWith: aDBPackage name)].	cls := ((aSet includes: #definition) or: [aSet includes: #comment]) 				ifTrue: [self]				ifFalse: [nil].	cname := self classNameWithMeta.	"actually, this is always the instance side."	isMeta ifTrue: [cname := cname , ' class'].	methods := (aSet includes: #methods) 				ifTrue: [aDBPackage methodsForClassNamed: cname]				ifFalse: [Array new].	data := (aSet includes: #data) 				ifTrue: [aDBPackage dataForNamed: self absoluteName]				ifFalse: [Array new].	(LoadAnalyzer 		canLoadClass: cls		methods: methods		data: data		from: imPkg) ifFalse: [^self].	(aSet includes: #definition) 		ifTrue: 			[Policies packagePolicy forcePackage: imPkg while: [self loadDefinition]].	(aSet includes: #comment) 		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadComment]].	(aSet includes: #methods) 		ifTrue: [methods do: [:m | m loadSrcIntoPackage: imPkg confirm: false]].	(aSet includes: #data) 		ifTrue: [data do: [:m | m loadSrcIntoPackage: imPkg confirm: false]]</body><body package="Store-DB-Records" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| imPkg methods cls data |	imPkg := Registry packageNamed: aDBPackage name.	imPkg isNil 		ifTrue: 			[^Dialog 				warn: ((#Package1sIsNotLoaded &lt;&lt; #store &gt;&gt; 'Package &lt;1s&gt; is not loaded.') expandMacrosWith: aDBPackage name)].	cls := ((aSet includes: #definition) or: [aSet includes: #comment]) 				ifTrue: [self]				ifFalse: [nil].	methods := (aSet includes: #methods) 				ifTrue: [aDBPackage methodsForClassNamed: self classNameWithMeta]				ifFalse: [Array new].	data := (aSet includes: #data) 				ifTrue: [aDBPackage dataForNamed: self absoluteName]				ifFalse: [Array new].	(LoadAnalyzer 		canLoadClass: cls		methods: methods		data: data		from: imPkg) ifFalse: [^self].	(aSet includes: #definition) 		ifTrue: 			[Policies packagePolicy forcePackage: imPkg while: [self loadDefinition]].	(aSet includes: #comment) 		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadComment]].	(aSet includes: #methods) 		ifTrue: [methods do: [:m | m loadSrcIntoPackage: imPkg confirm: false]].	(aSet includes: #data) 		ifTrue: [data do: [:m | m loadSrcIntoPackage: imPkg confirm: false]]</body><body package="Store-DB-Records" selector="loadSrc">loadSrc	"Load a class definition if necessary do not log changes."	^self loadSrcInto: nil.		"whatever the default is"</body><body package="Store-DB-Records" selector="loadSrcInto:">loadSrcInto: imagePackage	"Load a class definition if necessary do not log changes."	| classFalseOrUnloadableDefinitionError |	classFalseOrUnloadableDefinitionError := self loadDefinition: self definition into: imagePackage logged: false.	(classFalseOrUnloadableDefinitionError == false or: [classFalseOrUnloadableDefinitionError isSignalledException])		ifTrue: [^false].	(self isMeta not and: [classFalseOrUnloadableDefinitionError notNil]) ifTrue:		[self loadCommentFor: classFalseOrUnloadableDefinitionError].	IncrementNotification raiseSignal.	^classFalseOrUnloadableDefinitionError notNil</body><body package="Store-DB-Records" selector="myClass">myClass		"Answer the receiver's class in the image. 		Answer nil if not loaded."	| cls |	cls := self fullName asClassNameOnly asStrictReference valueOrDo: [ ^nil ].	^self isMeta		ifTrue: [ cls class ]		ifFalse: [ cls ].</body><body package="Store-DB-Records" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveClass: self className		package: aPackage</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>browser support</category><body package="Store-DB-Records" selector="asString">asString	^name</body><body package="Store-DB-Records" selector="binding">binding		"No such thing"	^self</body><body package="Store-DB-Records" selector="simpleName">simpleName	^name</body><body package="Store-DB-Records" selector="value">value		"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body><body package="Store-DB-Records" selector="valueOrDo:">valueOrDo: aBlock		"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="absoluteName">absoluteName	^self fullNameOnly</body><body package="Store-DB-Records" selector="className">className	^name</body><body package="Store-DB-Records" selector="classNameWithMeta">classNameWithMeta	^self fullyQualifiedPath, '.', name</body><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#class</body><body package="Store-DB-Records" selector="fullName">fullName	| str |	str := BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.	self isMeta ifTrue: [ str := str, ' class' ].	^str</body><body package="Store-DB-Records" selector="fullNameOnly">fullNameOnly	^BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.</body><body package="Store-DB-Records" selector="instanceBehavior">instanceBehavior		^self</body><body package="Store-DB-Records" selector="nameOnly">nameOnly	^BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.</body><body package="Store-DB-Records" selector="object">object		"Answer the object represented by the receiver as it exists in the image."	| obj |	obj := self fullNameOnly asStrictReference valueOrDo: [ ^nil ].	^self isMeta		ifTrue: [ obj class ]		ifFalse: [ obj ]</body><body package="Store-DB-Records" selector="realname">realname	^name asClassNameOnly</body><body package="Store-DB-Records" selector="setCommentFor:">setCommentFor: aClass 	"OBSOLETE"</body><body package="Store-DB-Records" selector="superclass">superclass	"Answer the receiver's superclass."	^superclass</body><body package="Store-DB-Records" selector="superclass:">superclass: newSuperclass	"Set the receiver's superclass to newSuperclass."	superclass := newSuperclass</body><body package="Store-DB-Records" selector="symbol">symbol	^self absoluteSymbol</body><body package="Store-DB-Records" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isClassCommentTag		ifTrue: [self comment]		ifFalse: [self definition]</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="containingPackages">containingPackages	^[( PkgClasses packagesContainingClass: self primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body><body package="Store-DB-Records" selector="instSideFrom:">instSideFrom: aDBPackage 	^self isMeta		ifTrue: [ aDBPackage classInPackageNamed: self absoluteName meta: false ] 		ifFalse: [ self ]</body><body package="Store-DB-Records" selector="metaSideFrom:">metaSideFrom: aDBPackage 	^self isMeta		ifTrue: [ self ]		ifFalse: [ aDBPackage classInPackageNamed: self absoluteName meta: true ]</body><body package="Store-DB-Records" selector="oppositeSideFrom:">oppositeSideFrom: aDBPackage 	^self isMeta		ifTrue: [self instSideFrom: aDBPackage]		ifFalse: [self metaSideFrom: aDBPackage]</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="convertFromXML:">convertFromXML: aString	| p element out attr value i |	p := XML.XMLParser on: aString readStream.	element := p validate: false; getNextChar; element.	out := (String new: 128) writeStream.	out nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'environment') characterData			quoted: false).	out nextPutAll: ' defineClass: ';		store: (element elementNamed: 'name') characterData asSymbol.	out crtab; nextPutAll: 'superclass: ';		nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'super') characterData			quoted: true).	out crtab; nextPutAll: 'indexedType: ';		store: (element elementNamed: 'indexed-type') characterData asSymbol.	out crtab; nextPutAll: 'private: ';		nextPutAll: (element elementNamed: 'private') characterData.	out crtab; nextPutAll: 'instanceVariableNames: ';		store: (element elementNamed: 'inst-vars') characterData.	out crtab; nextPutAll: 'classInstanceVariableNames: ';		store: (element elementNamed: 'class-inst-vars') characterData.	out crtab; nextPutAll: 'imports: ';		store: (element elementNamed: 'imports') characterData.	out crtab; nextPutAll: 'category: ';		store: (element elementNamed: 'category') characterData.	attr := [element elementNamed: 'attributes'] on: Error do: [:ex | ex return: nil].	attr == nil ifFalse:		[out crtab; nextPutAll: 'attributes: #('.		attr elements do: [:elm |			elm isElement ifTrue:				[out crtab: 3; nextPutAll: '#('; store: elm tag type asSymbol; space.				((elm elements contains: [:e | e isElement]) or: [elm elements isEmpty])					ifTrue: [value := (elm elements select: [:e | e isElement])							collect: [:e | e characterData]]					ifFalse:						[value := elm characterData.						i := #('nil' 'true' 'false') indexOf: value.						value := i = 0 ifTrue: [value asSymbol] ifFalse: [#(nil true false) at: i]].				out store: value; nextPutAll: ')']].		out nextPutAll: ')'].	^out contents</body><body package="Store-DB-Records" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineClass:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'super' value: (self convertVariableNodeToXML: (data at: 'superclass:')).	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'indexed-type' value: (data at: 'indexedType:') value asString.	self sax: driver tag: 'inst-vars' value: (data at: 'instanceVariableNames:') value.	self sax: driver tag: 'class-inst-vars' value: (data at: 'classInstanceVariableNames:') value.	self sax: driver tag: 'imports' value: (data at: 'imports:') value asString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	(data includesKey: 'attributes:') ifTrue:		[driver startElement: 'attributes' atts: nil.		(data at: 'attributes:') value do: [:attr |			(attr last isKindOf: Array)				ifTrue:					[driver startElement: attr first atts: nil.					attr last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: attr first value: attr last displayString]].		driver endElement].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body><body package="Store-DB-Records" selector="loadDefinition:into:logged:">loadDefinition: aString into: anImagePackage logged: aBoolean	"Load the receiver into the image by compiling it's definition."		(self superclass asStrictReference isDefined or: [self superclass = 'nil']) 		ifFalse: [^false].	^[super loadDefinition: aString into: anImagePackage logged: aBoolean]		on: ClassBuilder buildFailureSignal		do:			[:exception | 			| msg |			msg := #N1sErrorCompilingClass2sNt3s &lt;&lt; #store &gt;&gt; '&lt;n&gt;&lt;1s&gt;: Error compiling class &lt;2s&gt;:&lt;nt&gt;&lt;3s&gt;'				expandMacrosWith: anImagePackage name				with: name				with: exception description.			Transcript show: msg.			exception proceed]</body><body package="Store-DB-Records" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean 	"Load the method. Make sure that it goes to the imPkg. and it does not	overwrites existing definition from another package."	aBoolean ifTrue: 		[(Dialog confirm: #DoYouWantToLoadTheSelectedClass &lt;&lt; #store &gt;&gt; 'Do you want to load the selected class?') ifFalse: [^self]].	(LoadAnalyzer canLoadClass: self from: imPkg) ifTrue:		[Policies packagePolicy forcePackage: imPkg while: [self loadSrc]]</body><body package="Store-DB-Records" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	XChangeSet current moveClassDefinition: obj toPackage: imgPackage</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	anObject isMeta = self isMeta		ifFalse: [ ^false ].	^anObject absoluteName = self absoluteName.</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForClass</body><body package="Store-DB-Records" selector="quickComparesTo:">quickComparesTo: anObject		"Answer true if anObject could be another version of the receiver."		"For comparing differenct db versions."	^( super quickComparesTo: anObject ) and: [ self isMeta = anObject isMeta ]</body><body package="Store-DB-Records" selector="sameAsImThing:">sameAsImThing: aThing 	"Answer true if aThing is defined the same as the receiver."		"Ds- this compares the definition as a string--problem is, 		for non-existant ClassPools there is an error producing this		string. So... punt for now."	^[ aThing definitionAndComment = self definitionAndComment ] 		on: Dictionary valueNotFoundSignal do: [ :exp | exp return: false ].</body><body package="Store-DB-Records" selector="sourceMatches:">sourceMatches: aClass	"Answer whether the source matches."	^aClass definitionAndComment equalsAcrossPlatforms: self definitionAndComment</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="from:timeStamp:trace:">from: class timeStamp: timeStamp trace: oldDB		| classDef classComment superclassName |	classDef := self definitionFor: class.	classComment := self commentFor: class.	superclassName := self superclassNameFor: class.	^(self new)		name: class name asString;		environmentString: class environment absoluteName;		timeStamp: timeStamp;		superclass: superclassName;		definitionStr: classDef;		commentStr: classComment;		setTrace: oldDB</body><body package="Store-DB-Records" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord	super moveFieldsFrom: aView to: aDBRecord.	aDBRecord superclass: aView superclass.</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="associationClass">associationClass	^PkgClasses</body><body package="Store-DB-Records" selector="commentFor:">commentFor:  aClass	^self processString: aClass comment</body><body package="Store-DB-Records" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_ClassName' #('name'))		#('ST_ClassTimestamp' #('timeStamp'))		#('ST_ClassEnvString' #('environmentString'))		#('ST_ClassGCSupport' #('trace'))		)</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn	^#classRef</body><body package="Store-DB-Records" selector="sourcesViewClass">sourcesViewClass	^PkgClassesAndSourcesView</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="allMetaclassesInPackage:butNotIn:">allMetaclassesInPackage: pkgKey1 butNotIn: pkgKey2 	"Answer a collection of metaclasses that are part of a package 	whith key pkgKey1 but are not part of a package pkgKey2."	"self allMetaclassesInPackage: 63 butNotIn: 57"	^Array new	"^ self 		allIn: pkgKey1		butNotIn: pkgKey2		refColumn: 'metaclassRef'		associationClass: PkgClasses"</body><body package="Store-DB-Records" selector="allMetaclassesInPackages:">allMetaclassesInPackages: keys	"Answer a collection of items that are in the packages in keys"	"Send to a concrete subclass that implements #referenceColumn"	"Method allInPackages: #( '23' '55' )"	^self allInPackages: keys refColumn: #metaClassRef</body><body package="Store-DB-Records" selector="allMetaclassesInPackages:butNotIn:">allMetaclassesInPackages: pkgKeys1 butNotIn: pkgKeys2 	"Answer a collection of instances for metaclasses that are contained in one of the packages 	in pkgKeys1, but not in the packages in pkgKeys2."	^Array new"	^ self 		allInPackages: pkgKeys1 		butNotIn: pkgKeys2 		refColumn: #metaclassRef"</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>private-testing</category><body package="Store-DB-Records" selector="test1">test1	"Create class records in the data base."	"self test1"	self newFrom: self</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>private</category><body package="Store-DB-Records" selector="absentClassNameToUseOn:">absentClassNameToUseOn: class	"We are used only on AbsentClassImporter classes (and meta classes) to give back a	subclass name that is really the real target subclass to use, if the real subclass existed.	However, they don't really exist in an AbsentClassImporter, but they do say who they are a stand in for	in the #absentSuperclassName, and we use that to get the value we want to save in the database"	| absentName classToQuery stream |	classToQuery := class isMeta		ifTrue: [class soleInstance]		ifFalse: [class].	absentName := classToQuery absentSuperclassName.	stream := WriteStream on: (String new: 100).	stream nextPutAll: absentName asStrictReference home fullRootName.	stream nextPut: $..	stream nextPutAll: absentName.	class isMeta ifTrue: [stream nextPutAll: ' class'].	^stream contents.</body><body package="Store-DB-Records" selector="isAbsentClassImporter:">isAbsentClassImporter: aClassOrMetaclass	"Is the passed in class or meta in any way a kind of AbsentClassImporter"		^(aClassOrMetaclass superclass = AbsentClassImporter) or: [aClassOrMetaclass superclass = AbsentClassImporter class]</body><body package="Store-DB-Records" selector="superclassNameFor:">superclassNameFor: aClassOrMetaclass		(self isAbsentClassImporter: aClassOrMetaclass) ifTrue: 		[^self absentClassNameToUseOn: aClassOrMetaclass].	^aClassOrMetaclass superclass isNil		ifTrue: ['nil']		ifFalse: [aClassOrMetaclass superclass absoluteName]</body></methods><methods><class-id>Store.BundleHasUnpublisedChangesConfirmation</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		^Dialog		confirm:			(#T1sHasUnpublisheUdedNttttContinue &lt;&lt; #store &gt;&gt;					'&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.BundleHasUnpublisedChangesConfirmation</class-id> <category>constants</category><body package="Store-Base" selector="defaultResumeValue">defaultResumeValue	"Answer the default value to resume with."	^true</body><body package="Store-Base" selector="defaultReturnValue">defaultReturnValue	"Answer the default value to resume with."	^true</body></methods><methods><class-id>Store.BundleHasUnpublisedChangesConfirmation class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>private</category><body package="Store-Merge Management" selector="clearMoves">clearMoves		| knownMoves |	knownMoves := OrderedCollection new.	resolutions do: 		[:eachResolution | 		eachResolution 			execute: [:each | each isMove] 			ifTrueAddTo: knownMoves].	knownMoves do: [:each | each movePair: nil]</body><body package="Store-Merge Management" selector="createResolutionFrom:from:">createResolutionFrom: aPseudoDifference from: aVersionNode	| packageResolution packageTarget |	packageTarget := aPseudoDifference mainPackage ifNil: [aPseudoDifference otherPackage].	packageResolution := self resolutions at: packageTarget name ifAbsentPut: [PackageResolutions fromPundle: packageTarget].	packageResolution resolutionForDifference: aPseudoDifference fromVersion: aVersionNode package.	packageResolution isBundle ifTrue: [packageResolution structureDifferenceUsing: aPseudoDifference fromVersion: aVersionNode package].</body><body package="Store-Merge Management" selector="detectMoves">detectMoves	self markMovesUsingFindBlock: [:each | each proposed notNil and: [each isClassDefintionResolver]].	self markMovesUsingFindBlock: [:each | each proposed notNil and: [each isNameSpaceDefinitionResolver]]</body><body package="Store-Merge Management" selector="markMovePairsIn:">markMovePairsIn: aCollection		| groupedDefinitions |	groupedDefinitions := aCollection groupedBy: [:each | each proposed isRemovalResolution].	(groupedDefinitions isEmpty or: [groupedDefinitions keys size &lt; 2]) ifTrue: [^self].	(groupedDefinitions at: true) do:		[:eachRemoval | 		| pair |		pair := (groupedDefinitions at: false) 			detect: [:eachAdd | eachAdd proposed value = eachRemoval proposed definitionValue] 			ifNone: [nil].		pair ifNotNil:			[:value | 			eachRemoval movePair: value.			value movePair: eachRemoval]]</body><body package="Store-Merge Management" selector="markMovesUsingFindBlock:">markMovesUsingFindBlock: aOneArgumentBlock	| potentialMoves |	potentialMoves := OrderedCollection new.	resolutions do: [:eachResolution | eachResolution execute: aOneArgumentBlock ifTrueAddTo: potentialMoves].	potentialMoves size &gt; 1 ifTrue: [self markMovePairsIn: potentialMoves].</body><body package="Store-Merge Management" selector="mostRecentlyPublished:">mostRecentlyPublished: aCollectionOfDbVersions	"Answer the most recently published of a from the collection."	"NOTE: image versions are not allowed in the list."	| max |	max := aCollectionOfDbVersions asOrderedCollection first.	aCollectionOfDbVersions do:		[ :ver | 		ver primaryKey &gt; max primaryKey			ifTrue: [ max := ver ]		].	^max.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>accessing</category><body package="Store-Merge Management" selector="addPackageNamed:mergeVersions:">addPackageNamed: aString mergeVersions: aCollectionOfPundleVersions	"Specify that 'aPackageVersionCollection' are the package 	versions of 'aPackageName' to be merged.	We add the versions to the list of those to integratedVersions.	Get the image version pundle model, if there is none, or the image model is not in the current database, raise an error.	build the root node, then if the pundleModel is nil (should never get there) then do some ugly stuff.	Build the tree of packages to be merged. 	And add the the trees to integrate."		| pundleModel parentPundle rootNode builtNode delta |	(integratedVersions at: aString ifAbsentPut: [OrderedCollection new]) addAll: aCollectionOfPundleVersions.	pundleModel := aCollectionOfPundleVersions asOrderedCollection first getImagePundle.	(pundleModel isNil or: [pundleModel validateDatabaseId]) ifFalse: [pundleModel raiseMismatchedSignal].	pundleModel isNil		ifTrue: [parentPundle := self mostRecentlyPublished: aCollectionOfPundleVersions]		ifFalse:			[parentPundle := pundleModel tracePackage asStorePundleIn: (self sessionFrom: aCollectionOfPundleVersions).			(integratedVersions at: aString) addFirst: parentPundle].	parentPundle isNil		ifTrue: [self error: (#PackageVersionOf1pDoesNotExist &lt;&lt; #store &gt;&gt; 'Package version of &lt;1p&gt; does not exist' expandMacrosWith: aString)].	rootNode := Store.Glorp.VersionNode on: parentPundle.	pundleModel isNil ifTrue:		[parentPundle class imageClass emptyPundleFrom: parentPundle.		delta := PackageComparitor differencesWithPropertiesBetween: parentPundle and: PseudoPackage new.		delta changedClassesNamespacesAndPropertiesForMerge do:			[:eachDifference | 			self createResolutionFrom: eachDifference from: parentPundle]].	builtNode := rootNode buildTree: aCollectionOfPundleVersions.	trees add: (Array with: rootNode with: builtNode)</body><body package="Store-Merge Management" selector="affectedPackages">affectedPackages	"Answer a collection of image packages that were affected by applying modifications."	"Meaning, that they have modifications that will be lost."	| pkgs |	trees isNil ifTrue: [^#()].	pkgs := Set new.	trees do: 		[ :tree |   | node imPkg |		node := tree at: 1.		imPkg := Registry packageNamed: node package name.		( imPkg notNil and: [ imPkg hasBeenModified ] )				ifTrue: [ pkgs add: imPkg ]		].	^pkgs asArray</body><body package="Store-Merge Management" selector="doMerge">doMerge	"For each tree divide nodes into level. For each level calculate the 	difference between the node and its parent."		trees keysAndValuesDo:		[:index :each | 		| rootNode |		rootNode := each at: 2.		rootNode maxLevel to: 1 by: -1 do:			[:eachLevel | 			(rootNode nodesAtLevel: eachLevel) do:				[:eachVersionNode | 				| delta |				(Merging for: eachVersionNode package) started.				delta := PackageComparitor differencesWithPropertiesBetween: eachVersionNode package and: eachVersionNode parent package.				delta changedClassesNamespacesAndPropertiesForMerge do:					[:eachDifference | 					self createResolutionFrom: eachDifference from: eachVersionNode].				(Merging for: eachVersionNode package) finished]]].	self makeResolutionProposals.	self resolutions isEmpty ifTrue: [^false].	^true</body><body package="Store-Merge Management" selector="integratedPackages">integratedPackages	^integratedVersions select: [:each | each first isPackage]</body><body package="Store-Merge Management" selector="integratedVersions">integratedVersions	^integratedVersions</body><body package="Store-Merge Management" selector="makeResolutionProposals">makeResolutionProposals	"if the alternatives without the one (if any) associated with the base leaves precisely 	one alternative, that single alternative is the one that becomes the proposed alternative."		resolutions do: [:packageResolutions | packageResolutions makeResolutionProposals].	resolutions do: [:packageResolutions | packageResolutions removeEmptyResolvers].	self resolutions copy do:		[:each |		each resolutions isEmpty ifTrue: [resolutions removeKey: each name]].	self detectMoves.</body><body package="Store-Merge Management" selector="mergePackageVersions:">mergePackageVersions: aCollectionOfPackageVersions	"Iterate over packages separately because they may have the same name"		| map |	self reset.	map := Dictionary new.	aCollectionOfPackageVersions do: [:each | (map at: each name ifAbsent: [map at: each name put: OrderedSet new]) add: each].	map keysAndValuesDo:		[:name :packages | 		| versions |		(versions := packages select: [:each | each isPackage]) isEmpty ifFalse: 			[self addPackageNamed: name mergeVersions: versions].		(versions := packages select: [:each | each isBundle]) isEmpty ifFalse: 			[self addPackageNamed: name mergeVersions: versions]]</body><body package="Store-Merge Management" selector="packages">packages	"Answer a collection of image packages that 	are included in this set of merge data"	| pkgs |	pkgs := Set new.	trees isNil ifTrue: [^#()].	trees		do: 			[:tree | 			| node imPkg |			node := tree at: 1.			imPkg := Registry packageNamed: node package name.			imPkg notNil				ifTrue: [pkgs add: imPkg]].	^pkgs asArray</body><body package="Store-Merge Management" selector="proposedResolutions">proposedResolutions	| proposed |	proposed := resolutions 		inject: OrderedCollection new		into: 			[:sum :each |			sum addAll: each proposedResolutions.			sum].	^proposed</body><body package="Store-Merge Management" selector="resolutions">resolutions	^resolutions</body><body package="Store-Merge Management" selector="sessionFrom:">sessionFrom: aCollectionOfPundleVersions		| pundle |	pundle := aCollectionOfPundleVersions 		detect: [:each | each isKindOf: StorePundle]		ifNone: [^nil].	^pundle session</body><body package="Store-Merge Management" selector="sortedListResolutionValues:">sortedListResolutionValues: aSymbol	| result |	result := OrderedCollection new.	resolutions values 		inject: result 		into: 			[:sum :each | 			sum addAll: (each sortedListResolutionValues: aSymbol).			sum].	^result</body><body package="Store-Merge Management" selector="sortedTreeResolutionValues:">sortedTreeResolutionValues: aSymbol	aSymbol = #unresolved ifTrue: [^self sortedTreeResolutions select: [:each | each isResolved not]].	aSymbol = #conflicts ifTrue: [^self sortedTreeResolutions select: [:each | each hasNoConflicts not]].	^self sortedTreeResolutions</body><body package="Store-Merge Management" selector="sortedTreeResolutions">sortedTreeResolutions	| result |	result := resolutions values select: #isBundle.	result addAll: (resolutions values select: #isPackage).	^result</body><body package="Store-Merge Management" selector="trees">trees	^trees</body><body package="Store-Merge Management" selector="versionsUsedForMerge">versionsUsedForMerge	| storePundles resolvedNames |	trees ifNil: [^#()].	storePundles := Set new.	trees do:		[:eachTree |		storePundles add: eachTree first package.		storePundles addAll: (eachTree first leaves collect: #package).		storePundles add: eachTree last package.		storePundles addAll: (eachTree last leaves collect: #package)].	resolvedNames := resolutions keys.	^(storePundles reject: #sameAsImage) select: [:each | each isBundle or: [resolvedNames includes: each name]]</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>copying</category><body package="Store-Merge Management" selector="copyEmpty">copyEmpty	^self class new.</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>testing</category><body package="Store-Merge Management" selector="isEmpty">isEmpty	^integratedVersions isEmpty</body></methods><methods><class-id>Store.Glorp.ResolutionManager</class-id> <category>initialize-release</category><body package="Store-Merge Management" selector="initialize">initialize	self reset</body><body package="Store-Merge Management" selector="reset">reset	resolutions := Dictionary new: 30.	integratedVersions := Dictionary new.	trees := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.ResolutionManager class</class-id> <category>instance-creation</category><body package="Store-Merge Management" selector="new">new		^super new initialize</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"set new blessings and comments...."	self validatePublishStateIsConsistent ifFalse: [^self].	self newGlobalState.	self specList publishBlessing.	self specList do:		[:each | each dbPundle blessingLevel: each blessing printString].	self setDetailState.	dialog accept; closeRequest</body><body package="Store-UI" selector="cancel">cancel	dialog doCancel</body><body package="Store-UI" selector="publishAllYes">publishAllYes	self forAllItemsDo: 		[ :ar | ar publish: true ].	labelDict := nil.	self newSelection</body><body package="Store-UI" selector="resetBundleOnly">resetBundleOnly	self forAllItemsDo: 		[ :ar | ar publish: false ].	items list first publish: true.		labelDict := nil.	self newSelection</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="localPostOpenWith:">localPostOpenWith: aBuilder	self items selectionIndexHolder onChangeSend: #newSelection to: self.	self setVisualBlocks.	self items selectionIndex: 1.</body><body package="Store-UI" selector="localRebuild">localRebuild		self setVisualBlocks.</body><body package="Store-UI" selector="userData:">userData: userData	self items list: userData.	labelDict := nil.</body><body package="Store-UI" selector="windowLabel">windowLabel	^(#ResettingBlessingLevelsAndComments &lt;&lt; #store &gt;&gt; 'Resetting Blessing Levels and Comments on: &lt;1s&gt; for: &lt;2s&gt;')		expandMacrosWith: self connectionLabel		with: self userNameLabel</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>help</category><body package="Store-UI" selector="mainHelp">mainHelp	^(#TheBlessingLevelAnAllPublishedItems &lt;&lt; #store &gt;&gt; 'The Blessing Level and Blessing Comment can be set individually for each component. It will apply to the selected item. Set Current Blessing Level and Comment for All, sets the same level and comment for all published items.') asString</body><body package="Store-UI" selector="publishHelp">publishHelp	^(#TheDefaultIsToResSelectedComponent &lt;&lt; #store &gt;&gt; 'The default is to reset the blessing level/comment for all modified subcomponents.Select Reset All to publish all components.Select Reset Only Modified to reset the default, which does not reset any unmodified components.Select Reset Bundle Only to reset only the topmost bundle.Reset and Do not Reset allow you to change the setting of the currently selected component.') asString</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>private</category><body package="Store-UI" selector="enableDetails">enableDetails	"The opposite of the publish dialog -- only modified guys can be changed."	self enablePublishBox.	self items selection notNil		ifTrue: 			[ self publish value				ifTrue: 					[ self details do: 						[:sym | self enableComponentAt: sym enable: true ] 					]			]</body><body package="Store-UI" selector="open">open	self openDialogInterface: #windowSpec</body><body package="Store-UI" selector="openDialogInterface:">openDialogInterface: aSymbol 		dialog := SimpleDialog new.	builder := dialog builder.	dialog postOpenBlock: [:dlg :bld |		self postOpenWith: bld].	dialog openFor: self interface: aSymbol</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>accessing</category><body package="Store-UI" selector="dialog">dialog	^dialog</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="setBlessingFor:">setBlessingFor: aPundle	aPundle isBundle 			ifTrue: [ self setBlessingForBundle: aPundle ]		ifFalse: [ self setBlessingForPackage: aPundle ].</body><body package="Store-UI" selector="setBlessingForBundle:">setBlessingForBundle: aBundle	"self setBlessingForBundle: ( Registry packageNamed: 'Store-Base' ) parentRecord."		| specificationList files instance |	(self validateForPublishing:		((aBundle containedItems)			addFirst: aBundle;			yourself)) ifFalse: [^self].	specificationList := self publishSpecsFrom: aBundle.		files := self publishFileSpecsFrom: aBundle.	instance := self new.	instance items list: specificationList.	instance blessingLevel value: aBundle blessingLevelNumber.	instance openWith: specificationList with: files.	instance dialog accept value ifTrue:		[instance accept.		aBundle blessingLevel: instance blessingLevel value]</body><body package="Store-UI" selector="setBlessingForPackage:">setBlessingForPackage: aStorePackage	"Redirect to existing dialog for a single package."		"self setBlessingForBundle: ( Registry packageNamed: 'Store-Base' ) parentRecord."	| dialog publishSpecification |	dialog := CommentPrompt forPundle: aStorePackage.	dialog blessingLevel value: aStorePackage blessingLevelNumber.	dialog open.	dialog accept value ifTrue: 		[publishSpecification := self publishSpecFrom: aStorePackage.		publishSpecification publish: true.		publishSpecification blessing: dialog blessingLevel value.		publishSpecification comment: dialog text value asString.		publishSpecification publishBlessing.		aStorePackage blessingLevel: dialog blessingLevel value]</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	| complexList |	complexList := 		OrderedCollection new			add: 'Blessing' -&gt; #(#mainSpec #mainHelp);			add: 'Reset Options' -&gt; #(#publishSpec #publishHelp);			asArray.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new: 1.</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>private</category><body package="Store-UI" selector="publishSpecFrom:">publishSpecFrom: aPackage	 ^PublishSpecification dbPundle: aPackage</body><body package="Store-UI" selector="publishSpecsFrom:">publishSpecsFrom: aBundle  	 ^PublishSpecificationList fromDbBundle: aBundle</body><body package="Store-UI" selector="userData:forPundle:">userData: anUserData forPundle: aPundle 	"Set the common items in the user data."	anUserData 		at: #publish put: true;		at: #pundle put: aPundle;		at: #comment put: '';		at: #level put: 0;		at: #modified put: true;		at: #version put: aPundle version;		at: #parentVersion put: aPundle version;		at: #description put: nil;		at: #blessing put: aPundle blessingLevelNumber;		yourself.</body><body package="Store-UI" selector="userData:forPundle:traceItems:">userData: anUserData forPundle: aPundle traceItems: traceItems	"Set the common items in the user data."	| mod |	 mod := traceItems contains: [ :p | p primaryKey = aPundle primaryKey ].	anUserData 		at: #publish put: mod not;		at: #pundle put: aPundle;		at: #comment put: '';		at: #level put: 0;		at: #modified put: mod not;		at: #description put: nil;		at: #version put: aPundle version;		at: #parentVersion put: aPundle version;		at: #blessing put: aPundle blessingLevelNumber;		yourself.</body><body package="Store-UI" selector="userDataFrom:">userDataFrom: aBundle  	| dict coll items traceItems trace |	dict := Dictionary new.	items := aBundle uniqueItemsAndLevels.	( trace := aBundle parentRecord ) == nil		ifTrue: [ traceItems := Set new ]		ifFalse: [ traceItems := trace allItems ].	self userData: dict forPundle: aBundle traceItems: traceItems.	dict 		at: #publish put: true;		at: #modified put: true.	coll := List with: dict.	items do: 		[ :pair | 	| pndl comp |		comp := pair at: 1.		pndl := comp.		dict := Dictionary new.		self userData: dict forPundle: pndl traceItems: traceItems.		dict at: #description put: comp.		dict at: #level put: ( pair at: 2 ).		coll add: dict		].	^coll</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="isAddition">isAddition	^isAddition</body><body package="Store-Code Comparison" selector="isAddition:">isAddition: aBoolean	isAddition := aBoolean</body><body package="Store-Code Comparison" selector="method:">method: aMethodBlueprint	method := aMethodBlueprint</body><body package="Store-Code Comparison" selector="parseTree">parseTree	parseTree == 0		ifTrue: 			[parseTree := [Refactory.Browser.RBParser parseMethod: method source]						on: Error						do: [nil]].	^parseTree</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>row population</category><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	| view |	view := TextEditorView model: method sourceText asValue.	view beReadOnly.	^Array with: view</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| header |	super populateHeader.	header := self header.	header add: (isAddition				ifTrue: [ComparisonIcons add]				ifFalse: [ComparisonIcons remove]).	header add: (Label with: method selectorDisplayText).	header add: self moreInfoTooltipHandle</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="initialize">initialize	super initialize.	parseTree := 0</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>private</category><body package="Store-Code Comparison" selector="imageMethod">imageMethod	^self imageMethodDefinitionFrom: method</body><body package="Store-Code Comparison" selector="storeMethod">storeMethod	^method originalStoreObject</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>testing</category><body package="Store-Code Comparison" selector="hasMenu">hasMenu	^true</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison" selector="categoryInfoTooltipText">categoryInfoTooltipText	| output |	output := TextStream on: String new.	output nextPutAll: (#MethodCategoryC &gt;&gt; 'Category:' &lt;&lt; #IDE) asString.	output space.	output		emphasis: #bold;		nextPutAll: method category;		emphasis: nil.	^output contents</body><body package="Store-Code Comparison" selector="packageInfoTooltipText">packageInfoTooltipText	| output |	output := TextStream on: String new.	output nextPutAll: (#DefinitionPackageC &gt;&gt; 'Package:' &lt;&lt; #IDE) asString.	output space.	output		emphasis: #bold;		nextPutAll: method packageName;		emphasis: nil.	^output contents</body><body package="Store-Code Comparison" selector="tooltipTextChunks">tooltipTextChunks	^Array with: self categoryInfoTooltipText with: self packageInfoTooltipText</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^Array		with: #singleMethod		with: method selector		with: method isInstanceBehavior</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>accessing</category><body package="Store-Database Model" selector="definition">definition	^self object.</body><body package="Store-Database Model" selector="object">object	^self basicDefinition object.</body><body package="Store-Database Model" selector="searchString">searchString	^searchString</body><body package="Store-Database Model" selector="searchString:">searchString: aString	"Clean up TwoByteString objects, etc. before accepting them."	searchString := Store.PropertyRecord searchStringFrom: aString</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>reconciling</category><body package="Store-Database Model" selector="reconcilesWith:">reconcilesWith: aStoreDefinitionObject	self searchString = aStoreDefinitionObject searchString ifFalse: [^false].	(super reconcilesWith: aStoreDefinitionObject) ifFalse: [^false].	^true.</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	"See class creation method."	super postCopyIn: aDictionary.	searchString isNil ifFalse: [searchString := searchString copyFrom: 1 to: (250 min: searchString size)].</body></methods><methods><class-id>Store.Glorp.StoreProperty</class-id> <category>printing</category><body package="Store-Database Model" selector="printOn:">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: self name;		nextPut: $)</body></methods><methods><class-id>Store.Glorp.StoreProperty class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="named:forObject:in:">named: aString forObject: anObject in: aPundle	| objectName |	objectName := anObject displayString asString.	^self new		username: aPundle username;		timestamp: (aPundle timestamp ifNil: [Dialect storeTimestampIn: aPundle session]);		name: aString;		basicDefinition: (StoreBlob forObject: anObject);		searchString: (objectName copyFrom: 1 to: (250 min: objectName size)).	"We allow 255 characters, but on some databases that's bytes, so non-ascii characters in comments might pad that. This is just a hack to allow a bit of free space"</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>actions</category><body package="Store-UI" selector="applyChanges">applyChanges	self targetedPundles list do:		[:each |		each currentBlessingLevel = -54 ifFalse: [self setBlessingForRemoval: each]].	previouslyMarkedPundles do:		[:each |		(self targetedPundles list includes: each) ifFalse: [self resetBlessingFor: each]].	previouslyMarkedPundles := self targetedPundles list asOrderedCollection.	self enableApply</body><body package="Store-UI" selector="browseBundle">browseBundle	(Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: (Store.Glorp.StoreForGlorpBrowserEnvironment on: self bundleVersions selections first)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-UI" selector="browsePackage">browsePackage	(Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: (Store.Glorp.StoreForGlorpBrowserEnvironment on: self packageVersions selections first)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-UI" selector="bundleSelectionChanged">bundleSelectionChanged	bundles selectionIndex isZero ifTrue: [^self bundleVersions list: #()].	builder window sensor invalidationSuppressWhile: [bundleVersions list: self filteredBundleVersions].	self setupBundleListPane.</body><body package="Store-UI" selector="cancelChanges">cancelChanges	self targetedPundles list copy do:		[:each |		each blessingLevelNumber = -54 ifFalse: [self targetedPundles list remove: each]].	self enableApply</body><body package="Store-UI" selector="clearFilter">clearFilter	| bundlesTarget packagesTarget |	bundlesTarget := self bundles selection.	packagesTarget := self packages selection.	oldFilter := filter.	filter := DeletionToolFilter new.	self setPundleNames.	(self packages list includes: packagesTarget)		ifTrue: [self packages selection: packagesTarget].	(self bundles list includes: bundlesTarget)		ifTrue: [self bundles selection: bundlesTarget].</body><body package="Store-UI" selector="closeWindow">closeWindow	^self closeRequest</body><body package="Store-UI" selector="editFilter">editFilter	| dialog |	dialog := DeletionToolFilterTool new.	oldFilter ifNotNil: [filter := oldFilter].	dialog filter: filter.	dialog open.	dialog accept value 		ifTrue: [filter := dialog filter]		ifFalse: [filter := DeletionToolFilter new].	self applyFilter</body><body package="Store-UI" selector="enableApply">enableApply	| enablement |	enablement := (self targetedPundles list allSatisfy: [:each | each currentBlessingLevel = -54]) not.	enablement := enablement or: [(targetedPundles list isSameSequenceAs: previouslyMarkedPundles) not].	self setupTargetedPundlesPane.	(self widgetAt: #ApplyChanges) isEnabled: enablement.	(self widgetAt: #CancelChanges) isEnabled: enablement.	(self widgetAt: #TargetedPundles) invalidate.	(self widgetAt: #BundleVersions) ifNotNil: 		[:value | 		self setupBundleListPane.		value invalidate].	(self widgetAt: #PackageVersions) ifNotNil: 		[:value | 		self setupPackageListPane.		value invalidate].</body><body package="Store-UI" selector="installBundlePage">installBundlePage	(self widgetAt: #PundleChooser)		client: self		spec: #bundlesPage		builder: (builder newSubBuilder).	(self widgetAt: #PundleChooser) invalidate</body><body package="Store-UI" selector="installPackagePage">installPackagePage	(self widgetAt: #PundleChooser)		client: self		spec: #packagesPage		builder: (builder newSubBuilder)</body><body package="Store-UI" selector="packageSelectionChanged">packageSelectionChanged	packages selectionIndex isZero ifTrue: [^self packageVersions list: #()].	builder window sensor invalidationSuppressWhile: [packageVersions list: self filteredPackageVersions].	self setupPackageListPane.</body><body package="Store-UI" selector="pageChanged">pageChanged	| index |	index := self pundleTabs selectionIndex.	index = 1		ifTrue: [self installBundlePage]		ifFalse: [self installPackagePage].</body><body package="Store-UI" selector="setPundleNames">setPundleNames		self packages list: (cachedNames at: #packages).	self bundles list: (cachedNames at: #bundles)</body><body package="Store-UI" selector="startGarbageCollector">startGarbageCollector	Store.DbRegistry 		doIfImageAdministrator: 			[[GarbageCollector collectGarbage] fork.			self closeWindow] 		label: (#runGarbageCollection &lt;&lt; #store &gt;&gt; 'run garbage collection') asString</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>aspects</category><body package="Store-UI" selector="bundleVersions">bundleVersions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundleVersions isNil		ifTrue:			[bundleVersions := MultiSelectionInList new]		ifFalse:			[bundleVersions]</body><body package="Store-UI" selector="bundles">bundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundles isNil		ifTrue:			[bundles := SelectionInList new]		ifFalse:			[bundles]</body><body package="Store-UI" selector="packageVersions">packageVersions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageVersions isNil		ifTrue:			[packageVersions := MultiSelectionInList new]		ifFalse:			[packageVersions]</body><body package="Store-UI" selector="packages">packages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packages isNil		ifTrue:			[packages := SelectionInList new]		ifFalse:			[packages]</body><body package="Store-UI" selector="pundleTabs">pundleTabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleTabs isNil		ifTrue:			[pundleTabs := SelectionInList new]		ifFalse:			[pundleTabs]</body><body package="Store-UI" selector="targetedPundles">targetedPundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetedPundles isNil		ifTrue:			[targetedPundles := MultiSelectionInList new]		ifFalse:			[targetedPundles]</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>menu-actions</category><body package="Store-UI" selector="retractAllBundleVersions">retractAllBundleVersions	self bundleVersions list do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI" selector="retractAllPackageVersions">retractAllPackageVersions	self packageVersions list do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI" selector="retractAllPundleVersions">retractAllPundleVersions	self targetedPundles list: OrderedCollection new.	self enableApply</body><body package="Store-UI" selector="retractThisBundleVersion">retractThisBundleVersion	self bundleVersions selections do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI" selector="retractThisPackageVersion">retractThisPackageVersion	self packageVersions selections do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI" selector="retractThisPundleVersion">retractThisPundleVersion	self targetedPundles selections do: 		[:each | self targetedPundles list remove: each ifAbsent: [nil]].	self enableApply</body><body package="Store-UI" selector="selectAllBundleVersions">selectAllBundleVersions	self bundleVersions list do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]].	self enableApply</body><body package="Store-UI" selector="selectAllPackageVersions">selectAllPackageVersions	self packageVersions list do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]].	self enableApply</body><body package="Store-UI" selector="selectBundleVersionForRemoval">selectBundleVersionForRemoval	builder window sensor invalidationSuppressWhile:		[self bundleVersions selections do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]]].	self enableApply</body><body package="Store-UI" selector="selectPackageVersionForRemoval">selectPackageVersionForRemoval	builder window sensor invalidationSuppressWhile:		[self packageVersions selections do: [:each | (self targetedPundles list includes: each) ifFalse: [self targetedPundles list add: each]]].	self enableApply</body><body package="Store-UI" selector="viewContainedItems">viewContainedItems	[DefinitionForListTool forBundleContents: self bundleVersions selections first] withStoreFeedbackOn: self mainWindow.</body><body package="Store-UI" selector="viewEnclosingBundles">viewEnclosingBundles	| bundle enclosingBundles versionAspect |	versionAspect := self pundleTabs selectionIndex = 1		ifTrue: [self bundleVersions]		ifFalse: [self packageVersions].	bundle := versionAspect selections first.	(enclosingBundles := bundle enclosingComponents) isEmpty		ifTrue: [^Dialog warn: #NoEnclosingBundles &lt;&lt; #store &gt;&gt; 'No enclosing bundles.'].	DefinitionForListTool forPackages: enclosingBundles</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>private</category><body package="Store-UI" selector="applyFilter">applyFilter	| bundlesTarget packagesTarget |	bundlesTarget := self bundles selection.	packagesTarget := self packages selection.	self setPundleNames.	filter pundleName ifNotNil:		[self bundles list: (self bundles list asOrderedCollection removeAllSuchThat: [:each | (filter pundleName match: each)]).		self packages list: (self packages list asOrderedCollection removeAllSuchThat: [:each | (filter pundleName match: each)])].	(self packages list includes: packagesTarget)		ifTrue: [self packages selection: packagesTarget].	(self bundles list includes: bundlesTarget)		ifTrue: [self bundles selection: bundlesTarget].</body><body package="Store-UI" selector="compositePundleVersionUsing:nameSize:versionSize:blessingSize:in:">compositePundleVersionUsing: aPundle nameSize: longestName versionSize: longestVersion blessingSize: longestBlessing in: aSequenceView	| iconPart currentStart nameLabel versionLabel blessingLabel timestampLabel mainThing emphasis icon |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	icon := aPundle blessingLevelNumber = -54		ifTrue: [VisualStack with: aPundle toolListIcon with: (ToolbarIconLibrary visualFor: #debugTerminate)]		ifFalse: 			[(self targetedPundles list includes: aPundle)				ifTrue: [VisualStack with: aPundle toolListIcon with: (ToolbarIconLibrary visualFor: #delete)]				ifFalse: [aPundle toolListIcon]].	iconPart icon: icon.	currentStart := 25.	nameLabel := Label with: aPundle name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 12.	emphasis := Array with: #bold with: #color -&gt; ColorValue darkGreen.	versionLabel := Label with: aPundle versionString asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestVersion + 12.	blessingLabel := Label with: (aPundle blessingLevelString asText emphasizeAllWith: emphasis) attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestBlessing + 12.	timestampLabel := Label with: aPundle timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: nameLabel;		add: versionLabel;		add: blessingLabel;		add: timestampLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="filteredBundleVersions">filteredBundleVersions	| allBundles |	allBundles := (StoreBundle allVersionsWithName: bundles selection in: session) asOrderedCollection.	filter versionLike ifNotNil:		[allBundles := allBundles select: [:each | filter versionLike match: each version, ',' , each username]].	filter beforeDate ifNotNil:		[allBundles := allBundles select: [:each | each timestamp asDate &lt;= filter beforeDate]].	filter afterDate ifNotNil:		[allBundles := allBundles select: [:each | each timestamp asDate &gt;= filter afterDate]].	filter blessingGreater ifNotNil:		[allBundles := allBundles select: [:each | each blessingLevelNumber ifNotNil: [:value | value &gt;= filter blessingGreater] ifNil: [true]]].	filter blessingLess ifNotNil:		[allBundles := allBundles select: [:each | each blessingLevelNumber ifNotNil: [:value | value &lt;= filter blessingLess] ifNil: [true]]].	^allBundles</body><body package="Store-UI" selector="filteredPackageVersions">filteredPackageVersions	| allPackages |	allPackages := (StorePackage allVersionsWithName: packages selection in: session) asOrderedCollection.	filter versionLike ifNotNil:		[allPackages := allPackages select: [:each | filter versionLike match: each version, ',' , each username]].	filter beforeDate ifNotNil:		[allPackages := allPackages select: [:each | each timestamp asDate &lt;= filter beforeDate]].	filter afterDate ifNotNil:		[allPackages := allPackages select: [:each | each timestamp asDate &gt;= filter afterDate]].	filter blessingGreater ifNotNil:		[allPackages := allPackages select: [:each | each blessingLevelNumber ifNotNil: [:value | value &gt;= filter blessingGreater] ifNil: [true]]].	filter blessingLess ifNotNil:		[allPackages := allPackages select: [:each | each blessingLevelNumber ifNotNil: [:value | value &lt;= filter blessingLess] ifNil: [true]]].	^allPackages</body><body package="Store-UI" selector="resetBlessingFor:">resetBlessingFor: aStorePundle	| allBlessings newBlessings deniedCommands |	allBlessings := aStorePundle blessings.	newBlessings := allBlessings allButFirst: 1.	deniedCommands := 	session accessor deniedCommands.	[session inUnitOfWorkDo: 		[session register: aStorePundle.		session accessor permitEverything.		session delete: allBlessings first.		aStorePundle blessings: newBlessings.		aStorePundle currentBlessingLevel: newBlessings first blessingLevel]]			ensure: [session accessor deniedCommands: deniedCommands].</body><body package="Store-UI" selector="setBlessingForRemoval:">setBlessingForRemoval: aStorePundle	| specification |	specification := PublishSpecification dbPundle: aStorePundle.	specification publish: true.	specification blessing: -54.	specification publishBlessing.	aStorePundle currentBlessingLevel: -54.</body><body package="Store-UI" selector="setUpPundleList:in:">setUpPundleList: aSymbol in: aBuilder	| widget icon descent |	widget := (aBuilder componentAt: aSymbol) widget.	icon := aSymbol == #BundlesList				ifTrue: [StoreBundle toolListIcon]				ifFalse: [StorePackage toolListIcon].	descent := widget textStyle descent.	widget visualBlock: 			[:view :index |			| iconPart |			iconPart := LabelAndIcon with: (view sequence at: index) offset: 2 @ descent negated.			iconPart icon: icon.			BoundedWrapper on: iconPart].	widget selectedVisualBlock: 			[:view :index |			| iconPart wrapper |			iconPart := LabelAndIcon with: (view sequence at: index) offset: 2 @ descent negated.			iconPart icon: icon.			wrapper := ReversingWrapper on: iconPart.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body><body package="Store-UI" selector="setupBundleListPane">setupBundleListPane	| widget items longestName longestVersion longestBlessing |	widget := (self builder componentAt: #BundleVersions) widget.	items := self bundleVersions list.	items size isZero ifTrue: [^widget invalidate].	longestName := longestVersion := longestBlessing := 0.	longestName := (Label with: items first name asText allBold attributes: widget textStyle) width.	items		do:			[:each | 			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestBlessing := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: longestBlessing].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body><body package="Store-UI" selector="setupPackageListPane">setupPackageListPane	| widget items longestName longestVersion longestBlessing |	widget := (self builder componentAt: #PackageVersions) widget.	items := self packageVersions list.	items size isZero ifTrue: [^widget invalidate].	longestName := longestVersion := longestBlessing := 0.	longestName := (Label with: items first name asText allBold attributes: widget textStyle) width.	items		do:			[:each | 			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestBlessing := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: longestBlessing].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body><body package="Store-UI" selector="setupTargetedPundlesPane">setupTargetedPundlesPane	| widget items longestName longestVersion longestBlessing |	widget := (self builder componentAt: #TargetedPundles) widget.	items := self targetedPundles list.	items size isZero ifTrue: [^widget invalidate].	longestName := longestVersion := longestBlessing := 0.	items		do:			[:each | 			longestName := (Label with: each name asText allBold attributes: widget textStyle) width max: longestName.			longestVersion := (Label with: each versionString asText allBold attributes: widget textStyle) width max: longestVersion.			longestBlessing := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: longestBlessing].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositePundleVersionUsing: (view sequence at: index)				nameSize: longestName				versionSize: longestVersion				blessingSize: longestBlessing				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper].	widget invalidate</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>interface opening</category><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder		self pundleTabs selectionIndexHolder onChangeSend: #pageChanged to: self.	self bundles selectionIndexHolder onChangeSend: #bundleSelectionChanged to: self.	self packages selectionIndexHolder onChangeSend: #packageSelectionChanged to: self.	aBuilder = builder		ifTrue:			[cachedNames at: #packages put: (StorePackage allNamesIn: session) asSortedCollection asOrderedCollection.			cachedNames at: #bundles put: (StoreBundle allNamesIn: session) asSortedCollection asOrderedCollection.			self setPundleNames.			self refillTargedPundles].	aBuilder ~= builder		ifTrue:			[(aBuilder componentAt: #BundleVersions)				ifNotNil:					[:value | 					builder namedComponents at: #BundleVersions put: value.					builder namedComponents at: #BundlesList put: value.					self setUpPundleList: #BundlesList in: aBuilder].			(aBuilder componentAt: #PackageVersions)				ifNotNil:					[:value | 					builder namedComponents at: #PackageVersions put: value.					builder namedComponents at: #PackagesList put: value.					self setUpPundleList: #PackagesList in: aBuilder]]</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self pundleTabs selectionIndexHolder value: 1.	self setupTargetedPundlesPane</body><body package="Store-UI" selector="refillTargedPundles">refillTargedPundles		previouslyMarkedPundles addAll: (StoreBundle allVersionsWithBlessingLevel: -54 in: session).	previouslyMarkedPundles addAll: (StorePackage allVersionsWithBlessingLevel: -54 in: session).	self targetedPundles list removeAll.	self targetedPundles list addAll: previouslyMarkedPundles</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>menu-enablement</category><body package="Store-UI" selector="atLeastOneBundleVersionIsSelected">atLeastOneBundleVersionIsSelected	^self bundleVersions selectionIndexes size &gt; 0</body><body package="Store-UI" selector="atLeastOnePackageVersionIsSelected">atLeastOnePackageVersionIsSelected	^self packageVersions selectionIndexes size &gt; 0</body><body package="Store-UI" selector="atLeastOnePundleVersionIsSelected">atLeastOnePundleVersionIsSelected	^self targetedPundles selectionIndexes size &gt; 0</body><body package="Store-UI" selector="bundleIsSelected">bundleIsSelected	^self bundles selectionIndex ~= 0</body><body package="Store-UI" selector="oneBundleVersionIsSelected">oneBundleVersionIsSelected	^self bundleVersions selectionIndexes size = 1</body><body package="Store-UI" selector="onePackageVersionIsSelected">onePackageVersionIsSelected	^self packageVersions selectionIndexes size = 1</body><body package="Store-UI" selector="packageIsSelected">packageIsSelected	^self packages selectionIndex ~= 0</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	session := StoreLoginFactory currentStoreSession.	previouslyMarkedPundles := OrderedCollection new.	filter := DeletionToolFilter new.	cachedNames := Dictionary new.</body></methods><methods><class-id>Store.CreateParcelDirectoryConfirmation</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		^Dialog confirm: (#CreateDirectory1s &lt;&lt; #store &gt;&gt; 'Create directory &lt;1s&gt;?' expandMacrosWith: messageText)</body></methods><methods><class-id>Store.CreateParcelDirectoryConfirmation class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="from:">from: aStoreClassDefinitionInPackage	super from: aStoreClassDefinitionInPackage.	longName := aStoreClassDefinitionInPackage longName.	superclassName := aStoreClassDefinitionInPackage superclassName.</body><body package="Atomic Compiling and Loading" selector="from:in:">from: aStoreClass in: aStorePackage	super from: aStoreClass in: aStorePackage.	longName := aStoreClass longName.	superclassName := aStoreClass superclassName.</body><body package="Atomic Compiling and Loading" selector="longName">longName	^longName</body><body package="Atomic Compiling and Loading" selector="superclassName">superclassName	^superclassName</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	aStream nextPutAll: 'aShadowedClass('.	aStream nextPutAll: self longName.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.ShadowedClassObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading" selector="compileWith:">compileWith: anAtomicAnalysisLoader	[[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDefinedRecord: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader unloadableDefinitions add: (exception definitionRecord: self).			exception resume]]				on: RedefinitionNotification				do: 					[:notification |					anAtomicAnalysisLoader collectRedefinedClasses: notification override.					anAtomicAnalysisLoader overrides add: notification.					override := true.					notification resume]]						on: VariableConfirmation 						do: [:exception | exception resume: false]</body><body package="Atomic Compiling and Loading" selector="installWith:">installWith: anAtomicAnalysisLoader	[[anAtomicAnalysisLoader installClass: self]		on: RedefinitionNotification		do: 			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			anAtomicAnalysisLoader collectRedefinedClasses: notification override.			(currentPackage notNil and: [self packageModel name = currentPackage name or: [currentPackage name = Registry nullPackageName]]) 				ifFalse: 					[self fixAndInstallNotification: notification.					anAtomicAnalysisLoader overrides add: notification].			notification resume]]				on: VariableConfirmation 				do: [:exception | exception resume: false]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableNavigatorPart</class-id> <category>private-selectors</category><body package="StoreForGlorpBrowserUI" selector="allSharedVariableDefinitionsFor:in:">allSharedVariableDefinitionsFor: aProtocol in: class 	| sharedVariables |	sharedVariables := OrderedCollection new.	self inheritedClassesOf: class do: 		[:each | 		sharedVariables addAll: ((self environment sharedVariablesFor: aProtocol in: each) 			collect: [:eachVariable | StoreRBInitializerDefinition nameSpace: each key: eachVariable])].	^sharedVariables</body><body package="StoreForGlorpBrowserUI" selector="allSharedVariablesIn:">allSharedVariablesIn: aNavigatorState		| sharedVariables nameSpaces nameSpace |	nameSpaces := aNavigatorState classesAndNameSpaces.	nameSpaces size ~= 1 ifTrue: [^#()].	nameSpace := nameSpaces asArray first.	sharedVariables := self environment sharedVariablesForClass: nameSpace.	^sharedVariables collect: [:each | StoreRBInitializerDefinition nameSpace: nameSpace key: each]</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="blessing">blessing	^blessing</body><body package="Store-IMG-Configurations" selector="blessing:">blessing: anInteger	blessing := anInteger</body><body package="Store-IMG-Configurations" selector="comment">comment	^comment</body><body package="Store-IMG-Configurations" selector="comment:">comment: aString	comment := aString</body><body package="Store-IMG-Configurations" selector="description">description	^description</body><body package="Store-IMG-Configurations" selector="description:">description: aString	description := aString</body><body package="Store-IMG-Configurations" selector="level">level	^level</body><body package="Store-IMG-Configurations" selector="level:">level: anInteger	level := anInteger</body><body package="Store-IMG-Configurations" selector="modified">modified	^modified</body><body package="Store-IMG-Configurations" selector="modified:">modified: aBoolean	modified := aBoolean</body><body package="Store-IMG-Configurations" selector="parentVersion">parentVersion	^parentVersion</body><body package="Store-IMG-Configurations" selector="parentVersion:">parentVersion: aString	parentVersion := aString</body><body package="Store-IMG-Configurations" selector="publish">publish	^publish</body><body package="Store-IMG-Configurations" selector="publish:">publish: aBoolean	publish := aBoolean</body><body package="Store-IMG-Configurations" selector="pundle">pundle	^object</body><body package="Store-IMG-Configurations" selector="pundle:">pundle: aPundleModel		pundleModel := object := aPundleModel.	modified := object hasBeenModified or: [object hasTrace not].	publish := modified.	parentVersion := aPundleModel extractVersionFromVersionDisplayString.	version := parentVersion isEmpty		ifTrue: [Policies versionPolicy initialVersionForPundle: aPundleModel]		ifFalse: [Policies versionPolicy nextVersion: parentVersion forPundle: aPundleModel]</body><body package="Store-IMG-Configurations" selector="pundleModel">pundleModel	^pundleModel</body><body package="Store-IMG-Configurations" selector="version">version	^version</body><body package="Store-IMG-Configurations" selector="version:">version: aString	version := aString</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>initialize-release</category><body package="Store-IMG-Configurations" selector="initialize">initialize	comment := ''.	version := ''.	description := nil.	level := 0.	publish := false.	modified := false.	blessing := Policies blessingPolicy defaultBlessing.</body></methods><methods><class-id>Store.PublishFileSpecification</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="file">file	^object</body><body package="Store-IMG-Configurations" selector="file:">file: aFileName	object := aFileName.</body><body package="Store-IMG-Configurations" selector="name">name	^object name</body><body package="Store-IMG-Configurations" selector="parentVersion">parentVersion	^''</body><body package="Store-IMG-Configurations" selector="publishFile">publishFile	^self publish</body><body package="Store-IMG-Configurations" selector="publishFile:">publishFile: aBoolean	self publish: aBoolean</body></methods><methods><class-id>Store.PublishFileSpecification class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="new">new	^self basicNew initialize.</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>aspects</category><body package="Store-UI" selector="binarySaveChanged">binarySaveChanged	"No Selections in a package publish"</body><body package="Store-UI" selector="blessingLevel">blessingLevel	blessingLevel == nil		ifTrue: [ blessingLevel := Policies blessingPolicy defaultBlessing asValue ].	^blessingLevel</body><body package="Store-UI" selector="versionString">versionString		versionString ifNil: 		[versionString := (Policies versionPolicy nextVersion: package parentVersionString forPundle: package) asValue].	^versionString</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>accessing</category><body package="Store-UI" selector="package">package	^package</body><body package="Store-UI" selector="package:">package: aPackage	package := aPackage.	pundleModel := aPackage.</body><body package="Store-UI" selector="pundle">pundle	^package</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>private</category><body package="Store-UI" selector="newGlobalState">newGlobalState		"Update the global (belonging to the outer bundle) state."	^PublishSpecification new		binarySave: self binarySave value;		parcelSave: self parcelSave value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelPadded: self parcelPadded value;		parcelVersionString: self parcelVersionString value;		yourself.</body><body package="Store-UI" selector="newItemSelection">newItemSelection	"No Selections in a package publish"</body><body package="Store-UI" selector="newSelection">newSelection	"No Selections in a package publish"</body><body package="Store-UI" selector="publishSpecificationFrom:">publishSpecificationFrom: aPackageModel	"Create a PublishSpecifcation from the passed in package model"	| publishSpecification |	publishSpecification := PublishSpecification pundle: aPackageModel.	publishSpecification		binarySave: self binarySave value;		parcelSave: self parcelSave value;		comment: self blessingComment value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelVersionString: self parcelVersionString value;		description: aPackageModel comment;		blessing: self blessingLevel value;		version: self versionString value;		publish: true;		parcelPadded: self parcelPadded value.	^publishSpecification</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"It's possible there have been changes to the package since we opened the dialog, so regenerate our model before applying the spec."	| navigatorClass publishSpecification |	self validateParcelOptions ifFalse: [^self].	publishSpecification := self publishSpecificationFrom: package.	(self canPublish: package atBlessingLevel: self blessingLevel value) ifFalse: [^self].	StoreProgressOverlay 		subsume: builder window		while: [publishSpecification publishPundle].	navigatorClass := #{Refactory.Browser.BrowserNavigator} valueOrDo: [^self].	navigatorClass updatePackageListsInOpenWindows.	self closeAndUnschedule</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="localPostOpenWith:">localPostOpenWith: aBuilder	super localPostOpenWith: aBuilder.	package isPackage ifTrue: [self binarySave value: (package tracePackage ifNil: [false] ifNotNil: [:value | value parcelID notNil])].</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="publishPackage:">publishPackage: aPackage	( self validateForPublishing: ( PublishSpecificationList with: aPackage ) )		ifFalse: [ ^self ].	^self new		package: aPackage;		open;		yourself</body><body package="Store-UI" selector="validateForPublishing:">validateForPublishing: aList	^super validateForPublishing: (aList collect: [:each | each storeModel]).</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	| complexList |	complexList := 		OrderedCollection new			add: 'Version Name and Blessing' -&gt; #(#mainSpec #mainHelp);			add: 'Parcel Options' -&gt; #(#parcelSpec #parcelHelp);			asArray.	runtimeTabLabels := Array new: 1.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new: 1.</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>accessing</category><body package="Store-UI" selector="fillInFor:">fillInFor: aStoreBundle	(Gathering for: aStoreBundle) started.	self itemsInList list: (TreeModel 		on: (aStoreBundle)		displayRoot: true		childrenWith: [:each | each containedItems]).	self itemsInList tree expandFully: 1.	(Gathering for: aStoreBundle) finished.</body><body package="Store-UI" selector="listTitle">listTitle	^self title.</body><body package="Store-UI" selector="onlyOneItemSelected">onlyOneItemSelected	^self itemsInList selection notNil</body><body package="Store-UI" selector="selections">selections	| selected |	^(selected := self itemsInList selection) isNil		ifTrue: [#()] 		ifFalse: [OrderedCollection with: selected]</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>actions</category><body package="Store-UI" selector="browseSelectedVersion">browseSelectedVersion	| package |	package := self itemsInList selection.	(Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: (Store.Glorp.StoreForGlorpBrowserEnvironment on: package)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-UI" selector="compareSelectionWith">compareSelectionWith	| pundle target |	pundle := self itemsInList selection.	target := pundle class selectStoreVersionOf: pundle name in: pundle session.	target ifNotNil: [ComparePackages comparePackage: pundle toPackage: target]</body><body package="Store-UI" selector="enclosingBundles">enclosingBundles	| package enclosingBundles |	package := self itemsInList selection.	(enclosingBundles := package enclosingComponents) isEmpty		ifTrue: [^Dialog warn: #NoEnclosingBundles &lt;&lt; #store &gt;&gt; 'No enclosing bundles.'].	DefinitionForListTool forPackages: enclosingBundles</body><body package="Store-UI" selector="fileOutSelectedVersion">fileOutSelectedVersion	| package fileName fileManager |	package := self itemsInList selection.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: package name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			package fileOutOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: package) finished].</body><body package="Store-UI" selector="graphSelectedVersion">graphSelectedVersion	| package |	package := self itemsInList selection.	package isImageModel ifFalse: [package := StorePackage cachedItemFor: package].	VersionGraph browseVersionsOfPundle: package.</body><body package="Store-UI" selector="inspectSelected">inspectSelected	self itemsInList selection inspect</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated	| updateText item |	updateText := TextStream on: String new.	(item := self itemsInList selection) notNil		ifTrue: 			[updateText emphasis: #bold.			updateText nextPutAll: item name.			updateText space.			updateText nextPutAll: item versionString.			updateText cr.			updateText cr.			updateText emphasis: #none.			item blessings do:				[:eachBlessing | eachBlessing blessingLevel = -1 ifFalse: [eachBlessing printWideOn: updateText]]	.			updateText cr.			updateText emphasis: (Array with: #color-&gt; ColorValue navy).			updateText nextPutAll: item comment.			updateText cr].		self itemsInList selection			ifNil: [self updateStatusPaneWith: '']			ifNotNil: [:value | self updateStatusUsing: value package].	self updateTextPaneWith: updateText contents</body><body package="Store-UI" selector="setBlessingLevel">setBlessingLevel	| package |	package := self itemsInList selection.	BlessingDialog setBlessingFor: package. 	(self builder componentAt: #SelectionList) widget invalidate.	self selectionsUpdated</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>aspects</category><body package="Store-UI" selector="itemsInList">itemsInList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^itemsInList isNil		ifTrue:			[itemsInList := SelectionInTree new]		ifFalse:			[itemsInList]</body></methods><methods><class-id>Store.Glorp.BundleTreePane</class-id> <category>interface opening</category><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: aBuilder		| widget |	widget := (aBuilder componentAt: #SelectionList) widget.	widget useImage: #toolListIcon</body></methods><methods><class-id>ShadowNameSpaceBuilder</class-id> <category>creation</category><body package="Atomic Compiling and Loading" selector="createShadowRoot">createShadowRoot	"Create and answer an instance of the shadowed Root, populated with the existing NameSpace heirarachy.	First we carefully populate the Root namespace for any other than itself and Smalltalk rooted namspaces."		| smalltalk visited |	root := self createShadowOf: Root.	self createVariableBindingFor: root environment: root.	root environment: nil.	smalltalk := self setupShadowSmalltalk.	visited := OrderedCollection new.	(Root nameSpaces reject: [:each | each = Root or: [each = Smalltalk]]) do: 		[:eachRootedNamespace | 		self populateShadow: eachRootedNamespace parent: root visited: visited].	Smalltalk nameSpaces do: 		[:eachRegularNamespace | 		self populateShadow: eachRegularNamespace parent: smalltalk visited: visited].	^root</body></methods><methods><class-id>ShadowNameSpaceBuilder</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="createShadowOf:">createShadowOf: aNameSpace 	^NameSpace new 			name: aNameSpace name asSymbol;			imports: aNameSpace importString;			yourself</body><body package="Atomic Compiling and Loading" selector="createVariableBindingFor:environment:">createVariableBindingFor: nameSpaceName environment: parentNameSpace 	| vb |	vb := VariableBinding key: nameSpaceName name asSymbol value: nameSpaceName.	vb setReservedFlag: true.	parentNameSpace simpleAddBinding: vb.	nameSpaceName environment: parentNameSpace.	^vb</body><body package="Atomic Compiling and Loading" selector="populateShadow:parent:visited:">populateShadow: nameSpace parent: parent visited: visited 	| shadowSpace variableBinding |	( visited includes: nameSpace ) 		ifTrue: [ ^self ].	visited addLast: nameSpace.	shadowSpace := self createShadowOf: nameSpace.	variableBinding := self createVariableBindingFor: shadowSpace environment: parent.	"We need to ensure that the binding is actually marked as a 	 NameSpace binding."	variableBinding forNameSpace.	nameSpace nameSpaces do: 		[:localNameSpace | 		self 			populateShadow: localNameSpace			parent: shadowSpace			visited: visited		]</body><body package="Atomic Compiling and Loading" selector="setupShadowSmalltalk">setupShadowSmalltalk	"Create and return the shadow of Smalltalk as a special 	 case, ensuring that it is linked to Root properly."	| smalltalk variableBinding |	smalltalk := self createShadowOf: Smalltalk.	variableBinding := self createVariableBindingFor: smalltalk environment: root.	variableBinding forNameSpace.	self createVariableBindingFor: smalltalk environment: smalltalk.	self createVariableBindingFor: root environment: smalltalk.	root environment: nil.	smalltalk environment: root.	^smalltalk</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI" selector="at:ifAbsent:">at: className ifAbsent: aBlock	^environment at: className ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="classForName:">classForName: aString	^self classForName: aString ifAbsent: [nil]</body><body package="StoreForGlorpBrowserUI" selector="classForName:ifAbsent:">classForName: aString ifAbsent: aBlock	^environment classForName: aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="classesDo:">classesDo: aBlock 	classSelectors keysDo: 		[:each | 		aBlock value: (environment classForName: each)].	metaClassSelectors keysDo: 		[:each | 		aBlock value: (environment classForName: each) storeMetaClass]</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="methodDefinitions">methodDefinitions	| definitions |	definitions := OrderedCollection new.	self classesAndSelectorsDo: 		[:class :selector | 		definitions add: (StoreMethodDefinition class: class selector: selector)].	self sharedVariableReferencesDo: 		[:each | 		definitions add: (InitializerDefinition nameSpace: each environment key: each name)].	^definitions</body><body package="StoreForGlorpBrowserUI" selector="methodNamed:inClass:">methodNamed: aSelector inClass: aClass	^environment methodNamed: aSelector inClass: aClass</body><body package="StoreForGlorpBrowserUI" selector="navigatorClass">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI" selector="openEditor">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI" selector="pundleNamed:isPackage:">pundleNamed: aString isPackage: isPackage	^environment pundleNamed: aString isPackage: isPackage</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="includesSelector:in:">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass)</body></methods><methods><class-id>Store.Glorp.StoreSelectorEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI" selector="implementorsMatching:in:">implementorsMatching: aString in: anEnvironment 	^self implementorsOf: aString in: anEnvironment</body><body package="StoreForGlorpBrowserUI" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector asSymbol.	anEnvironment classesDo: 		[:class | 		| storeMetaClass |		((class includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: class]) 			ifTrue: [classDict at: class fullRootName put: selectors copy].		storeMetaClass := class isImageObject ifTrue: [class] ifFalse: [class storeMetaClass].		((storeMetaClass includesSelector: aSelector) and: [anEnvironment includesSelector: aSelector in: storeMetaClass]) 			ifTrue: [metaDict at: storeMetaClass fullRootName put: selectors copy]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body><body package="StoreForGlorpBrowserUI" selector="matches:in:">matches: aString in: anEnvironment		| newEnvironment |	newEnvironment := (self onEnvironment: anEnvironment)		label: (#Matching1s &lt;&lt; #browser &gt;&gt; 'Matching: &lt;1s&gt;' expandMacrosWith: aString);		searchStrings: (Array with: aString);		yourself.	anEnvironment		classesAndSelectorsDo:			[:eachClass :eachSelector | 			| method |			method := eachClass compiledMethodAt: eachSelector.			(aString match: method source) ifTrue: [newEnvironment addClass: eachClass selector: eachSelector]].	^newEnvironment</body><body package="StoreForGlorpBrowserUI" selector="onMethods:in:">onMethods: aMethodDefinitionCollection in: anEnvironment	"We have to perserve the extra text in the original method definitions, so we defer to some specialized subclass.	Also, being a Store Browser object, we need to pass along the Store environment"	| result |	result := StoreMethodDefinitionEnvironment onMethods: aMethodDefinitionCollection.	result environment: anEnvironment.	^result</body></methods><methods><class-id>Store.Loading</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="actionText">actionText	^(#Loading &lt;&lt; #store &gt;&gt; 'Loading') asString</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>testing</category><body package="Store-Database Model" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreNameSpace">asStoreNameSpace	^self</body><body package="Store-Database Model" selector="asStoreObjectInPackage:">asStoreObjectInPackage: aPackage	| session result |	session := aPackage isNil		ifTrue: [self error: (#ParameterToAsStoreObjectIsNil &lt;&lt; #store &gt;&gt; 'Parameter to #asStoreObjectInPackage: is nil')]		ifFalse: [aPackage session].	(aPackage namespaces		detect: [:each | each definition = self]		ifNone: [nil]) ifNotNil: [:value | ^value].	result := session 		readOneOf: Store.Glorp.StoreNamespaceInPackage 		where: [:each | each package primaryKey = aPackage primaryKey AND: (each definition primaryKey  = self primaryKey)].	^result</body><body package="Store-Database Model" selector="correspondingImageNamespace">correspondingImageNamespace	"Return the image namespace that corresponds to our name. Note that they may not have the same information"	^(Dialect smalltalkAt: self longName ifAbsent: [nil]).</body><body package="Store-Database Model" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version."	| theNamespace |	theNamespace := self correspondingImageNamespace.	theNamespace isNil ifTrue: [^false].	^self = theNamespace asStoreNameSpace.</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>accessing</category><body package="Store-Database Model" selector="actual">actual	^self correspondingImageNamespace</body><body package="StoreForGlorpVWUI" selector="bindingsDo:">bindingsDo: ignore	^self</body><body package="StoreForGlorpVWUI" selector="organization">organization	^NameSpaceOrganizer new environment: self</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := self definition.	insertPoint := definitionString indexOfSubCollection: 'defineNameSpace:' startingAt: 1.	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Store-Database Model" selector="xmlDefinition">xmlDefinition	| string |	string := self definitionString.	^string isEmpty		ifTrue: [string]		ifFalse: [self convertToXML: string]</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>private</category><body package="Store-Database Model" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineNameSpace:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'imports' value: (data at: 'imports:') value.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>filling out</category><body package="Store-Database Model" selector="fileOutObjectType">fileOutObjectType	^#nameSpace</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	[[binding := Compiler evaluate: self definitionString]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: UnhandledException			do:				[:exception | 				Store.UnloadableDefinitionError signalWith: self.				^nil].</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	[[binding := Compiler evaluate: self definitionString]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: UnhandledException			do:				[:exception | 				Store.UnloadableDefinitionError signalWith: self.				^nil].	self comment notEmpty ifTrue: [binding comment: self comment].</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon		^BehaviorIcons Namespace</body><body package="StoreForGlorpVWUI" selector="unambiguousName">unambiguousName	^self longName</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>comparing</category><body package="Store-Database Model" selector="equalsSignatureIn:">equalsSignatureIn: aStoreDefinitionObject	self environmentName = aStoreDefinitionObject environmentName ifFalse: [^false].	self name = aStoreDefinitionObject name ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="signatureHash">signatureHash	^self environmentName hash bitXor: self name hash</body></methods><methods><class-id>Store.Glorp.StoreNameSpace</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeNamespace: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedNamespaceObject</body></methods><methods><class-id>Store.Privileges class</class-id> <category>query</category><body package="Store-Ownership" selector="pundlesUser:privilege:">pundlesUser: aUser privilege: aSymbol 	"Answer a collection of pundles for which a user has given privilege. 	Do not check groups that the user belongs to."	self halt.	^self privilegeTable pundlesUser: aUser privilege: aSymbol.</body><body package="Store-Ownership" selector="usersWithPrivilege:pundle:">usersWithPrivilege: aSymbol pundle: aPundle	self halt.	^self privilegeTable usersWithPrivilege: aSymbol pundle: aPundle</body></methods><methods><class-id>Store.Privileges class</class-id> <category>private</category><body package="Store-Ownership" selector="privilegeTable">privilegeTable	self halt.	^DBPundlePrivileges</body></methods><methods><class-id>Store.Privileges class</class-id> <category>private-db installation</category><body package="Store-Ownership" selector="alterTablesPctincrease">alterTablesPctincrease	"Fix for databases created with 5i.2. Alter STORAGE PSTINCREASE from 0 to 1"	( Array with: DBUserGroup with: DBPundlePrivileges ) 		do: [:aClass | aClass alterTablePctincrease]</body><body package="Store-Ownership" selector="dropTables">dropTables	"self dropTables"	(Array with: DBUserGroup with: DBPundlePrivileges) 		do: [:aClass | aClass dropTableForClass].	Transcript		cr;		show: (#DoneBang &lt;&lt; #store &gt;&gt; 'Done!') asString</body><body package="Store-Ownership" selector="installUserManagement">installUserManagement	"Create the initial user management entries"	self installUserManagementPolicy.</body><body package="Store-Ownership" selector="installUserManagementTables">installUserManagementTables	"Now do nothing"</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^false</body><body package="Store-Merge Management" selector="isForProperties">isForProperties	^true</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>displaying</category><body package="Store-Merge Management" selector="typeIcon">typeIcon	^GeneralIcons gear</body></methods><methods><class-id>Store.Glorp.PropertyResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copy.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [newResolutions removeKey: key].		value applied ifTrue: [newResolutions removeKey: key]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Relinking</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="actionText">actionText	^(#Relinking &lt;&lt; #store &gt;&gt; 'Relinking') asString</body></methods><methods><class-id>Store.PkgClassesAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="blobData">blobData	^blobData</body><body package="Store-DB-Records" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.PkgClassesAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="resetSession">resetSession	ClassesWithSourcesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: ClassesWithSourcesSession].		ClassesWithSourcesSession := nil]</body><body package="Store-DB-Records" selector="sourcesSession">sourcesSession	"ClassesWithSourcesSession := nil"	( self isSessionValid: ClassesWithSourcesSession )		ifFalse: 	[ ClassesWithSourcesSession := self createSourcesSession ].	^ClassesWithSourcesSession</body></methods><methods><class-id>Store.PkgClassesAndSourcesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="subCollectionClasses">subCollectionClasses	^Array with: self subCollectionClass.</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>accessing</category><body package="Store-Database Model" selector="privilege">privilege	^privilege</body><body package="Store-Database Model" selector="privilege:">privilege: aString	privilege := aString</body><body package="Store-Database Model" selector="pundleName">pundleName	^pundleName</body><body package="Store-Database Model" selector="pundleName:">pundleName: aString	pundleName := aString</body><body package="Store-Database Model" selector="pundleType">pundleType	^pundleType</body><body package="Store-Database Model" selector="pundleType:">pundleType: aString	pundleType := aString</body><body package="Store-Database Model" selector="rights">rights		^#(#owner #read #publish)</body><body package="Store-Database Model" selector="session">session	^session</body><body package="Store-Database Model" selector="session:">session: aGlorpSession	session := aGlorpSession</body><body package="Store-Database Model" selector="setPundle:">setPundle: aPundle	self pundleName: aPundle name.	self pundleType: aPundle typeStringForBlessing</body><body package="Store-Database Model" selector="setUser:">setUser: aStoreUser	userName := aStoreUser userName.	userType := aStoreUser type.</body><body package="Store-Database Model" selector="userName">userName	^userName</body><body package="Store-Database Model" selector="userName:">userName: aString	userName := aString</body><body package="Store-Database Model" selector="userType">userType	^userType</body><body package="Store-Database Model" selector="userType:">userType: aString	userType := aString</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>comparing</category><body package="Store-Database Model" selector="&lt;=">&lt;= aStoreAccessPrivilege		self class == aStoreAccessPrivilege class ifFalse: 		[^false].	self userName = aStoreAccessPrivilege userName ifFalse: 		[^self userName &lt;= aStoreAccessPrivilege userName].	self privilege = aStoreAccessPrivilege privilege ifFalse: 		[^self privilege &lt;= aStoreAccessPrivilege privilege].	^self pundleName &lt;= pundleName</body><body package="Store-Database Model" selector="=">= aStoreAccessPrivilege		aStoreAccessPrivilege class == self class ifFalse: [^false].	^userType = aStoreAccessPrivilege userType and: 		[userName = aStoreAccessPrivilege userName and: 		[pundleName = aStoreAccessPrivilege pundleName and:		[pundleType = aStoreAccessPrivilege pundleType and:		[privilege = aStoreAccessPrivilege privilege]]]]</body><body package="Store-Database Model" selector="hash">hash		^(userType hash bitXor: pundleType hash) bitXor: ((userName hash bitXor: pundleName hash) bitXor: privilege hash)</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>testing</category><body package="Store-Database Model" selector="isBundle">isBundle	^pundleType = 'B'</body><body package="Store-Database Model" selector="isGroup">isGroup	^pundleType = 'G'</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege</class-id> <category>displaying</category><body package="Store-Database Model" selector="fullDescription">fullDescription		| stream |	stream := (String new: 30) writeStream.	stream nextPutAll: userName.	self isGroup ifTrue: [stream nextPutAll: '(G)'].	stream nextPutAll: (privilege = 'owner'		ifTrue: [' owns ']		ifFalse:			[privilege = 'read' 				ifTrue: [' can read '] 				ifFalse: 					[privilege = 'publish' 						ifTrue: [' can publlish '] 					ifFalse: [' *' , privilege , '* ']]]) , pundleName.	self isBundle ifTrue: [stream nextPutAll: '(B)'].	^stream contents</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>query</category><body package="Store-Database Model" selector="allDistinctUserGroups">allDistinctUserGroups	^self allDistinctUserGroupsIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allDistinctUserGroupsIn:">allDistinctUserGroupsIn: aSessionOrNil	| session groupNames userNames result |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	userNames := self allUserNamesIn: session.	groupNames := self allGroupNamesIn: session.	result := OrderedCollection new: userNames size + groupNames size.	result addAll: (userNames collect:		[:each | 		(StoreUserGroup new)			userName: each;			session: session;			type: 'U']).	result addAll: (groupNames collect:		[:each | 		(StoreUserGroup new)			userName: each;			session: session;			type: 'G']).	^result</body><body package="Store-Database Model" selector="allGroupNames">allGroupNames	^self allGroupNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allGroupNamesIn:">allGroupNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each userType = 'G'].	query retrieve: [:each | each userName distinct].	query orderBy: #userName.	^session execute: query</body><body package="Store-Database Model" selector="allPrivilegesForPundle:">allPrivilegesForPundle: aStorePundleOrPundleModel	^self allPrivilegesForPundle: aStorePundleOrPundleModel in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allPrivilegesForPundle:in:">allPrivilegesForPundle: aStorePundleOrPundleModel in: aSessionOrNil	| session query targetPundleType |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	targetPundleType := aStorePundleOrPundleModel typeStringForBlessing.	query := Query readManyOf: self where:		[:each | each pundleName = aStorePundleOrPundleModel name AND: (each pundleType = targetPundleType)].	^session execute: query</body><body package="Store-Database Model" selector="allPrivilegesForUser:">allPrivilegesForUser: aStoreUserGroup	| session query |	session := StoreLoginFactory currentStoreSession.	query := Query readManyOf: self where:		[:each | each userName = aStoreUserGroup userName AND: (each userType = aStoreUserGroup type)].	^session execute: query</body><body package="Store-Database Model" selector="allPrivilegesForUser:pundle:">allPrivilegesForUser: aStoreUserGroup pundle: aStorePundleOrPundleModel	| session query targetPundleType |	session := StoreLoginFactory currentStoreSession.	targetPundleType := aStorePundleOrPundleModel typeStringForBlessing.	query := Query readManyOf: self where:		[:each | 		each userName = aStoreUserGroup userName AND: 			(each userType = aStoreUserGroup type) AND:			(each pundleName = aStorePundleOrPundleModel name) AND:			(each pundleType = targetPundleType)].	^session execute: query</body><body package="Store-Database Model" selector="allUserNames">allUserNames	^self allUserNamesIn: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="allUserNamesIn:">allUserNamesIn: aSessionOrNil	"Sorted!"	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: [:each | each userType = 'U'].	query retrieve: [:each | each userName distinct].	query orderBy: #userName.	^session execute: query</body><body package="Store-Database Model" selector="ownerOfPundle:">ownerOfPundle: aPundle 	| result |	aPundle ifNil: [^nil].	result := self 		usersWithPrivilege: #owner		pundleName: aPundle name		pundleType: aPundle typeStringForBlessing		in: aPundle session.	result size == 0 ifTrue: [^nil].	result size &gt; 1 ifTrue: 		[Dialog warn: ((#_1sHasMoreThanOneOwner &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has more than one owner.') expandMacrosWith: aPundle name)].	^result first</body><body package="Store-Database Model" selector="privilegeForUser:pundle:">privilegeForUser: aStoreUserGroup pundle: aStorePundleOrPundleModel	| session query targetPundleType |	session := StoreLoginFactory currentStoreSession.	targetPundleType := aStorePundleOrPundleModel typeStringForBlessing.	query := Query readOneOf: self where:		[:each | 		each userName = aStoreUserGroup userName AND: 			(each userType = aStoreUserGroup type) AND:			(each pundleName = aStorePundleOrPundleModel name) AND:			(each pundleType = targetPundleType)].	^session execute: query</body><body package="Store-Database Model" selector="pundlesUser:privilege:">pundlesUser: aStoreUserGroup privilege: aSymbol	"Answer a collection of pundles for which a user has given privilege."	^self pundlesUserName: aStoreUserGroup userName userType: aStoreUserGroup type privilege: aSymbol.</body><body package="Store-Database Model" selector="pundlesUserName:userType:privilege:">pundlesUserName: aUserName userType: aString privilege: aSymbol	^self pundlesUserName: aUserName userType: aString privilege: aSymbol in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="pundlesUserName:userType:privilege:in:">pundlesUserName: aUserName userType: aString privilege: aSymbol in: aSessionOrNil	| session query |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: 		[:each |		each privilege = aSymbol AND: (each userName = aUserName) AND: (each userType = aString)].	^session execute: query</body><body package="Store-Database Model" selector="user:hasPrivilege:to:">user: aStoreUser hasPrivilege: aSymbol to: aPundle	| users groups |	users := self usersWithPrivilege: aSymbol pundle: aPundle in: aStoreUser session.	(users includes: aStoreUser) ifTrue: [^true].	groups := StoreUserGroup groupsForUser: aStoreUser.	^groups includes: aStoreUser</body><body package="Store-Database Model" selector="usersWithPrivilege:pundle:in:">usersWithPrivilege: aSymbol pundle: aPundle in: aSessionOrNil	^self usersWithPrivilege: aSymbol pundleName: aPundle name pundleType: aPundle typeStringForBlessing in: aSessionOrNil</body><body package="Store-Database Model" selector="usersWithPrivilege:pundleName:pundleType:">usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aString	^self usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aString in: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="usersWithPrivilege:pundleName:pundleType:in:">usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aString in: aSessionOrNil	| session query results |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	query := Query readManyOf: self where: 		[:each |		each privilege = aSymbol AND: (each pundleName = aPundleName) AND: (each pundleType = aString)].	query alsoFetch: #userName.	query alsoFetch: #userType.	results := session execute: query.	^results collect:		[:eachPair |		(StoreUserGroup new)			userName: eachPair userName;			session: session;			type: eachPair userType;			yourself]</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>installation</category><body package="Store-Database Model" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in."	^Store.Policies tableSpacePolicy userAndOwnershipTableSpace</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="forPundle:user:privilege:">forPundle: aStorePundle user: aStoreUserGroup privilege: aSymbol	| instance |	instance := self new.	instance setPundle: aStorePundle.	instance setUser: aStoreUserGroup.	instance privilege: aSymbol.	^instance</body></methods><methods><class-id>Store.Glorp.StoreAccessPrivilege class</class-id> <category>privilege management</category><body package="Store-Database Model" selector="grant:to:for:">grant: aSymbol to: aStoreUser for: aStorePundle	"Set the access privilege to aStoreUser for aStorePundle."		| instance session |	aSymbol == #owner ifTrue: [^self updateOwnershipFor: aStorePundle to: aStoreUser].	instance := self forPundle: aStorePundle user: aStoreUser privilege: aSymbol.	session := aStorePundle session ifNil: [StoreLoginFactory currentStoreSession].	session inUnitOfWorkDo:		[session register: instance]</body><body package="Store-Database Model" selector="revokeAllFor:for:">revokeAllFor: aStoreUserGroup for: aStorePundle	| privileges session deniedCommands |	privileges := self allPrivilegesForUser: aStoreUserGroup pundle: aStorePundle.	session := aStorePundle session ifNil: [StoreLoginFactory currentStoreSession].	deniedCommands := 	session accessor deniedCommands.	[session accessor permitEverything.	session inUnitOfWorkDo: [session deleteAll: privileges]]			ensure: [session accessor deniedCommands: deniedCommands].</body><body package="Store-Database Model" selector="updateOwnershipFor:to:">updateOwnershipFor: aStorePundle to: aStoreUser	"If there was no previous owner, make me the owner	Otherwise, remove the old owner, and make me the owner"	| instance session previousOwner oldPrivilege |	instance := self forPundle: aStorePundle user: aStoreUser privilege: #owner.	session := aStorePundle session ifNil: [StoreLoginFactory currentStoreSession].	((previousOwner := self ownerOfPundle: aStorePundle) isNil or: [previousOwner ~= aStoreUser])		ifTrue: [session inUnitOfWorkDo: [session register: instance]].	(previousOwner notNil and: [previousOwner ~= aStoreUser]) ifTrue:		[oldPrivilege := self privilegeForUser: previousOwner pundle: aStorePundle.		session inUnitOfWorkDo: [session delete: oldPrivilege].		session inUnitOfWorkDo: [session register: instance]].</body></methods><methods><class-id>ShadowBundleCompileManager</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="bundle">bundle	^bundle</body><body package="Atomic Compiling and Loading" selector="bundle:">bundle: anObject	bundle := anObject</body><body package="Atomic Compiling and Loading" selector="compilationManager">compilationManager	^compilationManager</body><body package="Atomic Compiling and Loading" selector="compilationManager:">compilationManager: anObject	compilationManager := anObject</body><body package="Atomic Compiling and Loading" selector="parentManager:">parentManager: anObject	parentManager := anObject</body><body package="Atomic Compiling and Loading" selector="pundle:">pundle: anObject	bundle := anObject</body><body package="Atomic Compiling and Loading" selector="results">results	^results</body><body package="Atomic Compiling and Loading" selector="results:">results: anObject	results := anObject</body><body package="Atomic Compiling and Loading" selector="resultsFromParent">resultsFromParent	| reverseResults |	reverseResults := OrderedCollection new.	parentManager isNil		ifFalse: [reverseResults addAll: parentManager resultsFromParent].	reverseResults add: results.	^reverseResults.</body><body package="Atomic Compiling and Loading" selector="root">root	^root</body><body package="Atomic Compiling and Loading" selector="root:">root: anObject	root := anObject</body></methods><methods><class-id>ShadowBundleCompileManager</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="atomicCompileWith:">atomicCompileWith: aCompilationManager	"I was invoked by the UI (or directly) do the preCompile, compile and then answer back either nil or the compilation result"	| redefines |	compilationManager := aCompilationManager.	(bundle preCompileWith: aCompilationManager) ifFalse: [^nil].	root := aCompilationManager root.	redefines := OrderedCollection new.	[[SystemUtils modifySystem: [self compile]]		on: RedefinitionOfClass		do: 			[:notification |			(redefines includes: notification parameter)				ifFalse: 					[compilationManager installEarlyAndReInitialize.					compilationManager newShadowRoot.					redefines add: notification parameter.					notification restart]				ifTrue: 					[notification resume]]]			on: NoDLLCCNotification			do: 				[:notification |				compilationManager installEarlyAndReInitialize.				compilationManager newShadowRoot.				notification restart]</body><body package="Atomic Compiling and Loading" selector="compile">compile	"Compile the bundle's package and sub-bundle definitions into shadow space"	bundle isComponentLoaded ifFalse: [bundle isNotLoaded ifFalse: [^nil]].	results := BundleCompilationResult new.	results bundle: bundle.	compilationManager ifNotNil: [compilationManager addResult: results].	(bundle containedItems select: [:each | each isNotLoaded]) do: 		[:each | 		| localResults pundleCompilerManager |		(each isBundle not and: [each binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]])			ifTrue: 				[compilationManager installEarlyAndReInitialize.				compilationManager newShadowRoot.				each binLoadWithin: bundle using: compilationManager]			ifFalse: 				[pundleCompilerManager := each defaultCompileManager root: root.				pundleCompilerManager pundle: each.				pundleCompilerManager compilationManager: compilationManager.				pundleCompilerManager parentManager: self.				SystemUtils modifySystem: [localResults := pundleCompilerManager compile].				results add: localResults.				localResults needsEarlyInstall ifTrue: 					[compilationManager installEarlyWith: self.					root := compilationManager root]]].	^results</body><body package="Atomic Compiling and Loading" selector="install">install	"I answer the results	Here I check to see if I can atomically load at all and if so, I call install on the results"		results isAtomicallyLoadable ifTrue: [results install].	^results</body></methods><methods><class-id>ShadowBundleCompileManager class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="root:">root: aShadowRoot		^(self new)		root: aShadowRoot;		yourself</body><body package="Atomic Compiling and Loading" selector="root:pundle:">root: aShadowRoot pundle: aBundle 	^(self new)		root: aShadowRoot;		bundle: aBundle;		yourself</body></methods><methods><class-id>Store.Glorp.Store74DescriptorSystem</class-id> <category>descriptors</category><body package="Store-Database Model" selector="descriptorForStoreLoadRecord:">descriptorForStoreLoadRecord: aDescriptor	| table |	table := self tableNamed: 'TW_LoadRecord'.	aDescriptor table: table.	aDescriptor directMapping from: #username to: 'username'.	aDescriptor directMapping from: #pundleName to: 'pundleName'.	aDescriptor directMapping from: #type to: 'pundleType'.	aDescriptor directMapping from: #version to: 'pundleVersion'.	self addTimestampTo: aDescriptor fromTable: aDescriptor table.</body><body package="Store-Database Model" selector="descriptorForStoreMethod:">descriptorForStoreMethod: aDescriptor	| |	super descriptorForStoreMethod: aDescriptor.	self hasMethodComments ifTrue: [		(aDescriptor newMapping: OneToOneMapping)			attributeName: #comment;			useLinkTable;			useFilteredRead].</body></methods><methods><class-id>Store.Glorp.Store74DescriptorSystem</class-id> <category>tables</category><body package="Store-Database Model" selector="allTableNames">allTableNames	^super allTableNames , #('TW_MethodDocs' 'TW_LoadRecord').</body><body package="Store-Database Model" selector="tableForTW_LOADRECORD:">tableForTW_LOADRECORD: aTable 	aTable createFieldNamed: 'username' type: (platform varchar: 255).	aTable createFieldNamed: 'pundleName' type: (platform varchar: 255).	aTable createFieldNamed: 'pundleType' type: (platform varchar: 1).	aTable createFieldNamed: 'pundleVersion' type: (platform varchar: 255).	aTable createFieldNamed: self timestampFieldName type: platform integer.	aTable propertyAt: #tableSpaceName put: StoreObject tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreObject tableSpaceName , '.' , session schema].</body><body package="Store-Database Model" selector="tableForTW_METHODDOCS:">tableForTW_METHODDOCS: aTable 	| methodRef documentRef foreignKey |	methodRef := aTable createFieldNamed: 'methodRef' type: platform int4.	methodRef bePrimaryKey.	documentRef := aTable createFieldNamed: 'documentRef' type: platform int4.	documentRef bePrimaryKey.	"This foreignKey is always in the same table space as the target, so we always create it"	aTable addForeignKeyFrom: methodRef		to: ((self tableNamed: 'TW_Method') fieldNamed: 'primaryKey').	foreignKey := aTable addForeignKeyFrom: documentRef		to: ((self tableNamed: 'TW_BinaryBlob') fieldNamed: 'primaryKey').	"This foreignKey talks to a table that may be in another table space, so we have to conditionally create it"	foreignKey shouldCreateInDatabase: self supportsTableSpaceBasedForeignKey.	aTable propertyAt: #tableSpaceName put: StoreObject tableSpaceName.	platform class = SQLServerPlatform ifTrue:		[aTable schema: StoreObject tableSpaceName , '.' , session schema].</body></methods><methods><class-id>Store.Glorp.Store74DescriptorSystem</class-id> <category>classes</category><body package="Store-Database Model" selector="classModelForStoreLoadRecord:">classModelForStoreLoadRecord: aClassModel	aClassModel newAttributeNamed: #username.	aClassModel newAttributeNamed: #pundleName.	aClassModel newAttributeNamed: #pundleType.	aClassModel newAttributeNamed: #version.	aClassModel newAttributeNamed: #timestamp type: Dialect timestampClass.</body><body package="Store-Database Model" selector="classModelForStoreMethod:">classModelForStoreMethod: aClassModel	super classModelForStoreMethod: aClassModel.	aClassModel newAttributeNamed: #comment type: StoreBinaryBlob.</body><body package="Store-Database Model" selector="constructAllClasses">constructAllClasses	^(super constructAllClasses)		add: StoreLoadRecord;		yourself</body></methods><methods><class-id>Store.SkipPrerequisite</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="defaultMessageText">defaultMessageText	^(#APrerequisiteNotLoaded &lt;&lt; #store &gt;&gt; 'A Prerequisite has been not loaded')</body></methods><methods><class-id>Store.IndentedListBuilder</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="initializeVisualComponentAsCFList">initializeVisualComponentAsCFList	"Return a node for the object, always return a new one."	self visualComponentBlock: 		[ :bldr :object | 		Lens.LDMListElementWrapper				on: (ElementView for: object model: bldr viewModel)				at: 0 @ 0		]</body><body package="Store-UI-Graphs" selector="reset">reset	bottom := 0.	spacing := 16@0</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>browsing</category><body package="StoreForGlorpBrowserUI" selector="browseImplementors">browseImplementors	"We need a local search block for the selection dialog."	| dialog searchString searcher |	searcher := (IncrementalSearchModule				forMethodSelectorEntry: #EnterAMethodNameC &lt;&lt; #browser						&gt;&gt; 'Enter a method name:')					searchBlock: [:string | self findLocalMethodSelectorsMatching: string].	dialog := (IncrementalSearchDialog new)				module: searcher;				requireSelection: true.	searchString := dialog select.	(searchString isNil or: [searchString isEmpty]) ifTrue: [^self].	self showWaitCursorWhile: 			[self class openOnEnvironment: (self environment						implementorsMatching: searchString asString)]</body><body package="StoreForGlorpBrowserUI" selector="findLocalMethodSelectorsMatching:">findLocalMethodSelectorsMatching: aString		| results pattern |	aString isEmpty ifTrue: [^Array new].	results := IdentitySet new: 100.	pattern := aString last = $*		ifTrue:			[results add: #*.			aString]		ifFalse: [aString , '*'].	navigator environment methodDefinitions do:		[:each |		(pattern match: each name) ifTrue:			[results add: each name asSymbol.			results size &gt; 500 ifTrue: [^results sorted]]].	^results sorted</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>interface opening</category><body package="StoreForGlorpBrowserUI" selector="postBuildWith:">postBuildWith: aBuilder 		super postBuildWith: aBuilder.	Glorp.GlorpError.Announcements when: ObsoleteBrowserContent send: #handleGlorpError: to: self</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>menus</category><body package="StoreForGlorpBrowserUI" selector="menuBar">menuBar	| menu |	menu := Menu new.	menu		addItem:				((MenuItem labeled: #_Find &lt;&lt; #browser &gt;&gt; '&amp;Find')						nameKey: #Find;						submenu: (self buildTopLevelMenuFrom: #findMenu);						yourself);		addItem:				((MenuItem labeled: #_View &lt;&lt; #browser &gt;&gt; '&amp;View')						nameKey: #View;						submenu: (self buildTopLevelMenuFrom: #viewMenu);						yourself).	navigator ifNotNil: [:nav | nav windowMenuItems		do:			[:each | 			menu				addItem:					((MenuItem labeled: each key)						nameKey: (each key copyWithout: $&amp;) asSymbol;						submenu: each value;						yourself)]].	menu		addItem:				((MenuItem labeled: #Tools &lt;&lt; #browser &gt;&gt; 'Tools')						nameKey: #Tools;						submenu: (self buildTopLevelMenuFrom: #toolsMenu);						yourself);		addItem:				((MenuItem labeled: #Help &lt;&lt; #browser &gt;&gt; 'Help')						nameKey: #Help;						submenu: (self buildTopLevelMenuFrom: #helpMenu);						yourself).	menu		augmentFrom: self class		to: self menuAugmentationRoot		menuName: #menuBar		for: self.	^menu</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI" selector="menuAugmentationRoot">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="codeModelClass">codeModelClass	^StoreCodeModel</body><body package="StoreForGlorpBrowserUI" selector="terminateBrowser">terminateBrowser	self release.	self builder ifNotNil: [self closeAndUnschedule]</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="isGlobalSelected">isGlobalSelected	"We always have a local environment confined to the selection from the database."	^false</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="storeLabelImage">storeLabelImage	| text |	text := navigator environment repositoryName asText				emphasizeAllWith: (Array						with: #color -&gt; (ColorValue red: 0.29 green: 0.43 blue: 0.76)						with: #bold						with: #large).	^VisualRow		withAll: (Array				with: GeneralIcons repository				with: (PixelSpace width: 5)				with: (Label with: text))					, (Array with: (PixelSpace width: 5) with: GeneralIcons repository)</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>interface closing</category><body package="StoreForGlorpBrowserUI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow 	"The ApplicationWindow aWindow is in the process of closing. 	You have been notified."	Glorp.GlorpError.Announcements unsubscribe: self.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>error handling</category><body package="StoreForGlorpBrowserUI" selector="handleGlorpError:">handleGlorpError: anAnnouncement	"Don't let anything hang us up here.	 The repository connection has terminated unexpectedly and we need to clean up the non-revivable browsers."	| session |	session := self navigator environment glorpSession.	session accessor connection = (anAnnouncement session ifNotNil: [:value | value accessor connection]) ifFalse: [^self].	[anAnnouncement wasUsed ifFalse: [Dialog warn: (#DatabaseInfoObsolete &lt;&lt; #store				&gt;&gt; 'The image is disconnected from the database,&lt;n&gt;and the version information is obsolete.&lt;n&gt;The window will now close.')						expandMacros].	self terminateBrowser]			on: Error			do: 				[Transcript show: ('Failed to terminate &lt;1s&gt; on Glorp Database Error.'							expandMacrosWith: self printString)].	anAnnouncement wasUsed: true.</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser class</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="browserEnvironmentClass">browserEnvironmentClass	^StoreForGlorpBrowserEnvironment</body><body package="StoreForGlorpBrowserUI" selector="cleanUpObsoleteInstances">cleanUpObsoleteInstances	"Once a repository connection is closed, any open instances are not revivable, even if the repository is connected again."	self allInstances do: [:ea | ea terminateBrowser]</body><body package="StoreForGlorpBrowserUI" selector="navigatorStateClass">navigatorStateClass		^StoreForGlorpNavigatorState</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="displayString">displayString	^key</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="absoluteClassName">absoluteClassName	^name</body><body package="Store-DB-Subdefs" selector="absoluteOwnerName">absoluteOwnerName	^name</body><body package="Store-DB-Subdefs" selector="className">className	^name</body><body package="Store-DB-Subdefs" selector="classNameWithMeta">classNameWithMeta	^name</body><body package="Store-DB-Subdefs" selector="dataKey">dataKey	^key</body><body package="Store-DB-Subdefs" selector="dataKey:">dataKey: aSymbol	key := aSymbol.	isData := true.</body><body package="Store-DB-Subdefs" selector="environmentString">environmentString	^name</body><body package="Store-DB-Subdefs" selector="fullClassName">fullClassName	^name</body><body package="Store-DB-Subdefs" selector="implementingClass">implementingClass	^nil</body><body package="Store-DB-Subdefs" selector="owner">owner	^nil</body><body package="Store-DB-Subdefs" selector="ownerName">ownerName	^name</body><body package="Store-DB-Subdefs" selector="selector">selector	^key</body><body package="Store-DB-Subdefs" selector="selector:">selector: aSymbol	key := aSymbol.	isData := false.</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="comparesTo:">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	| anObjectEnvironmentString anObjectKey |	(self objectIsForSelf: anObject) ifFalse: [^false].	anObjectEnvironmentString := self isForMethod 		ifTrue: [anObject classNameWithMeta]		ifFalse: [anObject environmentString].	self environmentString = anObjectEnvironmentString ifFalse: [^false].	anObjectKey := self isForMethod 		ifTrue: [anObject selector]		ifFalse: [anObject dataKey].	^key = anObjectKey</body><body package="Store-DB-Subdefs" selector="hash">hash	^key hash bitXor: self environmentString hash</body><body package="Store-DB-Subdefs" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^self isForGeneral		ifTrue: [ anObject isForGeneral ]		ifFalse: [ anObject isForMethod ]</body><body package="Store-DB-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aThing	^self comparesTo: aThing</body><body package="Store-DB-Subdefs" selector="sameAsImThing:">sameAsImThing: aThing	^self comparesTo: aThing</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>testing</category><body package="Store-DB-Subdefs" selector="isForData">isForData	^isData</body><body package="Store-DB-Subdefs" selector="isForGeneral">isForGeneral	^isData</body><body package="Store-DB-Subdefs" selector="isForMethod">isForMethod	^isData not</body><body package="Store-DB-Subdefs" selector="isMeta">isMeta	^self className namesMetaClass</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinition">asStoreMethodDefinition	"This is for a method that isn't really here. So assume that we only need to generate enough of a stub here for any comparison to successfully return false."	| method |	method := Store.Glorp.StoreMethod new name: self selector asString.	method className: self fullClassName.	^method.</body></methods><methods><class-id>Store.PseudoSubdef class</class-id> <category>instance creation</category><body package="Store-DB-Subdefs" selector="dataKey:owner:">dataKey: aSymbol owner: aName	^( super newNamed: aName )		dataKey: aSymbol;		yourself</body><body package="Store-DB-Subdefs" selector="selector:owner:">selector: aSymbol owner: aName	^( super newNamed: aName )		selector: aSymbol;		yourself</body></methods><methods><class-id>Store.StoreDevelopmentSystem</class-id> <category>actions</category><body package="Store-DB-BaseObjects" selector="setUp">setUp	DbRegistry isOnline		ifTrue:			[| action |			DbRegistry resetConnection.			action := self class reconnectAction.			action == #disconnect				ifTrue: [DbRegistry goOffLine]				ifFalse:					[(action == #reconnect and: [DbRegistry recentProfile notNil])						ifTrue: [DbRegistry connectTo: DbRegistry recentProfile]						ifFalse: [DbRegistry restoreConnection]]]</body></methods><methods><class-id>Store.StoreDevelopmentSystem</class-id> <category>prerequisites</category><body package="Store-DB-BaseObjects" selector="prerequisiteSystems">prerequisiteSystems	"We don't want this to run if we are in runtime, or if we are headless, and we want to wait until the ObjectMemory dependents have been notified, because Store session flushing happens there."	^Array with: DevelopmentSystem with: WindowingSystem with: InterestNotificationSystem.</body></methods><methods><class-id>Store.StoreDevelopmentSystem class</class-id> <category>fileIn/Out</category><body package="Store-DB-BaseObjects" selector="prerequisitesForLoading">prerequisitesForLoading	"List those classes that must be filed or BOSSed into the system 	before I can be loaded."	^(super prerequisitesForLoading)		add: DBAccess;		yourself</body></methods><methods><class-id>Store.StoreDevelopmentSystem class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="reconnectAction">reconnectAction	^ReconnectAction ifNil: [#prompt]</body><body package="Store-DB-BaseObjects" selector="reconnectAction:">reconnectAction: anObject	ReconnectAction := anObject</body></methods><methods><class-id>Store.PackageConflicts</class-id> <category>initialization</category><body package="Store-Change Management" selector="fromDiffHolder:">fromDiffHolder: aDiffHolder	"Inialize receiver from a difference holder."	self pkgSide: 1 put: (aDiffHolder pkgSide: 1).	self pkgSide: 2 put: (aDiffHolder pkgSide: 2).	self conflictingNameSpacesFrom: aDiffHolder.	self conflictingClassesFrom: aDiffHolder.	self conflictiongMetaclassesFrom: aDiffHolder.	self conflictingMethodsFrom: aDiffHolder.	self conflictingDataFrom: aDiffHolder.	self conflictingNameSpacesFrom: aDiffHolder</body></methods><methods><class-id>Store.PackageConflicts</class-id> <category>private</category><body package="Store-Change Management" selector="conflictingClassesFrom:">conflictingClassesFrom: aDiffHolder	"Given a difference holder compute collections of conflicting classes.  	Each collection contains classes that are modified in both pkg1 and pkg2."	classes2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	classes1 := ( aDiffHolder classesSide: 1 ) 	select: 		[:cl |   | cc |		cc := ( aDiffHolder classesSide: 2 ) 					detect: [:x | x absoluteName = cl absoluteName] ifNone: [nil].		cc notNil			ifTrue: [ classes2 add: cc.					true]			ifFalse: [ false ] 		].	classes1 := classes1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management" selector="conflictingDataFrom:">conflictingDataFrom: aDiffHolder	"Given a difference holder compute collections of conflicting data elements.  	Each collection contains data that are modified in both pkg1 and pkg2."	data2 := SortedCollection sortBlock: [ :x :y | x name &lt; y name].	data1 := ( aDiffHolder dataSide: 1 ) select: 		[ :datum |  | conflict |		conflict := ( aDiffHolder dataSide: 2 ) detect: 				[ :x | x name = datum name and: [ x ownerName = datum ownerName ] ]				ifNone: [ nil ].		conflict notNil			ifTrue: 				[ data2 add: conflict.				true]			ifFalse: [false]].	data1 := data1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management" selector="conflictingMethodsFrom:">conflictingMethodsFrom: aDiffHolder	"Given a difference holder compute collections of conflicting methods.  	Each collection contains classes that are modified in both pkg1 and pkg2."	methods2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	methods1 := ( aDiffHolder methodsSide: 1 ) select: 		[ :cl |  | cc |		cc := ( aDiffHolder methodsSide: 2 ) detect: 				[ :x | x name = cl name and: [ x className = cl className ] ]				ifNone: [ nil ].		cc notNil			ifTrue: 				[methods2 add: cc.				true]			ifFalse: [false]].	methods1 := methods1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management" selector="conflictingNameSpacesFrom:">conflictingNameSpacesFrom: aDiffHolder	"Given a difference holder compute collections of conflicting namespaces.  	Each collection contains classes that are modified in  both pkg1 and pkg2."	nameSpaces2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	nameSpaces1 := (aDiffHolder nameSpacesSide: 1) select: 		[:ns |   | cc |		cc := ( aDiffHolder nameSpacesSide: 2 ) 					detect: [:x | x absoluteName = ns absoluteName] ifNone: [nil].		cc notNil			ifTrue: [ nameSpaces2 add: cc.					true]			ifFalse: [ false ] 		].	nameSpaces1 := nameSpaces1 asSortedCollection: [ :x :y | x name &lt; y name ].</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>accessing</category><body package="Store-Difference Management" selector="mainPackage">mainPackage	^mainPackage</body><body package="Store-Difference Management" selector="mainPackageClasses">mainPackageClasses	^mainPackageClasses</body><body package="Store-Difference Management" selector="mainPackageClasses:">mainPackageClasses: aCollection	mainPackageClasses := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="mainPackageMethods">mainPackageMethods	^mainPackageMethods</body><body package="Store-Difference Management" selector="mainPackageMethods:">mainPackageMethods: aCollection	mainPackageMethods := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="mainPackageNamespaces">mainPackageNamespaces	^mainPackageNamespaces</body><body package="Store-Difference Management" selector="mainPackageNamespaces:">mainPackageNamespaces: aCollection	mainPackageNamespaces := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="mainPackageProperties">mainPackageProperties	^mainPackageProperties</body><body package="Store-Difference Management" selector="mainPackageProperties:">mainPackageProperties: aCollection	mainPackageProperties := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="mainPackageShareds">mainPackageShareds	^mainPackageShareds</body><body package="Store-Difference Management" selector="mainPackageShareds:">mainPackageShareds: aCollection	mainPackageShareds := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="otherPackage">otherPackage	^otherPackage</body><body package="Store-Difference Management" selector="otherPackageClasses">otherPackageClasses	^otherPackageClasses</body><body package="Store-Difference Management" selector="otherPackageClasses:">otherPackageClasses: aCollection	otherPackageClasses := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="otherPackageMethods">otherPackageMethods	^otherPackageMethods</body><body package="Store-Difference Management" selector="otherPackageMethods:">otherPackageMethods: aCollection	otherPackageMethods := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="otherPackageNamespaces">otherPackageNamespaces	^otherPackageNamespaces</body><body package="Store-Difference Management" selector="otherPackageNamespaces:">otherPackageNamespaces: aCollection	otherPackageNamespaces := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="otherPackageProperties">otherPackageProperties	^otherPackageProperties</body><body package="Store-Difference Management" selector="otherPackageProperties:">otherPackageProperties: aCollection	otherPackageProperties := aCollection asOrderedCollection</body><body package="Store-Difference Management" selector="otherPackageShareds">otherPackageShareds	^otherPackageShareds</body><body package="Store-Difference Management" selector="otherPackageShareds:">otherPackageShareds: aCollection	otherPackageShareds := aCollection asOrderedCollection</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>post load utilities</category><body package="Store-Difference Management" selector="classesToRemoveAfterLoad">classesToRemoveAfterLoad		^otherPackageClasses select: 		[:each | 		each isOverride not and: 			[mainPackageClasses allSatisfy: [:eachClass | eachClass absoluteName ~= each absoluteName]]]</body><body package="Store-Difference Management" selector="methodsToRemoveAfterLoad">methodsToRemoveAfterLoad		^otherPackageMethods select:		[:each | 		each isOverride not and:			[mainPackageMethods allSatisfy:				[:eachMethod | 				eachMethod isMeta ~= each isMeta or: 					[eachMethod name ~= each name or: 					[eachMethod className asClassNameOnly ~= each className asClassNameOnly]]]]]</body><body package="Store-Difference Management" selector="nameSpacesToRemoveAfterLoad">nameSpacesToRemoveAfterLoad		^otherPackageNamespaces select: 		[:each | 		each isOverride not and: 			[mainPackageNamespaces allSatisfy: [:eachNamespace | eachNamespace absoluteName ~= each absoluteName]]]</body><body package="Store-Difference Management" selector="sharedsToRemoveAfterLoad">sharedsToRemoveAfterLoad		^otherPackageShareds select:		[:each | 		each isOverride not and: 			[mainPackageShareds allSatisfy: 				[:eachShared | 				eachShared name ~= each name or: [eachShared environmentString ~= each environmentString]]]]</body><body package="Store-Difference Management" selector="sortedClassesToRemoveAfterLoad">sortedClassesToRemoveAfterLoad	| namedClassesToRemove sortedClasses sortedObjects |	namedClassesToRemove := self classesToRemoveAfterLoad.	sortedClasses := SystemUtils sortForLoading: (namedClassesToRemove collect: [:each | each actual]).	sortedObjects := OrderedCollection new: namedClassesToRemove size.	1 to: sortedClasses size do:		[:index |		sortedObjects add: (namedClassesToRemove 			detect: [:each | each absoluteName = (sortedClasses at: index) absoluteName] 			ifNone: [nil])].	^(sortedObjects reject: [:each | each isNil]) reverse</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>private</category><body package="Store-Difference Management" selector="combineDiffsFrom:">combineDiffsFrom: aPackageComparitor	"Add differences from aPackageComparitor into my differences."		self mainPackageMethods: self mainPackageMethods , aPackageComparitor mainPackageMethods.	self otherPackageMethods: self otherPackageMethods , aPackageComparitor otherPackageMethods.	self mainPackageClasses: self mainPackageClasses , aPackageComparitor mainPackageClasses.	self otherPackageClasses: self otherPackageClasses , aPackageComparitor otherPackageClasses.	self mainPackageShareds: self mainPackageShareds , aPackageComparitor mainPackageShareds.	self otherPackageShareds: self otherPackageShareds , aPackageComparitor otherPackageShareds.	self mainPackageNamespaces: self mainPackageNamespaces , aPackageComparitor mainPackageNamespaces.	self otherPackageNamespaces: self otherPackageNamespaces , aPackageComparitor otherPackageNamespaces.	self removeDuplicateDifferencesIn: mainPackageMethods and: otherPackageMethods.	self removeDuplicateDifferencesIn: mainPackageClasses and: otherPackageClasses.	self removeDuplicateDifferencesIn: mainPackageShareds and: otherPackageShareds.	self removeDuplicateDifferencesIn: mainPackageNamespaces and: otherPackageNamespaces</body><body package="Store-Difference Management" selector="removeDuplicateDifferencesIn:and:">removeDuplicateDifferencesIn: aCollection and: anotherCollection	"Remove differences that are in both."		| definitionsToRemove |	definitionsToRemove := List new.	aCollection do:		[:each | 		| index |		(index := anotherCollection indexOf: each ifAbsent: [nil])			ifNotNil:				[anotherCollection removeAtIndex: index.				definitionsToRemove add: each]].	aCollection removeAll: definitionsToRemove</body><body package="Store-Difference Management" selector="reverse">reverse	"Swap mainPackage with otherPackage"	| exchangeHolder |	exchangeHolder := mainPackage.	mainPackage := otherPackage.	otherPackage := exchangeHolder.	exchangeHolder := mainPackageClasses.	mainPackageClasses := otherPackageClasses.	otherPackageClasses := exchangeHolder.	exchangeHolder := mainPackageMethods.	mainPackageMethods := otherPackageMethods.	otherPackageMethods := exchangeHolder.	exchangeHolder := mainPackageShareds.	mainPackageShareds := otherPackageShareds.	otherPackageShareds := exchangeHolder.	exchangeHolder := mainPackageNamespaces.	mainPackageNamespaces := otherPackageNamespaces.	otherPackageNamespaces := exchangeHolder.</body><body package="Store-Difference Management" selector="setMainPackage:otherPackage:">setMainPackage: aPackage otherPackage: anotherPackage	mainPackage := aPackage.	otherPackage := anotherPackage</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>obsolete</category><body package="Store-Difference Management" selector="removeMatchingDefinitions">removeMatchingDefinitions	self removeMethodDifferencesIn: mainPackageMethods and: otherPackageMethods.	self cleanUpSharedDifferenceIn: mainPackageShareds and: otherPackageShareds.</body><body package="Store-Difference Management" selector="removeMethodDifferencesIn:and:">removeMethodDifferencesIn: aCollectionOfMethods and: anotherCollectionOfMethods	| methodsToRemove |	methodsToRemove := OrderedCollection new: aCollectionOfMethods size.	aCollectionOfMethods do:		[:each |		| index |		index := anotherCollectionOfMethods findFirst: 			[:eachMethod | eachMethod selector = each selector and: [eachMethod classNameWithMeta = each classNameWithMeta]].		index isZero ifFalse:			[ |otherMethod| 			otherMethod := anotherCollectionOfMethods at: index.			(otherMethod sourceMatches: each) ifTrue:				[methodsToRemove add: each.				anotherCollectionOfMethods removeAtIndex: index]]].	aCollectionOfMethods removeAll: methodsToRemove</body><body package="Store-Difference Management" selector="removeSharedDifferencesIn:and:">removeSharedDifferencesIn: aCollectionOfShareds and: anotherCollectionOfShareds	| sharedsToRemove |	sharedsToRemove := OrderedCollection new: aCollectionOfShareds size.	aCollectionOfShareds do:		[:each |		| index |		index := anotherCollectionOfShareds findFirst: 			[:eachShared | eachShared absoluteName = each absoluteName].		index isZero ifFalse:			[ |otherShared| 			otherShared := anotherCollectionOfShareds at: index.			(otherShared sourceMatches: each) ifTrue:				[sharedsToRemove add: each.				anotherCollectionOfShareds removeAtIndex: index]]].	aCollectionOfShareds removeAll: sharedsToRemove</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>comparison</category><body package="Store-Difference Management" selector="cleanseSystem">cleanseSystem		Registry cleanseModels.	mainPackage cleanse: false.	otherPackage cleanse: false</body><body package="Store-Difference Management" selector="computeDifferences">computeDifferences	(Comparing for: mainPackage) started.	self cleanseSystem.	mainPackage computeDiffsBetween: otherPackage into: self.	(Comparing for: mainPackage) finished.</body><body package="Store-Difference Management" selector="computeDifferencesWithProperties">computeDifferencesWithProperties		(Comparing for: mainPackage) started.	self cleanseSystem.	mainPackage computeDifferencesBetween: otherPackage into: self.	mainPackage computePropertyDifferencesBetween: otherPackage into: self.	(Comparing for: mainPackage) finished.</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>counting</category><body package="Store-Difference Management" selector="itemCount">itemCount	^mainPackageClasses size + mainPackageNamespaces size + mainPackageMethods size +  mainPackageShareds size</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>testing</category><body package="Store-Difference Management" selector="hasDifferences">hasDifferences	^mainPackageMethods isEmpty not or:		[otherPackageMethods isEmpty not or:		[mainPackageShareds isEmpty not or: 		[otherPackageShareds  isEmpty not or: 		[mainPackageNamespaces isEmpty not or:		[otherPackageNamespaces isEmpty not or:		[mainPackageClasses  isEmpty not or: 		[otherPackageClasses isEmpty not or:		[mainPackageProperties isEmpty not or:		[otherPackageProperties isEmpty not]]]]]]]]]</body><body package="Store-Difference Management" selector="isPackageComparitor">isPackageComparitor	^true</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>private-filing out</category><body package="Store-Difference Management" selector="fileOutDifferencesFrom:to:on:">fileOutDifferencesFrom: aCollectionOfFromObjects to: aCollectionOfToObjects on: aSourceCodeStream	aCollectionOfFromObjects do:		[:each || target |		target := aCollectionOfToObjects detect: [:eachObject | each absoluteName = eachObject absoluteName] ifNone: [nil].		target ifNotNil: [target fileOutDifferencesBetween: each on: aSourceCodeStream]].</body><body package="Store-Difference Management" selector="fileOutNewFrom:notIn:on:">fileOutNewFrom: someObjects notIn: someOtherObjects on: aSourceCodeStream		| target |	someObjects		do:			[:each | 			target := someOtherObjects detect: [:eachObject | each absoluteName = eachObject absoluteName] ifNone: [nil].			target ifNil: [each fileOutOn: aSourceCodeStream]]</body><body package="Store-Difference Management" selector="fileOutNewMainObjectsOn:">fileOutNewMainObjectsOn: aSourceCodeStream		self fileOutNewFrom: mainPackageNamespaces notIn: otherPackageNamespaces on: aSourceCodeStream.	self fileOutDifferencesFrom: otherPackageNamespaces to: mainPackageNamespaces on: aSourceCodeStream.	self fileOutNewFrom: mainPackageClasses notIn: otherPackageClasses on: aSourceCodeStream.	self fileOutDifferencesFrom: otherPackageClasses to: mainPackageClasses on: aSourceCodeStream.	self fileOutNewFrom: mainPackageShareds notIn: otherPackageShareds on: aSourceCodeStream.	self fileOutDifferencesFrom: otherPackageShareds to: mainPackageShareds on: aSourceCodeStream.</body><body package="Store-Difference Management" selector="fileOutNewOtherObjectsOn:">fileOutNewOtherObjectsOn: aSourceCodeStream		self fileOutNewFrom: otherPackageNamespaces notIn: mainPackageNamespaces on: aSourceCodeStream.	self fileOutDifferencesFrom: mainPackageNamespaces to: otherPackageNamespaces on: aSourceCodeStream.	self fileOutNewFrom: otherPackageClasses notIn: mainPackageClasses on: aSourceCodeStream.	self fileOutDifferencesFrom: mainPackageClasses to: otherPackageClasses on: aSourceCodeStream.	self fileOutNewFrom: otherPackageShareds notIn: mainPackageShareds on: aSourceCodeStream.	self fileOutDifferencesFrom: mainPackageShareds to: otherPackageShareds on: aSourceCodeStream.</body><body package="Store-Difference Management" selector="newMethodsFrom:">newMethodsFrom: aCollectionOfMethods	| modified classOrder protocolOrder |	modified := Dictionary new.	aCollectionOfMethods		do: 			[:each | 			classOrder := modified at: each classNameWithMeta ifAbsent: [Dictionary new].			protocolOrder := classOrder at: each protocol ifAbsent: [Set new].			protocolOrder add: each.			classOrder at: each protocol put: protocolOrder.			modified at: each classNameWithMeta put: classOrder].	^modified</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>user interface support</category><body package="Store-Difference Management" selector="changedClassesNamespacesAndProperties">changedClassesNamespacesAndProperties		| changedObjects |	changedObjects := OrderedCollection new.	self collectMainPackageClassesInto: changedObjects.	self collectOtherPackageClassesInto: changedObjects.	self collectMainPackageNamespacesInto: changedObjects.	self collectOtherPackageNamespacesInto: changedObjects.	self collectMainPackageSharedsInto: changedObjects.	self collectOtherPackageSharedsInto: changedObjects.	self collectMainPackageMethodsInto: changedObjects.	self collectOtherPackageMethodsInto: changedObjects.	changedObjects := (changedObjects collect: [:each | each classListName -&gt; each]) asSortedCollection		collect: [:each | each value].	(mainPackageProperties isEmpty and: [otherPackageProperties isEmpty]) ifFalse:		[self collectMainPackagePropertiesInto: changedObjects.		self collectOtherPackagePropertiesInto: changedObjects].	^changedObjects</body><body package="Store-Difference Management" selector="changedClassesNamespacesAndPropertiesForMerge">changedClassesNamespacesAndPropertiesForMerge		| changedObjects |	changedObjects := OrderedCollection new.	self collectMainPackageClassesInto: changedObjects.	self collectOtherPackageClassesInto: changedObjects.	self collectMainPackageNamespacesInto: changedObjects.	self collectOtherPackageNamespacesInto: changedObjects.	self collectMainPackageSharedsForMergeInto: changedObjects.	self collectOtherPackageSharedsForMergeInto: changedObjects.	self collectMainPackageMethodsInto: changedObjects.	self collectOtherPackageMethodsInto: changedObjects.	changedObjects := (changedObjects collect: [:each | each classListName -&gt; each]) asSortedCollection		collect: [:each | each value].	(mainPackageProperties isEmpty and: [otherPackageProperties isEmpty]) ifFalse:		[self collectMainPackagePropertiesInto: changedObjects.		self collectOtherPackagePropertiesInto: changedObjects].	otherPackage pseudoPackage ifTrue:		[changedObjects do: [:each | each otherPackage: otherPackage]].	^changedObjects</body><body package="Store-Difference Management" selector="collectMainPackageClassesInto:">collectMainPackageClassesInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		| targetClassDifference |	mainPackageClasses ifNil: [^self].	mainPackageClasses do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each longNameFromSmalltalk] ifNone: [nil].		targetClassDifference isNil ifTrue: 			[changedObjects add: (PseudoClassDifference mainPackage: mainPackage class: each)]]</body><body package="Store-Difference Management" selector="collectMainPackageMethodsInto:">collectMainPackageMethodsInto: changedObjects	"PseudoMethodDifferences are are contained in PseudoClassDifferences"	"The targetClassDifference should NEVER have mainPackage as nil"		| targetClassDifference |	mainPackageMethods ifNil: [^self].	mainPackageMethods do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each longNameFromSmalltalk] ifNone: [nil].		mainPackage pseudoPackage 			ifTrue: 				[targetClassDifference isNil ifTrue: [changedObjects add: (targetClassDifference := PseudoClassDifference otherPackage: otherPackage class: (otherPackage objectNamed: each classNameWithoutMeta))]]			ifFalse:				[targetClassDifference isNil ifTrue: [changedObjects add: (targetClassDifference := PseudoClassDifference mainPackage: mainPackage class: (mainPackage objectNamed: each classNameWithoutMeta))].				otherPackage pseudoPackage ifFalse: [(otherPackage objectNamed: each classNameWithoutMeta) ifNotNil: [:value | targetClassDifference otherPackage: otherPackage class: value]]].		targetClassDifference mainPackage: mainPackage method: each]</body><body package="Store-Difference Management" selector="collectMainPackageNamespacesInto:">collectMainPackageNamespacesInto: changedObjects	"The targetNamespaceDifference should NEVER have mainPackage as nil"		| targetNamespaceDifference |	mainPackageNamespaces ifNil: [^self].	mainPackageNamespaces do:		[:each | 		targetNamespaceDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each longNameFromSmalltalk] ifNone: [nil].		targetNamespaceDifference isNil ifTrue: 			[changedObjects add: (PseudoNamespaceDifference mainPackage: mainPackage namespace: each)]]</body><body package="Store-Difference Management" selector="collectMainPackagePropertiesInto:">collectMainPackagePropertiesInto: changedObjects		changedObjects add: (PseudoPropertiesDifference mainPackage: mainPackage properties: mainPackageProperties)</body><body package="Store-Difference Management" selector="collectMainPackageSharedsForMergeInto:">collectMainPackageSharedsForMergeInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		| targetClassDifference |	mainPackageShareds ifNil: [^self].	mainPackageShareds do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each environmentNameFromSmalltalk] ifNone: [nil].		targetClassDifference isNil ifTrue: 			[changedObjects add: (targetClassDifference :=				each belongsToClass					ifTrue: [PseudoClassForSharedDifference mainPackage: mainPackage class: (mainPackage objectNamed: each absoluteOwnerName asString)]					ifFalse: [PseudoNamespaceForSharedDifference mainPackage: mainPackage fromShared: each])].		targetClassDifference mainPackage: mainPackage shared: each]</body><body package="Store-Difference Management" selector="collectMainPackageSharedsInto:">collectMainPackageSharedsInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		| targetClassDifference |	mainPackageShareds ifNil: [^self].	mainPackageShareds do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each environmentNameFromSmalltalk] ifNone: [nil].		targetClassDifference isNil ifTrue: 			[changedObjects add: (targetClassDifference :=				each belongsToClass					ifTrue: [PseudoClassDifference mainPackage: mainPackage class: (mainPackage objectNamed: each absoluteOwnerName asString)]					ifFalse: [PseudoNamespaceDifference mainPackage: mainPackage fromShared: each])].		targetClassDifference mainPackage: mainPackage shared: each]</body><body package="Store-Difference Management" selector="collectOtherPackageClassesInto:">collectOtherPackageClassesInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		| targetClassDifference |	otherPackageClasses ifNil: [^self].	otherPackageClasses do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each longNameFromSmalltalk] ifNone: [nil].		targetClassDifference isNil 			ifTrue: [changedObjects add: (PseudoClassDifference otherPackage: otherPackage class: each)]			ifFalse: [targetClassDifference otherPackage: otherPackage class: each]]</body><body package="Store-Difference Management" selector="collectOtherPackageMethodsInto:">collectOtherPackageMethodsInto: changedObjects		| targetClassDifference |	otherPackageMethods ifNil: [^self].	otherPackageMethods do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each longNameFromSmalltalk] ifNone: [nil].		targetClassDifference isNil 			ifTrue: [changedObjects add: (targetClassDifference := PseudoClassDifference otherPackage: otherPackage class: (otherPackage objectNamed: each classNameWithoutMeta))]			ifFalse: 				[targetClassDifference otherPackage: otherPackage class: (otherPackage objectNamed: each classNameWithoutMeta)].			mainPackage pseudoPackage ifFalse: [(mainPackage objectNamed: each classNameWithoutMeta) ifNotNil: [:value | targetClassDifference mainPackage: mainPackage class: value]].		targetClassDifference otherPackage: otherPackage method: each]</body><body package="Store-Difference Management" selector="collectOtherPackageNamespacesInto:">collectOtherPackageNamespacesInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		| targetNamespaceDifference |	otherPackageNamespaces ifNil: [^self].	otherPackageNamespaces do:		[:each | 		targetNamespaceDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each longNameFromSmalltalk] ifNone: [nil].		targetNamespaceDifference isNil 			ifTrue: [changedObjects add: (PseudoNamespaceDifference otherPackage: otherPackage namespace: each)]			ifFalse: [targetNamespaceDifference otherPackage: otherPackage namespace: each]]</body><body package="Store-Difference Management" selector="collectOtherPackagePropertiesInto:">collectOtherPackagePropertiesInto: changedObjects	| targetChange |	targetChange := changedObjects detect: [:each | each classListName = PseudoPropertiesDifference classListName].	targetChange otherPackage: otherPackage properties: otherPackageProperties</body><body package="Store-Difference Management" selector="collectOtherPackageSharedsForMergeInto:">collectOtherPackageSharedsForMergeInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		| targetClassDifference |	otherPackageShareds ifNil: [^self].	otherPackageShareds do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each environmentNameFromSmalltalk] ifNone: [nil].		targetClassDifference isNil ifTrue: 			[changedObjects add: (targetClassDifference := 				each belongsToClass					ifTrue: [PseudoClassForSharedDifference otherPackage: otherPackage class: (otherPackage objectNamed: each absoluteOwnerName asString)]					ifFalse: [PseudoNamespaceForSharedDifference otherPackage: otherPackage fromShared: each])].		targetClassDifference otherPackage: otherPackage shared: each]</body><body package="Store-Difference Management" selector="collectOtherPackageSharedsInto:">collectOtherPackageSharedsInto: changedObjects	"The targetClassDifference should NEVER have mainPackage as nil"		| targetClassDifference |	otherPackageShareds ifNil: [^self].	otherPackageShareds do:		[:each | 		targetClassDifference := changedObjects detect: [:eachPseudo | eachPseudo classListName = each environmentNameFromSmalltalk] ifNone: [nil].		targetClassDifference isNil ifTrue: 			[changedObjects add: (targetClassDifference := 				each belongsToClass					ifTrue: [PseudoClassDifference otherPackage: otherPackage class: (otherPackage objectNamed: each absoluteOwnerName asString)]					ifFalse: [PseudoNamespaceDifference otherPackage: otherPackage fromShared: each])].		targetClassDifference otherPackage: otherPackage shared: each.		targetClassDifference otherClass ifNil: [targetClassDifference otherObject: (otherPackage objectNamed: each absoluteOwnerName asString)]]</body><body package="Store-Difference Management" selector="makeEmpty">makeEmpty	mainPackageMethods := otherPackageMethods := mainPackageShareds := otherPackageShareds := mainPackageNamespaces := otherPackageNamespaces := #().	mainPackageClasses := otherPackageClasses := mainPackageProperties := otherPackageProperties :=#()</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>filing out</category><body package="Store-Difference Management" selector="classesToRemoveForMain">classesToRemoveForMain	^mainPackageClasses select:		[:each |		(otherPackageClasses			detect: [:eachClass | eachClass absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management" selector="classesToRemoveForOther">classesToRemoveForOther	^otherPackageClasses select:		[:each |		(mainPackageClasses			detect: [:eachClass | eachClass absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management" selector="fileOutMainToOtherDifferencesOn:">fileOutMainToOtherDifferencesOn: aSourceCodeStream		aSourceCodeStream deferInitializations.	aSourceCodeStream cr.	aSourceCodeStream addComment: ((#PackageDifferencesFrom1sto2s &lt;&lt; #packages &gt;&gt; 'Package Differences from &lt;1s&gt; to &lt;2s&gt;')			expandMacrosWith: mainPackage itemString			with: otherPackage itemString).	self fileOutNewOtherObjectsOn: aSourceCodeStream.	self fileOutRemoveMainObjectsOn: aSourceCodeStream.	self newOtherMethods keysAndValuesDo:		[:key :value | aSourceCodeStream fileOutTTMessages: value for: key logging: false].	self methodsToRemoveForMain do:		[:each | aSourceCodeStream removeSelector: each selector fromClassNamed: each classNameWithMeta].	aSourceCodeStream finishInitializations</body><body package="Store-Difference Management" selector="fileOutOtherToMainDifferencesOn:">fileOutOtherToMainDifferencesOn: aSourceCodeStream		aSourceCodeStream deferInitializations.	aSourceCodeStream addComment: ((#PackageDifferencesFrom1sto2s &lt;&lt; #packages &gt;&gt; 'Package Differences from &lt;1s&gt; to &lt;2s&gt;')			expandMacrosWith: otherPackage itemString			with: mainPackage itemString).	self fileOutNewMainObjectsOn: aSourceCodeStream.	self fileOutRemoveOtherObjectsOn: aSourceCodeStream.	self newMainMethods keysAndValuesDo:		[:key :value | aSourceCodeStream fileOutTTMessages: value for: key logging: false].	self methodsToRemoveForOther do:		[:each | aSourceCodeStream removeSelector: each selector fromClassNamed: each classNameWithMeta].	aSourceCodeStream finishInitializations</body><body package="Store-Difference Management" selector="fileOutRemoveMainObjectsOn:">fileOutRemoveMainObjectsOn: aSourceCodeStream		self sharedsToRemoveForMain do: [:each | aSourceCodeStream removeObject: each absoluteName type: #variable].	self classesToRemoveForMain do: [:each | aSourceCodeStream removeObject: each absoluteName type: #class].	self nameSpacesToRemoveForMain do: [:each | aSourceCodeStream removeObject: each absoluteName type: #nameSpace]</body><body package="Store-Difference Management" selector="fileOutRemoveOtherObjectsOn:">fileOutRemoveOtherObjectsOn: aSourceCodeStream		self sharedsToRemoveForOther do: [:each | aSourceCodeStream removeObject: each absoluteName type: #variable].	self classesToRemoveForOther do: [:each | aSourceCodeStream removeObject: each absoluteName type: #class].	self nameSpacesToRemoveForOther do: [:each | aSourceCodeStream removeObject: each absoluteName type: #nameSpace]</body><body package="Store-Difference Management" selector="methodsToRemoveForMain">methodsToRemoveForMain	^mainPackageMethods select:		[:each |		(otherPackageMethods 			detect:				[:eachMethod | 				(eachMethod isMeta = each isMeta and: [eachMethod name = each name]) and: 					[eachMethod className asClassNameOnly = each className asClassNameOnly]]			ifNone: [nil]) isNil]</body><body package="Store-Difference Management" selector="methodsToRemoveForOther">methodsToRemoveForOther	^otherPackageMethods select:		[:each |		(mainPackageMethods 			detect:				[:eachMethod | 				(eachMethod isMeta = each isMeta and: [eachMethod name = each name]) and: 					[eachMethod className asClassNameOnly = each className asClassNameOnly]]			ifNone: [nil]) isNil]</body><body package="Store-Difference Management" selector="nameSpacesToRemoveForMain">nameSpacesToRemoveForMain		^mainPackageNamespaces select: 		[:each | 		(otherPackageNamespaces 			detect: [:eachNamespace | eachNamespace absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management" selector="nameSpacesToRemoveForOther">nameSpacesToRemoveForOther		^otherPackageNamespaces select: 		[:each | 		(mainPackageNamespaces 			detect: [:eachNamespace | eachNamespace absoluteName = each absoluteName] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management" selector="newMainMethods">newMainMethods	^self newMethodsFrom: mainPackageMethods</body><body package="Store-Difference Management" selector="newOtherMethods">newOtherMethods	^self newMethodsFrom: otherPackageMethods</body><body package="Store-Difference Management" selector="sharedsToRemoveForMain">sharedsToRemoveForMain	^mainPackageShareds select:		[:each |		(otherPackageShareds			detect: [:eachShared | eachShared name = each name and: [eachShared environmentString = each environmentString]] 			ifNone: [nil]) isNil]</body><body package="Store-Difference Management" selector="sharedsToRemoveForOther">sharedsToRemoveForOther	^otherPackageShareds select:		[:each |		(mainPackageShareds			detect: [:eachShared | eachShared name = each name and: [eachShared environmentString = each environmentString]] 			ifNone: [nil]) isNil]</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>printing</category><body package="Store-Difference Management" selector="mainVersionNameString">mainVersionNameString		^mainPackage name , mainPackage versionString</body><body package="Store-Difference Management" selector="otherVersionNameString">otherVersionNameString		^otherPackage name , otherPackage versionString</body><body package="Store-Difference Management" selector="versionNamesString">versionNamesString		^self mainVersionNameString , ' -&gt; ' , self otherVersionNameString</body></methods><methods><class-id>Store.PackageComparitor</class-id> <category>initialize-release</category><body package="Store-Difference Management" selector="initialize">initialize	mainPackageMethods := OrderedCollection new.	otherPackageMethods := OrderedCollection new.	mainPackageShareds := OrderedCollection new.	otherPackageShareds := OrderedCollection new.	mainPackageNamespaces := OrderedCollection new.	otherPackageNamespaces := OrderedCollection new.	mainPackageClasses := OrderedCollection new.	otherPackageClasses := OrderedCollection new.	mainPackageProperties := OrderedCollection new.	otherPackageProperties:= OrderedCollection new.</body></methods><methods><class-id>Store.PackageComparitor class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="differencesBetween:and:">differencesBetween: aPackage and: anotherPackage	| instance |	instance := self new.	instance setMainPackage: aPackage otherPackage: anotherPackage.	instance computeDifferences.	^instance</body><body package="Store-Difference Management" selector="differencesWithPropertiesBetween:and:">differencesWithPropertiesBetween: aPackage and: anotherPackage	| instance |	instance := self new.	instance setMainPackage: aPackage otherPackage: anotherPackage.	instance computeDifferencesWithProperties.	^instance</body><body package="Store-Difference Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.Glorp.RemovalResolution</class-id> <category>testing</category><body package="Store-Merge Management" selector="isClassDefintionResolver">isClassDefintionResolver	self halt.	^base isClassDefintionResolver</body><body package="Store-Merge Management" selector="isCommentResolver">isCommentResolver	^false</body><body package="Store-Merge Management" selector="isMethodResolver">isMethodResolver	self halt.	^base isMethodResolver</body><body package="Store-Merge Management" selector="isNameSpaceDefinitionResolver">isNameSpaceDefinitionResolver	self halt.	^base isNameSpaceDefinitionResolver</body><body package="Store-Merge Management" selector="isRemovalResolution">isRemovalResolution	^true</body><body package="Store-Merge Management" selector="isSharedResolver">isSharedResolver	self halt.	^base isSharedResolver</body></methods><methods><class-id>Store.Glorp.RemovalResolution</class-id> <category>accessing</category><body package="Store-Merge Management" selector="base">base	^base</body><body package="Store-Merge Management" selector="base:">base: aResolver	base := aResolver</body><body package="Store-Merge Management" selector="definitionValue">definitionValue	^base value</body><body package="Store-Merge Management" selector="original">original	^self package</body><body package="Store-Merge Management" selector="protocol">protocol	^''</body><body package="Store-Merge Management" selector="value">value	^base</body></methods><methods><class-id>Store.Glorp.RemovalResolution</class-id> <category>comparing</category><body package="Store-Merge Management" selector="=">= anObject	^self class = anObject class and:		[self base = anObject base and:		[self package = anObject package]]</body></methods><methods><class-id>Store.Glorp.RemovalResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="fromBaseResolution:">fromBaseResolution: aResolver	| instance |	instance := self new.	instance base: aResolver.	^instance</body><body package="Store-Merge Management" selector="fromBaseResolution:fromPackage:">fromBaseResolution: aResolver fromPackage: aPackage	| instance |	instance := self new.	instance base: aResolver.	instance package: aPackage.	^instance</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>persistence</category><body package="Store-UI" selector="addStateXmlElementsTo:">addStateXmlElementsTo: anElement	profiles do: 		[:each |		anElement addNode: each asXmlNode]</body><body package="Store-UI" selector="restoreFrom:">restoreFrom: aSettingSnapshot	| newProfiles |	newProfiles := OrderedCollection new.	aSettingSnapshot stateNodes do:		[:each | | profile |		profile := ConnectionProfile fromXmlElement: each.		newProfiles add: profile].	profiles := newProfiles.	self installProfiles</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>actions</category><body package="Store-UI" selector="installProfiles">installProfiles	RepositoryManager replaceRepositoriesWith: profiles</body><body package="Store-UI" selector="profiles">profiles	^profiles</body><body package="Store-UI" selector="resetProfiles">resetProfiles	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Store.Glorp.UserInputResolution</class-id> <category>accessing</category><body package="Store-Merge Management" selector="original">original	^self package</body><body package="Store-Merge Management" selector="protocol">protocol	^protocol</body><body package="Store-Merge Management" selector="protocol:">protocol: anObject	protocol := anObject</body><body package="Store-Merge Management" selector="protocolName">protocolName	^(protocol isNil or: [protocol isEmpty])		ifTrue: [ClassOrganizer defaultProtocol]		ifFalse: [protocol]</body><body package="Store-Merge Management" selector="text">text	^text</body><body package="Store-Merge Management" selector="text:">text: aString	text := aString</body><body package="Store-Merge Management" selector="value">value	^text</body></methods><methods><class-id>Store.Glorp.UserInputResolution</class-id> <category>testing</category><body package="Store-Merge Management" selector="isUserInputResolution">isUserInputResolution	^true</body></methods><methods><class-id>Store.Glorp.UserInputResolution</class-id> <category>comparing</category><body package="Store-Merge Management" selector="=">= anObject	^self class = anObject class and: 		[text = anObject text and:		[protocol = anObject protocol and:		[package = anObject package]]]</body></methods><methods><class-id>Store.Glorp.UserInputResolution</class-id> <category>resolving</category><body package="Store-Merge Management" selector="applyUsing:">applyUsing: aChangeResolver	"Answer true if it is OK, or false if something bad happened"	^aChangeResolver loadSourceUsing: self</body></methods><methods><class-id>Store.Glorp.UserInputResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="forPackage:text:">forPackage: aPundleModel text: aString	| instance |	instance := self new.	instance package: aPundleModel.	instance text: aString.	^instance</body><body package="Store-Merge Management" selector="forPackage:text:protocol:">forPackage: aPundleModel text: aString protocol: aProtocolString	| instance |	instance := self new.	instance package: aPundleModel.	instance text: aString.	instance protocol: aProtocolString.	^instance</body></methods><methods><class-id>Store.AlreadyConnected</class-id> <category>private - actions</category><body package="Store-Database" selector="defaultAction">defaultAction	^Dialog confirm: 		((#AlreadyConnected1snReconnect &lt;&lt; #store &gt;&gt; 'Already Connected to &lt;1s&gt;&lt;n&gt;Reconnect?') expandMacrosWith: parameter)</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>field list</category><body package="Store-UI" selector="fieldAll">fieldAll	^(#AsterisksAllAsterisks &lt;&lt; #store &gt;&gt; '*** all ***') asString</body><body package="Store-UI" selector="fieldList">fieldList	"Answer a collection of the keys of the inspected dictionary."	| keys | 	keys := OrderedCollection new.	object keysDo: [:each | keys add: each].	keys add: self fieldAll.	^keys asSortedCollection</body><body package="Store-UI" selector="fieldMenu">fieldMenu	^(InputState default ctrlDown or: [self object isMainChangeSet])		ifTrue: [field isSymbol				ifTrue: [Menu						labels: (#inspectChangesToClaEmptyAllChanges &lt;&lt; #store &gt;&gt; 'inspect changes to class&lt;n&gt;file out changes to class as...&lt;n&gt;empty changes to class...&lt;n&gt;file out all changes as ...&lt;n&gt;empty all changes...') expandMacros						lines: #(3)						values: #(#inspectField #fileOutField #emptyField #fileOut #empty)]				ifFalse: [Menu labels: (#fileOutAllChangesAEmptyAllChanges &lt;&lt; #store &gt;&gt; 'file out all changes as ...&lt;n&gt;empty all changes...') expandMacros values: #(#fileOut #empty)]]		ifFalse: [field isSymbol				ifTrue: [Menu						labels: (#fileOutChangesToClUtAllChangesAs &lt;&lt; #store &gt;&gt; 'file out changes to class as...&lt;n&gt;file out all changes as ...') expandMacros						lines: #(1)						values: #(#fileOutField #fileOut)]				ifFalse: [Menu labels: (#fileOutAllChangesAs &lt;&lt; #store &gt;&gt; 'file out all changes as ...') asString  values: #(#fileOut)]]</body><body package="Store-UI" selector="fieldValue">fieldValue	field = self fieldAll ifTrue: [ ^object ].	^object at: field		ifAbsent: 	['no longer any changes to this class']</body><body package="Store-UI" selector="printItems">printItems	"Answer whether the elements of the list of fields needs to be converted to strings"	^false</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>menu commands</category><body package="Store-UI" selector="empty">empty	(Dialog confirm: #ReallyEmptyThisChangeSet &lt;&lt; #store &gt;&gt; 'Really empty this change set?'for: self interfaceWindow) ifTrue: 		[self object initialize.		self changed: #text]</body><body package="Store-UI" selector="emptyField">emptyField	(Dialog confirm: ((#ReallyEmptyAllChangesToClass1s &lt;&lt; #store &gt;&gt; 'Really empty all changes to class &lt;1s&gt;?') asString				expandMacrosWith: self field)		for: self interfaceWindow) 			ifTrue: 				[self object doClassChange: ((Change new)							classSymbol: self field;							removeChanges).				field := nil.				self changed: #field]</body><body package="Store-UI" selector="fileOut">fileOut	| fileName |	fileName := Dialog 				requestNewFileName: #FileOutAsFileNamed &lt;&lt; #store &gt;&gt; 'File out as file named'				default: 'filename.st'.	fileName isEmpty ifTrue: [^self].	fileName := Filename named: fileName.	Transcript 		show: (#NnFilingOutChangesOnNt1s &lt;&lt; #store &gt;&gt; '&lt;nn&gt;Filing out changes on:&lt;nt&gt;&lt;1s&gt;' expandMacrosWith: fileName asString).	Cursor write showWhile: 			[| strm |			strm := SourceCodeStream write: fileName.						[strm timeStamp.			self object fileOutOn: strm] ensure: [strm close]]</body><body package="Store-UI" selector="fileOutField">fileOutField	| fileName |	fileName := Dialog 				requestNewFileName: (#FileOutChangeTo1sAsFileNamed &lt;&lt; #store &gt;&gt; 'File out change to &lt;1s&gt; as file named' expandMacrosWith: self field)				default: 'filename.st'.	fileName isEmpty ifTrue: [^self].	fileName := Filename named: fileName.	Transcript 		show: (#NnFilingOutChangesOnNt1s &lt;&lt; #store &gt;&gt; '&lt;nn&gt;Filing out changes on:&lt;nt&gt;&lt;1s&gt;' expandMacrosWith: fileName asString).	Cursor write showWhile: 			[| strm |			strm := SourceCodeStream write: fileName.						[strm timeStamp.			self object fileOutOn: strm classSymbol: self field] 					ensure: [strm close]]</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>initialize-release</category><body package="Store-UI" selector="inspect:">inspect: anObject 	super inspect: anObject .	self field: self fieldAll.</body><body package="Store-UI" selector="viewLabel">viewLabel	^windowLabel == nil 		ifTrue: 			[self object isMainChangeSet 				ifTrue: [(#MainChanges &lt;&lt; #store &gt;&gt; 'Main Changes') asString]				ifFalse: [(#PackageChanges &lt;&lt; #store &gt;&gt; 'Package Changes') asString]]		ifFalse: [windowLabel]</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>accessing</category><body package="Store-UI" selector="windowLabel:">windowLabel: aString	windowLabel := aString</body></methods><methods><class-id>Store.ChangeSetInspector class</class-id> <category>view creation</category><body package="Store-UI" selector="inspect:label:">inspect: anObject label: aLabel	"Answer an instance of me to provide an inspector for anObject."	^self open: 		( self new 			windowLabel: aLabel;			inspect: anObject		)</body><body package="Store-UI" selector="open:">open: anInspector 	"Create and schedule a window on the model, anInspector."	| window |	anInspector allButOpenInterface: #windowSpec.	window := anInspector builder window.	anInspector finallyOpenIn: (window defaultRectangle: (300 @ 200) rounded)		withType: #normal</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="classesAndNameSpaces">classesAndNameSpaces	| objects |	objects := OrderedCollection new.	self objectNames do: 			[:each |			| object |			object := environment classForName: each						ifAbsent: [environment nameSpaceForName: each ifAbsent: [nil]].			object notNil ifTrue: [objects add: object]].	^objects</body><body package="StoreForGlorpBrowserUI" selector="classesAndNameSpaces:">classesAndNameSpaces: aCollection	| any |	any := self any: aCollection.	any notNil		ifTrue: 			[type := any isForClassOrExtension						ifTrue: [any isMeta ifTrue: [#class] ifFalse: [#instance]]						ifFalse: [#sharedVariable]].	objectNameReferences := aCollection collect: 					[:each |					(each isBehavior ifTrue: [each instanceBehavior] ifFalse: [each])						fullRootName asQualifiedReference]</body><body package="StoreForGlorpBrowserUI" selector="environment">environment	^environment</body><body package="StoreForGlorpBrowserUI" selector="environment:">environment: aBrowserEnvironment	"It would be more in keeping with the way the RB works to have the state consult a global variable holding the glorp StoreModel loaded in the image.  However, that would not work if you want to browse two versions of the same code at the same time.  For that, we must ask the environment which knows which pundle models you are actually browsing.  Later we will distinguish the two cases and subclass so you can browse in glorp StoreModel organisation any code you have currently loaded from, or published to, Store, and also shadow-browse unloaded store models. Only the latter will need a state that knows its environment."	environment := aBrowserEnvironment.</body><body package="StoreForGlorpBrowserUI" selector="nameSpace">nameSpace	"Just give the name space equivalent that's in memory. We should probably disallow saving from this pane anyway"	^nameSpaceName asQualifiedReference valueOrDo: [Smalltalk].</body><body package="StoreForGlorpBrowserUI" selector="nameSpace:">nameSpace: aStringOrNamespace	aStringOrNamespace isString		ifTrue: 			[(aStringOrNamespace copyFrom: 1 to: (4 min: aStringOrNamespace size))				= 'Root'					ifTrue: [nameSpaceName := aStringOrNamespace]					ifFalse: [nameSpaceName := 'Root.Smalltalk.' , aStringOrNamespace]]		ifFalse: [nameSpaceName := aStringOrNamespace fullRootName]</body><body package="StoreForGlorpBrowserUI" selector="nonMetaClasses">nonMetaClasses	| classes |	classes := OrderedCollection new: self objectNames size.	self objectNames do:		[:each || class |		class := environment classForName: each ifAbsent: [nil].		(class notNil and: [class isClass]) ifTrue: [classes add: class]].	^classes</body><body package="StoreForGlorpBrowserUI" selector="objectNames:">objectNames: aCollection 	objectNameReferences := aCollection.</body><body package="StoreForGlorpBrowserUI" selector="pseudoBindingFor:">pseudoBindingFor: aBinding	^environment at: aBinding asString ifAbsent: [nil].</body><body package="StoreForGlorpBrowserUI" selector="pundles">pundles	^(pundles collect: [:each | environment pundleNamed: each first isPackage: each last])		select: [:each | each notNil].</body><body package="StoreForGlorpBrowserUI" selector="selectedBindings">selectedBindings	^objectNameReferences collect: [:each | self pseudoBindingFor: each].</body><body package="StoreForGlorpBrowserUI" selector="selectedMethods">selectedMethods	^self definitions collect:		[:each |		self environment methodNamed: each selector inClass: each implementingClass]</body><body package="StoreForGlorpBrowserUI" selector="selectedNameSpace">selectedNameSpace	^(objectNameReferences collect: [:each | self pseudoBindingFor: each])		detect: [:each | each isForNameSpace or: [each isForData]]		ifNone: [^nil]</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>accessing-class</category><body package="StoreForGlorpBrowserUI" selector="selectedGlobals">selectedGlobals	| globals classOrNameSpace |	globals := OrderedCollection new: objectNameReferences size.	objectNameReferences do:		[:each | 		classOrNameSpace := self pseudoBindingFor: each.		(classOrNameSpace isForClassOrExtension or: [classOrNameSpace isForNameSpace or: [classOrNameSpace isForData]])			ifTrue: [globals add: classOrNameSpace]].	^globals</body><body package="StoreForGlorpBrowserUI" selector="selectedShareds">selectedShareds	| shareds shared |	shareds := OrderedCollection new: objectNameReferences size.	objectNameReferences keysAndValuesDo:		[:index :each | 		shared := self binding.		(shared isForClassOrExtension or: [shared isForNameSpace or: [shared isForData]])			ifTrue: [shareds add: shared]].	^shareds</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>accessing-methods</category><body package="StoreForGlorpBrowserUI" selector="binding">binding		| localDefinitions |	localDefinitions := (self type = #sharedVariable and: [definitions isEmpty])		ifTrue: [^nil]		ifFalse: [definitions].	^environment sharedVariable: localDefinitions first variableName for: objectNameReferences first</body><body package="StoreForGlorpBrowserUI" selector="methodDefinitionClass">methodDefinitionClass	^StoreMethodDefinition</body><body package="StoreForGlorpBrowserUI" selector="selectors">selectors	"The methods in StorePundle hold selectors as String."	| defs class |	defs := self methodDefinitions.	defs isEmpty ifTrue: [^#()].	class := self selectedClass.	^(defs select: [:each | each inheritingClass = class]) 		collect: [:each | each selector asSymbol]</body><body package="StoreForGlorpBrowserUI" selector="selectors:">selectors: symbolCollection	"	| class |	class := self selectedClass.	class isNil ifTrue: [^self definitions: #()].	self definitions: (symbolCollection collect:		[:each | 		| implementingClass |		implementingClass := class whichClassIncludesSelector: each.		implementingClass isNil ifTrue: [implementingClass := class].		StoreMethodDefinition class: class implementor: implementingClass selector: (each isString ifTrue: [each] ifFalse: [each name])])"	super selectors: symbolCollection</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigatorState</class-id> <category>printing</category><body package="StoreForGlorpBrowserUI" selector="printOn:">printOn: aStream		| binding |	binding := self selectedBinding.	binding notNil		ifTrue:			[aStream nextPutAll: binding name.			self isMeta ifTrue: [aStream nextPutAll: ' class'].			self selector notNil				ifTrue:					[aStream						nextPutAll: '&gt;&gt;';						nextPutAll: self selector]				ifFalse:					[self sharedVariableName notNil						ifTrue:							[aStream								nextPut: $.;								nextPutAll: self sharedVariableName]						ifFalse:							[self protocol notNil								ifTrue:									[aStream										nextPut: $&gt;;										nextPutAll: self protocol]]]]		ifFalse:			[self pundles isEmpty				ifTrue: [aStream nextPutAll: '(nothing selected)']				ifFalse: [aStream nextPutAll: self pundle itemString]].</body></methods><methods><class-id>Store.PackagesView</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="binFile">binFile	^binFile</body><body package="Store-DB-Pundles" selector="binFile:">binFile: aString	binFile := aString</body><body package="Store-DB-Pundles" selector="bundleRef">bundleRef	^bundleRef</body><body package="Store-DB-Pundles" selector="bundleRef:">bundleRef: aValue	bundleRef := aValue</body><body package="Store-DB-Pundles" selector="commentSize">commentSize	^commentSize</body><body package="Store-DB-Pundles" selector="commentSize:">commentSize: aNumber	commentSize := aNumber</body><body package="Store-DB-Pundles" selector="expression">expression	^expression</body><body package="Store-DB-Pundles" selector="expression:">expression: aValue	expression := aValue</body><body package="Store-DB-Pundles" selector="longField">longField	^longField</body><body package="Store-DB-Pundles" selector="longField:">longField: anObject	longField := anObject</body><body package="Store-DB-Pundles" selector="seqNumber">seqNumber	^seqNumber</body><body package="Store-DB-Pundles" selector="seqNumber:">seqNumber: aValue	seqNumber := aValue</body></methods><methods><class-id>Store.PackagesView class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="childReference">childReference		^'packageRef'</body><body package="Store-DB-Pundles" selector="parentReference">parentReference	^'bundleRef'</body><body package="Store-DB-Pundles" selector="referencedClass">referencedClass	^Bundle</body><body package="Store-DB-Pundles" selector="subCollectionClass">subCollectionClass	^Packages</body></methods><methods><class-id>Store.PackagesView class</class-id> <category>session</category><body package="Store-DB-Pundles" selector="packageSession">packageSession	( self isSessionValid: PackageSession)		ifFalse:			[PackageSession := self broker getNewSession.			PackageSession bindOutput: self newPrimed.			PackageSession bindInput: Package new.			PackageSession prepare: 					( self newSQL						selectAll;						where;						column: #bundleRef equalTo: ':primaryKey') ].	^PackageSession</body><body package="Store-DB-Pundles" selector="resetSession">resetSession	PackageSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: PackageSession].		PackageSession := nil]</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>testing</category><body package="Store-Merge Management" selector="isForNamespace">isForNamespace	^true</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>accessing</category><body package="Store-Merge Management" selector="longTreeName">longTreeName	(name includes: $.) ifTrue: 		[^(('Root.*' match: name)			ifTrue: [name]			ifFalse: ['Root.', name]) , self applyableString].	^'Root.Smalltalk.' , name, self applyableString</body><body package="Store-Merge Management" selector="simpleName">simpleName	| index |	index := name lastIndexOf: $..	^name copyFrom: index + 1 to: name size.</body><body package="Store-Merge Management" selector="typeIcon">typeIcon	^NameSpace toolListIcon</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>resolving</category><body package="Store-Merge Management" selector="removeEmptyResolvers">removeEmptyResolvers	| newResolutions |	newResolutions := resolutions copy.	resolutions keysAndValuesDo:		[:key :value |		value alternatives isEmpty ifTrue: [newResolutions removeKey: key].		value applied ifTrue: [newResolutions removeKey: key]].	resolutions := newResolutions.</body></methods><methods><class-id>Store.Glorp.NamespaceResolutions</class-id> <category>displaying</category><body package="Store-Merge Management" selector="browseVersions">browseVersions	| list session |	(Gathering for: self simpleName) started.	self standardResolutionAlternative		ifNotNil: [:value | session := value key session].	list := Store.Glorp.StoreNamespaceInPackage				allVersionsWithName: self simpleName				in: session.	(Gathering for: self simpleName) finished.	list isEmpty		ifTrue: 			[^Dialog				warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.'						expandMacrosWith: name)].	Store.Glorp.DefinitionForListTool forNameSpaces: list</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>reporting</category><body package="Store-Database" selector="printFinalStatisticsTo:">printFinalStatisticsTo: aStream 	aStream nextPutAll: (#NGarbageCollectionEndedP &lt;&lt; #store &gt;&gt; '&lt;n&gt;Garbage collection ended:   &lt;1p&gt; ' expandMacrosWith: Timestamp now).	aStream nextPutAll: (#NRemoved &lt;&lt; #store &gt;&gt; '&lt;n&gt;Removed...') expandMacros.	aStream nextPutAll: (#NTBundles &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Bundles: &lt;1p&gt;' expandMacrosWith: bundlesToRemove size).	aStream nextPutAll: (#NTPackages &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Packages &lt;1p&gt;' expandMacrosWith: packagesToRemove size).	aStream nextPutAll: (#NtNamespaces1p &lt;&lt; #store &gt;&gt; '&lt;nt&gt;NameSpaces: &lt;1p&gt;'  expandMacrosWith: nameSpacesToRemove size).	aStream nextPutAll: (#NtClasses1p &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Classes: &lt;1p&gt;'  expandMacrosWith: classesToRemove size).	aStream nextPutAll: (#NtMethods1p &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Methods: &lt;1p&gt;' expandMacrosWith: methodsToRemove size).	aStream  nextPutAll: (#NtSharedVariables1pN &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Shared Variables: &lt;1p&gt;&lt;n&gt;' expandMacrosWith: sharedsToRemove size)</body><body package="Store-Database" selector="printInitialStatisticsTo:">printInitialStatisticsTo: aStream		aStream nextPutAll: (#NGarbageCollectionStarted1p &lt;&lt; #store &gt;&gt; '&lt;n&gt;Garbage collection started:   &lt;1p&gt;' expandMacrosWith: Timestamp now).	aStream		cr;		nextPutAll: (#Examining &lt;&lt; #store &gt;&gt; 'Examining...') asString.	aStream nextPutAll: (#NTBundles &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Bundles: &lt;1p&gt;' expandMacrosWith: bundlesToRemove size).	aStream nextPutAll: (#NTPackages &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Packages &lt;1p&gt;' expandMacrosWith: packagesToRemove size).	aStream		nextPutAll:			(#NtNamespaces1p &lt;&lt; #store &gt;&gt; '&lt;nt&gt;NameSpaces: &lt;1p&gt;' expandMacrosWith: (packagesToRemove inject: 0 into: [:sum :each | sum + each allNameSpaces size])).	aStream		nextPutAll:			(#NtClasses1p &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Classes: &lt;1p&gt;' expandMacrosWith: (packagesToRemove inject: 0 into: [:sum :each | sum + each allClasses size])).	aStream		nextPutAll:			(#NtMethods1p &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Methods: &lt;1p&gt;' expandMacrosWith: (packagesToRemove inject: 0 into: [:sum :each | sum + each methods size])).	aStream		nextPutAll:			(#NtSharedVariables1pN &lt;&lt; #store &gt;&gt; '&lt;nt&gt;Shared Variables: &lt;1p&gt;&lt;n&gt;'				expandMacrosWith: (packagesToRemove inject: 0 into: [:sum :each | sum + each sharedVariables size]))</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>initialize-release</category><body package="Store-Database" selector="bundlesToRemove:">bundlesToRemove: aCollectionOfBundles	| storeBundles |	storeBundles := aCollectionOfBundles collect: 		[:each | 		each isGlorpObject ifTrue: [each] ifFalse: [each asStorePundleIn: session]].	storeBundles do:		[:each | 		each blessingLevelNumber = -54 ifFalse:			[self setBlessingForRemoval: each]].</body><body package="Store-Database" selector="collectGarbage">collectGarbage		| stream packageKeys |	self gatherPackagesFromDatabase.	self gatherBundlesFromDatabase.	stream := (String new: 1000) writeStream.	self printInitialStatisticsTo: stream.	Transcript		cr;		show: stream contents.	packageKeys := packagesToRemove collect: [:each | each primaryKey].	self collectMethodsFrom: packageKeys.	self collectNameSpacesFrom: packageKeys.	self collectSharedsFrom: packageKeys.	self collectClassesFrom: packageKeys.	self collectBlessingBlobsFrom: packagesToRemove.	self collectBlessingBlobsFrom: bundlesToRemove.	self collectPackageDefinitions.	self collectBundleDefinitions.	self collectPackageContentsDefinitions.	bundlesToAdopt := self substituteParentsFor: bundlesToRemove.	packagesToAdopt := self substituteParentsFor: packagesToRemove.	methodsToAdopt := self substituteParentsFor: (methodsToRemove collect: [:each | each definition]).	sharedsToAdopt := self substituteParentsFor: (sharedsToRemove collect: [:each | each definition]).	classesToAdopt := self substituteParentsFor: (classesToRemove collect: [:each | each definition]).	nameSpacesToAdopt := self substituteParentsFor: (nameSpacesToRemove collect: [:each | each definition]).	self removeRecords.	stream := (String new: 1000) writeStream.	self printFinalStatisticsTo: stream.	Transcript		cr;		show: stream contents</body><body package="Store-Database" selector="initialize">initialize		methodsToRemove := Set new: 1000.	sharedsToRemove := Set new: 1000.	blobObjectsToRemove := Set new: 1000.	classesToRemove := Set new: 500.	nameSpacesToRemove := Set new: 100.	parcelRecordsToRemove := Set new: 100.	binaryDefinitionsToRemove := Set new: 200.	blessingsToRemove := Set new: 200.	propertiesToRemove := Set new: 100.	session := StoreLoginFactory currentStoreSession.</body><body package="Store-Database" selector="packagesToRemove:">packagesToRemove: aCollectionOfPackages	| storePackages |	storePackages := aCollectionOfPackages collect: 		[:each | 		each isGlorpObject ifTrue: [each] ifFalse: [each asStorePundleIn: session]].	storePackages do:		[:each | 		each blessingLevelNumber = -54 ifFalse:			[self setBlessingForRemoval: each]].</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>private</category><body package="Store-Database" selector="allObjectsOf:in:">allObjectsOf: aStoreObjectInPackageClass in: aCollectionOfKeys	| results |	results := OrderedCollection new: aCollectionOfKeys size * 1000.	1 to: aCollectionOfKeys size by: 100 do:		[:index |		| subsetKeys query |		subsetKeys := aCollectionOfKeys copyFrom: index to: (index + 99 min: aCollectionOfKeys size).		query := Query read: aStoreObjectInPackageClass where: [:each | each definition primaryKey in: subsetKeys].		query alsoFetch: #definition.		results addAll: (session execute: query)].	^results</body><body package="Store-Database" selector="clearRelationshipRecords">clearRelationshipRecords	"Create tw_pkgclasses records for all relationship entries, and delete 'em	Create tw_methods records for all relationship enteries, and delete 'em"	| relationships packageKeys packageType bundleKeys bundleType |	packageKeys := packagesToRemove collect: #primaryKey.	relationships := OrderedCollection new.	bundleKeys := bundlesToRemove collect: #primaryKey.	relationships addAll: (session 		read: StoreBundleSubBundleRelationship 		where: 			[:eachRelationship | 			(eachRelationship subbundleID in: bundleKeys) OR:			(eachRelationship bundleID in: bundleKeys)]).	relationships addAll: (session 		read: StoreBundlePackageRelationship 		where: 			[:eachRelationship | 			(eachRelationship packageID in: packageKeys) OR:			(eachRelationship bundleID in: bundleKeys)]).	packageType := StorePackage propertyTypeCode.	relationships addAll: (session 		read: StorePundlePropertyRelationship 		where: 			[:eachRelationship | 			((eachRelationship pundleID in: packageKeys) AND: (eachRelationship recordType = packageType))]).	bundleType := StoreBundle propertyTypeCode.	relationships addAll: (session 		read: StorePundlePropertyRelationship 		where: 			[:eachRelationship | 			((eachRelationship pundleID in: bundleKeys) AND: (eachRelationship recordType = bundleType))]).	session deleteAll: relationships</body><body package="Store-Database" selector="collectBinaryDefinitions">collectBinaryDefinitions	"Collect parcelRecords and their binary data. 	There can only be one referece to a parcelRecord and it's data."		packagesToRemove do:		[:each | 		each binaryVersion ifNotNil:			[ | parcelRecord |			parcelRecordsToRemove add: (parcelRecord := each basicParcel).			binaryDefinitionsToRemove				add: parcelRecord blob;				add: parcelRecord source]]</body><body package="Store-Database" selector="collectBlessingBlobsFrom:">collectBlessingBlobsFrom: aCollectionOfPundles	"Check blessings. Note that blessings are not shared among packages/bundles nor do 	blessings share definitions, so all blessings attached to removed packages should 	be removed.	We still want to collect records for comments."		aCollectionOfPundles do:		[:eachPundle | 		blessingsToRemove addAll: eachPundle blessings.		eachPundle blessings do:			[:blessing | 			| blob |			blob := blessing basicComment.			blob ifNotNil: [blobObjectsToRemove add: blob]]]</body><body package="Store-Database" selector="collectBundleDefinitions">collectBundleDefinitions	"Mark definitions used only by the removed bundles."		bundlesToRemove do:		[:eachBundle | 		(Array with: eachBundle basicComment with: eachBundle propertiesBlob) do:			[:eachBlob | 			(eachBlob isNil or: [blobObjectsToRemove includes: eachBlob]) ifFalse:				[| bundles |				bundles := session 					readManyOf: StoreBundle 					where: [:each | each comment = eachBlob OR: each propertiesBlob = eachBlob].				bundles 					detect: [:eachRelatedBundle | (bundlesToRemove includes: eachRelatedBundle) not] 					ifNone: [blobObjectsToRemove add: eachBlob]]]].	bundlesToRemove do:		[:eachBundle |		| properties |		properties := eachBundle propertiesRecordDictionary.		properties copy keysAndValuesDo:			[:eachKey :eachProperty |			| sharingBundle targetPrimaryKey bundles |			targetPrimaryKey := eachProperty primaryKey.			bundles := session 				readManyOf: StoreBundle				where: [:each | each propertiesRecordDictionary primaryKey = targetPrimaryKey].			sharingBundle := bundles reject: [:each | bundlesToRemove includes: each].			sharingBundle isEmpty ifTrue: 				[propertiesToRemove add: eachProperty.				blobObjectsToRemove add: eachProperty basicDefinition].			properties removeKey: eachKey]].	bundlesToRemove do:		[:eachBundle |		eachBundle bundles copy keysAndValuesDo:			[:eachSubKey :eachSubBundle |			eachBundle bundles removeKey: eachSubKey]].	bundlesToRemove do:		[:eachBundle |		eachBundle packages copy keysAndValuesDo:			[:eachSubKey :eachSubPackage |			eachBundle packages removeKey: eachSubKey]]</body><body package="Store-Database" selector="collectClassDefinitions">collectClassDefinitions	"At this point we have all classes that we want to remove, so 	we can find out comments &amp; definitions that are used only by them."		classesToRemove do:		[:eachClass | 		(Array with: eachClass definition basicComment with: eachClass definition basicDefinition) do:			[:eachBlob |			(eachBlob isNil or: [blobObjectsToRemove includes: eachBlob]) ifFalse:				[ | classes |				classes := session					readManyOf: StoreClassDefinitionInPackage					where: [:each | each definition comment = eachBlob OR: each definition definition = eachBlob].				classes					detect: [:eachRelatedClass | (classesToRemove includes: eachRelatedClass) not]					ifNone: [blobObjectsToRemove add: eachBlob]]]].	classesToRemove do:		[:eachClass | 		(Array with: eachClass metaclass basicComment with: eachClass metaclass basicDefinition) do:			[:eachBlob |			(eachBlob isNil or: [blobObjectsToRemove includes: eachBlob]) ifFalse:				[ | classes |				classes := session					readManyOf: StoreClassDefinitionInPackage					where: [:each | each metaclass comment = eachBlob OR: each metaclass definition = eachBlob].				classes					detect: [:eachRelatedClass | (classesToRemove includes: eachRelatedClass) not]					ifNone: [blobObjectsToRemove add: eachBlob]]]]</body><body package="Store-Database" selector="collectClassesFrom:">collectClassesFrom: aCollectionOfPrimaryKeys	"First check all classes defined in packages. If a class is used only by packages 	that are to be removed then mark it for removal."	| targetKeys targetObjects |	targetKeys := packagesToRemove inject: Set new into:		[:sum :each |		sum addAll: (each classDefinitions collect: [:eachClassDefinition | eachClassDefinition primaryKey]).		sum].	targetObjects := self allObjectsOf: StoreClassDefinitionInPackage in: targetKeys asOrderedCollection.	classesToRemove := self objectsOnlyIn: aCollectionOfPrimaryKeys from: targetObjects.	metaClassesToRemove := self metaClassObjectsOnlyIn: aCollectionOfPrimaryKeys from: targetObjects.</body><body package="Store-Database" selector="collectMethodDefinitions">collectMethodDefinitions	"At this point we have all methods that we want to remove, so add the definitions that	are not shared with other methods."	methodsToRemove  do:		[:eachMethod | 		| eachBlob |		eachBlob := eachMethod definition basicSource.		(eachBlob isNil or: [blobObjectsToRemove includes: eachBlob]) ifFalse:			[ | methods |			methods := session				readManyOf: StoreMethodInPackage				where: [:each | each definition source = eachBlob].			methods				detect: [:eachRelatedMethod | (methodsToRemove includes: eachRelatedMethod) not]				ifNone: [blobObjectsToRemove add: eachBlob]]]</body><body package="Store-Database" selector="collectMethodsFrom:">collectMethodsFrom: aCollectionOfPrimaryKeys	"First check all methods defined in a package. If a method is used only by packages 	that are to be removed that are then mark it for removal."	| targetKeys targetObjects |	targetKeys := packagesToRemove inject: Set new into:		[:sum :each |		sum addAll: (each methods collect: [:eachMethod | eachMethod primaryKey]).		sum].	targetObjects := self allObjectsOf: StoreMethodInPackage in: targetKeys asOrderedCollection.	methodsToRemove := self objectsOnlyIn: aCollectionOfPrimaryKeys from: targetObjects</body><body package="Store-Database" selector="collectNameSpaceDefinitions">collectNameSpaceDefinitions	"At this point we have all namespaces that we want to remove, so 	we can find out comments &amp; definitions that are used only by them."	nameSpacesToRemove do:		[:eachNamespace | 		(Array with: eachNamespace definition basicComment with: eachNamespace definition basicDefinition) do:			[:eachBlob |			(eachBlob isNil or: [blobObjectsToRemove includes: eachBlob]) ifFalse:				[ | nameSpaces |				nameSpaces := session					readManyOf: StoreNamespaceInPackage					where: [:each | each definition comment = eachBlob OR: each definition definition = eachBlob].				nameSpaces					detect: [:eachRelatedNamespace | (nameSpacesToRemove includes: eachRelatedNamespace) not]					ifNone: [blobObjectsToRemove add: eachBlob]]]]</body><body package="Store-Database" selector="collectNameSpacesFrom:">collectNameSpacesFrom: aCollectionOfPrimaryKeys	"First check all namespaces defined in packages. If a namespace is used only by packages 	that are to be removed then mark it for removal."	| targetKeys targetObjects |	targetKeys := packagesToRemove inject: Set new into:		[:sum :each |		sum addAll: (each nameSpaces collect: [:eachNameSpace | eachNameSpace primaryKey]).		sum].	targetObjects := self allObjectsOf: StoreNamespaceInPackage in: targetKeys asOrderedCollection.	nameSpacesToRemove := self objectsOnlyIn: aCollectionOfPrimaryKeys from: targetObjects</body><body package="Store-Database" selector="collectPackageContentsDefinitions">collectPackageContentsDefinitions	"At this point we have all classes, methods and data that we want to remove, so 	we can find out definitions that are used only by these classes, methods and data."	self collectClassDefinitions.	self collectNameSpaceDefinitions.	self collectMethodDefinitions.	self collectSharedDefinitions.	self collectBinaryDefinitions.</body><body package="Store-Database" selector="collectPackageDefinitions">collectPackageDefinitions	"Mark definitions used only by the removed bundles."		packagesToRemove do:		[:eachPackage | 		(Array with: eachPackage basicComment with: eachPackage propertiesBlob) do:			[:eachBlob | 			(eachBlob isNil or: [blobObjectsToRemove includes: eachBlob]) ifFalse:				[| packages sharingPackages |				packages := session 					readManyOf: StorePackage					where: [:each | each comment = eachBlob OR: each propertiesBlob = eachBlob].				sharingPackages := packages reject: [:each | packagesToRemove includes: each].				sharingPackages isEmpty ifTrue: [blobObjectsToRemove add: eachBlob]]]].	packagesToRemove do:		[:eachPackage |		| properties |		properties := eachPackage propertiesRecordDictionary.		properties copy keysAndValuesDo:			[:eachKey :eachProperty |			| sharingPackages targetPrimaryKey packages |			targetPrimaryKey := eachProperty primaryKey.			packages := session 				readManyOf: StorePackage				where: [:each | each propertiesRecordDictionary primaryKey = targetPrimaryKey].			sharingPackages := packages reject: [:each | packagesToRemove includes: each].			sharingPackages isEmpty ifTrue: 				[propertiesToRemove add: eachProperty.				blobObjectsToRemove add: eachProperty basicDefinition].			properties removeKey: eachKey]].</body><body package="Store-Database" selector="collectSharedDefinitions">collectSharedDefinitions	"At this point we have all data that we want to remove, so 	we can find out definitions that are used only by these data."	sharedsToRemove  do:		[:eachShared | 		(Array with: eachShared definition basicComment with: eachShared definition basicDefinition) do:			[:eachBlob |			(eachBlob isNil or: [blobObjectsToRemove includes: eachBlob]) ifFalse:				[ | sharedVariables |				sharedVariables := session					readManyOf: StoreSharedVariableInPackage					where: [:each | each definition comment = eachBlob OR: each definition definition = eachBlob].				sharedVariables					detect: [:eachRelatedClass | (sharedsToRemove includes: eachRelatedClass) not]					ifNone: [blobObjectsToRemove add: eachBlob]]]]</body><body package="Store-Database" selector="collectSharedsFrom:">collectSharedsFrom: aCollectionOfPrimaryKeys	"First check all data defined in a package. If a datum is used only by packages 	that are to be removed that are then mark it for removal."	| targetKeys targetObjects |	targetKeys := packagesToRemove inject: Set new into:		[:sum :each |		sum addAll: (each sharedVariables collect: [:eachSharedVariable | eachSharedVariable primaryKey]).		sum].	targetObjects := self allObjectsOf: StoreSharedVariableInPackage in: targetKeys asOrderedCollection.	sharedsToRemove := self objectsOnlyIn: aCollectionOfPrimaryKeys from: targetObjects</body><body package="Store-Database" selector="gatherBundlesFromDatabase">gatherBundlesFromDatabase	bundlesToRemove := StoreBundle allVersionsWithBlessingLevel: -54 in: session</body><body package="Store-Database" selector="gatherPackagesFromDatabase">gatherPackagesFromDatabase	packagesToRemove := StorePackage allVersionsWithBlessingLevel: -54 in: session</body><body package="Store-Database" selector="metaClassObjectsOnlyIn:from:">metaClassObjectsOnlyIn: aCollectionOfPrimaryKeys from: aCollectionOfObjectsInPackage	"A metaclass definition can be shared with its parent (often are!)	So, we only delete the metaclass objects that are NOT shared in another package"	| objectsForDeletion |	objectsForDeletion := Set new: aCollectionOfObjectsInPackage size.	aCollectionOfObjectsInPackage do:		[:eachObject |		| query queryKeys |		query := Query 			read: StoreClassDefinitionInPackage 			where: [:each | each metaclass primaryKey = eachObject metaclass primaryKey].		query retrieve: [:each | each package primaryKey].		queryKeys := session execute: query.		(queryKeys allSatisfy: [:each | aCollectionOfPrimaryKeys includes: each])			ifTrue: [objectsForDeletion add: eachObject metaclass]].	^objectsForDeletion asOrderedCollection</body><body package="Store-Database" selector="objectsOnlyIn:from:">objectsOnlyIn: aCollectionOfPrimaryKeys from: aCollectionOfObjectsInPackage	| objectsForDeletion definitionsNotToBeDeleted |	definitionsNotToBeDeleted := Set new: aCollectionOfObjectsInPackage size.	objectsForDeletion := Set new: aCollectionOfObjectsInPackage size.	aCollectionOfObjectsInPackage do:		[:eachObject |		eachObject package ifNotNil:			[(aCollectionOfPrimaryKeys includes: eachObject package primaryKey)				ifTrue: 					[(definitionsNotToBeDeleted includes: eachObject definition) ifFalse: 						[objectsForDeletion add: eachObject]]				ifFalse: 					[ | targets |					definitionsNotToBeDeleted add: eachObject definition.					targets := objectsForDeletion select: [:each | each definition primaryKey = eachObject primaryKey].					targets do: [:each | objectsForDeletion remove: each ifAbsent: [nil]]]]].	^objectsForDeletion asOrderedCollection</body><body package="Store-Database" selector="performAdoptionFor:in:">performAdoptionFor: aCollectionOfPairs in: aSession	"Change parent relationship to reflect removed records"		aCollectionOfPairs do: 		[:childAndParent | 		aSession register: childAndParent first.		aSession register: childAndParent last.		childAndParent first previous: childAndParent last]</body><body package="Store-Database" selector="removeFileRecordsFor:">removeFileRecordsFor: aCollection	"Remove all of the artificats in the database that are associated with any files attached	 to the passed in bundles.	This is slow but sure, since it has to collect up all versions, which may be big or tiny"		| binaryBlobs fileRecords queryObject pundleKeys |	aCollection isEmpty ifTrue: [^self].	fileRecords := Set new.	aCollection do:		[:eachPundle |		fileRecords addAll: eachPundle files].	queryObject := aCollection any.	pundleKeys := aCollection collect: [:each | each primaryKey].	fileRecords copy do:		[:each |		((queryObject allVersionPrimaryKeysWithFile: each) allSatisfy: [:eachKey | pundleKeys includes: eachKey])			ifFalse: [fileRecords remove: each ifAbsent: [nil]]].	fileRecords isEmpty ifTrue: [^self].	binaryBlobs := fileRecords collect: [:each | each basicContents].	session deleteAll: binaryBlobs.	session deleteAll: fileRecords</body><body package="Store-Database" selector="removePropertyRecordsFor:">removePropertyRecordsFor: aCollection	"Remove all of the artificats in the database that are associated with any properties attached	 to the package or bundle.	There are four parts: 		Properties (the association between a pundle and the property record)		PropertyRecords themselves		Only one blob for the definition"	| blobObjects propertyObjects queryObject pundleKeys deleteablePropertyObjects |	aCollection isEmpty ifTrue: [^self].	blobObjects := Set new.	propertyObjects := Set new.	aCollection do:		[:eachPundle |		| propertyDictionary |		propertyDictionary := eachPundle propertiesRecordDictionary.		propertyObjects addAll: propertyDictionary values].	queryObject := aCollection any.	pundleKeys := aCollection collect: [:each | each primaryKey].	deleteablePropertyObjects := propertyObjects select:		[:each |		(queryObject sharesProperty: each) not or: 			[(queryObject allVersionPrimaryKeysWithProperty: each) allSatisfy: 				[:eachKey | pundleKeys includes: eachKey]]].	deleteablePropertyObjects do: 		[:each |		each ifNotNil:			[(blobObjectsToRemove includes: each basicDefinition)				ifFalse: [blobObjects add: each basicDefinition].			(blobObjectsToRemove includes: each basicComment)				ifFalse: [blobObjects add: each basicComment]]].	session deleteAll: blobObjects.	session deleteAll: deleteablePropertyObjects.</body><body package="Store-Database" selector="removeRecords">removeRecords	"Perform removes and updates"	| success deniedCommands |	success := false.		deniedCommands := 	session accessor deniedCommands.	[session accessor permitEverything.	session inUnitOfWorkDo: 		[session deleteAll: blobObjectsToRemove.		session deleteAll: binaryDefinitionsToRemove.		session deleteAll: (methodsToRemove collect: [:each | each definition]).		session deleteAll: methodsToRemove.		session deleteAll: (sharedsToRemove collect: [:each | each definition]).		session deleteAll: sharedsToRemove.		session deleteAll: (classesToRemove collect: [:each | each definition]).		session deleteAll: ((classesToRemove collect: [:each | each metaclass]) select: [:each | metaClassesToRemove includes: each]).		session deleteAll: classesToRemove.		session deleteAll: (nameSpacesToRemove collect: [:each | each definition]).		session deleteAll: nameSpacesToRemove.		session deleteAll: parcelRecordsToRemove.		session deleteAll: blessingsToRemove.		session registerAll: packagesToRemove.		session deleteAll: packagesToRemove.		self clearRelationshipRecords.		self removePropertyRecordsFor: packagesToRemove.		self removePropertyRecordsFor: bundlesToRemove.		self removeFileRecordsFor: bundlesToRemove.		session deleteAll: bundlesToRemove.		session deleteAll: propertiesToRemove.		self performAdoptionFor: packagesToAdopt in: session.		self performAdoptionFor: bundlesToAdopt in: session.		self performAdoptionFor: classesToAdopt in: session.		self performAdoptionFor: nameSpacesToAdopt in: session.		self performAdoptionFor: methodsToAdopt in: session.		self performAdoptionFor: sharedsToAdopt in: session.		success := true]]			ensure: [session accessor deniedCommands: deniedCommands]." Some day, if we ever save the filename with the bin file, something like the below will be usable	success ifTrue:		[packagesToRemove do:			[:each | 			| fileName |			fileName := each fileNameForBinVersion.			fileName notNil ifTrue: [fileName delete]]]"</body><body package="Store-Database" selector="setBlessingForRemoval:">setBlessingForRemoval: aStorePundle	| specification |	specification := PublishSpecification dbPundle: aStorePundle.	specification publish: true.	specification blessing: -54.	specification publishBlessing.	aStorePundle currentBlessingLevel: -54.</body><body package="Store-Database" selector="substituteParentsFor:">substituteParentsFor: aCollectionOfObjectsToRemove	"Given a collection of records to remove collect those that will	become orphans. 	Answer a list of pairs of  each orphan and new parent (childID, newParentID).."		| objectsToAdopt knownObjects |	objectsToAdopt := List new.	knownObjects := aCollectionOfObjectsToRemove asSet.	aCollectionOfObjectsToRemove do:		[:eachObject | 		| parent children |		parent := eachObject parent.		[parent notNil and: [knownObjects includes: parent]]			whileTrue:				[| parentObject |				parentObject := parent parent.				parent := parentObject].		children := eachObject childrenIn: session.		children do:			[:eachChild | 			(knownObjects includes: eachChild) ifFalse: [objectsToAdopt add: (Array with: eachChild with: parent)]]].	^objectsToAdopt</body></methods><methods><class-id>Store.GarbageCollector class</class-id> <category>instance creation</category><body package="Store-Database" selector="collectGarbage">collectGarbage	| instance |	instance := self new.	instance collectGarbage.</body><body package="Store-Database" selector="new">new	^super new initialize</body><body package="Store-Database" selector="removeBundles:packages:">removeBundles: bundles packages: packages	"Remove the bundles and packages from the physical store."		self new		bundlesToRemove: bundles;		packagesToRemove: packages;		collectGarbage.</body></methods><methods><class-id>Store.Installing</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="actionText">actionText	^(#Installing &lt;&lt; #store &gt;&gt; 'Installing') asString</body></methods><methods><class-id>Store.PkgNameSpacesAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="blobData">blobData	^blobData</body><body package="Store-DB-Records" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.PkgNameSpacesAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="resetSession">resetSession	NameSpacesWithSourcesSession ifNotNil: 		[self brokerOrNil ifNotNil: [self broker dismissSession: NameSpacesWithSourcesSession].		NameSpacesWithSourcesSession := nil]</body><body package="Store-DB-Records" selector="sourcesSession">sourcesSession	"NameSpacesWithSourcesSession := nil"	( self isSessionValid: NameSpacesWithSourcesSession )		ifFalse: 	[ NameSpacesWithSourcesSession := self createSourcesSession ].	^NameSpacesWithSourcesSession</body></methods><methods><class-id>Store.PkgNameSpacesAndSourcesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="subCollectionClasses">subCollectionClasses	^Array with: self subCollectionClass.</body></methods><methods><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="buildSelectorSubcanvas">buildSelectorSubcanvas	| subcanvases |	subcanvases := self components.	(subcanvases size = 1 		and: [subcanvases first class = StoreSelectorNavigatorPart]) 			ifFalse: [self installSubcanvas: #selectorWithProtocolWindowSpec using: self]</body></methods><methods><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="categories">categories	| categories |	categories := self componentNamed: #categories.	categories isNil 		ifTrue: 			[categories := StoreSharedVariableProtocolNavigatorPart new.			navigator notNil ifTrue: [categories navigator: navigator].			self componentNamed: #categories put: categories].	^categories</body><body package="StoreForGlorpBrowserUI" selector="fillInState:">fillInState: aNavigatorState	aNavigatorState environment isNil		ifTrue: [aNavigatorState environment: self environment].	aNavigatorState type: type.	super fillInState: aNavigatorState</body><body package="StoreForGlorpBrowserUI" selector="protocols">protocols		| protocols |	protocols := self componentNamed: #protocols.	protocols isNil		ifTrue:			[protocols := StoreSelectorProtocolNavigatorPart new.			navigator notNil ifTrue: [protocols navigator: navigator].			self componentNamed: #protocols put: protocols].	^protocols</body><body package="StoreForGlorpBrowserUI" selector="selectors">selectors		| selectors |	selectors := self componentNamed: #selectors.	selectors isNil		ifTrue:			[selectors := StoreSelectorNavigatorPart new.			navigator notNil ifTrue: [selectors navigator: navigator].			self componentNamed: #selectors put: selectors].	^selectors</body><body package="StoreForGlorpBrowserUI" selector="selectorsWithProtocol">selectorsWithProtocol	| selectorsWithProtocol |	selectorsWithProtocol := self componentNamed: #selectorsWithProtocol.	selectorsWithProtocol isNil 		ifTrue: 			[selectorsWithProtocol := StoreSelectorNavigatorPart new.			selectorsWithProtocol listSelector: #allSelectorsIn:.			navigator notNil ifTrue: [selectorsWithProtocol navigator: navigator].			self componentNamed: #selectorsWithProtocol put: selectorsWithProtocol].	^selectorsWithProtocol</body><body package="StoreForGlorpBrowserUI" selector="sharedVariables">sharedVariables	| sharedVariables |	sharedVariables := self componentNamed: #sharedVariables.	sharedVariables isNil 		ifTrue: 			[sharedVariables := StoreSharedVariableNavigatorPart new.			navigator notNil ifTrue: [sharedVariables navigator: navigator].			self componentNamed: #sharedVariables put: sharedVariables].	^sharedVariables</body></methods><methods><class-id>Store.ReconcilingComparitor</class-id> <category>accumulate changes</category><body package="Store-Difference Management" selector="addClassChanges">addClassChanges	"Find and note class changes"	| classChange matchingClass |	pundleModel classesWithSource do: 		[:eachClass |		classChange := Change new classSymbol: eachClass absoluteName.		(storePundle includesClassNamed: eachClass absoluteName)			ifFalse: [workingChangeSet doClassChange: classChange add]			ifTrue: 				[matchingClass := storePundle classInPackageNamed: eachClass absoluteName meta: false.				eachClass definition = matchingClass definition ifFalse: 					[workingChangeSet doClassChange: classChange change].				(eachClass comment string equalsAcrossPlatforms: matchingClass comment string) ifFalse: 					[workingChangeSet doClassChange: classChange comment]]].	storePundle classesDefinedInPackage do: 		[:eachClass |		(pundleModel includesClassNamed: eachClass absoluteName) ifFalse: 			[classChange := Change new classSymbol: eachClass absoluteName.			workingChangeSet doClassChange: classChange removeDefinition]]</body><body package="Store-Difference Management" selector="addMethodChanges">addMethodChanges	"Add method changes to the change sets."	| methodChange matchingMethod |	pundleModel methodsWithSource do: 		[:eachMethod |		methodChange := (Change new)			classSymbol: eachMethod classNameWithMeta;			selector: eachMethod selector.		(storePundle includesMethod: eachMethod)			ifFalse: [workingChangeSet doSubdefChange: methodChange add]			ifTrue: 				[matchingMethod := storePundle					method: eachMethod selector					forClassNamed: eachMethod absoluteClassName					meta: eachMethod isMeta.				(eachMethod sourceMatches: matchingMethod) ifFalse: 					[workingChangeSet doSubdefChange: methodChange change]]].	storePundle methods do: 		[:eachMethod |		((pundleModel includesMethod: eachMethod) or: [pundleModel includesUninstalledMethod: eachMethod]) ifFalse: 			[methodChange := (Change new)				classSymbol: eachMethod classNameWithMeta;				selector: eachMethod selector.			workingChangeSet doSubdefChange: methodChange remove]]</body><body package="Store-Difference Management" selector="addNamespaceChange">addNamespaceChange	"Add def namespace changes to the change sets."	| namespaceChange matchingNamespace |	pundleModel nameSpacesWithSource do: 		[:eachNamespace |		namespaceChange := Change new nameSpaceSymbol: eachNamespace absoluteName.		(matchingNamespace := storePundle nameSpaceInPackageNamed: eachNamespace absoluteName) notNil			ifTrue: 				[eachNamespace definition = matchingNamespace definition ifFalse: 					[workingChangeSet doNameSpaceChange: namespaceChange change].				(eachNamespace comment equalsAcrossPlatforms: matchingNamespace comment) ifFalse: 					[workingChangeSet doNameSpaceChange: namespaceChange comment]]			ifFalse: [workingChangeSet doNameSpaceChange: namespaceChange add]].	storePundle nameSpacesDefinedInPackage do: 		[:eachNamespace |		(pundleModel includesNameSpaceNamed: eachNamespace absoluteName) ifFalse: 			[namespaceChange := Change new nameSpaceSymbol: eachNamespace absoluteName.			workingChangeSet doNameSpaceChange: namespaceChange removeDefinition]]</body><body package="Store-Difference Management" selector="addPropertyChanges">addPropertyChanges	"Add property changes to the changesets.	Ensure that we remove any property keys that are volatile or system only.  The list of 	these property keys has changed over time so there is no point tracking them."	| imageProperties databaseProperties |	imageProperties := pundleModel propertiesForFileOut.	databaseProperties := storePundle propertiesForFileOut.	CodeComponent systemOnlyPropertyKeys do: 		[:each |		imageProperties removeKey: each ifAbsent: [nil].		databaseProperties removeKey: each ifAbsent: [nil]].	imageProperties associationsDo: 		[:each |		((databaseProperties includesKey: each key) and: [each value = (databaseProperties at: each key)]) ifFalse: 			[workingChangeSet addPropertyChange: each key]].	databaseProperties keysDo: 		[:each |		(imageProperties includesKey: each) ifFalse: 			[workingChangeSet addPropertyChange: each]]</body><body package="Store-Difference Management" selector="addSharedChanges">addSharedChanges	"Add shared variable changes to the working change set."	| sharedChange matchingShared |	pundleModel dataWithSource do: 		[:eachShared |		sharedChange := Change new dataKey: eachShared dataKey.		eachShared isInClass			ifTrue: [sharedChange classSymbol: eachShared absoluteOwnerName asSymbol]			ifFalse: [sharedChange nameSpaceSymbol: eachShared absoluteOwnerName asSymbol].		sharedChange dataKey: eachShared dataKey.		(storePundle includesDatum: eachShared)			ifTrue: 				[matchingShared := storePundle datum: eachShared dataKey forOwnerNamed: eachShared absoluteOwnerName.				(eachShared sourceMatches: matchingShared) ifFalse: 					[workingChangeSet doSubdefChange: sharedChange change]]			ifFalse: [workingChangeSet doSubdefChange: sharedChange add]].	storePundle sharedVariables do: 		[:eachShared |		| ownerName |		ownerName := eachShared absoluteOwnerName asSymbol.		(pundleModel includesDatum: eachShared) ifFalse: 			[sharedChange := Change new dataKey: eachShared dataKey.			eachShared isInClass 				ifTrue: [sharedChange classSymbol: ownerName] 				ifFalse: [sharedChange nameSpaceSymbol: ownerName].			workingChangeSet doSubdefChange: sharedChange remove]]</body><body package="Store-Difference Management" selector="addStructureChanges">addStructureChanges	"Only called for bundles"		pundleModel structure = storePundle structure 		ifFalse: [workingChangeSet addOtherChange: BundleModel structureMark]</body><body package="Store-Difference Management" selector="reconcileBundle">reconcileBundle	(Reconciling for: storePundle) started.	self addStructureChanges.	self addPropertyChanges.	self reconcileBundleParts.	self updateDatabaseInformationInPundleModel.	(Reconciling for: storePundle) finished</body><body package="Store-Difference Management" selector="reconcileBundleParts">reconcileBundleParts	"We must call #initializeForReconcileWith: on the pundelModel to ensure it has a databaseInformation for this reconcile before we call #contentDescriptions on it.  If this is omitted, and the pundelModel does not already have a databaseInformation for the current database, #contentDescriptions will call #anyContentDescriptions which returns copies, not originals, so the setting of their traces and databaseIdentifiers below will be lost."	| databaseItems |	pundleModel initializeForReconcileWith: pundleModel.	storePundle makeProxiesForSubcomponents.	databaseItems := storePundle containedItems.	pundleModel contentDescriptions do:		[:eachContentDescription |		| subPundleModel matchingDatabasePundle |		subPundleModel := eachContentDescription component.		subPundleModel ifNotNil:			[subPundleModel hasTrace ifFalse:				[matchingDatabasePundle := databaseItems					detect: [:eachPundle | subPundleModel isBundle == eachPundle isBundle and: [subPundleModel name = eachPundle name]] 					ifNone: [nil].				matchingDatabasePundle ifNotNil: [self reconcileQuietly: subPundleModel against: matchingDatabasePundle]].				eachContentDescription id: subPundleModel dbTrace.				eachContentDescription dbIdentifier: storePundle dbIdentifier.		storePundle uninstantiateSubcomponentProxies]].</body><body package="Store-Difference Management" selector="reconcilePackage">reconcilePackage	"Compare the model and store, and put the change set into the model"	(Reconciling for: storePundle) started.	pundleModel cleanse: false.	self addClassChanges.	self addNamespaceChange.	self addMethodChanges.	self addSharedChanges.	self addPropertyChanges.	self updateDatabaseInformationInPundleModel.	(Reconciling for: storePundle) finished</body></methods><methods><class-id>Store.ReconcilingComparitor</class-id> <category>reconcile</category><body package="Store-Difference Management" selector="reconcile">reconcile	Registry cleanseModels.	pundleModel isBundle		ifTrue: [self reconcileBundle]		ifFalse: [self reconcilePackage]</body><body package="Store-Difference Management" selector="reconcileQuietly">reconcileQuietly		pundleModel isBundle 		ifTrue: [self reconcileBundle] 		ifFalse: [self reconcilePackage]</body></methods><methods><class-id>Store.ReconcilingComparitor</class-id> <category>private</category><body package="Store-Difference Management" selector="pundleModel:storePundle:">pundleModel: aPundleModel storePundle: aStorePundle	pundleModel := aPundleModel.	storePundle := aStorePundle.	workingChangeSet := XChangeSet new.</body><body package="Store-Difference Management" selector="reconcileQuietly:against:">reconcileQuietly: aPundleModel against: aStorePundle	self class reconcileQuietly: aPundleModel against: aStorePundle</body><body package="Store-Difference Management" selector="updateDatabaseInformationInPundleModel">updateDatabaseInformationInPundleModel		| databaseInformation |	databaseInformation := pundleModel databaseInformationOrCreate.	databaseInformation setDbTrace: nil.	databaseInformation changeSet: workingChangeSet.	pundleModel setDbTraceAndVersionUsing: storePundle for: databaseInformation dbIdentifier.	pundleModel databaseInformations removeKey: pundleModel noDbSymbol ifAbsent: [nil]</body></methods><methods><class-id>Store.ReconcilingComparitor class</class-id> <category>private</category><body package="Store-Difference Management" selector="reconcileQuietly:against:">reconcileQuietly: aPundleModel against: aStorePundle		| instance session newPundle |	instance := self new.	session := Store.Glorp.StoreLoginFactory currentStoreSession.	session system cachePolicy: Glorp.CachePolicy new.	newPundle := session readOneOf: aStorePundle yourSelf class where: [:each | each primaryKey = aStorePundle primaryKey].	instance pundleModel: aPundleModel storePundle: newPundle.	instance reconcileQuietly.	session reset.</body></methods><methods><class-id>Store.ReconcilingComparitor class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="reconcile:against:">reconcile: aPundleModel against: aStorePundle	| instance |	instance := self new.	instance pundleModel: aPundleModel storePundle: aStorePundle.	instance reconcile.</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>accessing-calculated</category><body package="Store-IMG-Configurations" selector="at:">at: aKey	"backward compatibility for when dictionary expected."	^self perform: aKey</body><body package="Store-IMG-Configurations" selector="at:ifAbsent:">at: aKey ifAbsent: aBlock	"backward compatibility for when dictionary expected. If absent (shouldn't be, but can), answer the value of the block"	(self respondsTo: aKey) ifFalse: [^aBlock value].	^self perform: aKey</body><body package="Store-IMG-Configurations" selector="basePath">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: self parcelDirectory ) asString</body><body package="Store-IMG-Configurations" selector="padded">padded	"compatibilty"	^self parcelPadded</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="binarySave">binarySave	^binarySave</body><body package="Store-IMG-Configurations" selector="binarySave:">binarySave: aBoolean	binarySave := aBoolean</body><body package="Store-IMG-Configurations" selector="bundleStructure">bundleStructure	^bundleStructure</body><body package="Store-IMG-Configurations" selector="bundleStructure:">bundleStructure: aBoolean	bundleStructure := aBoolean</body><body package="Store-IMG-Configurations" selector="databaseLinks">databaseLinks	^databaseLinks</body><body package="Store-IMG-Configurations" selector="databaseLinks:">databaseLinks: aBoolean	databaseLinks := aBoolean</body><body package="StoreForGlorpVWUI" selector="dbPundle">dbPundle	^object.</body><body package="Store-IMG-Configurations" selector="dbPundle:">dbPundle: aStorePundle	object := aStorePundle.	pundleModel := aStorePundle storeModel.	modified := publish := false.	parentVersion := object version.	version := object version.</body><body package="Store-IMG-Configurations" selector="mergeData">mergeData	^mergeData</body><body package="Store-IMG-Configurations" selector="mergeData:">mergeData: aMergeData	mergeData := aMergeData</body><body package="Store-IMG-Configurations" selector="parcelBackup">parcelBackup	^parcelBackup</body><body package="Store-IMG-Configurations" selector="parcelBackup:">parcelBackup: aBoolean	parcelBackup := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelDirectory">parcelDirectory	^parcelDirectory</body><body package="Store-IMG-Configurations" selector="parcelDirectory:">parcelDirectory: aFilename	parcelDirectory := aFilename</body><body package="Store-IMG-Configurations" selector="parcelHideSource">parcelHideSource	^parcelHideSource</body><body package="Store-IMG-Configurations" selector="parcelHideSource:">parcelHideSource: aBoolean	parcelHideSource := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelOverwrite">parcelOverwrite	^parcelOverwrite</body><body package="Store-IMG-Configurations" selector="parcelOverwrite:">parcelOverwrite: aBoolean	parcelOverwrite := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelPadded">parcelPadded	^parcelPadded</body><body package="Store-IMG-Configurations" selector="parcelPadded:">parcelPadded: aBoolean	parcelPadded := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelRepublish">parcelRepublish	^parcelRepublish</body><body package="Store-IMG-Configurations" selector="parcelRepublish:">parcelRepublish: aBoolean	parcelRepublish := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelSave">parcelSave	^parcelSave</body><body package="Store-IMG-Configurations" selector="parcelSave:">parcelSave: aBoolean	parcelSave := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelSaveSource">parcelSaveSource	^parcelSaveSource</body><body package="Store-IMG-Configurations" selector="parcelSaveSource:">parcelSaveSource: aBoolean	parcelSaveSource := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelVersionString">parcelVersionString	^parcelVersionString</body><body package="Store-IMG-Configurations" selector="parcelVersionString:">parcelVersionString: aString	parcelVersionString := aString</body><body package="StoreForGlorpVWUI" selector="privateSetDbPundle:">privateSetDbPundle: aStorePundle	object := aStorePundle.</body><body package="Store-IMG-Configurations" selector="publisher">publisher	^publisher</body><body package="Store-IMG-Configurations" selector="pundle:">pundle: aPundle	super pundle: aPundle.	aPundle isPackage ifTrue: [binarySave := aPundle hasRelatedParcel].</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>initialize-release</category><body package="Store-IMG-Configurations" selector="initialize">initialize	super initialize.	binarySave := false.	parcelSave := false.	bundleStructure := false.	databaseLinks := false.	parcelDirectory := ''.	parcelRepublish := false. 	parcelBackup := false. 	parcelOverwrite := false. 	parcelSaveSource := true. 	parcelHideSource := false. 	parcelPadded := false.</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>publishing</category><body package="Store-IMG-Configurations" selector="prepareBinary">prepareBinary		| packageModel |	self pundle isBundle ifTrue: [^self].	packageModel := self pundle storeModel.	packageModel propertyAt: #packageName put: packageModel name.	self pundle binFile: ''</body><body package="Store-IMG-Configurations" selector="publishBlessing">publishBlessing	"Create new blessing/comment records for the pundle."		| newBlessing previous session |	self publish ifFalse: [^true].	DbRegistry clearPundleCaches.	session := self pundle isGlorpObject		ifTrue: [self pundle session]		ifFalse: [StoreLoginFactory currentStoreSession].	publisher ifNil: 		[publisher := StorePundleWriter new.		publisher targetSession: session.		publisher splitPundles: false].	^[publisher pundle: (self pundle asStorePundleIn: publisher targetSession).	newBlessing := (StoreBlessing new)		blessingLevel: self blessing value;		comment: self comment asString.	previous := publisher pundle previous.	publisher pundle previous: previous.	publisher addBlessing: newBlessing.	true] value.		"on: Error 		do: [:exception | exception return: false]"</body><body package="Store-IMG-Configurations" selector="publishParcel">publishParcel		self pundle storeModel saveAsParcelFromSpecs: self</body><body package="Store-IMG-Configurations" selector="publishPundle">publishPundle	"Publish. Answer false if aborted."	| pundle |	(Publishing for: self) started.	pundle := self publishSilently.	(Publishing for: self) finished.	^pundle</body><body package="Store-IMG-Configurations" selector="publishSilently">publishSilently	^self publishSilentlyUsingSession: StoreLoginFactory currentStoreSession.</body><body package="Store-IMG-Configurations" selector="publishSilentlyUsingSession:">publishSilentlyUsingSession: aSession	"Publish. Answer false if aborted."		| newPundle currentPundleModel targetPundles |	self publish ifFalse: [^nil].	DbRegistry clearPundleCaches.	publisher ifNil:		[publisher := StorePundleWriter new.		publisher targetSession: aSession.		publisher splitPundles: false].	self binarySave ifFalse:		[currentPundleModel := self pundleModel.		currentPundleModel runPreSave.		currentPundleModel isBundle ifFalse:			[currentPundleModel allDefinedClasses do: [:eachClass | eachClass preSave: currentPundleModel]]].	Dialect reset.	^[targetPundles := self updateStorePundleItems.	newPundle := [publisher writePundle: self pundle withChangesBasedOn: self pundle storeModel using: targetPundles]		on: GlorpDatabaseWriteError		do: 			[:exception |			StorePublishingError raiseErrorString: exception messageText.			exception return: nil].	newPundle ifNil: [^nil].	newPundle applyPundleVersionsToTheImage.	self parcelSave ifTrue: [self publishParcel].	newPundle ifNotNil:		[newPundle storeModel markNotModified].	newPundle] value</body><body package="Store-IMG-Configurations" selector="updateStorePundleItems">updateStorePundleItems		| pundle commentString storeBlessing newPundle currentPundle |	currentPundle := self pundle storeModel asStorePundleIn: publisher targetSession.	newPundle := currentPundle storeModel asNewStorePundleIn: currentPundle session.	self privateSetDbPundle: newPundle.	self binarySave 		ifTrue: [self prepareBinary]		ifFalse: [self pundle isPackage ifTrue: [self pundle binFile: nil]].	self publish ifFalse: [^self].	pundle := self pundle.	pundle version: self version.	storeBlessing := StoreBlessing new.	storeBlessing blessingLevel: self blessing.	commentString := self comment asString.	commentString isEmpty ifFalse: [storeBlessing comment: commentString].	pundle bless: storeBlessing.	pundle timestamp: (Dialect storeTimestampIn: publisher targetSession).	^Array with: pundle</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>private</category><body package="Store-IMG-Configurations" selector="setPublisher:">setPublisher: aStorePundleWriter	publisher := aStorePundleWriter</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>testing</category><body package="Store-IMG-Configurations" selector="isConsistentForPublishing">isConsistentForPublishing	"If it has been modified and marked for publishing we say Ok, you pass	If it has NOT been modified no matter if it is marked for publishing or not, we say OK, you pass.	Otherwise, fail"	^self pundleModel isNil or:		[(self pundleModel hasBeenModified and: [self publish]) or:		[self pundleModel hasBeenModified not]]</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>As yet unclassified</category><body package="Store-IMG-Configurations" selector="pundle:binary:">pundle: aStorePundleModel binary: aBoolean 	super pundle: aStorePundleModel.	aStorePundleModel isPackage ifTrue: [binarySave := aBoolean].</body></methods><methods><class-id>Store.PublishSpecification class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="dbPundle:">dbPundle: aPundle	^self new dbPundle: aPundle</body><body package="Store-IMG-Configurations" selector="new">new	^self basicNew initialize.</body><body package="Store-IMG-Configurations" selector="pundle:">pundle: aPundle	^(aPundle isLoaded and: [aPundle isImageObject])		ifTrue: [self new pundle: aPundle]		ifFalse: [self dbPundle: aPundle]</body><body package="Store-IMG-Configurations" selector="pundle:binary:">pundle: aPundle binary: aBoolean	^(aPundle isLoaded and: [aPundle isImageObject])		ifTrue: [self new pundle: aPundle binary: aBoolean]		ifFalse: [self dbPundle: aPundle]</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>actions</category><body package="Store-UI" selector="quitLoading">quitLoading	result := #quitLoading.	self accept value: true.</body><body package="Store-UI" selector="skipPrerequisite">skipPrerequisite	result := #skip.	self accept value: true.</body><body package="Store-UI" selector="tryParcel">tryParcel	result := #tryParcel.	self accept value: true.</body><body package="Store-UI" selector="useSelection">useSelection	self selections selection ifNil: [^self].	result := self selections selection.	self accept value: true.</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>interface opening</category><body package="Store-UI" selector="displayPundleLabelUsing:blessingAt:timestampAt:in:">displayPundleLabelUsing: aPundle blessingAt: blessingStart timestampAt: timestampStart in: aSequenceView		| nameLabel currentStart blessingLabel timestampLabel mainThing |	currentStart := 1.	nameLabel := Label with: aPundle displayString asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + blessingStart + 8.	blessingLabel := Label with: aPundle blessingLevelString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + timestampStart + 12.	timestampLabel := Label with: aPundle timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: nameLabel;		add: blessingLabel;		add: timestampLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="openFrom:">openFrom: aSpec 	"Open a dialog based on aSpec.  If the windowing system is not active	 then simply accept."	WindowingSystem isActive ifFalse: [^accept value].	self allButOpenFrom: aSpec.	builder openDialog.	^result ifNil: [#quitLoading]</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder		| widget blessingStart timestampStart |	(aBuilder componentAt: #PrereqList) widget displayStringSelector: #itemStringWithBlessing.	selections list first isBundle ifTrue: 		[(aBuilder componentAt: #TryParcel) widget labelString: #TryPackage &lt;&lt; #store &gt;&gt; 'Try Package'.		(aBuilder componentAt: #PromptLabel) widget labelString: #ChooseBundlePrereq &lt;&lt; #store &gt;&gt; 'Choose a Bundle version to fullfill prerequiste:'].	widget := (aBuilder componentAt: #PrereqList) widget.	blessingStart := 0.	timestampStart := 0.	selections list		do:			[:each | 			blessingStart := (Label with: each displayString asText allBold attributes: widget textStyle) width max: blessingStart.			timestampStart := (Label with: each blessingLevelString asText attributes: widget textStyle) width max: timestampStart].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self displayPundleLabelUsing: (view sequence at: index) blessingAt: blessingStart timestampAt: timestampStart in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self displayPundleLabelUsing: (view sequence at: index) blessingAt: blessingStart timestampAt: timestampStart in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>accessing</category><body package="Store-UI" selector="result">result	^result</body></methods><methods><class-id>Store.PrerequisiteSelector</class-id> <category>aspects</category><body package="Store-UI" selector="selections">selections	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selections isNil		ifTrue:			[selections := SelectionInList new]		ifFalse:			[selections]</body></methods><methods><class-id>Store.PrerequisiteSelector class</class-id> <category>interface opening</category><body package="Store-UI" selector="openWith:">openWith: aCollectionOfStorePundle	| instance |	instance := self new.	instance selections list: aCollectionOfStorePundle asList.	^instance open</body></methods><methods><class-id>Tools.SinglePropertyView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="isAddition">isAddition	^isAddition</body><body package="Store-Code Comparison" selector="isAddition:">isAddition: aBoolean	isAddition := aBoolean</body><body package="Store-Code Comparison" selector="property:">property: aPropertyBlueprint	property := aPropertyBlueprint</body></methods><methods><class-id>Tools.SinglePropertyView</class-id> <category>row population</category><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	| view |	view := TextEditorView model: property value printString asValue.	view beReadOnly.	^Array with: view</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| header |	super populateHeader.	header := self header.	header add: (isAddition				ifTrue: [ComparisonIcons add]				ifFalse: [ComparisonIcons remove]).	header add: (Label with: property key asText allBold)</body></methods><methods><class-id>Tools.SinglePropertyView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^Array with: #singleCodeComponentProperty with: property key</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>menu</category><body package="Store-UI" selector="oneItemAndInImage">oneItemAndInImage	| selection |	^self onlyOneItemSelected and: 		[selection := self itemsInList selections first.		selection package storeModel notNil]</body><body package="Store-UI" selector="onlyOneItemSelected">onlyOneItemSelected	^self itemsInList selections size = 1</body><body package="Store-UI" selector="onlyTwoItemsSelected">onlyTwoItemsSelected	^self itemsInList selections size = 2</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>actions</category><body package="Store-UI" selector="browseSelectedVersion">browseSelectedVersion	| package classes class |	package := (class := self itemsInList selections first) package.	classes := OrderedCollection with: class.	Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: ((StoreForGlorpBrowserEnvironment on: package) forClasses: classes)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false</body><body package="Store-UI" selector="compareSelectionWith">compareSelectionWith	| class target |	class := self itemsInList selections first.	target := class class selectStoreVersionOf: class name in: class package session.	target ifNotNil: [TextDifferenceBrowser compare: class definitionString with: target definitionString]</body><body package="Store-UI" selector="compareVersions">compareVersions	| class target |	class := self itemsInList selections first.	target := self itemsInList selections last.	target ifNil: [^self].	TextDifferenceBrowser compare: class definitionString with: target definitionString</body><body package="Store-UI" selector="containingPackages">containingPackages	| class packages |	class := self itemsInList selections first.	[(Gathering for: class name) started.	packages := StoreClassDefinitionInPackage allPackagesContaining: class.	(Gathering for: class name) finished] withStoreFeedbackOn: tool mainWindow.	DefinitionForListTool forPackages: packages containingString: class longNameFromSmalltalk</body><body package="Store-UI" selector="fileOutClass">fileOutClass	| class fileName fileManager |	class := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (class longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: class package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager deferInitializations.			class fileOutOn: fileManager.			fileManager finishInitializations]				ensure: [fileManager close].			(FilingOut for: class package) finished].</body><body package="Store-UI" selector="fileOutOnlyClassDefinition">fileOutOnlyClassDefinition	| class fileName fileManager |	class := self itemsInList selections first.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (class longNameFromSmalltalk replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: class package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			class fileOutDefinitionOn: fileManager.			fileManager comment: class value: class comment]				ensure: [fileManager close].			(FilingOut for: class package) finished].</body><body package="Store-UI" selector="loadClass">loadClass		| package class imageModel methodsToRemove fullClass sharedsToRemove |	class := self itemsInList selections first.	package := class package.	imageModel := package storeModel.	fullClass := package fullClassForClass: class.	methodsToRemove := self methodsInClass: class notIn: imageModel.	sharedsToRemove := self sharedsInClass: class notIn: imageModel.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: 					[fullClass loadSource.					methodsToRemove do: [:each | each implementingClass removeSelector: each selector].					sharedsToRemove do: [:each | each absoluteName asQualifiedReference removeFromSystem]].			(Loading for: package) finished].</body><body package="Store-UI" selector="loadOnlyClassDefinition">loadOnlyClassDefinition		| package class |	class := self itemsInList selections first.	package := class package.	StoreProgressOverlay		subsume: builder window		while:			[(Loading for: package) started.			Store.Policies packagePolicy 				forcePackage: package storeModel				while: [class loadSource].			(Loading for: package) finished].</body><body package="Store-UI" selector="selectionsUpdated">selectionsUpdated		| updateText |	updateText := TextStream on: String new.	self itemsInList selections size &gt; 0 ifTrue:		[self itemsInList selections do:			[:each | 			updateText emphasis: #bold.			updateText nextPutAll: each longName.			updateText emphasis: #none.			updateText cr.			updateText nextPutAll: each definition definitionString.			updateText cr.			updateText cr.			updateText emphasis: (Array with: #color -&gt; ColorValue navy).			updateText nextPutAll: each definition comment.			updateText cr].		self updateStatusUsing: self itemsInList selections first package].	self updateTextPaneWith: updateText contents</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>interface opening</category><body package="Store-UI" selector="compositeViewUsing:nameSize:longestTimestamp:longestUsername:in:">compositeViewUsing: aClass nameSize: longestName longestTimestamp: longestTimestamp longestUsername: longestUsername in: aSequenceView	| iconPart currentStart nameLabel timestampLabel mainThing usernameLabel packageNameLabel |	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aClass toolListIcon.	currentStart := iconPart width + 2.	nameLabel := Label with: aClass longNameFromSmalltalk asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestName + 8.	timestampLabel := Label with: aClass definition timeStampString asText attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing := CompositePart new.	currentStart := currentStart + longestTimestamp + 8.	usernameLabel := Label with: aClass definition username asText attributes: aSequenceView textStyle offset: currentStart @ 0.	currentStart := currentStart + longestUsername + 8.	packageNameLabel := Label with: aClass package name asText allBold attributes: aSequenceView textStyle offset: currentStart @ 0.	mainThing		add: iconPart;		add: nameLabel;		add: timestampLabel;		add: usernameLabel;		add: packageNameLabel;		yourself.	^mainThing</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpListViewWith: aBuilder</body><body package="Store-UI" selector="setUpListViewWith:">setUpListViewWith: aBuilder	"First we measure 4 things... 		The largest size of the package names, 		the largest size of the version string, 		the largest size of a blessing name 		the largest size of a timestamp"		| widget items longestName longestTimestamp longestUsername |	widget := (aBuilder componentAt: #SelectionList) widget.	items := self itemsInList list.	longestName := longestTimestamp := longestUsername := 0.	items do:		[:each | 		longestTimestamp := (Label with: each definition timeStampString asText attributes: widget textStyle) width max: longestTimestamp.		longestUsername := (Label with: each definition username asText attributes: widget textStyle) width max: longestUsername.		longestName := (Label with: each longNameFromSmalltalk asText allBold attributes: widget textStyle) width max: longestName].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self				compositeViewUsing: (view sequence at: index)				nameSize: longestName				longestTimestamp: longestTimestamp				longestUsername: longestUsername				in: view.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>private</category><body package="Store-UI" selector="methodsInClass:notIn:">methodsInClass: aClassDefinitionInPackage notIn: aPackageModel	| fullClass instanceMethods classMethods removeMethods |	fullClass := aClassDefinitionInPackage package fullClassForClass: aClassDefinitionInPackage.	instanceMethods := aPackageModel methodsForClassNamed: fullClass fullName meta: false.	classMethods := aPackageModel methodsForClassNamed: fullClass fullName meta: true.	removeMethods := OrderedCollection new.	removeMethods addAll: (instanceMethods reject: [:each | fullClass includesSelector: each selector]).	fullClass := fullClass storeMetaClass.	removeMethods addAll: (classMethods reject: [:each | fullClass includesSelector: each selector]).	^removeMethods</body><body package="Store-UI" selector="sharedsInClass:notIn:">sharedsInClass: aClassDefinitionInPackage notIn: aPackageModel	| fullClass shareds removeShareds |	fullClass := aClassDefinitionInPackage package fullClassForClass: aClassDefinitionInPackage.	shareds := aPackageModel dataForNamed: fullClass fullName.	removeShareds := OrderedCollection new.	removeShareds addAll: (shareds reject: [:each | fullClass sharedVariables contains:  [:eachShared | eachShared dataKey = each dataKey]]).	^removeShareds</body></methods><methods><class-id>Store.Glorp.ClassListPane</class-id> <category>accessing</category><body package="Store-UI" selector="fillInFor:">fillInFor: aClass	| classesInPackage finalClassesInPackage |	(Gathering for: aClass name) started.	classesInPackage := (StoreClassDefinitionInPackage 		allVersionsWithName: aClass name		in: (aClass package ifNotNil: [:value | value session])) asList.	finalClassesInPackage := classesInPackage reject: [:each | each package isNil].	finalClassesInPackage size ~= classesInPackage size		ifTrue: [self reportUnpackagedDefinitionNamed: aClass name].	self fillListWith: finalClassesInPackage.	(Gathering for: aClass name) finished.</body><body package="Store-UI" selector="listTitle">listTitle	self itemsInList list size = 0 ifTrue: [^#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions'].	^self title.</body><body package="Store-UI" selector="title">title	^title ifNil: [(#VersionsOfClass1s &lt;&lt; #store &gt;&gt; 'Versions of class &lt;1s&gt;' expandMacrosWith: self itemsInList list first name)]</body></methods><methods><class-id>Store.LoadCanceled</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="defaultMessageText">defaultMessageText	^(#LoadingHasBeenCanceled &lt;&lt; #store &gt;&gt; 'Loading has been canceled')</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="definitionRecord">definitionRecord	^parameter</body><body package="Store-DB-BaseObjects" selector="definitionRecord:">definitionRecord: aDbRecord	parameter := aDbRecord</body><body package="Store-DB-BaseObjects" selector="originalError">originalError	^originalError</body><body package="Store-DB-BaseObjects" selector="originalError:">originalError: anError	originalError := anError</body><body package="Store-DB-BaseObjects" selector="package">package 	^package</body><body package="Store-DB-BaseObjects" selector="package:">package: aPackage	package := aPackage</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>private - actions</category><body package="Store-DB-BaseObjects" selector="defaultAction">defaultAction	"What to do when the exception is unhandled."	Dialog warn:		( self definitionRecord isForMethod			ifTrue: [  ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is not loadable.' ) expandMacrosWith: self definitionRecord printString ]			ifFalse: [ ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt;  '&lt;1s&gt; is not loadable.' ) expandMacrosWith: self definitionRecord name ]		)</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>actions</category><body package="Store-DB-BaseObjects" selector="fileoutOutOn:">fileoutOutOn: aSourceCodeStream	self definitionRecord fileOutOn: aSourceCodeStream.</body><body package="Store-DB-BaseObjects" selector="loadRecord">loadRecord	self definitionRecord loadSrcInto: package</body><body package="Store-DB-BaseObjects" selector="removeRecord">removeRecord	"Mark this record as removed - so it shows up in the package's changeset."	package == nil		ifFalse: [ self definitionRecord removeFromPackage: package ]</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="displayString">displayString	| stream |	stream := WriteStream on: String new.	stream nextPutAll: self definitionRecord fullDisplayString.	originalError ifNotNil:		[stream 			space			nextPut: $(;			nextPutAll: originalError class name;			space;			nextPutAll: originalError messageText;			nextPut: $)].	^stream contents</body><body package="Store-DB-BaseObjects" selector="printOn:">printOn: aStream 	aStream nextPutAll: (#UnloadableError1p &lt;&lt; #store &gt;&gt; 'Unloadable Error: &lt;1p&gt;' expandMacrosWith: self definitionRecord)</body></methods><methods><class-id>Store.UnloadableDefinitionError class</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreClassNavigatorPart</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="classForName:">classForName: aString	^self classForName: aString ifAbsent: [nil]</body><body package="StoreForGlorpBrowserUI" selector="classForName:ifAbsent:">classForName: aString ifAbsent: aBlock	^self environment classForName:  aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="displayTextFor:">displayTextFor: classNameWrapper		| type each simpleName |	each := self objectForName: classNameWrapper fullName.	type := (each notNil and: [each isPatched])		ifTrue: [Array with: #color -&gt; self overriddenColor]		ifFalse: [#()].	simpleName := (each isNil		ifTrue: ['']		ifFalse: [each longNameFromSmalltalk]) asText.	(self class shouldBoldDefinedItems		and: [each notNil and: [self isClassOrNameSpaceDefinedInSelection: each]])		ifTrue: [simpleName emphasizeAllWith: (type copyWith: #bold)]		ifFalse: [simpleName emphasizeAllWith: type].	^simpleName</body></methods><methods><class-id>Store.Glorp.StoreClassNavigatorPart</class-id> <category>accessing-navigator</category><body package="StoreForGlorpBrowserUI" selector="fillInState:">fillInState: aNavigatorState	aNavigatorState environment isNil		ifTrue: [aNavigatorState environment: self environment].	super fillInState: aNavigatorState</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^false</body><body package="Store-Merge Management" selector="isCommentResolver">isCommentResolver	^true</body><body package="Store-Merge Management" selector="isProposedRemovalNotInPackage">isProposedRemovalNotInPackage	| class |	proposed ifNil: [^false].	proposed isRemovalResolution ifFalse: [^false].	class :=  self longOwnerName asQualifiedReference valueOrDo: [^true].	^((Registry containingPackageForClass: class) name = proposed package name) not</body><body package="Store-Merge Management" selector="sameDefinitionAs:">sameDefinitionAs: aString	| reference |	(reference := self ownerName asQualifiedReference) ifNil: [^false].	reference valueOrDo: [^false].	^reference value comment = aString</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>resolving</category><body package="Store-Merge Management" selector="apply">apply	"Make sure we don't apply the text, just the text asString"	| class result |	applyable ifFalse: [^true].	proposed isRemovalResolution ifTrue: [^self applyAsRemove].	proposed isAbsentResolution ifTrue: [^true].	proposed isNoOpResolution ifTrue: [^true].	class := ownerName asStrictReference valueOrDo: 		[Transcript show: (#nFailedChangeCommentOnClass1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Failed when trying to change comment on a removed Class : &lt;1s&gt;' expandMacrosWith: ownerName).		^false].	self hasOverrideAndShouldApply ifFalse: [^false].	result := [class comment: proposed value asString]		on: Error		do: 			[:exception | 			Transcript show: (#nApplyingRemovalCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: nil].	^result notNil</body><body package="Store-Merge Management" selector="applyAsRemove">applyAsRemove	| class result |	class :=  self longOwnerName asQualifiedReference valueOrDo: [^true].	result := [class comment: '']		on: Error		do:			[:exception | 			Transcript show: (#nApplyingRemovalCommentFailed1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Applying Removal of Comment Failed &lt;2s&gt; : &lt;1s&gt;' 				expandMacrosWith: exception messageText				with: self longOwnerName).			exception return: #failed].	^result ~= #failed</body><body package="Store-Merge Management" selector="existingOverrides">existingOverrides	^#()</body><body package="Store-Merge Management" selector="hasOverrideAndShouldApply">hasOverrideAndShouldApply		self potentialOverride ifNotNil:		[:value | 		value name = proposed key name ifFalse: 			[(self proceedWithPossibleOverrideFrom: value name to: proposed key name) ifFalse: 				[Transcript show: (#nDidNotApplyCommentChangeToClass1s &lt;&lt; #store &gt;&gt; '&lt;n&gt;Did not apply comment change to Class &lt;1s&gt;' expandMacrosWith: ownerName).				^false]]].	^true</body><body package="Store-Merge Management" selector="potentialOverride">potentialOverride		^nil</body><body package="Store-Merge Management" selector="proceedWithPossibleOverrideFrom:to:">proceedWithPossibleOverrideFrom: aPackageName to: anotherPackageName	"Answer true if the user wants to create this override, otherwise false"	IgnorePossibleOverrideNotice raiseRequest ifTrue: [^true].	^Dialog confirm: 		(#ApplyingLoss1snIn2sOverideIn3snn &lt;&lt; #store &gt;&gt; 'Applying this change may cause a loss of information because&lt;n&gt;Class "&lt;1s&gt;" in Package "&lt;2s&gt;"&lt;n&gt;may later be created as an override in Package "&lt;3s&gt;"&lt;nn&gt;Proceed with change?' 			expandMacrosWith: ownerName			with: aPackageName			with: anotherPackageName)</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>private</category><body package="Store-Merge Management" selector="parseText:">parseText: aString		^aString notNil</body></methods><methods><class-id>Store.Glorp.ClassCommentChangeResolver</class-id> <category>displaying</category><body package="Store-Merge Management" selector="definitionTextFor:">definitionTextFor: anAlternative	anAlternative isRemovalResolution ifTrue: 		[^(proposed = anAlternative or: [applied])			ifTrue: [self removeFromImageString]			ifFalse: [self absentFromPackageString]].	^anAlternative value</body><body package="Store-Merge Management" selector="longListName">longListName	| string |	string := self longOwnerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="longOwnerName">longOwnerName	| name |	name := self ownerName.	(name includes: $.) ifTrue: 		[^('Root.*' match: name)			ifTrue: [name]			ifFalse: ['Root.', name]].	^'Root.Smalltalk.' , name</body><body package="Store-Merge Management" selector="mergeDisplayName">mergeDisplayName		^(#BracketClassCommentBracket &lt;&lt; #store &gt;&gt; '[Class Comment]') asString</body><body package="Store-Merge Management" selector="shortListName">shortListName	| string |	string := self ownerName , ' ', self shortTreeName.	^self hasPotentialOverride		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis]		ifFalse: [string]</body><body package="Store-Merge Management" selector="shortTreeName">shortTreeName		| string |	string := self mergeDisplayName , self applyableString.	^self hasPotentialOverride 		ifTrue: [string asText emphasizeAllWith: self overrideEmpahsis] 		ifFalse: [string]</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-utilities</category><body package="Store-DB-Broker" selector="answerFromQuery:bindInput:">answerFromQuery: aSQLString bindInput: anObject	^self process: aSQLString bindInput: anObject.</body><body package="Store-DB-Broker" selector="existsInDatabase:">existsInDatabase: anObj	| res |	res := self process: 				(( self newSQLFor: anObj class)					selectCountAll;					whereSqlString)  bindInput: anObj.	^res first first &gt; 0</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>drop objects</category><body package="Store-DB-Broker" selector="dropDatabaseFor:">dropDatabaseFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropIndexForClass:">dropIndexForClass: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropIndexForClass:index:">dropIndexForClass: aClass index: aName	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropSequenceForClass:">dropSequenceForClass: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropTable:">dropTable: aTable 		Transcript cr; show: 'Dropping table ' , aTable.	self performDrop: [self processSQL: 'DROP TABLE ' , aTable]</body><body package="Store-DB-Broker" selector="dropTableForClass:">dropTableForClass: aClass 	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropUser:">dropUser: aName	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropView:">dropView: aViewName	self performDrop: [self processSQL:  ('DROP VIEW ' , aViewName) asString]</body><body package="Store-DB-Broker" selector="dropViewForClass:">dropViewForClass: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="performDrop:">performDrop: aBlock		[aBlock value]		on: Error		do:			[:exception | 			(self doesNotExistErrors includes: exception parameter first dbmsErrorCode)				ifTrue:					[Transcript cr; show: exception parameter first dbmsErrorString.					exception return]				ifFalse:					[exception appendNewLineToMessageText: (self messageFor: exception).					self registry goOffLine.					exception pass]]</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>grant statements</category><body package="Store-DB-Broker" selector="grant:on:columnList:to:">grant: aPermissionList on: aTableName columnList: aColumnList  to: aUserNameList	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="grant:on:to:">grant: aPermissionList on: aTableName to: aUserNameList	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  (' ON ' , aTableName, ' TO ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.		self processGrantStatement: aStream contents.</body><body package="Store-DB-Broker" selector="grant:to:">grant: aStatementList to: aNameList	|  aStream |		aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aStatementList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  ' TO ' .	aNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	self processGrantStatement: aStream contents.</body><body package="Store-DB-Broker" selector="grantAllForClass:to:">grantAllForClass: aClass to: aUserName	self processGrantStatement:  'GRANT ALL ON ',  (self tableNameWithPrefix: aClass), ' TO ', aUserName.</body><body package="Store-DB-Broker" selector="grantAllTo:">grantAllTo: aName	self processGrantStatement:  'GRANT ALL TO ', aName.</body><body package="Store-DB-Broker" selector="grantForClass:permissions:columns:toUsers:">grantForClass: aClass permissions: aPermissionList columns: aColumnList toUsers: aUserNameList	self grant:aPermissionList		on: (self tableNameWithPrefix: aClass)		columnList: (self columnList: aColumnList for: aClass)		to: aUserNameList</body><body package="Store-DB-Broker" selector="grantForClass:permissions:toUsers:">grantForClass: aClass permissions: aPermissionList toUsers: aUserNameList	self grant: aPermissionList on: (self tableNameWithPrefix: aClass) to: aUserNameList.</body><body package="Store-DB-Broker" selector="grantForSeqClass:permissions:toUsers:">grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList	self grant: aPermissionList on: (self sequenceNameWithPrefix: aClass) to: aUserNameList.</body><body package="Store-DB-Broker" selector="processGrantStatement:">processGrantStatement: aString	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="processRevokeStatement:">processRevokeStatement: aString		[self processSQL: aString]		on: Error		do:			[:exception | 			exception appendNewLineToMessageText: (self messageFor: exception).			exception pass]</body><body package="Store-DB-Broker" selector="revoke:on:from:">revoke: aPermissionList on: aTableName from: aUserNameList	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'REVOKE ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  (' ON ' , aTableName, ' FROM ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.		self processRevokeStatement: aStream contents.</body><body package="Store-DB-Broker" selector="revokeForClass:permissions:fromUsers:">revokeForClass: aClass permissions: aPermissionList fromUsers: aUserNameList	self revoke: aPermissionList on: (self tableNameWithPrefix: aClass) from: aUserNameList.</body><body package="Store-DB-Broker" selector="setDatabasePrivilegesForTable:">setDatabasePrivilegesForTable: aClass	"Defines who can do what wtih the table"	| aColl |	self grantForClass: aClass permissions: #('INSERT' 'SELECT' ) toUsers: #('PUBLIC').	aColl := self allUpdatableColumnsFor: aClass.	aColl isEmpty 		ifFalse: [ self grantForClass: aClass permissions: #('UPDATE') columns: aColl toUsers: #('PUBLIC').].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-accessing</category><body package="Store-DB-Broker" selector="closeConnection">closeConnection	self registry closeConnection</body><body package="Store-DB-Broker" selector="dismissSession:">dismissSession: aSession	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="getNewSession">getNewSession	^ self connection getSession</body><body package="Store-DB-Broker" selector="reconnect">reconnect	self registry reconnect</body><body package="Store-DB-Broker" selector="resetSessionCursorFor:">resetSessionCursorFor: aSession	^self</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>connection class</category><body package="Store-DB-Broker" selector="connectionClass">connectionClass	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>error handling</category><body package="Store-DB-Broker" selector="alreadyExistErrors">alreadyExistErrors	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="brokerSignals">brokerSignals	"self brokerSignals"	self subclassResponsibility.</body><body package="Store-DB-Broker" selector="cannotCloseCursorErrorCode">cannotCloseCursorErrorCode	"Answer a number that database uses in case whe the cursor cannot be closed."		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="currentlyNotConnectedSignal">currentlyNotConnectedSignal	^self registry currentlyNotConnectedSignal</body><body package="Store-DB-Broker" selector="doesNotExistErrors">doesNotExistErrors	^#()</body><body package="Store-DB-Broker" selector="errorSignals">errorSignals	^self registry errorSignals</body><body package="Store-DB-Broker" selector="indexConflictSignal">indexConflictSignal	^ self connectionClass indexConflictSignal</body><body package="Store-DB-Broker" selector="invalidObjectErrorNumber">invalidObjectErrorNumber	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="notConnectedSignal">notConnectedSignal	^self registry notConnectedSignal</body><body package="Store-DB-Broker" selector="objectAlreadyExistisErrorNumber">objectAlreadyExistisErrorNumber	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="objectAlreadyGoneErrorNumber">objectAlreadyGoneErrorNumber	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="reconnectSignals:">reconnectSignals: ex	"Should we offer the user the choice of reconnecting when we get this signal. By default, yes to everything"	^true.</body><body package="Store-DB-Broker" selector="serverDiedErrorCodes">serverDiedErrorCodes	"Answer a number that database uses in case of 	server going away while we are connected."	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="connection">connection	^self registry connection</body><body package="Store-DB-Broker" selector="connectionOrNil">connectionOrNil	^self registry connectionOrNil</body><body package="Store-DB-Broker" selector="currentTimestampSQLString">currentTimestampSQLString	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="databaseName">databaseName	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="fullTableName:">fullTableName: aClass	"Override as required -	 Answer the full, database qualified table name for aClass."	^ self tableNameWithPrefix: aClass</body><body package="Store-DB-Broker" selector="getBlobData:">getBlobData: aData	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="indexNameFor:">indexNameFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="isConnectionAlive">isConnectionAlive	^self registry isConnectionAlive</body><body package="Store-DB-Broker" selector="maxLongBytes">maxLongBytes	^32000</body><body package="Store-DB-Broker" selector="maxPropertySearchStringSize">maxPropertySearchStringSize	"Return the mazimum length of property record search string. Should be &lt;= 255.	Override this value in subclasses if the searchable varchars are shorter on your DB."	^255</body><body package="Store-DB-Broker" selector="maxSqlString">maxSqlString	"Answer the maximum length of a sql string.	Subclasses should implement platform specific limitations."	^8000</body><body package="Store-DB-Broker" selector="needsSequenceFor:">needsSequenceFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="permissionsForSequence">permissionsForSequence	"Answer an array of permissions to grant to sequence tables."	^#( 'SELECT' ).</body><body package="Store-DB-Broker" selector="sequenceNameWithPrefix:">sequenceNameWithPrefix: aClass		^(self tableNameWithPrefix: aClass), 'Seq'</body><body package="Store-DB-Broker" selector="tableName:">tableName: aClass	^'TW_', aClass name asString</body><body package="Store-DB-Broker" selector="tableNameWithPrefix:">tableNameWithPrefix: aClass	^(self tablePrefix isNil or: [self tablePrefix isEmpty])		ifTrue: [self tableName: aClass]		ifFalse: [self tablePrefix, '.', (self tableName: aClass)]</body><body package="Store-DB-Broker" selector="tablePrefix">tablePrefix	^self registry tablePrefix</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private</category><body package="Store-DB-Broker" selector="messageFor:">messageFor: exception	| errs msg |	exception signal == self connectionClass authenticationFailureSignal 		ifTrue: [ ^exception errorString ].	errs := exception parameter.	^errs notNil 		ifTrue: 			[ errs isSignalledException ifTrue: [ ^ errs errorString].			(errs isEmpty not				and: [ (msg := (exception parameter at: 1) dbmsErrorString) notNil				and: [ msg isEmpty not ] ] )					ifTrue: [msg ]					ifFalse:  [exception errorString ]			]		ifFalse: [exception errorString ]</body><body package="Store-DB-Broker" selector="registry">registry	^DbRegistry</body><body package="Store-DB-Broker" selector="sessionFromOutputObject:">sessionFromOutputObject: anObject	^[ anObject class session ] 		on: MessageNotUnderstood 		do: [ : ex | ex return: DBObject session ].</body><body package="Store-DB-Broker" selector="typeToStringMap">typeToStringMap	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>sql processing</category><body package="Store-DB-Broker" selector="getAnswerFromSession:bindInput:">getAnswerFromSession: getSessionBlock bindInput: bindInputBlock 		^self safelyExecuteBlock: 		[ | session ans res |		session := getSessionBlock value.		bindInputBlock value: session.		session execute.		[ ans := session answer.		ans == #noMoreAnswers		] whileFalse: 			[ ans == #noAnswerStream 				ifFalse: [ res := ans upToEnd ]			].		self registry printDebug: 'Output'; printDebug: res.		^ res.		]</body><body package="Store-DB-Broker" selector="nextIDForClass:">nextIDForClass: aClass	"Answer the next number in the sequence established for artifact. "	| res ans sess |	^ [ self  safelyExecuteBlock: 		[ ( sess := aClass sequenceGeneratorSession ) execute.			[ ans := sess answer.			ans == #noMoreAnswers			] whileFalse: 				[ ans == #noAnswerStream 					ifFalse: [ res := ans upToEnd ]				].		res first first	] ] on: UnhandledException do: [ :ex | ex return ]</body><body package="Store-DB-Broker" selector="process:">process: sqlString	"Return the result not the answer stream."	^self registry goToScript 		ifTrue: [	self log: sqlString  level: #SQLBroker ]		ifFalse: 	[ self process: sqlString bindInput: nil  bindOutput: nil.]</body><body package="Store-DB-Broker" selector="process:bindInput:">process: sqlString bindInput: anObject	"Return the result not the answer stream."	^self process: sqlString bindInput: anObject bindOutput: nil</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:">process: sqlString bindInput: inputObj bindOutput: outputObj 	"Return the result not the answer stream. 	Watch for the server going away."	^self safelyExecuteBlock: 		[ self			process: sqlString			bindInput: inputObj			bindOutput: outputObj			usingSession: ( self sessionFromOutputObject: outputObj )		]</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:onError:do:">process: sqlString bindInput: anObj bindOutput: anObject onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: anObj 		bindOutput: anObject 		usingSession: ( self sessionFromOutputObject: anObject )		onError: aSignal 		do: aBlock</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:usingSession:">process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session	| res ans |	"Return the result not the answer stream."	self isConnectionAlive ifFalse: [self currentlyNotConnectedSignal raise].	self log: sqlString  level: #SQLBroker.	session bindInput: inputObj.	session bindOutput: outputObj.	session prepare: sqlString. 	session execute.	[ans := session answer.	ans == #noMoreAnswers]		whileFalse: [ans == #noAnswerStream ifFalse: [res := ans upToEnd]].	self log: 'Done ! '  level: #SQLBroker.	^ res</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:usingSession:onError:do:">process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session onError: aSignal do: aBlock	^[		self process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session 	] 	on: aSignal	do:		[:exception |			aBlock notNil ifTrue: [exception return: (aBlock value: exception)].			exception pass		]</body><body package="Store-DB-Broker" selector="process:bindOutput:">process: sqlString bindOutput: anObject 	"Return the result not the answer stream."	^self process: sqlString bindInput: nil bindOutput: anObject</body><body package="Store-DB-Broker" selector="process:bindOutput:onError:do:">process: sqlString bindOutput: anObject onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: nil 		bindOutput: anObject 		usingSession: ( self sessionFromOutputObject: anObject )		onError: aSignal 		do: aBlock</body><body package="Store-DB-Broker" selector="process:onError:do:">process: sqlString onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: nil 		bindOutput: nil		usingSession: DBObject session 		onError: aSignal 		do: aBlock</body><body package="Store-DB-Broker" selector="processPublishException:note:">processPublishException: anException note: aString	| newNote | 	anException appendNewLineToMessageText: 'ERROR: ', (self messageFor: anException).	newNote := aString.	newNote notEmpty ifTrue: [newNote := newNote, ' --- '].	newNote := newNote, 'Operation was not completed.'.	anException appendNewLineToMessageText: newNote.	self registry goOffLine.</body><body package="Store-DB-Broker" selector="processSQL:">processSQL: sqlString	^self registry goToScript 		ifTrue: [	self log: sqlString  level: #SQLBroker ]		ifFalse:  [ self processSQL: sqlString bindInput: nil bindOutput: nil.]</body><body package="Store-DB-Broker" selector="processSQL:bindInput:">processSQL: sqlString bindInput: anObject	^ self 	processSQL: sqlString bindInput: anObject bindOutput: nil</body><body package="Store-DB-Broker" selector="processSQL:bindInput:bindOutput:">processSQL: sqlString bindInput: anObjectInp bindOutput: anObjectOut	^self  process: sqlString		bindInput: anObjectInp		bindOutput: anObjectOut		usingSession: ( self sessionFromOutputObject: anObjectOut )</body><body package="Store-DB-Broker" selector="processSQL:bindOutput:">processSQL: sqlString bindOutput: anObject	^ self processSQL: sqlString bindInput: nil bindOutput: anObject</body><body package="Store-DB-Broker" selector="publishTransaction:">publishTransaction: aBlock	"If not already in transaction mode then start one. Assumes progress dialog already up.	Answer either a value returned by aBlock or nil if the transaction fails."	^[ | res connection |	 ( connection := self connection ) isNil		ifTrue: [ ^nil ].	connection inTransactionMode 		ifTrue: [ res := aBlock value	"We are already inside a transaction." ]		ifFalse: 			[ [ connection begin.				  res := aBlock value.				  connection commit			   ] ifCurtailed:				[ self registry isOnline ifTrue: [ connection rollback ].				res := nil				]			].		res	] on: ( ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex |  			self processPublishException: ex  note: ''. 			ex outer. 			ex return]</body><body package="Store-DB-Broker" selector="publishTransaction:showing:">publishTransaction: aBlock showing: aNote 	"If not already in transaction mode than put a notice on the screen and start 	transaction. Answer either a value returned by aBlock or nil if the transaction fails."	^ [| res |		self connection inTransactionMode 			ifTrue: [ res := aBlock value	"We are already inside a transaction." ]			ifFalse: 				[ Notice show: aNote while: 					[ [ self connection begin.					  res := aBlock value.					  self connection commit					  ] ifCurtailed:						[ self registry isOnline ifTrue: [self connection rollback].						res := nil						]					]				].		res	] 	on: (ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex | self processPublishException: ex  note: aNote.				ex outer.			ex return.]</body><body package="Store-DB-Broker" selector="publishTransaction:showing:count:">publishTransaction: aBlock showing: aNote count: anInteger	"If not already in transaction mode than put a progress dialog on the screen and start 	transaction. Answer either a value returned by aBlock or nil if the transaction fails."	^[ | res connection |	 ( connection := self connection ) isNil		ifTrue: [ ^nil ].	connection inTransactionMode 		ifTrue: [ res := aBlock value	"We are already inside a transaction." ]		ifFalse: 			[Notice 				showProgress: aNote 				complete: anInteger 				while: 					[[connection begin.					  res := aBlock value.					  connection commit] ifCurtailed:						[self registry isOnline ifTrue: [connection rollback].						res := nil]]				title: 'Store'].		res	] 	on: (ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex |  			self processPublishException: ex  note: aNote. 			ex outer. 			ex return]</body><body package="Store-DB-Broker" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock	"Catch errors that arise. Do not offer reconnect for certain errors during transaction."	(self registry connectionOrNil == nil or: [self registry isOnline not])		ifTrue: [^self currentlyNotConnectedSignal raiseSignal].	^[[Cursor database showWhile: [aBlock value]]		on: self brokerSignals		do:			[:exception | 			| inTransaction |			self registry debug ifTrue: [self hardHalt].			inTransaction := self connection inTransactionMode.			self registry goOffLine.			(inTransaction not and: [self reconnectSignals: exception])				ifTrue:					[(Dialog confirm: 'Currently disconnected. Do you want to reconnect?')						ifTrue: [self registry reconnect ifTrue: [exception retry]].					exception resignalAs: self currentlyNotConnectedSignal new]]]		on: UnhandledException		do:			[:ex | 			(ControlInterrupt handles: ex parameter) ifTrue: [ex pass].			self processPublishException: ex note: ''.			self currentlyNotConnectedSignal raiseSignal.			ex return].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>create objects</category><body package="Store-DB-Broker" selector="addIdentityFor:">addIdentityFor: aColumn	"Most databases don't use this, but some may require a special identity(xx) function call in the definition string"	^String new.</body><body package="Store-DB-Broker" selector="allocateSpaceForObjectsIn:">allocateSpaceForObjectsIn: fileName		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="collWhereClauseFor:from:collClass:">collWhereClauseFor: aClass from: refClass collClass: collClass	| position column defIsOptional |	position := aClass subCollectionClasses indexOf: collClass.	column := aClass childReferenceColumns at: position.		defIsOptional := aClass definitionsAreOptional at: position.	^'(', (self tableNameWithPrefix: refClass), '.', (self columnName: 'primaryKey' for: refClass),			 ' = ', ( self tableNameWithPrefix: collClass), '.', (self columnName: column for: collClass),		((defIsOptional not or: [self ansiOuterJoins]) ifTrue: [')'] ifFalse: [' (+))']).</body><body package="Store-DB-Broker" selector="createDatabaseSequence:">createDatabaseSequence: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="createDatabaseTable:">createDatabaseTable:  aClass		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="createDatabaseTableColumnsFor:keyNames:">createDatabaseTableColumnsFor: aClass keyNames: aKeyCollection	"Creates column list for a new table"		| fieldTypes stringMap stream fieldType |	stringMap := self typeToStringMap.	fieldTypes := aClass fieldTypes.	stream := (String new: 100) writeStream.	stream cr.	aClass columnNames do:			[:each | 			fieldType := fieldTypes				at: each				ifAbsent: [#String].			(self isPrimaryKeyType: fieldType) ifTrue: [aKeyCollection addLast: each].			stream nextPutAll: '     ' , (self columnName: each for: aClass) , '  ' , (stringMap at: fieldType).			stream nextPutAll: (self addIdentityFor: each).			stream nextPutAll: ','; cr].	aKeyCollection isEmpty ifTrue:		[stream skip: -2.		stream nextPut: $ ].	^stream contents</body><body package="Store-DB-Broker" selector="createIndex:onTable:columns:">createIndex: indName onTable: aTable columns: aNameCollection	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE INDEX ' , indName, ' ON ' , aTable, ' ( '.	aNameCollection 		do: [ :each | aStream nextPutAll: each, ', ' ].	aStream skip: -2.	aStream nextPutAll: ' )'.	self performCreate: [ self processSQL: aStream contents]</body><body package="Store-DB-Broker" selector="createIndexForClass:">createIndexForClass: aClass 	"self createIndexForClass: Method"	self 		createIndexForClass: aClass		index: (self tableNameWithPrefix: aClass) , aClass indexName		columns: aClass indexColumnNames</body><body package="Store-DB-Broker" selector="createIndexForClass:index:columns:">createIndexForClass: aClass index: indName columns: aNameCollection	"Creates an index on a given table that either 		changes the physical ordering of the table or		provides the optimizer with a logical ordering of the table to increase efficiency for queries."	self createIndex: indName 			onTable: (self fullTableName: aClass) 			columns: (self columnList: aNameCollection for: aClass)</body><body package="Store-DB-Broker" selector="createSourcesViewForClass:">createSourcesViewForClass: aClass 	"self createSourcesViewForClass: MethodsView"	self 		createView: (self tableNameWithPrefix: aClass) 		selectStatement: (self createViewSelectWithSourcesSQLForClass: aClass).	self 		grantForClass: aClass		permissions: #('SELECT')		toUsers: #('PUBLIC')</body><body package="Store-DB-Broker" selector="createTable:columns:">createTable: aTableName columns: columnString	"Creates a new table."	| aStream |	Transcript cr; show: 'Creating table for ' , aTableName.	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE TABLE ' , aTableName,  columnString.	self performCreate: [self processSQL: aStream contents]</body><body package="Store-DB-Broker" selector="createTablePrimaryKeySectionFor:keys:">createTablePrimaryKeySectionFor: aClass keys: aKeyCollection		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="createView:selectStatement:">createView: aViewName selectStatement: aSelectString	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE VIEW ' ,  aViewName , ' as	SELECT ', aSelectString.	self performCreate: [self processSQL: aStream contents]</body><body package="Store-DB-Broker" selector="createViewForClass:">createViewForClass: aClass	"self createViewForClass: Store.PropertiesView"	self 		createView: (self tableNameWithPrefix: aClass)		selectStatement: (self createViewSelectSQLForClass: aClass).</body><body package="Store-DB-Broker" selector="createViewSelectSQLForClass:">createViewSelectSQLForClass: aClass	|  aStream collClass refClass refColumnNames |	aStream := (String new: 100) writeStream.	collClass := aClass subCollectionClass.	refClass := aClass referencedClass.	refColumnNames := (self allColumnsFor: refClass) asSet.	(self allColumnsFor: aClass) do: [:each |			| tName | 			tName := (refColumnNames includes: each) 				ifTrue: [ self tableNameWithPrefix: refClass ]				ifFalse: [ self tableNameWithPrefix: collClass ].			aStream nextPutAll: tName , '.' , each , ', '].	aStream skip: -2.	aStream nextPutAll: '	FROM ' , (self tableNameWithPrefix: collClass), ', ' , (self tableNameWithPrefix: refClass), '	WHERE '.	aStream nextPutAll: 		( self tableNameWithPrefix: collClass), '.', (self columnName: (aClass childReference) for: collClass),			 ' = ',			(self tableNameWithPrefix: refClass), '.', (self columnName: 'primaryKey' for: refClass).	^ aStream contents</body><body package="Store-DB-Broker" selector="createViewSelectWithSourcesSQLForClass:">createViewSelectWithSourcesSQLForClass: aClass	"Create the sql for a view that retrieves method comments in a join"	"Modified so that it could keep better track of which columns were associated with which table, 	permitting the possibility of a view which joined the same table twice, and to allow the view class 	to specify which table the definition key was in"	| aStream linkClasses mainClass definitionClasses refColumnNames allColumnNames items allColumns |	aStream := (String new: 100) writeStream.	linkClasses := aClass subCollectionClasses.	mainClass := aClass referencedClass.	definitionClasses := aClass definitionClasses.	refColumnNames := self allColumnsFor: mainClass.	allColumnNames := self allColumnsFor: aClass.	items := OrderedCollection new.	refColumnNames do: [:each | items add: each -&gt; ((self tableNameWithPrefix: mainClass), '.', each)].	1 to: linkClasses size do: 		[ :i |  | eachLink eachDef defColumnNamesForViewList defColumnNamesForMatching linkColumnNames |		eachLink := linkClasses at: i.		eachDef := definitionClasses at: i.			defColumnNamesForViewList := (aClass aliasedDefReferenceColumnNamesCollection at: i) asOrderedCollection.		defColumnNamesForMatching := (aClass defReferenceColumnNamesCollection at: i) asOrderedCollection.		refColumnNames := refColumnNames select: [:each | allColumnNames includes: each].		defColumnNamesForMatching size to: 1 by: -1 do: 			[ :j |			(allColumnNames includes: (defColumnNamesForMatching at: j))				ifFalse: 					[ defColumnNamesForMatching removeIndex: j.					defColumnNamesForViewList removeIndex: j					]			].		linkColumnNames := (self allColumnsFor: eachLink) select: [:each | allColumnNames includes: each].		linkColumnNames do: [:each | items add: each -&gt; ((self tableNameWithPrefix: eachLink), '.', each)].		defColumnNamesForMatching with: defColumnNamesForViewList do: [:instVarName :columnName | 			items add: instVarName -&gt; ((self tableNameWithPrefix: eachDef), '.', columnName)]].	allColumns := self allColumnsFor: aClass.	allColumns do: 		[ :each |  | match |			match := items detect: [:eachAssociation | eachAssociation key = each] ifNone: [nil].			match isNil 				ifFalse: 					[						aStream nextPutAll: match value.					each == allColumns last 						ifFalse: [ aStream nextPutAll: ', ' ]					] 		].	self printTableListAndWhereClauseForViewWithSourcesFrom: mainClass 			to: definitionClasses 			via: linkClasses 			for: aClass on: aStream. 	^ aStream contents</body><body package="Store-DB-Broker" selector="defWhereClauseFor:withDefClass:">defWhereClauseFor: aClass withDefClass: defClass	| position defRefClass column defIsOptional |	position := aClass definitionClasses indexOf: defClass.	defRefClass := aClass definitionReferenceClasses at: position.	column := aClass definitionReferenceColumns at: position.	defIsOptional := aClass definitionsAreOptional at: position.	^'(', (self tableNameWithPrefix: defRefClass) , '.'		, (self columnName: column for: defClass), 		 ' = ', 		 (self tableNameWithPrefix: defClass) , '.'		, (self columnName: 'primaryKey' for: defClass), 		((defIsOptional not or: [self ansiOuterJoins]) ifTrue: [')'] ifFalse: [' (+))']).</body><body package="Store-DB-Broker" selector="fileNameForBlobs">fileNameForBlobs	^Store.Policies tableSpacePolicy blobTableSpace</body><body package="Store-DB-Broker" selector="fileNameForClasses">fileNameForClasses	^Store.Policies tableSpacePolicy defaultTableSpace</body><body package="Store-DB-Broker" selector="installPhysicalSpaces">installPhysicalSpaces	"Create the physical table spaces/device spaces   used by Store."	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="isPrimaryKeyType:">isPrimaryKeyType: aType	"Returns whether or not aType is a primary key type"	"Added by Philippe F. Monnet of Andersen Consulting"		^self primaryKeyTypes includes: aType</body><body package="Store-DB-Broker" selector="performCreate:">performCreate: aBlock		[aBlock value]		on: Error		do:			[:exception | 			(self alreadyExistErrors includes: exception parameter first dbmsErrorCode)				ifTrue:					[Transcript cr; show: exception parameter first dbmsErrorString.					exception return]				ifFalse:					[exception appendNewLineToMessageText: (self messageFor: exception).					self registry goOffLine.					exception pass]]</body><body package="Store-DB-Broker" selector="primaryKeyTypes">primaryKeyTypes	"Returns the primary key types"	^#( #PrimaryKey #PrimaryKeyInteger #PrimaryKeyString 		#PrimaryKeyChar #PrimaryKeyShortString)</body><body package="Store-DB-Broker" selector="printTableListAndWhereClauseForViewWithSourcesFrom:to:via:for:on:">printTableListAndWhereClauseForViewWithSourcesFrom: mainClass to: definitionClasses via: linkClasses for: aClass on: aStream 	aStream nextPutAll: '	FROM '.	aStream nextPutAll: (self tableNameWithPrefix: mainClass).	self ansiOuterJoins 		ifTrue: 			[ linkClasses with: definitionClasses do: 				[ :eachLink :eachDefinition |  | defIsOptional |				defIsOptional := aClass definitionsAreOptional 							at: (linkClasses indexOf: eachLink).				defIsOptional 					ifTrue: [aStream nextPutAll: ' LEFT OUTER JOIN ']					ifFalse: [aStream nextPutAll: ' JOIN '].				aStream nextPutAll: (self tableNameWithPrefix: eachLink).				aStream nextPutAll: ' ON ('.				aStream nextPutAll: (self 							collWhereClauseFor: aClass							from: mainClass							collClass: eachLink).				aStream nextPutAll: ') '.				defIsOptional 					ifTrue: [aStream nextPutAll: ' LEFT OUTER JOIN ']					ifFalse: [aStream nextPutAll: ' JOIN '].				aStream nextPutAll: (self tableNameWithPrefix: eachDefinition).				aStream nextPutAll: ' ON ('.				aStream 					nextPutAll: (self defWhereClauseFor: aClass withDefClass: eachDefinition).				aStream nextPutAll: ') ']			]		ifFalse: 			[ aStream nextPutAll: ', '.			linkClasses , definitionClasses do: 				[:each | 				aStream nextPutAll: (self tableNameWithPrefix: each).				each == definitionClasses last ifFalse: [aStream nextPutAll: ', ']].			aStream nextPutAll: '			WHERE '.				linkClasses with: definitionClasses do: 					[ :eachLink :eachDefinition | 					eachLink == linkClasses first ifFalse: [aStream nextPutAll: ' AND '].					aStream nextPutAll: (self 						collWhereClauseFor: aClass						from: mainClass						collClass: eachLink).					aStream nextPutAll: ' AND ' 						, (self defWhereClauseFor: aClass withDefClass: eachDefinition)				]			]</body><body package="Store-DB-Broker" selector="spaceForBlobs">spaceForBlobs"MB"	^ '16'</body><body package="Store-DB-Broker" selector="spaceForClasses">spaceForClasses"MB"	^'32'</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>queries</category><body package="Store-DB-Broker" selector="alterTableFor:addColumn:">alterTableFor: aClass addColumn: aString	"Column name must be a String for compatibility with #fieldTypes"	| aType |	aType := aClass fieldTypes at: aString asString ifAbsent: [#String].	self process: 		((self newSQLFor: aClass)			addColumn: (self columnName: aString for: aClass) dbType: (self typeToStringMap at: aType))</body><body package="Store-DB-Broker" selector="alterTableFor:pctIncreaseBy:">alterTableFor: aClass  pctIncreaseBy: aNumber	| sql |	sql :=  (self newSQLFor: aClass)			alterPstincrease: aNumber printString.	self process: sql.	Transcript cr; show: sql, '-- Done!'.</body><body package="Store-DB-Broker" selector="newSQLFor:">newSQLFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="nextIDQuery:">nextIDQuery: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="sqlAssistClass">sqlAssistClass	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>debugging</category><body package="Store-DB-Broker" selector="debugLabelsAndValues">debugLabelsAndValues	^List new		add: ('Sql Statements'-&gt;#SQLBroker);		yourself</body><body package="Store-DB-Broker" selector="log:level:">log: aString level: aLevel	[ self registry debugger log: aString  level: aLevel ] on: Error do: [ :ex | ex return ]</body><body package="Store-DB-Broker" selector="menuItemName">menuItemName	^(#StoreMessages &lt;&lt; #store &gt;&gt; 'Store Messages') asString</body><body package="Store-DB-Broker" selector="registerToDebug">registerToDebug	[self registry debugger addToDebug: self] on: Error do: [ :ex | ]</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>class initialization</category><body package="Store-DB-Broker" selector="initialize">initialize	self registerToDebug</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-column names</category><body package="Store-DB-Broker" selector="allColumnsFor:">allColumnsFor: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	To override method, invoke super #allColumnsFor: 		and then convert names as required by specific database"	^aClass columnNames.</body><body package="Store-DB-Broker" selector="allUpdatableColumnsFor:">allUpdatableColumnsFor: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	To override method, invoke super #allUpdatableColumnsFor: 		and then convert names as required by specific database"	| aColl |	aColl := OrderedCollection new.	#( 'version'  'versionComment'  'blessingLevel' )  do: [ :each  |		(aClass columnNames includes:	each) ifTrue: [ aColl add: each ]	].	^aColl</body><body package="Store-DB-Broker" selector="columnList:for:">columnList: aCollection for: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	Override method to convert names as required by specific database table."	^ aCollection.</body><body package="Store-DB-Broker" selector="columnName:for:">columnName: aStringOrSymbol for: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	Override method to convert name as required by specific database table."	^aStringOrSymbol.</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>testing</category><body package="Store-DB-Broker" selector="ansiOuterJoins">ansiOuterJoins	"Return true if we use ansi outer joins."	^true.</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>obsolete</category><body package="Store-DB-Broker" selector="performCreate:for:">performCreate: aBlock for: aName	"This method is obsolete. use #performCreate: instead, since the for parameter is not used"		^self performCreate: aBlock</body><body package="Store-DB-Broker" selector="performDrop:for:">performDrop: aBlock for: aName	"This method is obsolete. use #performDrop: instead, since the for parameter is not used"		^self performDrop: aBlock</body></methods><methods><class-id>Store.FilingOut</class-id> <category>accessing</category><body package="Store-Difference Management" selector="actionText">actionText	^(#FilingOut &lt;&lt; #store &gt;&gt; 'Filing Out') asString</body></methods><methods><class-id>Store.Reading</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="actionText">actionText	^(#Reading &lt;&lt; #store &gt;&gt; 'Reading') asString</body></methods><methods><class-id>Store.Reading class</class-id> <category>utility</category><body package="Store-Code Comparison" selector="for:while:">for: aCodeComponent while: aBlock	(self for: aCodeComponent) started.	^aBlock ensure: [(self for: aCodeComponent) finished]</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>metaclasses</category><body package="Store-Database Model" selector="storeMetaClass">storeMetaClass	^self.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>accessing</category><body package="Store-Database Model" selector="classDefinition">classDefinition	^mainClass classDefinition.</body><body package="Store-Database Model" selector="classMethods">classMethods	^#()</body><body package="Store-Database Model" selector="classNameWithMeta">classNameWithMeta	^super classNameWithMeta , ' class'</body><body package="Store-Database Model" selector="instanceMethods">instanceMethods	^mainClass classMethods.</body><body package="Store-Database Model" selector="longName">longName	^mainClass longName.</body><body package="Store-Database Model" selector="mainClass">mainClass	^mainClass</body><body package="Store-Database Model" selector="mainClass:">mainClass: aStoreClassExtension	mainClass := aStoreClassExtension</body><body package="Store-Database Model" selector="name">name	^mainClass name.</body><body package="Store-Database Model" selector="package">package	^mainClass package.</body><body package="Store-Database Model" selector="sharedVariables">sharedVariables	^self mainClass sharedVariables</body><body package="Store-Database Model" selector="simpleNameWithMeta">simpleNameWithMeta	^self name, ' class'</body><body package="StoreForGlorpVWUI" selector="soleInstance">soleInstance	^mainClass</body><body package="Store-Database Model" selector="timestamp">timestamp	^self mainClass timestamp.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>testing</category><body package="Store-Database Model" selector="includesMethod:">includesMethod: aStoreMethodInPackage	^aStoreMethodInPackage isMetaclass		ifTrue: [self instanceMethods includes: aStoreMethodInPackage]		ifFalse: [false].</body><body package="Store-Database Model" selector="isMeta">isMeta	^true.</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="initialMethodCategory">initialMethodCategory		^Symbol new</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension</class-id> <category>image compatibility</category><body package="Store-Database Model" selector="instanceBehavior">instanceBehavior	"Override to provide my corresponding StoreClassExtension."	^mainClass</body></methods><methods><class-id>Store.Glorp.StoreMetaclassExtension class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="on:">on: aStoreClassExtension	^self new mainClass: aStoreClassExtension.</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>private</category><body package="Store-DB-Broker" selector="allColumnNames">allColumnNames	"Answer array of all column names from instance variables of aClass. 	Implemented here so we can re-map column names, if necessary."	^alias notNil		ifTrue: [self tableClass columnNames collect: [:name | alias , '.' , name]]		ifFalse: [self tableClass columnNames]</body><body package="Store-DB-Broker" selector="allHostVariableNames">allHostVariableNames 	"Answer array of all column names from instance variables of aClass.		These will be used as accessors."	^ self tableClass columnNames collect: [ :each | ':', each ]</body><body package="Store-DB-Broker" selector="columnName:">columnName: aStringOrSymbol 	"Answer the column name. 		Implemented here so we can re-map column names, as necessary.		Override for conversions as required by specific Database Table."	^alias notNil ifTrue: [alias , '.', aStringOrSymbol] ifFalse: [aStringOrSymbol]</body><body package="Store-DB-Broker" selector="removePrimaryKeyColumn:">removePrimaryKeyColumn: anArray	"Some databases do not allow CREATE and/or INSERT statements		to specify columns whose values are auto-generated.	 Override this method to exclude column 'primaryKey', as required.		This method is invoked before any column name re-mapping."	^anArray</body><body package="Store-DB-Broker" selector="removePrimaryKeyValue:">removePrimaryKeyValue: anArray	"Some databases do not allow CREATE and/or INSERT statements		to specify columns whose values are auto-generated.	 Override this method to exclude host variable ':primaryKey', as required."	^anArray</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="alias">alias	^alias</body><body package="Store-DB-Broker" selector="alias:">alias: aString	alias := aString</body><body package="Store-DB-Broker" selector="newSQLStream">newSQLStream	^ sqlStream := (String new: 150) writeStream.</body><body package="Store-DB-Broker" selector="sqlString">sqlString	^ sqlStream contents</body><body package="Store-DB-Broker" selector="tableClass">tableClass	^ tableClass</body><body package="Store-DB-Broker" selector="tableClass:">tableClass: aClass	tableClass := aClass</body><body package="Store-DB-Broker" selector="tableName">tableName	^ alias notNil ifTrue: [tableName, ' ', alias] ifFalse: [tableName]</body><body package="Store-DB-Broker" selector="tableName:">tableName: aString	tableName := aString</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>utility</category><body package="Store-DB-Broker" selector="smalltalkWildcardToSql:">smalltalkWildcardToSql: aString	"Translates a smalltalk wild card string to a sql wildcard string."	"* becomes % and ? becomes _"	| string index |	string := aString copy.	[ ( index := string indexOfSubCollection: '*' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $% ].	[ ( index := string indexOfSubCollection: '?' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $_ ].	^string</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>queries</category><body package="Store-DB-Broker" selector="addColumn:dbType:">addColumn: aString dbType: aColType	sqlStream nextPutAll: 'ALTER TABLE ', self tableName, ' ADD '.	self column: aString.	sqlStream nextPutAll: aColType.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="addString:">addString: aString	sqlStream nextPutAll: aString.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="alterPstincrease:">alterPstincrease: aNumber	sqlStream nextPutAll: 'ALTER TABLE ', self tableName, ' STORAGE (  PCTINCREASE ', aNumber, ' )'.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="and">and	sqlStream nextPutAll: ' AND '</body><body package="Store-DB-Broker" selector="beginClause">beginClause 	sqlStream nextPutAll: ' ( '</body><body package="Store-DB-Broker" selector="column:">column: column	sqlStream nextPutAll: ' ', (self columnName: column), ' '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:equalTo:">column: column equalTo: value	self column: column.	sqlStream nextPutAll: '= ',  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:equalToArray:">column: column equalToArray: values	"Add a where clause that selects the value equal to one in an array of values."	self column: column; in.	self beginClause.	values 		do: [ :each | sqlStream nextPutAll: each ]		separatedBy:[ sqlStream nextPutAll: ', ' ].	self endClause.	^sqlStream contents</body><body package="Store-DB-Broker" selector="column:greaterThan:">column: column greaterThan: value	self column: column.	sqlStream nextPutAll:  '&gt; ' ,  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:lessThan:">column: column lessThan: value	self column: column. 	sqlStream nextPutAll: '&lt; ' , value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:like:">column: column like: value	self column: column. 	sqlStream nextPutAll: 'like ' ,  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:notEqualTo:">column: column  notEqualTo: value	sqlStream nextPutAll: ' ', column, ' &lt;&gt; ',  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:notEqualToArray:">column: column notEqualToArray: values	"Add a where clause that selects the value not equal to one in an array of values."	self beginClause.	values 		do: [ :each | self column: column notEqualTo: each ]		separatedBy:[ self and ].	self endClause.	^sqlStream contents</body><body package="Store-DB-Broker" selector="column:wildcard:">column: column wildcard: string	| param |	param := self smalltalkWildcardToSql: string.	self column: column.	sqlStream nextPutAll: 'like ',  param.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="columnSAVE:equalToArray:">columnSAVE: column equalToArray: values	"Add a where clause that selects the value equal to one in an array of values."	self column: column; in.	self beginClause.	values 		do: [ :each | sqlStream nextPutAll: each ]		separatedBy:[ sqlStream nextPutAll: ', ' ].	self endClause.	^sqlStream contents</body><body package="Store-DB-Broker" selector="delete">delete	sqlStream nextPutAll: 'DELETE FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="endClause">endClause 	sqlStream nextPutAll: ' ) '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="equal">equal	sqlStream nextPutAll: ' = '.</body><body package="Store-DB-Broker" selector="in">in	sqlStream nextPutAll: ' IN '</body><body package="Store-DB-Broker" selector="in:">in: aString	sqlStream nextPutAll: ' IN (', aString, ' ) '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="innerJoin:">innerJoin: joinSql 		^ self join: joinSql  type: ' INNER JOIN '</body><body package="Store-DB-Broker" selector="insert:">insert: aColumnArray	| arr |	arr := self removePrimaryKeyColumn: aColumnArray.	sqlStream nextPutAll: 'INSERT INTO ', self tableName, ' ('.	arr do:		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' ) '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="insertColumns:values:">insertColumns: aColumnArray values: aValueArray	self insert: aColumnArray.	self insertValues: aValueArray.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="insertColumnsValues:">insertColumnsValues: aColumnArray	"Column names are used as host variables / accessors"	self insertColumns: aColumnArray 		values: (aColumnArray collect: [ :each | ':' , each ] ).	^ sqlStream contents</body><body package="Store-DB-Broker" selector="insertValues:">insertValues: aValueArray	| arr |	" aValueArray is a list of host variable names (each preceeded by a colon).		Colon is stripped and the name is used as accessor. "	arr := self removePrimaryKeyValue: aValueArray.	sqlStream nextPutAll: ' VALUES ('.	arr do: 		[ :col | sqlStream nextPutAll: col , ', ' ].	sqlStream skip: -2.	sqlStream nextPut: $).	^ sqlStream contents</body><body package="Store-DB-Broker" selector="isNull">isNull	sqlStream nextPutAll: ' IS NULL '</body><body package="Store-DB-Broker" selector="join:type:">join: joinSql type: aType	"insert join statement"	sqlStream nextPutAll: aType ;		nextPutAll: joinSql tableName;		nextPutAll: ' ON '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="joinedColumn:">joinedColumn: column"Like column: but without modifying of sqlStream"	^' ', (self columnName: column), ' '.</body><body package="Store-DB-Broker" selector="leftJoin:">leftJoin: joinSql 		^ self join: joinSql  type: ' LEFT OUTER JOIN '</body><body package="Store-DB-Broker" selector="notEqual">notEqual	sqlStream nextPutAll: ' &lt;&gt; '.</body><body package="Store-DB-Broker" selector="notIn">notIn	sqlStream nextPutAll: ' NOT IN '</body><body package="Store-DB-Broker" selector="notIn:">notIn: aString	sqlStream nextPutAll: ' NOT IN (', aString, ')'.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="notNull">notNull	sqlStream nextPutAll: ' NOT NULL '</body><body package="Store-DB-Broker" selector="or">or	sqlStream nextPutAll: ' OR '</body><body package="Store-DB-Broker" selector="orderBy:">orderBy: column	sqlStream nextPutAll: ' ORDER BY ', (self columnName: column). 	^ sqlStream contents</body><body package="Store-DB-Broker" selector="rightJoin:">rightJoin: joinSql 		^ self join: joinSql  type: ' RIGHT OUTER JOIN '</body><body package="Store-DB-Broker" selector="select:">select: aColumnArray	sqlStream nextPutAll: 'SELECT '.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectAll">selectAll	sqlStream nextPutAll: 'SELECT 	'.	alias notNil ifTrue: [	sqlStream nextPutAll: alias, '.' ].	sqlStream nextPutAll: '* FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectCountAll">selectCountAll	sqlStream nextPutAll: 'SELECT COUNT (*) FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectDistinct:">selectDistinct: aColumnArray	sqlStream nextPutAll: 'SELECT  DISTINCT '.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectMax:">selectMax: aColumnArray	sqlStream nextPutAll: 'SELECT MAX ('.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1. 	sqlStream nextPutAll: ') FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="setColumns:equalTo:">setColumns: columnArray equalTo: valueArray	"For set commands. Sets each column equal to cooresponding value in valueArray"	self update.	columnArray with: valueArray do:		[ :column :value |		self column: column.		sqlStream nextPutAll: '= ',  value.		sqlStream nextPutAll: ', '.		].	sqlStream skip: -2.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="update">update	sqlStream nextPutAll: 'UPDATE ', self tableName, ' SET '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="where">where	sqlStream nextPutAll: ' WHERE '</body><body package="Store-DB-Broker" selector="whereSqlString">whereSqlString	| columns values |	" Column names might need to be re-mapped 		but host variables for values must be the attribute names (accessors).		Therefore, we need to iterate over both lists concurrently. "	self where.	columns := self allColumnNames.		values := self allHostVariableNames.	columns with: values do: 		[ : column :value |		sqlStream 			cr; tab;			nextPutAll: column;			nextPutAll: ' = ';			nextPutAll: value;			nextPutAll: ' AND '.		].	sqlStream skip: -4.	sqlStream cr.	^sqlStream contents</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>special</category><body package="Store-DB-Broker" selector="classNamesInPackages:">classNamesInPackages: pkgIds	^self 	  selectDistinct: #( #className );	  where;	   column: #packageRef equalToArray: 		( pkgIds collect: [ :pkg | pkg primaryKey printString ] );	sqlString</body><body package="Store-DB-Broker" selector="recordsWithSourcesIn:butNotIn:">recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey "copied from ViewRecord&gt;&gt;recordsWithSourcesIn: butNotIn: "	self selectAll;		where;		column: #packageRef equalTo: aPrimaryKey printString;		and;  column: #primaryKey; notIn;		beginClause;		addString:			( tableClass subCollectionClass newSQL			select: ( Array with: tableClass childReference );			where;			column: #packageRef equalTo: bPrimaryKey printString;			endClause			);		yourself.</body></methods><methods><class-id>Store.SQLAssist class</class-id> <category>instance creation</category><body package="Store-DB-Broker" selector="newSQLFor:table:">newSQLFor: aClass table: aString	^ super new 		newSQLStream;		tableName: aString;		tableClass: aClass</body></methods><methods><class-id>Tools.BindingTextualDetailSingularView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="icon:name:text:">icon: aGraphic name: aStringThing text: aText	icon := aGraphic.	name := aStringThing.	text := aText.	self populate</body></methods><methods><class-id>Tools.BindingTextualDetailSingularView</class-id> <category>row population</category><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	| view |	view := TextEditorView model: text asText asValue.	view beReadOnly.	^Array with: view</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| header |	super populateHeader.	header := self header.	header add: icon.	header add: (self italicizedText: name)</body></methods><methods><class-id>Tools.BindingTextualDetailSingularView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^Array with: #singleBindingDetail with: name</body></methods><methods><class-id>Store.Glorp.StoreProtocolEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="bindingReferencesDo:">bindingReferencesDo: aBlock	^environment bindingReferencesDo: aBlock</body><body package="StoreForGlorpBrowserUI" selector="classForName:ifAbsent:">classForName: aString ifAbsent: aBlock	^environment classForName:  aString ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="glorpSession">glorpSession	^environment glorpSession.</body><body package="StoreForGlorpBrowserUI" selector="methodDefinitions">methodDefinitions	| definitions |	definitions := OrderedCollection new.	self classesAndSelectorsDo: 		[:class :selector | 		definitions add: (StoreMethodDefinition class: class selector: selector)].	self sharedVariableReferencesDo: 		[:each | 		definitions add: (InitializerDefinition nameSpace: each environment key: each name)].	^definitions</body><body package="StoreForGlorpBrowserUI" selector="navigatorClass">navigatorClass	^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI" selector="openEditor">openEditor	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI" selector="repositoryName">repositoryName	^environment repositoryName</body><body package="StoreForGlorpBrowserUI" selector="sharedVariableReferencesDo:">sharedVariableReferencesDo: aBlock 	self bindingReferencesDo: 		[:each | 		| binding |		binding := each bindingOrNil.		(binding notNil and: [binding isForSharedVariable and: [binding isInClass]]) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Store.Glorp.StoreProtocolEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI" selector="at:ifAbsent:">at: className ifAbsent: aBlock	^environment at: className ifAbsent: aBlock</body><body package="StoreForGlorpBrowserUI" selector="classesDo:">classesDo: aBlock 	environment allClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]].	environment allMetaClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Store.PseudoPropertiesDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="hasBothDefinitions">hasBothDefinitions	^true</body><body package="Store-Difference Management" selector="isBundleStructureOnly">isBundleStructureOnly	| result |	result := false.	mainObject ifNotNil: [result := mainObject size = 1 and: [mainObject first key = #structure]].	otherObject ifNotNil: [result := result and: [otherPackage pseudoPackage or: [otherObject size = 1 and: [otherObject first key = #structure]]]].	^result</body><body package="Store-Difference Management" selector="isMainDefinedInPackage">isMainDefinedInPackage	^true</body><body package="Store-Difference Management" selector="isOtherDefinedInPackage">isOtherDefinedInPackage	^true</body><body package="Store-Difference Management" selector="isStandin">isStandin	^true</body></methods><methods><class-id>Store.PseudoPropertiesDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="changedMethodsSharedAndProperties">changedMethodsSharedAndProperties	| properties |	properties := OrderedCollection new.	mainObject do:		[:each |		| targetProperty |		properties add: (targetProperty := PseudoPropertyDifference mainPackage: mainPackage property: each).		(otherPackage notNil and: [otherObject isEmpty]) ifTrue: [targetProperty otherPackage: otherPackage]].	otherObject do:		[:each |		| targetProperty |		targetProperty := properties 			detect: [:eachProperty | eachProperty selectorListName = each key]			ifNone: [nil].		targetProperty isNil			ifTrue: [properties add: (PseudoPropertyDifference otherPackage: otherPackage property: each)]			ifFalse: [targetProperty otherPackage: otherPackage property: each]].	^properties</body><body package="Store-Difference Management" selector="classListIcon">classListIcon	^GeneralIcons gear</body><body package="Store-Difference Management" selector="classListName">classListName	^self class classListName</body><body package="Store-Difference Management" selector="mainPackage:properties:">mainPackage: aPackage properties: aCollection	self mainPackage: aPackage object: aCollection</body><body package="Store-Difference Management" selector="modifiedMethodsSharedAndProperties">modifiedMethodsSharedAndProperties	^self changedMethodsSharedAndProperties</body><body package="Store-Difference Management" selector="otherPackage:properties:">otherPackage: aPackage properties: aCollection	self otherPackage: aPackage object: aCollection</body><body package="Store-Difference Management" selector="referencesHolderClass">referencesHolderClass 	^PropertyResolutions</body></methods><methods><class-id>Store.PseudoPropertiesDifference class</class-id> <category>accessing</category><body package="Store-Difference Management" selector="classListName">classListName	^(#BracketPropertiesBracket &lt;&lt; #store &gt;&gt; '[Properties]') asString</body></methods><methods><class-id>Store.PseudoPropertiesDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:properties:">mainPackage: aPackage properties: aCollection	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: aCollection;		yourself</body><body package="Store-Difference Management" selector="otherPackage:properties:">otherPackage: aPackage properties: aCollection	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: aCollection;		yourself</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="classListName">classListName	| dotedName start |	dotedName := otherObject 		ifNil: [mainObject longNameFromSmalltalk]		ifNotNil: [otherObject longNameFromSmalltalk].	start := dotedName lastIndexOf: $..	start = 0 ifTrue: [^dotedName].	^dotedName copyFrom: 1 to: start - 1</body><body package="Store-Difference Management" selector="differenceName">differenceName	^otherObject 		ifNil: [mainObject longNameFromSmalltalk]		ifNotNil: [otherObject longNameFromSmalltalk].</body><body package="Store-Difference Management" selector="mainClassStoreObject">mainClassStoreObject	^mainObject</body><body package="Store-Difference Management" selector="mainDefinition">mainDefinition	^(mainObject isNil		ifTrue: [self notDefinedInThisPackage]		ifFalse: [mainObject]) asText</body><body package="Store-Difference Management" selector="mainPackage:shared:">mainPackage: aPackage shared: aStoreSharedVariable	self mainPackage: aPackage object: aStoreSharedVariable</body><body package="Store-Difference Management" selector="mainProtocol">mainProtocol	^''</body><body package="Store-Difference Management" selector="otherClassStoreObject">otherClassStoreObject	^otherObject</body><body package="Store-Difference Management" selector="otherDefinition">otherDefinition	^(otherObject isNil		ifTrue: [self notDefinedInThisPackage]		ifFalse: [otherObject]) asText</body><body package="Store-Difference Management" selector="otherPackage:shared:">otherPackage: aPackage shared: aStoreSharedVariable	self otherPackage: aPackage object: aStoreSharedVariable</body><body package="Store-Difference Management" selector="otherProtocol">otherProtocol	^''</body><body package="Store-Difference Management" selector="resolutionClass">resolutionClass	^SharedChangeResolver</body><body package="Store-Difference Management" selector="selectorListIcon">selectorListIcon	^VisualStack with: BehaviorIcons Object with: BehaviorIcons SharedVariableOverlay</body><body package="Store-Difference Management" selector="selectorListName">selectorListName	^otherObject 		ifNil: [mainObject name]		ifNotNil: [otherObject name]</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	mainObject fileOutSourceOn: aStream</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	otherObject fileOutSourceOn: aStream</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="isForSharedVariable">isForSharedVariable	^true</body><body package="Store-Difference Management" selector="isShared">isShared	^true</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>loading</category><body package="Store-Difference Management" selector="loadMainDefinitionFrom:">loadMainDefinitionFrom: aStoreClassOrNamespaceOrNil		Store.Policies packagePolicy		forcePackage: mainPackage storeModel		while:			[mainObject loadSource.			mainObject correspondingImageBinding ifNotNil: 				[:value | 				(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]]</body><body package="Store-Difference Management" selector="loadOtherDefinitionFrom:">loadOtherDefinitionFrom: aStoreClassOrNamespaceOrNil	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: 			[otherObject loadSource.			otherObject correspondingImageBinding ifNotNil: 				[:value | 				(self askToReinitializeSharedVariable: value) ifTrue: [value reinitializeValue]]]</body></methods><methods><class-id>Store.PseudoSharedDifference</class-id> <category>user interface</category><body package="Store-Difference Management" selector="askToReinitializeSharedVariable:">askToReinitializeSharedVariable: aVariableBinding		^Dialog confirm: (#ReInitializeSharedVariable &lt;&lt; #store &gt;&gt; '(Re)Initialize Shared Variable : ''&lt;1s&gt;''?' expandMacrosWith: aVariableBinding absoluteName)</body></methods><methods><class-id>Store.PseudoSharedDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:shared:">mainPackage: aPackage shared: aStoreSharedVariable	| instance |	instance := self new.	^instance		mainPackage: aPackage shared: aStoreSharedVariable;		yourself</body><body package="Store-Difference Management" selector="otherPackage:shared:">otherPackage: aPackage shared: aStoreSharedVariable	| instance |	instance := self new.	^instance		otherPackage: aPackage shared: aStoreSharedVariable;		yourself</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource	"Answer nil if there is a failure, otherwise the real thing"	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[[[binding := Compiler evaluate: self definitionString]				on: VariableConfirmation				do: [:exception | exception resume: false]]					on: UnhandledException					do:						[:exception | 						Store.UnloadableDefinitionError signalWith: self.						^nil].			(Undeclared includesKey: binding name) ifTrue:				[Transcript show: (#NSharedVariable1pNotLoadable &lt;&lt; #dialogs &gt;&gt; '&lt;n&gt;Shared Variable &lt;1p&gt; is not loadable... Possible load order problem&lt;n&gt;' expandMacrosWith: binding name).				Store.UnloadableDefinitionError signalWith: self.				^nil]].	^self</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	"Answer nil if there is a failure, otherwise the real thing"	| binding |	self environmentString isEmpty ifTrue:		[Store.UnloadableDefinitionError signalWith: self.		^nil].	[[binding := Compiler evaluate: self definitionString]		on: VariableConfirmation		do: [:exception | exception resume: false]]			on: UnhandledException			do:				[:exception | 				Store.UnloadableDefinitionError signalWith: self.				^nil].	(Undeclared includesKey: binding name) ifTrue:		[Undeclared removeKey: binding name.		self correspondingImageBinding isNil ifTrue: [^nil]].	^self</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="absoluteOwnerName">absoluteOwnerName	^self definition absoluteOwnerName.</body><body package="Store-Code Comparison" selector="asBlueprint">asBlueprint	| definitionParts myReference blueprint |	blueprint := SharedVariableBlueprint of: self.	definitionParts := blueprint parseDefinition: self definition definition.	myReference := self fullName asQualifiedReference.	blueprint reference: myReference.	blueprint category: self protocol.	blueprint isPrivate: (definitionParts at: #private:).	blueprint isConstant: (definitionParts at: #constant:).	blueprint initializer: (definitionParts at: #initializer:).	^blueprint</body><body package="StoreForGlorpVWUI" selector="classNameWithoutMeta">classNameWithoutMeta	^self definition classNameWithoutMeta</body><body package="Store-Database Model" selector="classOrNameSpace">classOrNameSpace	^self owner</body><body package="Store-Database Model" selector="comment">comment	^definition comment</body><body package="StoreForGlorpVWUI" selector="dataKey">dataKey	^self definition dataKey.</body><body package="Store-Database Model" selector="environment">environment	^self owner</body><body package="Store-Database Model" selector="environmentName">environmentName	^self definition environmentName</body><body package="Store-Database Model" selector="key">key	^self dataKey.</body><body package="Store-Database Model" selector="owner">owner	^self definition owner.</body><body package="StoreForGlorpVWUI" selector="ownerName">ownerName	^self definition ownerName.</body><body package="Store-Database Model" selector="protocol">protocol	^self definition protocol</body><body package="Store-Database Model" selector="versions">versions	| session sharedDefinitionQuery shareds uniqueKeys |	session := StoreLoginFactory currentStoreSession.	sharedDefinitionQuery := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	sharedDefinitionQuery alsoFetch: #definition.	sharedDefinitionQuery orderBy: [:each | each definition timestamp descending].	shareds := session execute: sharedDefinitionQuery.	uniqueKeys := Set new.	^shareds inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>comparing</category><body package="Store-Database Model" selector="=">= aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifFalse: [		^self definition = aStoreObjectInPackage asStoreSharedVariable].	^self package yourSelf = aStoreObjectInPackage package yourSelf and: [self definition reconcilesWith: aStoreObjectInPackage definition].</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>testing</category><body package="Store-Database Model" selector="isBindingReference">isBindingReference	^true</body><body package="Store-Database Model" selector="isForData">isForData	^true.</body><body package="StoreForGlorpVWUI" selector="isForGeneral">isForGeneral	^false.</body><body package="Store-Database Model" selector="isForSharedVariable">isForSharedVariable	^true.</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>compatibility</category><body package="Store-Database Model" selector="asNameSpace">asNameSpace	"hack"	^Store.Glorp.StoreNameSpace new</body><body package="Store-Database Model" selector="isInClass">isInClass	^self definition isClassVariable.</body><body package="StoreForGlorpVWUI" selector="loadSrc">loadSrc	^self loadSource</body><body package="StoreForGlorpVWUI" selector="removeFromPackage:">removeFromPackage: aPackageModel	Store.XMainChangeSet current		addRemoveStatic: self dataKey		ownerName: self environmentString		isInNameSpace: self definition isInNameSpace		package: aPackageModel</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>printing</category><body package="Store-Database Model" selector="displayString">displayString	^self name</body><body package="Store-Database Model" selector="printOutOn:">printOutOn: aStream	"Print me out on a textStream"	| saved |	saved := aStream emphasis.	aStream emphasis: #bold.	aStream nextPutAll: self definitionString.	aStream cr.	aStream emphasis: #italic.	aStream cr.	aStream nextPutAll: self definition comment.	aStream emphasis: saved.	aStream cr.	aStream cr</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>filing out</category><body package="Store-Database Model" selector="fileOutDifferencesBetween:on:">fileOutDifferencesBetween: aSharedInPackage on: aSourceCodeStream	self definitionString = aSharedInPackage definitionString ifFalse:		[self fileOutSourceOn: aSourceCodeStream]</body><body package="Store-Database Model" selector="fileOutObjectType">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#variable</body><body package="Store-Database Model" selector="fileOutSourceOn:">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>displaying</category><body package="StoreForGlorpVWUI" selector="statusLineString">statusLineString	^self definition protocol.</body><body package="StoreForGlorpVWUI" selector="variableName">variableName	^self dataKey</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreSharedVariable">asStoreSharedVariable	^self definition</body><body package="Store-Database Model" selector="correspondingImageBinding">correspondingImageBinding	^self definition ifNotNil: [:value | value correspondingImageBinding].</body><body package="Store-Database Model" selector="correspondingImageSharedVariable">correspondingImageSharedVariable	^self definition ifNotNil: [:value | value correspondingImageSharedVariable].</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>reconciling</category><body package="Store-Database Model" selector="equalsSignatureIn:">equalsSignatureIn: aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifFalse: [		^self definition equalsSignatureIn: aStoreObjectInPackage asStoreSharedVariable].	^self package yourSelf = aStoreObjectInPackage package yourSelf and: [self definition equalsSignatureIn: aStoreObjectInPackage definition].</body><body package="Store-Database Model" selector="signatureHash">signatureHash	^self definition signatureHash</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeShared: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineNameSpace:... version of this, not the #defineNameSpace: version,	because the standard version calls link system too soon"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineSharedVariable:' startingAt: 1.	insertPoint isZero ifTrue: [insertPoint := definitionString indexOfSubCollection: 'defineStatic:' startingAt: 1].	^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'.</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedSharedVariableObject</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableInPackage class</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="allVersionsWithName:inOwner:">allVersionsWithName: aString inOwner: anOwnerName	^self allVersionsWithName: aString inOwner: anOwnerName in: Store.Glorp.StoreLoginFactory currentStoreSession.</body><body package="StoreForGlorpVWUI" selector="allVersionsWithName:inOwner:in:">allVersionsWithName: aString inOwner: anOwnerName in: aSession	| query session objects uniqueKeys |	session := aSession.	query := Query		read: self		where: [:eachShared | eachShared definition name = aString AND: [eachShared definition environmentName = anOwnerName]].	query alsoFetch: #definition.	query orderBy: [:each | each definition timestamp descending].	objects := session execute: query.	uniqueKeys := Set new.	^objects inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	^VisualStack with: BehaviorIcons Object with: BehaviorIcons SharedVariableOverlay</body></methods><methods><class-id>Store.PseudoClassForSharedDifference</class-id> <category>accessing</category><body package="Store-Merge Management" selector="modifiedMethodsSharedAndProperties">modifiedMethodsSharedAndProperties	"Answer the truly modified differences."	^self sharedAndMethodDifferences.</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableCodeTool</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="binding">binding	^codeModel binding</body><body package="StoreForGlorpBrowserUI" selector="definitionOfBinding:">definitionOfBinding: binding 	^binding definition asText</body><body package="StoreForGlorpBrowserUI" selector="template">template	^Text new</body></methods><methods><class-id>Store.Glorp.StoreSharedVariableCodeTool</class-id> <category>tab APIs</category><body package="StoreForGlorpBrowserUI" selector="isActive">isActive	^codeModel sharedVariableName notNil		or: [codeModel isData and: [codeModel protocol notNil]]</body><body package="StoreForGlorpBrowserUI" selector="tabName">tabName	^#Share  &gt;&gt; 'Share' &lt;&lt; #browser</body></methods><methods><class-id>Store.UninstallingDatabaseTables</class-id> <category>accessing</category><body package="Store-Base" selector="actionText">actionText	^(#UninstallingDatabaseTables &lt;&lt; #store &gt;&gt; 'Uninstalling Database Tables') asString</body><body package="Store-Base" selector="componentName">componentName	"DO NOT Assume that subject is a CodeComponent"	^self codeComponent isString ifTrue: [self codeComponent] ifFalse: [self codeComponent shortItemString]</body></methods><methods><class-id>Store.Glorp.StorePundlePropertyRelationship</class-id> <category>accessing</category><body package="Store-Database Model" selector="propertyID">propertyID		^propertyID</body><body package="Store-Database Model" selector="propertyID:">propertyID: anObject		propertyID := anObject</body><body package="Store-Database Model" selector="pundleID">pundleID		^pundleID</body><body package="Store-Database Model" selector="pundleID:">pundleID: anObject		pundleID := anObject</body><body package="Store-Database Model" selector="recordType">recordType		^recordType</body><body package="Store-Database Model" selector="recordType:">recordType: anObject		recordType := anObject</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="className">className	^className</body><body package="Atomic Compiling and Loading" selector="ctype">ctype	^ctype</body><body package="Atomic Compiling and Loading" selector="extension">extension	^extension</body><body package="Atomic Compiling and Loading" selector="from:">from: aStoreMethodInPackage	super from: aStoreMethodInPackage.	className := aStoreMethodInPackage className.	selector := aStoreMethodInPackage selector.	ctype := aStoreMethodInPackage version = 'CTYPE'.	extension := (package definesClassNamed: className) not</body><body package="Atomic Compiling and Loading" selector="from:in:">from: aStoreMethod in: aStorePackage	super from: aStoreMethod in: aStorePackage.	className := aStoreMethod className.	selector := aStoreMethod selector.	ctype := aStoreMethod version = 'CTYPE'.	extension := (package definesClassNamed: className) not</body><body package="Atomic Compiling and Loading" selector="mclass">mclass	^shadowCompiledDefinition ifNotNil: [:value | value mclass]</body><body package="Atomic Compiling and Loading" selector="protocol">protocol	^storeObject protocol</body><body package="Atomic Compiling and Loading" selector="selector">selector	^selector</body><body package="Atomic Compiling and Loading" selector="superclassNameFrom:">superclassNameFrom: aCollectionOfShadowedClasses	"We try to get the image class if it is there, otherwise we use the collection of ShadowedClassObject	and see if we can find the class's superclass there"	storeObject correspondingImageClass ifNotNil: [:value | ^value superclass ifNil: ['nil'] ifNotNil: [:innerValue | innerValue absoluteName]].	^(aCollectionOfShadowedClasses 		detect: [:each | each longName = self className]		ifNone: [^'nil']) superclassName.</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>compiling and loading</category><body package="Atomic Compiling and Loading" selector="compileWith:">compileWith: anAtomicAnalysisLoader	[[shadowCompiledDefinition := anAtomicAnalysisLoader shadowDbMethod: storeObject]		on: UnloadableDefinitionError		do:			[:exception | 			anAtomicAnalysisLoader unloadableDefinitions add: (exception definitionRecord: self).			exception resume]]				on: RedefinitionNotification				do: 					[:notification |					anAtomicAnalysisLoader overrides add: notification.					override := true.					notification resume]</body><body package="Atomic Compiling and Loading" selector="installWith:">installWith: anAtomicAnalysisLoader	[anAtomicAnalysisLoader installMethod: self]		on: RedefinitionNotification		do: 			[:notification |			| currentPackage |			currentPackage := notification currentPackage.			(self packageModel name = currentPackage name or: [currentPackage name = Registry nullPackageName]) 				ifFalse: 					[self fixAndInstallNotification: notification.					anAtomicAnalysisLoader overrides add: notification].			notification resume]</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="isExternalMethod">isExternalMethod	^shadowCompiledDefinition isExternalMethod</body><body package="Atomic Compiling and Loading" selector="isMeta">isMeta	^storeObject isMeta</body></methods><methods><class-id>Store.ShadowedMethodObject</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	aStream nextPutAll: 'aShadowedMethod('.	aStream nextPutAll: storeObject signature.	aStream nextPutAll: ') '</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="addClassDefinition:">addClassDefinition: aStoreClassDefinition	"Add the class to the package. Note that this will leave us with a definitionInPackage that has not metaclass. This must be fixed up or we'll have an invalid structure"	(aStoreClassDefinition username isNil or: [aStoreClassDefinition username = '???']) ifTrue: [aStoreClassDefinition username: username].	aStoreClassDefinition timestamp isNil ifTrue: [aStoreClassDefinition timestamp: timestamp].	^classDefinitions add: (StoreClassDefinitionInPackage new package: self; definition: aStoreClassDefinition).</body><body package="Store-Database Model" selector="addMethod:">addMethod: aStoreMethod	(aStoreMethod username isNil or: [aStoreMethod username = '???']) ifTrue: [aStoreMethod username: username].	aStoreMethod timestamp isNil ifTrue: [aStoreMethod timestamp: timestamp].	^methods add: (StoreMethodInPackage new package: self; definition: aStoreMethod).</body><body package="Store-Database Model" selector="addNameSpace:">addNameSpace: aStoreNameSpace	(aStoreNameSpace username isNil or: [aStoreNameSpace username = '???']) ifTrue: [aStoreNameSpace username: username].	aStoreNameSpace timestamp isNil ifTrue: [aStoreNameSpace timestamp: timestamp].	^nameSpaces add: (StoreNamespaceInPackage new package: self; definition: aStoreNameSpace).</body><body package="Store-Database Model" selector="addSharedVariable:">addSharedVariable: aStoreSharedVariable	(aStoreSharedVariable username isNil or: [aStoreSharedVariable username = '???']) ifTrue: [aStoreSharedVariable username: username].	aStoreSharedVariable timestamp isNil ifTrue: [aStoreSharedVariable timestamp: timestamp].	^sharedVariables add: (StoreSharedVariableInPackage new package: self; definition: aStoreSharedVariable).</body><body package="Store-Database Model" selector="allContainedItems">allContainedItems	^#().</body><body package="Store-Database Model" selector="allNameSpaces">allNameSpaces	^nameSpaces , (self sharedVariables select: [:each | each isInClass not])</body><body package="Store-Database Model" selector="allParents">allParents	^#().</body><body package="Store-Database Model" selector="allSubApplications">allSubApplications	^#().</body><body package="Store-Database Model" selector="basicParcel">basicParcel	^parcel</body><body package="Store-Database Model" selector="basicParcel:">basicParcel: aStoreBlob	parcel := aStoreBlob.</body><body package="Store-Database Model" selector="binFile">binFile	^binFile</body><body package="Store-Database Model" selector="binFile:">binFile: anObject	binFile := anObject</body><body package="Store-Database Model" selector="binaryVersion">binaryVersion	"You'd think this could just be ^parcel, but trying to get rid of any proxy and actually return nil if there isn't one"	^parcel isNil ifTrue: [nil] ifFalse: [parcel].</body><body package="Store-Code Comparison" selector="bindingBlueprints">bindingBlueprints	^self classBlueprints , self namespaceBlueprints		, self sharedVariableBlueprints</body><body package="Store-Code Comparison" selector="classBlueprints">classBlueprints	| output |	output := Array new writeStream.	self classDefinitions do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model" selector="classDefinitions">classDefinitions	^classDefinitions.	"^self classes asSortedCollection collect: [:each | each classDefinition]"</body><body package="Store-Database Model" selector="classes">classes	^classDefinitions</body><body package="Store-Database Model" selector="classesDefinedInPackage">classesDefinedInPackage	^self definedClasses.</body><body package="Store-Database Model" selector="classesWithSource">classesWithSource	^fullClasses ifNil: [#()].</body><body package="Store-Database Model" selector="containedItems">containedItems	^#().</body><body package="Store-Database Model" selector="data">data	^sharedVariables.</body><body package="Store-Database Model" selector="dataWithSource">dataWithSource	^sharedVariables.</body><body package="Store-Database Model" selector="datum:forNamed:">datum: aSymbol forNamed: aString	| stringKey |	stringKey := aSymbol asString.	^(self sharedVariables detect: [:each |		each name = stringKey and: [			each definition environmentName = aString]]		ifNone: [nil])</body><body package="Store-Database Model" selector="defined">defined	^self definedClasses.</body><body package="Store-Database Model" selector="definedClasses">definedClasses	^self fullClasses select: [:each | each classDefinition notNil].</body><body package="Store-Database Model" selector="definesClass:">definesClass: aStoreClass	^self definedClasses contains: [:each | each absoluteName = aStoreClass absoluteName]</body><body package="Store-Database Model" selector="definesClassNamed:">definesClassNamed: aString	^self classDefinitions contains: [:each | each absoluteName = aString]</body><body package="Store-Database Model" selector="definesObject:">definesObject: aStoreNameSpace	^nameSpaces contains: [:each | each absoluteName = aStoreNameSpace absoluteName]</body><body package="Store-Database Model" selector="descriptionsAndLevels">descriptionsAndLevels	"Answer a collection of pairs. The first element is the description	the second is level (zero)."	^OrderedCollection with: (Array with: self with: 1)</body><body package="Store-Database Model" selector="emptyChangeSet">emptyChangeSet	"We will get this if we are being used as part of a dbInfo in order to fake out Store loading into using us instead of the database. Ignore this message, as we will do this when we rebuild the proper database info later"	^self.</body><body package="Store-Database Model" selector="environment">environment	| environmentName |	environmentName := self propertyAt: #namespace ifAbsent: [^nil].	^environmentName asQualifiedReference valueOrDo: [nil].</body><body package="Glorp Atomic Compiling" selector="environmentFor:in:">environmentFor: aSelector in: aClass	"Return the environment for the method in question (which we assume we own). If we should not define its scope, return nil"		(self includesDefinitionOf: aClass instanceBehavior absoluteName) ifTrue: [^nil].	^self environment</body><body package="Store-Database Model" selector="extended">extended	^self extendedClasses.</body><body package="Store-Database Model" selector="extendedClasses">extendedClasses	^self fullClasses select: [:each | each classDefinition isNil].</body><body package="Store-Database Model" selector="hasSubApplications">hasSubApplications	^false.</body><body package="Store-Database Model" selector="isRemoved">isRemoved	^false.</body><body package="StoreForGlorpVWUI" selector="itemCount">itemCount	(methods isGlorpProxy and: [methods isInstantiated not]) ifTrue: [^1].	^methods size + classDefinitions size + nameSpaces size + sharedVariables size.</body><body package="StoreForGlorpVWUI" selector="leafItems">leafItems	^Array with: self.</body><body package="Store-Database Model" selector="metaclassesDefinedInPackage">metaclassesDefinedInPackage	^self definedClasses collect: [:each | each classDefinition metaclass].</body><body package="Store-Code Comparison" selector="methodBlueprints">methodBlueprints	| output |	output := Array new writeStream.	self methods do: 			[:each |			| blueprint |			blueprint := MethodBlueprint of: each.			blueprint				classReference: each className asQualifiedReference;				selector: each selector;				isInstanceBehavior: each isMeta not;				source: each sourceCode;				category: each protocol;				package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model" selector="methodDefinitions">methodDefinitions	^methods</body><body package="Store-Database Model" selector="methods">methods	^methods</body><body package="Store-Database Model" selector="methodsForClass:meta:">methodsForClass: aClass meta: aBoolean	^aBoolean 		ifTrue: [methods select: [:each | each absoluteClassName = (aClass absoluteClassName, ' class')]]		ifFalse: [methods select: [:each | each absoluteClassName = aClass absoluteClassName]]</body><body package="Store-Database Model" selector="methodsWithSource">methodsWithSource	^methods</body><body package="Store-Database Model" selector="nameSpaceDefinitions">nameSpaceDefinitions	^self nameSpaces asSortedCollection collect: [:each | each nameSpaceDefinition]</body><body package="Store-Database Model" selector="nameSpaces">nameSpaces	^nameSpaces</body><body package="Store-Database Model" selector="nameSpacesDefinedInPackage">nameSpacesDefinedInPackage	^nameSpaces</body><body package="Store-Database Model" selector="nameSpacesWithSource">nameSpacesWithSource	^nameSpaces</body><body package="Store-Code Comparison" selector="namespaceBlueprints">namespaceBlueprints	| output |	output := Array new writeStream.	self namespaces do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model" selector="namespaces">namespaces	^nameSpaces</body><body package="Store-Database Model" selector="parcel">parcel	self basicParcel yourSelf isNil ifTrue: [^nil].	^self basicParcel binaryData</body><body package="Store-Database Model" selector="parcelID">parcelID	^parcel isNil ifTrue: [nil] ifFalse: [parcel primaryKey].</body><body package="StoreForGlorpVWUI" selector="pseudoPundleClass">pseudoPundleClass	^Store.PseudoPackage</body><body package="Store-Database Model" selector="rootApplication">rootApplication	^self.</body><body package="Store-Database Model" selector="setName">setName	"This will be sent if we are part of the dbInfo for a component while loading. Ignore it, because we're going to replace ourselves with a valid ComponentDescription later."	^self.</body><body package="Store-Code Comparison" selector="sharedVariableBlueprints">sharedVariableBlueprints	| output |	output := Array new writeStream.	self sharedVariableDefinitions do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body><body package="Store-Database Model" selector="sharedVariableDefinitions">sharedVariableDefinitions	^sharedVariables</body><body package="Store-Database Model" selector="sharedVariables">sharedVariables	^sharedVariables</body><body package="Store-Database Model" selector="sharedVariablesForClass:">sharedVariablesForClass: aStoreClass	^sharedVariables select: [:each | each absoluteOwnerName asString = aStoreClass longName]</body><body package="Store-Database Model" selector="sharedVariablesForNamespaceNamed:">sharedVariablesForNamespaceNamed: aString	^sharedVariables select: [:each | each absoluteOwnerName asString = aString]</body><body package="Store-Database Model" selector="signature">signature	^self name, '(', self version, ')'.</body><body package="Store-Database Model" selector="subApplications">subApplications	^#().</body><body package="Store-Database Model" selector="typeStringForBlessing">typeStringForBlessing	^'P'</body><body package="Store-Database Model" selector="withContainedItems">withContainedItems	^(OrderedCollection with: self).</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>testing</category><body package="Store-Database Model" selector="definesClassOrNameSpace:">definesClassOrNameSpace: aClassOrNameSpace	^(self classDefinitions, self nameSpaces) anySatisfy: [:each | each fullName = aClassOrNameSpace fullName].</body><body package="Store-Database Model" selector="definesName:in:">definesName: key in: nameSpace	^true</body><body package="Store-Database Model" selector="definesSelector:forClass:">definesSelector: aString forClass: aStoreClassExtension 	^(aStoreClassExtension instanceMethods 		detect: [:each | each selector = aString]		ifNone: [nil]) notNil</body><body package="StoreForGlorpVWUI" selector="describesPackageNamed:">describesPackageNamed: aString	"Answer true if the description referes to a package named aString"	^self name = aString</body><body package="Store-Database Model" selector="hasExtensions">hasExtensions	"Return true if we extend a class or namespace we don't contain."	^(self fullClasses detect: [:each | each classDefinition isNil] ifNone: [nil]) notNil.</body><body package="Store-Database Model" selector="hasRelatedParcel">hasRelatedParcel	^(parcel == nil) not</body><body package="Store-Database Model" selector="includesClassNamed:">includesClassNamed: aName	^(self classInPackageNamed: aName meta: false) notNil.</body><body package="Store-Database Model" selector="includesDataKey:owner:">includesDataKey: dataKey owner: owner	^self includesDataKey: dataKey ownerName: owner absoluteName.</body><body package="Store-Database Model" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: environmentName	| stringKey |	stringKey := dataKey asString.	^(self sharedVariables detect: [:each |		each name = stringKey and: [			each definition environmentName = environmentName]]		ifNone: [nil]) notNil.</body><body package="Store-Database Model" selector="includesDatum:">includesDatum: aDatumDescriptor	^self includesDataKey: aDatumDescriptor dataKey ownerName: aDatumDescriptor absoluteOwnerName.</body><body package="Store-Database Model" selector="includesDefinitionOf:">includesDefinitionOf: aName  	^( self includesClassNamed: aName ) or: [ self includesNameSpaceNamed: aName ]</body><body package="Store-Database Model" selector="includesMethod:">includesMethod: aMethodDescription	^self includesSelector: aMethodDescription selector className: aMethodDescription absoluteClassName asClassNameOnly meta: aMethodDescription isMeta</body><body package="Store-Database Model" selector="includesNameSpaceNamed:">includesNameSpaceNamed: aName	^(self namespaces detect: [:each | each name = aName] ifNone: [nil]) notNil.</body><body package="Store-Database Model" selector="includesSelector:class:">includesSelector: aSelector class: aClass	^self includesSelector: aSelector asString className: aClass absoluteName asClassNameOnly meta: aClass isMeta.</body><body package="Store-Database Model" selector="includesSelector:className:meta:">includesSelector: aSelector className: aClassName meta: isMeta	| fullClass |	fullClass := self fullClasses at: aClassName ifAbsent: [^false].	isMeta ifTrue: [fullClass := fullClass storeMetaClass].	^fullClass includesSelector: aSelector asString.</body><body package="Store-Database Model" selector="isPublishedBinary">isPublishedBinary	^self hasRelatedParcel</body><body package="Store-Database Model" selector="isValid">isValid	(methods collect: [:each | each definition]) asSet size = methods size ifFalse: [^false].	(methods anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(classDefinitions anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(nameSpaces anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(sharedVariables anySatisfy: [:each | each package yourself ~~ self]) ifTrue: [^false].	(sharedVariables collect: [:each | each definition]) asSet size = sharedVariables size ifFalse: [^false].	^true.</body><body package="Store-Database Model" selector="method:forClassNamed:meta:">method: aSelector forClassNamed: aClassName meta: isMeta		| fullClass |	(methods isGlorpProxy and: [methods isInstantiated not]) &amp; fullClasses isNil		ifTrue:			[| query |			query := Query				readOneOf: StoreMethodInPackage				where:					[:each | 					each package = self &amp; (each definition name = aSelector)						&amp; (each definition className = aClassName | (each definition className = (aClassName , ' class'))) &amp; (each definition isMetaclass = isMeta)].			query alsoFetch: [:each | each definition].			query alsoFetch: [:each | each definition source].			^session execute: query]		ifFalse:			[fullClass := self fullClasses at: aClassName ifAbsent: [self fullClasses at: aClassName asClassNameOnly ifAbsent: [^nil]].			isMeta ifTrue: [fullClass := fullClass storeMetaClass].			^fullClass compiledMethodAt: aSelector asString ifAbsent: [nil]]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>full classes</category><body package="Store-Database Model" selector="fullClassForClass:">fullClassForClass: aStoreClassDefinitionInPackage	"Private - this constructs the class definition part of a full class"	| fullClass |	fullClasses ifNil: [self fullClasses].	fullClass := fullClasses at: aStoreClassDefinitionInPackage longName ifAbsentPut: [		StoreClassExtension new 			name: aStoreClassDefinitionInPackage name;			longName: aStoreClassDefinitionInPackage longName;			package: self].	fullClass classDefinition: aStoreClassDefinitionInPackage.	^fullClass.</body><body package="Store-Database Model" selector="fullClassForMethod:">fullClassForMethod: aStoreMethodInPackage	"Private - this adds the method to the full class in question"	| fullClass |	fullClasses ifNil: [fullClasses := Dictionary new].	fullClass := fullClasses at: aStoreMethodInPackage className ifAbsentPut: [		StoreClassExtension new 			longName: aStoreMethodInPackage className;			package: self].	fullClass addMethod: aStoreMethodInPackage.	^aStoreMethodInPackage isMeta		ifTrue: [fullClass classBehavior]		ifFalse: [fullClass]</body><body package="Store-Database Model" selector="fullClassNamed:fromMethods:classDefinition:">fullClassNamed: aString fromMethods: methodList classDefinition: aClassDefinition	"Given that we already have the methods, so we don't have to read them, construct the class extension"	"Note that aString is the completely, ridiculously qualified name. e.g. Root.Smalltalk.Object"	| |	fullClasses isNil ifTrue: [fullClasses := Dictionary new].	fullClasses isEmpty ifFalse: [^fullClasses at: aString ifAbsent: [nil]].	methodList do: [:each | self fullClassForMethod: each].	aClassDefinition isNil 		ifTrue: [	"If the class had not methods, and we don't have a class definition, then there's no class, just return nil. Otherwise, make sure we know the class definition is explicitly nil"			(fullClasses at: aString ifAbsent: [^nil]) classDefinition: aClassDefinition]		ifFalse: [self fullClassForClass: aClassDefinition].	^fullClasses at: aString ifAbsent: [nil].</body><body package="Store-Database Model" selector="fullClasses">fullClasses	(fullClasses isNil or: [fullClasses isEmpty]) ifTrue: [		fullClasses := Dictionary new.		methods isNil ifFalse: [methods do: [:each | self fullClassForMethod: each]].		classDefinitions isNil ifFalse: [classDefinitions do: [:each | self fullClassForClass: each]]].	^fullClasses.</body><body package="Store-Database Model" selector="fullClasses:">fullClasses: aCollection	fullClasses := (aCollection isKindOf: Dictionary)		ifTrue: [aCollection]		 ifFalse: [				| dict |			dict := Dictionary new.			aCollection do: [:each | dict at: each name put: each].			dict].</body><body package="Store-Database Model" selector="resetFullClasses">resetFullClasses	fullClasses := nil</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>reconciling</category><body package="Store-Database Model" selector="basicReconcileClassDefinition:">basicReconcileClassDefinition: aStoreClassDefinition	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous classDefinitions		detect: [:each | aStoreClassDefinition reconcilesWith: each definition]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch definition].</body><body package="Store-Database Model" selector="basicReconcileMetaClassDefinition:">basicReconcileMetaClassDefinition: aStoreClassDefinition	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous classDefinitions		detect: [:each | aStoreClassDefinition reconcilesWith: each metaclass]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch metaclass].</body><body package="Store-Database Model" selector="basicReconcileMethod:">basicReconcileMethod: aStoreMethod	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous methods		detect: [:each | aStoreMethod reconcilesWith: each definition]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch definition].</body><body package="Store-Database Model" selector="basicReconcileNameSpace:">basicReconcileNameSpace: aStoreNameSpace	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous nameSpaces		detect: [:each | aStoreNameSpace reconcilesWith: each definition ]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch definition].</body><body package="Store-Database Model" selector="basicReconcileSharedVariable:">basicReconcileSharedVariable: aSharedVariable	| exactMatch |	self previous isNil ifTrue: [^nil].	exactMatch := self previous sharedVariables		detect: [:each | aSharedVariable reconcilesWith: each definition ]		ifNone: [nil].	^exactMatch isNil ifTrue: [nil] ifFalse: [exactMatch definition].</body><body package="Store-Database Model" selector="makeProxiesForSubcomponents">makeProxiesForSubcomponents	"If we contain sub-bundles or packages, proxy each one individually"	^self.</body><body package="Store-Database Model" selector="matchesRecursivelyWith:">matchesRecursivelyWith: aStorePundle	"Return true if all of our contents match"	^self matchesWith: aStorePundle.</body><body package="Store-Database Model" selector="matchesWith:">matchesWith: aStorePundle	"Return true if all of our contents match"	(self ifMatchesWith: aStorePundle do: [^true] else: [^false]).	self methods size = aStorePundle methods size ifFalse: [^false].	self methods asSortedCollection with: aStorePundle methods asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].	self classDefinitions size = aStorePundle classDefinitions size ifFalse: [^false].	self classDefinitions asSortedCollection with: aStorePundle classDefinitions asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].	self nameSpaces size = aStorePundle nameSpaces size ifFalse: [^false].	self nameSpaces asSortedCollection with: aStorePundle nameSpaces asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].	self sharedVariables size = aStorePundle sharedVariables size ifFalse: [^false].	self sharedVariables asSortedCollection with: aStorePundle sharedVariables asSortedCollection do: [:one :two |		(one matchesWith: two) ifFalse: [^false]].		^true.</body><body package="Store-Database Model" selector="reconcile">reconcile	"When we share source with our previous version, use it instead of our own"	super reconcile.	self removeDuplicates.	self reconcileMethods.	self reconcileClasses.	self reconcileNameSpaces.	self reconcileSharedVariables.	self reconcileParcel.</body><body package="Store-Database Model" selector="reconcileClass:">reconcileClass: aStoreClassDefinition	| exactMatch previousVersion |	exactMatch := self basicReconcileClassDefinition: aStoreClassDefinition.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreClassDefinition previous: nil].	aStoreClassDefinition previous isNil 		ifTrue: [			previousVersion := self previous classDefinitionFor: aStoreClassDefinition.			previousVersion isNil ifFalse: [aStoreClassDefinition previous: previousVersion definition]]		ifFalse: [aStoreClassDefinition previous: (self previous basicReconcileClassDefinition: aStoreClassDefinition previous)].	^aStoreClassDefinition.</body><body package="Store-Database Model" selector="reconcileClasses">reconcileClasses	self classDefinitions size = self previous classDefinitions size ifFalse: [self markModified].	classDefinitions do: [:each |		each definition: (self reconcileClass: each definition).		each metaclass: (self reconcileMetaClass: each metaclass)].</body><body package="Store-Database Model" selector="reconcileMetaClass:">reconcileMetaClass: aStoreClassDefinition	| exactMatch previousVersion |	exactMatch := self basicReconcileMetaClassDefinition: aStoreClassDefinition.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreClassDefinition previous: nil].	aStoreClassDefinition previous isNil 		ifTrue: [			previousVersion := self previous metaClassDefinitionFor: aStoreClassDefinition.			previousVersion isNil ifFalse: [aStoreClassDefinition previous: previousVersion definition]]		ifFalse: [aStoreClassDefinition previous: (self previous basicReconcileMetaClassDefinition: aStoreClassDefinition previous)].	^aStoreClassDefinition.</body><body package="Store-Database Model" selector="reconcileMethod:">reconcileMethod: aStoreMethod	| exactMatch previousVersion |	exactMatch := self basicReconcileMethod: aStoreMethod.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreMethod previous: nil].	aStoreMethod previous isNil 		ifTrue: [			previousVersion := self previous methodFor: aStoreMethod.			previousVersion isNil ifFalse: [aStoreMethod previous: previousVersion definition]]		ifFalse: [aStoreMethod previous: (self previous basicReconcileMethod: aStoreMethod previous)].	^aStoreMethod.</body><body package="Store-Database Model" selector="reconcileMethods">reconcileMethods	(self methods isEmpty and: [self previous methods isEmpty]) ifTrue: [^self].	methods size = self previous methods size ifFalse: [self markModified].	methods do: [:each |		each definition: (	self reconcileMethod: each definition)].</body><body package="Store-Database Model" selector="reconcileNameSpace:">reconcileNameSpace: aStoreNameSpace	| exactMatch previousVersion |	exactMatch := self basicReconcileNameSpace: aStoreNameSpace.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreNameSpace previous: nil].	aStoreNameSpace previous isNil 		ifTrue: [			previousVersion := self previous nameSpaceFor: aStoreNameSpace.			previousVersion isNil ifFalse: [aStoreNameSpace previous: previousVersion definition]]		ifFalse: [aStoreNameSpace previous: (self previous basicReconcileNameSpace: aStoreNameSpace previous)].	^aStoreNameSpace.</body><body package="Store-Database Model" selector="reconcileNameSpaces">reconcileNameSpaces	(self nameSpaces isEmpty and: [self previous nameSpaces isEmpty]) ifTrue: [^self].	self nameSpaces size = self previous nameSpaces size ifFalse: [self markModified].	nameSpaces do: [:each |		each definition: (self reconcileNameSpace: each definition)].</body><body package="Store-Database Model" selector="reconcileParcel">reconcileParcel	self basicParcel = self previous basicParcel yourSelf		ifTrue: [parcel := self previous basicParcel]		 ifFalse: [self markModified].</body><body package="Store-Database Model" selector="reconcileSharedVariable:">reconcileSharedVariable: aStoreSharedVariable	| exactMatch previousVersion |	exactMatch := self basicReconcileSharedVariable: aStoreSharedVariable.	exactMatch isNil ifFalse: [^exactMatch] ifTrue: [self markModified].	self previous isNil ifTrue: [^aStoreSharedVariable previous: nil].	aStoreSharedVariable previous isNil 		ifTrue: [			previousVersion := self previous sharedVariableFor: aStoreSharedVariable.			previousVersion isNil ifFalse: [aStoreSharedVariable previous: previousVersion definition]]		ifFalse: [aStoreSharedVariable previous: (self previous basicReconcileSharedVariable: aStoreSharedVariable previous)].	^aStoreSharedVariable.</body><body package="Store-Database Model" selector="reconcileSharedVariables">reconcileSharedVariables	(self sharedVariables isEmpty and: [self previous sharedVariables isEmpty]) ifTrue: [^self].	self sharedVariables size = self previous sharedVariables size ifFalse: [self markModified].	sharedVariables do: [:each |		each definition: (self reconcileSharedVariable: each definition)].</body><body package="Store-Database Model" selector="unreconcile">unreconcile	"We have no previous version. Remove any references to it"	super unreconcile.	methods do: [:each | each unreconcile].	classDefinitions do: [:each | each unreconcile].	nameSpaces do: [:each | each unreconcile].	sharedVariables do: [:each | each unreconcile].</body><body package="Store-Database Model" selector="unreconcileBlessings">unreconcileBlessings	" I don't believe that blessings are ever shared between versions"	blessings do: [:each | each unreconcile].</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>changes</category><body package="Store-Database Model" selector="changedClassDefinitionsFrom:">changedClassDefinitionsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #classes</body><body package="Store-Database Model" selector="changedMethodsFrom:">changedMethodsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #methods</body><body package="Store-Database Model" selector="changedNameSpaceDefinitionsFrom:">changedNameSpaceDefinitionsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #nameSpaces</body><body package="Store-Database Model" selector="changedSharedVariableDefinitionsFrom:">changedSharedVariableDefinitionsFrom: aStorePackage 	"Return a collection of StoreMethods that don't occur in aStorePackage, but occurs in self."	^self changesFrom: aStorePackage ofType: #sharedVariables</body><body package="Store-Database Model" selector="changesFrom:ofType:">changesFrom: aStorePackage ofType: aSymbol 	"Return a collection of objects that don't occur in aStorePackage, but occurs in self."	| new existing |	new := OrderedCollection new.	existing := Set withAll: (aStorePackage perform: aSymbol).	(self perform: aSymbol) 		do: [:each | (existing includes: each) ifFalse: [new add: each]].	^new</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>loading</category><body package="Store-Database Model" selector="binLoadWithin:">binLoadWithin: parentBundle	"Supress unloadable code dialog in the intial load.	Handle redefininitions by short-circutting the bundle/package handler."	| packageModel record unloadable |	(record := self binaryVersion) ifNil: [^nil].	unloadable := OrderedCollection new.	packageModel := Registry packageNamed: name.	[[[packageModel isNil		ifTrue:			[packageModel := (Registry packageNamedOrCreate: name)				dbTrace: self primaryKey;				loadFrom: record using: CodeReader new;				yourself]		ifFalse: [packageModel updateFrom: record within: parentBundle]]			on: CodeReader requestWarningSuppressionSignal			do: [:exception | exception resume: true]]				on: RedefinitionNotification				do: [:notification | notification resume]]					on: self class imageClass fileFormatSignal					do: [:exception | exception return: nil].	packageModel ifNil: [^nil].	[self checkUninstalledClasses: packageModel]		on: UnloadableDefinitionError		do:			[:exception | 			exception package: packageModel.			unloadable add: exception.			exception resume].	unloadable isEmpty ifFalse:		[Store.UnloadableDefinitionsViewer openOnExceptions: unloadable].	packageModel ifNotNil:		[packageModel			dbTrace: self primaryKey;			markNotModified].	^packageModel</body><body package="Store-Database Model" selector="binLoadWithin:using:">binLoadWithin: parentBundle using: aCompilationManager	"Supress unloadable code dialog in the intial load.	Handle redefininitions by short-circutting the bundle/package handler."	| packageModel record unloadable |	(record := self binaryVersion) ifNil: [^nil].	(Loading for: self) started.	unloadable := OrderedCollection new.	packageModel := Registry packageNamed: name.	[[[packageModel isNil		ifTrue:			[packageModel := (Registry packageNamedOrCreate: name)				loadFrom: record using: CodeReader new with: aCompilationManager;				yourself]		ifFalse: [packageModel updateFrom: record within: parentBundle]]			on: CodeReader requestWarningSuppressionSignal			do: [:exception | exception resume: true]]				on: RedefinitionNotification				do: [:notification | notification resume]]					on: self class imageClass fileFormatSignal					do: [:exception | exception return: nil].	packageModel ifNil: 		[(Loading for: self) finished.		^nil].	[self checkUninstalledClasses: packageModel]		on: UnloadableDefinitionError		do:			[:exception | 			exception package: packageModel.			unloadable add: exception.			exception resume].	unloadable isEmpty ifFalse:		[Store.UnloadableDefinitionsViewer openOnExceptions: unloadable].	packageModel ifNotNil:		[ | databaseInformation |		databaseInformation := packageModel databaseInformationOrCreate.		packageModel			setDbTraceAndVersionUsing: self for: databaseInformation dbIdentifier;			markNotModified].	(Loading for: self) finished.	^packageModel</body><body package="Store-Database Model" selector="checkUninstalledClasses:">checkUninstalledClasses: imgPackage	"Determine if there are any uninstalled classes or methods and deal with them appropriately."		| uninstalledClasses uninstalledMethods uninstalledBindings |	uninstalledClasses := imgPackage		propertyAt: #uninstalledClasses		ifAbsent: [OrderedCollection new].	uninstalledMethods := imgPackage		propertyAt: #uninstalledMethods		ifAbsent: [OrderedCollection new].	uninstalledBindings := imgPackage		propertyAt: #uninstalledBindings		ifAbsent: [OrderedCollection new].	(uninstalledMethods isEmpty and: [uninstalledClasses isEmpty and: [uninstalledBindings isEmpty]])		ifFalse: [self checkUninstalledClasses: uninstalledClasses methods: uninstalledMethods bindings: uninstalledBindings]</body><body package="Store-Database Model" selector="checkUninstalledClasses:methods:bindings:">checkUninstalledClasses: aCollectionOfClasses methods: aCollectionOfMethods bindings: aCollectionOfBindings	"Determine why the uninstalled can't be installed and display a message box informing the user.	Signal the unloadable exception for the browser."		| clsRecords methRecords dataRecords |	clsRecords := self classesNamed: (aCollectionOfClasses collect: [:each | each absoluteName]).	methRecords := (aCollectionOfMethods collect:		[:each | 		self 			method: each selector 			forClassNamed: each implementingClass absoluteName 			meta: each implementingClass isMeta]) asOrderedCollection.	dataRecords := OrderedCollection new.	aCollectionOfClasses do:		[:eachClass | 		eachClass selectors do:			[:eachSelector | 			methRecords add: (self method: eachSelector forClassNamed: eachClass absoluteName meta: false)].		eachClass class selectors do:			[:eachSelector | 			methRecords add: (self method: eachSelector forClassNamed: eachClass absoluteName meta: true)].		dataRecords addAll:			(eachClass asNameSpace keys collect:				[:key | 				self datum: key forOwnerNamed: eachClass absoluteName])].	aCollectionOfBindings do:		[:eachBinding | 		eachBinding asNameSpace keys do:			[:key | 			dataRecords add: (self datum: key forOwnerNamed: eachBinding absoluteName)]].	LoadAnalyzer checkUninstalledForPackage: self classes: clsRecords methods: methRecords data: dataRecords.	clsRecords asOrderedCollection , methRecords , dataRecords do: [:each | UnloadableDefinitionError signalWith: each]</body><body package="StoreForGlorpVWUI" selector="dbLoadWithin:">dbLoadWithin: aBundle	"We are being told to load within the context of a Store.Bundle. Turn ourselves into an appropriate Store entity and do what it would do in these circumstances"	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource).	self loadSource</body><body package="Store-Database Model" selector="directCompileAndLoad">directCompileAndLoad	| packageModel isNew success unloadables |	Glorp.Dialect reset.	(Loading for: self) started.	(self checkPrerequisitesWithin: nil with: nil) ifFalse: 		[(Loading for: self) finished.		^nil].	(isNew := self getImagePundle isNil) ifTrue: 		[self runPreRead ifFalse: 			[(Loading for: self) finished.			^nil]].	(self binaryVersion notNil and: [Policies publishPolicy allowBinaryLoading]) ifTrue: 		[[^self binLoadWithin: nil using: nil] ensure: [(Loading for: self) finished]].	packageModel := self createImagePundle.	unloadables := OrderedCollection new.	self storeModel: packageModel.	Policies packagePolicy		forcePackage: packageModel		while: 			[XMainChangeSet ignoreMainChangesWhile:				[success := isNew					ifTrue: [self loadDirectNewCapturing: unloadables]					ifFalse: [self loadDirectDeltasCapturing: unloadables]]].	unloadables notEmpty ifTrue: [UnloadableDefinitionsViewer openOnExceptions: unloadables].	self postLoad: packageModel.	self resetStoreModel.	packageModel cleanse: false.	self applyPundleVersionsToTheImage.	unloadables isEmpty		ifTrue: [packageModel markNotModified]		ifFalse: [packageModel reconcileWithDbVersion: self].	(Loading for: self) finished.	^success		ifTrue: [packageModel]		ifFalse: [nil]</body><body package="Store-Database Model" selector="initializeClasses">initializeClasses	self initializeClasses: self classesDefinedInPackage methods: self methods</body><body package="Store-Database Model" selector="initializeClasses:methods:">initializeClasses: aCollectionOfClasses methods: aCollectionOfMethods	| extensions alreadyInitialized |	alreadyInitialized := OrderedCollection new.	extensions := aCollectionOfMethods select: [:each | each version ~= 'CTYPE' and: [(self definedClasses at: each className ifAbsent: [nil]) isNil]].	(extensions select: [:each | each isMeta and: [each selector = #initialize]]) do: 		[:each | (alreadyInitialized add: each correspondingImageClass nonMeta) postLoad: storeModel].	(SystemUtils sortForLoading: (aCollectionOfClasses collect: [:each | each correspondingImageClass])) do: 		[:each | 		each ifNotNil: [:value | (alreadyInitialized includes: value) ifFalse: 			[[value postLoad: storeModel]				on: InitializerFailedError				do: [:exception | exception resignalAs: MessageNotUnderstood new]]]]</body><body package="Store-Database Model" selector="initializeShareds">initializeShareds	self initializeShareds: self sharedVariables</body><body package="Store-Database Model" selector="initializeShareds:">initializeShareds: anOrderedCollection	anOrderedCollection do: 		[:each | each correspondingImageBinding ifNotNil: [:value | value reinitializeValue]]</body><body package="Store-Database Model" selector="loadClasses">loadClasses	^self loadClasses: self classesDefinedInPackage values</body><body package="Store-Database Model" selector="loadClasses:">loadClasses: aCollection	| failed |	failed := OrderedCollection new.	(self class superclassOrder: aCollection) do: 		[:each | 		each loadSourceDirect ifNil: [failed add: each]].	^failed</body><body package="Store-Database Model" selector="loadData:ownerName:ifNone:">loadData: aSymbol ownerName: aString ifNone: aBlock	"Load the data specified from the database."	| sharedVariableInPackage |	sharedVariableInPackage := self sharedVariable: aSymbol inPackageForOwnerNamed: aString.	sharedVariableInPackage isNil 		ifTrue: [aBlock value]		ifFalse: [sharedVariableInPackage loadSource]</body><body package="Store-Database Model" selector="loadDirectDeltasCapturing:">loadDirectDeltasCapturing: anOrderedCollection	| packageComparitor |	self runPreLoad ifFalse: [^false].	packageComparitor := PackageComparitor 		differencesBetween: self 		and: self storeModel.	packageComparitor hasDifferences ifFalse: [^true].	[[SystemUtils modifySystem:		[self loadNamespaces: packageComparitor mainPackageNamespaces.		self loadClasses: packageComparitor mainPackageClasses.		self loadShareds: packageComparitor mainPackageShareds].	self loadMethods: packageComparitor mainPackageMethods.	self initializeShareds: packageComparitor mainPackageShareds.	self initializeClasses: packageComparitor mainPackageClasses methods: packageComparitor mainPackageMethods.	self storeModel removeDeletedDefinitions: packageComparitor]		on: RedefinitionNotification		do: 			[:notification |			notification currentPackage = self storeModel				ifFalse: [notification override install].			notification resume]]				on: UnloadableDefinitionError				do: 					[:exception |					anOrderedCollection add: exception.					exception resume].	^true</body><body package="Store-Database Model" selector="loadDirectNewCapturing:">loadDirectNewCapturing: anOrderedCollection	| failed |	self runPreLoad ifFalse: [^false].	[[SystemUtils modifySystem:		[self loadNamespaces.		failed := self loadClasses.		self loadFailedClasses: failed.		self loadShareds.		self loadFailedClasses: failed.		anOrderedCollection addAll: (failed collect: 			[:each | 			Store.UnloadableDefinitionError new			definitionRecord: (each asStoreObjectInPackage: self)])].	self loadMethods.	self initializeShareds.	self initializeClasses]		on: RedefinitionNotification		do: 			[:notification |			notification currentPackage = self storeModel				ifFalse: [notification override install].			notification resume]]				on: UnloadableDefinitionError				do: 					[:exception |					anOrderedCollection add: exception.					exception resume].	^true</body><body package="Store-Database Model" selector="loadFailedClasses:">loadFailedClasses: aCollection	aCollection copy do:		[:each |		each loadSourceDirect ifNotNil: [aCollection remove: each]]</body><body package="Store-Database Model" selector="loadMethod:className:ifNone:">loadMethod: aSymbol className: aString ifNone: aBlock	"Load the method specified from the database.		aSelector		aSymbol		fullClassName	aString  		noneBlock		aBlock - execute if there is no such method in the package"		| methodInPackage |	methodInPackage := self 		method: aSymbol 		forClassNamed: aString asClassNameOnly 		meta: aString namesMetaClass.	methodInPackage isNil ifTrue: [^aBlock value].	methodInPackage loadSource</body><body package="Store-Database Model" selector="loadMethods">loadMethods	"There is an issue when loading extensions to the ExternalInterface class (or meta) 	because the parser's external instance variable is nil, 	and it will blow when nil is sent #notifyCompilationOfTypeDefinitionFromClass:.	However, that is not a problem for that class! So, we simply say resume!"	self loadMethods: self methods</body><body package="Store-Database Model" selector="loadMethods:">loadMethods: aCollection	"There is an issue when loading extensions to the ExternalInterface class (or meta) 	because the parser's external instance variable is nil, 	and it will blow when nil is sent #notifyCompilationOfTypeDefinitionFromClass:.	However, that is not a problem for that class! So, we simply say resume!"	(self sortedMethodsForLoading: aCollection) do:		[:each |		[each loadSourceDirect]			on: MessageNotUnderstood			do: 				[:exception |				exception parameter selector = #notifyCompilationOfTypeDefinitionFromClass:					ifTrue: [exception resume: nil].				exception pass]]</body><body package="Store-Database Model" selector="loadNamespaces">loadNamespaces	self loadNamespaces: self nameSpaces</body><body package="Store-Database Model" selector="loadNamespaces:">loadNamespaces: aCollection	aCollection do: [:each | each loadSourceDirect]</body><body package="Store-Database Model" selector="loadShareds">loadShareds	self loadShareds: self sharedVariables</body><body package="Store-Database Model" selector="loadShareds:">loadShareds: aCollection	| failed |	failed := OrderedCollection new.	aCollection do: [:each | each loadSourceDirect ifNil: [failed add: each]].	failed notEmpty ifTrue: [failed do: [:each | UnloadableDefinitionError signalWith: each]].</body><body package="Glorp Atomic Compiling" selector="preCompileWith:">preCompileWith: aCompilationManager	"Run approapiate actions before compiling. Answer true if okay to continue."	| parentBundleOrNil |	aCompilationManager ifNotNil:		[parentBundleOrNil := aCompilationManager pundle isBundle 			ifTrue: [aCompilationManager pundle] 			ifFalse: [nil]].	(self checkPrerequisitesWithin: parentBundleOrNil with: aCompilationManager)		ifFalse: [^false].	^true</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>comparison</category><body package="Store-Database Model" selector="computeDifferencesBetween:into:">computeDifferencesBetween: aPackage into: aPackageComparitor	"If aPackage is already a StorePackage, compute the diffs ourselves. 	Otherwise, convert it into one, either by reading it from the database if it's a Package, or by converting the image packageModel"		| other |	other := (aPackage pseudoPackage or: [aPackage class = self class])		ifTrue: [aPackage]		ifFalse:			[aPackage primaryKey = 0				ifTrue: [aPackage asStoreComparisonObjectIn: self session]				ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aPackage primaryKey]]].	^other computeDifferencesBetweenDBPackage: self into: aPackageComparitor</body><body package="Store-Database Model" selector="computeDifferencesBetweenDBPackage:into:">computeDifferencesBetweenDBPackage: aPackage into: aPackageComparitor	^self computeDiffsBetweenDBPackage: aPackage into: aPackageComparitor</body><body package="Store-Database Model" selector="computeDiffsBetween:into:">computeDiffsBetween: aPackage into: aPackageComparitor	"If aPackage is already a StorePackage, compute the diffs ourselves. 	Otherwise, convert it into one, either by reading it from the database if it's a Package, or by converting the image packageModel"		| other |	other := (aPackage pseudoPackage or: [aPackage class = self class])		ifTrue: [aPackage]		ifFalse:			[aPackage primaryKey = 0				ifTrue: [aPackage asStoreComparisonObjectIn: self session]				ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aPackage primaryKey]]].	^other computeDifferencesBetweenDBPackage: self into: aPackageComparitor</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>fixups</category><body package="Store-Database Model" selector="removeDuplicates">removeDuplicates	"We appear to be able to have duplicates, at least of methods, in the database. 	Remove them before proceeding. But don't bother if we're read from the database, 	because we aren't going to be written back anyway"	| classNames invalid indexes compactedNameSpaces |	self primaryKey isNil ifFalse: [^self].	methods := self uniqueObjectsIn: self methods.	sharedVariables := self uniqueObjectsIn: self sharedVariables.	compactedNameSpaces := self uniqueObjectsIn: self nameSpaces.	compactedNameSpaces size = self nameSpaces size ifFalse: [		nameSpaces := nameSpaces select: [:each |			| there |			there := compactedNameSpaces includes: each.			compactedNameSpaces remove: each ifAbsent: [].			there]].	classNames := Set new.	invalid := OrderedCollection new.	classDefinitions reverseDo: [:each |		(classNames includes: each longName) ifTrue: [invalid add: each].		classNames add: each longName].	indexes := OrderedCollection new.	invalid do: [:each | indexes add: (classDefinitions indexOf: each). classDefinitions removeIndex: indexes last].</body><body package="StoreForGlorpVWUI" selector="sortClassesForLoading">sortClassesForLoading	"Organize our classes and namespaces into an order that should load properly. Note that we rely on the image classes for this, so this will only work if their ordering corresponds to our own. Since this is really only used for publishing, that should be fine."	| defs reverseDefs sorted |	defs := classDefinitions collect: [:each | each definition correspondingImageClass ifNil: [each]].	reverseDefs := IdentityDictionary new.	classDefinitions with: defs do: [:eachStoreClass :eachImageClass |		reverseDefs at: eachImageClass put: eachStoreClass].	sorted := SystemUtils sortForLoading: defs.	classDefinitions := sorted collect: [:each | reverseDefs at: each].</body><body package="StoreForGlorpVWUI" selector="sortForLoading">sortForLoading	"Organize our classes and namespaces into an order that should load properly. Note that we rely on the image classes for this, so this will only work if their ordering corresponds to our own. Since this is really only used for publishing, that should be fine. Only works in VisualWorks. We could do our own sort for other dialects, but wouldn't be able to do much more than superclass order."	Dialect isVisualWorks ifFalse: [^self].	self sortClassesForLoading.	self sortNamespacesForLoading.</body><body package="Store-Database Model" selector="sortNamespacesForLoading">sortNamespacesForLoading	"Organize our classes and namespaces into an order that should load properly. Note that we rely on the image classes for this, so this will only work if their ordering corresponds to our own. Since this is really only used for publishing, that should be fine."	| defs reverseDefs sorted |	defs := nameSpaces collect: [:each | each definition correspondingImageNamespace].	reverseDefs := IdentityDictionary new.	nameSpaces with: defs do: [:eachStoreNamespace :eachImageNamespace |		reverseDefs at: eachImageNamespace put: eachStoreNamespace].	sorted := SystemUtils sortForLoading: defs.	nameSpaces := sorted collect: [:each | reverseDefs at: each].</body><body package="Store-Database Model" selector="uniqueObjectsIn:">uniqueObjectsIn: aCollection	| wrappers answer |	answer := OrderedCollection new.	wrappers := aCollection collect: [:each | StoreSignatureObject for: each].	wrappers asSet do: [:each | answer add: each signatureObject].	^answer</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="initialize">initialize	super initialize.	classDefinitions := OrderedCollection new.	nameSpaces := OrderedCollection new.	sharedVariables := OrderedCollection new.	methods := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>private</category><body package="Store-Database Model" selector="privateSetMethods:">privateSetMethods: aCollection	methods := aCollection.</body><body package="Store-Database Model" selector="sortedMethods:">sortedMethods: aCollection	| orderedMethods classesWithMethods orderedClasses |	classesWithMethods := Dictionary new.	orderedMethods := OrderedCollection new.	aCollection do:		[:each | 		[(classesWithMethods			at: each correspondingImageClass			ifAbsentPut: [OrderedCollection new]) add: each]				on: UnhandledException				do:					[:exception | 					UnloadableDefinitionError new						originalError: exception;						parameter: each;						raise.					exception return]].	orderedClasses := SystemUtils metaclassesFirst: (SystemUtils sortForLoading: classesWithMethods keys).	orderedClasses do: [:each | orderedMethods addAll: (classesWithMethods at: each)].	^orderedMethods</body><body package="Store-Database Model" selector="sortedMethodsForLoading:">sortedMethodsForLoading: aCollectionOfStoreMethod	"We sort out first any CTYPE methods, which come first	Then we sort out defined in package classes by class hierarchy	Finally we sort of extension methods by class hierarchy"	| cTypeMethods sortedMethods definedMethods extensionMethods |	sortedMethods := OrderedCollection new.	cTypeMethods := aCollectionOfStoreMethod select: [:each | each version = 'CTYPE'].	sortedMethods addAll: (self sortedMethods: cTypeMethods).	definedMethods := aCollectionOfStoreMethod select: 		[:each | each version ~= 'CTYPE' and: [(self definedClasses at: each className ifAbsent: [nil]) notNil]].	sortedMethods addAll: (self sortedMethods: definedMethods).	extensionMethods := aCollectionOfStoreMethod select: 		[:each | each version ~= 'CTYPE' and: [(self definedClasses at: each className ifAbsent: [nil]) isNil]].	sortedMethods addAll: (self sortedMethods: extensionMethods).	^sortedMethods</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>constants</category><body package="Store-Database Model" selector="componentType">componentType	^#package</body><body package="Glorp Atomic Compiling" selector="defaultCompileManager">defaultCompileManager	^ShadowPackageCompileManager</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>enumerating</category><body package="Store-Database Model" selector="allComponentsDo:">allComponentsDo: aBlock	aBlock value: self.</body><body package="StoreForGlorpVWUI" selector="classDefinitionFor:">classDefinitionFor: aClassDefinitionDescription	^self classDefinitions detect: [:each |			(each definition longName = aClassDefinitionDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI" selector="classInPackageNamed:meta:">classInPackageNamed: aClassName meta: aBoolean	| selector theClass |	selector := (aClassName includes: $.) ifTrue: [#longName] ifFalse: [#name].	theClass := self classes detect: [:each | (each perform: selector) = aClassName] ifNone: [^nil].	^(aBoolean ifTrue: [theClass metaclass] ifFalse: [theClass]) definition.</body><body package="Store-Database Model" selector="componentsDetect:ifNone:">componentsDetect: aBlock ifNone: missingBlock	(aBlock value: self) ifTrue: [^self].	^missingBlock value.</body><body package="StoreForGlorpVWUI" selector="datum:forOwnerNamed:">datum: dataKey forOwnerNamed: environmentName		^(self sharedVariables 		detect: [:each | each definition dataKey = dataKey and: [each definition environmentName = environmentName]]		ifNone: [^nil]) definition</body><body package="StoreForGlorpVWUI" selector="descriptionClass">descriptionClass	^PackageDescription</body><body package="StoreForGlorpVWUI" selector="metaClassDefinitionFor:">metaClassDefinitionFor: aClassDefinitionDescription	^self classDefinitions detect: [:each |			(each metaclass longName = aClassDefinitionDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI" selector="methodFor:">methodFor: aMethodDescriptor	^self methods detect: [:each |		(each isMetaclass = aMethodDescriptor isMeta) and: [			(each definition name = aMethodDescriptor selector asString)				and: [each className = aMethodDescriptor fullClassName asString]]]					ifNone: [nil].</body><body package="StoreForGlorpVWUI" selector="nameSpaceFor:">nameSpaceFor: aNamespaceDescription	^self nameSpaces detect: [:each |			(each definition longName = aNamespaceDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI" selector="nameSpaceInPackageNamed:">nameSpaceInPackageNamed: aString		^(self nameSpaces detect: [:each | each definition longName = aString] ifNone: [nil]) ifNotNil: [:value | value definition]</body><body package="StoreForGlorpVWUI" selector="sharedVariable:inPackageForOwnerNamed:">sharedVariable: aSymbol inPackageForOwnerNamed: aString		^(self sharedVariables 		detect: [:each | each definition dataKey = aSymbol and: [each definition environmentName = aString]]		ifNone: [^nil])</body><body package="StoreForGlorpVWUI" selector="sharedVariableFor:">sharedVariableFor: aSharedVariableDescription	^self sharedVariables detect: [:each |			(each definition longName = aSharedVariableDescription longName asString)]					ifNone: [nil].</body><body package="StoreForGlorpVWUI" selector="sharedVariableWithLongName:">sharedVariableWithLongName: aString		^self sharedVariables 		detect: [:each | each definition longName = aString] 		ifNone: [nil]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	nameSpaces := nameSpaces collect: [:each | each glorpCopyIn: aDictionary].	classDefinitions := classDefinitions collect: [:each | each glorpCopyIn: aDictionary].	sharedVariables := sharedVariables collect: [:each | each glorpCopyIn: aDictionary].	methods := methods collect: [:each | each glorpCopyIn: aDictionary].	parcel := parcel isNil ifTrue: [nil] ifFalse: [parcel glorpCopyIn: aDictionary].</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>converting</category><body package="Store-Database Model" selector="classesNamed:">classesNamed: aSetOfNames	"Convert aSetOfnames into a collection of StoreClassesInPackage or PseudoClasses."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:each :other | each name &lt; other name].	self classes do:		[:each | 		(names includes: each absoluteName) ifTrue:			[names remove: each absoluteName.			selected add: each]].	names do: [:each | selected add: (PseudoClass newNamed: each)].	^selected</body><body package="StoreForGlorpVWUI" selector="ownRecordForTag:">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^self recordForTag: aTag</body><body package="StoreForGlorpVWUI" selector="recordForClassTag:">recordForClassTag: aTag	| theName |	theName := aTag className asString.	^self classDefinitions		detect: [:each | each longName = theName]		ifNone: [nil].</body><body package="StoreForGlorpVWUI" selector="recordForDataTag:">recordForDataTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there."		^(self sharedVariables isNil or: [self sharedVariables isEmpty])		ifTrue: [nil]		ifFalse: [self sharedVariable: aTag dataKey inPackageForOwnerNamed: aTag ownerName asString]</body><body package="StoreForGlorpVWUI" selector="recordForMethodTag:">recordForMethodTag: aTag	^self methodFor: aTag.</body><body package="StoreForGlorpVWUI" selector="recordForNameSpaceTag:">recordForNameSpaceTag: aTag	"Answer the item in this package corresponding to 'aTag' or nil if not there."		^self nameSpaces detect: [:each | each absoluteName = aTag name] ifNone: [nil]</body><body package="StoreForGlorpVWUI" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Packages don't have structure objects so, answer nil"	^nil</body><body package="StoreForGlorpVWUI" selector="recordForTag:">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' 	or nil if not there."	^aTag recordForPackage: self.</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>private-file out</category><body package="StoreForGlorpVWUI" selector="fileOutClassesOn:">fileOutClassesOn: aSourceFileManager	self classDefinitions do:		[:each |		aSourceFileManager storeObjectDefinition: each.		each comment notEmpty ifTrue: [aSourceFileManager comment: each value: each comment]]</body><body package="StoreForGlorpVWUI" selector="fileOutMethodsOn:">fileOutMethodsOn: aSourceFileManager	"First group methods by class and protocol 	and the ask aFileManager to do the job class by class"		| toFileOut classes protocols |	toFileOut := Dictionary new.	self methodDefinitions do:		[:each | 		classes := toFileOut			at: each longNameFromSmalltalk			ifAbsent: [Dictionary new].		protocols := classes			at: each protocol asString			ifAbsent: [Set new].		protocols add: each.		classes			at: each protocol asString			put: protocols.		toFileOut			at: each longNameFromSmalltalk			put: classes.		(each name = 'initialize' and: [each absoluteClassName namesMetaClass])			ifTrue: [aSourceFileManager initializeThisClass: (PseudoClass newNamed: each longNameFromSmalltalk asClassNameOnly)]].	toFileOut keysAndValuesDo:		[:key :value | 		aSourceFileManager fileOutTTMessages: value for: key logging: false.		aSourceFileManager cr].</body><body package="StoreForGlorpVWUI" selector="fileOutNameSpacesOn:">fileOutNameSpacesOn: aSourceFileManager		self nameSpaces do:		[:each | 		aSourceFileManager storeObjectDefinition: each.		each comment isEmpty ifFalse: [aSourceFileManager comment: each value: each comment]]</body><body package="StoreForGlorpVWUI" selector="fileOutOn:">fileOutOn: aSourceFileManager	"When saving a Package to a aFileManager we need to ensure that there is a change to	create the package, this is why ComponentCreatedChange is used.  Also, to ensure	 that the aFileManager stores the package ownership information for any definitions	this package has. "		aSourceFileManager deferInitializations.	(ComponentCreatedChange new component: self) fileOutOn: aSourceFileManager.	aSourceFileManager sourceFormatter attributeFor: #package compute: [:ignore | self name].	aSourceFileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | self name].	aSourceFileManager cr.	aSourceFileManager addComment: 'Package ' , self itemString.	self fileOutPropertiesOn: aSourceFileManager.	self fileOutNameSpacesOn: aSourceFileManager.	self fileOutClassesOn: aSourceFileManager.	self fileOutSharedsOn: aSourceFileManager.	self fileOutMethodsOn: aSourceFileManager.	aSourceFileManager finishInitializations.	aSourceFileManager cr</body><body package="StoreForGlorpVWUI" selector="fileOutSharedsOn:">fileOutSharedsOn: aSourceFileManager	self sharedVariables do:		[:each | 		aSourceFileManager storeObjectDefinition: each.		each comment isEmpty ifFalse: [aSourceFileManager comment: each value: each comment]]</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>comparing</category><body package="Store-Database Model" selector="allClassesInPackage:butNotIn:">allClassesInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage classDefinitions])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage classDefinitions]).</body><body package="Store-Database Model" selector="allIn:butNotIn:">allIn: aCollection butNotIn: anotherCollection	| dictionary |	dictionary := Dictionary new.	aCollection do: [:each | dictionary at: each definition put: each].	aCollection isEmpty ifTrue: [^#()].	anotherCollection do: [:each | dictionary removeKey: each definition ifAbsent: []].	^dictionary asArray collect: [:each | each definition].</body><body package="Store-Database Model" selector="allMethodsInPackage:butNotIn:">allMethodsInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage methods])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage methods]).</body><body package="Store-Database Model" selector="allNamespacesInPackage:butNotIn:">allNamespacesInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage nameSpaces])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage nameSpaces]).</body><body package="Store-Database Model" selector="allSharedsInPackage:butNotIn:">allSharedsInPackage: aStorePackage butNotIn: anotherStorePackage	^self		allIn: (aStorePackage ifNil: [#()] ifNotNil: [aStorePackage sharedVariables])		butNotIn: (anotherStorePackage ifNil: [#()] ifNotNil: [anotherStorePackage sharedVariables]).</body><body package="Store-Database Model" selector="computeDiffsBetweenDBPackage:into:">computeDiffsBetweenDBPackage: aStorePackage into: aPackageComparitor	"Store  differences between receiver and a aStorePackage into an instance of PackageComparitor.	Store receiver's definitions as main and the other as other since this method	is called with arguments reversed."	| realOtherPackage |	realOtherPackage := (aStorePackage isNil or: [aStorePackage class == self class]) 		ifTrue: [aStorePackage] 		ifFalse: [self session readOneOf: self class where: [:each | each primaryKey = aStorePackage primaryKey]].	self = realOtherPackage ifTrue: [aPackageComparitor makeEmpty. ^self].	aPackageComparitor otherPackageMethods: (self allMethodsInPackage: self butNotIn: realOtherPackage).	aPackageComparitor mainPackageMethods: (self allMethodsInPackage: realOtherPackage butNotIn: self).	aPackageComparitor otherPackageShareds: (self allSharedsInPackage: self butNotIn: realOtherPackage).	aPackageComparitor mainPackageShareds: (self allSharedsInPackage: realOtherPackage butNotIn: self).	aPackageComparitor otherPackageNamespaces: (self allNamespacesInPackage: self butNotIn: realOtherPackage).	aPackageComparitor mainPackageNamespaces: (self allNamespacesInPackage: realOtherPackage butNotIn: self).	aPackageComparitor otherPackageClasses: (self allClassesInPackage: self butNotIn: realOtherPackage).	aPackageComparitor mainPackageClasses: (self allClassesInPackage: realOtherPackage butNotIn: self).	^aPackageComparitor</body><body package="StoreForGlorpVWUI" selector="computeFullDiffsBetweenDBPackage:into:">computeFullDiffsBetweenDBPackage: aDBPackage into: aComparitor	^self computeDiffsBetweenDBPackage: aDBPackage into: aComparitor.</body><body package="StoreForGlorpVWUI" selector="describesSameAs:">describesSameAs: aComponentDescr	"Copied from Store.PackageDescription"	"Answer true if aComponentDescr referes to	a package named the same as my bundle"	^aComponentDescr isPackage		and: [ self describesPackageNamed: aComponentDescr name ].</body></methods><methods><class-id>Store.Glorp.StorePackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="pundleInstallClass">pundleInstallClass	^PackageInstall</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>private-utilities</category><body package="Store-Database Model" selector="superclassOrder:">superclassOrder: aCollectionOfStoreClasses	"Sort all of the classes in the list into a collection where no class is preceded by a subclass or 	by its metaclass. I cannot use method in SystemUtils since the classes are not in the image"		| workingCopy orderedClasses classNames |	workingCopy := aCollectionOfStoreClasses copy.	orderedClasses := OrderedCollection new.	[workingCopy isEmpty]		whileFalse:			[classNames := workingCopy collect: [:each | each absoluteName].			workingCopy copy do:				[:each | 				(each isPseudo not and: [classNames includes: each superclassName])					ifFalse:						[orderedClasses add: each.						workingCopy remove: each]]].	^orderedClasses</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>constants</category><body package="Store-Database Model" selector="propertyTypeCode">propertyTypeCode	^1.</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="imageClass">imageClass	^PackageModel</body><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	^BehaviorIcons PackageDisconnected</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>query utility</category><body package="Store-Database Model" selector="hasRelatedParcelFor:">hasRelatedParcelFor: aPackageModel	^self hasRelatedParcelFor: aPackageModel In: StoreLoginFactory currentStoreSession</body><body package="Store-Database Model" selector="hasRelatedParcelFor:In:">hasRelatedParcelFor: aPackageModel In: aSessionOrNil	| session query primaryKey |	session := aSessionOrNil ifNil: [StoreLoginFactory currentStoreSession].	(primaryKey := aPackageModel dbTrace) ifNil: [^false].	query := Query count: self where: [:each | each primaryKey = primaryKey AND: (each parcel notNil)].	^(session execute: query) &gt; 0</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>database-utilities</category><body package="Store-Database Model" selector="allNonBinaryNamesIn:">allNonBinaryNamesIn: aSessionOrNil	| names |	names := super allNonBinaryNamesIn: aSessionOrNil.	names := names asSortedCollection asOrderedCollection.	^names select: 		[:each | 		(Gathering for: each) announce.		(self allVersionsWithName: each in: aSessionOrNil) allSatisfy: [:eachPackage | eachPackage binaryVersion isNil]]</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>initialize-release</category><body package="Store-DB-BaseObjects" selector="initialize">initialize	super initialize.	self tableOwnerListHolder value: 		self knownTableOwners asSortedCollection.</body><body package="Store-DB-BaseObjects" selector="initializeAspects">initializeAspects	super initializeAspects.	tableOwnerHolder := self profileAspect: #tableOwner.</body><body package="Store-DB-BaseObjects" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	( builder componentAt: #tableOwnerCombo ) 			widget controller continuousAccept: true.	self profileChanged "cause update"</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>notifications</category><body package="Store-DB-BaseObjects" selector="profileSelected">profileSelected	| profile name |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name] ifNone: [^self].	currentProfileHolder value: profile copy.	DbRegistry tablePrefix: profile tableOwner.	(StoreSettings preferenceModelFor: #tablePrefix) value: profile tableOwner</body><body package="Store-DB-BaseObjects" selector="tableOwnerChanged">tableOwnerChanged	self resetProfileName</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="createNewProfile">createNewProfile	| profile databaseNames |	profile := ConnectionProfile new.	databaseNames := self knownDatabases.	databaseNames isEmpty ifFalse:		[profile driverClassName: databaseNames first].	profile tableOwner: 'BERN'.	^profile</body><body package="Store-DB-BaseObjects" selector="knownDatabases">knownDatabases	"Only include those for which Store is available."	| coll |	coll := OrderedCollection new.	SQLBroker allSubclasses do:		[ :sb | 		( sb class includesSelector: #connectionClass )			ifTrue: [ coll add: sb connectionClass name ]		].	^coll</body><body package="Store-DB-BaseObjects" selector="knownTableOwners">knownTableOwners	"Collect tableOwners used in the existing connection profiles."	^(self allProfiles collect: [:each | each tableOwner]) asSet</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>aspects</category><body package="Store-DB-BaseObjects" selector="tableOwnerHolder">tableOwnerHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerHolder isNil		ifTrue:[ tableOwnerHolder := String new asValue ]		ifFalse:	[ tableOwnerHolder ]</body><body package="Store-DB-BaseObjects" selector="tableOwnerListHolder">tableOwnerListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerListHolder isNil		ifTrue: [ tableOwnerListHolder := List new asValue ]		ifFalse: 	[ tableOwnerListHolder ]</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>utility</category><body package="Store-DB-BaseObjects" selector="unsafeConnect:">unsafeConnect: aProfile	| connection |	connection := super unsafeConnect: aProfile.	StoreLoginFactory		currentStoreSessionFromProfile: aProfile		andItsConnection: connection.	^connection.</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>store</category><body package="Store-DB-Broker" selector="connectionProfileClass">connectionProfileClass	"We could get away with just writing ConnectionProfile here, because both the receiver and the 	 ConnectionProfile class we desire live are in the Store namespace.  However, to prevent any 	 confusion we are explicit in this by using a literal binding reference."	^Store.ConnectionProfile</body><body package="Store-DB-Broker" selector="openConnectionUsing:">openConnectionUsing: aProfile	"Open the dialog with aProfile and then open the database connection that was selected.	Answer the opened connection or nil if the dialog was cancelled."	| profile connection |	profile := aProfile.	[ ( profile := self openProfile: profile ) == nil		ifTrue: [ ^nil ].	connection := self connect: profile.	connection == nil.	] whileTrue.	DbRegistry updateTablePrefix: profile tableOwner.	^connection.</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="chooseProfile">chooseProfile	"Open the connection dialog. After it is closed answer either the	connection profile with parameters selected by the user if it was accepted	or nil if the dialog was cancelled."	| instance |	instance := self new.	instance updateProfileList.	^instance open		ifTrue: [instance currentProfile]		ifFalse: [nil]</body><body package="Store-DB-BaseObjects" selector="profiles">profiles	^RepositoryManager repositories</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="add:">add: aResult	results addLast: aResult</body><body package="Atomic Compiling and Loading" selector="finishInstall">finishInstall		results do: [:each | each finishInstall].	hasRunPostLoad ifFalse: 		[bundle postLoad: bundle createImagePundle using: self.		hasRunPostLoad := true].	bundle applyPundleVersionsToTheImage.</body><body package="Atomic Compiling and Loading" selector="install">install		| bundleModel |	bundleModel := self installWithoutPostLoad ifNil: [^self].	bundle applyPundleVersionsToTheImage.	hasRunPostLoad		ifTrue: [bundleModel markNotModified]		ifFalse: [bundle postLoad: bundleModel using: self].	hasRunPostLoad := true.</body><body package="Atomic Compiling and Loading" selector="installWithoutBundlePostLoad">installWithoutBundlePostLoad		| bundleModel |	bundleModel := self installWithoutPostLoad ifNil: [^self].	hasRunPostLoad ifTrue: [bundleModel markNotModified]</body><body package="Atomic Compiling and Loading" selector="installWithoutPostLoad">installWithoutPostLoad		| bundleModel |	installed ifFalse:		[bundle runPreRead ifFalse: [^nil].		bundle runPreLoad ifFalse: [^nil].		bundleModel := bundle createImagePundle.		bundleModel initializeFromDB: bundle].	results do: [:each | each installed ifFalse: [SystemUtils modifySystem: [each install]]].	^installed 		ifFalse: [bundleModel] 		ifTrue: [bundle createImagePundle]</body><body package="Atomic Compiling and Loading" selector="installed">installed		installed == true 		ifFalse: 			[self installWithoutBundlePostLoad.			installed := true]		ifTrue: 			[results do: [:each | each installed ifFalse: [SystemUtils modifySystem: [each install]]].			hasRunPostLoad ifFalse: 				[bundle postLoad: bundle createImagePundle using: self.				hasRunPostLoad := true]].	^true</body><body package="Atomic Compiling and Loading" selector="installedWithoutBundlePostLoad">installedWithoutBundlePostLoad		installed == true 		ifFalse: 			[self installWithoutBundlePostLoad.			installed := true]		ifTrue: [results do: [:each | each installed ifFalse: [SystemUtils modifySystem: [each install]]]].	^true</body><body package="Atomic Compiling and Loading" selector="markContentsInstalled">markContentsInstalled	results do: [:each | each markContentsInstalled]</body><body package="Atomic Compiling and Loading" selector="markContentsInstalled:">markContentsInstalled: aBoolean	results do: [:each | each markContentsInstalled: aBoolean]</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="hasChanges">hasChanges	^results isEmpty not</body><body package="Atomic Compiling and Loading" selector="hasChangesToLoad">hasChangesToLoad		^results allSatisfy: [:each | each hasChanges]</body><body package="Atomic Compiling and Loading" selector="hasShadowClassMatching:">hasShadowClassMatching: aClass	^self results anySatisfy: [:each | each hasShadowClassMatching: aClass]</body><body package="Atomic Compiling and Loading" selector="hasShadowMethodMatching:">hasShadowMethodMatching: aCompiledMethod	^self results anySatisfy: [:each | each hasShadowMethodMatching: aCompiledMethod]</body><body package="Atomic Compiling and Loading" selector="isAtomicallyLoadable">isAtomicallyLoadable	"Answer false if the bundle contains an override of itself, or if any of our subcomponents are not atomically loadable."	^results allSatisfy: [:each | each isAtomicallyLoadable].</body><body package="Atomic Compiling and Loading" selector="isCodeReader">isCodeReader	^false</body><body package="Atomic Compiling and Loading" selector="isCompilationResult">isCompilationResult	^true</body><body package="Atomic Compiling and Loading" selector="isForBundle">isForBundle	^true</body><body package="Atomic Compiling and Loading" selector="isFullyLoaded">isFullyLoaded	"Answer true if no there are no unloadables"		^self isAtomicallyLoadable and: [((results reject: [:each | each = self]) contains: [:each | each isFullyLoaded not]) not]</body><body package="Atomic Compiling and Loading" selector="needsEarlyInstall">needsEarlyInstall	bundle propertyAt: #installBeforeContinuing ifAbsent: [^false].	^true</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="bundle">bundle	^bundle</body><body package="Atomic Compiling and Loading" selector="bundle:">bundle: anObject	bundle := anObject</body><body package="Atomic Compiling and Loading" selector="component">component	^bundle</body><body package="Atomic Compiling and Loading" selector="leafItems">leafItems	^self results inject: OrderedCollection new into:		[:sum :each |		sum addAll: each leafItems.		sum]</body><body package="Atomic Compiling and Loading" selector="overrides">overrides	"I myself never have any, but my sub results may"		^#()</body><body package="Atomic Compiling and Loading" selector="packageDifferences">packageDifferences	^nil</body><body package="Atomic Compiling and Loading" selector="pundle">pundle	^self bundle.</body><body package="Atomic Compiling and Loading" selector="results">results		^results</body><body package="Atomic Compiling and Loading" selector="shadowedObjects">shadowedObjects	^#()</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitions">unloadableDefinitions	^results inject: OrderedCollection new into: 		[ :collection :res | 		collection addAll: (res unloadableDefinitions); yourself			].</body><body package="Atomic Compiling and Loading" selector="unloadableDefinitionsForBrowsing">unloadableDefinitionsForBrowsing	"Answer a collection of Unloadable with the package set."	^results inject: OrderedCollection new into: 		[ :collection :res | 		collection addAll: (res unloadableDefinitionsForBrowsing); yourself			].</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>initialize-release</category><body package="Atomic Compiling and Loading" selector="initialize">initialize		results := OrderedCollection new.	hasRunPostLoad := false.	installed := false.</body></methods><methods><class-id>BundleCompilationResult</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $&lt;;		nextPutAll: bundle name;		nextPut: $&gt;.</body></methods><methods><class-id>BundleCompilationResult class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="new">new		^super new initialize</body></methods><methods><class-id>Store.Glorp.StandardResolution</class-id> <category>accessing</category><body package="Store-Merge Management" selector="resolver">resolver	^resolver</body><body package="Store-Merge Management" selector="resolver:">resolver: aResolver	resolver := aResolver</body><body package="Store-Merge Management" selector="value">value	^resolver</body></methods><methods><class-id>Store.Glorp.StandardResolution</class-id> <category>testing</category><body package="Store-Merge Management" selector="canBrowseVersions">canBrowseVersions	^true</body><body package="Store-Merge Management" selector="isStandardResolution">isStandardResolution	^true</body><body package="Store-Merge Management" selector="sameAsImageUsing:">sameAsImageUsing: aChangeResolver	resolver isImageObject not ifTrue: [^resolver sameAsImage].	^aChangeResolver sameDefinitionAs: resolver</body></methods><methods><class-id>Store.Glorp.StandardResolution</class-id> <category>comparing</category><body package="Store-Merge Management" selector="=">= aResolution	^self class = aResolution class and:		[self package = aResolution package and:		[self value = aResolution value]]</body></methods><methods><class-id>Store.Glorp.StandardResolution class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="package:resolver:">package: aPackage resolver: aResolver	| instance |	instance := self new.	instance package: aPackage.	instance resolver: aResolver.	^instance</body></methods><methods><class-id>Store.StoreLoggingTool</class-id> <category>views</category><body package="Store-Base" selector="collector">collector	| textCollectorView |	textCollectorView := TextCollectorView model: self textCollector.	textCollectorView editText: self textCollector value.	textCollectorView controller: TextEditorController new.	^textCollectorView</body></methods><methods><class-id>Store.DatabaseIdentifier</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="identityName">identityName	^ identityName</body><body package="Store-DB-BaseObjects" selector="identityName:">identityName: aString	identityName := aString.</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	^OrderedCollection with: self  identityName</body></methods><methods><class-id>Store.DatabaseIdentifier</class-id> <category>private-utilities</category><body package="Store-DB-BaseObjects" selector="installInDatabase1">installInDatabase1	"Create a corresponding record in the database."	| str stream  ind | 	str := self installSqlString.	ind := str findString: ':identity' startingAt: 1.	stream := (String new: 100) writeStream.	stream nextPutAll: (str copyFrom: 1 to: ind - 1).	stream nextPut: $'.	stream nextPutAll: self identityName, ''')'.  	str := String readFrom: stream.	self broker process: stream contents.</body></methods><methods><class-id>Store.DatabaseIdentifier class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="createDatabaseTable1">createDatabaseTable1	"Creates a corresponding database table and force you to enter DB identifier."	| identifier |		[(identifier := Dialog 				request: #PleaseEnterTheDatabaseIdentifier &lt;&lt; #store &gt;&gt; 'Please, enter the database identifier.'				initialAnswer: '') notEmpty] 			whileFalse.	self broker createDatabaseTable: self.	self broker 		grantForClass: self		permissions: #('SELECT')		toUsers: #('PUBLIC').	self newDBIdentifier: identifier.	DbRegistry databaseIdentifier: identifier</body><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'identityName' put: #PrimaryKeyString.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="installInDatabase">installInDatabase	"Asks the user to identify the database. Does not take no for an answer."	| identifier |		[(identifier := Dialog 				request: #EnterAUniqueNameForThisStoreRepository &lt;&lt; #store &gt;&gt; 'Enter a unique name for this Store repository:'				initialAnswer: '') notEmpty] 			whileFalse.	self newDBIdentifier: identifier.	DbRegistry databaseIdentifier: identifier</body><body package="Store-DB-BaseObjects" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	self broker grantForClass: self permissions: #('SELECT' 'UPDATE') toUsers: #('PUBLIC').</body></methods><methods><class-id>Store.DatabaseIdentifier class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="newDBIdentifier:">newDBIdentifier: aString	self new		identityName: aString;		installInDatabase.</body></methods><methods><class-id>Store.DatabaseIdentifier class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="databaseIdentifier">databaseIdentifier	^[ self databaseIdentifierSQL]		on: Error		do: [ :exception | exception return: nil.].</body><body package="Store-DB-BaseObjects" selector="databaseIdentifierSQL">databaseIdentifierSQL	^ (self broker processSQL: 			( self newSQL selectAll) bindOutput: self newPrimed)			first			identityName</body><body package="Store-DB-BaseObjects" selector="getDatabaseIdentifier">getDatabaseIdentifier	^ self databaseIdentifierSQL</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentInspectPropertiesTool</class-id> <category>initialize-release</category><body package="StoreForGlorpBrowserUI" selector="initialize">initialize	"We specifically do NOT call super initialize."	inspector := Tools.Trippy.InspectorHolder		with: (StoreCodeComponentPropertyInspector on: nil).	^self</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>testing</category><body package="Store-Difference Management" selector="isMeta">isMeta	^otherObject 		ifNil: [mainObject isMeta]		ifNotNil: [otherObject isMeta]</body><body package="Store-Difference Management" selector="isMethod">isMethod	^true</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>accessing</category><body package="Store-Difference Management" selector="classListName">classListName	^otherObject 		ifNil: [mainObject longNameFromSmalltalk]		ifNotNil: [otherObject longNameFromSmalltalk]</body><body package="Store-Difference Management" selector="differenceName">differenceName	^otherObject 		ifNil: [mainObject signature]		ifNotNil: [otherObject signature]</body><body package="Store-Difference Management" selector="mainClassStoreObject">mainClassStoreObject	^mainObject</body><body package="Store-Difference Management" selector="mainDefinition">mainDefinition		^(mainObject isNil 		ifTrue: [self notDefinedInThisPackage] 		ifFalse: [mainObject]) asText</body><body package="Store-Difference Management" selector="mainPackage:method:">mainPackage: aPackage method: aStoreMethod	self mainPackage: aPackage object: aStoreMethod</body><body package="Store-Difference Management" selector="mainProtocol">mainProtocol	^(mainObject isNil		ifTrue: ['']		ifFalse: [mainObject protocol]) asText</body><body package="Store-Difference Management" selector="otherClassStoreObject">otherClassStoreObject	^otherObject</body><body package="Store-Difference Management" selector="otherDefinition">otherDefinition	^(otherObject isNil		ifTrue: [self notDefinedInThisPackage]		ifFalse: [otherObject]) asText</body><body package="Store-Difference Management" selector="otherPackage:method:">otherPackage: aPackage method: aStoreMethod	self otherPackage: aPackage object: aStoreMethod</body><body package="Store-Difference Management" selector="otherProtocol">otherProtocol	^(otherObject isNil		ifTrue: ['']		ifFalse: [otherObject protocol]) asText</body><body package="Store-Difference Management" selector="resolutionClass">resolutionClass	^MethodChangeResolver</body><body package="Store-Difference Management" selector="selectorListIcon">selectorListIcon	^CompiledMethod toolListIcon</body><body package="Store-Difference Management" selector="selectorListName">selectorListName	^otherObject 		ifNil: [mainObject selector asString]		ifNotNil: [otherObject selector asString]</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>loading</category><body package="Store-Difference Management" selector="loadMainDefinitionFrom:">loadMainDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: mainPackage storeModel		while: [mainObject loadSource].</body><body package="Store-Difference Management" selector="loadOtherDefinitionFrom:">loadOtherDefinitionFrom: aStoreClassOrNamepace	Store.Policies packagePolicy 		forcePackage: otherPackage storeModel		while: [otherObject loadSource].</body></methods><methods><class-id>Store.PseudoMethodDifference</class-id> <category>fileIn/Out</category><body package="Store-Difference Management" selector="fileOutMainOn:from:">fileOutMainOn: aStream from: aStoreClassOrNamespace	mainObject fileOutSourceOn: aStream</body><body package="Store-Difference Management" selector="fileOutOtherOn:from:">fileOutOtherOn: aStream from: aStoreClassOrNamespace	otherObject fileOutSourceOn: aStream</body></methods><methods><class-id>Store.PseudoMethodDifference class</class-id> <category>instance creation</category><body package="Store-Difference Management" selector="mainPackage:method:">mainPackage: aPackage method: aStoreMethod	| instance |	instance := self new.	^instance 		mainPackage: aPackage object: aStoreMethod;		yourself</body><body package="Store-Difference Management" selector="otherPackage:method:">otherPackage: aPackage method: aStoreMethod	| instance |	instance := self new.	^instance 		otherPackage: aPackage object: aStoreMethod;		yourself</body></methods><methods><class-id>Store.UserManagementPoliciesNotInstalledNotice</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction		Dialog warn:		(#ToAddUserManagementStallUserManagement &lt;&lt; #store &gt;&gt;		'To add user management policies later, execute:&lt;n&gt;''StoreDescriptorSystem installUserManagementPolicies''') expandMacros</body></methods><methods><class-id>Store.UserManagementPoliciesNotInstalledNotice class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus</category><body package="Store-Difference Management" selector="classesMenu">classesMenu	^(self mainMenu atNameKey: #AmpClass) submenu</body><body package="Store-Difference Management" selector="definitionMenu">definitionMenu	definitionMenu ifNotNil: [^definitionMenu].	definitionMenu := Menu		labelList:			(Array				with:					(Array						with: #DoIt &lt;&lt; #dialogs &gt;&gt; 'Do it'						with: #PrintIt &lt;&lt; #dialogs &gt;&gt; 'Print it'						with: #InspectIt &lt;&lt; #dialogs &gt;&gt; 'Inspect it'						with: #DebugIt &lt;&lt; #dialogs &gt;&gt; 'Debug it')				with: (Array with: #Explain &lt;&lt; #menus &gt;&gt; 'Explain')) , ParagraphEditor editGroupLabels		values: #(#doIt #printIt #inspectIt #debugIt #explain) , ParagraphEditor editGroupSelectors.	ParagraphEditor decorateTextItemsIn: definitionMenu.	ParagraphEditor decorateEvaluationItemsIn: definitionMenu.	^definitionMenu</body><body package="Store-Difference Management" selector="mainMenu">mainMenu	| menu |	menu := self class mainMenu.	menu		augmentFrom: self class		to: self class		menuName: #mainMenu		for: self.	^menu</body><body package="Store-Difference Management" selector="methodsMenu">methodsMenu	^(self mainMenu atNameKey: #AmpDefinition) submenu</body><body package="Store-Difference Management" selector="noMenu">noMenu	^Menu new</body><body package="Store-Difference Management" selector="packageMenu">packageMenu	^(self mainMenu atNameKey: #AmpPackage) submenu</body><body package="Store-Difference Management" selector="textController">textController	^(self widgetAt: #FromDefinition) controller</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>private interface configuration</category><body package="Store-Difference Management" selector="bothObjectEmphasisSelected:">bothObjectEmphasisSelected: aBoolean		^#bold</body><body package="Store-Difference Management" selector="bothObjectsIn:emphasisSelected:">bothObjectsIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean		(aClassNamespaceOrPropertiesDifference isMainDefinedInPackage or: [aClassNamespaceOrPropertiesDifference isOtherDefinedInPackage])		ifFalse: [^#none].	^#bold</body><body package="Store-Difference Management" selector="classAndPseudoLabelUsing:in:selected:">classAndPseudoLabelUsing: aClassNamespaceOrPropertiesDifference in: aSelectionInList selected: aBoolean	| mainString iconPart |	mainString := aClassNamespaceOrPropertiesDifference classListName asText.	aClassNamespaceOrPropertiesDifference hasBothDefinitions		ifTrue: [mainString emphasizeAllWith: (self bothObjectsIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean)]		ifFalse: 			[aClassNamespaceOrPropertiesDifference hasOnlyMainDefinition				ifTrue: [mainString emphasizeAllWith: (self mainObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean)]				ifFalse: [mainString emphasizeAllWith: (self otherObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean)]].	iconPart := LabelAndIcon 		with: mainString		attributes: aSelectionInList textStyle.	iconPart icon: aClassNamespaceOrPropertiesDifference classListIcon.	iconPart offset: 2 @ 0.	^iconPart</body><body package="Store-Difference Management" selector="compositeViewUsing:startingAt:in:selected:">compositeViewUsing: aPackageComparitor startingAt: anInteger in: aSequenceView selected: aBoolean	| mainPackageLabel otherPackageLabel currentStart mainString differLabel mainThing iconPart otherString secondIconPart |	mainString := aPackageComparitor mainVersionNameString.	otherString := aPackageComparitor otherVersionNameString.	iconPart := LabelAndIcon with: '' offset: 2 @ 0.	iconPart icon: aPackageComparitor mainPackage toolListIcon.	currentStart := iconPart width + 2.	mainPackageLabel := Label				with: (mainString asText						emphasizeAllWith: (self mainObjectEmphasisSelected: aBoolean))				attributes: aSequenceView textStyle				offset: currentStart @ 0.	currentStart := currentStart + anInteger.	differLabel := Label				with: ' ==&gt; ' asText				attributes: aSequenceView textStyle				offset: currentStart @ 0.	currentStart := differLabel width + 2.	secondIconPart := LabelAndIcon with: '' offset: currentStart @ 0.	secondIconPart icon: aPackageComparitor otherPackage toolListIcon.	currentStart := secondIconPart width + 2.	otherPackageLabel := Label				with: (otherString asText						emphasizeAllWith: (self otherObjectEmphasisSelected: aBoolean))				attributes: aSequenceView textStyle				offset: currentStart @ 0.	mainThing := CompositePart new.	mainThing		add: iconPart;		add: mainPackageLabel;		add: differLabel;		add: secondIconPart;		add: otherPackageLabel;		yourself.	^mainThing</body><body package="Store-Difference Management" selector="mainObjectEmphasisSelected:">mainObjectEmphasisSelected: aBoolean	^aBoolean 		ifTrue: [#bold]		ifFalse: [(Array with: #bold with: #color -&gt; ColorValue blue)]</body><body package="Store-Difference Management" selector="mainObjectIn:emphasisSelected:">mainObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean	| emphasis |	emphasis := aClassNamespaceOrPropertiesDifference isMainDefinedInPackage 		ifTrue: [#bold]		ifFalse: 			[ | targetObject|			targetObject := aClassNamespaceOrPropertiesDifference mainClassStoreObject.			targetObject isNil				ifTrue: [#none]				ifFalse:					[(targetObject isForClassOrExtension 						ifTrue: [targetObject isImageObject ifTrue: [targetObject] ifFalse: [targetObject correspondingImageClass]]						ifFalse: [(targetObject isForSharedVariable ifTrue: [targetObject correspondingImageBinding] ifFalse: [targetObject correspondingImageNamespace])])							ifNil: [#italic]							ifNotNil: [#none]]].	^aBoolean 		ifTrue: [emphasis]		ifFalse: [(Array with: emphasis with: #color -&gt; ColorValue blue)]</body><body package="Store-Difference Management" selector="methodOrPropertiesLabelUsing:in:selected:">methodOrPropertiesLabelUsing: aMethodOrSharedOrPropertyDifference in: aSelectionInList selected: aBoolean	| mainString iconPart |	mainString := aMethodOrSharedOrPropertyDifference selectorListName asText.	aMethodOrSharedOrPropertyDifference hasBothDefinitions		ifTrue: [mainString emphasizeAllWith: (self bothObjectEmphasisSelected: aBoolean)]		ifFalse: 			[aMethodOrSharedOrPropertyDifference hasOnlyMainDefinition				ifTrue: [mainString emphasizeAllWith: (self mainObjectEmphasisSelected: aBoolean)]				ifFalse: [mainString emphasizeAllWith: (self otherObjectEmphasisSelected: aBoolean)]].	iconPart := LabelAndIcon 		with: mainString		attributes: aSelectionInList textStyle.	iconPart icon: aMethodOrSharedOrPropertyDifference selectorListIcon.	iconPart offset: 2 @ 0.	^iconPart</body><body package="Store-Difference Management" selector="otherObjectEmphasisSelected:">otherObjectEmphasisSelected: aBoolean		^aBoolean 		ifTrue: [#bold]		ifFalse: [(Array with: #bold with: #color -&gt; ColorValue purple)]</body><body package="Store-Difference Management" selector="otherObjectIn:emphasisSelected:">otherObjectIn: aClassNamespaceOrPropertiesDifference emphasisSelected: aBoolean	| emphasis |	emphasis := aClassNamespaceOrPropertiesDifference isOtherDefinedInPackage 		ifTrue: [#bold]		ifFalse: 			[ | targetObject|			targetObject := aClassNamespaceOrPropertiesDifference otherClassStoreObject.			targetObject isNil				ifTrue: [#none]				ifFalse:					[(targetObject isForClassOrExtension 						ifTrue: [targetObject isImageObject ifTrue: [targetObject] ifFalse: [targetObject correspondingImageClass]]						ifFalse: [targetObject isForSharedVariable ifTrue: [targetObject correspondingImageBinding] ifFalse: [targetObject correspondingImageNamespace]])							ifNil: [#italic]							ifNotNil: [#none]]].	^aBoolean 		ifTrue: [emphasis]		ifFalse: [(Array with: emphasis with: #color -&gt; ColorValue purple)]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>aspects</category><body package="Store-Difference Management" selector="classesAndProperties">classesAndProperties	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classesAndProperties isNil		ifTrue:			[classesAndProperties := SelectionInList new]		ifFalse:			[classesAndProperties]</body><body package="Store-Difference Management" selector="comparedPackages">comparedPackages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^comparedPackages isNil		ifTrue:			[comparedPackages := SelectionInList new]		ifFalse:			[comparedPackages]</body><body package="Store-Difference Management" selector="fromDefinition">fromDefinition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fromDefinition isNil		ifTrue:			[fromDefinition := String new asValue]		ifFalse:			[fromDefinition]</body><body package="Store-Difference Management" selector="fromProtocol">fromProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fromProtocol isNil		ifTrue:			[fromProtocol := Text new asValue]		ifFalse:			[fromProtocol]</body><body package="Store-Difference Management" selector="methodsOrProperties">methodsOrProperties	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^methodsOrProperties isNil		ifTrue:			[methodsOrProperties := MultiSelectionInList new]		ifFalse:			[methodsOrProperties]</body><body package="Store-Difference Management" selector="selectionType">selectionType	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectionType isNil		ifTrue:			[selectionType := nil asValue]		ifFalse:			[selectionType]</body><body package="Store-Difference Management" selector="toDefinition">toDefinition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^toDefinition isNil		ifTrue:			[toDefinition := String new asValue]		ifFalse:			[toDefinition]</body><body package="Store-Difference Management" selector="toProtocol">toProtocol	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^toProtocol isNil		ifTrue:			[toProtocol := Text new asValue]		ifFalse:			[toProtocol]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - dynamic</category><body package="Store-Difference Management" selector="mainPackageVersionName">mainPackageVersionName	self comparedPackages selection ifNil: [^''].	^self comparedPackages selection mainPackage versionString.</body><body package="Store-Difference Management" selector="otherPackageVersionName">otherPackageVersionName	self comparedPackages selection ifNil: [^''].	^self comparedPackages selection otherPackage versionString.</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>private</category><body package="Store-Difference Management" selector="allClasses">allClasses	| definedClasses |	definedClasses := Dictionary new.	comparedDifferences do:		[:each |		each mainPackageClasses, each otherPackageClasses do:			[:eachClass |			definedClasses at: eachClass name ifAbsentPut: [each -&gt; eachClass]]].	^definedClasses</body><body package="Store-Difference Management" selector="browseImagePackage:">browseImagePackage: aPackage		Refactory.Browser.RefactoringBrowser openOnEnvironment: (Refactory.Browser.PundleEnvironment new pundles: (List with: aPackage))</body><body package="Store-Difference Management" selector="browseStorePackage:">browseStorePackage: aPackage	(Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: (Store.Glorp.StoreForGlorpBrowserEnvironment on: aPackage)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false).</body><body package="Store-Difference Management" selector="fileNameForDefinitionsUsing:">fileNameForDefinitionsUsing: targetString		| fileName |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (targetString , '-definitions' replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	^fileName</body><body package="Store-Difference Management" selector="fileOutClassNamespaceOrShared:definedIn:">fileOutClassNamespaceOrShared: aStoreObject definedIn: aStorePackage		| fileName sourceCodeStream |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: ((aStoreObject longNameFromSmalltalk) replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: aStoreObject) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | aStorePackage name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aStorePackage name].			[sourceCodeStream timeStamp.			aStoreObject fileOutOn: sourceCodeStream] 				ensure: [sourceCodeStream close].			(FilingOut for: aStoreObject) finished].</body><body package="Store-Difference Management" selector="fileOutPackage:">fileOutPackage: aPackage		| fileName fileManager |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: aPackage name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: aPackage) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager sourceFormatter attributeFor: #package compute: [:ignore | aPackage name].			fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aPackage name].			aPackage fileOutOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: aPackage) finished].</body><body package="Store-Difference Management" selector="fileOutSharedsFrom:definedIn:">fileOutSharedsFrom: aNamespaceString definedIn: aStorePackage		| fileName sourceCodeStream |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sst &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;.st' expandMacrosWith: (('Root.Smalltalk.', aNamespaceString) replaceAll: $. with: $-))).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: aNamespaceString) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | aStorePackage name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | aStorePackage name].			[sourceCodeStream timeStamp.			(aStorePackage sharedVariablesForNamespaceNamed: 'Root.Smalltalk.', aNamespaceString) do:				[:each | each fileOutOn: sourceCodeStream]] 				ensure: [sourceCodeStream close].			(FilingOut for: aNamespaceString) finished].</body><body package="Store-Difference Management" selector="findClassIn:matching:">findClassIn: aDictionary matching: aString	| results pattern |	aString isEmpty ifTrue: [^Array new].	results := IdentitySet new: 100.	pattern := aString last = $*		ifTrue:			[results add: #*.			aString]		ifFalse: [aString , '*'].	aDictionary do:		[:each |		(pattern match: each value name) ifTrue:			[results add: each value name.			results size &gt; 500 ifTrue: [^results sorted]]].	^results sorted</body><body package="Store-Difference Management" selector="loadClass:fromPackage:removing:">loadClass: aStoreObject fromPackage: aPackage removing: aCollection		StoreProgressOverlay		subsume: builder window		while:			[(Loading for: aPackage) started.			Store.Policies packagePolicy 				forcePackage: aPackage storeModel				while: 					[aStoreObject loadSource.					self removeObjects: aCollection fromPackage: aPackage].			(Loading for: aPackage) finished].</body><body package="Store-Difference Management" selector="mainClassNameFrom:">mainClassNameFrom: selection		| targetString |	targetString := selection isNamespace		ifTrue: [selection mainNamespace asString]		ifFalse: [selection isClass ifTrue: [selection mainClassLongName] ifFalse: [selection mainPackage name]].	^targetString</body><body package="Store-Difference Management" selector="noDifferenceTabbedNamesUsing:">noDifferenceTabbedNamesUsing: aCollectionOfPackageComparitors	| stream counter items |	stream := WriteStream on: String new.	counter := 1.	items := aCollectionOfPackageComparitors reject: #hasDifferences.	items do:		[:each | 		counter = 1 ifTrue: [stream tab].		stream nextPutAll: each mainPackage name.		counter = 7 			ifTrue: [stream cr]			ifFalse: [each = items last ifFalse: [stream nextPutAll: ', ']].		counter := counter \\ 7 + 1].	^stream contents</body><body package="Store-Difference Management" selector="openBrowserOnClasses:definedIn:">openBrowserOnClasses: aCollection definedIn: aStorePackageOrImageModel		aStorePackageOrImageModel isImageModel ifTrue: 		[^RefactoringBrowser openOnEnvironment: (BrowserEnvironment new forClasses: aCollection)].	Store.Glorp.StoreRefactoringBrowser		openOnEnvironment: ((StoreForGlorpBrowserEnvironment on: aStorePackageOrImageModel) forClasses: aCollection)		state: Store.Glorp.StoreForGlorpNavigatorState new		hierarchy: false</body><body package="Store-Difference Management" selector="otherClassNameFrom:">otherClassNameFrom: selection		| targetString |	targetString := selection isNamespace		ifTrue: [selection otherNamespace asString]		ifFalse: [selection isClass ifTrue: [selection otherClassLongName] ifFalse: [selection otherPackage name]].	^targetString</body><body package="Store-Difference Management" selector="packagesContaining:in:">packagesContaining: target in: package		| packages storeObject |	storeObject := target isImageObject		ifTrue: [(package asStorePundleIn: storeSession) objectNamed: target longName]		ifFalse: [target].	StoreProgressOverlay		subsume: builder window		while:			[(Gathering for: storeObject) started.			packages := storeObject isForNameSpace 				ifTrue: [StoreNamespaceInPackage allPackagesContaining: storeObject in: storeSession]				ifFalse: [StoreClassDefinitionInPackage allPackagesContaining: storeObject in: storeSession].			(Gathering for: storeObject) finished].	DefinitionForListTool forPackages: packages</body><body package="Store-Difference Management" selector="redrawTextPanes">redrawTextPanes	(self widgetAt: #FromDefinition) invalidateNow.	(self widgetAt: #ToDefinition) invalidateNow.</body><body package="Store-Difference Management" selector="removeObjects:fromPackage:">removeObjects: aCollection fromPackage: aPackage	StoreProgressOverlay		subsume: builder window		while: 			[(Loading for: aPackage) started.			aCollection do: [:each | each removeFromImage].			(Loading for: aPackage) finished].</body><body package="Store-Difference Management" selector="setRawDifferences:">setRawDifferences: aCollection	rawDifferences := aCollection</body><body package="Store-Difference Management" selector="storeSession:">storeSession: aSession	storeSession := aSession</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - actions - Package</category><body package="Store-Difference Management" selector="browseMainPackage">browseMainPackage	| package |	package := self comparedPackages selection mainPackage.	package isImageModel		ifTrue: [self browseImagePackage: package]		ifFalse: [self browseStorePackage: package]</body><body package="Store-Difference Management" selector="browseOtherPackage">browseOtherPackage	| package |	package := comparedPackages selection otherPackage.	self browseStorePackage: package</body><body package="Store-Difference Management" selector="browseVersions">browseVersions	| selection targetPackage |	selection := comparedPackages selection.	(targetPackage := selection mainPackage) pseudoPackage ifTrue: 		[targetPackage := selection otherPackage].	DefinitionForListTool forVersionsOfPackage: targetPackage</body><body package="Store-Difference Management" selector="compareMainPackage">compareMainPackage	| target fromPackage session |	fromPackage := self comparedPackages selection mainPackage.	session := fromPackage session.	target := StorePackage selectStoreVersionOf: fromPackage name in: session.	target ifNil: [^self].	self collectDifferencesFrom: (Array with: (Array with: fromPackage with: target)).	self comparedPackages selectionIndex: (self comparedPackages list size)</body><body package="Store-Difference Management" selector="compareOtherPackage">compareOtherPackage		| target fromPackage session |	fromPackage := self comparedPackages selection otherPackage.	session := fromPackage session.	target := StorePackage selectStoreVersionOf: fromPackage name in: session.	target ifNil: [^self].	self collectDifferencesFrom: (Array with: (Array with: fromPackage with: target)).	self comparedPackages selectionIndex: self comparedPackages list size</body><body package="Store-Difference Management" selector="fileOutMainPackage">fileOutMainPackage		| package |	package := comparedPackages selection mainPackage.	self fileOutPackage: package</body><body package="Store-Difference Management" selector="fileOutMainToOtherPackageDifference">fileOutMainToOtherPackageDifference		| packageComparitor fileName package fileManager |	packageComparitor := comparedPackages selection.	package := packageComparitor mainPackage.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: package name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager sourceFormatter attributeFor: #package compute: [:ignore | package name].			fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			packageComparitor fileOutMainToOtherDifferencesOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management" selector="fileOutOtherPackage">fileOutOtherPackage		| package |	package := comparedPackages selection otherPackage.	self fileOutPackage: package</body><body package="Store-Difference Management" selector="fileOutOtherToMainPackageDifference">fileOutOtherToMainPackageDifference		| packageComparitor fileName package fileManager |	packageComparitor := comparedPackages selection.	package := packageComparitor mainPackage.	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: package name)).	fileName isEmpty ifTrue: [^nil].	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			fileManager := SourceCodeStream write: fileName encoding: #Source.			[fileManager timeStamp.			fileManager sourceFormatter attributeFor: #package compute: [:ignore | package name].			fileManager sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			packageComparitor fileOutOtherToMainDifferencesOn: fileManager] 				ensure: [fileManager close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management" selector="findClass">findClass	| dialog searchString searcher allClasses comparitor targetClass targetPseudo |	allClasses := self allClasses.	searcher := (IncrementalSearchModule new)		firstLabel: #FindClass &lt;&lt; #dialogs &gt;&gt; 'Find Class';		secondLabel: #ClassesC &lt;&lt; #labels &gt;&gt; 'Classes:';		searchBlock: [:string | self findClassIn: allClasses matching: string];		objectToStringBlock: [:object | object];		useEagerSelection: true;		pasteSelected: false.	dialog := (IncrementalSearchDialog new)		module: searcher;		requireSelection: true.	searchString := dialog select.	(searchString isNil or: [searchString isEmpty]) 		ifTrue: [^self].	comparitor := (allClasses at: searchString) key.	self comparedPackages selection: comparitor.	targetClass :=  (allClasses at: searchString) value.	targetPseudo := self classesAndProperties list		detect: [:each | each classListName = targetClass longName]		ifNone: [^self].	self classesAndProperties selection: targetPseudo</body><body package="Store-Difference Management" selector="graphMainVersion">graphMainVersion	| pundle |	pundle := comparedPackages selection mainPackage.	pundle isImageModel ifFalse: [pundle := pundle class cachedItemFor: pundle].	VersionGraph browseVersionsOfPundle: pundle.</body><body package="Store-Difference Management" selector="graphOtherVersion">graphOtherVersion	| pundle |	pundle := comparedPackages selection otherPackage.	pundle isImageModel ifFalse: [pundle := pundle class cachedItemFor: pundle].	VersionGraph browseVersionsOfPundle: pundle.</body><body package="Store-Difference Management" selector="loadMainPackage">loadMainPackage	comparedPackages selection mainPackage loadSource</body><body package="Store-Difference Management" selector="loadOtherPackage">loadOtherPackage	comparedPackages selection otherPackage loadSource</body><body package="Store-Difference Management" selector="mergeMainIntoImage">mergeMainIntoImage	| package target |	package := comparedPackages selection mainPackage.	target := package isBundle		ifTrue: [StoreBundle pundleWithName: package name version: package version in: package session]		ifFalse: [StorePackage pundleWithName: package name version: package version in: package session].	Store.Glorp.MergeTool openOnPundles: (Array with: target)</body><body package="Store-Difference Management" selector="mergeOtherIntoImage">mergeOtherIntoImage	| package target |	package := comparedPackages selection otherPackage.	target := package isBundle		ifTrue: [StoreBundle pundleWithName: package name version: package version in: package session]		ifFalse: [StorePackage pundleWithName: package name version: package version in: package session].	Store.Glorp.MergeTool openOnPundles: (Array with: target)</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - actions - Class</category><body package="Store-Difference Management" selector="browseClassVersions">browseClassVersions	| selection |	selection := self classesAndProperties selection.	selection isNamespace		ifTrue: [DefinitionForListTool forVersionsOfNameSpace: (selection mainClassStoreObject ifNil: [selection otherClassStoreObject])]		ifFalse: [	DefinitionForListTool forVersionsOfClass: (selection mainClassStoreObject ifNil: [selection otherClassStoreObject])]</body><body package="Store-Difference Management" selector="browseMainClass">browseMainClass		| package target objects |	package := self comparedPackages selection mainPackage.	target := package objectNamed: self classesAndProperties selection mainClassLongName.	objects := OrderedCollection with: target.	target isImageObject 		ifTrue: [target isForClass ifTrue: [objects add: target class]]		ifFalse: [target isClass ifTrue: [objects add: target storeMetaClass]].	self openBrowserOnClasses: objects definedIn: package</body><body package="Store-Difference Management" selector="browseOtherClass">browseOtherClass		| package target objects |	package := self comparedPackages selection otherPackage.	target := package objectNamed: self classesAndProperties selection otherClassLongName.	objects := OrderedCollection with: target.	target isClass ifTrue: [objects add: target storeMetaClass].	self openBrowserOnClasses: objects definedIn: package</body><body package="Store-Difference Management" selector="fileOutMainClass">fileOutMainClass		| selection targetString storeObject package |	selection := self classesAndProperties selection.	targetString := self mainClassNameFrom: selection.	storeObject := (package := self comparedPackages selection mainPackage) objectNamed: targetString.	storeObject ifNil: [^self fileOutSharedsFrom: targetString definedIn: package].	self fileOutClassNamespaceOrShared: storeObject definedIn: package</body><body package="Store-Difference Management" selector="fileOutOtherClass">fileOutOtherClass		| selection targetString storeObject package |	selection := self classesAndProperties selection.	targetString := self otherClassNameFrom: selection.	storeObject := (package := self comparedPackages selection otherPackage) objectNamed: targetString.	storeObject ifNil: [^self fileOutSharedsFrom: targetString definedIn: package].	self fileOutClassNamespaceOrShared: storeObject definedIn: package</body><body package="Store-Difference Management" selector="loadMainClass">loadMainClass	| selection targetString storeObject package removeObjects |	selection := self classesAndProperties selection.	targetString := selection isNamespace		ifTrue: [selection mainNamespace asString]		ifFalse: 			[selection isClass				ifTrue: [selection mainClassLongName]				ifFalse: [selection mainObject]].	storeObject := (package := (self comparedPackages selection mainPackage asStorePundleIn: storeSession)) objectNamed: targetString.	removeObjects := (selection methodDifferences select: [:each | each mainPackage isNil]) collect: [:each | each otherObject].	removeObjects addAll: ((selection sharedDifferences select: [:each | each mainPackage isNil]) collect: [:each | each otherObject]).	self loadClass: storeObject fromPackage: package removing: removeObjects</body><body package="Store-Difference Management" selector="loadOtherClass">loadOtherClass		| selection targetString storeObject package removeObjects |	selection := self classesAndProperties selection.	targetString := selection isNamespace		ifTrue: [selection otherNamespace asString]		ifFalse: 			[selection isClass 				ifTrue: [selection otherClassLongName] 				ifFalse: [selection otherObject]].	storeObject := (package := (self comparedPackages selection otherPackage asStorePundleIn: storeSession)) objectNamed: targetString.	removeObjects := (selection methodDifferences select: [:each | each otherPackage isNil]) collect: [:each | each mainObject].	removeObjects addAll: ((selection sharedDifferences select: [:each | each otherPackage isNil]) collect: [:each | each mainObject]).	self loadClass: storeObject fromPackage: package removing: removeObjects</body><body package="Store-Difference Management" selector="packagesContainingMainObject">packagesContainingMainObject		| package target |	package := self comparedPackages selection mainPackage.	target := package objectNamed: self classesAndProperties selection mainClassLongName.	self packagesContaining: target in: package</body><body package="Store-Difference Management" selector="packagesContainingOtherObject">packagesContainingOtherObject		| package target |	package := self comparedPackages selection otherPackage.	target := package objectNamed: self classesAndProperties selection otherClassLongName.	self packagesContaining: target in: package</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - enablement</category><body package="Store-Difference Management" selector="canActOnMainClass">canActOnMainClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection mainClassStoreObject notNil</body><body package="Store-Difference Management" selector="canActOnOtherClass">canActOnOtherClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection otherClassStoreObject notNil</body><body package="Store-Difference Management" selector="canFileOutMainClass">canFileOutMainClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection hasMainDifferences</body><body package="Store-Difference Management" selector="canFileOutMainDefinitions">canFileOutMainDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasMainDifferences].</body><body package="Store-Difference Management" selector="canFileOutOtherClass">canFileOutOtherClass	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection hasOtherDifferences</body><body package="Store-Difference Management" selector="canFileOutOtherDefinitions">canFileOutOtherDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasOtherDifferences].</body><body package="Store-Difference Management" selector="canLoadMainDefinitions">canLoadMainDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasMainDifferences].</body><body package="Store-Difference Management" selector="canLoadMainPackage">canLoadMainPackage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^(selection mainPackage pseudoPackage or: [selection mainPackage isImageModel]) not</body><body package="Store-Difference Management" selector="canLoadOtherDefinitions">canLoadOtherDefinitions	| selections |	selections := self methodsOrProperties selections.	^selections anySatisfy: [:each | each hasOtherDifferences].</body><body package="Store-Difference Management" selector="canLoadOtherPackage">canLoadOtherPackage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^selection otherPackage pseudoPackage not</body><body package="Store-Difference Management" selector="classObjectIsSelected">classObjectIsSelected	| selection |	selection := self classesAndProperties selection.	^self classesAndProperties selectionIndex &gt; 0 and: [selection isStandin not]</body><body package="Store-Difference Management" selector="classObjectIsSelectedAndBrowsable">classObjectIsSelectedAndBrowsable	| selection |	selection := self classesAndProperties selection.	^self classObjectIsSelected and: [selection isNamespaceExtension not and: [selection isClassExtension not]]</body><body package="Store-Difference Management" selector="instanceClassOrShared:">instanceClassOrShared: aMenuItem	self selectionType value = #instance ifTrue: [^aMenuItem nameKey = #AmpInstanceMethods].	self selectionType value = #class ifTrue: [^aMenuItem nameKey = #AmpClassMethods].	self selectionType value = #shared ifTrue: [^aMenuItem nameKey = #AmpSharedVariables].	^false</body><body package="Store-Difference Management" selector="mainClassIsNotExtension">mainClassIsNotExtension	| package target |	package := self comparedPackages selection mainPackage.	target := package definedObjectNamed: self classesAndProperties selection mainClassLongName.	^target notNil and: [target isExtension not]</body><body package="Store-Difference Management" selector="mainPackageIsPseudo">mainPackageIsPseudo	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^selection mainPackage pseudoPackage</body><body package="Store-Difference Management" selector="namespaceNotSelected">namespaceNotSelected	| selection |	(selection := self classesAndProperties selection) ifNil: [^false].	^selection isNamespace not</body><body package="Store-Difference Management" selector="otherClassIsNotExtension">otherClassIsNotExtension	| package target |	package := self comparedPackages selection otherPackage.	target := package definedObjectNamed: self classesAndProperties selection otherClassLongName.	^target notNil and: [target isExtension not]</body><body package="Store-Difference Management" selector="otherPackageIsPseudo">otherPackageIsPseudo	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^selection otherPackage pseudoPackage</body><body package="Store-Difference Management" selector="packageIsInImage">packageIsInImage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	^(Registry packageNamed: (selection mainPackage ifNil: [selection otherPackage]) name) notNil</body><body package="Store-Difference Management" selector="packageIsInImageButNotActualImage">packageIsInImageButNotActualImage	| selection |	(selection := self comparedPackages selection) ifNil: [^false].	(selection mainPackage notNil and: [selection mainPackage = (Registry packageNamed: selection mainPackage name)])		ifTrue: [^false].	^(Registry packageNamed: (selection mainPackage ifNil: [selection otherPackage]) name) notNil</body><body package="Store-Difference Management" selector="singleMainDefinitionObjectSelectedAndBrowseableForVersion">singleMainDefinitionObjectSelectedAndBrowseableForVersion	| selections |	selections := self methodsOrProperties selections.	^selections size = 1 and: [selections first isExtensionInMain not and: [selections first isPropertyDifference not]]</body><body package="Store-Difference Management" selector="singleMethodObjectSelectedAndBrowseable">singleMethodObjectSelectedAndBrowseable	| selections |	selections := self methodsOrProperties selections.	^selections size = 1 and: [selections first isStandin not]</body><body package="Store-Difference Management" selector="singleOtherDefinitionObjectSelectedAndBrowseableForVersion">singleOtherDefinitionObjectSelectedAndBrowseableForVersion	| selections |	selections := self methodsOrProperties selections.	^selections size = 1 and: [selections first isExtensionInOther not and: [selections first isPropertyDifference not]]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus - actions - Definitions</category><body package="Store-Difference Management" selector="browseDefinitionVersions">browseDefinitionVersions	| selection methodOrShared |	selection := self methodsOrProperties selections first.	methodOrShared := selection mainClassStoreObject ifNil: [selection otherClassStoreObject].	methodOrShared isForSharedVariable		ifTrue: [DefinitionForListTool forVersionsOfShared: methodOrShared]		ifFalse: [DefinitionForListTool forVersionsOfMethod: methodOrShared]</body><body package="Store-Difference Management" selector="fileOutMainDefinitions">fileOutMainDefinitions		| selections targets targetString fileName package sourceCodeStream storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasMainDifferences].	targets isEmpty ifTrue: [^self].	targetString := self mainClassNameFrom: self classesAndProperties selection.	(fileName := self fileNameForDefinitionsUsing: targetString) ifNil: [^self].	package :=  self comparedPackages selection mainPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | package name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			[sourceCodeStream timeStamp.			targets do: [:each | each fileOutMainOn: sourceCodeStream from: storeObject]] 				ensure: [sourceCodeStream close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management" selector="fileOutOtherDefinitions">fileOutOtherDefinitions		| selections targets targetString fileName package sourceCodeStream storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasOtherDifferences].	targets isEmpty ifTrue: [^self].	targetString := self otherClassNameFrom: self classesAndProperties selection.	(fileName := self fileNameForDefinitionsUsing: targetString) ifNil: [^self].	package :=  self comparedPackages selection otherPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(FilingOut for: package) started.			sourceCodeStream := SourceCodeStream write: fileName encoding: #Source.			sourceCodeStream sourceFormatter attributeFor: #package compute: [:ignore | package name].			sourceCodeStream sourceFormatter attributeForMethods: #package compute: [:ignore :igmore | package name].			[sourceCodeStream timeStamp.			targets do: [:each | each fileOutOtherOn: sourceCodeStream from: storeObject]] 				ensure: [sourceCodeStream close].			(FilingOut for: package) finished].</body><body package="Store-Difference Management" selector="loadMainDefinitions">loadMainDefinitions	| selections targets targetString package storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasMainDifferences].	targets isEmpty ifTrue: [^self].	targetString := self mainClassNameFrom: self classesAndProperties selection.	package :=  self comparedPackages selection mainPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(Loading for: package) started.			targets do: [:each | each loadMainDefinitionFrom: storeObject].			(Loading for: package) finished].</body><body package="Store-Difference Management" selector="loadOtherDefinitions">loadOtherDefinitions	| selections targets targetString package storeObject |	selections := self methodsOrProperties selections.	targets := selections select: [:each | each hasOtherDifferences].	targets isEmpty ifTrue: [^self].	targetString := self otherClassNameFrom: self classesAndProperties selection.	package :=  self comparedPackages selection otherPackage.	storeObject := package objectNamed: targetString.	StoreProgressOverlay		subsume: builder window		while: 			[(Loading for: package) started.			targets do: [:each | each loadOtherDefinitionFrom: storeObject].			(Loading for: package) finished].</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>actions</category><body package="Store-Difference Management" selector="classSelectionChanged">classSelectionChanged		| targetPsuedoDifference sourceList |	(targetPsuedoDifference := self classesAndProperties selection) isNil		ifTrue: [self methodsOrProperties list: #()] 	"Eventually, here is where we put Propertyies?"		ifFalse:			[sourceList := targetPsuedoDifference changedMethodsSharedAndProperties.			self selectionType value == #instance 				ifTrue: [self methodsOrProperties list: (sourceList select: [:each | each isMethod and: [each isNotMeta]])].			self selectionType value == #class 				ifTrue: [self methodsOrProperties list: (sourceList select: [:each | each isMethod and: [each isMeta]])].			self selectionType value == #shared 				ifTrue: [self methodsOrProperties list: (sourceList select: [:each | each isShared])].			self setSelectionTypeEmpahsisFrom: sourceList.			self methodsOrProperties list isEmpty ifFalse: [self methodsOrProperties selectionIndexes: (Set with: 1)]]</body><body package="Store-Difference Management" selector="collectDifferencesFrom:">collectDifferencesFrom: aCollection	comparedDifferences ifNil: [comparedDifferences := OrderedCollection new: aCollection size].	StoreProgressOverlay		subsume: builder window		while: 			[aCollection do:				[:each |				(Comparing for: (each first ifNil: [PseudoPackage new])) started.				comparedDifferences add: (PackageComparitor 					differencesWithPropertiesBetween: (each first ifNil: [each last pseudoPundleClass new]) 					and: (each last ifNil: [each first pseudoPundleClass new])).				(Comparing for: (each first ifNil: [PseudoPackage new])) finished]].	(comparedDifferences allSatisfy: #hasDifferences) ifFalse:		[Dialog warn: (#NoDifferences1s &lt;&lt; #store &gt;&gt; 'The Following Items Have No Differences:&lt;n&gt;&lt;1s&gt;' expandMacrosWith: (self noDifferenceTabbedNamesUsing: comparedDifferences)) ].	 self comparedPackages list: comparedDifferences</body><body package="Store-Difference Management" selector="methodSelectionChanged">methodSelectionChanged		| pseudoDifferences |	pseudoDifferences := self methodsOrProperties selections.	pseudoDifferences size = 1		ifFalse:			[ | definitionString |			definitionString := pseudoDifferences size &gt; 1 				ifTrue: [(#MutlipleDefinitionsSelected &lt;&lt; #store &gt;&gt; 'Multiple Definitions Selected') asString] 				ifFalse: [String new].			self fromDefinition value: definitionString.			self toDefinition value: definitionString.			self fromProtocol value: String new.			self toProtocol value: String new]		ifTrue: [self emphasizeCodeUsing: pseudoDifferences first]</body><body package="Store-Difference Management" selector="packageSelectionChanged">packageSelectionChanged	| targetComparitor |	self comparedPackages list size isZero ifTrue: [^self].	(targetComparitor := self comparedPackages selection) isNil		ifTrue: [classesAndProperties list: #()]		ifFalse: [classesAndProperties list: targetComparitor changedClassesNamespacesAndProperties].	self clearSelectionTypeEmpahsis</body><body package="Store-Difference Management" selector="setClassSelectionType">setClassSelectionType	self selectionType value: #class</body><body package="Store-Difference Management" selector="setInstanceSelectionType">setInstanceSelectionType	self selectionType value: #instance</body><body package="Store-Difference Management" selector="setSharedSelectionType">setSharedSelectionType	self selectionType value: #shared</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>interface opening</category><body package="Store-Difference Management" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(builder window)		application: self;		sendWindowEvents: #(#newGraphicsDevice #reopen).	self setUpPackageViewWith: aBuilder.	self setUpClassesAndPseudoViewWith: aBuilder.	self setUpMethodsOrPropertiesViewWith: aBuilder.	self comparedPackages selectionIndexHolder		onChangeSend: #packageSelectionChanged		to: self.	self classesAndProperties selectionIndexHolder		onChangeSend: #classSelectionChanged		to: self.	self methodsOrProperties selectionIndexHolder		onChangeSend: #methodSelectionChanged		to: self.	self selectionType value: #instance.	self selectionType onChangeSend: #classSelectionChanged to: self</body><body package="Store-Difference Management" selector="postOpenWith:">postOpenWith: aBuilder		self collectDifferencesFrom: rawDifferences.	self comparedPackages selectionIndex: 1</body><body package="Store-Difference Management" selector="setUpClassesAndPseudoViewWith:">setUpClassesAndPseudoViewWith: aBuilder		| widget |	widget := (aBuilder componentAt: #ClassesAndPseudo) widget.	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self classAndPseudoLabelUsing: (view sequence at: index) in: view selected: false.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self classAndPseudoLabelUsing: (view sequence at: index) in: view selected: true.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body><body package="Store-Difference Management" selector="setUpMethodsOrPropertiesViewWith:">setUpMethodsOrPropertiesViewWith: aBuilder		| widget |	widget := (aBuilder componentAt: #MethodsOrProperties) widget.	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self methodOrPropertiesLabelUsing: (view sequence at: index) in: view selected: false.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self methodOrPropertiesLabelUsing: (view sequence at: index) in: view selected: true.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body><body package="Store-Difference Management" selector="setUpPackageViewWith:">setUpPackageViewWith: aBuilder		| widget firstMax |	widget := (aBuilder componentAt: #Packages) widget.	firstMax := 0.	rawDifferences do: 		[:each | 		| labelString |		labelString := each first 			ifNil: [#BracketNoMatchingPackage &lt;&lt; #store &gt;&gt; '[No Matching Package]']			ifNotNil: [each first name , each first versionString].		firstMax := (Label with: labelString asText allBold attributes: widget textStyle) width max: firstMax].	widget		visualBlock:			[:view :index | 			| compositeView |			compositeView := self compositeViewUsing: (view sequence at: index) startingAt: firstMax in: view selected: false.			BoundedWrapper on: compositeView].	widget		selectedVisualBlock:			[:view :index | 			| compositeView wrapper |			compositeView := self compositeViewUsing: (view sequence at: index) startingAt: firstMax in: view selected: true.			wrapper := ReversingWrapper on: compositeView.			wrapper reverse setValue: true.			BoundedWrapper on: wrapper]</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>emphasis</category><body package="Store-Difference Management" selector="clearSelectionTypeEmpahsis">clearSelectionTypeEmpahsis		| text widget |	text := (widget := self widgetAt: #InstanceSelection) label text.	widget label text: text string asText.	text := (widget := self widgetAt: #ClassSelection) label text.	widget label text: text string asText.	text := (widget := self widgetAt: #SharedSelection) label text.	widget label text: text string asText.	self mainWindow display.</body><body package="Store-Difference Management" selector="emphasizeCodeUsing:">emphasizeCodeUsing: anIndividualDifference	| secondProtocol prefix firstProtocol firstFragments secondFragments |	firstFragments := anIndividualDifference firstTextFragments.	secondFragments := anIndividualDifference secondTextFragments.	(firstFragments differences: secondFragments)		do: #applyAnyDifferenceTextEmphases.	self fromDefinition value: (firstFragments isEmpty				ifTrue: [Text new]				ifFalse: [firstFragments first sequence]).	self toDefinition value: (secondFragments isEmpty				ifTrue: [Text new]				ifFalse: [secondFragments first sequence]).	prefix := (#ProtocolSpaceColonSpace &lt;&lt; #store &gt;&gt; 'Protocol : ') asText				allBold.	firstProtocol := anIndividualDifference mainProtocol asText.	secondProtocol := anIndividualDifference otherProtocol asText.	firstProtocol = secondProtocol		ifFalse: 			[firstProtocol := firstProtocol						emphasizeAllWith: TextFragment emphasisForChange.			secondProtocol := secondProtocol						emphasizeAllWith: TextFragment emphasisForChange].	firstProtocol notEmpty ifTrue: [firstProtocol := prefix , firstProtocol].	secondProtocol notEmpty		ifTrue: [secondProtocol := prefix , secondProtocol].	self fromProtocol value: firstProtocol.	self toProtocol value: secondProtocol</body><body package="Store-Difference Management" selector="setSelectionTypeEmpahsisFrom:">setSelectionTypeEmpahsisFrom: sourceList		| text widget |	text := (widget := self widgetAt: #InstanceSelection) label text.	widget label text: ((sourceList anySatisfy: [:each | each isMethod and: [each isMeta not and: [each isStandin not]]])		ifTrue: [text allBold]		ifFalse: [text string asText]).	text := (widget := self widgetAt: #ClassSelection) label text.	widget label text: ((sourceList anySatisfy: [:each | each isMethod and: [each isMeta and: [each isStandin not]]])		ifTrue: [text allBold]		ifFalse: [text string asText]).	text := (widget := self widgetAt: #SharedSelection) label text.	widget label text: ((sourceList anySatisfy: [:each | each isShared])		ifTrue: [text allBold]		ifFalse: [text string asText]).	self mainWindow display.</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>events</category><body package="Store-Difference Management" selector="windowEvent:from:">windowEvent: anEvent from: aWindow 	super windowEvent: anEvent from: aWindow.	(#(#newGraphicsDevice #reopen) includes: anEvent key) 		ifTrue: [self closeAndUnschedule]</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>interface opening</category><body package="Store-Difference Management" selector="compareFrom:to:">compareFrom: aCodeComponent to: bCodeComponent	^self compareFromAll: (Array with: aCodeComponent)		toAll: (Array with: bCodeComponent)</body><body package="Store-Difference Management" selector="compareFromAll:toAll:">compareFromAll: aSequenceOfCodeComponents toAll: bSequenceOfCodeComponents	| packagePairs session |	(UseNewCompareTool ~~ false and: [InputState default shiftDown not])		ifTrue: 			[PackageComparisonTool compareFromAll: aSequenceOfCodeComponents				toAll: bSequenceOfCodeComponents.			^self].	packagePairs := OrderedCollection new.	session := Store.Glorp.StoreLoginFactory currentStoreSession.	aSequenceOfCodeComponents with: bSequenceOfCodeComponents		do: 			[:first :second |			first isPackage				ifTrue: 					[packagePairs add: (Array with: (first asStoreComparisonObjectIn: session)								with: (second asStoreComparisonObjectIn: session))]				ifFalse: 					[(self						gatherVersionsFor: (first asStoreComparisonObjectIn: session)						and: (second asStoreComparisonObjectIn: session)						in: session) do: [:pair | packagePairs add: pair]]].	packagePairs isEmpty		ifTrue: 			[^Dialog				warn: (#NoDifferences1s &lt;&lt; #store						&gt;&gt; 'The Following Items Have No Differences:&lt;n&gt;&lt;1s&gt;'							expandMacrosWith: (self									noDifferenceTabbedNamesUsing: aSequenceOfCodeComponents))].	self openOn: packagePairs using: session</body><body package="Store-Difference Management" selector="openOn:using:">openOn: aCollection using: aSession	| instance |	instance := self new.	instance setRawDifferences: aCollection.	instance storeSession: aSession.	self openOn: instance</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>old browser compatibility</category><body package="Store-Difference Management" selector="compareClass:toClass:">compareClass: aClass toClass: anotherClass	Store.TextDifferenceBrowser compare: aClass definition with: anotherClass definition</body><body package="Store-Difference Management" selector="compareMethod:toMethod:">compareMethod: aMethod toMethod: anotherMethod	Store.MethodDifferenceBrowser compare: aMethod definition with: anotherMethod definition protocol: aMethod protocol with: anotherMethod protocol</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>resources</category><body package="Store-Difference Management" selector="mainMenu">mainMenu	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #store ) 				#nameKey: #AmpView 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InstanceMethods 								#defaultString: '&amp;Instances Methods' 								#catalogID: #store ) 							#nameKey: #AmpInstanceMethods 							#value: #setInstanceSelectionType 							#indication: true 							#indicationSelector: 							#instanceClassOrShared: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ClassMethods 								#defaultString: '&amp;Class Methods' 								#catalogID: #store ) 							#nameKey: #AmpClassMethods 							#value: #setClassSelectionType 							#indication: true 							#indicationSelector: 							#instanceClassOrShared: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SharedVariables 								#defaultString: '&amp;Shared Variables' 								#catalogID: #store ) 							#nameKey: #AmpSharedVariables 							#value: #setSharedSelectionType 							#indication: true 							#indicationSelector: 							#instanceClassOrShared: ) ) #(3  ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AmpPackage 					#defaultString: '&amp;Package' 					#catalogID: #store ) 				#nameKey: #AmpPackage 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOut 								#defaultString: '&amp;File Out' 								#catalogID: #store ) 							#nameKey: #AmpFileOut 							#submenu: #(#{UI.Menu} #() #(0 0) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Versions 								#defaultString: '&amp;Versions' 								#catalogID: #store ) 							#nameKey: #AmpVersions 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #_List 											#defaultString: '&amp;List' 											#catalogID: #store ) 										#nameKey: #AmpList 										#value: #browseVersions ) ) #(1 0 0 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Find_ClassDots 								#defaultString: 'Find &amp;Class...' 								#catalogID: #store ) 							#nameKey: #FindAmpClassDots 							#value: #findClass) ) #(0 2 0 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Class 					#defaultString: '&amp;Class' 					#catalogID: #store ) 				#nameKey: #AmpClass 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseClassAmpVersions 								#defaultString: 'Browse Class &amp;Versions' 								#catalogID: #store ) 							#nameKey: #BrowseClassAmpVersions							#enablementSelector: #classObjectIsSelectedAndBrowsable							#value: #browseClassVersions ) 							) #(1 0 0 0 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Definition 					#defaultString: '&amp;Definition' 					#catalogID: #store ) 				#nameKey: #AmpDefinition 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseDefinition_Versions 								#defaultString: 'Browse Definition &amp;Versions' 								#catalogID: #store ) 							#nameKey: #BrowseDefinitionAmpVersions 							#enablementSelector: #singleMethodObjectSelectedAndBrowseable							#value: #browseDefinitionVersions ) 						) #(1 0 0 0 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #AmpHelp 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Topics 								#defaultString: '&amp;Topics' 								#catalogID: #store ) 							#nameKey: #AmpTopics ) ) #(1 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>deprecated</category><body package="Store-Difference Management" selector="comparePackage:toPackage:">comparePackage: aStorePackage toPackage: aStorePackageOrPackageModel	"Deprecated. Use compareFrom:to: with the appropriate left-&gt;right semantics instead."	self deprecated: #(#after '7.7' #use #compareFrom:to: #callSite)				, (Array with: thisContext sender home method definition displayString).	self compareFromAll: (Array with: aStorePackage)		toAll: (Array with: aStorePackageOrPackageModel)</body><body package="Store-Difference Management" selector="comparePackages:to:">comparePackages: aCollectionOfPackages to: anotherCollectionOfPackages	"Deprecated. Use compareFromAll:toAll: with the appropriate left-&gt;right semantics instead."	self deprecated: #(#after '7.7' #use #compareFromAll:toAll: #callSite)				, (Array with: thisContext sender home method definition displayString).	self compareFromAll: aCollectionOfPackages		toAll: anotherCollectionOfPackages</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>private</category><body package="Store-Difference Management" selector="gatherVersionsFor:and:in:">gatherVersionsFor: aBundle and: anotherBundle in: aSession	| gatheredPundles versionMatchedPundles mainLeafItems otherLeafItems session |	mainLeafItems := (aBundle asStoreComparisonObjectIn: aSession) withAllItems.	otherLeafItems := (anotherBundle asStoreComparisonObjectIn: aSession) withAllItems.	gatheredPundles := Dictionary new.	versionMatchedPundles := OrderedCollection new.	session := aSession.	otherLeafItems do: [:each | gatheredPundles at: (each name, each typeStringForBlessing) put: (each asStoreComparisonObjectIn: session)].	mainLeafItems do:		[:each | 		| other |		(Gathering for: (each asStoreComparisonObjectIn: session)) started.		other := gatheredPundles			at: each name, each typeStringForBlessing			ifAbsent:				[versionMatchedPundles add: (Array with: (each asStoreComparisonObjectIn: session) with: nil).				nil].		other notNil ifTrue:			[(other sameVersionAs: (each asStoreComparisonObjectIn: session)) ifFalse: 				[versionMatchedPundles add: (Array 					with: (each asStoreComparisonObjectIn: session) 					with: (other asStoreComparisonObjectIn: session))].			gatheredPundles at: each name, each typeStringForBlessing put: nil].		(Gathering for: (each asStoreComparisonObjectIn: session)) finished].	gatheredPundles do: 		[:each | 		each notNil ifTrue: [versionMatchedPundles add: (Array with: nil with: (each asStoreComparisonObjectIn: session))]].	^versionMatchedPundles</body><body package="Store-Difference Management" selector="noDifferenceTabbedNamesUsing:">noDifferenceTabbedNamesUsing: aCollectionOfPundles	| stream counter items |	stream := WriteStream on: String new.	counter := 1.	items := aCollectionOfPundles reject: #hasDifferences.	items do:		[:each | 		counter = 1 ifTrue: [stream tab].		stream nextPutAll: each name.		counter = 7 			ifTrue: [stream cr]			ifFalse: [each = items last ifFalse: [stream nextPutAll: ', ']].		counter := counter \\ 7 + 1].	^stream contents</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>comparing</category><body package="StoreForGlorpVWUI" selector="asStoreComparisonObjectIn:">asStoreComparisonObjectIn: aSession	^self</body><body package="StoreForGlorpVWUI" selector="computeDifferencesBetween:into:">computeDifferencesBetween: aPackage into: aComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[aComparitor reverse.	aPackage computeDifferencesBetween: self into: aComparitor]		ensure: [aComparitor reverse].	^aComparitor</body><body package="Store-IMG-Pundles" selector="computeDifferencesBetweenDBPackage:into:">computeDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."	^self computeStoreDiffsBetweenDBPackage: aStorePackage into: aPackageComparitor</body><body package="Store-IMG-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aPackage into: diffHolder	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[diffHolder reverse.	aPackage computeDiffsBetween: self into: diffHolder]		ensure: [diffHolder reverse].	^diffHolder</body><body package="Store-IMG-Pundles" selector="computeDiffsBetweenDBBundle:into:">computeDiffsBetweenDBBundle: aStoreBundle into: aComparitor	"I do nothing for a Bundle"</body><body package="Store-IMG-Pundles" selector="computeDiffsBetweenDBPackage:into:">computeDiffsBetweenDBPackage: aDBPackage into: diffHolder	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."	diffHolder isPackageComparitor ifTrue:		[^self computeStoreDiffsBetweenDBPackage: aDBPackage into: diffHolder].	diffHolder methodsSide: 2 put: OrderedCollection new.	diffHolder methodsSide: 1 put: aDBPackage methods.	diffHolder dataSide: 2 put: OrderedCollection new.	diffHolder dataSide: 1 put: aDBPackage data.	diffHolder classesSide: 2 put: OrderedCollection new.	diffHolder classesSide: 1 put: aDBPackage classes.	diffHolder metaSide: 2 put: OrderedCollection new.	diffHolder metaSide: 1 put: aDBPackage metaclasses.	diffHolder nameSpacesSide: 2 put: OrderedCollection new.	diffHolder nameSpacesSide: 1 put: aDBPackage nameSpaces.	^diffHolder</body><body package="StoreForGlorpVWUI" selector="computePropertyDifferencesBetween:into:">computePropertyDifferencesBetween: aStorePundle into: aPackageComparitor	^self computePropertyDiffsBetweenDBPundle: aStorePundle into: aPackageComparitor</body><body package="StoreForGlorpVWUI" selector="computePropertyDiffsBetweenDBPundle:into:">computePropertyDiffsBetweenDBPundle: aStorePackage into: aPackageComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		aPackageComparitor mainPackageProperties: OrderedCollection new.	aPackageComparitor otherPackageProperties: aStorePackage properties associations.	aStorePackage isBundle ifTrue:		[aPackageComparitor otherPackageProperties add: #structure -&gt; aStorePackage structure].	^aPackageComparitor</body><body package="Store-IMG-Pundles" selector="computeStoreDiffsBetweenDBPackage:into:">computeStoreDiffsBetweenDBPackage: aStorePackage into: aPackageComparitor	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."	aPackageComparitor otherPackageMethods: (OrderedCollection new).	aPackageComparitor mainPackageMethods: (aStorePackage methods collect: [:each | each definition]).	aPackageComparitor otherPackageShareds: (OrderedCollection new).	aPackageComparitor mainPackageShareds: (aStorePackage sharedVariables collect: [:each | each definition]).	aPackageComparitor otherPackageNamespaces: (OrderedCollection new).	aPackageComparitor mainPackageNamespaces: (aStorePackage nameSpaces collect: [:each | each definition]).	aPackageComparitor otherPackageClasses: (OrderedCollection new).	aPackageComparitor mainPackageClasses: (aStorePackage classes collect: [:each | each definition]).	^aPackageComparitor</body><body package="Store-IMG-Pundles" selector="sameAs:">sameAs: aPackage	^false</body><body package="Store-IMG-Pundles" selector="sameVersionAs:">sameVersionAs: aPackage	^false.</body><body package="Store-IMG-Pundles" selector="sameVersionAsLoadedPundle:">sameVersionAsLoadedPundle: aPundle	^false</body><body package="Store-IMG-Pundles" selector="sameVersionAsPublished:">sameVersionAsPublished: aPundle	^false</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="allClasses">allClasses	^#()</body><body package="Store-IMG-Pundles" selector="allDatabases">allDatabases	^#()</body><body package="Store-IMG-Pundles" selector="allNameSpaces">allNameSpaces	^#()</body><body package="Store-IMG-Pundles" selector="classesAndNameSpacesFromChanges:meta:">classesAndNameSpacesFromChanges: changeSet meta: isMeta	^self classesNamed: 		( changeSet keys collect: [ :key | key asString ] )</body><body package="Store-IMG-Pundles" selector="classesDefinedInPackage">classesDefinedInPackage	^#()</body><body package="Store-IMG-Pundles" selector="classesNamed:">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassRecord"	"sorts a list of nils..."	^(aSetOfNames collect: [:aName| self classInPackageNamed: aName])			asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-IMG-Pundles" selector="classesNamed:meta:">classesNamed: aSetOfNames meta: aBoolean	"Convert aSetOfnames into a collection of ClassRecords"	^( aSetOfNames collect: 		[ :aName | self classInPackageNamed: aName meta: aBoolean ]	) asSortedCollection: [ :x :y | x name &lt; y name ]</body><body package="Store-IMG-Pundles" selector="classesWithSource">classesWithSource	"For image model, same as defined classes."	^self classesDefinedInPackage.</body><body package="Store-IMG-Pundles" selector="classInPackageNamed:">classInPackageNamed: cName 	"See if the class is new and answer nil or the class descriptor."	^nil</body><body package="Store-IMG-Pundles" selector="classInPackageNamed:meta:">classInPackageNamed: cName meta: isMeta	"See if the class is new and answer nil or the class descriptor."	^nil</body><body package="Store-IMG-Pundles" selector="data">data	^#()</body><body package="Store-IMG-Pundles" selector="dataWithSource">dataWithSource	"For the image model this is the same as data."	^self data.</body><body package="Store-IMG-Pundles" selector="datum:forNamed:">datum: dataKey forNamed: aFullName	^nil</body><body package="Store-IMG-Pundles" selector="datum:forOwnerNamed:">datum: dataKey forOwnerNamed: cName 	^nil</body><body package="Store-IMG-Pundles" selector="dbTrace">dbTrace	^nil</body><body package="Store-IMG-Pundles" selector="hasTrace">hasTrace 	^false</body><body package="Store-IMG-Pundles" selector="isLoaded">isLoaded 	^true</body><body package="Store-IMG-Pundles" selector="itemCount">itemCount	"Answer a count of work to be done. Not much."	^realPackage == nil		ifTrue: [ 1 ]		ifFalse: [ realPackage itemCount ]</body><body package="StoreForGlorpVWUI" selector="itemString">itemString	^self name</body><body package="Store-IMG-Pundles" selector="method:forClassNamed:meta:">method: aSelector forClassNamed: cName meta: isMeta 	^nil</body><body package="Store-IMG-Pundles" selector="methods">methods	^#()</body><body package="Store-IMG-Pundles" selector="methodsForClassNamed:">methodsForClassNamed: cName	^#()</body><body package="Store-IMG-Pundles" selector="methodsWithSource">methodsWithSource	"For image model same as methods since sources are already loaded."	^self methods.</body><body package="Store-IMG-Pundles" selector="name">name	^realPackage isNil		ifTrue: [(#BracketNoMatchingPackage &lt;&lt; #store &gt;&gt; '[No Matching Package]') asString]		ifFalse: [realPackage name]</body><body package="Store-IMG-Pundles" selector="nameSpaceInPackageNamed:">nameSpaceInPackageNamed: aName 	^nil</body><body package="Store-IMG-Pundles" selector="nameSpacesDefinedInPackage">nameSpacesDefinedInPackage	^#()</body><body package="Store-IMG-Pundles" selector="nameSpacesNamed:">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassRecord"	"sorts a list of nils...."	^(aSetOfNames collect: [:aName| self classInPackageNamed: aName])			asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-IMG-Pundles" selector="nameSpacesWithSource">nameSpacesWithSource	"For image model same as defined NameSpace."	^self nameSpacesDefinedInPackage.</body><body package="Store-IMG-Pundles" selector="primaryKey">primaryKey	^nil</body><body package="Store-IMG-Pundles" selector="properties">properties	^IdentityDictionary new.</body><body package="Store-IMG-Pundles" selector="propertiesForFileOut">propertiesForFileOut	^IdentityDictionary new.</body><body package="Store-IMG-Pundles" selector="propertiesForSave">propertiesForSave	^IdentityDictionary new.</body><body package="StoreForGlorpVWUI" selector="propertiesWithoutVolatileKeys">propertiesWithoutVolatileKeys	^IdentityDictionary new.</body><body package="Store-IMG-Pundles" selector="pseudoPackage">pseudoPackage	"Answer true since I'm a fake."	^true</body><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	^PackageChanges</body><body package="StoreForGlorpVWUI" selector="session">session	"This for being compatable with StorePundle objects"	^nil</body><body package="Store-IMG-Pundles" selector="shortItemString">shortItemString	^self name</body><body package="StoreForGlorpVWUI" selector="structure">structure	^#()</body><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	^VisualStack with: Store.Glorp.StorePackage toolListIcon with: GeneralIcons deprecationWarning</body><body package="Store-IMG-Pundles" selector="version">version	^'--'</body><body package="Store-IMG-Pundles" selector="versionString">versionString	^''</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="includesClassNamed:">includesClassNamed: aName 	^false</body><body package="Store-IMG-Pundles" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName	^false</body><body package="Store-IMG-Pundles" selector="includesDatum:">includesDatum: datum	^false</body><body package="Store-IMG-Pundles" selector="includesMethod:">includesMethod: method	^false</body><body package="Store-IMG-Pundles" selector="includesNameSpaceNamed:">includesNameSpaceNamed: aName 	^false</body><body package="Store-IMG-Pundles" selector="isBundle">isBundle	^realPackage isBundle</body><body package="StoreForGlorpVWUI" selector="isImageModel">isImageModel	^false</body><body package="Store-IMG-Pundles" selector="isPackage">isPackage	^realPackage isPackage</body><body package="StoreForGlorpVWUI" selector="isVersionLoaded">isVersionLoaded	^false</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>private-accessing</category><body package="Store-IMG-Pundles" selector="realPackage:">realPackage: aPackage	realPackage := aPackage</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="fileOutProperties:on:">fileOutProperties: props on: aFileManager	^self.</body><body package="Store-IMG-Pundles" selector="textForItem">textForItem	^'*****'</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>compatibility</category><body package="Store-IMG-Pundles" selector="cleanse:">cleanse: ignored	"Just so I can participate in a REAL Package world cleanly"</body></methods><methods><class-id>Store.PseudoPackage class</class-id> <category>instance-creation</category><body package="Store-IMG-Pundles" selector="fromPackage:">fromPackage: aPackage		^self new realPackage: aPackage</body></methods><methods><class-id>Store.PseudoNamespaceForSharedDifference</class-id> <category>accessing</category><body package="Store-Merge Management" selector="changedMethodsSharedAndProperties">changedMethodsSharedAndProperties		^self sortedSharedDifferences</body></methods><methods><class-id>Store.PseudoNamespaceForSharedDifference class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="mainPackage:fromShared:">mainPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference mainPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		mainPackage: aPackage namespace: namespace fullName asQualifiedReference;		yourself</body><body package="Store-Merge Management" selector="otherPackage:fromShared:">otherPackage: aPackage fromShared: aSharedVariable	| instance namespace |	namespace := aPackage objectNamed: aSharedVariable environmentName.	namespace ifNil: [^PseudoNamespaceExtensionDifference otherPackage: aPackage fromShared: aSharedVariable].	instance := self new.	^instance		otherPackage: aPackage justNamespace: namespace fullName asQualifiedReference;		yourself</body></methods><methods><class-id>Store.PkgNameSpaces</class-id> <category>accessing</category><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: newClassOrder	"Set the receiver's definitionOrder to newClassOrder."	definitionOrder := newClassOrder</body><body package="Store-DB-Records" selector="nameSpaceRef">nameSpaceRef	"Answer the receiver's nameSpaceRef."	^nameSpaceRef</body><body package="Store-DB-Records" selector="nameSpaceRef:">nameSpaceRef: newNameSpaceRef	"Set the receiver's nameSpaceRef to newNameSpaceRef."	nameSpaceRef := newNameSpaceRef</body><body package="Store-DB-Records" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Records" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self nameSpaceRef</body><body package="Store-DB-Records" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self nameSpaceRef</body></methods><methods><class-id>Store.PkgNameSpaces class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes	| dict |	( dict := Dictionary new )		at: 'packageRef' put: #PrimaryKey;	 	at: 'nameSpaceRef' put: #PrimaryKey;		at: 'definitionOrder' put: #Integer.	self checkFieldsWith: dict.	^dict</body></methods><methods><class-id>Store.PkgNameSpaces class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="packagesContainingNameSpace:">packagesContainingNameSpace: anID	"Check what packages define a given class. Return a collection of package IDs "	^[(self broker process: 			( self newSQL				select: #( packageRef );				where;				column: #nameSpaceRef equalTo: anID printString)	 ) collect: [ :each | each first ]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body></methods><methods><class-id>Store.PkgNameSpaces class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="indexNamesAndColumnNames">indexNamesAndColumnNames	^#(		#('ST_PkgNSReverse' #('nameSpaceRef'))		)</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn		^#nameSpaceRef</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="addedMethodRow:">addedMethodRow: aMethodBlueprint	^(SingleMethodView new)		method: aMethodBlueprint;		isAddition: true;		populate</body><body package="Store-Code Comparison" selector="changedMethodRowFrom:to:">changedMethodRowFrom: anOriginalMethodBlueprint to: aChangedMethodBlueprint	^MethodComparisonView new leftMethod: anOriginalMethodBlueprint rightMethod: aChangedMethodBlueprint</body><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	^super computeDetailRows , self methodRows</body><body package="Store-Code Comparison" selector="defaultIcon">defaultIcon	^BehaviorIcons Object</body><body package="Store-Code Comparison" selector="detailHintGraphics">detailHintGraphics	| icons addedMethodCount changedMethodCount removedMethodCount changedCategoryCount changedPackageCount |	icons := super detailHintGraphics.	addedMethodCount := changedMethodCount := removedMethodCount := changedCategoryCount := changedPackageCount := 0.	self		enumerateOrderedMethodAdditions: [addedMethodCount := addedMethodCount + 1]		removals: [removedMethodCount := removedMethodCount + 1]		changes: 			[:a :b |			a source = b source				ifFalse: [changedMethodCount := changedMethodCount + 1].			a category = b category				ifFalse: [changedCategoryCount := changedCategoryCount + 1].			a packageName = b packageName				ifFalse: [changedPackageCount := changedPackageCount + 1]].	changedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons modify						with: (Label with: '×' , changedMethodCount printString))].	changedPackageCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons movePackage						with: (Label with: '×' , changedPackageCount printString))].	changedCategoryCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons moveCategory						with: (Label with: '×' , changedCategoryCount printString))].	addedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons add						with: (Label with: '×' , addedMethodCount printString))].	removedMethodCount isZero		ifFalse: 			[icons add: (VisualRow with: ComparisonIcons remove						with: (Label with: '×' , removedMethodCount printString))].	^icons</body><body package="Store-Code Comparison" selector="methodRows">methodRows	| rows adds removes |	rows := OrderedCollection new.	adds := OrderedCollection new.	removes := OrderedCollection new.	self		enumerateOrderedMethodAdditions: 			[:addedMethod |			rows add: (adds addLast: (self addedMethodRow: addedMethod))]		removals: 			[:removedMethod |			rows add: (removes addLast: (self removedMethodRow: removedMethod))]		changes: 			[:removedMethod :addedMethod |			rows add: (self changedMethodRowFrom: removedMethod to: addedMethod)].	self correlateRenamesFrom: adds to: removes.	^rows</body><body package="Store-Code Comparison" selector="removedMethodRow:">removedMethodRow: aMethodBlueprint	^(SingleMethodView new)		method: aMethodBlueprint;		isAddition: false;		populate</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="initialize">initialize	super initialize.	rightMethods := leftMethods := Array new</body><body package="Store-Code Comparison" selector="leftClass:leftMethods:rightClass:rightMethods:">leftClass: aClassBlueprint leftMethods: aSequenceOfMethodBlueprints rightClass: bClassBlueprint rightMethods: bSequenceOfMethodBlueprints	(aClassBlueprint isNil and: 			[aSequenceOfMethodBlueprints isEmpty				and: [bClassBlueprint isNil and: [bSequenceOfMethodBlueprints isEmpty]]])		ifTrue: [^self halt].	leftBlueprint := aClassBlueprint.	leftMethods := aSequenceOfMethodBlueprints.	rightBlueprint := bClassBlueprint.	rightMethods := bSequenceOfMethodBlueprints.	self populate</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>displaying</category><body package="Store-Code Comparison" selector="drawDetailsBackroundOn:">drawDetailsBackroundOn: aGC	| box oldPaint oldStrokeWidth hue |	oldPaint := aGC paint.	oldStrokeWidth := aGC lineWidth.	hue := ColorValue orange hue.	aGC lineWidth: 2.	self detailsPanel childrenDo: 			[:row |			(row propertyAt: #linkTo)				ifNotNil: 					[:target |					box := ((Rectangle vertex: row frame topLeft vertex: target frame topLeft)								expandedBy: (self indent - 1) @ 0) translatedBy: 0 @ 8.					aGC paint: (ColorValue hue: hue saturation: 1 brightness: 0.6).					hue := (hue + 0.4) \\ 1.0.					aGC						displayArcBoundedBy: box rounded						startAngle: 90						sweepAngle: 180						at: self detailsPanel frame origin rounded]].	aGC		paint: oldPaint;		lineWidth: oldStrokeWidth</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>private</category><body package="Store-Code Comparison" selector="bindingTest">bindingTest	^#isForClass</body><body package="Store-Code Comparison" selector="correlateRenamesFrom:to:">correlateRenamesFrom: addMethodViews to: removeMethodViews	| matches map |	(addMethodViews isEmpty or: [removeMethodViews isEmpty]) ifTrue: [^self].	map := Dictionary new.	addMethodViews do: 			[:eachAdd |			eachAdd parseTree				ifNotNil: 					[:addTree |					matches := removeMethodViews select: 									[:eachRemove |									eachRemove parseTree										ifNil: [false]										ifNotNil: 											[:removeTree |											addTree body equalTo: removeTree body												exceptForVariables: (addTree arguments collect: #name)]].					matches size = 1						ifTrue: [(map at: matches any ifAbsentPut: [IdentitySet new]) add: eachAdd]]].	map keysAndValuesDo: 			[:eachRemove :allAdds |			allAdds size = 1 ifTrue: [allAdds any propertyAt: #linkTo put: eachRemove]]</body><body package="Store-Code Comparison" selector="enumerateOrderedMethodAdditions:removals:changes:">enumerateOrderedMethodAdditions: additionBlock removals: removalBlock changes: changeBlock	| additionStack removalStack |	additionStack := OrderedCollection withAll: rightMethods.	removalStack := OrderedCollection withAll: leftMethods.	[additionStack isEmpty and: [removalStack isEmpty]] whileFalse: 			[additionStack isEmpty				ifTrue: [removalBlock cull: removalStack removeFirst]				ifFalse: 					[removalStack isEmpty						ifTrue: [additionBlock cull: additionStack removeFirst]						ifFalse: 							[(additionStack first isSameSignatureAs: removalStack first)								ifTrue: 									[changeBlock cull: removalStack removeFirst cull: additionStack removeFirst]								ifFalse: 									[(additionStack first isSignatureLess: removalStack first)										ifTrue: [additionBlock cull: additionStack removeFirst]										ifFalse: [removalBlock cull: removalStack removeFirst]]]]]</body><body package="Store-Code Comparison" selector="fullReferenceDisplayName:">fullReferenceDisplayName: aBindingReference	| path output nsPath |	path := aBindingReference path.	output := TextStream on: String new.	output		emphasis: #bold;		nextPutAll: path last;		emphasis: nil;		nextPutAll: ' in {'.	nsPath := path allButLast: 1.	(nsPath size &gt; 2 and: [(nsPath first: 2) = #(#Root #Smalltalk)])		ifTrue: [nsPath := nsPath allButFirst: 2].	nsPath do: [:each | output nextPutAll: each]		separatedBy: [output nextPut: $.].	output nextPut: $}.	^output contents</body><body package="Store-Code Comparison" selector="imageReferenceFrom:orMethods:">imageReferenceFrom: aClassBlueprint orMethods: aMethodArray	| classReference binding |	classReference := aClassBlueprint ifNotNil: #reference.	(classReference isNil and: [aMethodArray notEmpty])		ifTrue: [classReference := aMethodArray any classReference].	classReference ifNil: [^nil].	binding := classReference bindingOrNil.	binding ifNil: [^nil].	^binding isForClass ifTrue: [classReference] ifFalse: [nil]</body><body package="Store-Code Comparison" selector="leftImageReference">leftImageReference	^self imageReferenceFrom: leftBlueprint orMethods: leftMethods</body><body package="Store-Code Comparison" selector="leftStoreObject">leftStoreObject	^leftBlueprint		ifNotNil: #originalStoreObject		ifNil: 			[leftMethods do: 					[:blueprint |					blueprint originalStoreObject						ifNotNil: 							[:storeMethodInPackage |							(self storeClassForMethod: storeMethodInPackage)								ifNotNil: [:storeClassInPackage | ^storeClassInPackage]]].			nil]</body><body package="Store-Code Comparison" selector="rightImageReference">rightImageReference	^self imageReferenceFrom: rightBlueprint orMethods: rightMethods</body><body package="Store-Code Comparison" selector="rightStoreObject">rightStoreObject	^rightBlueprint		ifNotNil: #originalStoreObject		ifNil: 			[rightMethods do: 					[:blueprint |					blueprint originalStoreObject						ifNotNil: 							[:storeMethodInPackage |							(self storeClassForMethod: storeMethodInPackage)								ifNotNil: [:storeClassInPackage | ^storeClassInPackage]]].			nil]</body><body package="Store-Code Comparison" selector="storeClassForMethod:">storeClassForMethod: aStoreMethodInPackage	^(aStoreMethodInPackage package		objectNamed: aStoreMethodInPackage fullClassName)			ifNotNil: #classDefinition</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>detail rows</category><body package="Store-Code Comparison" selector="attributesComparisonRow">attributesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyClassAttributes		name: 'Attributes'		leftText: leftBlueprint attributes printString		rightText: rightBlueprint attributes printString</body><body package="Store-Code Comparison" selector="attributesSingularRow">attributesSingularRow	^self singularBlueprint attributes isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyClassAttributes)				name: 'Attributes'				text: self singularBlueprint attributes printString]</body><body package="Store-Code Comparison" selector="behaviorTypeComparisonRow">behaviorTypeComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifyBehaviorType;		add: (self italicizedText: 'Type');		add: 'changed from';		add: leftBlueprint behaviorType asText allBold;		add: 'to';		add: rightBlueprint behaviorType asText allBold;		yourself</body><body package="Store-Code Comparison" selector="behaviorTypeSingularRow">behaviorTypeSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons modifyBehaviorType);		add: (self italicizedText: 'Type');		add: self singularBlueprint behaviorType asText allBold;		yourself</body><body package="Store-Code Comparison" selector="classInstanceVariablesComparisonRow">classInstanceVariablesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyClassInstanceVariables		name: 'Class Instance Variables'		leftText: (self				formattedInstanceVariables: leftBlueprint classInstanceVariables)		rightText: (self				formattedInstanceVariables: rightBlueprint classInstanceVariables)</body><body package="Store-Code Comparison" selector="classInstanceVariablesSingularRow">classInstanceVariablesSingularRow	^self singularBlueprint classInstanceVariables isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyClassInstanceVariables)				name: 'Class Instance Variables'				text: (self						formattedInstanceVariables: self singularBlueprint classInstanceVariables)]</body><body package="Store-Code Comparison" selector="formattedInstanceVariables:">formattedInstanceVariables: anInstanceVariableSequence	| ws |	ws := String new writeStream.	anInstanceVariableSequence do: [:each | ws nextPutAll: each]		separatedBy: [ws cr].	^ws contents</body><body package="Store-Code Comparison" selector="instanceVariablesComparisonRow">instanceVariablesComparisonRow	^BindingTextualDetailComparisonView new		icon: ComparisonIcons modifyInstanceVariables		name: 'Instance Variables'		leftText: (self formattedInstanceVariables: leftBlueprint instanceVariables)		rightText: (self				formattedInstanceVariables: rightBlueprint instanceVariables)</body><body package="Store-Code Comparison" selector="instanceVariablesSingularRow">instanceVariablesSingularRow	^self singularBlueprint instanceVariables isEmpty		ifTrue: [nil]		ifFalse: 			[BindingTextualDetailSingularView new				icon: (self						annotateIconWithDisposition: ComparisonIcons modifyInstanceVariables)				name: 'Instance Variables'				text: (self						formattedInstanceVariables: self singularBlueprint instanceVariables)]</body><body package="Store-Code Comparison" selector="superclassReferenceComparisonRow">superclassReferenceComparisonRow	^(self newRow)		add: self disclosureButtonSpace;		add: ComparisonIcons modifySuperclass;		add: (self italicizedText: 'Superclass');		add: 'changed from';		add: leftBlueprint superclassReference toolListDisplayString asText allBold;		add: 'to';		add: rightBlueprint superclassReference toolListDisplayString asText					allBold;		yourself</body><body package="Store-Code Comparison" selector="superclassReferenceSingularRow">superclassReferenceSingularRow	^(self newRow)		add: self disclosureButtonSpace;		add: (self annotateIconWithDisposition: ComparisonIcons modifySuperclass);		add: (self italicizedText: 'Superclass');		add: (self fullReferenceDisplayName: self singularBlueprint superclassReference)					asText allBold;		yourself</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="objectReference">objectReference	^super objectReference		ifNil: 			[leftMethods isEmpty				ifFalse: [leftMethods any classReference]				ifTrue: 					[rightMethods isEmpty						ifTrue: [nil]						ifFalse: [rightMethods any classReference]]]</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>testing</category><body package="Store-Code Comparison" selector="browseInHierarchy">browseInHierarchy	^true</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>utility-menu</category><body package="Store-Code Comparison" selector="versionListPaneClass">versionListPaneClass	^Store.Glorp.ClassListPane</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>private-tooltip</category><body package="Store-Code Comparison" selector="additionalInfoTooltipText">additionalInfoTooltipText	| output extendingPackages |	extendingPackages := (leftMethods , rightMethods collect: #packageName)				asSet.	self definingPackageNames		do: [:each | extendingPackages remove: each ifAbsent: []].	output := TextStream on: String new.	extendingPackages isEmpty ifTrue: [^output contents].	output		nextPutAll: (#ExtensionPackagesC &gt;&gt; 'Other Packages:' &lt;&lt; #IDE) asText.	output space.	extendingPackages sorted do: 			[:each |			output				emphasis: #bold;				nextPutAll: each;				emphasis: nil]		separatedBy: [output nextPut: $/].	^output contents</body><body package="Store-Code Comparison" selector="definingNamespaceReferences">definingNamespaceReferences	"When we have no class blueprints (unique to class variant), we probe the first method on each side for the information."	| references |	(leftBlueprint isNil and: [rightBlueprint isNil])		ifFalse: [^super definingNamespaceReferences].	references := OrderedCollection new.	leftMethods isEmpty		ifFalse: 			[references add: (self referenceNamespace: leftMethods any classReference)].	rightMethods isEmpty		ifFalse: 			[| rightReference |			rightReference := self referenceNamespace: rightMethods any classReference.			(references includes: rightReference)				ifFalse: [references add: rightReference]].	^references</body><body package="Store-Code Comparison" selector="definingPackageNames">definingPackageNames	"When we have no class blueprints (unique to class variant), we use the method packages IF and only IF, they are consistent."	| packages leftPackages rightPackages |	(leftBlueprint isNil and: [rightBlueprint isNil])		ifFalse: [^super definingPackageNames].	packages := OrderedCollection new.	leftPackages := (leftMethods collect: #packageName) asSet.	rightPackages := (rightMethods collect: #packageName) asSet.	leftPackages size = 1 ifTrue: [packages add: leftPackages any].	rightPackages size = 1		ifTrue: 			[(packages includes: rightPackages any)				ifFalse: [packages add: rightPackages any]].	^packages</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^super expansionMemoryKey		ifNil: 			[leftMethods isEmpty				ifTrue: 					[rightMethods isEmpty						ifTrue: [nil]						ifFalse: [Array with: self bindingTest with: rightMethods any classReference]]				ifFalse: [Array with: self bindingTest with: leftMethods any classReference]]</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView class</class-id> <category>example</category><body package="Store-Code Comparison" selector="compareTwoClasses">compareTwoClasses	"self compareTwoClasses"	| leftClass rightClass leftMethods rightMethods differences view scrolled |	leftClass := (IncrementalSearchDialog selectClass: 'First (left) class?')				ifNil: [^self].	rightClass := (IncrementalSearchDialog				selectClass: 'Second (right) class?') ifNil: [^self].	leftMethods := (leftClass getMethodDictionary values				, leftClass class getMethodDictionary values collect: #definition)				collect: #asBlueprint.	rightMethods := (rightClass getMethodDictionary values				, rightClass class getMethodDictionary values collect: #definition)				collect: #asBlueprint.	differences := (SequenceableCollectionDifferences new)				comparisonFunction: [:a :b | a &gt;=&lt; b];				differencesFrom: leftMethods sort to: rightMethods sort.	leftMethods := (differences select: #isDelete) inject: Array new				into: [:accum :each | accum , each].	rightMethods := (differences select: #isInsert) inject: Array new				into: [:accum :each | accum , each].	view := (ClassBlueprintComparisonView new)				leftClass: leftClass asBlueprint					leftMethods: leftMethods					rightClass: rightClass asBlueprint					rightMethods: rightMethods;				toggleExpansion.	scrolled := (BorderDecorator on: view) useVerticalScrollBar.	scrolled scrollerComponent scrollOffsetHolder grid: 1 @ 20.	(ScheduledWindow new)		component: scrolled;		openWithExtent: 800 @ 800</body></methods><methods><class-id>Store.LoadingActionError</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="action">action	^action</body><body package="Atomic Compiling and Loading" selector="action:">action: anObject	action := anObject</body><body package="Atomic Compiling and Loading" selector="error">error	^parameter</body><body package="Atomic Compiling and Loading" selector="error:">error: anError	parameter := anError</body></methods><methods><class-id>Store.LoadingActionError</class-id> <category>printing</category><body package="Atomic Compiling and Loading" selector="defaultMessageText">defaultMessageText	^#_1sActionFor2sCHeErrorN3s4s &lt;&lt; #store 		&gt;&gt; '&lt;1s&gt; action for &lt;2s&gt; caused the error:&lt;n&gt;&lt;3s&gt;:&lt;4s&gt;' 			expandMacrosWith: action			with: package name			with: self error displayString			with: self error description</body></methods><methods><class-id>Store.LoadingActionError</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="defaultAction">defaultAction	"What to do when the exception is unhandled."	^Dialog confirm: ((#_1sNttContinue &lt;&lt; #store &gt;&gt; '&lt;1s&gt;&lt;ntt&gt;Continue?') expandMacrosWith: self defaultMessageText)</body></methods><methods><class-id>Store.LoadingActionError class</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.LoadingActionError class</class-id> <category>instance creation</category><body package="Atomic Compiling and Loading" selector="pundle:action:error:">pundle: aPundle action: aSymbol error: anError	^self new		package: aPundle;		action: aSymbol;		error: anError;		raise</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentTabNavigatorPart</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="classes">classes	| classes |	classes := self componentNamed: #classes.	classes isNil 		ifTrue: 			[classes := StoreClassNavigatorPart new.			navigator notNil ifTrue: [classes navigator: navigator].			self componentNamed: #classes put: classes].	^classes</body><body package="StoreForGlorpBrowserUI" selector="packages">packages	| packages |	packages := self componentNamed: #packages.	packages isNil 		ifTrue: 			[packages := StorePundleNavigatorPart new.			navigator notNil ifTrue: [packages navigator: navigator].			self componentNamed: #packages put: packages].	^packages</body></methods><methods><class-id>Store.PseudoNameSpace</class-id> <category>browser support</category><body package="Store-DB-Records" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.PseudoNameSpace</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	(self objectIsForSelf: anObject) ifFalse: [^false].	^name = anObject absoluteName</body><body package="Store-DB-Records" selector="hash">hash	^name hash</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForNameSpace</body></methods><methods><class-id>Store.PseudoNameSpace</class-id> <category>accessing</category><body package="Store-DB-Records" selector="environmentString">environmentString	| path |	path := (GeneralBindingReference parseString: name).	path removeLast.	^path fold: [:a :b | a, '.', b]</body><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType	^#nameSpace</body><body package="Store-DB-Records" selector="name">name	^( name tokensBasedOn: $.) last</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteClassName">absoluteClassName	^self classNameWithMeta</body><body package="Store-Database Model" selector="className">className	^self definition className.</body><body package="StoreForGlorpVWUI" selector="classNameWithoutMeta">classNameWithoutMeta	^self definition classNameWithoutMeta</body><body package="Store-Database Model" selector="classOrNameSpace">classOrNameSpace	^self package fullClassForMethod: self.</body><body package="Store-Database Model" selector="correspondingImageClass">correspondingImageClass	^self definition correspondingImageClass</body><body package="Store-Database Model" selector="editionStamp">editionStamp	^''.</body><body package="Store-Database Model" selector="environment">environment	^self definition environment.</body><body package="StoreForGlorpVWUI" selector="fullClassName">fullClassName	^self longName</body><body package="StoreForGlorpVWUI" selector="implementingClass">implementingClass	^self myClass</body><body package="Store-Database Model" selector="inheritingClass">inheritingClass	"What is this for?  Just hard-code to the same class for the moment"	^self classOrNameSpace.</body><body package="Store-Database Model" selector="isMetaclass">isMetaclass	^self definition isMetaclass.</body><body package="Store-Database Model" selector="longName">longName	^self className</body><body package="Store-Database Model" selector="methodClass">methodClass	^self classOrNameSpace.</body><body package="Store-Database Model" selector="methodSources">methodSources	^self definition methodSources</body><body package="Store-Database Model" selector="myClass">myClass	^self definition correspondingImageClass.</body><body package="Store-Database Model" selector="name">name	^self definition name</body><body package="StoreForGlorpVWUI" selector="ownerName">ownerName	^self definition className.</body><body package="Store-Database Model" selector="protocol">protocol	^self definition protocol.</body><body package="Store-Database Model" selector="resourceType">resourceType	^nil.</body><body package="Store-Database Model" selector="selector">selector	^self definition selector.</body><body package="Store-Database Model" selector="source">source	^self definition source.</body><body package="Store-Database Model" selector="sourceString">sourceString	^self source.</body><body package="Store-Database Model" selector="symbol">symbol	^self definition name asSymbol.</body><body package="StoreForGlorpVWUI" selector="version">version	^self definition version.</body><body package="Store-Database Model" selector="versions">versions	| session methodDefinitionQuery methods uniqueKeys |	session := StoreLoginFactory currentStoreSession.	methodDefinitionQuery := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	methodDefinitionQuery alsoFetch: #definition.	methodDefinitionQuery orderBy: [:each | each definition timestamp descending].	methods := session execute: methodDefinitionQuery.	uniqueKeys := Set new.	^methods inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>printing</category><body package="Store-Database Model" selector="classNameWithMeta">classNameWithMeta	^self definition classNameWithMeta.</body><body package="Store-Database Model" selector="displayString">displayString	^self definition displayString.</body><body package="Store-Database Model" selector="fileOutSourceOn:">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager</body><body package="Store-Database Model" selector="fullDisplayText">fullDisplayText	^self displayString asText.</body><body package="Store-Database Model" selector="printOn:">printOn: aStream	| hasDefinition |	hasDefinition := 	(self definition isGlorpProxy not or: [self definition isInstantiated]).	aStream nextPutAll: self class name; space.	hasDefinition ifTrue: [aStream nextPutAll: self classNameWithMeta].	aStream nextPutAll: '&gt;&gt;'.	aStream nextPutAll: '#'.	hasDefinition ifTrue: [aStream nextPutAll: self definition name]		ifFalse: [aStream nextPutAll: 'Unknown'].</body><body package="Store-Database Model" selector="signature">signature	^self longNameWithMetaFromSmalltalk, ' &gt;&gt; ', self name</body><body package="StoreForGlorpVWUI" selector="statusLineString">statusLineString	^self protocol</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>loading</category><body package="StoreForGlorpVWUI" selector="loadAsNewIn:">loadAsNewIn: aPackageModel	Store.Policies packagePolicy 		forcePackage: aPackageModel		while: [self definition loadSource]</body><body package="StoreForGlorpVWUI" selector="loadAsNewIn:withCommittingSource:">loadAsNewIn: aPackageModel withCommittingSource: aBoolean	self deprecated: #(#version '7.8' #sunset '8.0' #use #loadSource or #loadAsNewIn:).	Store.Policies packagePolicy 		forcePackage: aPackageModel		while: [self definition loadSource]</body><body package="Store-Database Model" selector="loadSource">loadSource	| selector class protocol packageModel result |	(class := self correspondingImageClass) ifNil: 		[Store.UnloadableDefinitionError signalWith: self.		^nil].	selector := self selector.	protocol := self protocol.	packageModel := self package storeModel ifNil: [Registry pundleNamed: self package name].	((class includesSelector: selector)		and: [(class organization categoryOfElement: selector) = protocol 		and: [(class compiledMethodAt: selector) getSource string = self sourceCode]])			ifTrue: 				[result := class compiledMethodAt: selector.				packageModel ifNotNil: [Store.XChangeSet current moveSelector: selector class: class toPackage: packageModel]]			ifFalse:				[| environment |				environment := packageModel 					ifNil: [class environment]					ifNotNil:						[:value |							value environmentFor: selector							in: class].				result := class					compile: self sourceCode					classified: protocol					notifying: nil					environment: environment].	^result</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	^self loadSource</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>testing</category><body package="Store-Database Model" selector="isForMethod">isForMethod	^true.</body><body package="Store-Database Model" selector="isMeta">isMeta	^self definition isMeta</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>comparing</category><body package="Store-Database Model" selector="=">= aStoreMethodInPackage	aStoreMethodInPackage class == self class ifFalse: [		^self definition = aStoreMethodInPackage asStoreMethodDefinition].	^self package yourSelf == aStoreMethodInPackage package yourSelf and: [self definition yourSelf = aStoreMethodInPackage definition yourSelf].</body><body package="Store-Database Model" selector="equalsSignatureIn:">equalsSignatureIn: aStoreMethodInPackage	aStoreMethodInPackage class == self class ifFalse: [		^self definition equalsSignatureIn: aStoreMethodInPackage asStoreMethodDefinition].	^self package yourSelf == aStoreMethodInPackage package yourSelf and: [self definition equalsSignatureIn: aStoreMethodInPackage definition].</body><body package="Store-Database Model" selector="hash">hash	^self definition yourSelf hash</body><body package="Store-Database Model" selector="signatureHash">signatureHash	^self definition signatureHash</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>private</category><body package="Store-Database Model" selector="fileOutDefinitionOn:">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	| dictionary |	dictionary := Dictionary new.	dictionary at: self protocol put: (Set with: self).	aStream sourceFormatter attributeFor: #package compute: [:ignored | self package name].	aStream sourceFormatter attributeForMethods: #package compute: [:ignored :more | self package name].	aStream fileOutTTMessages: dictionary for: self classNameWithMeta logging: false.</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>converting</category><body package="Store-Database Model" selector="asStoreMethodDefinition">asStoreMethodDefinition	^self definition</body><body package="Store-Database Model" selector="asString">asString	^self displayString.</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>compatibility</category><body package="StoreForGlorpVWUI" selector="asTag">asTag	^Store.MethodTag 		newClassName: self className 		meta: self isMeta		selector: self selector asSymbol		protocol: self protocol.</body><body package="Store-Database Model" selector="isProbed">isProbed	^false.</body><body package="Store-Database Model" selector="method">method	^nil.</body><body package="Store-Database Model" selector="sourceCode">sourceCode	^self source</body><body package="Store-Database Model" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self source</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>compatiblity</category><body package="StoreForGlorpVWUI" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	Store.XMainChangeSet current		addRemoveSelector: self selector		className: self className asClassNameOnly		meta: self isMeta		package: aPackage</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeMethod: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedMethodObject</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage</class-id> <category>displaying</category><body package="Store-Database Model" selector="fullDisplayString">fullDisplayString	^'[&lt;3s&gt;] &lt;1s&gt; &lt;2s&gt;' 		expandMacrosWith: self signature		with: self bracketedVersionString		with: self package name</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage class</class-id> <category>database utility</category><body package="Store-Database Model" selector="allVersionsWithName:in:">allVersionsWithName: aString in: aSession	| query session objects uniqueKeys |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachClass | eachClass definition name = aString].	query alsoFetch: #definition.	query orderBy: [:each | each definition timestamp descending].	objects := session execute: query.	uniqueKeys := Set new.	^objects inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body><body package="Store-Database Model" selector="allVersionsWithName:inClass:">allVersionsWithName: aString inClass: aClassName	^self allVersionsWithName: aString inClass: aClassName in: nil</body><body package="Store-Database Model" selector="allVersionsWithName:inClass:in:">allVersionsWithName: aString inClass: aClassName in: aSession	| query session objects uniqueKeys |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachMethod | eachMethod definition name = aString AND: [eachMethod definition className = aClassName]].	query alsoFetch: #definition.	query alsoFetch: [:each | each definition source].	query alsoFetch: [:each | each definition source data].	query alsoFetch: [:each | each definition protocol].	query alsoFetch: [:each | each package name].	query orderBy: [:each | each definition timestamp descending].	objects := session execute: query.	uniqueKeys := Set new.	^objects inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body><body package="Store-Database Model" selector="allVersionsWithNameIn:inClass:">allVersionsWithNameIn: aCollection inClass: aClassName	"Note the result is unordered, it is up to you to order it if you want"	^self allVersionsWithNameIn: aCollection inClass: aClassName in: nil</body><body package="Store-Database Model" selector="allVersionsWithNameIn:inClass:in:">allVersionsWithNameIn: aCollection inClass: aClassName in: aSession	"Note the result is unordered, it is up to you to order it if you want"	| query session objects uniqueKeys |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	query := Query		read: self		where: [:eachMethod | (eachMethod definition name in: aCollection) AND: [eachMethod definition className = aClassName]].	query alsoFetch: #definition.	objects := session execute: query.	uniqueKeys := Set new.	^objects inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body><body package="Store-Database Model" selector="selectStoreVersionOf:inClass:in:">selectStoreVersionOf: aString inClass: aClassName in: aSession	"Produce a dialogue that answers a store class definitin in package object or nil."		| list session |	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	list := self allVersionsWithName: aString inClass: aClassName in: session.	list isEmpty		ifTrue:			[Dialog warn: (#NoPriorVersions &lt;&lt; #store &gt;&gt; 'No prior versions') asString.			^nil].	list size == 1 ifTrue: [^list first].	^Dialog		choose: (#ChooseVersionColon &lt;&lt; #store &gt;&gt; 'Choose version:') asString		fromList: (list collect: [:each | each longNameFromSmalltalk, ' ', each definition timeStampString])		values: list		lines: 10		cancel: [^nil]		for: nil</body></methods><methods><class-id>Store.Glorp.StoreMethodInPackage class</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="toolListIcon">toolListIcon	^BehaviorIcons Method</body></methods><methods><class-id>Store.RequestUniqueDatabaseIdentifierString</class-id> <category>constants</category><body package="Store-Base" selector="defaultResumeValue">defaultResumeValue	^'store_database'</body><body package="Store-Base" selector="defaultReturnValue">defaultReturnValue	^'store_database'</body></methods><methods><class-id>Store.RequestUniqueDatabaseIdentifierString</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	| identifier |	[(identifier := Dialog		request: #EnterAUniqueNameForThisStoreRepository &lt;&lt; #store &gt;&gt; 'Enter a unique name for this Store repository:'		initialAnswer: '') notEmpty] whileFalse.	^identifier</body></methods><methods><class-id>Store.RequestUniqueDatabaseIdentifierString class</class-id> <category>testing</category><body package="Store-Base" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>accessing</category><body package="StoreForGlorpBrowserUI" selector="addPundle:">addPundle: aPundle	^pundles add: aPundle</body><body package="StoreForGlorpBrowserUI" selector="allClasses">allClasses	^((self pundles inject: Set new into:		[:sum :each |		sum addAll: each definedClasses]) asSortedCollection: [:each :other| each name &lt;= other name]) asOrderedCollection</body><body package="StoreForGlorpBrowserUI" selector="allNameSpaces">allNameSpaces	^(self pundles inject: Set new into:		[:sum :each |		sum addAll: each nameSpaces]) asSortedCollection asOrderedCollection</body><body package="StoreForGlorpBrowserUI" selector="allPundles">allPundles	| result |	result := OrderedCollection new.	self bundlesAndPackagesDo: [:each | result add: each].	^result</body><body package="StoreForGlorpBrowserUI" selector="allShared">allShared	| answer sharedVariables |	answer := OrderedCollection new.	sharedVariables := self pundles		inject: Set new		into: [:sum :each | sum addAll: each sharedVariables].	sharedVariables do: [:each | answer add: each longNameFromSmalltalk -&gt; each].	^sharedVariables asSortedCollection collect: [:each | each value]</body><body package="StoreForGlorpBrowserUI" selector="bindingReferencesDo:">bindingReferencesDo: aBlock	| traversed enumerationBlock reference |	traversed := Set new.	enumerationBlock :=			[:each |			reference := each longName.			(traversed includes: reference)				ifFalse: 					[aBlock value: each.					traversed add: reference]].	pundles first nameSpaces do: enumerationBlock.	pundles first allClasses do: enumerationBlock.	pundles first sharedVariables		do: [:each | each isInClass ifFalse: [enumerationBlock value: each]]</body><body package="StoreForGlorpBrowserUI" selector="bundlesAndPackagesDo:">bundlesAndPackagesDo: aBlock	"This is a read-only environment so use the cached collection."	| visited visitor |	visited := IdentitySet new.	visitor :=			[:each |			(visited includes: each)				ifFalse: 					[visited add: each.					aBlock value: each.					each isBundle ifTrue: [each allItems do: visitor]]].	self pundles do: visitor</body><body package="StoreForGlorpBrowserUI" selector="bundlesDo:">bundlesDo: aBlock	"This is a read-only environment so use bundles from the cached collection."	| visited visitor |	visited := IdentitySet new.	visitor :=			[:each |			each isBundle				ifTrue: 					[(visited includes: each)						ifFalse: 							[visited add: each.							aBlock value: each.							each allItems do: visitor]]].	self pundles do: visitor</body><body package="StoreForGlorpBrowserUI" selector="categories">categories	^self pundles</body><body package="StoreForGlorpBrowserUI" selector="enclosingBundlesFor:">enclosingBundlesFor: aStorePundle	self pundles do:		[:each |		(each enclosingBundlesFor: aStorePundle) ifNotNil: [:value | ^value]].	^#()</body><body package="StoreForGlorpBrowserUI" selector="methodDefinitions">methodDefinitions	| methods |	methods := OrderedCollection new.	^pundles inject: methods into: [:sum :each | sum addAll: each methods. sum].</body><body package="StoreForGlorpBrowserUI" selector="methodNamed:inClass:">methodNamed: aSelector inClass: aClass	^self methodDefinitions 		detect: [:each | each classNameWithMeta = aClass classNameWithMeta and: [each name = aSelector asString]]		ifNone: [nil]</body><body package="StoreForGlorpBrowserUI" selector="navigatorClass">navigatorClass		^StoreForGlorpNavigator</body><body package="StoreForGlorpBrowserUI" selector="openEditor">openEditor	self pundles do: [:each | each resetFullClasses].	^StoreRefactoringBrowser openOnEnvironment: self</body><body package="StoreForGlorpBrowserUI" selector="packagesContaining:">packagesContaining: aClassOrNameSpaceOrShared	| found |	^(self pundles inject: OrderedCollection new into:		[:sum :each |		found := each 			componentsDetect: [:eachPundle | eachPundle isPackage and: [eachPundle name = aClassOrNameSpaceOrShared package name]]			ifNone: [nil].		found ifNotNil: [sum add: found].		sum]).</body><body package="StoreForGlorpBrowserUI" selector="packagesDo:">packagesDo: aBlock	"This is a read-only environment so use packages from the cached collection."	| visited visitor |	visited := IdentitySet new.	visitor :=			[:each |			(visited includes: each)				ifFalse: 					[visited add: each.					each isPackage ifTrue: [aBlock value: each].					each isBundle ifTrue: [each allItems do: visitor]]].	self pundles do: visitor</body><body package="StoreForGlorpBrowserUI" selector="protocolsFor:">protocolsFor: aClass 	^aClass protocols.</body><body package="StoreForGlorpBrowserUI" selector="pundleNamed:isPackage:">pundleNamed: aString isPackage: aBoolean	| target |	pundles do:		[:each |		target := each withAllItems 			detect:				[:eachPundle |				eachPundle isPackage = aBoolean and: [eachPundle name = aString]]			ifNone: [nil].		target ifNotNil: [^target]].	^nil</body><body package="StoreForGlorpBrowserUI" selector="pundles">pundles	^pundles</body><body package="StoreForGlorpBrowserUI" selector="selectorsFor:in:">selectorsFor: aProtocol in: aClass	^(aClass instanceMethods select: [:each | each protocol = aProtocol]) collect: [:each | each name]</body><body package="StoreForGlorpBrowserUI" selector="selectorsForClass:do:">selectorsForClass: aClass do: aBlock 	(aClass instanceMethods collect: [:each | each name])  do: aBlock.</body><body package="StoreForGlorpBrowserUI" selector="sharedVariable:for:">sharedVariable: aName for: aClassOrNameSpace	^self pundles first sharedVariables 		detect: [:each | each absoluteOwnerName asString = aClassOrNameSpace and: [each name = aName asString]]		ifNone: [nil]</body><body package="StoreForGlorpBrowserUI" selector="sharedVariableProtocolsFor:">sharedVariableProtocolsFor: aClass 	^(self pundles first sharedVariables select: [:each | each absoluteOwnerName asString = aClass longName])		collect: [:each | each protocol].</body><body package="StoreForGlorpBrowserUI" selector="sharedVariablesFor:in:">sharedVariablesFor: aProtocol in: aClassOrNameSpace	^(self pundles first sharedVariables		select: [:each | each absoluteOwnerName asString = aClassOrNameSpace longName and: [each protocol = aProtocol]])			collect: [:each | each dataKey]</body><body package="StoreForGlorpBrowserUI" selector="sharedVariablesForClass:">sharedVariablesForClass: aClass	^self pundles first sharedVariables		select: [:each | each absoluteOwnerName asString = aClass longName]</body><body package="StoreForGlorpBrowserUI" selector="whichProtocolIncludes:in:">whichProtocolIncludes: aSelector in: aClass	^(aClass compiledMethodAt: aSelector) ifNotNil: #protocol</body><body package="StoreForGlorpBrowserUI" selector="whichProtocolIncludesVariable:in:">whichProtocolIncludesVariable: aSymbol in: aClass	| result |	result := self pundles first sharedVariables 		detect: [:each | each absoluteOwnerName asString = aClass longName and: [each name = aSymbol]]		ifNone: [^nil].	^result protocol</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>testing</category><body package="StoreForGlorpBrowserUI" selector="includesClass:">includesClass: aClass	^self pundles anySatisfy: [:each |		each fullClasses includes: aClass mainClass].</body><body package="StoreForGlorpBrowserUI" selector="includesSelector:in:">includesSelector: aSelector in: aClass		^self pundles anySatisfy:		[:each | 		each methods anySatisfy: [:eachMethod | eachMethod classNameWithMeta = aClass classNameWithMeta and: [eachMethod selector = aSelector asSymbol]]]</body><body package="StoreForGlorpBrowserUI" selector="isEmpty">isEmpty	^pundles isEmpty.</body><body package="StoreForGlorpBrowserUI" selector="isSystem">isSystem	^false.</body><body package="StoreForGlorpBrowserUI" selector="useSystemNavigator">useSystemNavigator	"Override so we use the system browser spec, even though this is not the system browser."	^true</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>initialize-release</category><body package="StoreForGlorpBrowserUI" selector="initialize">initialize	pundles := OrderedCollection new.</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>accessing-classes</category><body package="StoreForGlorpBrowserUI" selector="allClassesDo:">allClassesDo: aBlock 	self packagesDo: [:each | each fullClasses do: [:eachClass | aBlock value: eachClass]].</body><body package="StoreForGlorpBrowserUI" selector="allMetaClassesDo:">allMetaClassesDo: aBlock 	self packagesDo: [:each | each fullClasses do: [:eachClass | aBlock value: eachClass storeMetaClass]].</body><body package="StoreForGlorpBrowserUI" selector="at:ifAbsent:">at: className ifAbsent: aBlock	^self classForName: className asString ifAbsent: aBlock.</body><body package="StoreForGlorpBrowserUI" selector="classForName:">classForName: aString	^self classForName: aString ifAbsent: [nil].</body><body package="StoreForGlorpBrowserUI" selector="classForName:ifAbsent:">classForName: aString ifAbsent: aBlock	"We may sometimes hand out object name wrappers but should always receive full names back from our navigator and state.  (Our code assumes that aBlock will either return or answer something that responds to #objectNamed:)"	| containingPundle theClass |	containingPundle := self pundles		detect: [:each | (each objectNamed: aString) notNil]		ifNone: aBlock.	containingPundle ifNil: [^aBlock value].	theClass := containingPundle objectNamed: aString.	^theClass isNil ifTrue: aBlock ifFalse: [theClass]</body><body package="StoreForGlorpBrowserUI" selector="nameSpaceForName:">nameSpaceForName: aString	^self nameSpaceForName: aString ifAbsent: [nil].</body><body package="StoreForGlorpBrowserUI" selector="nameSpaceForName:ifAbsent:">nameSpaceForName: aString ifAbsent: aBlock	"aBlock must either return or answer something that responds to #objectNamed:"	| containingPundle theNamespace |	containingPundle := self pundles		detect: [:each | (each nameSpaceNamed: aString ) notNil]		ifNone: aBlock.	containingPundle ifNil: [^aBlock value].	theNamespace := containingPundle nameSpaceNamed: aString.	^theNamespace isNil ifTrue: aBlock ifFalse: [theNamespace]</body><body package="StoreForGlorpBrowserUI" selector="nameSpaceObjectNames">nameSpaceObjectNames	| names |	names := OrderedCollection new.	self nameSpacesDo: [:each | names add: each name].	^names.</body><body package="StoreForGlorpBrowserUI" selector="nameSpacesDo:">nameSpacesDo: aBlock 	self packagesDo: [:each | each namespaces do: aBlock].</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>environments</category><body package="StoreForGlorpBrowserUI" selector="protocolEnvironmentClass">protocolEnvironmentClass	^StoreProtocolEnvironment</body><body package="StoreForGlorpBrowserUI" selector="pundleEnvironmentClass">pundleEnvironmentClass	^StorePundleEnvironment</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>printing</category><body package="StoreForGlorpBrowserUI" selector="fullNameFor:">fullNameFor: aClassOrNamespace	^aClassOrNamespace longName.</body><body package="StoreForGlorpBrowserUI" selector="glorpSession">glorpSession	^pundles first session</body><body package="StoreForGlorpBrowserUI" selector="repositoryName">repositoryName	^pundles first dbIdentifier</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment</class-id> <category>private</category><body package="StoreForGlorpBrowserUI" selector="classEnvironmentClass">classEnvironmentClass	^StoreClassEnvironment</body><body package="StoreForGlorpBrowserUI" selector="selectorEnvironmentClass">selectorEnvironmentClass	^StoreSelectorEnvironment</body></methods><methods><class-id>Store.Glorp.StoreForGlorpBrowserEnvironment class</class-id> <category>instance creation</category><body package="StoreForGlorpBrowserUI" selector="on:">on: aPundle	^self new		addPundle: aPundle;		yourself</body></methods><methods><class-id>Store.PseudoBundle</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="name">name	^realPackage isNil		ifTrue: [(#BracketNoMatchingBundle &lt;&lt; #store &gt;&gt; '[No Matching Bundle]') asString]		ifFalse: [realPackage name]</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>initialize-release</category><body package="Store-Code Comparison" selector="comparison:">comparison: aComparison	comparison := aComparison.	self isSimple ifTrue: [expandedFraction := 1].	self populate</body><body package="Store-Code Comparison" selector="initialize">initialize	super initialize.	expandedFraction := 0.	filteredComponents := Set new</body><body package="Store-Code Comparison" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	self		layoutAlgorithm: [:rect :parts | self computeLayouts: parts bounds: rect]</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>event driven</category><body package="Store-Code Comparison" selector="getEventHandler">getEventHandler		^self</body><body package="Store-Code Comparison" selector="handleEvent:">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-Code Comparison" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	^(aMouseEvent yellowButtonPressed		and: [(menuTarget := self menuTargetAt: aMouseEvent) notNil])			ifTrue: [self]			ifFalse: [super handlerForMouseEvent: aMouseEvent]</body><body package="Store-Code Comparison" selector="menuTargetAt:">menuTargetAt: aMouseEvent	self detailsPanel childrenDo: 			[:eachRow |			(eachRow containsMouseEvent: aMouseEvent)				ifTrue: 					[eachRow childrenDo: 							[:eachLabel |							(eachLabel containsMouseEvent: aMouseEvent)								ifTrue: [^eachLabel propertyAt: #codeComponent]]]].	^nil</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>private</category><body package="Store-Code Comparison" selector="adjustScrollBars">adjustScrollBars	self children size = 4 ifFalse: [^self].	(expandedFraction = 1		and: [self detailsPanel preferredHeight &gt; self detailsDecorator frame height])			ifTrue: 				[self detailsDecorator hasVerticalScrollBar					ifFalse: [self detailsDecorator useVerticalScrollBar]]			ifFalse: 				[self detailsDecorator hasVerticalScrollBar					ifTrue: [self detailsDecorator noVerticalScrollBar]]</body><body package="Store-Code Comparison" selector="anticipateNewDisclosureButtonLabel">anticipateNewDisclosureButtonLabel	self disclosureButton idleGraphic: (self isExpanded				ifTrue: [self collapsedIndicator]				ifFalse: [self expandedIndicator])</body><body package="Store-Code Comparison" selector="changeExpandedFractionTo:">changeExpandedFractionTo: aFraction	expandedFraction := aFraction.	self changedPreferredBounds: nil.	self invalidateNow</body><body package="Store-Code Comparison" selector="collapsedIndicator">collapsedIndicator	| label |	label := Label with: '+' asText allBold.	^VisualBlock block: 			[:gc :box |			gc				paint: SymbolicPaint background;				displayRectangle: box;				paint: SymbolicPaint foreground;				display: label at: box center - label extent half]		extent: 16 @ 16</body><body package="Store-Code Comparison" selector="compareCodeComponent:equalTo:">compareCodeComponent: aCodeComponent equalTo: bCodeComponent	^aCodeComponent name = bCodeComponent name		and: [aCodeComponent isBundle = bCodeComponent isBundle]</body><body package="Store-Code Comparison" selector="compareCodeComponent:lessThan:">compareCodeComponent: aCodeComponent lessThan: bCodeComponent	^aCodeComponent name = bCodeComponent name		ifTrue: [aCodeComponent isBundle]		ifFalse: [aCodeComponent name &lt;= bCodeComponent name]</body><body package="Store-Code Comparison" selector="computeLayouts:bounds:">computeLayouts: aVisualPartSequence bounds: aRectangle	| summaryBox detailsBox disclosureBox disclosureExtent swapBox |	aVisualPartSequence size = 4		ifFalse: [^aVisualPartSequence collect: [:ignored | Rectangle zero]].	summaryBox := aRectangle origin extent: aRectangle width						@ (self summaryPanel preferredHeight * (1 - expandedFraction)).	disclosureExtent := self disclosureButton preferredExtent.	disclosureBox := aRectangle bottomCenter				- (disclosureExtent x half @ disclosureExtent y) extent: disclosureExtent.	detailsBox := summaryBox bottomLeft				corner: aRectangle right @ disclosureBox top.	swapBox := (detailsBox topCenter leftBy: 8)				corner: (detailsBox bottomCenter rightBy: 8).	^Array		with: summaryBox		with: detailsBox		with: swapBox		with: disclosureBox</body><body package="Store-Code Comparison" selector="disclosureClicked">disclosureClicked	self toggleExpansion</body><body package="Store-Code Comparison" selector="expandedIndicator">expandedIndicator	| label |	label := Label with: '-' asText allBold.	^VisualBlock block: 			[:gc :box |			gc				paint: SymbolicPaint background;				displayRectangle: box;				paint: SymbolicPaint foreground;				display: label at: box center - label extent half]		extent: 16 @ 16</body><body package="Store-Code Comparison" selector="expansionChangeBeginning">expansionChangeBeginning	self anticipateNewDisclosureButtonLabel</body><body package="Store-Code Comparison" selector="expansionChangeFinished">expansionChangeFinished	self adjustScrollBars</body><body package="Store-Code Comparison" selector="filterChanged">filterChanged	self neighborComparisonShell comparisonSource: self filteredComparison</body><body package="Store-Code Comparison" selector="filteredComparison">filteredComparison	filteredComponents isEmpty ifTrue: [^comparison].	^comparison withoutComponents: filteredComponents</body><body package="Store-Code Comparison" selector="menuTargetCompliment">menuTargetCompliment	"Return the codeComponent which is the counterpart to the current menuTarget"	| search |	search := (comparison leftCodeComponents includes: menuTarget)				ifTrue: [comparison rightCodeComponents]				ifFalse: [comparison leftCodeComponents].	^search detect: 			[:each |			each name = menuTarget name and: [each isBundle = menuTarget isBundle]]		ifNone: [nil]</body><body package="Store-Code Comparison" selector="neighborComparisonShell">neighborComparisonShell	^self parent mainArea component</body><body package="Store-Code Comparison" selector="selectOnly:">selectOnly: aCodeComponentCollection	filteredComponents removeAll.	self leftComponents do: 			[:each |			(aCodeComponentCollection includes: each)				ifFalse: [filteredComponents add: each]].	self rightComponents do: 			[:each |			(aCodeComponentCollection includes: each)				ifFalse: [filteredComponents add: each]].	self filterChanged</body><body package="Store-Code Comparison" selector="similiarStringFrom:">similiarStringFrom: aComponentSequence	| prefix suffix |	aComponentSequence isEmpty ifTrue: [^''].	prefix := aComponentSequence inject: aComponentSequence first name				into: [:accum :each | accum first: (each name sameCharacters: accum)].	suffix := aComponentSequence inject: aComponentSequence first name				into: [:accum :each | accum last: (each name reverse sameCharacters: accum reverse)].	(prefix isEmpty and: [suffix isEmpty]) ifTrue: [^''].	^'(' , prefix , '...' , suffix , ') '</body><body package="Store-Code Comparison" selector="summaryPanel">summaryPanel	^self children first</body><body package="Store-Code Comparison" selector="swapSides">swapSides	comparison invert.	self populateDetailRows.	self filterChanged.	self topComponent ifNotNil: [:window | window label: self summaryLabel]</body><body package="Store-Code Comparison" selector="toggleExpansion">toggleExpansion	| start steps fastEnough limit |	start := Time microsecondClock.	self expansionChangeBeginning.	steps := expandedFraction isZero				ifTrue: [#(0.5 0.75 0.875 0.9125 1)]				ifFalse: [#(0.5 0.25 0.125 0.0625 0)].	limit := 50 milliseconds.	fastEnough := (Time microsecondClock - start) microseconds &lt; limit.	steps do: 			[:each |			(fastEnough or: [each isInteger])				ifTrue: 					[self changeExpandedFractionTo: each.					fastEnough := (Time microsecondClock - start) microseconds &lt; limit]].	self expansionChangeFinished</body><body package="Store-Code Comparison" selector="toggleFiltered:">toggleFiltered: aCodeComponentCollection	(self areComponentsFiltered: aCodeComponentCollection)		ifTrue: 			[aCodeComponentCollection				do: [:each | filteredComponents remove: each ifAbsent: []]]		ifFalse: [filteredComponents addAll: aCodeComponentCollection].	self filterChanged</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="browseMenuTarget">browseMenuTarget	menuTarget isImageModel		ifTrue: 			[(Refactory.Browser.BrowserEnvironment new				forCodeComponents: (Array with: menuTarget)) openEditor]		ifFalse: 			[(Store.Glorp.StoreForGlorpBrowserEnvironment on: menuTarget) openEditor]</body><body package="Store-Code Comparison" selector="fileoutChangesToGetToMenuTarget">fileoutChangesToGetToMenuTarget	| dialog targetFile session comparitor fileManager |	dialog := SaveFileDialog new.	dialog		addFileFilter: 'Smalltalk source (*.st)' pattern: '*.st';		fileCondition: #new;		defaultFilename: (Filename					filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st'							expandMacrosWith: menuTarget name))						asFilename.	(targetFile := dialog select) ifNil: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.		[(Store.FilingOut for: menuTarget) started.	comparitor := Store.PackageComparitor				differencesWithPropertiesBetween: (self menuTargetCompliment						asStoreComparisonObjectIn: session)				and: (menuTarget asStoreComparisonObjectIn: session).	fileManager := SourceCodeStream write: targetFile encoding: #Source.		[fileManager timeStamp.	fileManager sourceFormatter attributeFor: #package		compute: [:ignore | menuTarget name].	fileManager sourceFormatter attributeForMethods: #package		compute: [:ignore :igmore | menuTarget name].	comparitor fileOutMainToOtherDifferencesOn: fileManager]			ensure: [fileManager close].	(Store.FilingOut for: menuTarget) finished]			withStoreFeedbackOn: self topComponent</body><body package="Store-Code Comparison" selector="menu">menu		| menu |	menu := Menu new.	menu		augmentFrom: self class		to: self class		menuName: #menu		for: self.	^menu</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>displaying</category><body package="Store-Code Comparison" selector="displayOn:">displayOn: aGC	| myBox buttonBox buttonHalf oldPaint |self children isEmpty ifTrue: [^super displayOn: aGC].	myBox := self bounds.	buttonBox := self disclosureButton frame.	buttonHalf := buttonBox center y.	oldPaint := aGC paint.	aGC		paint: (ColorValue red: 0.85 green: 0.85 blue: 0.9);		displayRectangle: (myBox topLeft corner: myBox right @ buttonHalf).	aGC paint: oldPaint.	super displayOn: aGC.	aGC		paint: ColorValue black;		displayRectangularBorder: (buttonBox topLeft					corner: buttonBox bottomRight - 1);		displayLineFrom: buttonBox leftCenter to: myBox left @ buttonHalf;		displayLineFrom: buttonBox rightCenter to: myBox right @ buttonHalf</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>view construction</category><body package="Store-Code Comparison" selector="addDetailsLeft:right:">addDetailsLeft: aCodeComponent right: bCodeComponent	| newRow label |	newRow := Panel new.	newRow add: (self				filterToggleFor: (Array with: aCodeComponent with: bCodeComponent)).	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: aCodeComponent);		add: aCodeComponent toolListText.	label propertyAt: #codeComponent put: aCodeComponent.	newRow add: label.	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: bCodeComponent);		add: bCodeComponent toolListText.	label propertyAt: #codeComponent put: bCodeComponent.	newRow add: label.	self layoutDetailsRow: newRow.	self detailsPanel add: newRow</body><body package="Store-Code Comparison" selector="addDetailsPanel">addDetailsPanel	| details scrolled |	details := Panel new.	details beFullColumn.	scrolled := (BorderDecorator on: details)				useVerticalScrollBar;				noBorder.	self add: scrolled.	self populateDetailRows</body><body package="Store-Code Comparison" selector="addDetailsSolitaryLeft:">addDetailsSolitaryLeft: aCodeComponent	| newRow label |	newRow := Panel new.	newRow add: (self filterToggleFor: (Array with: aCodeComponent)).	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: aCodeComponent);		add: aCodeComponent toolListText.	label propertyAt: #codeComponent put: aCodeComponent.	newRow add: label.	newRow add: self notPresentLabel.	self layoutDetailsRow: newRow.	self detailsPanel add: newRow</body><body package="Store-Code Comparison" selector="addDetailsSolitaryRight:">addDetailsSolitaryRight: aCodeComponent	| newRow label |	newRow := Panel new.	newRow add: (self filterToggleFor: (Array with: aCodeComponent)).	newRow add: self notPresentLabel.	label := Panel new beRow: 0.5 gap: 5.	label		add: (self componentIcon: aCodeComponent);		add: aCodeComponent toolListText.	label propertyAt: #codeComponent put: aCodeComponent.	newRow add: label.	self layoutDetailsRow: newRow.	self detailsPanel add: newRow</body><body package="Store-Code Comparison" selector="addDisclosureButton">addDisclosureButton	| disclosure |	(self isSimple or: [self isEmpty])		ifTrue: [disclosure := PixelSpace extent: Point zero]		ifFalse: 			[disclosure := ClickableGraphic new.			disclosure idleGraphic: (self isExpanded						ifTrue: [self expandedIndicator]						ifFalse: [self collapsedIndicator]).			disclosure				tooltip: #ComparisonHeaderDisclosureButtonTooltip						&gt;&gt; 'Toggle between showing all changed components or a one line summary view.'							&lt;&lt; #IDE.			disclosure when: Clicked send: #disclosureClicked to: self].	self add: disclosure</body><body package="Store-Code Comparison" selector="addSummaryPanel">addSummaryPanel	| summary |	summary := Panel new beColumn: 0.5.	summary add: self summaryLabel.	self add: summary</body><body package="Store-Code Comparison" selector="addSwapSidesButton">addSwapSidesButton	| button |	button := ClickableGraphic new.	button		idleGraphic: (VisualBlock block: 						[:gc :box |						gc							paint: SymbolicPaint inactiveBackground;							displayRectangle: box;							paint: SymbolicPaint inactiveForeground;							displayRectangularBorder: (box origin corner: box corner - 1);							display: ComparisonIcons swapSides								at: box center - ComparisonIcons swapSides extent half]);		mouseOverGraphic: (VisualBlock block: 						[:gc :box |						gc							paint: SymbolicPaint buttonBackground;							displayRectangle: box;							paint: SymbolicPaint buttonForeground;							displayRectangularBorder: (box origin corner: box corner - 1);							display: ComparisonIcons swapSides								at: box center - ComparisonIcons swapSides extent half]).	button		tooltip: #ComparisonHeaderSwapButtonTooltip				&gt;&gt; 'Toggle direction of the compare (switch left with right).' &lt;&lt; #IDE.	button when: Clicked send: #swapSides to: self.	self add: button</body><body package="Store-Code Comparison" selector="componentIcon:">componentIcon: aCodeComponent	^aCodeComponent isImageModel		ifTrue: [aCodeComponent toolListIcon]		ifFalse: 			[aCodeComponent isBundle				ifTrue: [BehaviorIcons BundleDisconnected]				ifFalse: [BehaviorIcons PackageDisconnected]]</body><body package="Store-Code Comparison" selector="detailsDecorator">detailsDecorator	^self children at: 2</body><body package="Store-Code Comparison" selector="detailsPanel">detailsPanel	^self detailsDecorator component</body><body package="Store-Code Comparison" selector="disclosureButton">disclosureButton	^self children last</body><body package="Store-Code Comparison" selector="filterToggleFor:">filterToggleFor: aCodeComponentCollection	| clicker |	clicker := Refactory.Browser.ClickableGraphic new.	clicker		idleGraphic: (VisualBlock block: 					[:gc :box |					| graphic |					graphic := (self areComponentsFiltered: aCodeComponentCollection)								ifTrue: [ComparisonIcons hidePackage]								ifFalse: [ComparisonIcons seePackage].					graphic displayOn: gc at: box center - graphic extent half]				extent: ComparisonIcons hidePackage extent).	clicker		mouseOverGraphic: (VisualBlock block: 					[:gc :box |					| graphic |					graphic := (self areComponentsFiltered: aCodeComponentCollection)								ifTrue: [ComparisonIcons hidePackageActive]								ifFalse: [ComparisonIcons seePackageActive].					graphic displayOn: gc at: box center - graphic extent half]				extent: ComparisonIcons hidePackageActive extent).	clicker when: Refactory.Browser.Clicked		do: 			[InputState default shiftDown				ifTrue: 					[self selectOnly: aCodeComponentCollection.					self invalidate]				ifFalse: 					[self toggleFiltered: aCodeComponentCollection.					clicker invalidate]].	clicker tooltip: #ComparisonHeaderToggleTooltip &lt;&lt; #IDE				&gt;&gt; 'Toggles whether changes from this package are shown below.&lt;shift-click&gt; Makes this row the sole selection.'.	^clicker</body><body package="Store-Code Comparison" selector="layoutDetailsRow:">layoutDetailsRow: aRowPanel	"Should only be called after all 3 of its children are set."	| sumHeight |	aRowPanel layoutAlgorithm: 			[:rectangle :parts |			| boxes |			boxes := parts						collect: [:each | rectangle origin extent: each preferredExtent].			sumHeight := boxes inject: 0 into: [:max :each | max max: each height].			boxes				keysAndValuesDo: [:index :each | each moveBy: 0 @ (sumHeight - each height) half].			(boxes at: 2) moveTo: (boxes first right + 5) @ (boxes at: 2) top.			(boxes at: 3) moveTo: (rectangle center x + 13) @ (boxes at: 3) top.			boxes]</body><body package="Store-Code Comparison" selector="newDetailsRow">newDetailsRow	| row |	row := Panel new.	row layoutAlgorithm: 			[:rectangle :parts |			| boxes lastRight |			boxes := parts						collect: [:each | rectangle origin extent: each preferredExtent].			lastRight := rectangle left.			boxes keysAndValuesDo: 					[:index :each |					each moveBy: (lastRight + 5) @ (rectangle height - each height) half.					lastRight := each right].			boxes last right: rectangle right.			boxes].	^row</body><body package="Store-Code Comparison" selector="notPresentLabel">notPresentLabel	^Label with: ((#NotPresent &gt;&gt; 'Not Present' &lt;&lt; #IDE) asText				emphasizeAllWith: (Array with: #italic						with: #color -&gt; SymbolicPaint inactiveForeground))</body><body package="Store-Code Comparison" selector="populate">populate	self releaseAllComponents.	self updateFramesAfter: 			[self addSummaryPanel.			self addDetailsPanel.			self addSwapSidesButton.			self addDisclosureButton]</body><body package="Store-Code Comparison" selector="populateDetailRows">populateDetailRows	| rightStack leftStack |	self detailsPanel releaseAllComponents.	leftStack := OrderedCollection withAll: self leftComponents.	rightStack := OrderedCollection withAll: self rightComponents.	[rightStack isEmpty and: [leftStack isEmpty]] whileFalse: 			[rightStack isEmpty				ifTrue: [self addDetailsSolitaryLeft: leftStack removeFirst]				ifFalse: 					[leftStack isEmpty						ifTrue: [self addDetailsSolitaryRight: rightStack removeFirst]						ifFalse: 							[(self compareCodeComponent: rightStack first equalTo: leftStack first)								ifTrue: 									[self addDetailsLeft: leftStack removeFirst right: rightStack removeFirst]								ifFalse: 									[(self compareCodeComponent: rightStack first lessThan: leftStack first)										ifTrue: [self addDetailsSolitaryRight: rightStack removeFirst]										ifFalse: [self addDetailsSolitaryLeft: leftStack removeFirst]]]]]</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>testing</category><body package="Store-Code Comparison" selector="areComponentsFiltered:">areComponentsFiltered: aCodeComponentCollection	^aCodeComponentCollection		allSatisfy: [:eachCodeComponent | filteredComponents includes: eachCodeComponent]</body><body package="Store-Code Comparison" selector="isEmpty">isEmpty	^self leftComponents isEmpty and: [self rightComponents isEmpty]</body><body package="Store-Code Comparison" selector="isExpanded">isExpanded		^expandedFraction = 1</body><body package="Store-Code Comparison" selector="isSimple">isSimple	^self leftComponents size = 1 and: 			[self rightComponents size = 1 and: 					[self leftComponents any name = self rightComponents any name						and: [self leftComponents any isBundle = self rightComponents any isBundle]]]</body><body package="Store-Code Comparison" selector="menuTargetIsLeftSide">menuTargetIsLeftSide	^comparison leftCodeComponents includes: menuTarget</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>bounds accessing</category><body package="Store-Code Comparison" selector="bounds:">bounds: aRectangle	super bounds: aRectangle.	self adjustScrollBars</body><body package="Store-Code Comparison" selector="preferredHeight">preferredHeight	"Make sure we leave enough room in the color backed section to show a help icon"	| backedHeight borderHeight remainingDisclosureHeight |	backedHeight := self summaryPanel preferredHeight * (1 - expandedFraction)				+ (self detailsPanel preferredHeight * expandedFraction)					+ self disclosureButton preferredHeight half max: GeneralIcons help height.	borderHeight := 1.	remainingDisclosureHeight := self disclosureButton preferredHeight half.	^backedHeight + borderHeight + remainingDisclosureHeight</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="leftComponents">leftComponents	^comparison leftCodeComponents</body><body package="Store-Code Comparison" selector="rightComponents">rightComponents	^comparison rightCodeComponents</body><body package="Store-Code Comparison" selector="summaryLabel">summaryLabel	^self isEmpty		ifTrue: [(#NoChanges &lt;&lt; #IDE &gt;&gt; 'No Changes') asText]		ifFalse: 			[self isSimple				ifTrue: 					[#ComparingSingleCodeComponentHeader &lt;&lt; #IDE &gt;&gt; 'Changes from &lt;1s&gt; to &lt;2s&gt;'						expandMacrosWith: self leftComponents any toolListText						with: self rightComponents any toolListText]				ifFalse: 					[#ComparingCodeComponentsHeader &lt;&lt; #IDE						&gt;&gt; 'Changes from &lt;1p&gt; components &lt;2s&gt; to &lt;3p&gt; other components &lt;4s&gt;'							expandMacrosWithArguments: (Array									with: self leftComponents size									with: (self similiarStringFrom: self leftComponents)									with: self rightComponents size									with: (self similiarStringFrom: self rightComponents))]]</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertiesTool</class-id> <category>menu accessing</category><body package="StoreForGlorpBrowserUI" selector="menuAugmentationRoot">menuAugmentationRoot	"Accept nothing but locally defined menu items."	^self class</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>interface opening</category><body package="Store-UI" selector="preBuildWith:">preBuildWith: aBuilder 	"Get the blessing names."	aBuilder aspectAt: #blessingLevelMenu put: (Policies blessingPolicy blessingLevelsMenuForPundle: self pundle)</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>aspects</category><body package="Store-UI" selector="addComment:">addComment: aString	self text value: self defaultComment, self text value.	(aString isNil or: [aString isEmpty]) ifTrue: [^self].	self text value: aString, '', self text value.</body><body package="Store-UI" selector="blessingLevel">blessingLevel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLevel isNil		ifTrue:			[blessingLevel := 0 asValue]		ifFalse:			[blessingLevel]</body><body package="Store-UI" selector="defaultComment">defaultComment	^(#VersionCreatedBy1sOn2pAt3pN &lt;&lt; #store &gt;&gt; 'Version created by: &lt;1s&gt; on: &lt;2p&gt; at: &lt;3p&gt;&lt;n&gt;') 		expandMacrosWith: self userName		with: Date today		with: Time now</body><body package="Store-UI" selector="text">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	text := '' asValue.</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>accessing</category><body package="Store-UI" selector="pundle">pundle	^pundle</body><body package="Store-UI" selector="pundle:">pundle: aPundle	pundle := aPundle</body><body package="Store-UI" selector="userName">userName	^userName isNil 		ifTrue: [(#Unknown &lt;&lt; #store &gt;&gt; 'Unknown') asString]		ifFalse: [userName]</body><body package="Store-UI" selector="userName:">userName: aString		userName := aString</body></methods><methods><class-id>Store.CommentPrompt class</class-id> <category>instance creation</category><body package="Store-UI" selector="forPundle:">forPundle: aPundle	^self new pundle: aPundle</body></methods><methods><class-id>Store.NoCommonAncestor class</class-id> <category>testing</category><body package="Store-Merge Management" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>accessing</category><body package="Store-Merge Management" selector="addChildren:">addChildren: aCollectionOfVersionNodes		children addAll: aCollectionOfVersionNodes.	aCollectionOfVersionNodes do: [:each | each parent: self]</body><body package="Store-Merge Management" selector="children">children	^children</body><body package="Store-Merge Management" selector="children:">children: aCollection	children := aCollection</body><body package="Store-Merge Management" selector="isLeaf">isLeaf	^children isEmpty</body><body package="Store-Merge Management" selector="isRoot">isRoot	^parent isNil</body><body package="Store-Merge Management" selector="leaves">leaves	"Assuming that I'm the root of the tree answer all leaves."		| leaves |	children isEmpty ifTrue: [^OrderedSet with: self].	leaves := OrderedSet new.	children do: [:each | leaves addAll: each leaves].	^leaves</body><body package="Store-Merge Management" selector="level">level	^level</body><body package="Store-Merge Management" selector="maxLevel">maxLevel	"Assuming that I'm the root of the tree 	calculate the biggest level."	| maxLevel |	maxLevel := level.	children do: [:each | maxLevel := maxLevel max: each maxLevel].	^maxLevel</body><body package="Store-Merge Management" selector="nodesAtLevel:">nodesAtLevel: anInteger	"Assuming that I'm the root of the tree answer all my children that are at level aLevel."		| result |	level = anInteger ifTrue: [^OrderedSet with: self].	result := OrderedSet new.	children do: [:each | result addAll: (each nodesAtLevel: anInteger)].	^result</body><body package="Store-Merge Management" selector="package">package	^package</body><body package="Store-Merge Management" selector="package:">package: aStorePundle	package := aStorePundle</body><body package="Store-Merge Management" selector="parent">parent	^parent</body><body package="Store-Merge Management" selector="parent:">parent: aVersionNode	parent := aVersionNode</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>initialize release</category><body package="Store-Merge Management" selector="initialize">initialize	children := OrderedSet new.</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>private-calculations</category><body package="Store-Merge Management" selector="becomeParentFor:">becomeParentFor: aVersionNode	aVersionNode parent: self.	children add: aVersionNode.</body><body package="Store-Merge Management" selector="buildTowardsRoot:initial:">buildTowardsRoot: aRootVersionNode initial: aVersionNode	"Move towards the specified root. 	If I'm older then the root then process stops. 	If I'm part of another tree then reparent the root of the other tree off the 'initialNode'.	Answer either root or the node containing package older then the root.	If the common ancestor of me and aRoot cannot be found	raise an exception and then answer nil."		| node parentPundle |	(aRootVersionNode package youngerThan: self package) ifTrue: [^self].	parentPundle := self package tracePackage yourSelf.	node := parentPundle isNil		ifTrue:			["We cannot reach the root, Raise a signal."			NoCommonAncestor raiseRequestWith: (Array with: aVersionNode package with: aRootVersionNode package).			^nil]		ifFalse: [aRootVersionNode nodeContainingVersion: parentPundle primaryKey].	^node isNil		ifTrue:			[node := self class on: parentPundle.			node becomeParentFor: self.			node buildTowardsRoot: aRootVersionNode initial: aVersionNode]		ifFalse:			[node becomeParentFor: self.			aRootVersionNode]</body><body package="Store-Merge Management" selector="buildTree:">buildTree: aCollectionOfPundleVersions	"Given an initial package version find all integration-ready versions and build a tree which encompasses all 	integration-ready versions. Answer the root of the newly built tree."		| rootNode |	rootNode := self.	aCollectionOfPundleVersions		do:			[:eachVersion | 			(rootNode nodeContainingVersion: eachVersion primaryKey) isNil				ifTrue:					[| childNode parentNode resultNode |					childNode := self class on: eachVersion.					parentNode := rootNode.					[resultNode := childNode buildTowardsRoot: parentNode initial: self.					resultNode = parentNode or: [resultNode isNil]]						whileFalse:							[childNode := parentNode.							parentNode := resultNode].					resultNode notNil ifTrue: [rootNode := resultNode]]].	[rootNode compressPreserving: self] whileFalse.	rootNode setLevel: 0.	^rootNode</body><body package="Store-Merge Management" selector="compressPreserving:">compressPreserving: aVersionNode	"Remove all the intermediate nodes. Children are moved up to parent.	The result is a tree with each leaf having its own branch starting at the root.	Do not remove aNode."		self isLeaf ifTrue: [^true].	^(self isRoot not and: [self package ~= aVersionNode package])		ifTrue:			[parent remove: self.			parent addChildren: children.			children do: [:eachVersionNode | eachVersionNode compressPreserving: aVersionNode].			false]		ifFalse: [children shallowCopy inject: true into: [:sum :each | sum &amp; (each compressPreserving: aVersionNode)]]</body><body package="Store-Merge Management" selector="remove:">remove: aVersionNode	"Remove aNode form my children."		children remove: aVersionNode</body><body package="Store-Merge Management" selector="setLevel:">setLevel: anInteger		level := anInteger.	children do: [:each | each setLevel: anInteger + 1]</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>testing</category><body package="Store-Merge Management" selector="nodeContainingVersion:">nodeContainingVersion: anInteger	"Starting from the receiver as a tree root, answer a node which contains a package with	the specified key."		| result |	self package primaryKey = anInteger ifTrue: [^self].	self children do: [:each | (result := each nodeContainingVersion: anInteger) notNil ifTrue: [^result]].	^nil</body></methods><methods><class-id>Store.Glorp.VersionNode</class-id> <category>printing</category><body package="Store-Merge Management" selector="basicNodePrintOn:">basicNodePrintOn: aStream		aStream nextPutAll: package version.	children isEmpty ifTrue: [^self].	aStream space.	aStream nextPut: $(.	children do: [:each | each printChildrenOn: aStream first: true] separatedBy: [aStream nextPut: $-].	aStream nextPut: $)</body><body package="Store-Merge Management" selector="printChildrenOn:first:">printChildrenOn: aStream first: aBoolean		aBoolean ifFalse: [aStream nextPut: $-].	self basicNodePrintOn: aStream</body><body package="Store-Merge Management" selector="printOn:">printOn: aStream		aStream nextPut: Character space.	parent isNil ifFalse: [self printParentOn: aStream last: true].	self basicNodePrintOn: aStream</body><body package="Store-Merge Management" selector="printParentOn:last:">printParentOn: aStream last: aBoolean		parent isNil ifFalse: [parent printParentOn: aStream last: false].	aBoolean ifTrue: [^self].	aStream nextPutAll: package version.	aStream nextPut: $-</body></methods><methods><class-id>Store.Glorp.VersionNode class</class-id> <category>instance creation</category><body package="Store-Merge Management" selector="on:">on: aPackageVersion 	^(self new) initialize; package: aPackageVersion; yourself</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken 	"Answer a collection of related elements."	Transcript		cr;		show: ((#PackageElementToken1sElement2p &lt;&lt; #store &gt;&gt; 'PackageElement token: &lt;1s&gt; element: &lt;2p&gt;') 					expandMacrosWith: relToken					with: element).	Transcript		cr;		show: (element relatedBy: relToken) printString.	^element relatedBy: relToken</body><body package="Store-UI-Graphs" selector="stringKey:">stringKey: hints 	^element class == StoreUserGroup 		ifTrue: 			[(hints includes: #sort) 				ifFalse: [(#_1sOwns &lt;&lt; #store &gt;&gt; '&lt;1s&gt; owns') expandMacrosWith: element userName]				ifTrue: [element]]		ifFalse: [element stringKey: hints]</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="itemString">itemString	^element</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>execute</category><body package="Store-Base" selector="executeAll:">executeAll: aStream" Execute SQL statements from the stream. Statements should be separated by two cr's" 	| string  pattern |	DbRegistry isOnline ifFalse: [ DbRegistry reconnect: false].	pattern := '\\'  withCRs. 	[aStream peekFor: Character cr]		whileTrue: [].	self safelyExecuteBlock: 				[[ aStream atEnd ]					whileFalse:						[ string := aStream upToAll: pattern. 						DbRegistry storeBroker processSQL: string. 						aStream  atEnd ifFalse: [ aStream skip: 2] ].				DbRegistry goOffLine]		note: (#ExecuteAll &lt;&lt; #store &gt;&gt; 'Execute All: ') asString</body><body package="Store-Base" selector="executeSelection:">executeSelection: aString	self safelyExecuteBlock: 			[ | onlineState |				aString isEmpty not 				ifTrue:					[onlineState := DbRegistry isOnline.					onlineState ifFalse: [ DbRegistry reconnect: false ].					DbRegistry storeBroker processSQL: aString ].					onlineState ifFalse: [ DbRegistry goOffLine ]]		note: (#ExecuteSelection &lt;&lt; #store &gt;&gt; 'Execute Selection: ') asString</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>actions</category><body package="Store-Base" selector="installInfo"> installInfo	StoreDescriptorSystem installUserManagementPolicies</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>accessing</category><body package="Store-Base" selector="logFileName">logFileName	logFileName isNil		ifTrue: [ logFileName  := 'StoreLog.txt'].	^ logFileName</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>debugging</category><body package="Store-Base" selector="log:level:">log: aStringOrBlock level: aLevel	| stream aMsg |	self 		debug:			[(stream := self debugStream) == nil ifTrue: [^self].			(aStringOrBlock isKindOf: BlockClosure)				ifTrue: [ aMsg := aStringOrBlock value]				ifFalse: [ aMsg := aStringOrBlock ].			stream cr; nextPutAll: aMsg; cr; flush]		level: aLevel</body><body package="Store-Base" selector="traceOff">traceOff	self trace: false.</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>private</category><body package="Store-Base" selector="safelyExecuteBlock:note:">safelyExecuteBlock: aBlock note: aNote 		[Notice 		show: #ExecutingSQLStatements &lt;&lt; #store &gt;&gt; 'Executing SQL statements..'		while: 			[Cursor database showWhile: 					[aBlock value.					Dialog 						warn: #SQLExecutedSuccessfully &lt;&lt; #store &gt;&gt; 'SQL executed successfully!']]] 			on: Error			do: [:ex | DbRegistry storeBroker processPublishException: ex note: aNote]</body></methods><methods><class-id>Tools.PropertyComparisonView</class-id> <category>row population</category><body package="Store-Code Comparison" selector="computeDetailRows">computeDetailRows	^Array with: (SideBySideTextComparisonView new				leftText: leftProperty value printString				rightText: rightProperty value printString)</body><body package="Store-Code Comparison" selector="populateHeader">populateHeader	| header |	super populateHeader.	header := self header.	header add: ComparisonIcons modify.	header add: (Label with: leftProperty key asText allBold)</body></methods><methods><class-id>Tools.PropertyComparisonView</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="leftProperty:rightProperty:">leftProperty: aLeftProperty rightProperty: aRightProperty	leftProperty := aLeftProperty.	rightProperty := aRightProperty.	self populate</body></methods><methods><class-id>Tools.PropertyComparisonView</class-id> <category>private-expansion memory</category><body package="Store-Code Comparison" selector="expansionMemoryKey">expansionMemoryKey	^Array with: #compareCodeComponentProperty with: leftProperty key</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>event driven</category><body package="Store-UI" selector="getEventHandler">getEventHandler		^self</body><body package="Store-UI" selector="handleEvent:">handleEvent: anEvent	self eventReactions reactTo: anEvent</body><body package="Store-UI" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	^(super handlerForMouseEvent: aMouseEvent)		ifNil: 			[(aMouseEvent isMouseWheelEvent not				and: [self containsMouseEvent: aMouseEvent]) ifTrue: [self] ifFalse: [nil]]</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>private</category><body package="Store-UI" selector="computeFrameFor:in:">computeFrameFor: aChild in: rect	| left right bottom top |	top := (aChild propertyAt: #row) * self lineGrid.	bottom := top + self lineGrid.	right := (aChild propertyAt: #column) * rect width half + rect left.	left := right - rect width half				+ ((aChild propertyAt: #indent) * self indentGrid).	^(left @ top corner: right @ bottom) rounded insetBy: 3 @ 0</body><body package="Store-UI" selector="highlightRectangle">highlightRectangle	targetView ifNil: [^nil].	^(targetView frame origin leftBy: 3) corner: targetView frame corner</body><body package="Store-UI" selector="iconFor:">iconFor: aCodeComponent	^aCodeComponent isImageModel		ifTrue: [aCodeComponent toolListIcon]		ifFalse: 			[aCodeComponent isBundle				ifTrue: [BehaviorIcons BundleDisconnected]				ifFalse: [BehaviorIcons PackageDisconnected]]</body><body package="Store-UI" selector="indentGrid">indentGrid	^15</body><body package="Store-UI" selector="isPressed:">isPressed: aBoolean	aBoolean == isPressed ifTrue: [^self].	isPressed := aBoolean.	self highlightRectangle ifNotNil: [:rect | self invalidateRectangle: rect]</body><body package="Store-UI" selector="left:right:enumerateChildren:">left: aLeftComponent right: aRightComponent enumerateChildren: a2ArgBlock	| diff |	diff := SequenceableCollectionDifferences new				comparisonFunction: [:a :b | a name = b name and: [a isBundle = b isBundle]].	(diff differencesFrom: aLeftComponent containedItems		to: aRightComponent containedItems) do: 				[:eachDifference |				eachDifference isInsert					ifTrue: [eachDifference do: [:each | a2ArgBlock value: nil value: each]].				eachDifference isMatch					ifTrue: 						[eachDifference do: 								[:eachLeft |								a2ArgBlock value: eachLeft									value: (self partnerFor: eachLeft in: aRightComponent)]].				eachDifference isDelete					ifTrue: [eachDifference do: [:each | a2ArgBlock value: each value: nil]]]</body><body package="Store-UI" selector="lineGrid">lineGrid	^20</body><body package="Store-UI" selector="minorDeviationOfColor:">minorDeviationOfColor: aPaint	| baseColor |	baseColor := aPaint asColorValue.	^baseColor brightness = 1		ifTrue: 			[ColorValue				hue: baseColor hue				saturation: baseColor saturation				brightness: 0.97]		ifFalse: 			[ColorValue				hue: baseColor hue				saturation: baseColor saturation				brightness: (baseColor brightness + 0.03 min: 1)]</body><body package="Store-UI" selector="partnerFor:in:">partnerFor: aChildComponent in: anOppositeContainer	^aChildComponent		ifNotNil: 			[anOppositeContainer containedItems detect: 					[:eachChild |					eachChild name = aChildComponent name						and: [aChildComponent isBundle = eachChild isBundle]]				ifNone: [nil]]</body><body package="Store-UI" selector="targetView:">targetView: aChild	| rectangles |	targetView == aChild ifTrue: [^self].	rectangles := OrderedCollection new.	self highlightRectangle ifNotNil: [:rect | rectangles add: rect].	targetView := aChild.	self highlightRectangle ifNotNil: [:rect | rectangles add: rect].	rectangles		do: [:each | self invalidateRectangle: (each expandedBy: 4 @ 0)]</body><body package="Store-UI" selector="versionString:">versionString: aCodeComponent	^aCodeComponent isImageModel		ifTrue: [(aCodeComponent traceVersionString allButLast: 1) allButFirst: 1]		ifFalse: [aCodeComponent simpleVersionString]</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>view construction</category><body package="Store-UI" selector="addLeft:partner:right:partner:indent:row:">addLeft: aLeftComponent partner: aLeftPartner right: aRightComponent partner: aRightPartner indent: anIndent row: aRowIndex	"The partner arguments are the corresponding entity (same version or not) from the same container, it may not be on the same row as the component, if reording has taken place. This method is the workhorse of the tree traversal, if one side or another is nil, then there is no corresponding part to traverse in parallel, so we branch off into solo mode. This method returns the number of rows it added. If both are non nil, then we add views on both sides, and then use special enumeration method."	| rowsAdded |	aLeftComponent		ifNil: 			[^self				addSolo: aRightComponent				partner: aRightPartner				column: 2				indent: anIndent				row: aRowIndex].	aRightComponent		ifNil: 			[^self				addSolo: aLeftComponent				partner: aLeftPartner				column: 1				indent: anIndent				row: aRowIndex].	self		addView: aLeftComponent		partner: aLeftPartner		column: 1		indent: anIndent		row: aRowIndex.	self		addView: aRightComponent		partner: aRightPartner		column: 2		indent: anIndent		row: aRowIndex.	rowsAdded := 1.	self		left: aLeftComponent		right: aRightComponent		enumerateChildren: 			[:leftChild :rightChild |			rowsAdded := rowsAdded + (self								addLeft: leftChild								partner: (self partnerFor: leftChild in: aRightComponent)								right: rightChild								partner: (self partnerFor: rightChild in: aLeftComponent)								indent: anIndent + 1								row: aRowIndex + rowsAdded)].	^rowsAdded</body><body package="Store-UI" selector="addSolo:partner:column:indent:row:">addSolo: aCodeComponent partner: anOppositePartner column: aColumnIndex indent: anIndent row: aRowIndex	"We're in a mode where we're adding solely to one column for aCodeComponent and all of its children."	| rowsAdded |	self		addView: aCodeComponent		partner: anOppositePartner		column: aColumnIndex		indent: anIndent		row: aRowIndex.	rowsAdded := 1.	aCodeComponent containedItems do: 			[:child |			rowsAdded := rowsAdded + (self								addSolo: child								partner: nil								column: aColumnIndex								indent: anIndent + 1								row: aRowIndex + rowsAdded)].	^rowsAdded</body><body package="Store-UI" selector="addView:partner:column:indent:row:">addView: aCodeComponent partner: anOppositeComponent column: aColumnIndex indent: anIndent row: aRowIndex	"This is where we put the view together for the given parameters."	| newView nameText versionText |	newView := Panel new beRow: 0.5 gap: 4.	nameText := aCodeComponent name asText.	versionText := (self versionString: aCodeComponent) asText.	anOppositeComponent		ifNil: 			[nameText := nameText emphasizeAllWith: (aColumnIndex = 1								ifTrue: [TextFragment emphasisForDelete]								ifFalse: [TextFragment emphasisForInsert])]		ifNotNil: 			[(self isSame: anOppositeComponent versionAs: aCodeComponent)				ifFalse: 					[versionText := versionText emphasizeAllWith: (aColumnIndex = 1										ifTrue: [TextFragment emphasisForDelete]										ifFalse: [TextFragment emphasisForInsert])]].	newView		add: (self iconFor: aCodeComponent);		add: nameText;		add: '(' asText , versionText , ')' asText.	newView		propertyAt: #codeComponent put: aCodeComponent;		propertyAt: #codeComponentPeer put: anOppositeComponent;		propertyAt: #column put: aColumnIndex;		propertyAt: #row put: aRowIndex;		propertyAt: #indent put: anIndent.	self add: newView</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>menu</category><body package="Store-UI" selector="browseMenuTarget">browseMenuTarget	self selectedCodeComponent isImageModel		ifTrue: 			[(Refactory.Browser.BrowserEnvironment new				forCodeComponents: (Array with: self selectedCodeComponent)) openEditor]		ifFalse: 			[(Store.Glorp.StoreForGlorpBrowserEnvironment				on: self selectedCodeComponent) openEditor]</body><body package="Store-UI" selector="fileoutChangesToGetToMenuTarget">fileoutChangesToGetToMenuTarget	| dialog targetFile session comparitor fileManager menuTarget |	menuTarget := self selectedCodeComponent.	dialog := SaveFileDialog new.	dialog		addFileFilter: 'Smalltalk source (*.st)' pattern: '*.st';		fileCondition: #new;		defaultFilename: (Filename					filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st'							expandMacrosWith: menuTarget name))						asFilename.	(targetFile := dialog select) ifNil: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.		[(Store.FilingOut for: menuTarget) started.	comparitor := Store.PackageComparitor				differencesWithPropertiesBetween: (self selectedCodeComponentPeer						asStoreComparisonObjectIn: session)				and: (menuTarget asStoreComparisonObjectIn: session).	fileManager := SourceCodeStream write: targetFile encoding: #Source.		[fileManager timeStamp.	fileManager sourceFormatter attributeFor: #package		compute: [:ignore | menuTarget name].	fileManager sourceFormatter attributeForMethods: #package		compute: [:ignore :igmore | menuTarget name].	comparitor fileOutMainToOtherDifferencesOn: fileManager]			ensure: [fileManager close].	(Store.FilingOut for: menuTarget) finished]			withStoreFeedbackOn: self topComponent</body><body package="Store-UI" selector="menu">menu		| menu |	menu := Menu new.	menu		augmentFrom: self class		to: self class		menuName: #menu		for: self.	^menu</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>displaying</category><body package="Store-UI" selector="displayBackgroundStripeOn:">displayBackgroundStripeOn: aGC	| box clip oldPaint strip |	box := self bounds.	clip := aGC clippingBounds.	oldPaint := aGC paint.	aGC		paint: (self minorDeviationOfColor: SymbolicPaint background asColorValue).	0 to: self children last frame top		by: self lineGrid * 2		do: 			[:y |			strip := box left @ y extent: box width @ self lineGrid.			(strip intersects: clip) ifTrue: [aGC displayRectangle: strip]].	aGC paint: oldPaint</body><body package="Store-UI" selector="displayOn:">displayOn: aGC	self displayBackgroundStripeOn: aGC.	self displayTargetOn: aGC.	super displayOn: aGC</body><body package="Store-UI" selector="displayTargetOn:">displayTargetOn: aGC	| oldPaint highlightRect |	targetView ifNil: [^self].	oldPaint := aGC paint.	highlightRect := self highlightRectangle.	isPressed		ifTrue: 			[aGC				paint: SymbolicPaint selectionBackground;				displayRectangle: highlightRect].	aGC		paint: (SymbolicPaint background asColorValue					blendWith: SymbolicPaint selectionForeground asColorValue					weight: 0.2);		displayRectangularBorder: (highlightRect origin					corner: highlightRect corner - 1).	aGC paint: oldPaint</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>public</category><body package="Store-UI" selector="left:right:">left: aLeftBundle right: aRightBundle	"Shut down updating while we're building, otherwise we may add views that don't have enough properties for our layout algorithm."	isInUpdate := true.	self		addLeft: aLeftBundle		partner: aRightBundle		right: aRightBundle		partner: aLeftBundle		indent: 0		row: 0.	isInUpdate := false.	self relayout</body><body package="Store-UI" selector="openScrolledWindow">openScrolledWindow	"Open a window around me with a vertical scroll bar."	| scroller |	scroller := BorderDecorator on: self.	scroller		noHorizontalScrollBar;		noBorder;		useVerticalScrollBar.	(ScheduledWindow new)		useDisplayBuffer;		label: #CompareBundleStructure &gt;&gt; 'Compare Bundle Structure' &lt;&lt; #IDE;		component: scroller;		openWithExtent: 800 @ self preferredHeight</body><body package="Store-UI" selector="selectedCodeComponent">selectedCodeComponent	"Returns the current codeComponent that the menu was raised over."	^targetView ifNotNil: [targetView propertyAt: #codeComponent]</body><body package="Store-UI" selector="selectedCodeComponentPeer">selectedCodeComponentPeer	"Returns the otherside commpliment to the selectedCodeComponentPeer. It may be nil."	^targetView ifNotNil: [targetView propertyAt: #codeComponentPeer]</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	isPressed := false.	targetView := nil</body><body package="Store-UI" selector="initializeLayoutAlgorithm">initializeLayoutAlgorithm	self layoutAlgorithm: 			[:rect :views |			views collect: [:each | self computeFrameFor: each in: rect]]</body><body package="Store-UI" selector="scrollOffsetHolder:">scrollOffsetHolder: aScrollOffsetHolder	aScrollOffsetHolder grid: 1 @ self lineGrid</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>testing</category><body package="Store-UI" selector="isLeftSideSelection">isLeftSideSelection	^(targetView propertyAt: #column) = 1</body><body package="Store-UI" selector="isSame:versionAs:">isSame: aCodeComponent versionAs: anotherComponent	"Have to treat inImageModel's specially."	anotherComponent isImageModel		ifTrue: 			[^anotherComponent hasBeenModified not				and: [anotherComponent dbTrace = aCodeComponent primaryKey]].	aCodeComponent isImageModel		ifTrue: 			[^aCodeComponent hasBeenModified not				and: [aCodeComponent dbTrace = anotherComponent primaryKey]].	^aCodeComponent = anotherComponent</body><body package="Store-UI" selector="isSelectedPeerDifferent">isSelectedPeerDifferent	^(self selectedCodeComponent notNil		and: [self selectedCodeComponentPeer notNil]) and: 				[(self isSame: self selectedCodeComponent					versionAs: self selectedCodeComponentPeer) not]</body></methods><methods><class-id>Store.DownloadingFiles</class-id> <category>accessing</category><body package="Store-User Management" selector="actionText">actionText	^(#DowlindingFiles &lt;&lt; #store &gt;&gt; 'Downloading Files') asString</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>accessing</category><body package="Store-Database Model" selector="absoluteClassName">absoluteClassName	^self definition absoluteClassName</body><body package="Store-Code Comparison" selector="asBlueprint">asBlueprint	| definitionParts names myReference blueprint |	blueprint := ClassBlueprint of: self.	definitionParts := blueprint parseDefinition: self definition definition.	myReference := self fullName asQualifiedReference.	blueprint reference: myReference.	(definitionParts at: #superclass:)		ifNotNil: 			[:superclassReference |			blueprint				superclassReference: superclassReference asString asQualifiedReference						makeUnambiguous].	blueprint behaviorType: (definitionParts at: #indexedType:).	names := (definitionParts at: #instanceVariableNames:)				runsFailing: #isSeparator.	blueprint instanceVariables: names.	names := (definitionParts at: #classInstanceVariableNames:)				runsFailing: #isSeparator.	blueprint classInstanceVariables: names.	blueprint isPrivate: (definitionParts at: #private:).	blueprint importsString: (definitionParts at: #imports:).	blueprint		attributes: (definitionParts at: #attributes: ifAbsent: [Array new]).	self comment ifNotNil: [:string | blueprint comment: string].	^blueprint</body><body package="Store-Database Model" selector="comment">comment	^definition comment.</body><body package="Store-Database Model" selector="correspondingImageClass">correspondingImageClass	^self definition correspondingImageClass</body><body package="Store-Database Model" selector="definitionString">definitionString	^self definition definitionString.</body><body package="Store-Database Model" selector="environmentName">environmentName	^self definition environmentName.</body><body package="Store-Database Model" selector="environmentNameFromSmalltalk">environmentNameFromSmalltalk	^self definition environmentNameFromSmalltalk.</body><body package="Store-Database Model" selector="longName">longName	^self definition longName.</body><body package="Store-Database Model" selector="metaclass">metaclass	^metaclass</body><body package="Store-Database Model" selector="metaclass:">metaclass: aStoreClassDefinition	metaclass := aStoreClassDefinition</body><body package="Store-Database Model" selector="myClass">myClass	^self definition correspondingImageClass.</body><body package="Store-Database Model" selector="name">name	^self definition name.</body><body package="Store-Database Model" selector="superclass">superclass	^self superclassName.</body><body package="Store-Database Model" selector="superclassName">superclassName	^self definition superclassName.</body><body package="Store-Database Model" selector="timestamp">timestamp	^self definition timestamp.</body><body package="Store-Database Model" selector="versions">versions	| session classDefQuery classes uniqueKeys |	session := StoreLoginFactory currentStoreSession.	classDefQuery := Query		read: self class		where: [:each | each definition name = self name &amp; (each package name = self package name)].	classDefQuery alsoFetch: #definition.	classDefQuery alsoFetch: [:eachClass | eachClass definition definition].	classDefQuery orderBy: [:each | each definition timestamp descending].	classes := session execute: classDefQuery.	uniqueKeys := Set new.	^classes inject: OrderedCollection new into:		[:sum :each |		(uniqueKeys includes: each primaryKey) ifFalse: 			[uniqueKeys add: each primaryKey.			sum add: each].		sum]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>loading</category><body package="Store-Database Model" selector="loadSource">loadSource	| newClass |	Store.Policies packagePolicy 		forcePackage: (self package storeModel ifNil: [Registry nullPackage])		while: 			[newClass := [[[Object evaluatorClass evaluate: self definitionString notifying: nil logged: false]				on: VariableConfirmation				do: [:exception | exception resume: false]]					on: ClassBuilder buildFailureSignal					do:						[:exception | 						exception proceed]]							on: Error							do: 								[:exception | 								exception return: nil].			newClass ifNotNil: 				[(self comment notNil and: [self comment notEmpty]) ifTrue:					[newClass comment: self comment]]].	^newClass</body><body package="Store-Database Model" selector="loadSourceDirect">loadSourceDirect	^self loadSource</body><body package="StoreForGlorpVWUI" selector="loadSrcInto:">loadSrcInto: aPackageModel	Store.Policies packagePolicy 		forcePackage: aPackageModel		while: [self definition loadSource]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>testing</category><body package="Store-Database Model" selector="isClass">isClass	^true.</body><body package="Store-Database Model" selector="isForClass">isForClass	^true</body><body package="Store-Database Model" selector="isForClassOrExtension">isForClassOrExtension	^true</body><body package="Store-Database Model" selector="isMeta">isMeta	^false.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>compatibility</category><body package="Store-Database Model" selector="allInstVarNames">allInstVarNames	^self definition allInstVarNames.</body><body package="StoreForGlorpVWUI" selector="object">object	^self definition correspondingImageClass.</body><body package="StoreForGlorpVWUI" selector="removeFromPackage:">removeFromPackage: aPackageModel	Store.XMainChangeSet current		addRemoveClass: self absoluteClassName		package: aPackageModel</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>comparing</category><body package="Store-Database Model" selector="=">= aStoreObjectInPackage	aStoreObjectInPackage yourSelf isNil ifTrue: [^false].	aStoreObjectInPackage class == self class ifFalse: [		(self definition primaryKey notNil and: [self definition primaryKey = aStoreObjectInPackage primaryKey])			ifTrue: [^true].		^self definition = aStoreObjectInPackage asStoreClassDefinition].	^self package yourSelf = aStoreObjectInPackage package yourSelf and: [self definition reconcilesWith: aStoreObjectInPackage definition].</body><body package="StoreForGlorpVWUI" selector="comparesTo:">comparesTo: anObject	^self definition comparesTo: anObject definition.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>copying</category><body package="Store-Database Model" selector="postCopyIn:">postCopyIn: aDictionary	super postCopyIn: aDictionary.	metaclass := metaclass glorpCopyIn: aDictionary.</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>filing out</category><body package="Store-Database Model" selector="fileOutDifferencesBetween:on:">fileOutDifferencesBetween: aClassInPackage on: aSourceCodeStream	self definitionString = aClassInPackage definitionString ifFalse:		[aSourceCodeStream storeObjectDefinition: self].	self comment = aClassInPackage comment ifFalse:		[aSourceCodeStream comment: self value: self comment]</body><body package="Store-Database Model" selector="fileOutMethodsOn:">fileOutMethodsOn: aSourceFileManager	| methods |	methods := self package methodsForClass: self meta: false.	methods do: [:each | each fileOutSourceOn: aSourceFileManager].	methods := self package methodsForClass: self meta: true.	methods do: [:each | each fileOutSourceOn: aSourceFileManager]</body><body package="Store-Database Model" selector="fileOutObjectType">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#class</body><body package="Store-Database Model" selector="fileOutSourceOn:">fileOutSourceOn: aSourceFileManager	self fileOutDefinitionOn: aSourceFileManager.	aSourceFileManager comment: self value: self comment.	self fileOutMethodsOn: aSourceFileManager</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asCommentTag">asCommentTag	^Store.ClassCommentTag newClassName: self longName.</body><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	^self definition</body><body package="StoreForGlorpVWUI" selector="asTag">asTag	^self definition asTag isMeta: false.</body><body package="StoreForGlorpVWUI" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^aTag isClassCommentTag		ifTrue: [self definition comment]		ifFalse: [self definition definition]</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>atomic loading</category><body package="Glorp Atomic Compiling" selector="gatherAndAnalyzeInto:using:">gatherAndAnalyzeInto: aPackageInstall using: anAtomicAnalysisLoader	aPackageInstall gatherAndAnalyzeClass: self using: anAtomicAnalysisLoader</body><body package="Glorp Atomic Compiling" selector="shadowLoadDefinition">shadowLoadDefinition	"In the shadow world, I need to use the shadowLoadDefineClass:... version of this, not the #defineClass: version,	because the standard version calls link system too soon and also will create change objects too soon.	We support all old style class creation methods also: #subclass:... #variableByteSubclass:... and #variableSubclass:..	if there is something else, we just go with whatever there is"	| definitionString insertPoint |	definitionString := super shadowLoadDefinition.	insertPoint := definitionString indexOfSubCollection: 'defineClass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadD'].	insertPoint := definitionString indexOfSubCollection: 'subclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadS'].	insertPoint := definitionString indexOfSubCollection: 'variableByteSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	insertPoint := definitionString indexOfSubCollection: 'variableSubclass:' startingAt: 1.	insertPoint &gt; 0 ifTrue: [^definitionString copyReplaceFrom: insertPoint to: insertPoint with: 'shadowLoadV'].	^definitionString</body><body package="Glorp Atomic Compiling" selector="shadowedObjectClass">shadowedObjectClass	^ShadowedClassObject</body></methods><methods><class-id>Store.Glorp.StoreClassDefinitionInPackage</class-id> <category>printing</category><body package="Store-Database Model" selector="displayString">displayString	^self longNameFromSmalltalk</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>testing</category><body package="Store-Change Management" selector="belongsToClass">belongsToClass	^true</body><body package="Store-Change Management" selector="existsInImage">existsInImage	^self actualClass notNil</body><body package="Store-Change Management" selector="isClassCommentTag">isClassCommentTag	^true</body><body package="Store-Change Management" selector="isInClass">isInClass	^true</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new class comment from a definition contained in 	aRecord. 	Return true is the operation is successful."	| cl |	cl := aRecord myClass.	^cl isNil 		ifTrue: 			[self error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') expandMacrosWith: aRecord className).			false]		ifFalse: 			[aRecord loadCommentFor: cl.			true]</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me."	"(ClassCommentTag newClassName: 'MethodTag class') containingPackage"	^Registry containingPackageForClassNamed: self className</body><body package="Store-Change Management" selector="description">description	^'class comment'</body><body package="Store-Change Management" selector="isMeta">isMeta	^false</body><body package="Store-Change Management" selector="name">name	^self className, ' comment'</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl comment]</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| actualClass |	actualClass := self actualClass.	actualClass isNil 		ifTrue: 			[Dialog 				warn: ((#TheClass1sMustExistAndApplyResolved &lt;&lt; #store &gt;&gt; 'The class "&lt;1s&gt;" must be loaded into&lt;n&gt;the image before you can accept an edited comment.&lt;n&gt;Resolve conflicts in the class definition, if any,&lt;n&gt;and "Apply Resolved".') 						expandMacrosWith: self classSymbol asString).			^false].	actualClass comment: someText.	^true</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	actual notNil		ifTrue: [XChangeSet current				moveClassDefinition: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	(self actualClass isNil and: [tolerantBoolean not]) ifTrue: [		^self 			error: ((#Class1sDoesNotExistInTheImage &lt;&lt; #store &gt;&gt; 'Class "&lt;1s&gt;" does not exist in the image.') 			expandMacrosWith: self className)].	self actualClass comment: nil.</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseClass: self actualClass.</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self actualClass ) == nil		ifFalse: [ obj fileOutCommentOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutCommentOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"don't bother to remove the comment"</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'class comment'</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForClassTag: self.</body></methods><methods><class-id>Store.ClassCommentTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^2</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="Store-Base" selector="contentsOfEntireBinaryFile">contentsOfEntireBinaryFile	"Answer the contents of a binary file represented by the receiver."	| stream |	stream := self readStream binary.	^[ stream contents ] 		ensure: [ stream close ]</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>private - actions</category><body package="Store-Base" selector="defaultAction">defaultAction	"This catches errors which might occur when we have Store Browsers open, but the database connection has been lost or terminated.	 At this point any database information any open browsers is obsolete and reconnecting the database will not restore	 the browsers to working order.  When this happens there is no browser specific code in the stack in which to place any 	 exception handler, so we need to be notified asynchronously of the event."	| announcement |	announcement := Store.ObsoleteBrowserContent new session: self session.	Announcements announce: announcement.	^super defaultAction.</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>private-compiling</category><body package="Store-Base" selector="compileWithoutUsingChangeFile:classified:notifying:attributes:">compileWithoutUsingChangeFile: code classified: heading notifying: requestor attributes: attributes 	| selector srcs |	self 		compile: code		notifying: requestor		attributes: attributes		selectorBlock: 			[:sel :oldMeth | 			selector := sel.			srcs := oldMeth == nil 						ifTrue: [MethodSourceCollection new]						ifFalse: [oldMeth methodSources copy]]		ifFail: [^nil].	srcs source: code.	(methodDict at: selector) sourcePointer: srcs.	self organization classify: selector under: heading.	^selector</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>binary storage</category><body package="Store-Base" selector="binoutOn:">binoutOn: outputStream	self timeStampFileOut.	outputStream nextPutPackage: self</body></methods><methods><class-id>Core.Object</class-id> <category>tt-utilities</category><body package="Store-Base" selector="debugVersionOnly">debugVersionOnly	"Senders of this method should be present	in the development version only."</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Store-Base" selector="isForNameSpace">isForNameSpace	^false</body></methods><methods><class-id>Core.Object</class-id> <category>tt-utilities</category><body package="Store-Base" selector="needsMoreWork">needsMoreWork	"Senders of this method require redesign.."</body><body package="Store-Base" selector="textRepresentation">textRepresentation	^self printString.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="Store-Base" selector="equalsAcrossPlatforms:">equalsAcrossPlatforms: aCharacterArray	"Answer whether the argument and the receiver's size is the same as aCharacterArray's size, 	and each of the receiver's elements equal the corresponding element of aCharacterArray.	Notes: 		The platforms are: Gemstone and VisualWorks.		We hope the future will have Gemstone bring source in the future to be VW format (CR)		If that happens then this can be much faster by no longer having to do this."		| eofs |	aCharacterArray isCharacters ifFalse: [^false].	self size = aCharacterArray size ifFalse: [^false].	eofs := Array with: Character lf with: Character cr with: (Character value: 11).	self with: aCharacterArray do: 		[:char1 :char2 | 		char1 = char2 ifFalse: [((eofs includes: char1) and: [eofs includes: char2])			ifFalse: [^false]]].	^true</body></methods><methods><class-id>Kernel.CodeComponent class</class-id> <category>signals</category><body package="Store-Database" selector="errorSignals">errorSignals	^Store.DBAccess errorSignals</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>utilities-store</category><body package="Store-Database" selector="errorSignals">errorSignals	^self class errorSignals</body></methods><methods><class-id>Kernel.AbsentClassImporter class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="underlyingDefinition">underlyingDefinition	"We get the definition message object, and then replace the #superclass: argument (#2) with the	object that is REALLY the superclass if it were to load properly."		| aStream msg |	aStream := WriteStream on: (String new: 300).	msg := self definitionMessage.	aStream nextPutAll: msg receiver unambiguousName.	msg argumentAt: 2 put: self absentSuperclassName asStrictReference.	msg selector keywords with: msg arguments do:		[:word :arg |		arg == self name			ifTrue: [aStream space]			ifFalse: [aStream cr; tab].		aStream nextPutAll: word; space.		arg class == Array			ifTrue:				[aStream nextPutAll: '#('.				arg do: [:argN | aStream crtab: 3; store: argN].				aStream nextPutAll: ')']			ifFalse: [aStream store: arg]].	^aStream contents</body></methods><methods><class-id>Core.Boolean class</class-id> <category>tt-utilities</category><body package="Store-DB-BaseObjects" selector="fromText:">fromText: aString	^( aString first = $T  ) | ( aString first = $t )</body></methods><methods><class-id>Core.False</class-id> <category>tt-utilities</category><body package="Store-DB-BaseObjects" selector="textRepresentation">textRepresentation	^'F'</body></methods><methods><class-id>Core.True</class-id> <category>tt-utilities</category><body package="Store-DB-BaseObjects" selector="textRepresentation">textRepresentation	^'T'</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-accessing</category><body package="Store-DB-Broker" selector="cursor:">cursor: anObj</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>store</category><body package="Store-DB-Broker" selector="connection">connection	"Answer the opened connection or nil if the dialog was cancelled."		self lastUsedProfile == nil		ifTrue: [self lastUsedProfile: self connectionProfileClass new].	^self openConnectionUsing: self lastUsedProfile</body><body package="Store-DB-Broker" selector="connectionProfileClass">connectionProfileClass		^ConnectionProfile</body><body package="Store-DB-Broker" selector="openConnectionUsing:">openConnectionUsing: aProfile	"Open the dialog with aProfile and then open the database connection that was selected.	Answer the opened connection or nil if the dialog was cancelled."	| profile connection |	profile := aProfile.	[ ( profile := self openProfile: profile ) == nil		ifTrue: [ ^nil ].	connection := self connect: profile.	connection == nil.	] whileTrue.	^connection.</body><body package="Store-DB-Broker" selector="openProfile:">openProfile: aProfile	"Open the connection dialog. After it is closed answer either the	connection profile with parameters selected by the user if it was accepted	or nil if the dialog was cancelled."	| instance |	instance := self new.	instance currentProfile: aProfile copy.	^instance open		ifTrue: [ instance currentProfile ]		ifFalse: [ nil ]</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="storeBroker">storeBroker	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-accessing</category><body package="Store-DB-Broker" selector="nilParams">nilParams</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="storeBroker">storeBroker	"Answer a broker for Store"	^self class storeBroker</body></methods><methods><class-id>OS.PortableFilename</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="hasSystemVariable">hasSystemVariable	^components first isString not</body></methods><methods><class-id>OS.LogicalFilename</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="hasSystemVariable">hasSystemVariable	^false</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>compiling</category><body package="Store-DB-Subdefs" selector="compileWithoutStoringSource:classified:">compileWithoutStoringSource: code classified: heading 	"Compile the argument, code, as source code in the context of the receiver and	install the result in the receiver's method dictionary under the classification 	indicated by the second argument, heading. nil is to be notified if an error occurs.	The argument code is either a string or an object that converts to a string or a	PositionableStream on an object that converts to a string.	Do not store source code in the changes file."	| selector |	selector := self				compile: code				notifying: nil				ifFail: [^nil].	self organization classify: selector under: heading.	^selector</body></methods><methods><class-id>Kernel.Override</class-id> <category>accessing</category><body package="Store-ImageModel" selector="actual">actual	^self object</body></methods><methods><class-id>Kernel.Override</class-id> <category>private-store</category><body package="Store-ImageModel" selector="addDiffTo:into:">addDiffTo: aStorePackage into: aPackageComparitor	"Add the appropiate diff to a difference holder."	"NOTE: called after other diffs have been calculated, so got to clean out db version."		| storeRecord |	(storeRecord := self dbVersionFrom: aStorePackage) ifNil: 		[^self addOrReplaceInOtherDiffs: aPackageComparitor].	(storeRecord sourceMatches: self)		ifTrue: [(self mainDiffs: aPackageComparitor) remove: storeRecord ifAbsent: [nil]]		ifFalse:			[(self mainDiffs: aPackageComparitor) add: storeRecord.			(self otherDiffs: aPackageComparitor) add: self]</body><body package="Store-ImageModel" selector="addOrReplaceInDiffs:side:">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different definitions it has computed.  If the 	 differences already have the same definition then remove it because it will be	 the definition in the system (the override) and add the overridden version of the	 definition (the receiver).  Otherwise, simply add the receiver to the list of different 	 definitions."		self subclassResponsibility</body><body package="Store-ImageModel" selector="addOrReplaceInOtherDiffs:">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different definitions it has computed.  If the 	 differences already have the same definition then remove it because it will be	 the definition in the system (the override) and add the overridden version of the	 definition (the receiver).  Otherwise, simply add the receiver to the list of different 	 definitions."		self subclassResponsibility</body><body package="Store-ImageModel" selector="cleanUpAfterLoad">cleanUpAfterLoad	^self subclassResponsibility</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	self subclassResponsibility</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	self subclassResponsibility</body><body package="Store-ImageModel" selector="mainDiffs:">mainDiffs: aPackageComparitor	self subclassResponsibility</body><body package="Store-ImageModel" selector="moveToPackage:">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	self subclassResponsibility.</body><body package="Store-ImageModel" selector="myClass">myClass    ^self implementingClass</body><body package="Store-ImageModel" selector="otherDiffs:">otherDiffs: differances	self subclassResponsibility</body><body package="Store-ImageModel" selector="primaryKey">primaryKey	^0</body></methods><methods><class-id>Kernel.Override</class-id> <category>private-store</category><body package="Store-ImageModel" selector="setOverriddenDefinition:">setOverriddenDefinition: aMessageSend	definition := aMessageSend</body><body package="Store-ImageModel" selector="source">source	^self text</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="Store-ImageModel" selector="sourceMatches:">sourceMatches: anObject	"Answer whether the source matches."	^anObject sourceMatches: self.</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>private-store</category><body package="Store-ImageModel" selector="addOrReplaceInDiffs:side:">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different namespaces it computed.  If the 	 list of namespaces already has the same namespace then remove it because it will be	 the namespace in the system (the override) and add the overridden version of the	 namespace (the receiver).  Otherwise, simply add the receiver to the list of different 	 namespaces."	| namespaces namespaceDescriptor |	namespaces := self diffs: packageDifferences side: side.	namespaceDescriptor := namespaces 				detect: [:descriptor | descriptor absoluteName = self absoluteName]				ifNone: [nil].	namespaceDescriptor 		ifNotNil: [namespaces remove: namespaceDescriptor].	namespaces add: self</body><body package="Store-ImageModel" selector="addOrReplaceInOtherDiffs:">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different namespaces it computed.  If the 	 list of namespaces already has the same namespace then remove it because it will be	 the namespace in the system (the override) and add the overridden version of the	 namespace (the receiver).  Otherwise, simply add the receiver to the list of different 	 namespaces."		| namespaces namespaceDescriptor |	namespaces := self otherDiffs: aPackageComparitor.	namespaceDescriptor := namespaces 		detect: [:descriptor | descriptor absoluteName = self absoluteName] 		ifNone: [nil].	namespaceDescriptor ifNotNil: [namespaces remove: namespaceDescriptor].	namespaces add: self</body><body package="Store-ImageModel" selector="cleanUpAfterLoad">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse:			[each changeSetsDo:				[:eachChangeSet |				| nameSpaceChange |				nameSpaceChange := eachChangeSet at: self absoluteSymbol ifAbsent: [nil].				nameSpaceChange ifNotNil: [nameSpaceChange removeDefChanges: #(#override #comment #removeDefinition)].				eachChangeSet removeIfEmptySymbol: self absoluteSymbol]]]</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage nameSpaceInPackageNamed: self absoluteName</body><body package="Store-ImageModel" selector="definitionAndComment">definitionAndComment	^Store.NameSpaceRecord mergeDefinition: self text andComment: self comment</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs nameSpacesSide: side</body><body package="Store-ImageModel" selector="mainDiffs:">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageNamespaces]		ifFalse: [aPackageComparitor nameSpacesSide: 1]</body><body package="Store-ImageModel" selector="otherDiffs:">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageNamespaces]		ifFalse: [aPackageComparitor nameSpacesSide: 2]</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>private-store</category><body package="Store-ImageModel" selector="addOrReplaceInDiffs:side:">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different classes it computed.  If the 	 list of classes already has the same class then remove it because it will be	 the class in the system (the override) and add the overridden version of the	 class (the receiver).  Otherwise, simply add the receiver to the list of different 	 classes."	| classes classDescriptor |	classes := self diffs: packageDifferences side: side.	classDescriptor := classes 				detect: [:descriptor | descriptor absoluteName = self absoluteName]				ifNone: [nil].	classDescriptor 		ifNotNil: [classes remove: classDescriptor].	classes add: self</body><body package="Store-ImageModel" selector="addOrReplaceInOtherDiffs:">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different classes it computed.  If the 	 list of classes already has the same class then remove it because it will be	 the class in the system (the override) and add the overridden version of the	 class (the receiver).  Otherwise, simply add the receiver to the list of different 	 classes."		| classes classDescriptor |	classes := self otherDiffs: aPackageComparitor.	classDescriptor := classes 		detect: [:descriptor | descriptor absoluteName = self absoluteName] 		ifNone: [nil].	classDescriptor ifNotNil: [classes remove: classDescriptor].	classes add: self</body><body package="Store-ImageModel" selector="cleanUpAfterLoad">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse: 			[each changeSetsDo:				[:eachChangeSet |				| classChange |				classChange := eachChangeSet at: self actual absoluteSymbol ifAbsent: [nil].				classChange ifNotNil: [classChange removeDefChanges: #(#add)].				eachChangeSet removeIfEmptySymbol: self actual absoluteSymbol]]]</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		classInPackageNamed: self absoluteName 		meta: self isMeta</body><body package="Store-ImageModel" selector="definitionAndComment">definitionAndComment	^Store.ClassRecord mergeDefinition: self text andComment: self comment</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^self isMeta		ifTrue: [ diffs metaSide: side ]		ifFalse: [ diffs classesSide: side ]</body><body package="Store-ImageModel" selector="mainDiffs:">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageClasses]		ifFalse: [aPackageComparitor classesSide: 1]</body><body package="Store-ImageModel" selector="otherDiffs:">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageClasses]		ifFalse: [aPackageComparitor classesSide: 2]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>private-store</category><body package="Store-ImageModel" selector="addOrReplaceInDiffs:side:">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different methods it computed.  If the 	 list of methods already has the same method then remove it because it will be	 the method in the system (the override) and add the overridden version of the	 method (the receiver).  Otherwise, simply add the receiver to the list of different 	 methods."	| methods methodDescriptor |	methods := self diffs: packageDifferences side: side.	methodDescriptor := methods detect: 					[:descriptor | 					descriptor classNameWithMeta = self classNameWithMeta and: 							[descriptor selector = self selector and: 									[descriptor protocol = self protocol and: [descriptor isMeta = self isMeta]]]]				ifNone: [nil].	methodDescriptor ifNotNil: [methods remove: methodDescriptor].	methods add: self</body><body package="Store-ImageModel" selector="addOrReplaceInOtherDiffs:">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different methods it computed.  If the 	 list of methods already has the same method then remove it because it will be	 the method in the system (the override) and add the overridden version of the	 method (the receiver).  Otherwise, simply add the receiver to the list of different 	 methods."		| methods methodDescriptor |	methods := self otherDiffs: aPackageComparitor.	methodDescriptor := methods		detect:			[:descriptor | 			descriptor classNameWithMeta = self classNameWithMeta and: 				[descriptor selector = self selector and: 				[descriptor protocol = self protocol and: 				[descriptor isMeta = self isMeta]]]]		ifNone: [nil].	methodDescriptor ifNotNil: [methods remove: methodDescriptor].	methods add: self</body><body package="Store-ImageModel" selector="cleanUpAfterLoad">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse:			[each changeSetsDo:				[:eachChangeSet |				| classChange |				classChange := eachChangeSet at: self implementingClass nonMeta absoluteSymbol ifAbsent: [nil].	 			classChange ifNotNil: [(classChange alterMethodChangesMeta: self implementingClass isMeta) 					removeKey: selector 					ifAbsent: [nil]].					eachChangeSet removeIfEmptySymbol: self implementingClass nonMeta absoluteSymbol]]]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		method: self selector 		forClassNamed: self implementingClass absoluteName 		meta: self isMeta</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs methodsSide: side</body><body package="Store-ImageModel" selector="mainDiffs:">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageMethods]		ifFalse: [aPackageComparitor methodsSide: 1]</body><body package="Store-ImageModel" selector="moveToPackage:">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	#{Store.XChangeSet} ifDefinedDo:		[ :xs | xs current moveSelector: self selector class: self owner toPackage: aPackage ]</body><body package="Store-ImageModel" selector="myClass">myClass	"Answer ther receiver's class. Compatibility."	^self implementingClass</body><body package="Store-ImageModel" selector="otherDiffs:">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageMethods]		ifFalse: [aPackageComparitor methodsSide: 2]</body></methods><methods><class-id>Store.Model</class-id> <category>testing</category><body package="Store-ImageModel" selector="isForFile">isForFile	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Store-ImageModel" selector="isDataModel">isDataModel	"Is this a Bernstein data model?"	^false</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="Store-ImageModel" selector="actual">actual	^self object value</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>private-store</category><body package="Store-ImageModel" selector="addOrReplaceInDiffs:side:">addOrReplaceInDiffs: packageDifferences side: side 	"Consult packageDifferences for the different shareds it computed.  If the 	 list of shareds already has the same shared then remove it because it will be	 the shared in the system (the override) and add the overridden version of the	 shared (the receiver).  Otherwise, simply add the receiver to the list of different 	 shareds."	| shareds sharedDescriptor |	shareds := packageDifferences dataSide: side.	sharedDescriptor := shareds 				detect: [:descriptor | descriptor absoluteName = self absoluteName]				ifNone: [nil].	sharedDescriptor ifNotNil: [shareds remove: sharedDescriptor].	shareds add: self</body><body package="Store-ImageModel" selector="addOrReplaceInOtherDiffs:">addOrReplaceInOtherDiffs: aPackageComparitor	"Consult packageDifferences for the different shareds it computed.  If the 	 list of shareds already has the same shared then remove it because it will be	 the shared in the system (the override) and add the overridden version of the	 shared (the receiver).  Otherwise, simply add the receiver to the list of different 	 shareds."		| shareds sharedDescriptor |	shareds := self otherDiffs: aPackageComparitor.	sharedDescriptor := shareds 		detect: [:descriptor | descriptor absoluteName = self absoluteName] 		ifNone: [nil].	sharedDescriptor ifNotNil: [shareds remove: sharedDescriptor].	shareds add: self</body><body package="Store-ImageModel" selector="cleanUpAfterLoad">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse: 			[each changeSetsDo:				[:eachChangeSet |				| classChange |				classChange := eachChangeSet at: self owner absoluteSymbol ifAbsent: [nil].				classChange ifNotNil: [classChange alterDataChanges removeKey: self binding key ifAbsent: [nil]].				eachChangeSet removeIfEmptySymbol: self owner absoluteSymbol]]]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		datum: self key		forNamed: self owner absoluteName</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs dataSide: side</body><body package="Store-ImageModel" selector="mainDiffs:">mainDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor mainPackageShareds]		ifFalse: [aPackageComparitor dataSide: 1]</body><body package="Store-ImageModel" selector="moveToPackage:">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	#{Store.XChangeSet} ifDefinedDo:		[ :xs | xs current moveDataKey: self dataKey owner: self owner toPackage: aPackage ]</body><body package="Store-ImageModel" selector="otherDiffs:">otherDiffs: aPackageComparitor	^aPackageComparitor isPackageComparitor 		ifTrue: [aPackageComparitor otherPackageShareds]		ifFalse: [aPackageComparitor dataSide: 2]</body><body package="Store-ImageModel" selector="sourceMatches:">sourceMatches: aDatum 	"Answer whether the source matches."	^self text equalsAcrossPlatforms: aDatum definition</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>converting</category><body package="Store-IMG-Records" selector="asCommentTag">asCommentTag	"Answer an instance of NameSpaceCommentTag"	^NameSpaceCommentTag newNameSpaceName: self absoluteName</body><body package="Store-IMG-Records" selector="asTag">asTag	"Answer an instance of TT_NameSpaceTag"	^NameSpaceTag newNameSpaceName: self absoluteName</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Records" selector="definitionAndComment">definitionAndComment	| ns |	(ns := self nameSpace) == nil		ifTrue: [ ^'' ]		ifFalse: [ ^NameSpaceRecord mergeDefinition: ns definition andComment: ns comment ]</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Records" selector="sameAsDBThing:">sameAsDBThing: aNameSpace	^aNameSpace sameAsImThing: self</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store utils</category><body package="Store-IMG-Records" selector="definitionOf:ifAbsent:">definitionOf: aSymbol ifAbsent: aBlock	| binding |	( binding := self bindingFor: aSymbol ) == nil		ifTrue: [ ^aBlock value ].	^binding isForGeneral		ifTrue: [ self definitionOfStatic: binding ] 		ifFalse: [ binding value definition ]</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="Store-IMG-Records" selector="textRepresentation">textRepresentation	^self</body></methods><methods><class-id>Core.Class</class-id> <category>store tools</category><body package="Store-IMG-Records" selector="classSymbol">classSymbol	^self name</body><body package="Store-IMG-Records" selector="nonMeta">nonMeta	^self</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Records" selector="definitionAndComment">definitionAndComment		^super definitionAndComment."	^'This class is not defined in this package'"</body></methods><methods><class-id>Core.Metaclass</class-id> <category>team tools</category><body package="Store-IMG-Records" selector="classSymbol">classSymbol	^self soleInstance name</body><body package="Store-IMG-Records" selector="nonMeta">nonMeta	^self soleInstance</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>converting</category><body package="Store-IMG-Records" selector="asCommentTag">asCommentTag	"Answer an instance of TT_ClassCommentTag"	^ClassCommentTag newClassName: self absoluteName</body><body package="Store-IMG-Records" selector="asTag">asTag	"Answer an instance of TT_ClassTag."	^ClassTag newClassName: self absoluteName isMeta: self isMeta</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Records" selector="definitionAndComment">definitionAndComment	| cl |	(cl := self myClass) isNil		ifTrue: [ ^'' ]		ifFalse: [ ^ClassRecord mergeDefinition: cl definition andComment: cl comment ]</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Records" selector="sameAsDBThing:">sameAsDBThing: aClass	^aClass sameAsImThing: self</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="Store-IMG-Subdefs" selector="decode:">decode: aByteArray	"self decode: (self encode: self new)"	| stream bos data |	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	data := bos next.	bos close.	^data</body><body package="Store-IMG-Subdefs" selector="encode:">encode: data	"self encode: self new"	| stream bos |	stream := WriteStream on: ByteArray new.	bos := BinaryObjectStorage onNew: stream.	bos nextPut: data.	bos close.	^stream contents</body><body package="Store-IMG-Subdefs" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self definitionOf: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printString asText</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>converting</category><body package="Store-IMG-Subdefs" selector="asTag">asTag	"Answer an instance of TT_DataTag."	^self isInClass		ifTrue: [ 	DataTag newClassName: self ownerName dataKey: self dataKey ]		ifFalse: [ DataTag newNameSpaceName: self ownerName dataKey: self dataKey ]</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aDatum 	"When comparing with DB - the definition has it all"	"Note: at the moment, no comments for data."	^self definition = aDatum definition</body><body package="Store-IMG-Subdefs" selector="sourceMatches:">sourceMatches: aDatumDescriptor 	"Answer whether the source matches.	Note: since protocol is part of the definition, we don't need to check it."	^aDatumDescriptor notNil and: [self definition equalsAcrossPlatforms: aDatumDescriptor definition]</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self definition</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="Store-IMG-Subdefs" selector="decode:">decode: aByteArray	"self decode: (self encode: self new)"	| stream bos data |	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	data := bos next.	bos close.	^data</body><body package="Store-IMG-Subdefs" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey	"Answer text for aDataKey"		^(self dataAt: aDataKey ifAbsent: [^(#twoStarUnresolvedTwoStar &lt;&lt; #store &gt;&gt; '**Unresolved**') asText]) printString asText</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>comparing</category><body package="Store-IMG-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aMethod 	aMethod isMeta = self isMeta ifFalse: [ ^false ].	self absoluteClassName = aMethod absoluteClassName ifFalse: [ ^false ].	self selector = aMethod selector ifFalse: [ ^false ].	self protocol = aMethod protocol ifFalse: [^false].	^self sourceCode asString = aMethod sourceCode asString.</body><body package="Store-IMG-Subdefs" selector="sameAsImThing:">sameAsImThing: aMethod	^self classNameWithMeta = aMethod classNameWithMeta		and: [self selector = aMethod selector		and: [(self sources notEmpty ifTrue: [self sources any]) = (aMethod sources notEmpty ifTrue: [aMethod sources any])]]</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>converting</category><body package="Store-IMG-Subdefs" selector="asTag">asTag	"Answer an instance of TT_MethodTag."	^MethodTag newClassName: self fullClassName selector: self selector meta: self isMeta.</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aMethod 	"When comparing with DB method take protocol into account."	| cls |	(cls := self myClass) ifNil: [^false].	^(cls includesSelector: self selector)		and: [aMethod sameAsSelector: self selector class: cls]</body><body package="Store-IMG-Subdefs" selector="sourceMatches:">sourceMatches: aMethod	"Answer whether the source match."		^self protocol = aMethod protocol		and: [self sourceCode equalsAcrossPlatforms: aMethod sourceCode]</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self sourceCode</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="adjustVersion">adjustVersion	"Do nothing for bundles."</body><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^Bundles new		subBundleRef: self component dbTrace		yourself</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="dbComponent">dbComponent	"Find a component named componentName and answer it."	^id == nil		ifTrue: [ nil ]		ifFalse: [ Bundle aRecordWithID: id ]</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="descriptionsAndLevels">descriptionsAndLevels	"Answer a list of pairs. The first element contains a descriptions the second the 	level on which the description was found."	| comp coll |	comp := self component.	comp isNil ifTrue: [^#()].	coll := comp descriptionsAndLevels.	coll do: [:pair | pair at: 2 put: (pair at: 2) + 1].	coll addFirst: (Array with: self with: 1).	^coll</body><body package="Store-IMG-Pundles" selector="loadFromDBWithin:">loadFromDBWithin: parentBundle	"Locate a record containig my component and load the package from it."		| key | 	key := self id.	^BundleModel binLoadFromDB: key within: parentBundle.</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="addFileDescription:">addFileDescription: aFilename	"Add the file specified by aFilename to the contents"	|filename|	filename := aFilename asLogicalFileSpecification.	( self fileDescriptions contains: [ :fm | fm portableFilename = filename ] )		ifTrue: [ ^false ].		self fileDescriptions add: ( ( FileModel from: filename ) bundle: self pundle ).	self shouldTrackChanges 		ifTrue: [ self addOtherChange: BundleModel fileMark ].	^true</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="fileDescriptions">fileDescriptions		fileDescriptions == nil		ifTrue: [ fileDescriptions := List new.].	^fileDescriptions</body><body package="Store-IMG-Pundles" selector="fileDescriptions:">fileDescriptions: aCollection	fileDescriptions := aCollection asList.	fileDescriptions do: [:fd | fd bundle: self pundle]</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="removeFile:">removeFile: aFileDescription	"Remove aFileDescription to the contents"	aFileDescription isString		ifTrue: [ fileDescriptions do: 					[ :fd | fd portableFilename asString = aFileDescription							ifTrue: [ ^self removeFile: fd ]					].				^true				]		ifFalse: [ fileDescriptions remove: aFileDescription ifAbsent: nil ].	self shouldTrackChanges 		ifTrue: [ self addOtherChange: BundleModel fileMark ].	^true</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="Store-IMG-Pundles" selector="resetContentsFrom:">resetContentsFrom: aBundleConnectionInformation	"Make this database information adopt the parameter information's view of what pundles the bundle contains and in what order.  Since addComponentDescription: is lazy (does nothing if it is already there), the first statement only adds pundles we do not already have.  The second removes pundles which we have but which the newly loaded version does not have.  If the two content description collections are still not equal (content description equality only checks names) then we resort our pundle orders to match that of the (about-to-be) loaded pundle."	(self copy initializeContentsFrom: aBundleConnectionInformation)		contentDescriptions do: [:each | self addComponentDescription: each].	(contentDescriptions reject:		[:each | aBundleConnectionInformation contentDescriptions includes: each])			do: [:each | self removeComponentDescription: each].	contentDescriptions = aBundleConnectionInformation contentDescriptions ifFalse:		[self shouldTrackChanges ifTrue: [self addOtherChange: pundle structureMark].		Registry changedBundleStructure: self pundle.		SequenceableCollectionSorter			sort: contentDescriptions			using: [:a :b | (aBundleConnectionInformation contentDescriptions indexOf: a)						&lt; (aBundleConnectionInformation contentDescriptions indexOf: b)]].</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="ensureLoadedParcel:withVersion:forPundle:">ensureLoadedParcel: parcelName withVersion: versionString forPundle: aPundle	"Check if a Parcel named parcelName is loaded with an appropriate version.	 If its not then attempt to load it."	"Called while trying to meet a Store parcel prerequisite"	| newParcel |	Cursor wait showWhile:		[self withFileCachesDo: 			[newParcel := self								ensureLoadedParcel: parcelName								withVersion: versionString								for: aPundle]].	self broadcastParcels.	^newParcel</body><body package="Store-IMG-Pundles" selector="ensureLoadedParcel:withVersion:forPundle:with:">ensureLoadedParcel: parcelName withVersion: versionString forPundle: aPundle with: aCompilationManager	"Check if a Parcel named parcelName is loaded with an appropriate version.	 If its not then attempt to load but not install it.	Called while trying to meet a Store parcel prerequisite"		| uninstalledParcel |	self withFileCachesDo: 		[uninstalledParcel := self ensureLoadedParcel: parcelName withVersion: versionString for: aPundle with: aCompilationManager].	aCompilationManager ifNotNil: [aCompilationManager newShadowRoot].	^uninstalledParcel</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>updating</category><body package="Store-IMG-Pundles" selector="traceChangedForComponent:">traceChangedForComponent: aCodeComponent"	self changed: #parcelTraceChanged with: aCodeComponent"</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store-utilities</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent this component type in the database."	^Store.ParcelRecord</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleName">pundleName	"Used by parcel resolving pundle prereqs- Answers a name regardless"	( name := self bundleName ) == nil		ifTrue: 			[ ( name := self packageName ) == nil 				ifTrue: [ name := self name ].			].	^name</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^Packages new		packageRef: self component dbTrace;		yourself.</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="dbComponent">dbComponent	"Find a component named componentName and answer it."	^id == nil		ifTrue: [ nil ]		ifFalse: [ Package aRecordWithID: id ]</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="exactLoadedComponent">exactLoadedComponent	"Find if a bundle with my id is loaded into the image."	id isNil ifTrue: [^nil].	Registry packagesDo: 		[ :pkg | 		( pkg dbTraceFor: dbIdentifier ) = id 			ifTrue: 				[ ^pkg hasBeenModified					ifTrue: [ nil ]					ifFalse: [ pkg ]				]		].	^nil</body><body package="Store-IMG-Pundles" selector="isLoaded">isLoaded	"Find if a package fulfilling 	my description is loaded into the image."	^Registry isPackageLoaded: self name</body><body package="Store-IMG-Pundles" selector="loadedComponent">loadedComponent	"Find if a package fulfilling exactly my description is loaded into the image."	componentName == nil		ifFalse: [ ^Registry packageNamed: componentName ].	id isNil ifTrue: [ ^nil ].	Registry packagesDo: 		[ :pkg | 		( pkg dbTraceFor: dbIdentifier ) = id 			ifTrue: 				[ ^pkg hasBeenModified					ifTrue: [ nil ]					ifFalse: [ pkg ]				]		].	^nil</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="loadFromDBWithin:">loadFromDBWithin: parentBundle	"Locate a record containig my component and load the package from it."		| key | 	key := self id.	^PackageModel binLoadFromDB: key within: parentBundle.</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="Store-IMG-Pundles" selector="createPDPBundle">createPDPBundle	"Creates the PDP bundle from the tobc file created with:		( Store.Registry bundleNamed: 'PDP 3.0' ) 				tableOfBundleContentsOnFile: 'pdp.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'pdp.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="Store-IMG-Pundles" selector="createRBBundle">createRBBundle	"Creates the system bundle from the tobc file created with:		( Store.Registry bundleNamed: 'RefactoringBrowser' ) 				tableOfBundleContentsOnFile: 'RefactoringBrowser.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'RefactoringBrowser.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="Store-IMG-Pundles" selector="createToolsBundle">createToolsBundle	"Creates the Tools bundle from the tobc file created with:		( Store.Registry bundleNamed: 'Tools-IDE' ) 				tableOfBundleContentsOnFile: 'Tools-IDE.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'Tools-IDE.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>parcel load/unload/save</category><body package="Store-IMG-Pundles" selector="postLoadActionFor:">postLoadActionFor: aParcel 	self createStoreBundle: aParcel</body><body package="Store-IMG-Pundles" selector="preUnloadActionFor:">preUnloadActionFor: aParcel "Removed for now... reinstate if major UI changes made	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel."</body><body package="Store-IMG-Pundles" selector="preUpdateActionFor:">preUpdateActionFor: aParcel	"Do the part of postLoad necessary for Store to update itself."	Override registerSourceManager: Store.Registry.	self addImports.	( Store.Registry dependents includes: Store.Registry )		ifFalse: [ Store.Registry addDependent: Store.Registry ].</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-bundle</category><body package="Store-IMG-Pundles" selector="allBundlesWithNewerInDB">allBundlesWithNewerInDB	"Answer a collection of packages with newer published versions."	"Store.Registry allBundlesWithNewerInDB"	^self allBundlesWithNewerInDBIn: Store.Glorp.StoreLoginFactory currentStoreSession</body><body package="Store-IMG-Pundles" selector="allBundlesWithNewerInDBIn:">allBundlesWithNewerInDBIn: aSession	"Answer a collection of packages with newer published versions."	"Store.Registry allBundlesWithNewerInDB"		^Store.Glorp.StoreBundle allPundlesIn: bundles withNewerInDBIn: aSession</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-package</category><body package="Store-IMG-Pundles" selector="allPackagesWithNewerInDB">allPackagesWithNewerInDB	"Answer a collection of packages with newer published versions."	"Store.Registry allPackagesWithNewerInDB"	^self allPackagesWithNewerInDBIn: Store.Glorp.StoreLoginFactory currentStoreSession</body><body package="Store-IMG-Pundles" selector="allPackagesWithNewerInDBIn:">allPackagesWithNewerInDBIn: aSession	"Answer a collection of packages with newer published versions."	^Store.Glorp.StorePackage allPundlesIn: packages withNewerInDBIn: aSession</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="Store-IMG-Pundles" selector="checkUnpublishedPundlesOn:">checkUnpublishedPundlesOn: aStream 	| first |	first := true.	self packagesDo: 			[:pkg | 			pkg hasBeenModified 				ifTrue: 					[first 						ifTrue: 							[aStream								nextPutAll: (#TheFollowingPackagesAreModified &lt;&lt; #store 											&gt;&gt; 'The following packages are modified:') asString;								cr.							first := false].					aStream						tab;						nextPutAll: pkg name;						cr]].	first ifFalse: [aStream cr].	first := true.	self bundlesDo: 			[:bndl | 			bndl hasBeenModified 				ifTrue: 					[first 						ifTrue: 							[aStream								nextPutAll: (#TheFollowingBundlesAreModified &lt;&lt; #store 											&gt;&gt; 'The following bundles are modified:') asString;								cr.							first := false].					aStream						tab;						nextPutAll: bndl name;						cr]]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>change set conversion</category><body package="Store-IMG-Pundles" selector="conversionSetForComponentChange:into:">conversionSetForComponentChange: aComponentChange into: pkgDictionary	"Private- get the appropiate package for a change, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet, nil if not for us."	 | pkg thePackage |	pkg := aComponentChange component.	( pkg == nil or: [ pkg isPackage not ] )		ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForDataKey:in:into:">conversionSetForDataKey: key in: aClassOrNameSpace into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForDataKey: key symbol: aClassOrNameSpace absoluteSymbol.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForDataRemoval:into:">conversionSetForDataRemoval: aName into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer an array with the changeSet and the removed DatumDescriptor."	 | pkg thePackage descr |	pkg := self allPackages detect:			[ :p | ( p changeSet removedDatumDescriptors collect: [ :dd | dd fullName ] ) includes: aName ]						ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	descr := pkg removedDatumDescriptors select: [ :dd | dd fullName = aName ].	^Array with: thePackage changeSet with: descr first</body><body package="Store-IMG-Pundles" selector="conversionSetForDefinition:into:">conversionSetForDefinition: aClassOrNameSpace into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForSymbol: aClassOrNameSpace absoluteSymbol.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForDefinitionRemoval:into:">conversionSetForDefinitionRemoval: aName into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self allPackages detect:			[ :p | p changeSet removedNameSpaceOrDefinitionNames includes: aName ] ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForMethodRemoval:className:meta:into:">conversionSetForMethodRemoval: selector className: aName meta: meta into: pkgDictionary	"Private- look up the appropiate package for a method, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage descr |	pkg := self allPackages detect:			[ :p | p changeSet removedMethodDescriptors contains: 				[ :md | 				descr := md.				( ( md isMeta = meta ) &amp; ( md selector = selector ) ) 						and: [ md className = aName ]				]			] ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet</body><body package="Store-IMG-Pundles" selector="conversionSetForSelector:in:into:">conversionSetForSelector: selector in: aClass into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForSelector: selector class: aClass.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="convertComponentChange:into:">convertComponentChange: aComponentChange into: pkgDictionary	"Private-Add the component change to aChangeSet."	 | xcs |	xcs := self conversionSetForComponentChange: aComponentChange into: pkgDictionary.	xcs == nil		ifFalse: [ aComponentChange doChangeTo: xcs ].</body><body package="Store-IMG-Pundles" selector="convertDefinitionChanges:into:from:">convertDefinitionChanges: aClassOrNameSpace into: pkgDictionary from: aChangeSet	"Private-Look up aClassOrNameSpace that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change real |	real := aClassOrNameSpace isForClass				ifTrue: [ aClassOrNameSpace instanceBehavior ]				ifFalse: [ aClassOrNameSpace ].	( aChangeSet changeTypesFor: real fullName ) isEmpty		ifTrue: [ ^self ].		"no definition changes."	xcs := self conversionSetForDefinition: real into: pkgDictionary.	change :=  aClassOrNameSpace isForClass 		ifTrue: [ Change new class: real ]		ifFalse: [ Change new nameSpace: real ].	( aChangeSet atClass: aClassOrNameSpace includes: #add )		ifTrue: 			[ xcs doChange: change add.			"Since added classes include all selectors for that class, get them here."			( real isForClass and: [  aClassOrNameSpace isMeta not ] )				ifTrue: [ self convertRestOfClassAdd: real into: pkgDictionary from: aChangeSet ].			].	( aChangeSet atClass: aClassOrNameSpace includes: #change )				ifTrue: [ xcs doChange: change change ].	( aChangeSet atClass: aClassOrNameSpace includes: #comment )		ifTrue: [ xcs doChange: change comment ].	( aChangeSet atClass: aClassOrNameSpace includes: #reorganize )		ifTrue: [ xcs doChange: change reorganize ].</body><body package="Store-IMG-Pundles" selector="convertMethodChange:into:from:">convertMethodChange: methodDescriptor into: pkgDictionary from: aChangeSet	"Private-Look up aClass that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change type |	xcs := self conversionSetForSelector: methodDescriptor selector in: methodDescriptor implementingClass into: pkgDictionary.	change :=  Change new 				class: methodDescriptor implementingClass; 				selector: methodDescriptor selector.	type := aChangeSet atSelector: methodDescriptor selector class: methodDescriptor implementingClass.	change perform: type.	xcs doSubdefChange: change.</body><body package="Store-IMG-Pundles" selector="convertMethodRemoval:className:into:">convertMethodRemoval: selector className: className into: pkgDictionary	"Private- className&gt;&gt;selector was removed. Class may not exist. Figure out where it was removed from."	 | xcs name meta |	meta := className namesMetaClass.	name := SystemUtils convertFullNameToAbsolute: className asClassNameOnly.	( xcs := self conversionSetForMethodRemoval: selector className: name meta: meta into: pkgDictionary ) == nil		ifTrue: [ ^self ].	xcs doSubdefChange: ( Change new classSymbol: name asSymbol; meta: meta; selector: selector; remove ).</body><body package="Store-IMG-Pundles" selector="convertNamedChangeSet:">convertNamedChangeSet: aChangeSet	"Answer a dictionary of package copies with changelist determined by aChangeSet"	"Store.Registry convertNamedChangeSet: ( NamedChangeSet lookup: #test )"	| pkgDictionary |	pkgDictionary := Dictionary new.		aChangeSet changedNameSpaces do:		[ :ns | self convertDefinitionChanges: ns into: pkgDictionary from: aChangeSet ].	aChangeSet changedClasses do: 		[ :cls | self convertDefinitionChanges: cls into: pkgDictionary from: aChangeSet ].	aChangeSet changedMessageList do:		[ :md | self convertMethodChange: md into: pkgDictionary  from: aChangeSet ].	aChangeSet changedStatics do:		[ :name | self convertStaticChange: name into: pkgDictionary  from: aChangeSet ].	aChangeSet objectRemoves keysAndValuesDo:		[ :key :value | self convertRemoval: key type: value into: pkgDictionary ].	aChangeSet removedMethodsDo:		[ :className :selector | self convertMethodRemoval: selector className: className into: pkgDictionary ].	aChangeSet componentChangesDo:		[ :componentChange | self convertComponentChange: componentChange into: pkgDictionary ].	^pkgDictionary</body><body package="Store-IMG-Pundles" selector="convertRemoval:type:into:">convertRemoval: aString type: aSymbol into: pkgDictionary	"Private- aString names a class/namespace/static indicated by type. Figure out where it was removed from."	 | xcs name change descr array |	name := SystemUtils convertFullNameToAbsolute: aString.	change := Change new remove.	aSymbol == #variable		ifTrue:			[ ( array := self conversionSetForDataRemoval: name into: pkgDictionary ) == nil				ifTrue: [ ^self ].			xcs := array first.			descr := array last.			descr isInClass				ifTrue: [ change classSymbol: descr ownerName asSymbol ]				ifFalse: [ change nameSpaceSymbol: descr ownerName asSymbol ].			change dataKey: descr key.			xcs doSubdefChange: change.			]		ifFalse: 			[ "must be class or namespace"			( xcs := self conversionSetForDefinitionRemoval: name into: pkgDictionary ) == nil				ifTrue: [ ^self ].			aSymbol == #class				ifTrue: [ change classSymbol: name asSymbol ]				ifFalse: [ change nameSpaceSymbol: name asSymbol ].			xcs doChange: change.			].</body><body package="Store-IMG-Pundles" selector="convertRestOfClassAdd:into:from:">convertRestOfClassAdd: aClass into: pkgDictionary from: aChangeSet	"Private-Look up aClass that came from a ChangeSet and create changes in the appropiate packages."	aClass selectors do:		[ :selector | | xcs change |		xcs := self conversionSetForSelector: selector in: aClass into: pkgDictionary.		change :=  Change new class: aClass; selector: selector; add.		xcs doSubdefChange: change.		].	aClass class selectors do:		[ :selector | | xcs change |		xcs := self conversionSetForSelector: selector in: aClass into: pkgDictionary.		change :=  Change new class: aClass; selector: selector; add.		xcs doSubdefChange: change.		].</body><body package="Store-IMG-Pundles" selector="convertStaticChange:into:from:">convertStaticChange: aString into: pkgDictionary from: aChangeSet	"Private-Look up a static that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change ref env |	ref := aString asStrictReference.	env := ref environment.	change := env isForClass		ifTrue: [ Change new class: env ]		ifFalse: [ Change new nameSpace: env ].	xcs := self conversionSetForDataKey: ref simpleName in: env into: pkgDictionary.	change dataKey: ref simpleName.	( aChangeSet atName: aString includes: #add )		ifTrue: [ change add ].	( aChangeSet atName: aString includes: #change )		ifTrue: [ change change ].		xcs doSubdefChange: change.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="Store-IMG-Pundles" selector="makeConsistent">makeConsistent	"Review state of the image. All Packages remove bogus changeSet references &amp; 	the Registry needs to validate nil class defs."	"Store.Registry makeConsistent"		( packages keys select: [ : key | key isSymbol ] ) do:		[ :key | 	packages at: key asString put: ( packages removeKey: key ) ].	( bundles keys select: [ : key | key isSymbol ] ) do:		[ :key | 	bundles at: key asString put: ( bundles removeKey: key ) ].	self packagesDo: 		[ :pkg | pkg makeConsistent ].	modelDictionary associationsDo:		[ :assoc | 	| pkg |		assoc value first == nil			ifTrue: 				[ ( pkg := packages detect: [ :p | p includesDefinitionOf: assoc key ] ) == nil					ifFalse: [ modelDictionary at: assoc key put: ( pkg modelAtSymbol: assoc key asSymbol ifAbsent: nil ) ]				]		]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="removeDatabaseLinks">removeDatabaseLinks	"Remove the all loaded pundles to a different database.	Store.Registry removeDatabaseLinks"		| allPundles identifiersToRemove |	allPundles := self allBundles , self allPackages.	identifiersToRemove := PundleModel		selectDatabasesFor: allPundles		prompt: (#SelectDatabasesToUnlink &lt;&lt; #store &gt;&gt; 'Select databases to unlink') asString.	identifiersToRemove isEmpty ifTrue: [^self].	allPundles do: [:each | each removeDbInformationFor: identifiersToRemove]</body><body package="Store-IMG-Pundles" selector="switchDatabases">switchDatabases	"Reconcile the all loaded pundles to a different database."	"Store.Registry switchDatabases"		| pundleModels databaseIdentifiers |	pundleModels := self allBundles , self allPackages.	databaseIdentifiers := Set new.	pundleModels do: [:eachPundleModel | databaseIdentifiers addAll: eachPundleModel allDatabases].	databaseIdentifiers remove: DbRegistry dbIdentifier ifAbsent: nil.	databaseIdentifiers := databaseIdentifiers reject:		[:eachIdentifier | 		Dialog confirm: (#MaintainExistingLinksTo1s &lt;&lt; #store &gt;&gt; 'Maintain existing links to: &lt;1s&gt;?' expandMacrosWith: eachIdentifier)].	self switchDatabases: pundleModels remove: databaseIdentifiers</body><body package="Store-IMG-Pundles" selector="switchDatabases:remove:">switchDatabases: aCollectionOfPundleModel remove: aCollectionOfDatabaseIdentifiers 	"Reconcile the pundles in aPundleCollection to a different database."	| which trace |	which := Dialog 		choose: #WhichVersionsShouldBeUsedToReconcile &lt;&lt; #store &gt;&gt; 'Which versions should be used to reconcile?'		labels: (Array 			with: (#UseMostRecentlyPublished &lt;&lt; #store  &gt;&gt; 'Use most recently published?') asString			with: (#SelectPublishedVersions &lt;&lt; #store &gt;&gt; 'Select published versions') asString			with: (#Cancel &lt;&lt; #store &gt;&gt; 'Cancel') asString)		values: #(#recent #select #cancel)		default: #recent.	which == #cancel ifTrue: [^self].	aCollectionOfPundleModel do: [:eachPundleModel | eachPundleModel removeDbs: aCollectionOfDatabaseIdentifiers].		[aCollectionOfPundleModel do: 		[:eachPundleModel | 		eachPundleModel dbTrace ifNil: 			[trace := which == #recent 				ifTrue: [eachPundleModel newestVersionWithName: eachPundleModel name]				ifFalse: [eachPundleModel selectStoreVersionWarnIfNone: false].			trace isNil				ifTrue: 					[Transcript						cr;						show: (#CouldNotReconcile2sColon1s &lt;&lt; #store &gt;&gt; 'Could not reconcile &lt;2s&gt;: &lt;1s&gt;' 								expandMacrosWith: eachPundleModel name								with: eachPundleModel classDescription)]				ifFalse: 					[[eachPundleModel reconcileWithDb: trace] 						on: Error						do: 							[:exception | 							Transcript								cr;								show: (#_1sERRORReconciling2s &lt;&lt; #store &gt;&gt; '&lt;1s&gt;: ERROR reconciling: &lt;2s&gt;' 									expandMacrosWith: eachPundleModel name									with: exception description).							exception return]]]]] 			on: DbRegistry errorSignals			do: [:exception | exception return]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>table of contents</category><body package="Store-IMG-Pundles" selector="tableOfContentsTagsFrom:">tableOfContentsTagsFrom: aStream 	| pkgTags defKey |	pkgTags := OrderedCollection new: 20.		[ aStream skipSeparators.	defKey := aStream upToSeparator.	defKey = ';' ] whileFalse: 		[ | index defTag start |		index := defKey indexOf: $&gt; ifAbsent: [nil].		defTag := index notNil			ifTrue: [ MethodTag new selector: ( defKey copyFrom: index + 1 to: defKey size ) asSymbol ]			ifFalse: 				[ index := defKey indexOf: $@ ifAbsent: [nil].				index notNil					ifTrue: [ DataTag new dataKey: ( defKey copyFrom: index + 1 to: defKey size ) asSymbol ]					ifFalse: 						[ index := defKey size + 1.						defKey first = $!							ifTrue: [ NameSpaceTag new ]							ifFalse: [ ClassTag new ]						]				].		defTag isMeta: defKey first = $%.		start := ( defTag isMeta  or: [ defTag isNameSpaceTag ] )			ifTrue: [ 2 ]  ifFalse: [ 1 ].		defTag classSymbol: ( defKey copyFrom: start to: index - 1 ) asSymbol.		pkgTags add: defTag		].	^pkgTags</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="Store-IMG-Pundles" selector="zeroTraceForAll">zeroTraceForAll	"Elimate references to database  ids- neccessary when moving to	a new database."	"TT_Registry zeroTraceForAll"	self packagesDo: [:pkg | pkg setNoTrace; markNotModified].	self  bundlesDo: [:bun | bun setNoTrace; markNotModified].</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>utilities-store</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent this component type in the database."	self subclassResponsibility</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="elementLabel:">elementLabel: hints 	"This method returns a visual component used to represent me in a  browser graph."	| lab |	lab := LabelAndIcon with: ( self stringKey: hints )				attributes: ( TextAttributes styleNamed: #systemDefault ).	lab icon: ( Store.AbstractTool iconForPundle: self ).	^lab</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>utilities-store</category><body package="Store-IMG-Pundles" selector="parcelInto:">parcelInto: aStoreParcelRecord	"Convert the parcel to binary and install in dbParcel."		| codeWriter |	codeWriter := CodeWriter new.	self prepareCodeWriter: codeWriter.	[codeWriter parcelInto: aStoreParcelRecord] 		on: CodeWriter invalidTraceSignal 		do: [:exception | Parcel invalidNamedObjectSignal raiseWith: exception parameter]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>load/unload</category><body package="Store-IMG-Pundles" selector="parcelOutToDb:">parcelOutToDb: dbParcel	"Convert the parcel to binary and install in dbParcel."	| cWriter |	cWriter := CodeWriter new.	Cursor wait showWhile: [ self prepareCodeWriter: cWriter].	[ cWriter writeForDb: dbParcel ]		on: CodeWriter invalidTraceSignal		do: [ :ex | Parcel invalidNamedObjectSignal raiseWith: ex parameter]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing-store</category><body package="Store-IMG-Pundles" selector="primaryKey">primaryKey	"unpublished"	^0</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="relatedBy:">relatedBy: token		token == #tt_derivesRel ifTrue: [^Set new].	token == #tt_derivesRRel ifTrue: [^Set with: self parentRecord].	^super relatedBy: token</body></methods><methods><class-id>Store.DatabaseConnectionInformation class</class-id> <category>instance creation</category><body package="Store-IMG-Pundles" selector="databaseId:dbTrace:">databaseId: aString dbTrace: anInteger	"Answer an instance of the receiver initialized (with a nil changeset)"	^self new		dbIdentifier: aString;		dbTrace: anInteger</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="changeSet:">changeSet: anXChangeSet	changeSet := anXChangeSet</body><body package="Store-IMG-Pundles" selector="changeSetifNone:">changeSetifNone: aBlock	^changeSet == nil		ifTrue: [ aBlock value ]		ifFalse: [ changeSet ]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="hasTrace">hasTrace	^self dbTrace notNil and: [ self dbTrace ~= 0 ]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="inspectChangeSet">inspectChangeSet		changeSet ifNil: [^Dialog warn: (#NoChangesFor1s &lt;&lt; #store &gt;&gt; 'No changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)].	changeSet inspectorClass		inspect: changeSet copy		label: (#ChangesFor1s &lt;&lt; #store &gt;&gt; 'Changes for &lt;1s&gt;' expandMacrosWith: dbIdentifier)</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="markNotModified">markNotModified	self emptyChangeSet</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="printOn:">printOn: aStream 	aStream nextPutAll: self class name asString.	aStream nextPutAll: ' ('.	dbIdentifier notNil 		ifTrue: [ aStream nextPutAll: dbIdentifier ].	aStream nextPut: $).</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="setNoTrace">setNoTrace	versionString := nil.	self dbTrace: nil.</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="traceVersion">traceVersion	"Answer a string describing a version of my trace  pundle."	^Store.DbRegistry isOnlineImage 		ifTrue: [(pundle storeForGlorpPundleClass traceVersionFor: self dbTrace) ifNil: ['']]		ifFalse: ['']</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="unhook">unhook	"Remove db identitity from the receiver."		dbTrace := nil.	dbIdentifier := nil.	versionString := nil.</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="cannotLoadComponentSignal">cannotLoadComponentSignal	^CannotLoadComponentSignal</body><body package="Store-IMG-Pundles" selector="cannotStoreComponentSignal">cannotStoreComponentSignal	^CannotStoreComponentSignal</body><body package="Store-IMG-Pundles" selector="cannotUnloadComponentSignal">cannotUnloadComponentSignal	^CannotUnloadComponentSignal</body><body package="Store-IMG-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	^Pundle componentNotFoundSignal</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>instance creation</category><body package="Store-IMG-Pundles" selector="fromBos:">fromBos: aString	"This method is used by the bos reader to create 	instances while loading a bundle."	| baby |	baby := self new.	baby fileNameString: aString.	^baby</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>parcel support</category><body package="Store-IMG-Pundles" selector="fromParcelPrerequisite:">fromParcelPrerequisite: aPreqArray	"Answer a ComponentDescription that represents the parcel prerequisite as a pundle."	"Parcel prereqs are #( name version )."	"self fromParcelPrerequisite: #( 'TestBundle876-B', '876' )"	"self fromParcelPrerequisite: #( 'TestPackage876', '876' )"	| cname version descclass |	cname := aPreqArray first.	version := aPreqArray last.	( cname copyFrom: ( cname size - 1 ) to: cname size ) = '-B'		ifTrue: 			[ descclass := BundleDescription.			cname := cname copyFrom: 1 to: ( cname size - version size - 2 ).			]		ifFalse: 			[ descclass := PackageDescription.			cname := cname copyFrom: 1 to: ( cname size - version size ).			].		^descclass new			componentName: cname;			id: version asNumber.</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>class initialization</category><body package="Store-IMG-Pundles" selector="initialize">initialize	"self initialize"	CannotLoadComponentSignal := (Object informationSignal newSignal)				notifierString: (#CannotLoadAComponent &lt;&lt; #store 							&gt;&gt; 'Cannot load a component') asString;				nameClass: self message: #cannotLoadComponentSignal.	CannotStoreComponentSignal := (Object informationSignal newSignal)				notifierString: (#CannotStoreAComponent &lt;&lt; #store 							&gt;&gt; 'Cannot store a component') asString;				nameClass: self message: #cannotStoreComponentSignal.	CannotUnloadComponentSignal := (Object informationSignal newSignal)				notifierString: (#CannotUnloadAComponent &lt;&lt; #store 							&gt;&gt; 'Cannot unload a component') asString;				nameClass: self message: #cannotUnloadComponentSignal</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="binLoadComponentFrom:">binLoadComponentFrom: anExternalHandle	self subclassResponsibility</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="dbLoadWithin:">dbLoadWithin: parentBundle	"Load the corresponding component form the database. 	If the component cannot be found just fail loading."	^self isNotLoaded and: 		[ [ | comp |		  comp := self loadFromDBWithin: parentBundle.		  comp == nil			ifTrue: [ self class cannotLoadComponentSignal raiseWith: self ]		  	ifFalse: [ self component: comp ].		  ] on: self class componentNotFoundSignal do:			[ :ex | self failLoadingWith: ex errorString ]		]</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="descriptionsAndLevels">descriptionsAndLevels	"Answer a collection of pairs. The first element is the description	the second is level (zero)."	| comp |	comp := self component.	^comp isNil 		ifTrue: [#()]		ifFalse: [OrderedCollection with: (Array with: self with: 1)]</body><body package="Store-IMG-Pundles" selector="externalHandle">externalHandle	self subclassResponsibility</body><body package="Store-IMG-Pundles" selector="externalHandleForStorage">externalHandleForStorage	self subclassResponsibility</body><body package="Store-IMG-Pundles" selector="failLoadingWith:">failLoadingWith: anErrorString	self class cannotLoadComponentSignal raiseErrorString: anErrorString</body><body package="Store-IMG-Pundles" selector="fileName">fileName	^fileName</body><body package="Store-IMG-Pundles" selector="fileName:">fileName: aFilename	fileName := aFilename tail.</body><body package="Store-IMG-Pundles" selector="fileNameString:">fileNameString: aString	fileName := aString</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="isComponentLoaded">isComponentLoaded	"Answer true if the actual component is already	loaded into the image."	^self component notNil</body><body package="Store-IMG-Pundles" selector="isInCurrentDatabase">isInCurrentDatabase	^#{Store.DbRegistry}		ifDefinedDo: [:registry | registry notNil and: [registry dbIdentifier = self dbIdentifier]]		elseDo: [false]</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="isNotLoaded">isNotLoaded	"Answer true if there is no compatible version of the component 	already loaded into the image."	^self exactLoadedComponent isNil</body><body package="Store-IMG-Pundles" selector="publishComponent">publishComponent	"Publish the component I hold onto and modify my description	to reflect changes."	| comp | 	comp := self component.	comp storeInDB.	id := comp dbTrace.</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="representBinaryOn:">representBinaryOn: binWriter	"When we store description we only need to know the	type of the component and the file name used for storage."	^MessageSend				receiver: self class				selector: #fromBos:				arguments: (Array with: fileName)</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="updateVersion">updateVersion	"The underlying component has been published. 	Update my data to reflect this change."	| comp |	comp := self component.	comp == nil 		ifFalse: 	[ id := comp dbTraceFor: dbIdentifier ]</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="binLoadFromDB:within:">binLoadFromDB: aKey within: parentBundle 	"Given a primary key get the instance of a database pundle from the database."	| dbRec |	[dbRec := self databaseClass aRecordWithID: aKey] on: self errorSignals		do: 			[:ex | 			ex outer.			^nil].	dbRec isNil 		ifTrue: 			[self componentNotFoundSignal 				raiseErrorString: ((#CannotLoacateA1sWithID2p &lt;&lt; #store &gt;&gt; 'Cannot loacate a &lt;1s&gt; with ID = &lt;2p&gt;') 						expandMacrosWith: self descriptionString						with: aKey)].	^self loadFromDB: dbRec within: parentBundle</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>constants</category><body package="Store-IMG-Pundles" selector="databaseClass">databaseClass	^Bundle</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-utilities</category><body package="Store-IMG-Pundles" selector="loadFromDB:asDiffTo:within:">loadFromDB: aDBBundle asDiffTo: anImBundle within: parentBundle	"Load bundle content from the database but first calculate the difference between aDBBundle and a version of me loaded into the image."	| baby pundlesToUnload |	anImBundle runPreUnload: true.	baby := self named: aDBBundle name.	baby		initializeFromDB: aDBBundle;		initializeFromImage: anImBundle for: DbRegistry dbIdentifier;		loadContentsFromDBWithin: parentBundle.	pundlesToUnload := (anImBundle pundlesNotIn: baby or: parentBundle) select:		[:any | (any onlyReferencedBy: anImBundle) and: [baby shouldProceedToUnload: any]].	pundlesToUnload do: [:each | each unloadFromImage].	^baby</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="loadFromDB:within:">loadFromDB: aDBBundle within: parentBundle	"Given a published bundle create a new bundle model and load the contents. 	Answer the new bundle or nil."		| imgBundle storeBundle |	DbRegistry useAtomicLoader		ifTrue:			[(storeBundle := aDBBundle glorpReconciledVersion) ifNil: [^nil].			^storeBundle loadSource]		ifFalse: [aDBBundle checkPrerequisites ifFalse: [^nil]].	aDBBundle runPreRead ifFalse: [^nil].	imgBundle := Registry bundleNamed: aDBBundle name.	imgBundle := imgBundle == nil		ifTrue:			[aDBBundle runPreLoad.			self loadNewFromDB: aDBBundle within: parentBundle]		ifFalse: [self loadFromDB: aDBBundle asDiffTo: imgBundle within: parentBundle].	imgBundle == nil		ifFalse:			[imgBundle				dbTrace: aDBBundle primaryKey;				runPostLoad;				markNotModified].	^imgBundle</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-utilities</category><body package="Store-IMG-Pundles" selector="loadNewFromDB:within:">loadNewFromDB: aDBBundle  within: parentBundle	"Load bundle content from the database. 	There is no existing version of me loaded into the image."	| baby |	baby := self named: aDBBundle name.	baby initializeFromDB: aDBBundle.	baby loadContentsFromDBWithin: parentBundle.	^baby</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-instance creation</category><body package="Store-IMG-Pundles" selector="newFromBinFile:">newFromBinFile: aFilename 	"Create new instance and initilaize it form data stored in	the bos file. Do not load components."		| bos baby |	bos := BinaryObjectStorage onOld: aFilename asFilename readStream.	[baby := self readFrom: bos]		ensure: [bos close].	^baby</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="newFromDB:within:">newFromDB: aDBBundle within: parentBundle	"Given a published bundle create a new bundle model and load the contents as part of a larger whole.	Answer either the new bundle or nil."	( LoadDialog okToLoadBundle: aDBBundle ) 		ifFalse: [ ^nil ].	^[ self loadFromDB: aDBBundle within: parentBundle ]  on: self emergencyUnloadSignal do: 		[ :ex | ex return: nil ]</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>constants</category><body package="Store-IMG-Pundles" selector="storeDatabaseClass">storeDatabaseClass	^Store.Glorp.StoreBundle</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="addFile:">addFile: aFileDescription	"Add a external file to the receiver."	dbInfo isEmpty		ifTrue: [ self databaseInformationForOrCreate: self noDbSymbol ].	self databaseInformationsDo:		[ : info | info addFileDescription: aFileDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="adjustComponents">adjustComponents	"Iterate over description and make sure that	the names of components are OK.	Descriptions for which components were loaded have	names not set up/"	self databaseInformation adjustComponents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="anyFileDescriptions">anyFileDescriptions	"Answer a collection of file descriptors for any database connection"	dbInfo isEmpty		ifTrue: [ ^ OrderedCollection new ].	dbInfo size &gt; 1 		ifTrue: [ dbInfo removeKey: self noDbSymbol ifAbsent: nil ].	^dbInfo values first fileDescriptions collect:		[ :desc |		desc copy			yourself		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^Bundles new"		expressionStr: condition; "	" not being used"		subBundleRef: self dbTrace		yourself</body><body package="Store-IMG-Pundles" selector="canReplaceVersions">canReplaceVersions	super canReplaceVersions ifFalse: [^false].	^self containedItems allSatisfy: #canReplaceVersions</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="changedItemCount">changedItemCount	"Answer a count of work to be done for filing out changes."	^self contents inject: 1 into:		[ :sz :pun | 		pun == nil			ifTrue: [ sz ]			ifFalse: [ sz + pun changedItemCount ]		].</body><body package="Store-IMG-Pundles" selector="changedItemCountFor:">changedItemCountFor: dbid	"Answer a count of work to be done for filing out changes."	^self contents inject: 1 into:		[ :sz :pun | 		pun == nil			ifTrue: [ sz ]			ifFalse: [ sz + ( pun changedItemCountFor: dbid ) ]		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent bundles in the database."	^Bundle</body><body package="Store-IMG-Pundles" selector="comparePackages:">comparePackages: aBundle	"Compare all packages that I contain with	packages that are contained by aBundle."</body></methods><methods><class-id>Store.BundleModel</class-id> <category>compaisons</category><body package="Store-IMG-Pundles" selector="comparesTo:">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isBundle and: [ name = aCodeComponent name ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="computeDifferencesBetween:into:">computeDifferencesBetween: aBundle into: aComparitor 	"Since I am a Bundle, I have no non property differences."		^aComparitor</body><body package="Store-IMG-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aBundle into: aComparitor	"Since the receiver is a loaded package an argument aBundle	has to be a DB packagge."		[aComparitor reverse.	self computeDiffsBetweenDBBundle: aBundle into: aComparitor] 		ensure: [aComparitor reverse].	^aComparitor</body><body package="Store-IMG-Pundles" selector="computeDiffsBetweenDBBundle:into:">computeDiffsBetweenDBBundle: aBundle into: diffHolder	diffHolder methodsSide: 2 put: OrderedCollection new.	diffHolder methodsSide: 1 put: OrderedCollection new.	diffHolder dataSide: 2 put: OrderedCollection new.	diffHolder dataSide: 1 put: OrderedCollection new.	diffHolder classesSide: 2 put: OrderedCollection new.	diffHolder classesSide: 1 put: OrderedCollection new.	diffHolder metaSide: 2 put: OrderedCollection new.	diffHolder metaSide: 1 put: OrderedCollection new.	diffHolder nameSpacesSide: 2 put: OrderedCollection new.	diffHolder nameSpacesSide: 1 put: OrderedCollection new.	^diffHolder</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-repository storage</category><body package="Store-IMG-Pundles" selector="dbContent">dbContent	"Convert my component descriptions into a collection of database components."	^self contentDescriptions collect: 		[ :each | each asDBDescription ]</body><body package="Store-IMG-Pundles" selector="dbContentPundleFragments:">dbContentPundleFragments: aCollection	"Convert my component descriptions into a collection of database components,	using any existing fragments when they exist in aCollection"	^self contentDescriptions collect: 		[ :each | 		( aCollection detect: 			[ :pundle | each describesSameAs: pundle ] ifNone: [ each ]		) asDBDescription		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="dbLoadComponentsWithin:">dbLoadComponentsWithin: parentBundle	"Load all components from the DB.	If there is a problem while loading one of the components show  dialog and either fail loading 	this bundle and the encloasing bundles or continue."	self contentDescriptions do: 		[ :comp | 		[ comp dbLoadWithin: parentBundle ] on:  self class abortLoadingSignal do:			[ :ex | 			( self dialogForException: ex ) = #abort 				ifTrue: [ self class emergencyUnloadSignal raise ].			ex return			]		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="emergencyUnload">emergencyUnload	"One of the components failed to load 	unload all compopnents loaded up to this point."	self contents reverseDo: 		[ :comp | comp notNil 					ifTrue: [ comp unloadFromGroup: self ] 		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="fileDescriptions">fileDescriptions	"Answer a collection of FileModels for any files that are associated with the current/last database connection."	| dbinfo |	^( dbinfo := self databaseInformation ) == nil		ifTrue: [ self anyFileDescriptions ]		ifFalse: [ dbinfo fileDescriptions ].</body><body package="Store-IMG-Pundles" selector="fileDescriptions:">fileDescriptions: aCollectionOfFileModels	"Set my files to be aCollectionOfFileModels."	( self databaseInformationOrCreate )		fileDescriptions: aCollectionOfFileModels.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="fileOutChangesForDb:on:within:">fileOutChangesForDb: aSymbol on: aStream within: aBundle	"Write out all the changes the receiver knows about."		(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse: 		[self fileOutChangedPropertiesForDb: aSymbol on: aStream].	self containedItems do: [:each | each fileOutChangesForDb: aSymbol on: aStream within: aBundle]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="Store-IMG-Pundles" selector="fileOutChangesOn:">fileOutChangesOn: aFileManager 	Notice 		showProgress: (#FilingOutChangesFor1s &lt;&lt; #store 				&gt;&gt; 'Filing out changes for &lt;1s&gt;' expandMacrosWith: name)		complete: self changedItemCount		while: [self fileOutChangesOn: aFileManager within: self]		title: (#Store &lt;&lt; #store &gt;&gt; 'Store') asString</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="fileOutChangesOn:within:">fileOutChangesOn: aStream within: aBundle	"Write out all the changes the receiver knows about."		| changeSet |	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse: 		[self fileOutChangedPropertiesOn: aStream].	self containedItems do: [:each | each fileOutChangesOn: aStream within: aBundle].	(StoreSettings preferenceFor: #fileoutOption) == #never ifFalse:		[changeSet := self changeSet.		(changeSet otherChangesInclude: self structureMark) ifTrue: 			[(BundleStructureChange new component: self) fileOutOn: aStream]]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>initialize-release</category><body package="Store-IMG-Pundles" selector="initializeForReconcileWith:">initializeForReconcileWith: aDbBundle	"Ensure that the receiver is set up for the current database.  Do not inline the descs and fdescs temporaries: their values must be obtained before the databaseInformation for the current database is created."	| descs fdescs |	self databaseInformation == nil ifFalse: [ ^self ].	descs := self anyContentDescriptions.		"do not inline this assignment"	fdescs := self anyFileDescriptions.			"do not inline this assignment"	self databaseInformationOrCreate 		contentDescriptions: descs;		fileDescriptions: fdescs;		dbTrace: ((aDbBundle == nil) ifFalse: [aDbBundle primaryKey]).</body><body package="Store-IMG-Pundles" selector="initializeFromDB:">initializeFromDB: aStoreBundle		self properties: aStoreBundle properties.	self comment: aStoreBundle commentOrNil.	self databaseInformationOrCreate contentDescriptions: 		(aStoreBundle containedItems collect: [:each | each asComponentDescription]).	self databaseInformation fileDescriptions: 		(aStoreBundle files collect: [:each | each asComponentDescription bundle: self]).	dbInfo removeKey: self noDbSymbol ifAbsent: [nil]</body><body package="Store-IMG-Pundles" selector="initializeFromImage:">initializeFromImage: anImgBundle	"We have already initialized the current database information in the image model from the database for the version we are about to load. Now we move over that database info's structural data from anImgBundle to the other database informations, so that all will reflect the (about-to-be) loaded structure of the bundle."	anImgBundle databaseInformationsDo:		[:info | info isInCurrentDatabase ifFalse:			[dbInfo at: info dbIdentifier put:				(info resetContentsFrom: self databaseInformation)]].</body><body package="Store-IMG-Pundles" selector="initializeFromImage:for:">initializeFromImage: anImgBundle for: aSymbol	"We have just loaded or published a database version to which this image model is now being synchronised.  We have already synchronised the aSymbol database information in anImgBundle (which in typical calls will be identical to self, but we pass it as a parameter for flexibility).  Now we move over that database info's structural data to the other database informations, so that all will reflect the structure of the bundle."	anImgBundle ifNil: [^self].	anImgBundle databaseInformationsDo:		[:info | info dbIdentifier = aSymbol ifFalse:			[dbInfo at: info dbIdentifier put:				(info resetContentsFrom: (self databaseInformationFor: aSymbol))]]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="loadContentsFromDBWithin:">loadContentsFromDBWithin: parentBundle	"At this moment, descriptions are initialized I have to load components."	[ self dbLoadComponentsWithin: parentBundle.	self adjustComponents	] on: self class emergencyUnloadSignal do:		[:ex | 		self emergencyUnload.		ex pass		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="modifications">modifications	"Answer my content as a collection of modifications in order."	| mods |	mods := List new.	self leafItems do:		[ :pkg | mods addAll: pkg modifications ].	^mods</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	^BundleChanges</body></methods><methods><class-id>Store.BundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="reconcileWithDb:">reconcileWithDb: aPundleOrStorePundle	"Change the receiver to reflect dbPundle as it's parent."		| storePundle |	storePundle := aPundleOrStorePundle asStorePundle.	self initializeForReconcileWith: storePundle.	super reconcileWithDb: storePundle.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="relatedBy:">relatedBy: token		token == #tt_containsRel ifTrue: [^self contents asSet].	^super relatedBy: token</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="removeFile:">removeFile: aFileDescription	self databaseInformationsDo:		[ :info | info removeFile: aFileDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-validation</category><body package="Store-IMG-Pundles" selector="removeNonexistentComponentsRecursive">removeNonexistentComponentsRecursive	self databaseInformationsDo:		[ :info | info removeNonexistentComponentsRecursive ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>parcel support</category><body package="Store-IMG-Pundles" selector="saveAsParcelFromSpecs:">saveAsParcelFromSpecs: publishSpec	"Save the receiver as a parcel -without creating the parcel in the image.	specs fullPathName is a directory/parcelName with no extension.	If specs bundleStructure is true, fill in the bundleStructure property with bundle/package contents.	If specs databaseLinks is true, save the db links for every component."		| dir link pname |	link := publishSpec databaseLinks.	link &amp; self hasBeenModified		ifTrue:			[(BundleHasUnpublisedChangesConfirmation raiseRequestErrorString: name) ifFalse: [^self].			link := false].	pname := publishSpec basePath asFilename tail.	dir := publishSpec basePath asFilename directory.	dir exists		ifFalse:			[(CreateParcelDirectoryConfirmation raiseRequestErrorString: dir asString) ifFalse: [^self].			dir makeDirectory].	properties		at: #bundleName put: self name;		at: #parcelName put: pname.	publishSpec bundleStructure ifTrue: [properties at: #bundleStructure put: (PundleForParcel from: self saveLinks: link)].	[self 		parcelOutTo: (dir construct: pname , '.pcl') asString 		sourceFileName: (dir construct: pname , '.pst') asString 		parcelOptions: publishSpec]			ensure:				[properties					removeKey: #bundleStructure ifAbsent: [];					removeKey: #bundleName ifAbsent: []]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="setNewTraceTo:">setNewTraceTo: dbPundle	"Change the receiver to reflect dbPundle as it's parent."			| dbItems |	super reconcileWithDb: dbPundle.	dbItems := dbPundle containedItems.	self contentDescriptions do:		[ :desc |  | match item |		item := desc component.		( item dbTrace == nil or: [ item dbTrace == 0 ] )			ifTrue:				[				( match := dbItems 					detect: 						[ :dbitem |  						( ( item isBundle == dbitem isBundle ) and: [ item name = dbitem name ] )						]					ifNone: [ nil ] ) == nil						ifFalse: 							[ item setNewTraceTo: match.							desc  id: item dbTrace.	"so we match"								].				].		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="shouldProceedToUnload:">shouldProceedToUnload: aPundle	"We find out if the new bundle might have as a prereq the passed in package or bundle.	We start off with no, don't.	Then we go over my prereqs. If the passed in package or bundle name is the same as a prereq name,	and the details of the version are the same (or not specified) we say, continue with don't.	If the details are NOT the same, we say DO, which will allow the package or bundle passed in to be unloaded"	| prerequisites |	prerequisites := self prerequisiteDescriptions.	(prerequisites isNil or: [prerequisites isEmpty]) ifTrue: [^true].	^prerequisites anySatisfy: 			[:each |			| target eachPrerequisiteName |			eachPrerequisiteName := each name.			aPundle name = eachPrerequisiteName and: 					[target := (Registry bundleNamed: aPundle name)								ifNil: [Registry packageNamed: aPundle name].					target notNil						ifTrue: 							[| block |							block := CodeComponent asActionBlock: self versionSelectionBlock.							block isNil								ifTrue: 									[each versionFilter notEmpty										and: [target traceVersion ~= each versionFilter]]								ifFalse: 									[(block										value: eachPrerequisiteName										value: target traceVersion										value: each versionFilter) not]]]]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-repository storage</category><body package="Store-IMG-Pundles" selector="storeInDB">storeInDB	"Open a dialog that will let us store into the database all components that have been modified and the bundle description.  Return the dialog if we succeed in opening it (lets callers prep values further if needed), self if not.  Accepting the dialog stores into DB and empties the change set."		Undeclared purgeUnusedBindings.	self removeNonexistentComponentsRecursive.	self shouldSaveIfNotNewestVersion ifFalse: [^self].	^PublishPundleDialog publishBundle: self</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForBundles</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>utility storage</category><body package="Store-IMG-Pundles" selector="parcelInto:">parcelInto: aStoreParcelRecord 	"Store the parcel to a database record.  Answer true if successful."	| success |	((properties at: #packageName ifAbsent: [nil]) notNil and: [(properties at: #name) = (properties at: #packageName)])		ifFalse: [properties at: #name put: (properties at: #packageName)].	analysisTracer trace: properties.	self traceNamedObjects.	newSourceKeys := IdentityDictionary new: analysisTracer compiledMethodCount * 3 // 2.	self createInternalSourceStreams.	hideOnLoad := false.	success := true.	[ self allocate.	self layout.	self storePackage.	stream close.	sourceStream close.	aStoreParcelRecord privateSetBlob: (Store.Glorp.StoreBinaryBlob forByteArray: stream contents).	aStoreParcelRecord privateSetSource: (Store.Glorp.StoreBinaryBlob forByteArray: sourceStream targetFile stream contents) 	] ifCurtailed: [ success := false ].	^success</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="writeForDb:">writeForDb: dbParcel 	"Store the parcel to a database record.  Answer true if successful."	| success |	analysisTracer trace: properties.	self traceNamedObjects.	newSourceKeys := IdentityDictionary new: analysisTracer compiledMethodCount * 3 // 2.	self createInternalSourceStreams.	hideOnLoad := false.	success := true.	[ self allocate.	self layout.	self storePackage.	stream close.	sourceStream close.	dbParcel blobData: stream contents.	dbParcel sourceData: sourceStream targetFile stream contents 	] ifCurtailed: [ success := false ].	^success</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="binLoadFromDB:within:">binLoadFromDB: aKey within: parentBundle 	"Given a primary key get the instance of TT_Package 	from the database and load the new version."	| dbPkg |	[dbPkg := self databaseClass aRecordWithID: aKey] on: self errorSignals		do: 			[:ex | 			ex outer.			^nil].	dbPkg isNil 		ifTrue: 			[self componentNotFoundSignal 				raiseErrorString: (#CannotLocateAPackageWithID1p &lt;&lt; #store 						&gt;&gt; 'Cannot locate a package with ID = &lt;1p&gt;' expandMacrosWith: aKey)].	^dbPkg loadSrcWithin: parentBundle warnReplace: false</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>constants</category><body package="Store-IMG-Pundles" selector="databaseClass">databaseClass	^Package</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="describeBOSS:on:">describeBOSS: p on: strm 	| lines |	self shouldNotImplement.	"FOR REFERENCE ONLY"	lines := 0.	p first size &gt; 0 		ifTrue: 			[strm 				nextPutAll: (#ThisPackageContainsTheClasses &lt;&lt; #store &gt;&gt; 'This package contains the classes:') asString.			p first do: 					[:clsName | 					strm nextPut: Character cr.					lines := lines + 1.					lines &gt; 10 						ifTrue: 							[strm nextPutAll: '...'.							^self].					strm nextPutAll: '   '.					strm nextPutAll: clsName].			strm nextPut: Character cr.			strm nextPut: Character cr].	strm nextPutAll: (#ThisPackageContainsTheMethods &lt;&lt; #store &gt;&gt; 'This package contains the methods: ').	(p at: 2) do: 			[:sel | 			strm nextPut: Character cr.			lines := lines + 1.			lines &gt; 10 				ifTrue: 					[strm nextPutAll: '...'.					^self].			strm nextPutAll: '   '.			strm nextPutAll: sel className.			strm nextPutAll: '&gt;&gt;'.			strm nextPutAll: sel selector]</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>constants</category><body package="Store-IMG-Pundles" selector="storeDatabaseClass">storeDatabaseClass	^Store.Glorp.StorePackage</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>utilities</category><body package="Store-IMG-Pundles" selector="zeroTraceForAll">zeroTraceForAll	"self zeroTraceForAll"	Registry packagesDo: [:pkg | pkg setNoTrace].	Registry bundlesDo: [:bun | bun setNoTrace].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^( Packages new )"		expressionStr: condition; "	" not being used"		packageRef: self dbTrace;		yourself.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="changedItemCount">changedItemCount	"Answer a count of work to be done for filing out changes	from the current database."	^self changeSet == nil		ifTrue: [ 0 ]		ifFalse: [ self changeSet itemCount ]</body><body package="Store-IMG-Pundles" selector="changedItemCountFor:">changedItemCountFor: dbid	"Answer a count of work to be done for filing out changes from the indicated database."	| cs |	^( cs := self changeSetFor: dbid ) == nil		ifTrue: [ 0 ]		ifFalse: [ cs itemCount ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>public-change set access</category><body package="Store-IMG-Pundles" selector="changedMessageList">changedMessageList	^self changedMessageListFor: DbRegistry dbIdentifier</body><body package="Store-IMG-Pundles" selector="changedMethodList">changedMethodList	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet modifiedMethodDescriptors  ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="changeSetClassDifferencesBetweenDBPackage:into:">changeSetClassDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Compute differences between me and my trace package. 	Use change set."		| otherClasses mainClasses mainNamespaces otherNamespaces |	otherNamespaces := self affectedNameSpaceNames.	mainNamespaces := Set new: otherNamespaces size.	otherClasses := self affectedClassNamesMeta: false.	mainClasses := Set new: otherClasses size.	aStorePackage notNil		ifTrue:			[otherNamespaces				do:					[:each | 					| storeNameSpace |					storeNameSpace := aStorePackage nameSpaceInPackageNamed: each.					storeNameSpace notNil ifTrue: [mainNamespaces add: storeNameSpace]].			otherClasses				do:					[:each | 					| storeClass |					storeClass := aStorePackage classInPackageNamed: each meta: false.					storeClass notNil ifTrue: [mainClasses add: storeClass]].			self removedClassOrDefinitionNames				do:					[:each | 					| storeClass |					storeClass := aStorePackage classInPackageNamed: each meta: false.					storeClass notNil ifTrue: [mainClasses add: storeClass]].			self removedNameSpaceOrDefinitionNames				do:					[:each | 					| storeNameSpace |					storeNameSpace := aStorePackage nameSpaceInPackageNamed: each.					storeNameSpace notNil ifTrue: [mainNamespaces add: storeNameSpace]]].	aPackageComparitor otherPackageNamespaces: (otherNamespaces collect: [:each | (NameSpaceDescriptor new fullName: each) asStoreNameSpace]).	aPackageComparitor mainPackageNamespaces: mainNamespaces.	aPackageComparitor otherPackageClasses: (otherClasses collect: [:each | (ClassDescriptor fullName: each meta: false) asStoreClassDefinition]).	aPackageComparitor mainPackageClasses: mainClasses</body><body package="Store-IMG-Pundles" selector="changeSetClassDiffsBetweenDBPackage:into:">changeSetClassDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	| classes2 classes1 meta2 meta1 namespaces1 namespaces2 |	namespaces2 := self affectedNameSpaceNames.	namespaces1 := Set new: namespaces2 size.	classes2 := self affectedClassNamesMeta: false.	classes1 := Set new: classes2 size.	meta2 := self affectedClassNamesMeta: true.	meta1 := Set new: meta2 size.	aTracePackage notNil		ifTrue: 			[ namespaces2 do: 				[: nsName | | nsDb |				nsDb := aTracePackage nameSpaceInPackageNamed: nsName.				nsDb notNil ifTrue: [ namespaces1 add: nsDb ]				].			classes2 do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: false.				cdb notNil ifTrue: [ classes1 add: cdb ]				].			meta2 do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: true.				cdb notNil ifTrue: [meta1 add: cdb]				].			self removedClassOrDefinitionNames do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: false.				cdb notNil ifTrue: [ classes1 add: cdb ].				cdb := aTracePackage classInPackageNamed: cName meta: true.				cdb notNil ifTrue: [ meta1 add: cdb ]				].			self removedNameSpaceOrDefinitionNames do: 				[ :nsName | | cdb |				cdb := aTracePackage nameSpaceInPackageNamed: nsName.				cdb notNil ifTrue: [ namespaces1 add: cdb ].				]			].	diff nameSpacesSide: 2 put: ( namespaces2 collect: [:cName | NameSpaceDescriptor new fullName: cName ] ).	diff nameSpacesSide: 1 put: namespaces1.	diff classesSide: 2 put: ( classes2 collect: [:cName | ClassDescriptor fullName: cName meta: false ] ).	diff classesSide: 1 put: classes1.	diff metaSide: 2 put: (meta2 collect: [:cName | ClassDescriptor fullName: cName meta: true ] ).	diff metaSide: 1 put: meta1.</body><body package="Store-IMG-Pundles" selector="changeSetDataDifferencesBetweenDBPackage:into:">changeSetDataDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Compute differences between me and my trace package. 	Use change set."	"Get all modified data."		| otherShareds mainShareds |	otherShareds := self modifiedDatumDescriptors.	mainShareds := Set new: otherShareds size.	aStorePackage notNil		ifTrue:			[otherShareds				do:					[:each | 					| storeShared |					storeShared := aStorePackage datum: each dataKey forOwnerNamed: each ownerName.					storeShared notNil ifTrue: [mainShareds add: storeShared]].			self removedDatumDescriptors				do:					[:each | 					| storeShared |					storeShared := aStorePackage datum: each dataKey forOwnerNamed: each ownerName.					storeShared == nil ifFalse: [mainShareds add: storeShared]]].	aPackageComparitor otherPackageShareds: (otherShareds collect: [:each | each asStoreSharedVariable]).	aPackageComparitor mainPackageShareds: (mainShareds collect: [:each | each asStoreSharedVariable]).</body><body package="Store-IMG-Pundles" selector="changeSetDataDiffsBetweenDBPackage:into:">changeSetDataDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	"Get all modified data."	| data2 data1 |	data2 := self modifiedDatumDescriptors.	data1 := Set new: data2 size.	aTracePackage notNil		ifTrue: 			[ data2 do: 				[:dd | | ddb |				ddb := aTracePackage datum: dd dataKey forOwnerNamed: dd ownerName.					ddb notNil ifTrue: [ data1 add: ddb ]			].			self removedDatumDescriptors do: 				[ :dd | 	| ddb |				ddb := aTracePackage datum: dd dataKey forOwnerNamed: dd ownerName.				ddb == nil ifFalse: [ data1 add: ddb ]				]			].		"At this point data1 contains data that are only in a trace package 	and data2 data that are only the receiver."	diff dataSide: 2 put: data2.	diff dataSide: 1 put: data1.</body><body package="Store-IMG-Pundles" selector="changeSetDifferencesBetweenDBPackage:into:">changeSetDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor 	"Compute differences between me and my trace package. 	Use change set."	self changeSetClassDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor.	self changeSetMethodDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor.	self changeSetDataDifferencesBetweenDBPackage: aTracePackage into: aPackageComparitor.	self computeOverrideDiffsBetweenDBPackage: aTracePackage into: aPackageComparitor.	^aPackageComparitor</body><body package="Store-IMG-Pundles" selector="changeSetDiffsBetweenDBPackage:into:">changeSetDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	self changeSetClassDiffsBetweenDBPackage: aTracePackage into: diff.	self changeSetMethodDiffsBetweenDBPackage: aTracePackage into: diff.	self changeSetDataDiffsBetweenDBPackage: aTracePackage into: diff.	self computeOverrideDiffsBetweenDBPackage: aTracePackage into: diff.	^diff</body><body package="Store-IMG-Pundles" selector="changeSetMethodDifferencesBetweenDBPackage:into:">changeSetMethodDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Compute differences between me and my trace package. 	Use change set."	"Get all modified methods."		| otherMethods mainMethods |	otherMethods := self modifiedAndReorganizedMethodDescriptors.	mainMethods := Set new: otherMethods size.	aStorePackage notNil ifTrue:		[otherMethods do:			[:each | 			| storeMethodInPackage |			storeMethodInPackage := aStorePackage 				method: each selector 				forClassNamed: each className asClassNameOnly 				meta: each isMeta.			storeMethodInPackage notNil ifTrue: [mainMethods add: storeMethodInPackage definition]].		self removedMethodDescriptors do:			[:each | 			| storeMethodInPackage |			storeMethodInPackage := aStorePackage 				method: each selector 				forClassNamed: each className asClassNameOnly 				meta: each isMeta.			storeMethodInPackage notNil ifTrue: [mainMethods add: storeMethodInPackage definition]]].	aPackageComparitor otherPackageMethods: (otherMethods collect: [:each | each asStoreMethodDefinition]).	aPackageComparitor mainPackageMethods: mainMethods</body><body package="Store-IMG-Pundles" selector="changeSetMethodDiffsBetweenDBPackage:into:">changeSetMethodDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	"Get all modified methods."	| meth2 meth1 | 	meth2 := self modifiedAndReorganizedMethodDescriptors.	meth1 := Set new: meth2 size.	aTracePackage notNil		ifTrue: 			[ meth2 do: 				[ :md | | mdb |				mdb := aTracePackage							method: md selector							forClassNamed: md className asClassNameOnly							meta: md isMeta.				mdb notNil ifTrue: [ meth1 add: mdb ]				].			self removedMethodDescriptors do: 				[ :md | | mdb |				mdb := aTracePackage							method: md selector							forClassNamed: md className asClassNameOnly							meta: md isMeta.				mdb notNil ifTrue: [ meth1 add: mdb ]				]			].		"At this point meth1 contains methods that are only in a trace package 	and meth2 methods that are only the receiver."	diff methodsSide: 2 put: meth2.	diff methodsSide: 1 put: meth1.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>consistency checking</category><body package="Store-IMG-Pundles" selector="checkConsistencyOn:">checkConsistencyOn: aStream 	self cleanse.	self isChangeSetEmpty 		ifFalse: [self changeSet checkConsistencyInPackage: self on: aStream].	self modelsDo: 			[:model | 			(Registry modelsForSymbol: model absoluteSymbol) 				detect: [:aModel | aModel == model]				ifNone: 					[aStream nextPutAll: ((#model1sInPackagIsNotRegisteredN &lt;&lt; #store &gt;&gt; 'model "&lt;1s&gt;" in package &lt;1p&gt; is not registered&lt;n&gt;') 								expandMacrosWith: model absoluteSymbol								with: self)]]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-consistency checking</category><body package="Store-IMG-Pundles" selector="checkIfPublishedIsEqual">checkIfPublishedIsEqual	"Test is the published version contains exactly the same definitions."	| diff myParent |	myParent := self parentRecord.	myParent == nil 		ifTrue: 			[(myParent := Package mostRecentVersionOfPundleWithName: name) == nil 				ifFalse: [self dbTrace: myParent primaryKey]].	myParent notNil 		ifTrue: 			[Notice 				show: (#ComparingVersionsOfPackage1s &lt;&lt; #store 						&gt;&gt; 'Comparing versions of package &lt;1s&gt;.' expandMacrosWith: self name)				while: 					[diff := PackageDifferences new.					diff						pkgSide: 2 put: self;						pkgSide: 1 put: myParent.					self computeFullDiffsBetweenDBPackage: myParent into: diff]].	^diff</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="classListForPackage">classListForPackage	^self definedClassModels collect: [:cm| cm actualClass]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent packages in the database."	^Package</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="compiledMethods">compiledMethods	| comp |	comp := OrderedCollection new.	self classModelsDo: [:cm| comp addAll: cm compiledMethods].	^comp</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aPackage into: aComparitor 	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[aComparitor reverse.	self computeDiffsBetweenDBPackage: aPackage into: aComparitor]		ensure: [aComparitor reverse].	^aComparitor</body><body package="Store-IMG-Pundles" selector="computeDiffsBetweenDBPackage:into:">computeDiffsBetweenDBPackage: aDBPackage into: diff	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number-2 since this method	is called with arguments reversed.	The comparison is done in two steps. First we compare,	image with trace and then we compare trace	with aDBpackage and combine the restults."	|  tracePkg diff2| 	"If aDB package is a pseudo package use change set only"	(aDBPackage pseudoPackage) 		ifTrue: [^self changeSetDiffsBetweenDBPackage: aDBPackage into: diff].	((self otherChangesInclude: self parentChangedMark) 			or: [(tracePkg := self tracePackage) isNil  					or: [self userWantsFullCompare]])		ifTrue: 			["I do not have a parent package do the full comparison"			^self computeFullDiffsBetweenDBPackage: aDBPackage into: diff].	"Calculate differences between me and the trace."	self changeSetDiffsBetweenDBPackage: tracePkg into: diff.	(aDBPackage sameAs: tracePkg) 		ifTrue: ["We are done" ^self].	"Now calculate differences between my trace and aDBPackage." 	diff2 := PackageDifferences with: aDBPackage with: tracePkg. 	diff combineDiffsFrom: diff2.	^diff</body><body package="Store-IMG-Pundles" selector="computeFullDiffsBetweenDBPackage:into:">computeFullDiffsBetweenDBPackage: aDBPackage into: diff 	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number2 since this method	is called with arguments reversed."	| coll1 coll2 |	"methods"	coll1 := aDBPackage methodsWithSource asSet.	coll2 := OrderedCollection new: coll1 size.	self methods 		do: [:method | coll1 remove: method ifAbsent: [coll2 add: method]].	"At this point coll1 contains methods that are only in aDBPackage	and coll2 methods that are only the receiver."	diff methodsSide: 2 put: coll2.	diff methodsSide: 1 put: coll1.	"data"	coll1 := aDBPackage data asSet.	coll2 := OrderedCollection new: coll1 size.	self data do: [:datum | coll1 remove: datum ifAbsent: [coll2 add: datum]].	"At this point coll1 contains data that are only in aDBPackage	and coll2 data that are only the receiver."	diff dataSide: 2 put: coll2.	diff dataSide: 1 put: coll1.	"namespaces"	coll1 := aDBPackage nameSpacesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self nameSpacesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff nameSpacesSide: 2 put: coll2.	diff nameSpacesSide: 1 put: coll1.	"classes"	coll1 := aDBPackage classesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self classesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff classesSide: 2 put: coll2.	diff classesSide: 1 put: coll1.	coll1 := aDBPackage metaclassesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self metaclassesDefinedInPackage 		do: [:x | coll1 remove: x ifAbsent: [coll2 add: x]].	diff metaSide: 2 put: coll2.	diff metaSide: 1 put: coll1.	self computeOverrideDiffsBetweenDBPackage: aDBPackage into: diff.	^diff</body><body package="Store-IMG-Pundles" selector="computeOverrideDiffsBetweenDBPackage:into:">computeOverrideDiffsBetweenDBPackage: aTracePackage into: diff 	"Add overriden stuff to diff. Valid for all methods of calculation"	self overrides do:		[ :over | over addDiffTo: aTracePackage into: diff ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="currentTag">currentTag 	^self class currentTag</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="Store-IMG-Pundles" selector="fileOutChangesOn:within:">fileOutChangesOn: aFileManager within: aBundle	self fileOutChangesForDb: DbRegistry dbIdentifier on: aFileManager within: aBundle</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="indexTag">indexTag	^self class indexTag</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="isSaveable">isSaveable	"Answer true if ok to save"	"NOTE: must match #isSaveableWithWarning"		^self isNullPackage not and: 		[super isSaveable and: 		[self checkUndeclared]]</body><body package="Store-IMG-Pundles" selector="isSaveableWithWarning">isSaveableWithWarning	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveable"		self isNullPackage		ifTrue:			[NullPackageCanNotBeSavedError raiseSignal.			^false].	super isSaveableWithWarning ifFalse: [^false].	self checkUndeclared		ifFalse:			[ContainsUndeclaredError raiseRequestErrorString: name.			^false].	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="literalClassListForPackage">literalClassListForPackage	^(self definedClassModels 		collect: [:cm | cm className])			asArray</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	^PackageChanges</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="readFromCodeReader:">readFromCodeReader: aReader 	self comment: aReader comment.	aReader classes do: [:cl | self addFullClassSymbol: cl fullClassSymbol].	aReader extensionMethods do: [:marr | 		self addSelector: (marr at: 1)			class: (marr at: 2) mclass].	self markNotModified</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-descriptors</category><body package="Store-IMG-Pundles" selector="reorganizedMethodDescriptors">reorganizedMethodDescriptors	| parentID meths |	(DbRegistry isOnline and: [self hasTrace])		ifFalse: [^Array new].	parentID := self dbTrace.	meths := Set new. 	self changeSet reorganizedClassNames		do: 			[:cName | 			| actualClass isMeta |			isMeta := cName namesMetaClass.			actualClass := cName asClassNameOnly asStrictReference value.			isMeta ifTrue: [actualClass := actualClass class].			actualClass organization elements				do: 					[:mSym | 					| traceMethod |					traceMethod := MethodsView								methodNamed: mSym								class: cName								package: parentID.					(traceMethod notNil and: [(actualClass organization categoryOfElement: mSym)							~= traceMethod protocol])						ifTrue: [meths add: (MethodDescriptor fromSelector: mSym className: cName meta: isMeta )]]].	^meths</body></methods><methods><class-id>Store.PackageModel</class-id> <category>parcel support</category><body package="Store-IMG-Pundles" selector="saveAsParcelFromSpecs:">saveAsParcelFromSpecs: publishSpec	"Save the receiver as a parcel -without creating the parcel in the image.	specs fullPathName is a directory/parcelName with no extension."		| dir pname |	pname := publishSpec basePath asFilename tail.	dir := publishSpec basePath asFilename directory.	dir exists		ifFalse:			[(CreateParcelDirectoryConfirmation raiseRequestErrorString: dir asString) ifFalse: [^self].			dir makeDirectory].	properties at: #packageName put: name.	self 		parcelOutTo: (dir construct: pname , '.pcl') asString 		sourceFileName: (dir construct: pname , '.pst') asString 		parcelOptions: publishSpec</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-repository storage</category><body package="Store-IMG-Pundles" selector="storeInDB">storeInDB	"Open a dialog that will let us store the source code into the database.  Return the dialog if we succeed in opening it (lets callers prep values further if needed), self if not.  Accepting the dialog stores into DB and empties the change set."		Undeclared purgeUnusedBindings.	self removeEmptyModels.	self shouldSaveIfNotNewestVersion ifFalse: [^self].	self isSaveableWithWarning ifTrue: [PublishPackageDialog publishPackage: self]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing-fake</category><body package="Store-IMG-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForPackages</body></methods><methods><class-id>Store.PackageModel</class-id> <category>unloading</category><body package="Store-IMG-Pundles" selector="unloadProblemsQuery:">unloadProblemsQuery: problems 	| probStream |	probStream := WriteStream on: String new.	probStream		nextPutAll: (#ClassesInPackageStillInUse &lt;&lt; #store 					&gt;&gt; 'Classes in package still in use:') asString;		cr.	problems size = 0 ifTrue: [^true].	problems size &lt; 20 		ifTrue: 			[problems do: 					[:prob | 					probStream nextPutAll: prob.					probStream cr]]		ifFalse: 			[1 to: 14				do: 					[:inx | 					probStream nextPutAll: (problems at: inx).					probStream cr].			probStream				nextPutAll: '...';				cr].	^#proceed == (Dialog 				choose: probStream contents				labels: (Array with: (#Proceed &lt;&lt; #store &gt;&gt; 'Proceed') asString						with: (#Cancel &lt;&lt; #store &gt;&gt; 'Cancel') asString)				values: #(#proceed #cancel)				default: #cancel)</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-load/unload</category><body package="Store-IMG-Pundles" selector="updateFrom:within:">updateFrom: aStoreParcelRecord within: aBundleOrNil	"Load code from aStoreParcelRecord (a fast-loading binary parcel stream) and update the system with the new code.	 Update the receiver to reflect the new code. Answer the receiver."	| aCodeReader |	aCodeReader := CodeReader new.	"First get the CodeReader to read-in all code objects into shadow namespaces	 internal to the CodeReader, leaving the system unmodified."	[ self startLoad.	self class		handleCodeReaderSignalsDo: [aCodeReader readFromStore: aStoreParcelRecord]		for: aStoreParcelRecord.	] ensure: [ self endLoad ].	aCodeReader properties removeKey: #dbTrace ifAbsent: [nil].	^self		updateCodeReadBy: aCodeReader		from: aStoreParcelRecord		within: aBundleOrNil</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="createStreamFromGlorpRecord:">createStreamFromGlorpRecord: aParcelRecord		| sourceFileInTempDirectory |	stream := InternalCodeReaderStream on: aParcelRecord binaryData.	tempSourceFile := Filename filterFilename: aParcelRecord defaultParcelName , '.pst'.	streamDir := aParcelRecord yourself class parcelDirectory.	streamDir exists ifFalse: [streamDir asFilename makeDirectory].	sourceFileInTempDirectory := streamDir construct: tempSourceFile.	sourceFileInTempDirectory exists ifFalse:		[sourceFileInTempDirectory := (sourceFileInTempDirectory withEncoding: #binary) writeStream.		[sourceFileInTempDirectory nextPutAll: aParcelRecord source binaryData] ensure: [sourceFileInTempDirectory close]]</body><body package="Store-IMG-Pundles" selector="createStreamFromRecord:">createStreamFromRecord: aParcelRecord		| tmp |	stream := InternalCodeReaderStream on: aParcelRecord blobData.	tempSourceFile := Filename filterFilename: aParcelRecord defaultParcelName , '.pst'.	streamDir := aParcelRecord class parcelDirectory.	streamDir exists ifFalse: [streamDir asFilename makeDirectory].	tmp := streamDir construct: tempSourceFile.	tmp exists		ifFalse:			[tmp := (tmp withEncoding: #binary) writeStream.			[tmp nextPutAll: aParcelRecord sourceData] ensure: [tmp close]]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>atomic installation</category><body package="Store-IMG-Pundles" selector="isAtomicallyLoadable">isAtomicallyLoadable	^self packageUndeclared isNil or: [self packageUndeclared isEmpty]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="isFullyLoaded">isFullyLoaded	^self isLoaded</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="readFromRecord:">readFromRecord: aParcelRecord	self createStreamFromRecord: aParcelRecord.	[self readPackage] ensure: [stream close]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="readHeaderFromRecord:">readHeaderFromRecord: aParcelRecord	"Answer aDictionary of the header information from the Parcel data 	 contained in aParcelRecord."	| info |	info := self readInfoFromRecord: aParcelRecord.	^info 		at: #stats put: ((Dictionary new)							at: #objectSpaceSize put: objectSpaceSize;							at: #mclassNum put: mclassNum;							at: #mclassclassNum put: mclassclassNum;							at: #refNamObjNum put: refNamObjNum;							at: #numNamedObjects put: numNamedObjects;							at: #numClasses put: numClasses;							at: #numExtensionMethods put: numExtensionMethods;							at: #scopeZonesNum put: scopeZonesNum;							at: #symbolNum put: symbolNum;							at: #twoByteSymbolNum put: twoByteSymbolNum;							at: #stringNum put: stringNum;							at: #twoByteStringNum put: twoByteStringNum;							at: #byteArrayNum put: byteArrayNum;							at: #floatNum put: floatNum;							at: #doubleNum put: doubleNum;							at: #largePositiveNum put: largePositiveNum;							at: #largeNegativeNum put: largeNegativeNum;							at: #fixedNum put: fixedNum;							at: #classOrganizerNum put: classOrganizerNum;							at: #arbClassNum put: arbClassNum;							at: #arbObjectNum put: arbObjectNum;							at: #userStringsNum put: userStringsNum;							at: #namedObjectsNum put: namedObjectsNum;							yourself);		at: #sourceFile put: sourceFile;		at: #hideSource put: hideSource;		yourself</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="readInfoFromRecord:">readInfoFromRecord: aParcelRecord	"Answer a Dictionary of useful information from the Parcel named aParcelRecord."	| info timestamp |	info := Dictionary new.	self createStreamFromRecord: aParcelRecord.	[self readHeader.	format &gt;= 7 ifTrue:		[info at: #prerequisiteParcels put: OrderedCollection new.		[self readPrerequisites]			on: self class prerequisiteSignal			do: [:ex|				ex parameter first = 'parcel'					ifTrue:						[(info at: #prerequisiteParcels)							add: (ex parameter copyFrom: 2 to: 3)]					ifFalse:						[info at: ex parameter first asSymbol							put: (ex parameter copyFrom: 2 to: ex parameter size - 1)].				ex resume]]]		ensure: [stream close].	parcelName size &gt; 0 ifTrue: [info at: #parcel put: parcelName].	versionString size &gt; 0 ifTrue: [info at: #version put: versionString].	info at: #format put: format.	timestamp := Timestamp readFromDateAndTime: (dateString, ' ', timeString) readStream.	timestamp notNil ifTrue:		[info at: #timestamp put: timestamp].	^info</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>atomic installation</category><body package="Store-IMG-Pundles" selector="unloadableDefinitionsForBrowsing">unloadableDefinitionsForBrowsing	^#()</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="abortLoadingSignal">abortLoadingSignal	^ComponentDescription cannotLoadComponentSignal.</body><body package="Store-IMG-Pundles" selector="abortUnloadingSignal">abortUnloadingSignal	^ComponentDescription cannotUnloadComponentSignal.</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="allDatabasesFor:">allDatabasesFor: aCollection	"Answer a list of existing dbIdentifiers linked to pundles."		| dbIdentifiers |	dbIdentifiers := Set new.	aCollection do: [:each | dbIdentifiers addAll: each allDatabases].	^dbIdentifiers asSortedCollection</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="changeSetClass">changeSetClass	^XChangeSet</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-IMG-Pundles" selector="classAlreadyLoadedSignal">classAlreadyLoadedSignal	^Parcel classAlreadyLoadedSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="compilationErrorSignal">compilationErrorSignal	^ParagraphEditor compilationErrorSignal</body><body package="Store-IMG-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	^Pundle componentNotFoundSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="currentBosFormat">currentBosFormat 	^1</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="databaseListFor:">databaseListFor: pundles	"Answer a list of existing db names linked to pundles."	| dbs |	dbs := Set new.	pundles do: [ :p | dbs addAll: p databaseList ].	^dbs asSortedCollection</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="emergencyUnloadSignal">emergencyUnloadSignal	^EmergencyUnloadSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private-loading</category><body package="Store-IMG-Pundles" selector="handlePrerequisite:">handlePrerequisite: anArray 	"With StORE loading all prereqs have been loaded before the CodeReader	 is used to load code, so we can ignore all prerequisites."	^self</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-IMG-Pundles" selector="invalidClassFormatSignal">invalidClassFormatSignal	^Parcel invalidClassFormatSignal</body><body package="Store-IMG-Pundles" selector="invalidNamedObjectSignal">invalidNamedObjectSignal	^Parcel invalidNamedObjectSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="mismatchedDatabaseSignal">mismatchedDatabaseSignal	^Store.MismatchedDatabaseError</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-IMG-Pundles" selector="missingClassSignal">missingClassSignal	^Parcel missingClassSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="useChangeSetsForCompare">useChangeSetsForCompare 	^UseChangeSetsForCompare</body><body package="Store-IMG-Pundles" selector="useChangeSetsForCompare:">useChangeSetsForCompare: aBoolean	UseChangeSetsForCompare := aBoolean</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="allDatabases">allDatabases	"Answer an array of datbase identifiers that the receiver has links to"	^( ( dbInfo select: [ :info | info hasTrace ] )		collect: [ :info | info dbIdentifier ]	) asArray.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="Store-IMG-Pundles" selector="asStoreComparisonObjectIn:">asStoreComparisonObjectIn: ignore	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="canBePublishedToCurrentDatabase">canBePublishedToCurrentDatabase	"Answer true if the receiver can safely be published to the current database."		(self hasTraceFor: DbRegistry dbIdentifier) ifTrue: [^true].	^(self storeForGlorpPundleClass hasVersionNamed: name) not</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="canReplaceVersions">canReplaceVersions	"Answer true if the users agrees to replace versions."	^self hasItselfBeenModified not or: 			[ReplaceModifiedPackageNotice raiseRequestErrorString: self name]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>TEMP</category><body package="Store-IMG-Pundles" selector="convertDbInfos">convertDbInfos	| new |	new := IdentityDictionary new.	dbInfo keysAndValuesDo:		[ :key : value |		new at: key asSymbol put: value 		].	dbInfo := new.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="databaseId">databaseId	"Answer the db identifier for the current connection, nil if none."	^self dbIdentifier</body><body package="Store-IMG-Pundles" selector="databaseId:">databaseId: dbIndentifier 	"Set the database identifier."	self dbIdentifier: dbIndentifier</body><body package="Store-IMG-Pundles" selector="dbTrace:">dbTrace: aKeyOfDBPackage 	"Store a key of the trace package."	self databaseInformationOrCreate		dbTrace: aKeyOfDBPackage.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="Store-IMG-Pundles" selector="doComponentUpdatingActions:">doComponentUpdatingActions: codeReader	self needsMoreWork</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-file out</category><body package="Store-IMG-Pundles" selector="fileOutChangedPropertiesOn:">fileOutChangedPropertiesOn: aFileManager	"File out only changed, saveable properties to aFileManager."	self fileOutChangedPropertiesForDb: DbRegistry dbIdentifier on: aFileManager.</body><body package="Store-IMG-Pundles" selector="fileOutChangesForDb:on:">fileOutChangesForDb: dbid on: aFileManager 	self 		fileOutChangesForDb: dbid		on: aFileManager		within: (self isBundle ifTrue: [self])</body><body package="Store-IMG-Pundles" selector="fileOutChangesOn:">fileOutChangesOn: aFileManager 	Notice 		showProgress: (#FilingOutChangesFor1s &lt;&lt; #store &gt;&gt; 'Filing out changes for &lt;1s&gt;' expandMacrosWith: name)		complete: self changedItemCount		while: [self fileOutChangesOn: aFileManager within: nil]		title: #Store &lt;&lt; #store &gt;&gt; 'Store'</body><body package="Store-IMG-Pundles" selector="fileOutPropertiesOn:">fileOutPropertiesOn: aFileManager		| props |	props := self propertiesForFileOut.	props size isZero ifTrue:		[^aFileManager			createdComponent: self componentType			named: self name].	self fileOutProperties: props on: aFileManager</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="hasTrace">hasTrace	^self dbTrace notNil and: [ self dbTrace ~= 0 ]</body><body package="Store-IMG-Pundles" selector="hasTraceFor:">hasTraceFor: aString	"Answer true if the receiver has a parent in the database, aString."	| info |	^( info := self databaseInformationFor: aString ) == nil		ifTrue: [ false ]		ifFalse: [ info hasTrace ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>public-change set access</category><body package="Store-IMG-Pundles" selector="inspectChangeSet">inspectChangeSet		self databaseInformationsDo: [:each | each inspectChangeSet]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="interactiveSelectVersion">interactiveSelectVersion 	"Answer a version of the receiver selected by the user, or nil if cancelled.	Always show a list with OK and Cancel options, no matter how many	actual versions are on the list."	^self class databaseClass interactiveSelectVersionOf: self name.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="isConnectedToAny">isConnectedToAny	^dbInfo contains: 		[ :info | info hasTrace ].</body><body package="Store-IMG-Pundles" selector="isSameAsImage">isSameAsImage	^true</body><body package="Store-IMG-Pundles" selector="isSaveable">isSaveable	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveableWithWarning"		readonly == nil ifTrue: [readonly := false].	^readonly not</body><body package="Store-IMG-Pundles" selector="isSaveableWithWarning">isSaveableWithWarning	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveable"		readonly == nil ifTrue: [readonly := false].	^readonly		ifTrue:			[WasConvertedFromParcelWithUndeclaredError raiseRequestErrorString: name.			false]		ifFalse: [true]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="newestVersionWithName:">newestVersionWithName: aName 	"Answer the user selected published version of the receiver.	nil if none."	^self class storeDatabaseClass newestVersionWithName: aName</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="otherChangesInclude:">otherChangesInclude: aChange 	^self isChangeSetEmpty		ifTrue: [false]		ifFalse: [self changeSet otherChangesInclude: aChange]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>ownership</category><body package="Store-IMG-Pundles" selector="owner">owner	"Returns the owner of the pundle"	^Policies ownershipPolicy ownerOfPundle: self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="parentRecord">parentRecord	"Answer an instance of the glorp database record that echos the receiver.	Use the dbTrace field to retrieve record from the DB. For new packages/bundles trace can be nil.	The only time that DbRegistry might be defined and still be nil is	if StoreBase is being loaded into the image for the first time.  So,	the following check is simply to prevent walkbacks while loading StoreBase."	| storePundle |	#{Store.DbRegistry}		ifDefinedDo:			[:registry | 			(registry notNil and: [registry isOnline]) ifFalse: [^nil]]		elseDo: [^nil].	self dbTrace ifNil: [^nil].	(self dbIdentifier notNil and: [self dbIdentifier = Store.DbRegistry dbIdentifier]) ifFalse: [^nil].	[storePundle := self storeForGlorpPundleClass aRecordWithID: self dbTrace]		on: self errorSignals		do:			[:exception | 			exception outer.			^nil].	^storePundle</body><body package="Store-IMG-Pundles" selector="parentVersionString">parentVersionString	"Answer a string describing the parent version."		^self traceVersion</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="pseudoPackage">pseudoPackage	"Answer false since I'm genuine."	^false</body><body package="Store-IMG-Pundles" selector="publishedBefore:">publishedBefore: aTimestamp	| myTimestamp |	myTimestamp := self dbTimestamp notNil		ifTrue: [self dbTimestamp]		ifFalse: [Timestamp fromSeconds: 0].	^myTimestamp &lt; aTimestamp</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	self subclassResponsibility</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="reconcileWithDb">reconcileWithDb	"Select a database pundle as the new parent of the receiver.	Answer nil if we haven't selected anything, otherwise, we don't care what we answer"		| storePundle |	(storePundle := self selectStoreVersion) ifNil: [^nil].	self reconcileWithDbVersion: storePundle</body><body package="Store-IMG-Pundles" selector="reconcileWithDb:">reconcileWithDb: aPundleOrStorePundle	"Change the receiver's change set to reflect the differences between it and &lt;aPundleOrStorePundle&gt;."		| storePundle |	self hasBeenModified ifFalse: [^self].	storePundle := aPundleOrStorePundle asStorePundle.	ReconcilingComparitor reconcile: self against: storePundle</body><body package="Store-IMG-Pundles" selector="reconcileWithDbVersion:">reconcileWithDbVersion: dbPundle	"Select a database pundle as the new parent of the receiver."		self isBundle 		ifTrue: [self allItems do: [:each | each setNoTrace]] 		ifFalse: [self setNoTrace].	self reconcileWithDb: dbPundle</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="removeDbInformationFor:">removeDbInformationFor: aCollection	"Remove any existing infos for the list of dbIdentifiers	Be careful not to remove the last one."		aCollection do:		[:eachIdentifier | 		(dbInfo size == 1 and: [dbInfo includesKey: eachIdentifier])			ifTrue: [self unlinkLastLink: eachIdentifier]			ifFalse: [dbInfo removeKey: eachIdentifier ifAbsent: [nil]]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="removeDbs:">removeDbs: aCollectionOfDatabaseIdentifiers	"Removes anything associated with databases in aCollectionOfDatabaseIdentifiers	This is only reached through the switchDatabase operation, 	which is only available while logged in."		dbInfo copy keys do:		[:eachDatabaseInfoSymbol | 		(aCollectionOfDatabaseIdentifiers includes: eachDatabaseInfoSymbol) ifTrue:			[dbInfo size == 1 ifTrue: [self databaseInformationForOrCreate: DbRegistry dbIdentifier].			dbInfo removeKey: eachDatabaseInfoSymbol]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>TEMP</category><body package="Store-IMG-Pundles" selector="removeOtherDbInfos">removeOtherDbInfos	"Store.PundleModel allGeneralInstances do:			[ :p | p removeOtherDbInfos ]		"	| id |	id := DbRegistry dbIdentifier.	dbInfo keys do:		[ :k | k = id				ifFalse: [ dbInfo removeKey: k ]		].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="Store-IMG-Pundles" selector="runClassExtensionPostLoadMethods">runClassExtensionPostLoadMethods	"Run the #postLoad: method on any classes extended with a class-side initialize method."	"We simply ignore this because for now this is already accomplished by Package&gt;&gt;#initializeClasses:.	 That method should probably have its code to initialize extended classes removed and equivalent	 code placed here." 	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="sameVersionAs:">sameVersionAs: aPundle		^aPundle sameVersionAsLoadedPundle: self</body><body package="Store-IMG-Pundles" selector="sameVersionAsLoadedPundle:">sameVersionAsLoadedPundle: aPundle		^aPundle name = self name</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="sameVersionAsPublished:">sameVersionAsPublished: aDbRecord		| info |	^( info := self databaseInformationFor: aDbRecord dbIdentifier ) == nil		ifTrue: [ false ]		ifFalse: 			[ ( self hasBeenModifiedIn: aDbRecord dbIdentifier ) not				  and: [ info dbTrace = aDbRecord primaryKey ]			]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="selectVersion">selectVersion 	"Answer the user selected published version of the receiver.	nil if none."	^self class databaseClass selectVersionOf: self name.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="setDbTraceAndVersionUsing:for:">setDbTraceAndVersionUsing: aPundle for: aDatabaseIdentifierKey	| databaseInformation |	databaseInformation := self databaseInformationFor: aDatabaseIdentifierKey.	(databaseInformation isNil or: [self shouldTrackChanges]) ifFalse:		[self addOtherChange: self parentChangedMark].	(databaseInformation notNil and: [self shouldTrackChanges])		ifTrue: [databaseInformation versionString: aPundle versionString].	databaseInformation ifNotNil: [		databaseInformation setDbTrace: aPundle primaryKey;			dbTimestamp: aPundle timestamp].	self isInCurrentDatabase ifTrue:		[Registry traceChangedForComponent: self].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="setNewTrace">setNewTrace	"Select a database pundle as the new parent of the receiver."		| storePundle |	(storePundle := self selectStoreVersion) ifNil: [^nil].	self isBundle ifTrue: [self allItems do: [:each | each setNoTrace]].	self setNewTraceTo: storePundle</body><body package="Store-IMG-Pundles" selector="setNewTraceTo:">setNewTraceTo: dbPundle	"Change the receiver to reflect dbPundle as it's parent."		self databaseInformationOrCreate		dbTrace: dbPundle primaryKey;		markNotModified.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="setNoTrace">setNoTrace	| info |	( info := self databaseInformation ) == nil		ifTrue: [ ^self ].		"already none"	info setNoTrace.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="shortItemString">shortItemString	^self name, self traceVersionString</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="shouldSaveIfNotNewestVersion">shouldSaveIfNotNewestVersion	| versions result pundle |	Store.Glorp.StoreObject warnIfNewerVersionPublished ifFalse: [^true].	(pundle := self asStorePundle) ifNil: [^true].	versions := self storeForGlorpPundleClass newerVersionsOf: pundle.	versions isEmpty ifTrue: [^true].	result := StoreNewVersionWarning raiseSignal: (#AtLeastOneNew1Bool2sn &lt;&lt; #store &gt;&gt;		'There is at least one newer verson of &lt;1?Bundle:Package&gt; &lt;2s&gt; in the repository.&lt;n&gt;Continue to Publish?' expandMacrosWith: self isBundle with: pundle shortItemString).	^result</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="silentlyFailSelectVersion">silentlyFailSelectVersion	"Answer the user selected published version of the receiver.	nil if none."	^self class databaseClass silentlyFailSelectVersionOf: self name.</body><body package="Store-IMG-Pundles" selector="storeVersions">storeVersions	"Return all versions for the receiver.  This assumes the system is already connected to the database."	^self storeForGlorpPundleClass allVersionsWithName: self name</body><body package="Store-IMG-Pundles" selector="storeVersionsIn:">storeVersionsIn: aSession	"Return all versions for the receiver. This assumes the system is already connected to the database."	^self storeForGlorpPundleClass allVersionsWithName: self name in: aSession</body></methods><methods><class-id>Store.PundleModel</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="stringKey:">stringKey: hints 	"A string used to represent myself in browsers, for example in a menu. The 	default is to use my displayString"	^(hints includes: #blessing) 		ifTrue: 			[#Image1s &lt;&lt; #store &gt;&gt; 'Image: &lt;1s&gt;' expandMacrosWith: self versionString]		ifFalse: [self name , self traceVersionString	"displayString"]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body><body package="Store-IMG-Pundles" selector="timeStampString">timeStampString	^'(image)'</body><body package="Store-IMG-Pundles" selector="tracePackage">tracePackage		^self parentRecord</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="traceVersionString">traceVersionString	"Answer a string describing a version of my trace 	pundle. Use cache if possible."	| info |	^( info := self databaseInformation ) == nil		ifTrue: [ '' ]		ifFalse: [ info traceVersionString ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="unlinkLastLink:">unlinkLastLink: id 	"Remove the last dbInfo. If it has something of value, move it to no db."	| theLast |	dbInfo size == 1 ifFalse: 		[self notify: #UnexpectedShouldBeSingularDb &lt;&lt; #store &gt;&gt; 'Unexpected - should be singular db'].	theLast := dbInfo removeKey: id.	(theLast isChangeSetEmpty and: [self isPackage]) ifFalse:        [theLast unhook; dbIdentifier: self noDbSymbol.       dbInfo at: theLast dbIdentifier put: theLast].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>load/unload</category><body package="Store-IMG-Pundles" selector="unloadFromGroup:">unloadFromGroup: aGroup 	"aGroup asks for unloading this component. 	Obey only if aGroup is the only group that references this component."	( self onlyReferencedBy: aGroup )		ifTrue: 			[ self doUnloadFromImage.			ChangeSet unloadContainedComponent: self. 			]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="userWantsFullCompare">userWantsFullCompare	"Answer true if the preferences are set or if the control key is down.  Otherwise, 	changesets will be used for comparison."	^self class useChangeSetsForCompare not or: [InputState default ctrlDown]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="validateDatabaseId">validateDatabaseId	"Answer tuee if the receiver is linked to the current database."	^self isInCurrentDatabase</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="Store-IMG-Pundles" selector="versions">versions	"Return all versions for the receiver.  This assumes the system is already connected to the database."	^self storeForGlorpPundleClass allVersionsWithName: self name</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="versionStringAlternate">versionStringAlternate	^(self hasBeenModified 		ifTrue: [(#InImage &lt;&lt; #store &gt;&gt; ' - in image - ') asString]		ifFalse: [' ']) , self traceVersionString</body><body package="Store-IMG-Pundles" selector="versionStringFor:">versionStringFor: dbid	| info |	info := self databaseInformationFor: dbid.	info == nil		ifTrue: [ ^'' ].	^info  traceVersionString, 		( info isChangeSetEmpty		"hasBeenModified"			ifTrue: [ '=' ]			ifFalse: [ '*' ]		)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="youngerThan:">youngerThan: aDBPackage	^self hasBeenModified		ifTrue: [ true ]		ifFalse: [ ( self dbTraceFor: aDBPackage dbIdentifier ) &gt;= aDBPackage primaryKey ]</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>testing</category><body package="Store-UI" selector="hasStoreProgressOverlay">hasStoreProgressOverlay	^component isKindOf: Store.StoreProgressOverlay</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>Store feedback</category><body package="Store-UI" selector="withStoreFeedbackOn:">withStoreFeedbackOn: aWindow	Store.StoreProgressOverlay subsume: aWindow while: self</body></methods><methods><class-id>UI.MultiSelectionSequenceView</class-id> <category>text length calculation</category><body package="Store-UI" selector="fontForEmphasis:">fontForEmphasis: emphasisSymbol	^self graphicsContext		findFont: (self textStyle fontAt: emphasisSymbol for: self textStyle defaultFontPolicy)</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>private</category><body package="Store-UI" selector="printNamesAndVersionsOf:on:">printNamesAndVersionsOf: pundleCollection on: aStream	(pundleCollection asSortedCollection: [:a :b | a name &lt;= b name]) do:		[:pundle |		aStream 			crtab; 			nextPutAll: pundle name, ' ', pundle versionString]</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="store01StoreIIDebug">store01StoreIIDebug	"&lt;setting: #(store storeIIPage storeIIDebug)&gt;"	^(BooleanSetting on: #{Store.Glorp.StoreObject.DebugStoreII})		label: #debugStoreII &lt;&lt; #labels &gt;&gt; 'Debug Store II';		default: false;		helpText: #storeDebugStoreII &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store II will throw a Dialog before it attempts to convert a Store II object into a Store I object'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storeIIPage">storeIIPage	"&lt;settingsPage: #(#store #storeIIPage)&gt;"	^ModularSettingsPage new		label: #StoreIIPage &lt;&lt; #store &gt;&gt; 'Store II';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store storeIIPage))</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>file name list</category><body package="Store-UI" selector="fileIntoPackage">fileIntoPackage	"Prompt for the package to read into. 	Read the entire file into the selected package."	| pkg |	pkg := PackageChooser chooseOrAddOnCancelDo: [ ^self ].	[ Policies packagePolicy forcePackage: pkg while: 		[Notice			show: (#FilingIntoN1S &lt;&lt; #dialogs &gt;&gt; 'Filing into&lt;n&gt;&lt;1s&gt;' expandMacrosWith: pkg name)			while: [(fileName asFilename withEncoding: self currentFileEncoding) fileIn]]	] on: RedefinitionNotification do:		[ :note | 		note currentPackage = pkg			ifFalse: [ note override install ].		note resume.		].</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store</category><body package="Store-UI" selector="areAttached">areAttached	^DbRegistry isConnected</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI" selector="noItemsOfType:match:">noItemsOfType: aTypeString match: aString		Dialog warn: (#No1sMatching2s &lt;&lt; #store &gt;&gt; 'No &lt;1s&gt; matching &lt;2s&gt;' expandMacrosWith: aTypeString with: aString)</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store</category><body package="Store-UI" selector="notAttached">notAttached	^self areAttached not</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI" selector="selectNameFrom:chooseTitle:">selectNameFrom: aCollection chooseTitle: aString		^Dialog		choose: (#ChooseA1s &lt;&lt; #store &gt;&gt; 'Choose a &lt;1s&gt;' expandMacrosWith: aString)		fromList: aCollection		values: aCollection		lines: 12		cancel: nil.</body><body package="Store-UI" selector="storeRepositoryLabelPart">storeRepositoryLabelPart	| profileName |	profileName := (#Repository &lt;&lt; #store &gt;&gt; 'Repository') asString.	DbRegistry connectedProfile ifNotNil: 		[:profile | 		profile name ifNotNil: 			[:name | profileName := name]].	^profileName</body><body package="Store-UI" selector="toggleStoreConnectionItemLabel">toggleStoreConnectionItemLabel	^DbRegistry isConnected 		ifTrue: 			[#DisconnectFrom1s &lt;&lt; #store &gt;&gt; 'Disconnect from &lt;1s&gt;' expandMacrosWith: self storeRepositoryLabelPart]		ifFalse: 			[(#ConnectToRepository &lt;&lt; #store &gt;&gt; 'Connect to Repository...') asString]</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>accessing</category><body package="Store-UI-Comparitors" selector="package">package	"Answer the package that contains the name space that this descriptor describes.	 If none can be found, then answer nil.  This method is intended to provide 	 polymorphic behavior with NameSpaceRecord so that the PackageComparisonApplication	 can handle both instances of NameSpaceRecord and NameSpaceDescriptor."	^Registry containingPackageForNameSpaceSymbol: self absoluteSymbol</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="Store-UI-Comparitors" selector="package">package	"Answer the package that contains the shared variable that this descriptor describes.	 If none can be found, then answer nil.  This method is intended to provide 	 polymorphic behavior with DataElement so that the PackageComparisonApplication	 can handle both instances of DataElement and DatumDescriptor."	^Registry containingPackageForDataKey: dataKey symbol: self owner absoluteSymbol</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>printing</category><body package="Store-UI-Comparitors" selector="statusLineString">statusLineString	^self protocolName</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>printing</category><body package="Store-UI-Comparitors" selector="statusLineString">statusLineString	^''</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="Store-UI-Comparitors" selector="package">package	"Answer the package that contains the class that this descriptor describes.	 If none can be found, then answer nil.  This method is intended to provide 	 polymorphic behavior with ClassRecord so that the PackageComparisonApplication	 can handle both instances of ClassRecord and ClassDescriptor."	^Registry containingPackageForClassSymbol: self absoluteSymbol</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>printing</category><body package="Store-UI-Comparitors" selector="statusLineString">statusLineString	^self myClass		ifNil: ['']		ifNotNil: [self protocolName]</body></methods><methods><class-id>Lens.LensBrowsingToolModel</class-id> <category>store</category><body package="Store-UI-Graphs" selector="openInLevels:">openInLevels: levels	self selectionDo: 		[ :e | self browserModel body openAllFrom: e side: 2 levels: levels ]</body><body package="Store-UI-Graphs" selector="openOutLevels:">openOutLevels: levels	self selectionDo: 		[ :e | self browserModel body openAllFrom: e side: 1 levels: levels ]</body></methods><methods><class-id>Lens.LDMArrowView class</class-id> <category>instance creation</category><body package="Store-UI-Graphs" selector="model:fullImage:emptyImage:">model: mdl fullImage: fullImage emptyImage: emptyImage	| dv |	dv := super model: mdl.	dv beVisual: emptyImage ifTrue: fullImage.	^dv</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>scanning-code components</category><body package="Store-Change Management" selector="scan_pundle_loaded:">scan_pundle_loaded: anElement 	self doChange: 		( Store.PundleLoadedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			databaseId: ( self getString: 'databaseId' from: anElement default: '' );			primaryKey: ( self getString: 'primaryKey' from: anElement default: '0' ) asNumber			yourself 		  )</body><body package="Store-Change Management" selector="scan_pundle_saved:">scan_pundle_saved: anElement 	self doChange: 		( Store.PundleSavedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			databaseId: ( self getString: 'databaseId' from: anElement default: '' );			primaryKey: ( self getString: 'primaryKey' from: anElement default: '0' ) asNumber			yourself 		  )</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="Store-Change Management" selector="asTag">asTag	^Store.ClassTag newClassName: self absoluteName isMeta: false.</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management" selector="loadPundle:type:primaryKey:databaseId:on:">loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	"So it shows up in references and senders..."	Array with: CodeComponent with: #reloadPundle:named:id:fromDatabase:.	aStream nextChunkPut: 		( '#{Store.Pundle} ifDefinedDo:&lt;n&gt;[ :pundleClass |&lt;n&gt;pundleClass reloadPundle: &lt;1s&gt; named: &lt;2s&gt; id &lt;3s&gt; fromDatabase: &lt;3s&gt;&lt;n&gt;].'				expandMacrosWith: pundleType storeString				with: name				with: key storeString				with: databaseId storeString		); cr.</body><body package="Store-Change Management" selector="savePundle:type:primaryKey:databaseId:on:">savePundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the saving of a Pundle event on a stream - action is same as loading. "	"For packages there is no difference in restoring a save and a load."	self loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management" selector="bundleStructure:on:">bundleStructure:  aBundle on: aStream	"Add the loading of a package/bundle event on a stream. "	^self subclassResponsibility</body><body package="Store-Change Management" selector="loadPundle:type:primaryKey:databaseId:on:">loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a package/bundle event on a stream. "	^self subclassResponsibility</body><body package="Store-Change Management" selector="savePundle:type:primaryKey:databaseId:on:">savePundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the saving of a package/bundle event on a stream. "	^self subclassResponsibility</body></methods><methods><class-id>Kernel.ComponentDefinitionChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := self isForClass		ifTrue: [ Store.Change new className: definitionName meta: false ]		ifFalse: [ Store.Change new nameSpaceSymbol: definitionName ].	self performChange: change to: aChangeSet.</body><body package="Store-Change Management" selector="performChange:to:">performChange: aChange to: aChangeSet	definitionChange == #added		ifTrue: [ aChange add ]		ifFalse: [ aChange remove ].		aChangeSet doChange: aChange.</body></methods><methods><class-id>Kernel.ChangeSet class</class-id> <category>component change management</category><body package="Store-Change Management" selector="loadPundle:">loadPundle: aPundle	"Include indication that aPundle was loaded."	self changed: #loadPundle: with: ( Array with: aPundle )</body><body package="Store-Change Management" selector="savePundle:">savePundle: aPundle	"Include indication that aPundle was loaded."	self changed: #savePundle: with: ( Array with: aPundle )</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>component change management</category><body package="Store-Change Management" selector="loadPundle:">loadPundle: aPundle	"Include indication that aPundle was loaded."	self addComponentChange:			( Store.PundleLoadedChange new				component: aPundle;				yourself 			)</body><body package="Store-Change Management" selector="savePundle:">savePundle: aPundle	"Include indication that aPundle was loaded."	self addComponentChange:			( Store.PundleSavedChange new				component: aPundle;				yourself 			)</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#class</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="modifiedTags">modifiedTags	"Answer a collection of tags for changed or add definitions, methods or data, 	not including removed definitions."		| tags |	tags := OrderedCollection new.	(self isAdded or: [self isClassChangedMeta: false]) ifTrue: 		[tags add: (ClassTag newClassSymbol: symbol isMeta: false)].	(self isClassChangedMeta: true) ifTrue: 		[tags add: (ClassTag newClassSymbol: symbol isMeta: true)].	self isCommented ifTrue: 		[tags add: (ClassCommentTag newClassSymbol: symbol isMeta: false)].	(self modifiedSelectorsMeta: false) do: 		[:each | tags add: (MethodTag newClassSymbol: symbol isMeta: false selector: each)].	(self modifiedSelectorsMeta: true) do: 		[:each | tags add: (MethodTag newClassSymbol: symbol isMeta: true selector: each)].	self modifiedDataKeys do: 		[:each | tags add: (DataTag newClassSymbol: symbol dataKey: each)].	^tags</body><body package="Store-Change Management" selector="removedTags">removedTags	"Answer a collection of tags for removed definitions, methods or data."		| tags |	tags := OrderedCollection new.	(self isRemoved or: [self isDefinitionRemoved]) ifTrue: 		[tags add: (ClassTag newClassSymbol: symbol isMeta: false)].	(self removedSelectorsMeta: false) do: 		[:selector | tags add: (MethodTag newClassSymbol: symbol isMeta: false selector: selector)].	(self removedSelectorsMeta: true) do: 		[:selector | tags add: (MethodTag newClassSymbol: symbol isMeta: true selector: selector)].	self removedDataKeys do: 		[:dataKey | tags add: (DataTag newClassSymbol: symbol dataKey: dataKey)].	^tags</body></methods><methods><class-id>Kernel.ComponentChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	" self subclassResponsibility "	"default to do nothing"</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="dataChanges">dataChanges	"Answer a collection of Changes for all modified/added/removed statics"	| coll |	dataChanges == nil		ifTrue: [ ^#( ) ].	coll := OrderedCollection new.	dataChanges keysAndValuesDo:		[ :key :type | 		coll add:			( Change new				nameSpaceSymbol: symbol;				dataKey: key;				perform: type;				yourself				)		].	^coll</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#namespace</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="modifiedDatumDescriptors">modifiedDatumDescriptors	^( self getDataChangesIfNone: [ ^#( ) ] ) keys collect:		[ :key  | DatumDescriptor fromDataKey: key nameSpaceName: symbol asString ].</body><body package="Store-Change Management" selector="modifiedTags">modifiedTags	"Answer a collection of tags for changed or add definitions, methods or data, 	not including removed definitions."		| tags |	tags := OrderedCollection new.	(self isAdded or: [self isChanged]) ifTrue: 		[tags add: (NameSpaceTag newNameSpaceSymbol: symbol)].	self isCommented ifTrue: 		[tags add: (NameSpaceCommentTag newNameSpaceSymbol: symbol)].	self modifiedDataKeys do: 		[:each | tags add: (DataTag newNameSpaceSymbol: symbol dataKey: each)].	^tags</body><body package="Store-Change Management" selector="removedTags">removedTags	"Answer a collection of tags for removed definitions or data."	| tags |	tags := OrderedCollection new.	( self isDefinitionRemoved )		ifTrue: [ tags add: ( NameSpaceTag newNameSpaceSymbol: symbol ) ].	self removedDataKeys do: 		[ :dataKey | tags add: ( DataTag newNameSpaceSymbol: symbol dataKey: dataKey ) ].	^tags</body></methods><methods><class-id>Kernel.ComponentSelectorChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := Store.Change new className: definitionName meta: meta.	change selector: self selector.	self performChange: change to: aChangeSet.</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="Store-Change Management" selector="asTag">asTag	^Store.MethodTag 		newClassName: self implementingClass absoluteName		meta: self isMeta		selector: self selector asSymbol		protocol: self protocol.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>events</category><body package="Store-Change Management" selector="addBinding:in:">addBinding: binding in: anObject	"Event triggered when new static is created."	anObject isInStandardEnvironment		ifFalse: [ ^self ].	anObject isBehavior		ifTrue:			[ self addDataKey: binding key 				class: anObject				package: ( Registry packageForNewDataKey: binding key 								classSymbol: anObject absoluteSymbol )			]	ifFalse:		[ self addDataKey: binding key			nameSpace: anObject			package: ( Registry packageForNewDataKey: binding key							nameSpaceSymbol: anObject absoluteSymbol )		].</body><body package="Store-Change Management" selector="addBinding:in:attributes:">addBinding: binding in: anObject attributes: attributes	"Event triggered when new static is created with attributes."	| pkg |	anObject isInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ ^self addBinding: binding in: anObject ].	anObject isBehavior		ifTrue: [ self addDataKey: binding key class: anObject package: pkg ]		ifFalse:	[ self addDataKey: binding key nameSpace: anObject package: pkg ].</body><body package="Store-Change Management" selector="addClass:">addClass: class 	"Event triggered when new class is created."	| cls |	class isInStandardEnvironment		ifFalse: [ ^self ].	cls := class instanceBehavior.	self addClass: cls toPackage: 	( Registry packageForClass: cls ).</body><body package="Store-Change Management" selector="addClass:attributes:">addClass: class attributes: attributes	"Event triggered when new class is created with attributes."	| pkg cls |	class isInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	cls := class instanceBehavior.	pkg == nil		ifTrue: [ 	self addClass: cls ]		ifFalse: [ self addClass: cls toPackage: pkg ]</body><body package="Store-Change Management" selector="addNameSpace:">addNameSpace: namespace 	"Event triggered when new namespace is created."	| pkg |	namespace isInStandardEnvironment		ifFalse: [ ^self ].	( pkg := Registry packageForNameSpace: namespace ) == nil		ifFalse: [ self addNameSpace: namespace toPackage: pkg ]</body><body package="Store-Change Management" selector="addNameSpace:attributes:">addNameSpace: namespace attributes: attributes	"Event triggered when new namespace is created with attributes."	| pkg |	namespace isInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ 	self addNameSpace: namespace ]		ifFalse: [ self addNameSpace: namespace toPackage: pkg ]</body><body package="Store-Change Management" selector="addSelector:class:">addSelector: selector class: class 	"Event triggered when a new method is created."	class isInStandardEnvironment		ifFalse: [ ^self ].	self addSelector: selector class: class toPackage: 		( Registry 			packageForNewSelector: selector				classSymbol: class absoluteName asClassNameOnly asSymbol			meta: class isMeta		).</body><body package="Store-Change Management" selector="addSelector:class:attributes:">addSelector: selector class: class attributes: attributes	"Event triggered when new method is created with attributes."	| pkg |	class isInStandardEnvironment		ifFalse:	[ ^self ].			"ignore while shadow compiling"	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ self addSelector: selector class: class ]		ifFalse: [ self addSelector: selector class: class toPackage: pkg ]</body><body package="Store-Change Management" selector="changeBinding:in:">changeBinding: binding in: anObject	"Event triggered when a static definition is changed."	anObject isInStandardEnvironment		ifFalse: [ ^self ].	anObject isBehavior		ifTrue: [ self changeDataKey: binding key class: anObject ]		ifFalse: [ self changeDataKey: binding key nameSpace: anObject ].</body><body package="Store-Change Management" selector="changeBinding:in:attributes:">changeBinding: binding in: anObject attributes: attributes	"Event triggered when a static definition is changed with attributes."	| pkg |	anObject isInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ]. 	pkg == nil		ifTrue: [ ^self changeBinding: binding in: anObject ].	anObject isBehavior		ifTrue: [ self changeDataKey: binding key class: anObject package: pkg ]		ifFalse: [ self changeDataKey: binding key nameSpace: anObject package: pkg ].</body><body package="Store-Change Management" selector="changeClass:">changeClass: class 	"Event triggered when a class definition is changed."	| cls |	class isInStandardEnvironment		ifFalse: [ ^self ].	cls := class instanceBehavior.	self changeClass: cls toPackage: ( Registry packageForClass: cls ).</body><body package="Store-Change Management" selector="changeClass:attributes:">changeClass: class attributes: attributes	"Event triggered when a class definition is changed with attributes."	| pkg cls |	class isInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	cls := class instanceBehavior.	pkg == nil		ifTrue: [ 	self changeClass: cls ]		ifFalse: [ self changeClass: cls toPackage: pkg ]</body><body package="Store-Change Management" selector="changeNameSpace:">changeNameSpace: namespace	"Event triggered when a namespace definition is changed."	| pkg |	namespace isInStandardEnvironment		ifFalse: [ ^self ].	( pkg := Registry packageForNameSpace: namespace ) == nil		ifFalse: [ self changeNameSpace: namespace toPackage: pkg ].</body><body package="Store-Change Management" selector="changeNameSpace:attributes:">changeNameSpace: namespace attributes: attributes	"Event triggered when a namespace definition is changed with attributes."	| pkg |	namespace isInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ 	self changeNameSpace: namespace ]		ifFalse: [ self changeNameSpace: namespace toPackage: pkg ]</body><body package="Store-Change Management" selector="changeSelector:class:">changeSelector: selector class: class 	"Event triggered when a method is changed."	class isInStandardEnvironment		ifFalse: [ ^self ].	self changeSelector: selector class: class toPackage: 		( Registry			packageForSelector: selector			classSymbol: class absoluteName asClassNameOnly asSymbol			meta: class isMeta		)</body><body package="Store-Change Management" selector="changeSelector:class:attributes:">changeSelector: selector class: class attributes: attributes	"Event triggered when a method is changed with attributes."	| pkg |	class isInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [  self changeSelector: selector class: class ]		ifFalse: [ self changeSelector: selector class: class toPackage: pkg ]</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-method changes</category><body package="Store-Change Management" selector="revertData:owner:">revertData: aSymbol owner: aClassOrNameSpace	"Reload from the database the most recently loaded version of the data described. 	Assumes that we've already verified that this is actually possible. "		| tracePackage packageModel |	packageModel := Registry containingPackageForDataKey: aSymbol symbol: aClassOrNameSpace absoluteSymbol.	Cursor wait showWhile:		[DbRegistry doIfOnlineImage:			[(tracePackage := packageModel tracePackage) ifNil: [^self warnNoParentForSharedInDatabase].			tracePackage 				loadData: aSymbol 				ownerName: aClassOrNameSpace absoluteName 				ifNone: [^self warnCanNotRevertSharedNoParent: tracePackage].			packageModel changeSet forgetDataChange: aSymbol owner: aClassOrNameSpace]]</body><body package="Store-Change Management" selector="revertSelector:class:">revertSelector: selector class: class	"Reload from the database the most recently loaded version of the method described. 	Assumes that we've already verified that this is actually possible. 	Answer true if sucessful."		| traceStorePackage packageModel |	packageModel := Registry containingPackageForSelector: selector class: class.	Cursor wait showWhile:		[DbRegistry doIfOnlineImage:			[(traceStorePackage := packageModel tracePackage) isNil ifTrue: 				[^self warnForNoParentInDatabase].			traceStorePackage 				loadMethod: selector 				className: class absoluteName 				ifNone: [^self warnForCanNotRevertInPackage: traceStorePackage].			packageModel changeSet forgetMethodChange: selector class: class]].	^true</body><body package="Store-Change Management" selector="warnCanNotRevertSharedNoParent:">warnCanNotRevertSharedNoParent: tracePackage		^Dialog		warn:			(#ParentDoesNotContainData &lt;&lt; #store &gt;&gt;					'The parent package &lt;1s&gt; does not contain this data.&lt;n&gt;Cannot revert method to previous version.&lt;n&gt;Perhaps you want "remove..."'				expandMacrosWith: tracePackage itemString)</body><body package="Store-Change Management" selector="warnForCanNotRevertInPackage:">warnForCanNotRevertInPackage: traceStorePackage		Dialog		warn:			(#ParentDoesNotContainMethod &lt;&lt; #store &gt;&gt;					'The parent package &lt;1s&gt; does not contain this method.&lt;n&gt;Cannot revert method to previous version.&lt;n&gt;Perhaps you want "remove..."'				expandMacrosWith: traceStorePackage itemString).	^false</body><body package="Store-Change Management" selector="warnForNoParentInDatabase">warnForNoParentInDatabase		Dialog		warn:			(#NoParentForMethod &lt;&lt; #store &gt;&gt; 'The package containing this method has no parent in the database.&lt;n&gt;Cannot revert method to previous version.')				expandMacros.	^false</body><body package="Store-Change Management" selector="warnNoParentForSharedInDatabase">warnNoParentForSharedInDatabase		^Dialog		warn:			(#NoParentForDataKey &lt;&lt; #store &gt;&gt; 'The package containing this datakey has no parent in the database.&lt;n&gt;Cannot revert datakey to previous version.')				expandMacros</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="Store-Change Management" selector="asTag">asTag	^self isInClass		ifTrue: [ Store.DataTag newClassName: self absoluteOwnerName dataKey: self dataKey ]		ifFalse: [ Store.DataTag newNameSpaceName: self absoluteOwnerName dataKey: self dataKey ]</body></methods><methods><class-id>Kernel.ComponentStaticChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perform the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := Store.Change new actual: self owner.	change dataKey: self dataKey.	self performChange: change to: aChangeSet.</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management" selector="loadPundle:type:primaryKey:databaseId:on:">loadPundle: name type: typeSymbol primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'pundle-loaded' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str cr.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'primaryKey' value: key storeString.		str cr.		xml on: str tag: 'databaseId' value: databaseId storeString.		str cr.		]</body><body package="Store-Change Management" selector="savePundle:type:primaryKey:databaseId:on:">savePundle: name type: typeSymbol primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'pundle-saved' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str cr.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'primaryKey' value: key storeString.		str cr.		xml on: str tag: 'databaseId' value: databaseId storeString.		str cr.		]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="Store-Change Management" selector="loadPundle:">loadPundle: aPundle	self 		loadPundleNamed: aPundle name		type: aPundle componentType		primaryKey: aPundle primaryKey 		databaseId: aPundle dbIdentifier</body><body package="Store-Change Management" selector="loadPundleNamed:type:primaryKey:databaseId:">loadPundleNamed: pundleName type: typeSymbol primaryKey: anInteger databaseId: aString 	self noTargetForWrites 		ifFalse: 			[self targetFormatter 				loadPundle: pundleName				type: typeSymbol				primaryKey: anInteger				databaseId: aString				on: self targetFile]</body><body package="Store-Change Management" selector="savePundle:">savePundle: aPundle	self 		savePundleNamed: aPundle name		type: aPundle componentType		primaryKey: aPundle primaryKey 		databaseId: aPundle databaseId</body><body package="Store-Change Management" selector="savePundleNamed:type:primaryKey:databaseId:">savePundleNamed: pundleName type: typeSymbol primaryKey: anInteger databaseId: aString 	self noTargetForWrites 		ifFalse: 			[self targetFormatter 				savePundle: pundleName				type: typeSymbol				primaryKey: anInteger				databaseId: aString				on: self targetFile]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-fileIn/Out</category><body package="Store-Change Management" selector="fileOutOn:classSymbol:">fileOutOn: outputStream classSymbol: classSymbol	"Write out all the changes the receiver knows about."		| fileManager cc |	fileManager := outputStream.	fileManager deferInitializations.	cc := self at: classSymbol.	(cc isRemoved or: [cc isDefinitionRemoved])		ifTrue: [fileManager removeObject: classSymbol type: cc fileOutObjectType]		ifFalse:			[| class |			class := classSymbol asStrictReference				valueOrDo: [^FileOutClassDoesntExistError raiseRequestErrorString: classSymbol].			cc fileOutChangesFor: class for: nil within: nil on: fileManager.			cc fileOutChangesFor: class class for: nil within: nil on: fileManager].	fileManager finishInitializations.	fileManager cr</body><body package="Store-Change Management" selector="fileOutOn:within:">fileOutOn: outputStream within: aBundle	"Write out all the changes the receiver knows about."	self fileOutOn: outputStream for: nil within: aBundle</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-lists</category><body package="Store-Change Management" selector="modifiedTags">modifiedTags	"Answer a collection of tags for changed or add class definitions,	methods or data, not including removed definitions."	| tags props |	tags := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc | tags addAll: cc modifiedTags ].	( props := self propertiesOrNil ) == nil		ifFalse: [ props do: [ :prop | tags add: ( PropertyTag new property: prop ) ] ].	( other ~~ nil and: [ other includes: BundleModel structureMark ] )		ifTrue: [ tags add: BundleStructureTag new ].	^tags</body><body package="Store-Change Management" selector="removedTags">removedTags	"Answer a collection of tags for removed class/namespace definitions,	methods and data."	| tags |	tags := OrderedCollection new.	self keysAndValuesDo: [ :symbol :cc | tags addAll: cc removedTags ].	^tags</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-Change Management" selector="modificationsFor:">modificationsFor: dbid	"Answer my content as a collection of modifications in order."	| mods |	mods := List new.	mods addAll: ( self basicModificationsFor: dbid ).	self leafItems do:		[ :pkg | mods addAll: ( pkg modificationsFor: dbid ) ].	^mods</body></methods><methods><class-id>Kernel.PropertyChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	aChangeSet addPropertyChange: property</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-Change Management" selector="modifications">modifications	"Answer my content as a collection of modifications."	| mods |	mods := List new.	self isChangeSetEmpty ifTrue: [ ^mods ].	self changeSet modifiedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: tag sourceTextForImage				)		].	self changeSet removedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: nil				)		].	^mods</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>compiling-code components</category><body package="Store-Change Management" selector="compile_pundle_loaded:">compile_pundle_loaded: anElement	#{Store.Pundle} ifDefinedDo:		[ :pundleClass |		pundleClass			reloadPundle: ( self getSymbol: 'type' from: anElement )			named: ( self getString: 'name' from: anElement default: '' )			id: ( self getString: 'primaryKey' from: anElement default: '0' ) asInteger			fromDatabase: ( self getString: 'databaseId' from: anElement default: '' )		].</body><body package="Store-Change Management" selector="compile_pundle_saved:">compile_pundle_saved: anElement	#{Store.Pundle} ifDefinedDo:		[ :pundleClass |		pundleClass			reloadPundle: ( self getSymbol: 'type' from: anElement )			named: ( self getString: 'name' from: anElement default: '' )			id: ( self getString: 'primaryKey' from: anElement default: '0' ) asInteger			fromDatabase: ( self getString: 'databaseId' from: anElement default: '' )		].</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="Store-Change Management" selector="asTag">asTag	^Store.NameSpaceTag newNameSpaceName: self absoluteName</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Change Management" selector="basicallySameVersionAsPublished:">basicallySameVersionAsPublished: aDbRecord		| info |	^( info := self databaseInformationFor: aDbRecord dbIdentifier ) notNil		and: [ info dbTrace = aDbRecord primaryKey ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="Store-Change Management" selector="basicModificationsFor:">basicModificationsFor: dbid	"Answer my content as a collection of modifications."	| mods cs |	mods := List new.	cs := self changeSetFor: dbid.	cs == nil		ifTrue: [ cs :=  ( dbInfo at: self noDbSymbol ifAbsent: [ ^mods ] ) changeSet ].	cs isEmpty ifTrue: [ ^mods ].	cs modifiedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: ( tag sourceTextForImage: self )				)		].	cs removedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: nil				)		].	^mods</body></methods><methods><class-id>Store.Access class</class-id> <category>filein/fileout</category><body package="Store-User Management" selector="prerequisitesForLoading">prerequisitesForLoading	^super prerequisitesForLoading		add: BasicBlessingPolicy;		add: BasicPublishPolicy;		add: BasicMergePolicy;		add: BasicOwnershipPolicy;		add: BasicPackagePolicy;		add: BasicVersionPolicy;		add: BranchingVersionPolicy;		add: BasicTableSpacePolicy;		add: BasicFilePolicy;		yourself</body></methods><methods><class-id>Store.Access</class-id> <category>accessing</category><body package="Store-User Management" selector="includeBranchBlessingCommentHistory">includeBranchBlessingCommentHistory	^self mergePolicy includeBranchBlessingCommentHistory</body><body package="Store-User Management" selector="includeBranchBlessingCommentHistory:">includeBranchBlessingCommentHistory: aSymbol	self mergePolicy includeBranchBlessingCommentHistory: aSymbol</body><body package="Store-User Management" selector="integratedBlessingChangePolicy">integratedBlessingChangePolicy	^self mergePolicy integratedBlessingChangePolicy</body><body package="Store-User Management" selector="integratedBlessingChangePolicy:">integratedBlessingChangePolicy: aSymbol	self mergePolicy integratedBlessingChangePolicy: aSymbol</body><body package="Store-User Management" selector="mergeToolMaxInitialTreeSize">mergeToolMaxInitialTreeSize	^self mergePolicy mergeToolMaxInitialTreeSize</body><body package="Store-User Management" selector="mergeToolMaxInitialTreeSize:">mergeToolMaxInitialTreeSize: anInteger	self mergePolicy mergeToolMaxInitialTreeSize: anInteger</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>reading</category><body package="Store-SourceManagement" selector="nextPackageWithSource:">nextPackageWithSource: sourceMode	"Read a collection of classes. The semantics are equivalent to 	fileIn, i.e., only the code is read, not the values of the class 	variables or class instance variables."  	useSource := sourceMode.	readingClasses := true.	^Class commentRequestSignal		handle: [:ex | ex proceedWith: useSource ~= #discard]		do: [self readObject]</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>writing</category><body package="Store-SourceManagement" selector="nextPutPackage:withSource:">nextPutPackage: aPackage withSource: sourceMode	"Store a collection of classes and method additions. The semantics are similar to 	fileOut, i.e., only the code is written, not the values of the class 	variables or class instance variables.  The main difference is that any methods that are additions in another package are	assumed to be the responsibility of the other package and are not stored.	Method changes are shared between package i.e. they clobber each other." 	| classSet objColl  packageArray  |	packageArray := Array new: 7.	packageArray at: 1 put: aPackage classListForPackage.	packageArray at: 2 put: aPackage compiledMethods.	packageArray at: 3 put: aPackage name.	packageArray at: 4 put: aPackage comment.	packageArray at: 5 put: aPackage postLoadBlock.	packageArray at: 6 put: aPackage preUnloadBlock.	packageArray at: 7 put: aPackage currentTag.	useSource := sourceMode.	classSet := IdentitySet new: packageArray first size * 2.	classSet addAll: packageArray first.	objColl := SystemUtils sortForLoading: packageArray first.	objColl := objColl asArray.	packageArray at: 1 put: objColl.	self nextPut: packageArray do:		[objColl do:			[:c |			currentClass := c.			self trace: (BOSSContents new object: c).			self trace: c].		(packageArray at: 2) do:			[:m |			currentClass := m mclass.			self trace: m].		objColl do:			[:c |			| list |			list := c binaryInitializationMessagesFor: useSource.			list do:				[:msg |				| init |				init := Array with: #deferSend: with: msg.				self trace: init body: init class: BinaryObjectStorage indexImportSendSelf]]]</body><body package="Store-SourceManagement" selector="nextPutPackageIndex:">nextPutPackageIndex: aPackage	"Store the index to a package." 	| indexArray |	indexArray := Array new: 4.	indexArray at: 1 put: aPackage literalClassListForPackage.	indexArray at: 2 put: aPackage methods asArray.	indexArray at: 3 put: aPackage name.	indexArray at: 4 put: aPackage indexTag.	self nextPut: indexArray.  "Put table of contents"</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>reading</category><body package="Store-SourceManagement" selector="nextPackage">nextPackage	^self reader nextPackageWithSource: sourceMode</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>writing</category><body package="Store-SourceManagement" selector="nextPutPackage:">nextPutPackage: aPackage	self writer nextPutPackage: aPackage withSource: sourceMode</body><body package="Store-SourceManagement" selector="nextPutPackageIndex:">nextPutPackageIndex: aPackage	self writer nextPutPackageIndex: aPackage</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>private-compiling</category><body package="Atomic Compiling and Loading" selector="compileForShadow:classified:notifying:environment:attributes:">compileForShadow: aString classified: aCategoryName notifying: requestor environment: aNamespace attributes: attributes	"Compile the argument, code, as source code in the context of the receiver 	and install the result in the receiver's method dictionary under the 	classification indicated by the second argument, heading.  The third 	argument, requestor, is to be notified if an error occurs.  The argument code 	is either a string or an object that converts to a string or a 	PositionableStream on an object that converts to a string."		| selector methodSource |	self		compileForShadow: aString		notifying: requestor		attributes: attributes		selectorBlock:			[:newSelector :existingMethod | 			selector := newSelector.			methodSource := existingMethod isNil				ifTrue: [MethodSourceCollection new]				ifFalse: [existingMethod methodSources copy]]		ifFail: [^nil]		environment: aNamespace.	methodSource source: aString.	(methodDict at: selector) sourcePointer: methodSource.	self organization classify: selector under: aCategoryName.	^selector</body><body package="Atomic Compiling and Loading" selector="compileForShadow:notifying:attributes:selectorBlock:ifFail:environment:">compileForShadow: aString notifying: requestor attributes: attributes selectorBlock: selectorBlock ifFail: failBlock environment: aNamespace	"Intercept this message in order to remember system changes."		| methodNode selector compiler message existingMethod |	compiler := self compilerClass new.	compiler environment: aNamespace.	methodNode := compiler 		compile: aString 		in: self 		notifying: requestor 		ifFail: failBlock.	(aNamespace notNil and: [aNamespace ~~ self environment]) ifTrue:		[message := Message selector: #__namespace: argument: aNamespace.		methodNode method: (methodNode generate withAdditionalProperties: (Array with: message))].	selector := methodNode selector.	existingMethod := methodDict at: selector ifAbsent: [nil].	selectorBlock value: selector value: existingMethod.	existingMethod ifNotNil:		[RedefinitionNotification redefinedSelector: selector class: self attributes: existingMethod attributes].	self addSelector: selector withMethod: methodNode generate.	^selector</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading" selector="postCopyFromShadow:">postCopyFromShadow: shadowClass	"We have just been copied from a shadow namespace, either because we were just loaded, or because changes to us were just loaded. Normally we shouldn't have to do anything, but in some circumstances we might. For example, subclasses of GeneralParser rely on side effects of method compilation to populate the methodInfo class instance variable. If the class is compiled in shadow and then the resulting compiled methods are applied, those side effects will have happened only to the shadow class. This method gives us an opportunity to do anything necessary."</body><body package="Atomic Compiling and Loading" selector="redirectInstallTo:">redirectInstallTo: mgr	^mgr installClass: self.</body></methods><methods><class-id>Kernel.BindingReference</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	"Return a boolean indicating whether the receiver actually lives in the system."	| myParent |	myParent := self environment == nil 		ifTrue: [ environment ]		ifFalse:  [ self environment ].	[ myParent environment == nil ] 		whileFalse: [myParent := myParent environment].	^myParent == Root</body></methods><methods><class-id>Kernel.BindingReference</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading" selector="redirectInstallTo:">redirectInstallTo: mgr	^mgr installSharedBinding: self.</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>private-loading</category><body package="Atomic Compiling and Loading" selector="ensureLoadedParcel:withVersion:for:with:">ensureLoadedParcel: parcelName withVersion: versionString for: aPundle with: aCompilationManagerOrNil	"Check if a Parcel named parcelName is loaded with an appropriate version.	If its not then attempt to load it.  If codeReaderOrNil is non-nil then substitute codeReaderOrNil streamDirectory for `current directory' in the SearchPath directory list.	If the parcel is already loaded check its version and bail if its not acceptable.	If aDirectoryOrNil notNil include it after the list.	As a last resort include the current directory.	Map the current directory onto the supplied current directory if dirName is dot and we're not searching the current directory."	| aDirectoryOrNil parcelOrPundle directories found |	aDirectoryOrNil := aPundle ifNotNil: [aPundle streamDirectory].	(parcelOrPundle := self parcelOrPundleNamed: parcelName) ifNotNil:		[(aPundle isNil or: [aPundle checkPrerequisiteNamed: parcelName withVersion: parcelOrPundle traceVersion requiredVersion: versionString])			ifFalse: [CodeReader incompatibleVersionIdSignal raiseRequestWith: (Array with: parcelName with: versionString)].		^parcelOrPundle].	directories := OrderedCollection withAll: self searchPathModel value.		aDirectoryOrNil notNil ifTrue: [directories addLast: aDirectoryOrNil asLogicalFileSpecification].	Parcel parcelFileDirectoryCache removeKey: directories last asResolvedString ifAbsent: [nil].	directories addLast: Filename currentDirectory.	Parcel parcelFileDirectoryCache removeKey: directories last asResolvedString ifAbsent: [nil].	found := false.	1 to: directories size do:		[:index | 		| directoryName directory |		directoryName := directories at: index.		directory := (directoryName asString = Filename defaultClass currentDirectoryString and: [index &lt; directories size]) 			ifTrue: [aDirectoryOrNil] 			ifFalse: [directoryName].		directory ifNotNil:			[self				cachedParcelFileInfoIn: directory asLogicalFileSpecification				for: parcelName				do:					[:info :filename | 					found := found or: [parcelName = (info at: #parcel)].					(parcelName = (info at: #parcel) and: [aPundle isNil or: [aPundle checkPrerequisiteNamed: parcelName withVersion: (info at: #version ifAbsent: ['']) requiredVersion: versionString]])						ifTrue:							[Transcript cr; show: (#autoloadParcelFrom &lt;&lt; #dialogs &gt;&gt; 'Autoloading &lt;1s&gt; from &lt;2s&gt;' expandMacrosWith: parcelName with: filename asString).							^aCompilationManagerOrNil isNil								ifTrue: [self loadParcelCachedFrom: filename]								ifFalse: [self loadParcelCachedFrom: filename with: aCompilationManagerOrNil]]]]].	found ifTrue: [CodeReader incompatibleVersionIdSignal raiseRequestWith: (Array with: parcelName with: versionString)].	^Parcel missingParcelSignal raiseRequestWith: parcelName</body><body package="Atomic Compiling and Loading" selector="loadParcelCachedFrom:with:">loadParcelCachedFrom: aStringOrFilename with: aCompilationManagerOrNil	"Load the required parcel, using the info cache to locate the parcel and any prerequisites.	First see if this parcel is already in the process of being loaded.	If the parcel is being reloaded loadFrom: will return the old parcel."	| loadedParcel loadTag |	loadedParcel := QueryNotification newSignal		parameter: (loadTag := #parcel -&gt; aStringOrFilename asString);		valueWithDefault: [nil].	loadedParcel notNil ifTrue: [^loadedParcel].	aCompilationManagerOrNil ifNotNil: [aCompilationManagerOrNil installEarlyWith: aCompilationManagerOrNil].	loadedParcel := self new.	[	loadedParcel startLoad.		[[loadedParcel := loadedParcel loadFrom: aStringOrFilename with: aCompilationManagerOrNil]			on: QueryNotification			do: 				[:exception|				loadTag = exception parameter ifTrue: [exception resume: loadedParcel].				exception pass].		self replaceParcel: loadedParcel]					on: self abortedActionSignal					do: 						[:exception|						(exception parameter size &lt; 4 or: [(exception parameter at: 4) ~~ #silent]) 							ifTrue: [Dialog warn: exception errorString].						exception parameter first isNil ifFalse: [exception parameter first unload].						^nil].		self loadUninstalledCodePostLoadOf: loadedParcel]							ensure: [loadedParcel endLoad].	^loadedParcel</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>definition</category><body package="Atomic Compiling and Loading" selector="shadowLoadDefineSharedVariable:private:constant:category:initializer:">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: #()</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineSharedVariable:private:constant:category:initializer:attributes:">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: attributes		recordIn: #()</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineSharedVariable:private:constant:category:initializer:attributes:recordIn:">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes recordIn: logNames	"Unlike our not shadowLoad... cousins, we don't touch change sets or try to push ourselves into the file manager.	We're quiet that way, and must be because we're just compiling in the shadow world, not installing.	The resulting object will be put into the appropriate change set and written to the file manager when it is (later) installed"	| targetSelf approved initializer variableBinding bindingReference |	targetSelf := self isInStandardEnvironment		ifTrue: [(SharedNeedsShadowRoot raiseSignal shadowAt: self absoluteReference path) ifNil: [self]]		ifFalse: [self].	(self isKindOf: NameSpaceOfClass) ifTrue: [targetSelf := targetSelf asNameSpace].	targetSelf checkInstalled.	(approved := SystemUtils validateStaticVariableName: varName for: nil) ifNil: [^nil].	initString ifNotNil:		[initializer := targetSelf compileInitializer: initString.		initializer method sourcePointer: initString].	(targetSelf includesKey: approved) ifTrue:		[variableBinding := targetSelf bindingFor: approved.		variableBinding isForGeneral ifFalse:			[| errorMessage |			errorMessage := (#errGeneralVariable &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; exists but is not a general variable. It must be removed from the NameSpace &lt;2p&gt; before this definition can be accepted.')				expandMacrosWith: approved 				with: targetSelf.			targetSelf class failureSignal raiseWith: approved errorString: errorMessage]].	variableBinding isNil		ifTrue:			[variableBinding := SystemUtils ensureName: approved in: targetSelf.			variableBinding forGeneral]		ifFalse: [RedefinitionNotification redefinedBinding: variableBinding in: targetSelf attributes: attributes].	(targetSelf organization notNil and: [newCategory notNil]) ifTrue: 		[targetSelf organization classify: approved under: newCategory asSymbol].	variableBinding bePrivate: isPrivate.	variableBinding beStaticallyDefined: initString notNil.	variableBinding initializer: initializer.	variableBinding beConstant: isConstant.	bindingReference := (BindingReference simpleName: variableBinding key) home: targetSelf namedReferent.	^bindingReference</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineStatic:private:constant:category:initializer:">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	"Backward compatibility."	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: #()</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineStatic:private:constant:category:initializer:attributes:">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: aCollection	"Backward compatibility."	^self shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: aCollection</body></methods><methods><class-id>Kernel.BehaviorBuilderRecord</class-id> <category>accessing</category><body package="Atomic Compiling and Loading" selector="classOfBehavior:">classOfBehavior: aBehavior	^aBehavior isBehavior		ifTrue: [aBehavior class]		ifFalse: [aBehavior isNil			ifTrue: [ RequestNilSuperClassNotification raiseSignal ]			ifFalse: [self buildError: (#ThisObjectShouldBeNilOrBehavior &lt;&lt; #dialogs &gt;&gt; 'This object should be nil or a Behavior')]]</body></methods><methods><class-id>Kernel.BehaviorBuilderRecord</class-id> <category>accessing shadow compiliation</category><body package="Atomic Compiling and Loading" selector="standardEnvironmentClass">standardEnvironmentClass	"If the receiver has a targetClass, then ask the targetClass for its standardEnvironmentClass.  	 See Behavior&gt;&gt;standardEnvironmentClass for more details."	^targetClass ifNotNil: [targetClass standardEnvironmentClass]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>changes</category><body package="Atomic Compiling and Loading" selector="recompileExtensionsForSunshine">recompileExtensionsForSunshine	"Our compilation scope has changed. Recompile any extension methods which may be affected"		self extensionsDo:		[:eachClass :eachSelector | 		| method |		method := eachClass compiledMethodAt: eachSelector.		((method isKindOf: ExternalMethod) not and: [(method mclass nonMeta includesBehavior: ExternalInterface) not])			ifTrue: [eachClass recompileForSunshine: eachSelector in: (self environmentFor: eachSelector in: eachClass)]]</body><body package="Atomic Compiling and Loading" selector="recompileOverrideAffectedMethods">recompileOverrideAffectedMethods	| affectedClasses |	affectedClasses := self allClasses select: [:each | Override inheritsFromOverriddenClass: each value].	affectedClasses := affectedClasses collect: [:each | each value].	affectedClasses := SystemUtils sortForLoading: affectedClasses.	affectedClasses do: [:each | each selectors do: [:eachSelector | each recompile: eachSelector]]</body><body package="Atomic Compiling and Loading" selector="recompileSunshineMethodsFor:">recompileSunshineMethodsFor: aClass	"Our compilation scope has changed. Recompile any methods which may be affected."		| environment realClass |	realClass := aClass isBehavior		ifTrue: [aClass instanceBehavior]		ifFalse: [aClass actualClass instanceBehavior].	environment := (self includesDefinitionOf: realClass absoluteName)		ifTrue: [nil]		ifFalse: [self environment].	self methodsFor: aClass do:		[:eachClass :eachSelector | 		eachClass recompileForSunshine: eachSelector in: environment]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change management</category><body package="Atomic Compiling and Loading" selector="removeDeletedDefinitions:">removeDeletedDefinitions: packageDifferences	"Using packageDifferences, adjust the receiver so that those definitions are removed are removed 	 in such a way that any overrides are restored.  This is used by the shadow loading system."		packageDifferences methodsToRemoveAfterLoad do:		[:each | Override unloadSelector: each selector class: each correspondingImageClass from: self logged: true].	packageDifferences sharedsToRemoveAfterLoad do:		[:each | Override unloadStatic: each in: each owner from: self logged: #(#changes #file)].	packageDifferences sortedClassesToRemoveAfterLoad , packageDifferences nameSpacesToRemoveAfterLoad do:		[:each | Override unloadClassOrNameSpace: each actual from: self]</body></methods><methods><class-id>Kernel.NameSpaceOfClass</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	^self owner isInStandardEnvironment</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading" selector="redirectInstallTo:">redirectInstallTo: mgr	^mgr installMethod: self.</body></methods><methods><class-id>Kernel.MetaclassBuilderRecord</class-id> <category>mutation</category><body package="Atomic Compiling and Loading" selector="constructCopy">constructCopy	newClass == nil ifFalse: [^newClass].	self targetClass == nil		ifFalse: [^super constructCopy].	newClass := self newMetaclass new.	newClass hash.	newClass setSuperclass: self newSuperclass.	newClass methodDictionary: MethodDictionary new.	newClass setInstanceFormat: (Behavior											formatFromType: self behaviorType											super: self superclass											instVars: instVarNames).	instance environment isInStandardEnvironment ifTrue:		[newClass addToSuper].	^newClass</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="isCompilationResult">isCompilationResult	^false</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>atomic loading</category><body package="Atomic Compiling and Loading" selector="queryAtomicallyLoaded:ifPreviouslyLoadedAndOK:ifFail:">queryAtomicallyLoaded: aParcelName ifPreviouslyLoadedAndOK: anUpdateBlock ifFail: aFailBlock	"Check if the receiver is already loaded and if so, take whatever error actions are required and 	 evaluate aBlock with the error value, which will probably be derived from some exception handler."		| parcelOrPundle |	parcelOrPundle := self class parcelOrPundleNamed: aParcelName.	parcelOrPundle isNil ifTrue: [^self].	parcelOrPundle isLoaded ifFalse: [^self].	^(Parcel parcelAlreadyLoadedSignal raiseRequestWith: aParcelName)		ifTrue: [anUpdateBlock value: parcelOrPundle asParcel]		ifFalse:			[aFailBlock value:				(self class abortedActionSignal					raiseRequestWith: (Array with: self with: aParcelName with: #parcelAlreadyLoaded &lt;&lt; #dialogs &gt;&gt; 'Parcel already loaded' with: #silent)					errorString: #loadAborted &lt;&lt; #dialogs &gt;&gt; 'Parcel load aborted')]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>actions</category><body package="Atomic Compiling and Loading" selector="recompileExtensionsForSunshine">recompileExtensionsForSunshine	"I don't do this, but subclasses might"	^self</body><body package="Atomic Compiling and Loading" selector="runComponentPostLoad">runComponentPostLoad	"Run the postLoad code for the receiver. "		| loadBlock |	(loadBlock := self postLoadBlock) ifNil: [^true].	self recompileExtensions.	[loadBlock value: self]		on: Error		do: 			[:exception | 			(Store.LoadingActionError pundle: self action: #postLoad error: exception) ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	^true</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>class creation</category><body package="Atomic Compiling and Loading" selector="shadowLoadSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a subclass	of nil (UndefinedObject)."	| approved builder |	ClassBuilder nilSuperclassSignal raiseRequest.	approved := SystemUtils validateClassName: t for: nil.	approved ifNil: [^self].	builder := self class classBuilder addRecord: (BehaviorBuilderRecord forName: approved in: Smalltalk).	^builder		superclass: self;		instVarString: f;		classVarString: d;		poolString: s;		category: cat;		beFixed;		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading" selector="shadowLoadVariableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadVariableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as asubclass	of an existing class (the receiver) in which the subclass is to have indexable	byte-sized nonpointer variables."	| approved |	ClassBuilder nilSuperclassSignal raiseRequest.	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^self].	^self class classBuilder		superclass: self;		environment: Smalltalk;		className: approved;		instVarString: f;		classVarString: d;		poolString: s;		category: cat;		beBytes;		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading" selector="shadowLoadVariableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadVariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a subclass	of an existing class (the receiver) in which the subclass is to have indexable	pointer variables."	| approved |	ClassBuilder nilSuperclassSignal raiseRequest.	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^self].	^self class classBuilder		superclass: self;		environment: Smalltalk;		className: approved;		instVarString: f;		classVarString: d;		poolString: s;		category: cat;		beVariable;		reviseSystemForAtomicCompiling</body></methods><methods><class-id>Kernel.AssemblerCodeStream</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="realClassOrNil">realClassOrNil	"This method is supplied by the Shadowed Compiling package.  It is used to help determine	if the destination class for the method will be in the Context hierarchy.	We should not track up the superclass chain. If the class's standardEnvironmentClass is nil, 	it should just directly answer nil. Otherwise, if I'm adding a new subclass to Object, its realClassOrNil will be Object. 	This new class can't be an ancestor of Context or SmallInteger, but Object is an ancestor class of Context and SmallInteger, 	so the analysis of forNonImmediate and forContext will be wrong"	Store.DbRegistry useAtomicLoader ifFalse: [^class].	^class standardEnvironmentClass.</body><body package="Atomic Compiling and Loading" selector="setContextFlag">setContextFlag	"We just saw our first reference to	an instance variable.  Check whether	this class might be a sub- or superclass	of Context, which requires special	action at run time."	"This method is overridden by the Shadow Compiling package to ensure that if 	 an extension method is being installed on Context, a proper CompiledMethod is	 created.  Context (and subclasses) have special CompiledMethods that are not	 short."	|realClass|	realClass := self realClassOrNil.	realClass == nil ifTrue: 		[forContext := false. 		^self].	forContext := realClass instSize &lt; Context instSize		ifTrue: [Context inheritsFrom: realClass]		ifFalse: [realClass == Context or: [realClass inheritsFrom: Context]]</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating class hierarchy</category><body package="Atomic Compiling and Loading" selector="addToSuper">addToSuper	"Add the receiver to the superclass's subclass list."	( superclass isInStandardEnvironment == self isInStandardEnvironment )		ifFalse: [ ^self ].	superclass == nil		ifFalse:	[superclass addSubclass: self]</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing shadow compilation</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	"Are we part of the real system, or of a shaow namespace. For anonymous behaviors, we assert that they are in the standard environment, since they don't really exist in a namespace."	^true.</body></methods><methods><class-id>Core.Behavior</class-id> <category>compiling</category><body package="Atomic Compiling and Loading" selector="recompileForSunshine:from:">recompileForSunshine: selector from: oldClass	"Recompile the method associated with selector in the receiver's method dictionary.	Take care not to write out any new source code - just generate new bytes.	oldClass may differ from self in order to decompile right (if sourceFiles == nil)	when adding or removing fields of a class."	self recompileForSunshine: selector from: oldClass in: nil.</body><body package="Atomic Compiling and Loading" selector="recompileForSunshine:from:in:">recompileForSunshine: selector from: oldClass in: aNamespace	"Recompile the method associated with selector in the receiver's method dictionary.	Take care not to write out any new source code - just generate new bytes.	oldClass may differ from self in order to decompile right (if sourceFiles == nil)	when adding or removing fields of a class."		| method methodNode sourcePointer compiler |	method := oldClass compiledMethodAt: selector.	sourcePointer := method sourcePointer.	compiler := (self isMeta ifTrue: [self nonMeta classCompilerClass] ifFalse: [self compilerClass]) new.	compiler environment: aNamespace.	methodNode := compiler		compile: (oldClass sourceCodeAt: selector)		in: self		notifying: nil		ifFail: [self error: #errFailureWhileRecompiling &lt;&lt; #dialogs &gt;&gt; 'Failure during recompiling method'].	methodNode == nil ifTrue: [^self recompileForSunshine: selector in: aNamespace].	"Try again after proceed from SyntaxError"	method := methodNode generate.	method sourcePointer: sourcePointer.	self addSelector: selector withMethod: method</body><body package="Atomic Compiling and Loading" selector="recompileForSunshine:in:">recompileForSunshine: selector in: aNamespace	"Recompile the method associated with selector in the receiver's method dictionary.	Take care not to write out any new source code - just generate new bytes.	It's possible that we won't be able to recompile, e.g. if it's a DLL/CC method, and the DLL/CC compiler is not available. If so, we'll get a SyntaxErrorException. Since we know the method compiled previously, assume that means a missing compiler, and just leave the method as is."	^[self recompileForSunshine: selector from: self in: aNamespace]		on: SyntaxErrorException		do: [:ex | ex return: (self compiledMethodAt: selector)].</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing shadow compilation</category><body package="Atomic Compiling and Loading" selector="standardEnvironmentClass">standardEnvironmentClass	"The receiver is assumed to exist in a shadow namespace created by the shadow compliation system.	 If the receiver is shadowing a class from the system, return that class it shadows.  Otherwise return	 nil.  The shadow compliation system is expected to know how to treat nil."		| realClass |	self isInStandardEnvironment ifTrue: [^self].	realClass := self absoluteName asClassNameOnly asStrictReference		ifDefinedDo: [:value | value]		elseDo: [^nil].	^self isMeta		ifTrue: [realClass class]		ifFalse: [realClass]</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="Atomic Compiling and Loading" selector="definitionMessage">definitionMessage	| args attr sel private |	args := (Array new: 5) writeStream.	private := self isInStandardEnvironment 		ifTrue: [self fullyQualifiedReference binding isPrivate]		ifFalse: [false].	args nextPut: self name;		nextPut: private;		nextPut: self importString;		nextPut: self category asString.	attr := self extraAttributesForDefinition.	attr isEmpty		ifTrue: [sel := #defineNameSpace:private:imports:category:]		ifFalse: 			[sel := #defineNameSpace:private:imports:category:attributes:.			args nextPut: attr].	^MessageSend		receiver: self environment		selector: sel		arguments: args contents</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	"Return a boolean indicating whether the receiver actually lives in the system."	| myEnvironment |	myEnvironment := self environment == nil ifTrue: [self] ifFalse: [self environment].	[myEnvironment environment == nil] whileFalse: 		[myEnvironment := myEnvironment environment].	^myEnvironment == Root</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="mergeDeeplyFrom:">mergeDeeplyFrom: aShadowEnvironment	aShadowEnvironment keys do: 		[:each | 		(self at: each ifAbsent: [nil]) isNil 			ifTrue: [self at: each put: (aShadowEnvironment at: each)] 			ifFalse:				[((self at: each) isForNameSpace and: [(aShadowEnvironment at: each) isForNameSpace]) ifTrue: 					[(self at: each) mergeDeeplyFrom: (aShadowEnvironment at: each)]]]</body><body package="Atomic Compiling and Loading" selector="mergeDeeplyFrom:butNot:">mergeDeeplyFrom: aShadowEnvironment butNot: aSet	aShadowEnvironment keys do: 		[:each | 		(self at: each ifAbsent: [nil]) isNil 			ifTrue: [(aShadowEnvironment at: each) ifNotNil: [:value | self at: each put: value]]			ifFalse:				[((aSet includes: each) not and: [(self at: each) isForNameSpace and: [(aShadowEnvironment at: each) isForNameSpace]]) ifTrue: 					[aSet add: each.					(self at: each) mergeDeeplyFrom: (aShadowEnvironment at: each) butNot: aSet]]]</body><body package="Atomic Compiling and Loading" selector="reallyFullyQualifiedReference">reallyFullyQualifiedReference	| mySmalltalk |	mySmalltalk := self.	mySmalltalk environment == nil 		ifTrue: [^self fullyQualifiedReferenceFrom: mySmalltalk].	[  ( mySmalltalk environment == nil ) | ( mySmalltalk = Smalltalk ) ]		whileFalse: [mySmalltalk := mySmalltalk environment].	^self fullyQualifiedReferenceFrom: mySmalltalk	"FileTools fullyQualifiedReference"	"FileTools fullyQualifiedReferenceFrom: Smalltalk"	"FileTools fullyQualifiedReferenceFrom: FileTools environment"	"FileTools reallyFullyQualifiedReference"	"FileTools fullyQualifiedReferenceFrom: Smalltalk"	"FileTools fullyQualifiedReferenceFrom: FileTools environment"</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>store-shadow compilation</category><body package="Atomic Compiling and Loading" selector="redirectInstallTo:">redirectInstallTo: mgr	^mgr installNameSpace: self.</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="Atomic Compiling and Loading" selector="shadowLoadDefineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:">shadowLoadDefineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category	^self shadowLoadDefineClass: className		superclass: superID		indexedType: typeName		private: isPrivate		instanceVariableNames: iVars		classInstanceVariableNames: ciVars		imports: pools		category: category		attributes: #( )</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:">shadowLoadDefineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes	"In the Shadow world, we don't care if the binding is constant"	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding value isBehavior]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystemForAtomicCompiling.	^class</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineNameSpace:private:imports:category:">shadowLoadDefineNameSpace: poolName private: isPrivate imports: importString category: newCategory	^self shadowLoadDefineNameSpace: poolName		private: isPrivate		imports: importString		category: newCategory		attributes: #()</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineNameSpace:private:imports:category:attributes:">shadowLoadDefineNameSpace: poolName private: isPrivate imports: importString category: newCategory attributes: attributes		| newNamespace approved isNew |	approved := SystemUtils validateStaticVariableName: poolName for: nil.	approved == nil ifTrue: [^nil].	(self includesKey: approved)		ifTrue:			[| which |			which := self bindingFor: approved.			(which value class == self class and: [which isForNameSpace])				ifTrue: [newNamespace := which value]				ifFalse:					[| errorMessage |					newNamespace := nil.					errorMessage := #errIsNotNameSpace &lt;&lt; #dialogs &gt;&gt;							'&lt;1s&gt; is a global but is not an existing NameSpace. It must be removed from the NameSpace &lt;2p&gt; before this definition can be accepted.'						expandMacrosWith: approved with: self.					self class failureSignal raiseWith: approved errorString: errorMessage]]		ifFalse: [newNamespace := nil].	(isNew := newNamespace == nil)		ifTrue:			[| newVariableBinding |			newNamespace := self class new.			newNamespace name: approved.			newNamespace environment: self.			newVariableBinding := SystemUtils				quietlyEnsureName: newNamespace name				in: self.			newVariableBinding setValue: newNamespace.			newVariableBinding forNameSpace]		ifFalse:			[RedefinitionNotification redefinedNameSpace: newNamespace attributes: attributes].	self organization == nil		ifFalse:			[self organization				classify: approved				under: newCategory asSymbol].	newNamespace imports: importString.	newNamespace reallyFullyQualifiedReference binding bePrivate: isPrivate.	isNew		ifTrue: [ChangeSet addNameSpace: newNamespace attributes: attributes]		ifFalse: [ChangeSet changeNameSpace: newNamespace attributes: attributes].	newNamespace fileOutDefinitionOn: SourceFileManager default.	^newNamespace</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefinitionMessage">shadowLoadDefinitionMessage		| argumentStream extraAttributes selector |	argumentStream := (Array new: 5) writeStream.	argumentStream		nextPut: self name;		nextPut: (self environment isNil			ifTrue: [self fullyQualifiedReference binding isPrivate]			ifFalse: [(self environment bindingFor: self name) isPrivate]);		nextPut: self importString;		nextPut: self category asString.	extraAttributes := self extraAttributesForDefinition.	extraAttributes isEmpty		ifTrue: [selector := #shadowLoadDefineNameSpace:private:imports:category:]		ifFalse:			[selector := #shadowLoadDefineNameSpace:private:imports:category:attributes:.			argumentStream nextPut: extraAttributes].	^MessageSend		receiver: self environment		selector: selector		arguments: argumentStream contents</body></methods><methods><class-id>Kernel.ClassBuilder</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="reviseSystemForAtomicCompiling">reviseSystemForAtomicCompiling	records do: [:each | each redefinitionCheck].	^self reviseSystemSilently.</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	^self instanceBehavior isInStandardEnvironment</body></methods><methods><class-id>Kernel.HintedCodeStream</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="isShadowClassIsForNonImmediate">isShadowClassIsForNonImmediate	"Make an explicit test for realClass if it is nil. 	The problem is that SmallInteger inheritsFrom nil, so if this method didn't test for nil it would answer true, 	when the desired behavior when realClass is nil is for this method to answer false."		| realClass |	(realClass := self realClassOrNil) ifNil: [^false].	^(SmallInteger inheritsFrom: realClass) or:		[(Character inheritsFrom: realClass)			or: [SmallDouble inheritsFrom: realClass]]</body><body package="Atomic Compiling and Loading" selector="setClassProperties">setClassProperties	"Set the flags indicating whether this class	is definitely a non-subclassable (immediate) class,	or if this class is definitely not	an immediate class or a superclass of one."	class instSize &gt; 0	  ifTrue:  "can't be a super of an immediate"		[forNonImmediate := true.		forNonSubclassable := false]	  ifFalse:		[class hasImmediateInstances		  ifTrue:			[forNonImmediate := false.			forNonSubclassable := true]		  ifFalse:			[forNonImmediate := ((SmallInteger inheritsFrom: class)								or: [(Character inheritsFrom: class)								or: [(SmallDouble inheritsFrom: class)								or: [self isShadowClassIsForNonImmediate]]]) not.			forNonSubclassable := false]]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private</category><body package="Atomic Compiling and Loading" selector="basicClasses">basicClasses	^classes</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>testing</category><body package="Atomic Compiling and Loading" selector="installed">installed	^self isLoaded</body></methods><methods><class-id>Core.Class</class-id> <category>testing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="isInStandardEnvironment">isInStandardEnvironment	| myEnvironment |	myEnvironment := self environment == nil 				ifTrue: [environment]				ifFalse: [self environment].	[myEnvironment environment == nil] 		whileFalse: [myEnvironment := myEnvironment environment].	^myEnvironment == Root</body></methods><methods><class-id>Core.Class</class-id> <category>accessing-store shadow compilation</category><body package="Atomic Compiling and Loading" selector="reallyFullyQualifiedReference">reallyFullyQualifiedReference	| mySmalltalk |	mySmalltalk := self.	mySmalltalk environment == nil 		ifTrue: [^self fullyQualifiedReferenceFrom: mySmalltalk].	[mySmalltalk environment environment == nil] 		whileFalse: [mySmalltalk := mySmalltalk environment].	^self fullyQualifiedReferenceFrom: mySmalltalk</body></methods><methods><class-id>Core.Class</class-id> <category>class variables</category><body package="Atomic Compiling and Loading" selector="shadowLoadDefineSharedVariable:private:constant:category:initializer:">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	^self asNameSpace 		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineSharedVariable:private:constant:category:initializer:attributes:">shadowLoadDefineSharedVariable: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes	^self asNameSpace 		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: attributes</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineStatic:private:constant:category:initializer:">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString	"Backward compatibility."	^self		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString</body><body package="Atomic Compiling and Loading" selector="shadowLoadDefineStatic:private:constant:category:initializer:attributes:">shadowLoadDefineStatic: varName private: isPrivate constant: isConstant category: newCategory initializer: initString attributes: attributes	"Backward compatibility."	^self		shadowLoadDefineSharedVariable: varName		private: isPrivate		constant: isConstant		category: newCategory		initializer: initString		attributes: attributes</body></methods><methods><class-id>Core.Class</class-id> <category>subclass creation</category><body package="Atomic Compiling and Loading" selector="shadowLoadSubclass:instanceVariableNames:classVariableNames:poolDictionaries:">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver). This method has been retained for	VisualSmalltalk file-out compatibility."	^self shadowLoadSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: self environment organization class defaultProtocol</body><body package="Atomic Compiling and Loading" selector="shadowLoadSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver)."	| approved builder |	approved := SystemUtils validateClassName: t for: nil.	approved ifNil: [^nil].	builder := self classBuilder addRecord: (BehaviorBuilderRecord forName: approved in: Smalltalk).	^builder		superclass: self;		instVarString: f;		classVarString: d;		poolString: (self computeFullPoolString: s);		category: cat;		beFixed;		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading" selector="shadowLoadVariableByteSubclass:classVariableNames:poolDictionaries:">shadowLoadVariableByteSubclass: t classVariableNames: d poolDictionaries: s	"This is a compatibility API method for creating a new class 	as a subclass of an existing class (the receiver) in which the 	subclass is to have indexable byte-sized nonpointer variables.	This method has been retained for VisualSmalltalk file-out	compatibility."	^self shadowLoadVariableByteSubclass: t		instanceVariableNames: ''		classVariableNames: d		poolDictionaries: s		category: self environment organization class defaultProtocol</body><body package="Atomic Compiling and Loading" selector="shadowLoadVariableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadVariableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is a compatibility API method for creating a new class 	as a subclass of an existing class (the receiver) in which the 	subclass is to have indexable byte-sized nonpointer variables."	| approved |	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^nil].	^(self classBuilder) 		superclass: self; 		environment: Smalltalk; 		className: approved; 		instVarString: f; 		classVarString: d; 		poolString: (self computeFullPoolString: s); 		category: cat; 		beBytes; 		reviseSystemForAtomicCompiling</body><body package="Atomic Compiling and Loading" selector="shadowLoadVariableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:">shadowLoadVariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver) in which the subclass is to have indexable	pointer variables. This method has been retained for VisualSmalltalk file-out compatibility."	^self shadowLoadVariableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: self environment organization class defaultProtocol</body><body package="Atomic Compiling and Loading" selector="shadowLoadVariableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadVariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is a compatibility API method for creating a new class as a subclass	of an existing class (the receiver) in which the subclass is to have indexable	pointer variables. This method has been retained for VisualSmalltalk file-out	compatibility."	| approved |	approved := SystemUtils			validateClassName: t			for: nil.	approved == nil ifTrue: [^nil].	^self classBuilder		superclass: self;		environment: Smalltalk;		className: approved;		instVarString: f;		classVarString: d;		poolString: (self computeFullPoolString: s);		category: cat;		beVariable;		reviseSystemForAtomicCompiling</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>creating subclasses</category><body package="Atomic Compiling and Loading" selector="shadowLoadSubclass:includeFiles:includeDirectories:libraryFiles:libraryDirectories:generateMethods:beVirtual:optimizationLevel:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadSubclass: t includeFiles: if includeDirectories: id libraryFiles: lf libraryDirectories: ld generateMethods: gm beVirtual: bv optimizationLevel: optLevel instanceVariableNames: f classVariableNames: d poolDictionaries: pd category: cat	"This is the enhanced initialization message for creating a new class as a subclass of the receiver.  Answer the new subclass."	| attrs theClass |	attrs := OrderedCollection new			add: (Array with: #includeFiles with: if);			add: (Array with: #includeDirectories with: id);			add: (Array with: #libraryFiles with: lf);			add: (Array with: #libraryDirectories with: ld);			add: (Array with: #beVirtual with: bv);			add: (Array with: #optimizationLevel with: optLevel);			asArray.	theClass := self classBuilder		superclass: self fullyQualifiedReference;		environment: Smalltalk;		className: ((SystemUtils validateClassName: t for: nil) ifNil: [^nil]);		instVarString: f;		classVarString: d;		poolString: pd;		attributes: attrs;		category: cat;		beFixed;		reviseSystemForAtomicCompiling.	^theClass</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>subclass creation</category><body package="Atomic Compiling and Loading" selector="shadowLoadSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:">shadowLoadSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a subclass of an existing class (the receiver).  Use default values for arguments supported by the receiver not specified by this message."	^self		subclass: t		includeFiles: ''		includeDirectories: ''		libraryFiles: ''		libraryDirectories: ''		generateMethods: ''		beVirtual: false		optimizationLevel: self defaultOptimizationLevel		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>linking</category><body package="Atomic Compiling and Loading" selector="quietlyEnsureName:in:">quietlyEnsureName: newName in: aNameSpace	"The binding is assumed to be new--i.e., it does not exist in	any NameSpace. Add it to Undeclared."	| new old |	(aNameSpace asNameSpace includesKey: newName)		ifTrue: [^aNameSpace bindingFor: newName].	new := aNameSpace asNameSpace createKey: newName value: nil.	(old := Undeclared bindingFor: newName) notNil		ifTrue: [new value: old value].	aNameSpace asNameSpace simpleAddBinding: new.	^new</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="Store-Database Model" selector="createDatabase:onDevice:size:in:">createDatabase: aDatabaseName onDevice: aDeviceName size: aString in: aDatabaseAccessor	| sqlString |	sqlString := self createDatabaseStringFor: aDatabaseName on: aDeviceName size: aString.	aDatabaseAccessor		executeInDDLOperation: 			[aDatabaseAccessor executeSQLStringNoResult: sqlString]		ifError: [:ex | self halt]</body><body package="Store-Database Model" selector="createDatabaseStringFor:on:size:">createDatabaseStringFor: aTablespaceName on: aFileNameString size: aString		^'CREATE TABLESPACE ' , aTablespaceName , ' DATAFILE ''' , aFileNameString , '''  SIZE ' , aString ,	'  REUSE DEFAULT STORAGE (INITIAL 1M NEXT 512K PCTINCREASE 1)'</body><body package="Store-Database Model" selector="createTableStatementStringFor:">createTableStatementStringFor: aGLORPDatabaseTable	| sqlString stream |	sqlString := super createTableStatementStringFor: aGLORPDatabaseTable.	stream := WriteStream with: sqlString.	(aGLORPDatabaseTable respondsTo: #propertyAt:) ifTrue:		[(aGLORPDatabaseTable propertyAt: #tableSpaceName) ifNotNil:			[:value |			stream nextPutAll: ' TABLESPACE ' , value]].	^stream contents</body><body package="Store-Database Model" selector="installPhysicalSpacesIn:">installPhysicalSpacesIn: aDatabaseAccessor		| path baseFilename spaceForBlobs defaultTableSpace names name methodsTableSpace userTableSpace |	Store.DbRegistry goToScript ifFalse:		[(Dialog confirm: #CreateTablespacesQ &lt;&lt; #store &gt;&gt; 'Create tablespaces? (Answer no only if they have already been created)') ifFalse: 			[^self]].	path := Dialog request: #PleaseEnterTableSpaceDirectory &lt;&lt; #store &gt;&gt; 'Please, enter directory for the table spaces.' initialAnswer: ''.	path isEmpty ifTrue: [^self].	baseFilename := (path includes: Filename getSeparator)		ifTrue: [path asFilename]		ifFalse: 			[(path includes: UnixFilename getSeparator) 				ifTrue: [UnixFilename named: path] 				ifFalse: [PCFilename named: path]].	names := Set new.	name := baseFilename constructString: (spaceForBlobs := Store.Policies tableSpacePolicy blobTableSpace) , '.dbf'.	names add: name -&gt; spaceForBlobs.	name := baseFilename constructString: (defaultTableSpace := Store.Policies tableSpacePolicy defaultTableSpace) , '.dbf'.	names add: name -&gt; defaultTableSpace.	name := baseFilename constructString: (methodsTableSpace := Store.Policies tableSpacePolicy methodsTableSpace) , '.dbf'.	names add: name -&gt; methodsTableSpace.	name := baseFilename constructString: (userTableSpace := Store.Policies tableSpacePolicy userAndOwnershipTableSpace) , '.dbf'.	names add: name -&gt; userTableSpace.	names do:		[:each | 		| size |		size := each value = spaceForBlobs 			ifTrue: [self spaceForBlobs] 			ifFalse: [self spaceForClasses].		self createDatabase: each value onDevice: each key size: size in: aDatabaseAccessor.		self setAutoExtentFor: each key in: aDatabaseAccessor]</body><body package="Store-Database Model" selector="setAutoExtentFor:in:">setAutoExtentFor: fileName1 in: aDatabaseAccessor		aDatabaseAccessor		executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: 'ALTER DATABASE DATAFILE ''' , fileName1 , ''' AUTOEXTEND ON']		ifError: [:exception | self halt]</body><body package="Store-Database Model" selector="spaceForBlobs">spaceForBlobs	^ '32M'</body><body package="Store-Database Model" selector="spaceForClasses">spaceForClasses	^ '32M'</body><body package="Store-Database Model" selector="storeSchemaNotFoundError">storeSchemaNotFoundError	^InvalidTableName</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>testing</category><body package="Store-Database Model" selector="supportsPhysicalSpaces">supportsPhysicalSpaces	^true</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="Store-Database Model" selector="createDatabase:onDevice:size:in:">createDatabase: aDatabaseName onDevice: aDeviceName size: aString in: aDatabaseAccessor	| sqlString |	sqlString := self createDatabaseStringFor: aDatabaseName on: aDeviceName size: aString.	aDatabaseAccessor		executeInDDLOperation: 			[aDatabaseAccessor executeSQLStringNoResult: sqlString]		ifError: [:ex | self halt]</body><body package="Store-Database Model" selector="createDatabaseStringFor:on:size:">createDatabaseStringFor: aDatabaseName on: aDeviceName size: aString	^'CREATE DATABASE ' , aDatabaseName , ' ON  ( NAME = ' , aDatabaseName , '_dat, ' , ' FILENAME = ''' , aDeviceName , ''', ' , ' SIZE = ' , aString , ') COLLATE Latin1_General_CS_AS'</body><body package="Store-Database Model" selector="createLoginIn:">createLoginIn: aDatabaseAccessor		| tableOwner |	aDatabaseAccessor executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: 'USE master'] ifError: [:ex | self halt].	tableOwner := aDatabaseAccessor currentLogin schema.	aDatabaseAccessor		executeInDDLOperation: 			[aDatabaseAccessor executeSQLStringNoResult: ('EXEC sp_addlogin ' , tableOwner , ', ' , tableOwner) asString]		ifError: 			[:ex |			| dbmsError |			dbmsError := ex parameter first.			dbmsError sqlState = '37000'				ifTrue: [ex return: true]				ifFalse: [ex pass]].</body><body package="Store-Database Model" selector="createNewAccountIn:">createNewAccountIn: aDatabaseAccessor	"Create the  SQL Server security account."	| str res tableOwner |	tableOwner := aDatabaseAccessor currentLogin schema.	(tableOwner equivalentTo: 'dbo' ignoreCase:  true) ifTrue: [^false].	str := (String new: 50) writeStream. 	str nextPutAll: ((#PressYesToCreateAccount1s1sn &lt;&lt; #store &gt;&gt; 'Press Yes to create a new account: &lt;1s&gt; password: &lt;1s&gt;&lt;n&gt;') expandMacrosWith: tableOwner).	str nextPutAll: (#PressNoToUseDBO &lt;&lt; #store &gt;&gt; 'Press No to use the dbo account&lt;n&gt;') expandMacros.	str nextPutAll:(#PressCancelToCancel &lt;&lt; #store &gt;&gt; 'Press Cancel  to cancel the installation') asString.		res := Dialog		choose: str contents		labels: (Array with: 'Yes' with: 'No'  with: 'Cancel')		values: #(#yes #no #cancel)		default: #maybe.	res == #yes ifTrue: 		[self createLoginIn: aDatabaseAccessor. 		^ true].	res == #no ifTrue: 		[Store.DbRegistry updateTablePrefix: 'dbo'. 		^ false].	res == #cancel ifTrue: [Error raiseSignal: 'Installation was canceled'].</body><body package="Store-Database Model" selector="grantAccessIn:">grantAccessIn: aDatabaseAccessor	self grantDBAccess: Store.Policies tableSpacePolicy blobTableSpace in: aDatabaseAccessor.	self grantDBAccess: Store.Policies tableSpacePolicy defaultTableSpace in: aDatabaseAccessor.</body><body package="Store-Database Model" selector="grantDBAccess:in:">grantDBAccess: aString in: aDatabaseAccessor		| tableOwner |	tableOwner := aDatabaseAccessor currentLogin schema.	aDatabaseAccessor executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: 'USE ' , aString] ifError: [:ex | self halt].	aDatabaseAccessor		executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: 'EXEC sp_grantdbaccess ' , tableOwner , ', ' , tableOwner]		ifError: [:ex | self halt].	aDatabaseAccessor		executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult:  'GRANT CREATE TABLE, CREATE VIEW, CREATE DEFAULT,  CREATE PROCEDURE TO ', tableOwner.]		ifError: [:ex | self halt].</body><body package="Store-Database Model" selector="installPhysicalSpacesIn:">installPhysicalSpacesIn: aDatabaseAccessor	| path baseFilename spaceForBlobs defaultTableSpace accountCreated names name methodsTableSpace userTableSpace |	Store.DbRegistry goToScript ifFalse:		[(Dialog confirm: #CreateTablespacesQ &lt;&lt; #store &gt;&gt; 'Create tablespaces? (Answer no only if they have already been created)') 			ifFalse: [^self]].	path := Dialog request: #PleaseEnterTableSpaceDirectory &lt;&lt; #store &gt;&gt; 'Please, enter directory for the table spaces.' initialAnswer: ''.	path isEmpty ifTrue: [^self].	baseFilename := (path includes: Filename getSeparator)		ifTrue: [path asFilename]		ifFalse: [(path includes: UnixFilename getSeparator)			ifTrue: [UnixFilename named: path]			ifFalse: [PCFilename named: path]].	names := Set new.	name :=  (baseFilename constructString: (spaceForBlobs := Store.Policies tableSpacePolicy blobTableSpace), '.mdf').	names add: name -&gt; spaceForBlobs.	name := (baseFilename constructString: (defaultTableSpace := Store.Policies tableSpacePolicy defaultTableSpace), '.mdf').	names add: name -&gt; defaultTableSpace.	name := (baseFilename constructString: (methodsTableSpace := Store.Policies tableSpacePolicy methodsTableSpace), '.mdf').	names add: name -&gt; methodsTableSpace.	name := (baseFilename constructString: (userTableSpace := Store.Policies tableSpacePolicy userAndOwnershipTableSpace), '.mdf').	names add: name -&gt; userTableSpace.	^ [accountCreated := self isNewAccountCreatedIn: aDatabaseAccessor.	names do:		[:each |		| size |		size := each value = spaceForBlobs			ifTrue: [self spaceForBlobs]			ifFalse: [self spaceForClasses].		self createDatabase: each value onDevice: each key size: size in: aDatabaseAccessor].	accountCreated ifTrue: [self grantAccessIn: aDatabaseAccessor].	true] 		on: Error 		do: [:exp | nil].</body><body package="Store-Database Model" selector="isLoginExist:in:">isLoginExist: aName in: aDatabaseAccessor	aDatabaseAccessor executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: 'USE master'] ifError: [:ex | self halt].	^ [aDatabaseAccessor executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: ( 'EXEC sp_addlogin '  ,  aName, ', ', aName  ) asString] ifError: 			[:ex | 			| dbmsError |			dbmsError := ex parameter first.			dbmsError sqlState = '37000'				ifTrue: [ex return: true]				ifFalse: [ex pass]].	aDatabaseAccessor executeInDDLOperation: [aDatabaseAccessor executeSQLStringNoResult: ('EXEC sp_droplogin ', aName )] ifError: [:ex | self halt].		false] 	on: Error	do: 		[ :exception | 		Transcript show:  exception  message; cr.		exception return: false].</body><body package="Store-Database Model" selector="isNewAccountCreatedIn:">isNewAccountCreatedIn: aDatabaseAccessor		| tableOwner |	tableOwner := aDatabaseAccessor currentLogin schema.	(tableOwner equivalentTo: 'dbo' ignoreCase: true) ifTrue: [^false].	^(Store.DbRegistry goToScript and: [false])		ifFalse: 			[(self isLoginExist: tableOwner in: aDatabaseAccessor) 				ifTrue: [true] 				ifFalse: [self createNewAccountIn: aDatabaseAccessor]]		ifTrue:			[self createLogin.			true]</body><body package="Store-Database Model" selector="spaceForBlobs">spaceForBlobs"MB"	^'32'</body><body package="Store-Database Model" selector="spaceForClasses">spaceForClasses"MB"	^'32'</body><body package="Store-Database Model" selector="spaceForDefault">spaceForDefault"MB"	^'48'</body><body package="Store-Database Model" selector="storeSchemaNotFoundError">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^UnableToExecuteSQL</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>testing</category><body package="Store-Database Model" selector="supportsPhysicalSpaces">supportsPhysicalSpaces	^true</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>database-specific</category><body package="Store-Database Model" selector="storeSchemaNotFoundError">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^UnableToPrepare</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>testing</category><body package="Store-Database Model" selector="supportsPhysicalSpaces">supportsPhysicalSpaces	^false</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>database-specific</category><body package="Store-Database Model" selector="installPhysicalSpacesIn:">installPhysicalSpacesIn: aDatabaseAccessor	"By default do nothing. Subclasses may want to do something"	^self</body><body package="Store-Database Model" selector="spaceForBlobs">spaceForBlobs	"Default is same as for Oracle"	^ '32M'</body><body package="Store-Database Model" selector="spaceForClasses">spaceForClasses	"Default is same as for Oracle"	^ '32M'</body><body package="Store-Database Model" selector="storeSchemaNotFoundError">storeSchemaNotFoundError	"Subclasses should supply a Database specific error that is raised if a table is not found	UnableToExecuteSQL is a standin for a more specific type of error"	^UnableToExecuteSQL</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>sequences</category><body package="Store-Database Model" selector="storeSequenceNameFor:">storeSequenceNameFor: aString	"Return a string representing the default Store sequence name on this platform"	^aString, 'Seq'.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>testing</category><body package="Store-Database Model" selector="supportsPhysicalSpaces">supportsPhysicalSpaces	^false</body></methods><methods><class-id>Glorp.GlorpSession class</class-id> <category>instance creation</category><body package="Store-Database Model" selector="fromLogin:">fromLogin: aGlorpLogin	| instance |	instance := self new.	instance accessor: (Store.DbRegistry currentDatabaseAccessorForLogin: aGlorpLogin).	instance accessor logging: false.	instance accessor isLoggedIn ifFalse: [instance accessor storeLogin].	instance system: (Store.DbRegistry storeDescriptorSystemForLogin: aGlorpLogin inSession: instance).	^instance</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>login</category><body package="Store-Database Model" selector="storeLogin">storeLogin	self isLoggedIn ifTrue: [^nil].	^self storeLoginIfError: [:ex | ex pass]</body><body package="Store-Database Model" selector="storeLoginIfError:">storeLoginIfError: aBlock	| result |	result := self accessor storeLoginIfError: aBlock.	system platform characterEncoding: accessor encoding.	^result.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>store constants</category><body package="Store-Database Model" selector="volatilePropertyKeys">volatilePropertyKeys	"Duplicated out of Store so that we don't need to worry about other dialects."	^#(sourceIndex overriddenExtensions recompile blessingLevel printStringCache dbTrace updating dbIdentifier databaseId loading packageUndeclared packageEnvironment timestamp parcel parcelDirectory)</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>database-specific</category><body package="Store-Database Model" selector="storeSchemaNotFoundError">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^UnableToExecuteSQL</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>database-specific</category><body package="Store-Database Model" selector="storeSchemaNotFoundError">storeSchemaNotFoundError	"This is a very generic error, which means we have to do more testing after we get it"	^#{PostgreSQLError} ifDefinedDo: [:value | value] elseDo: [nil]</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>sequences</category><body package="Store-Database Model" selector="storeSequenceNameFor:">storeSequenceNameFor: aString	"Return a string representing the default Store sequence name on this platform"	^aString, '_sequence'.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>executing</category><body package="Store-Database Model" selector="handleError:for:">handleError: exception for: command	"Signal a GlorpDatabase... error.  If it is handled to return true (any handler or defaultAction had better not return true in response to an error that logging in or logging out could reraise and on which it would again return true) and we have a reusable login, try to logout and in again and restart, otherwise exit."	| errorClass error |	errorClass := command isReadCommand		ifTrue: [GlorpDatabaseReadError]		ifFalse: [GlorpDatabaseWriteError].	error := errorClass new.	error command: command.	error databaseError: (self innerExceptionFor: exception).	error accessor: self.	(error signal ~~ true or: [currentLogin isNil or: [currentLogin secure]])		ifTrue: [exception return: nil]		ifFalse:			[self reset.			self logout.			self storeReLogin.			exception restart].</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>login</category><body package="Store-Database Model" selector="storeConnectionClass">storeConnectionClass	^currentLogin driverClassName asQualifiedReference value</body><body package="Store-Database Model" selector="storeLogin">storeLogin	"Just to help avoid confusion if someone thinks they're getting a login object back from this"	self storeLoginIfError: [:ex | ex pass].	^nil</body><body package="Store-Database Model" selector="storeLoginIfError:">storeLoginIfError: aBlock	"If the Login is secure, call the connection in its equivalent pattern (#connect:), otherwise set its password and call via #connect."	self log: 'Login'.	self logOnly ifTrue: [^self].	connection := self storeConnectionClass new.	connection initializeFromLogin: currentLogin.	(connection respondsTo: #useStatementCaching:) ifTrue:		[connection supportStatementCaching ifTrue:			[connection useStatementCaching: true]].	self		execute:			[self currentLogin secure				ifTrue: [connection connect: currentLogin password]				ifFalse: [connection connect]]		ifError: aBlock.	self log: 'Login finished'.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>executing</category><body package="Store-Database Model" selector="storeReLogin">storeReLogin	"Attempt to re-login to a database that's not responding. Give it a maximum of 5 attempts"	| attempts |	attempts := 0.	[attempts &lt; 5 and: [self isLoggedIn not]] whileTrue: [		attempts := attempts + 1.		self storeLoginIfError: [:ex | nil]].</body></methods><methods><class-id>Refactory.Browser.RBInitializerDefinition</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="anyStoreObjectInPackage">anyStoreObjectInPackage	| session query |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	query := Glorp.Query		readOneOf: Store.Glorp.StoreSharedVariableInPackage		where: [:eachShared | eachShared definition name = self variableName asString AND: [eachShared definition environmentName = self classOrNameSpace absoluteName]].	query alsoFetch: #definition.	^session execute: query.</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	| storeClassDefinition |	storeClassDefinition := Store.Glorp.StoreClassDefinition new. 	meta ifTrue: [storeClassDefinition name: self name, ' class'] ifFalse: [storeClassDefinition name: self name asString].	(meta not and: [self comment notNil and: [self comment notEmpty]]) ifTrue:		[storeClassDefinition comment: self comment].	storeClassDefinition definition: self definition.	storeClassDefinition environmentName: self environment absoluteName.	storeClassDefinition superclassName: (self superclass isNil ifTrue: ['nil'] ifFalse: [self superclass absoluteName]).	^storeClassDefinition.</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="anyStoreObjectInPackage">anyStoreObjectInPackage	| storePackage |	storePackage := self package asStorePundle.	storePackage ifNil: [storePackage := self package asNewStorePundleIn: Store.Glorp.StoreLoginFactory currentStoreSession].	^storePackage nameSpaceFor: self</body><body package="StoreForGlorpVWUI" selector="asStoreNameSpace">asStoreNameSpace	| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	namespace environmentName: self environmentString.	namespace definition: self actual definition. 	(self actual comment isEmpty) ifFalse: [		namespace comment: self actual comment].	^namespace.</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalkUsing:">longNameFromSmalltalkUsing: aString	| startingFromSmalltalk index |	index := aString findString: '.Smalltalk' startingAt: 1.	startingFromSmalltalk := aString copyFrom: index + 1 to: aString size.	index isZero		ifTrue: 			[(aString findString: 'Root' startingAt: 1) isZero ifFalse: [index := 1]].	index isZero ifFalse: [index := startingFromSmalltalk indexOf: $.].	^startingFromSmalltalk copyFrom: index + 1 to: startingFromSmalltalk size</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>aspects</category><body package="StoreForGlorpVWUI" selector="ClassVersionsNavigatorPart">ClassVersionsNavigatorPart	^partsDictionary at: #ClassVersionsNavigatorPart		ifAbsentPut: [parts add: (Store.Glorp.ClassVersionsNavigatorPart onNavigator: self)]</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>private</category><body package="StoreForGlorpVWUI" selector="privateSetState:">privateSetState: aNavigatorState	state := aNavigatorState.</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="StoreForGlorpVWUI" selector="removeSelector:fromClassNamed:">removeSelector: aSelectorName fromClassNamed: aString 	self noTargetForWrites ifTrue: [^self].	self targetFormatter 		removeSelector: aSelectorName		fromClassNamed: aString		on: self targetFile</body></methods><methods><class-id>Kernel.AbsentClassImporterMetaclass</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	| storeClassDefinition |	storeClassDefinition := Store.Glorp.StoreClassDefinition new. 	self isMeta ifTrue: [storeClassDefinition name: self name, ' class'] ifFalse: [storeClassDefinition name: self name asString].	storeClassDefinition definition: self definition.	storeClassDefinition environmentName: self environment absoluteName.	storeClassDefinition superclassName: (self superclass isNil ifTrue: ['nil'] ifFalse: [self superclass absoluteName]).	^storeClassDefinition.</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinition">asStoreMethodDefinition	| method |	method := Store.Glorp.StoreMethod new name: self selector asString.	method className: self classNameWithMeta.	method isMetaclass: self isMeta.	method basicSource: (Glorp.AdHocProxy readBlock: [Store.Glorp.StoreBlob forString: self sourceCode asString]).	method protocol: self protocol asString.	method setCTypeForPre77StoreFrom: definition.	^method.</body><body package="StoreForGlorpVWUI" selector="asText">asText	^self text asText.</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="classNameWithoutMeta">classNameWithoutMeta	"6 is the size of the text ' class'... Not a magic number"		^self isMeta		ifTrue: [self absoluteClassName copyFrom: 1 to: self absoluteClassName size - 6]		ifFalse: [self absoluteClassName]</body><body package="StoreForGlorpVWUI" selector="correspondingImageClass">correspondingImageClass	^self method mclass</body><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self classNameWithoutMeta</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinition">asStoreMethodDefinition	| method |	method := self asStoreMethodDefinitionWithoutProtocol.	method protocol: (self mclass organization categoryOfItem: self selector).	^method.</body><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinitionWithoutProtocol">asStoreMethodDefinitionWithoutProtocol		| method |	method := Store.Glorp.StoreMethod new name: self selector asString.	method className: self mclass absoluteName asString.	"A hack to fix the class name for absent class imports, for which absoluteName doesn't include the 'class' portion"	(mclass isMeta and: [(method classNameWithMeta copyFrom: (method classNameWithMeta size - 5 max: 1) to: method classNameWithMeta size) ~= ' class'])		ifTrue: [method className: method classNameWithMeta , ' class'].	method isMetaclass: mclass isMeta.	(self respondsTo: #methodSources)		ifTrue: [method basicSource: (Glorp.AdHocProxy readBlock: [Store.Glorp.StoreBlob forString: self methodSources source asString])]		ifFalse: [method basicSource: (Glorp.AdHocProxy readBlock: [Store.Glorp.StoreBlob forString: self definition sourceCode asString])].	method setCTypeForPre77StoreFrom: self.	^method</body><body package="StoreForGlorpVWUI" selector="correspondingImageMethod">correspondingImageMethod	^self</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="StoreForGlorpVWUI" selector="asStoreNameSpace">asStoreNameSpace	| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	namespace comment: self stDocumentation.	namespace definition: self definition.	self environment ifNotNil: [:value | namespace environmentName: value absoluteName].	^namespace.</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>actions</category><body package="StoreForGlorpVWUI" selector="removeSelector:fromClassNamed:on:">removeSelector: aSelectorName fromClassNamed: aString on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'remove-selector' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagForType: #class) value: aString.		str space.		xml on: str tag: 'selector' value: aSelectorName.		str cr]</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreSharedVariable">asStoreSharedVariable	| sharedVariable |	sharedVariable := Store.Glorp.StoreSharedVariable new name: self name asString.	sharedVariable environmentName: self environmentString.	sharedVariable definition: self definition.	sharedVariable protocol: (self protocol ifNil: ['']) asString.	sharedVariable isClassVariable: self isInClass.	^sharedVariable.</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="isMeta">isMeta 	"This can be called if an old class definition that defines a class variable is loaded from Store, and so the class var is converted to a shared variable in the class' namespace."	^className namesMetaClass</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="anyStoreObjectInPackage">anyStoreObjectInPackage	self subclassResponsibility</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="isForClassOrExtension">isForClassOrExtension	^false</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>browser support</category><body package="StoreForGlorpVWUI" selector="longName">longName	^self absoluteName</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="absoluteName">absoluteName	| prefix |	(self valueOrDo: [nil]) ifNotNil: [:value | ^value absoluteName].	prefix := ''.	self environment ifNotNil: [:value | prefix := value absoluteName, '.'].	^prefix , self fullName</body><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self asString</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>store-packages</category><body package="StoreForGlorpVWUI" selector="fileOutDifferencesBetween:and:">fileOutDifferencesBetween: aPundle and: anotherPundle	"File out code that would convert aPundle into anotherPundle if it were filed into an image with aPundle loaded.  This ordering reflects the general pattern that the parameter of the 'Between:' selector is the start point with the end point, whose code if different is filed-out, being either the receiver or another selector's parameter."		| fileName session |	fileName := Dialog		requestNewFileName: #FileOutOn &lt;&lt; #browser &gt;&gt; 'File out on'		default: (Filename filterFilename: (#x1sDashDiffsst &lt;&lt; #store &gt;&gt; '&lt;1s&gt;-diffs.st' expandMacrosWith: aPundle name)).	session := Store.Glorp.StoreLoginFactory currentStoreSession.	fileName isEmpty ifTrue: [^nil].	Store.StoreProgressOverlay		subsume: builder window		while:			[(Store.FilingOut for: aPundle) started.			aPundle isPackage 				ifTrue: [Store.Glorp.DefinitionsForListPane fileOutDifferencesBetweenPackage: aPundle and: anotherPundle into: fileName using: session]				ifFalse: [Store.Glorp.DefinitionsForListPane fileOutDifferencesBetweenBundle: aPundle and: anotherPundle into: fileName using: session].			(Store.FilingOut for: aPundle) finished]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>actions</category><body package="StoreForGlorpVWUI" selector="storeClassChanges">storeClassChanges	| pundles pundleNames methodsInPackage session classes classNames differentMethods uniqueThings moreGroup final |	classes := self selectedClasses.	pundles := Set new.	classes do: 		[:each | pundles addAll: (Store.Registry packagesContaining: each)].	pundles isEmpty ifTrue: [^self].		[(Store.Gathering for: classes first longNameFromSmalltalk) started.	session := Store.Glorp.StoreLoginFactory currentStoreSession.	pundleNames := pundles collect: [:each | each name].	classNames := classes collect: [:each | each absoluteName].	classNames addAll: (classes collect: [:each | each class absoluteName]).	methodsInPackage := session		read: Store.Glorp.StoreMethodInPackage		where:			[:eachMethod | 			((eachMethod definition className in: classNames)				&amp; (eachMethod package name in: pundleNames))].	differentMethods := OrderedCollection new.	differentMethods := methodsInPackage groupedBy: [:each | each signature].	uniqueThings := OrderedCollection new.	differentMethods do:		[:eachGroup |		eachGroup do:			[:eachMethod |			uniqueThings isEmpty 				ifTrue: [uniqueThings add: eachMethod]				ifFalse:					[uniqueThings 						detect: [:each | each definition definition = eachMethod definition definition]						ifNone: [uniqueThings add: eachMethod]]]].	moreGroup := uniqueThings groupedBy: [:each | each signature].	final := OrderedCollection new.	moreGroup do:		[:eachGroup | 		eachGroup size &gt; 1 ifTrue: [final addAll: eachGroup]].	(Store.Gathering for: classes first longNameFromSmalltalk) finished]			withStoreFeedbackOn: self mainWindow.	Store.Glorp.DefinitionForListTool forMethodChangesInClass: final</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="anyStoreObjectInPackage">anyStoreObjectInPackage	| storePackage |	storePackage := self package asStorePundle.	storePackage ifNil: [storePackage := self package asNewStorePundleIn: Store.Glorp.StoreLoginFactory currentStoreSession].	^storePackage classDefinitionFor: self</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="isForClassOrExtension">isForClassOrExtension	^true</body></methods><methods><class-id>Core.Behavior</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="correspondingImageClass">correspondingImageClass	^self</body><body package="StoreForGlorpVWUI" selector="isForClassOrExtension">isForClassOrExtension	^self isForClass</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreNameSpace">asStoreNameSpace	| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	namespace comment: self comment.	namespace definition: self definition.	self environment ifNotNil: [:value | namespace environmentName: value absoluteName].	^namespace.</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinition">asStoreMethodDefinition	"If the StoreMethod created by this call is for a method that is a CType definition and if it will be published to a Store Database and if we care that our published version be loadable in a 7.6 or earlier image, then we need to set the ridiculously-named 'version' instVar to 'CTYPE' in the code below."	| method name |	method := Store.Glorp.StoreMethod new name: self selector asString.	name := self fullClassName.	meta ifTrue: [name := name, ' class'].	method className: name.	method isMetaclass: meta.	method basicSource: (Glorp.AdHocProxy readBlock: [Store.Glorp.StoreBlob forString: self sourceCode asString]).	"Protocol only comes up nil for special profiler methods if we're profiling this. In which case the result won't really be valid anyway, because it gets these extra methods, but it's still nice to not crash"	method protocol: (self protocol isNil ifTrue: [''] ifFalse: [self protocol]) asString.	method setCTypeForPre77StoreFrom: self method.	^method.</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>definition</category><body package="StoreForGlorpVWUI" selector="asString">asString	^self absoluteName</body><body package="StoreForGlorpVWUI" selector="definitionString">definitionString	^self definition</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="isForClassOrExtension">isForClassOrExtension	^self isForClass</body><body package="StoreForGlorpVWUI" selector="isForSharedVariable">isForSharedVariable	^false</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>definition</category><body package="StoreForGlorpVWUI" selector="longName">longName	^self absoluteName</body><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self absoluteName</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>instance creation</category><body package="StoreForGlorpVWUI" selector="emptyPundleFrom:">emptyPundleFrom: aStorePundle	| instance |	instance := self named: aStorePundle name.	Store.ReconcilingComparitor reconcile: instance against: aStorePundle.	aStorePundle applyPundleVersionsToTheImage.	^instance</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI" selector="allPropertiesAndValuesIn:butNotIn:">allPropertiesAndValuesIn: aDictionary butNotIn: anotherDictionary	| dictionary |	dictionary := Dictionary new.	aDictionary keysAndValuesDo: [:key :value | dictionary at: key put: key -&gt; value].	aDictionary isEmpty ifTrue: [^Dictionary new].	anotherDictionary keysAndValuesDo: 		[:key :value | 		(dictionary at: key ifAbsent: [nil -&gt; nil]) value = value ifTrue:			[dictionary removeKey: key ifAbsent: []]].	^dictionary</body><body package="StoreForGlorpVWUI" selector="allPropertiesAndValuesInPundle:butNotIn:">allPropertiesAndValuesInPundle: aPackageModelOrStorePackage butNotIn: anotherPackageModelStorePackage	^self		allPropertiesAndValuesIn: (aPackageModelOrStorePackage ifNil: [#()] ifNotNil: [aPackageModelOrStorePackage propertiesWithoutVolatileKeys])		butNotIn: (anotherPackageModelStorePackage ifNil: [#()] ifNotNil: [anotherPackageModelStorePackage propertiesWithoutVolatileKeys]).</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asNewStorePundleIn:">asNewStorePundleIn: aGlorpSession	"Create a new StoreForGlorp pundle corresponding to ourselves. Note that for new  versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asNewStorePundleIn: aSession"	| session |	session := aGlorpSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	^self		asStorePundleIn: session		returnOriginalIfUnmodified: false		includeUninstalled: true.</body><body package="StoreForGlorpVWUI" selector="asStorePundle">asStorePundle		| session storePundle |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	storePundle := self asStorePundleEvenIfModifiedIn: session.	^storePundle</body><body package="StoreForGlorpVWUI" selector="asStorePundleEvenIfModifiedIn:">asStorePundleEvenIfModifiedIn: aGlorpSession		| storePundle dbName info session |	session := aGlorpSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	dbName := session system databaseIdentifier.	info := dbInfo		at: dbName		ifAbsent: [nil].	(info notNil and: [info dbTrace notNil])		ifTrue:			[storePundle := session				readOneOf: self storeForGlorpPundleClass				where: [:each | each primaryKey = info dbTrace]].	^storePundle</body><body package="StoreForGlorpVWUI" selector="asStorePundleFromCache">asStorePundleFromCache	| cache session |	session := (cache := self storeForGlorpPundleClass cache) notEmpty 		ifTrue: [cache any session]		ifFalse: [	Store.Glorp.StoreLoginFactory currentStoreSession].	^self storeForGlorpPundleClass cachedItemFor: (self asStorePundleIn: session)</body><body package="StoreForGlorpVWUI" selector="asStorePundleIn:">asStorePundleIn: aGlorpSession	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"	| session |	session := aGlorpSession ifNil: [Store.Glorp.StoreLoginFactory currentStoreSession].	^self		asStorePundleIn: session		returnOriginalIfUnmodified: true		includeUninstalled: true.</body><body package="StoreForGlorpVWUI" selector="asStorePundleIn:returnOriginalIfUnmodified:includeUninstalled:">asStorePundleIn: aGlorpSession returnOriginalIfUnmodified: returnOriginalIfUnmodified includeUninstalled: includeUninstalledCode	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new  versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"	| pundle info dbName previous |	dbName := aGlorpSession system databaseIdentifier.	info := dbInfo at: dbName ifAbsent: [nil].	(info notNil and: [info dbTrace notNil])		ifTrue:			[previous := aGlorpSession				readOneOf: self storeForGlorpPundleClass				where: [:each | each primaryKey = info dbTrace]].	returnOriginalIfUnmodified		ifTrue:			[((self hasBeenModifiedIn: dbName) not and: [previous notNil])				ifTrue: [^previous]].	pundle := self storeForGlorpPundleClass new.	pundle previous: previous.	pundle name: self name.	pundle properties: self propertiesForSave.	pundle comment: self comment.	pundle username: aGlorpSession accessor currentLogin username.	pundle timestamp: (Glorp.Dialect storeTimestampIn: aGlorpSession).	pundle storeModel: self.	pundle session: aGlorpSession.	^pundle.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI" selector="computePropertyDifferencesBetween:into:">computePropertyDifferencesBetween: aPundle into: aPackageComparitor 	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		self computePropertyDiffsBetweenDBPundle: aPundle into: aPackageComparitor.	^aPackageComparitor</body><body package="StoreForGlorpVWUI" selector="computePropertyDiffsBetweenDBPundle:into:">computePropertyDiffsBetweenDBPundle: aStorePackage into: aPackageComparitor		aPackageComparitor mainPackageProperties: (self allPropertiesAndValuesInPundle: self butNotIn: aStorePackage).	aPackageComparitor otherPackageProperties: (self allPropertiesAndValuesInPundle: aStorePackage butNotIn: self).	^aPackageComparitor</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="continueToReconcile">continueToReconcile	^ReconcileWarning raiseSignal: ((#x1sIsNotLinkedToDatabaseReconcileQ &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not linked to the current database.&lt;n&gt;It cannot be loaded until it has been reconciled.&lt;n&gt;Do you want to do that now?') 		expandMacrosWith: self name)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="dbTrace:for:">dbTrace: anInteger for: databaseId	"Answer the db parent id for the specified database, nil if none."	| info |	^( info := self databaseInformationFor: databaseId ) == nil		ifFalse: [ info dbTrace: anInteger ].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="StoreForGlorpVWUI" selector="emptyChangeSetFor:">emptyChangeSetFor: aDatabaseIdentifier	"Empty the currently active ChangeSet."	| info |	( info := self databaseInformationFor: aDatabaseIdentifier ) == nil		ifFalse: 			[ self updateAfterDo:  				[ info emptyChangeSet ]			]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="extractVersionFromVersionDisplayString">extractVersionFromVersionDisplayString	| result versionString |	versionString := self versionString.	result := versionString first = $( 		ifFalse: [(versionString = '*' or:  [versionString = '=']) ifTrue: [''] ifFalse: [versionString]]		ifTrue: 			[ | index | 			(index := versionString lastIndexOf: $,) &gt; 0 				ifTrue: [versionString copyFrom: 2 to: index -1]				ifFalse: 					[(index := versionString lastIndexOf: $)) &gt; 0						ifTrue: [versionString copyFrom: 2 to: index - 1]						ifFalse: [versionString copyFrom: 2 to: versionString size]]].	^result</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="glorpReconciledVersion">glorpReconciledVersion	^self glorpReconciledVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession.</body><body package="StoreForGlorpVWUI" selector="glorpReconciledVersionFrom:">glorpReconciledVersionFrom: aPundle	self databaseInformation isNil ifTrue:		[self continueToReconcile ifFalse: [^nil].		self isBundle			ifTrue: [self allItems do: [:each | each setNoTrace]]			ifFalse: [self setNoTrace].		self reconcileWithDb: aPundle].	^self canReplaceVersions ifTrue:		[aPundle ifNotNil: [aPundle asStorePundle]]</body><body package="StoreForGlorpVWUI" selector="glorpReconciledVersionIn:">glorpReconciledVersionIn: aSession	| dbSelection |	dbSelection := self databaseInformation isNil		ifFalse: [self selectStoreVersion]		ifTrue: [self continueToReconcile ifTrue: [self reconcileWithDb]].	^dbSelection ifNotNil:		[(dbSelection isBundle or: [self canReplaceVersions]) ifTrue:			[dbSelection asStorePundleIn: aSession]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>public-change set access</category><body package="StoreForGlorpVWUI" selector="markNotModifiedFor:">markNotModifiedFor: aDatabaseIdentifier	self shouldTrackChanges 		ifTrue: [ self emptyChangeSetFor: aDatabaseIdentifier ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="mergeItemString">mergeItemString	^self itemString , ' [Image]'</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="pundle">pundle	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="StoreForGlorpVWUI" selector="resetNoDatabaseInformation">resetNoDatabaseInformation	dbInfo removeKey: self noDbSymbol ifAbsent: [nil].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>utilities-repository</category><body package="StoreForGlorpVWUI" selector="selectStoreVersion">selectStoreVersion 	"Answer the user selected published version of the receiver.	nil if none."	^self selectStoreVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession.</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionIn:">selectStoreVersionIn: aSession	"Answer the user selected published version of the receiver.	nil if none."	^self class storeDatabaseClass selectStoreVersionOf: self name in: aSession</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionIn:warnIfNone:">selectStoreVersionIn: aSession warnIfNone: aBoolean	"Answer the user selected published version of the receiver.	nil if none."	^self class storeDatabaseClass selectStoreVersionOf: self name in: aSession warnIfNone: aBoolean</body><body package="StoreForGlorpVWUI" selector="selectStoreVersionWarnIfNone:">selectStoreVersionWarnIfNone: aBoolean	"Answer the user selected published version of the receiver.	nil if none."	^self selectStoreVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession warnIfNone: aBoolean</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="session">session	"This for being compatable with StorePundle objects"	^nil</body></methods><methods><class-id>Store.PundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="storeForGlorpPundleClass">storeForGlorpPundleClass	^self subclassResponsibility.</body><body package="StoreForGlorpVWUI" selector="storeTracePackage">storeTracePackage	| storePundle session |	#{Store.DbRegistry}		ifDefinedDo:			[:registry | 			(registry notNil and: [registry isOnline]) ifFalse: [^nil]]		elseDo: [^nil].	self dbTrace ifNil: [^nil].	(self dbIdentifier notNil and: [self dbIdentifier = Store.DbRegistry dbIdentifier]) ifFalse: [^nil].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	storePundle := session		readOneOf: self storeForGlorpPundleClass		where: [:each | each primaryKey = self dbTrace].	^storePundle</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI" selector="stripIgnorablePropertiesToMatch:">stripIgnorablePropertiesToMatch: aVersion	"Remove from ourselves any of the properties that we probably got from a parcel. Makes comparing to the database simpler."	Store.Glorp.StorePundle new ignorableProperties		do: [:each | self propertyAt: each put: (aVersion propertyAt: each ifAbsent: [nil])].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="withAllItems">withAllItems	^Array with: self</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	"Convert this to a StoreForGlorp class definition, ignoring the metaclass"	| storeClassDefinition | 	storeClassDefinition := Store.Glorp.StoreClassDefinition new.	storeClassDefinition name: self name asString.	(self stDocumentation notNil and: [self stDocumentation notEmpty]) ifTrue:		[storeClassDefinition comment: self stDocumentation].	storeClassDefinition definition: self definition.	storeClassDefinition environmentName: self environment absoluteName.	storeClassDefinition superclassName: (self superclass isNil ifTrue: ['nil'] ifFalse: [self superclass absoluteName]).	^storeClassDefinition.</body><body package="StoreForGlorpVWUI" selector="asStoreClassDefinitionWithMetaclass">asStoreClassDefinitionWithMetaclass	"Convert this to a StoreForGlorp class definition, with appropriate metaclass. Note that these appear to be always for classes, never metaclasses. Return an array of the class and metaclass."	| cl metacl |	cl := self asStoreClassDefinition.	metacl := Store.Glorp.StoreClassDefinition new.	metacl name:  self name, ' class'.	metacl definition: 'self error: ''no metaclass def'''. "We don't have a way to get the metaclass definition from this without creating the class or faking it up. But since it isn't used anyway, just leave it blank."	metacl environmentName: self environment absoluteName.	metacl superclassName: (self superclass isNil ifTrue: [nil] ifFalse: [self superclass class absoluteName]).	^Array with: cl with: metacl.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asStorePundleIn:returnOriginalIfUnmodified:includeUninstalled:">asStorePundleIn: aGlorpSession returnOriginalIfUnmodified: returnOriginalIfUnmodified includeUninstalled: includeUninstalledCode	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"	| bundle bundlesAndPackages |	bundle := super		asStorePundleIn: aGlorpSession		returnOriginalIfUnmodified: returnOriginalIfUnmodified		includeUninstalled: true.	bundle primaryKey isNil ifFalse: [^bundle].	bundlesAndPackages := self contents.	1		to: bundlesAndPackages size		do:			[:i | 			| each dict |			each := bundlesAndPackages at: i.			dict := each isBundle				ifTrue: [bundle bundles]				ifFalse: [bundle packages].			dict at: i put: (each asStorePundleIn: aGlorpSession)].	(self respondsTo: #fileDescriptions)		ifTrue:			[bundle				files: (self fileDescriptions collect: [:each | Store.Glorp.StoreFile fromFileRecord: each])].	^bundle.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="pseudoPundleClass">pseudoPundleClass	^Store.PseudoBundle</body></methods><methods><class-id>Store.BundleModel</class-id> <category>initialize-release</category><body package="StoreForGlorpVWUI" selector="setContentsFromDB:for:">setContentsFromDB: aDBBundle for: aDatabaseIdentifier		| databaseInfo |	databaseInfo := self databaseInfomationForOrCreate: aDatabaseIdentifier.	databaseInfo contentDescriptions: (aDBBundle containedItems collect: [:each | each asComponentDescription]).	databaseInfo fileDescriptions: (aDBBundle files collect: [:each | each asComponentDescription]).	dbInfo removeKey: self noDbSymbol ifAbsent: nil</body></methods><methods><class-id>Store.BundleModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="storeForGlorpPundleClass">storeForGlorpPundleClass	^self class storeDatabaseClass</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI" selector="stripIgnorablePropertiesToMatch:">stripIgnorablePropertiesToMatch: aVersion	"Remove from ourselves any 'volatile' properties that we probably got from a parcel. Makes comparing to the database simpler."	super stripIgnorablePropertiesToMatch: aVersion.	self containedItems with: aVersion containedItems		do: [:each :eachVersion | each stripIgnorablePropertiesToMatch: eachVersion].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="withAllItems">withAllItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this 	bundle. 	The list preserves the bundle order. Put this bundle as a first item on the list."		| items |	items := OrderedCollection with: self.	self containedItems do: 		[:item | 		item isBundle 			ifTrue: [items addAll: item allItems] 			ifFalse: [items add: item]].	^items</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>actions</category><body package="StoreForGlorpVWUI" selector="removeSelector:fromClassNamed:on:">removeSelector: aSelectorName fromClassNamed: aString on: aStream	"Record on the stream that the given selector	has been removed from the class argument."	^self subclassResponsibility</body></methods><methods><class-id>Glorp.CannotFindSession</class-id> <category>private - actions</category><body package="StoreForGlorpVWUI" selector="defaultAction">defaultAction	"What to do when the exception is unhandled.	 Users must still be able to catch this unhandled exception.	 Do not intercept with the immediate superclass extension method, but use the GenericException implementation."	^self noHandler</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="propertiesWithoutVolatileKeys">propertiesWithoutVolatileKeys	"Answer a copy of the component's properties"	| propertiesCopy |	propertiesCopy := properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesCopy removeKey: each ifAbsent: [nil]].	^propertiesCopy</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="anyStoreObjectInPackage">anyStoreObjectInPackage	| session query |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	query := Glorp.Query		readOneOf: Store.Glorp.StoreMethodInPackage		where: [:eachMethod | eachMethod definition name = self selector asString AND: [eachMethod definition className = self implementingClass absoluteName]].	query alsoFetch: #definition.	^session execute: query.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="addClassAndMetaclassTo:for:">addClassAndMetaclassTo: package for: each		| classAndMetaclass classInPackage |	classAndMetaclass := each asStoreClassDefinitionWithMetaclass.	classInPackage := package addClassDefinition: classAndMetaclass first.	^classInPackage metaclass: classAndMetaclass last.</body><body package="StoreForGlorpVWUI" selector="asStorePundleIn:returnOriginalIfUnmodified:includeUninstalled:">asStorePundleIn: aGlorpSession returnOriginalIfUnmodified: returnOriginalIfUnmodified includeUninstalled: includeUninstalledCode	"Create a StoreForGlorp pundle corresponding to ourselves. Depending on the value of aBoolean, if the image pundle hasn't been modified, 	we will either return the parent version from the database, or create a new one that has that version as a parent. 	Note that for new  versions, the blessing will not have been set	(Store.Registry packageNamed: 'StoreForGlorpVWUI') asStorePundleIn: aSession	(Store.Registry packageNamed: 'UIBasics-Controllers') asStorePundle"		| package classDefsInPackage |	package := super asStorePundleIn: aGlorpSession		returnOriginalIfUnmodified: returnOriginalIfUnmodified		includeUninstalled: true.	package primaryKey isNil ifFalse: [^package].	"currentVersion := info isNil ifTrue: [nil] ifFalse: [info versionString]."	self classesDefinedInPackage		do: [:each | package addClassDefinition: each asStoreClassDefinition].	classDefsInPackage := Dictionary new.	package classDefinitions		do: [:each | classDefsInPackage at: each fullName , ' class' put: each].	self metaclassesDefinedInPackage		do:			[:each | 			| storeDef |			storeDef := each asStoreClassDefinition.			storeDef timestamp: package timestamp.			storeDef username: package username.			(classDefsInPackage at: storeDef fullName) metaclass: storeDef].	self nameSpaceModels		do:			[:each | each isExtension ifFalse: [package addNameSpace: each asStoreNameSpace]].	Override overriddenClassesAndNameSpaces		keysAndValuesDo:			[:inMemoryVersion :eachList | 			eachList				do:					[:each | 					(each includesSource: self)						ifTrue:							[inMemoryVersion isBehavior								ifTrue: [self addClassAndMetaclassTo: package for: each]								ifFalse: [package addNameSpace: each asStoreNameSpace]]]].	self methods do: [:each | package addMethod: each asStoreMethodDefinition].	includeUninstalledCode		ifTrue:			[| parcel |			parcel := Parcel parcelNamed: self name.			(parcel notNil and: [parcel hasUninstalledCode])				ifTrue:					[(parcel propertyAt: #uninstalledMethods ifAbsent: [#()])						do: [:each | package addMethod: each asStoreMethodDefinition].						(parcel propertyAt: #uninstalledClasses ifAbsent: [#()])						do: [:each | self addClassAndMetaclassTo: package for: each].					"I don't know what these things look like, and don't have any examples, so ignore them for now"					(parcel propertyAt: #uninstalledBindings ifAbsent: [#()])						do: [:each | package halt]]].	self data		do: [:each | package addSharedVariable: each asStoreSharedVariable].	Override		overriddenStaticsDo:			[:each | 			(each includesSource: self)				ifTrue: [package addSharedVariable: each asStoreSharedVariable]].	package sortForLoading.	^package.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="StoreForGlorpVWUI" selector="computeDifferencesBetween:into:">computeDifferencesBetween: aPackage into: aComparitor 	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[aComparitor reverse.	self computeDifferencesBetweenDBPackage: aPackage into: aComparitor]		ensure: [aComparitor reverse].	^aComparitor</body><body package="StoreForGlorpVWUI" selector="computeDifferencesBetweenDBPackage:into:">computeDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor	"Store  differences between receiver and a aDBPackage  into an instance of TT_PackageDifferences.	Store receiver's definitions as number-2 since this method is called with arguments reversed.	The comparison is done in two steps. First we compare, image with trace and then we compare trace	with aDBpackage and combine the restults.	If aDB package is a pseudo package use change set only"		| storePackageParent comparitorToParent |	aStorePackage pseudoPackage ifTrue: 		[^self computeFullDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor].	((self otherChangesInclude: self parentChangedMark) or: 		[(storePackageParent := self storeTracePackage) isNil or: 		[self userWantsFullCompare]]) ifTrue:			[^self computeFullDifferencesBetweenDBPackage: aStorePackage into: aPackageComparitor].	self changeSetDifferencesBetweenDBPackage: storePackageParent into: aPackageComparitor.	(aStorePackage sameAs: storePackageParent) ifTrue:		[^aPackageComparitor].	comparitorToParent := Store.PackageComparitor differencesBetween: aStorePackage and: storePackageParent.	aPackageComparitor combineDiffsFrom: comparitorToParent .	^aPackageComparitor</body><body package="StoreForGlorpVWUI" selector="computeFullDifferencesBetweenDBPackage:into:">computeFullDifferencesBetweenDBPackage: aStorePackageOrPseudo into: aPackageComparitor	"Store general differences between receiver and a aDBPackage into aPackageComparitor	We turn everything into a StoreObject which does the trick when we do removes of comparing the right things"		| otherObjects mainObjects |	"methods"	mainObjects := (aStorePackageOrPseudo methodsWithSource collect: [:each | each asStoreMethodDefinition]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	self methods do: [:each | mainObjects remove: each asStoreMethodDefinition ifAbsent: [otherObjects add: each]].	aPackageComparitor otherPackageMethods: (otherObjects collect: [:each | each asStoreMethodDefinition]).	aPackageComparitor mainPackageMethods: (mainObjects collect: [:each | each asStoreMethodDefinition]).	"data"	mainObjects := (aStorePackageOrPseudo data collect: [:each | each asStoreSharedVariable]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	self data do: [:each | mainObjects remove: each asStoreSharedVariable ifAbsent: [otherObjects add: each]].	aPackageComparitor otherPackageShareds: (otherObjects collect: [:each | each asStoreSharedVariable]).	aPackageComparitor mainPackageShareds: (mainObjects collect: [:each | each asStoreSharedVariable]).	"namespaces"	mainObjects := (aStorePackageOrPseudo nameSpacesDefinedInPackage collect: [:each | each asStoreNameSpace]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	self nameSpacesDefinedInPackage do: [:each | mainObjects remove: each asStoreNameSpace ifAbsent: [otherObjects add: each]].	aPackageComparitor otherPackageNamespaces: (otherObjects collect: [:each | each asStoreNameSpace]).	aPackageComparitor mainPackageNamespaces: (mainObjects collect: [:each | each asStoreNameSpace]).	"classes"	mainObjects := (aStorePackageOrPseudo classesDefinedInPackage collect: [:each | each asStoreClassDefinition]) asSet.	otherObjects := OrderedCollection new: mainObjects size.	self classesDefinedInPackage do: [:each | mainObjects remove: each asStoreClassDefinition ifAbsent: [otherObjects add: each]].	aPackageComparitor otherPackageClasses: (otherObjects collect: [:each | each asStoreClassDefinition]).	aPackageComparitor mainPackageClasses:  (mainObjects collect: [:each | each asStoreClassDefinition]).	self computeOverrideDiffsBetweenDBPackage: aStorePackageOrPseudo into: aPackageComparitor.	^aPackageComparitor</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="definedObjectNamed:">definedObjectNamed: aString	| target |	target := self modelAtName: aString ifAbsent: [^nil].	^target isExtension ifTrue: [nil] ifFalse: [target actual]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="includesUninstalledMethod:">includesUninstalledMethod: aStoreMethodInPackage	"Answer true if the receiver contains a definition of aMethodDescriptor in a related parcel"	| relatedParcel |	relatedParcel := self relatedParcel ifNil: [^false].	relatedParcel uninstalledMethods		detect: 			[:each | 			each implementingClass absoluteName = aStoreMethodInPackage definition classNameWithoutMeta and:				[each implementingClass isMeta = aStoreMethodInPackage isMeta and:				[each selector = aStoreMethodInPackage selector and:				[each protocol = aStoreMethodInPackage protocol and: 				[each method getSource asString = aStoreMethodInPackage definition definition]]]]]		ifNone: [^false].	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="objectNamed:">objectNamed: aString	| target |	target := self modelAtName: aString ifAbsent: [^nil].	^target actual</body><body package="StoreForGlorpVWUI" selector="pseudoPundleClass">pseudoPundleClass	^Store.PseudoPackage</body></methods><methods><class-id>Store.PackageModel</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="storeForGlorpPundleClass">storeForGlorpPundleClass	^self class storeDatabaseClass</body></methods><methods><class-id>Tools.MethodInstallationRecord</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI" selector="asStoreMethodDefinition">asStoreMethodDefinition	| storeGlorpMethod |	storeGlorpMethod := method asStoreMethodDefinitionWithoutProtocol.	storeGlorpMethod name: self selector asString.	storeGlorpMethod protocol: self protocol asString.	^storeGlorpMethod.</body></methods><methods><class-id>Core.VariableBinding</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="correspondingImageBinding">correspondingImageBinding	^self</body><body package="StoreForGlorpVWUI" selector="correspondingImageSharedVariable">correspondingImageSharedVariable	^self</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>converting</category><body package="StoreForGlorpVWUI" selector="asComponentDescription">asComponentDescription	^self.</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI" selector="asStoreNameSpace">asStoreNameSpace	| namespace |	namespace := Store.Glorp.StoreNameSpace new name: self name asString.	namespace comment: self comment.	namespace definition: self definition.	self environment ifNotNil: [:value | namespace environmentName: value absoluteName].	^namespace.</body><body package="StoreForGlorpVWUI" selector="correspondingImageNamespace">correspondingImageNamespace	^self</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>private</category><body package="StoreForGlorpVWUI" selector="definitionBrowserTool">definitionBrowserTool		^Store.Glorp.DefinitionForListTool</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-classes</category><body package="StoreForGlorpVWUI" selector="storeBrowseClassVersions">storeBrowseClassVersions		self dbRegistry doIfOnlineImage: 		[[self definitionBrowserTool forVersionsOfClassOrNameSpace: self storeClass anyStoreObjectInPackage] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-methods</category><body package="StoreForGlorpVWUI" selector="storeBrowseMethodVersions">storeBrowseMethodVersions		self dbRegistry doIfOnlineImage: 		[[self definitionBrowserTool forVersionsOfMethod: self definition anyStoreObjectInPackage] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-packages</category><body package="StoreForGlorpVWUI" selector="storeBrowsePundleVersions">storeBrowsePundleVersions		| session |	self dbRegistry doIfOnlineImage: 		[[session := Store.Glorp.StoreLoginFactory currentStoreSession.		self pundles do: [:each | self definitionBrowserTool forVersionsOfPackage: (each asStorePundleIn: session)]] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserNavigator</class-id> <category>store-shared variables</category><body package="StoreForGlorpVWUI" selector="storeBrowseSharedVariableVersions">storeBrowseSharedVariableVersions		self dbRegistry doIfOnlineImage: 		[[self definitionBrowserTool forVersionsOfShared: self definition anyStoreObjectInPackage] withStoreFeedbackOn: self mainWindow]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="definitionString">definitionString	^self definition</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>testing</category><body package="StoreForGlorpVWUI" selector="isExtension">isExtension	^false</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="longName">longName	^self absoluteName</body><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self absoluteName</body><body package="StoreForGlorpVWUI" selector="shortItemString">shortItemString	^self name</body></methods><methods><class-id>Core.Class</class-id> <category>store for glorp</category><body package="StoreForGlorpVWUI" selector="asStoreClassDefinition">asStoreClassDefinition	| storeClassDefinition |	storeClassDefinition := Store.Glorp.StoreClassDefinition new. 	self isMeta ifTrue: [storeClassDefinition name: self name, ' class'] ifFalse: [storeClassDefinition name: self name asString].	(self isMeta not and: [self comment notNil and: [self comment notEmpty]]) ifTrue:		[storeClassDefinition comment: self comment].	storeClassDefinition definition: self definition.	storeClassDefinition environmentName: self environment absoluteName.	storeClassDefinition superclassName: (self superclass isNil ifTrue: ['nil'] ifFalse: [self superclass absoluteName]).	^storeClassDefinition.</body><body package="StoreForGlorpVWUI" selector="asStoreClassDefinitionWithMetaclass">asStoreClassDefinitionWithMetaclass	"Convert this to a StoreForGlorp class definition, with appropriate metaclass. Return an array of the class and metaclass."	^Array with: self asStoreClassDefinition with: self class asStoreClassDefinition.</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>accessing</category><body package="StoreForGlorpVWUI" selector="classNameWithMeta">classNameWithMeta	^self implementingClass absoluteName.</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>actions</category><body package="StoreForGlorpVWUI" selector="removeSelector:fromClassNamed:on:">removeSelector: aSelectorName fromClassNamed: aString on: aStream		aStream		cr;		cr;		nextChunkPut: aString storeString , ' removeSelector: ' , aSelectorName storeString</body></methods><methods><class-id>Kernel.Override</class-id> <category>printing</category><body package="StoreForGlorpVWUI" selector="longNameFromSmalltalk">longNameFromSmalltalk	^self longNameFromSmalltalkUsing: self absoluteName</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="StoreForGlorpVWUI" selector="asStoreSharedVariable">asStoreSharedVariable	| sharedVariable |	sharedVariable := Store.Glorp.StoreSharedVariable new name: self name asString.	sharedVariable environmentName: self absoluteOwnerName.	sharedVariable definition: self definition.	sharedVariable protocol: self protocol asString.	sharedVariable isClassVariable: self isInClass.	^sharedVariable.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>dates</category><body package="StoreForGlorpVWUI" selector="storeTimestamp">storeTimestamp	"Return a timestamp appropriate to use for publishing Store entities. Be exceedingly careful about errors due to databases that don't support this, 	or old code in various interesting combinations.	Note, if you are not connected, or can not connect, it gives you a local UTC timestamp.	Dialect storeTimestamp	Whenever possible, use the #storeTimestampIn: method, passing along a GlorpSession object"	^self storeTimestampIn: nil</body><body package="StoreForGlorpVWUI" selector="storeTimestampIn:">storeTimestampIn: aSession	"Return a timestamp appropriate to use for publishing Store entities. Be exceedingly careful about errors due to databases that don't support this.	In order to avoid excessive trips to the database, if we ask this more than once within a second, just return the previous result.	Note, if you are not connected, or can not connect, it gives you a local UTC timestamp.	Dialect storeTimestampIn: Store.Glorp.StoreLoginFactory currentStoreSession"	| possibleTimestamp session systemTime |	session := aSession ifNil: [Store.DbRegistry isOnlineImage ifTrue: [Store.Glorp.StoreLoginFactory currentStoreSession]].	systemTime := self timestampNowUTC asSeconds.	lastSystemTime = systemTime 		ifTrue: [^lastServerTime] ifFalse: [lastSystemTime := systemTime].	possibleTimestamp := session ifNotNil: [:value | value currentServerUTCTimestampOrNil].	^lastServerTime := (possibleTimestamp isKindOf: Timestamp)		ifTrue: [possibleTimestamp]		ifFalse: [self timestampNowUTC].</body></methods><methods><class-id>Kernel.Compiler</class-id> <category>private</category><body package="Store-Merge Management" selector="parseWithSignalling:in:noPattern:notifying:">parseWithSignalling: textOrStream in: aClass noPattern: noPattern notifying: req	"Compile the incoming text and answer with the resulting parse tree.	This is the only public message that saves the source map	and the comments.  If the requestor is nil,	warning messages (as opposed to outright errors)	are silently discarded."	self		from: textOrStream		class: aClass		context: nil		notifying: req.	^self		translate: sourceStream		noPattern: noPattern		ifFail: [^nil]		needSourceMap: true		handlerClass: SignallingCompilerErrorHandler</body></methods><methods><class-id>UI.Panel</class-id> <category>layout algorithms</category><body package="Store-Code Comparison" selector="beFullColumn">beFullColumn	self layoutAlgorithm: 			[:rect :parts |			| bottom |			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + each preferredHeight.					(rect copy)						top: top;						bottom: bottom]]</body><body package="Store-Code Comparison" selector="beFullColumnStretchIf:">beFullColumnStretchIf: aPredicateBlock	self layoutAlgorithm: 			[:rect :parts |			| bottom stretchHeight unstretched |			stretchHeight := 0.			unstretched := parts reject: aPredicateBlock.			unstretched size &lt; parts size				ifTrue: 					[stretchHeight := (rect height								- (unstretched inject: 0 into: [:sum :each | sum + each preferredHeight]))									/ (parts size - unstretched size) max: 0].			bottom := rect top.			parts collect: 					[:each |					| top |					top := bottom.					bottom := top + ((aPredicateBlock value: each)										ifTrue: [stretchHeight]										ifFalse: [each preferredHeight]).					(rect copy)						top: top;						bottom: bottom]]</body></methods><methods><class-id>UI.Label</class-id> <category>accessing</category><body package="Store-Code Comparison" selector="extent">extent	^self width @ self height</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>resources</category><body package="Store-UI" selector="bundleImageModifiedBW">bundleImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #bundleImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 63 254 0 0 32 254 0 0 32 254 0 0 32 254 0 0 32 254 0 0 32 36 0 0 63 228 0 0 4 4 0 0 4 4 0 0 7 252 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="bundleImageModifiedC">bundleImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #bundleImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue green; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 0 0 160 0 21 80 162 170 21 80 162 170 21 80 162 170 21 80 162 170 0 0 162 170 162 136 160 0 2 136 170 138 170 136 170 138 170 136 170 128 0 8 170 170 170 168 170 170 170 168])</body><body package="Store-UI" selector="bundleImageUnmodifiedBW">bundleImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #bundleImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 224 0 0 32 32 0 0 32 32 0 0 32 60 0 0 32 36 0 0 32 36 0 0 63 228 0 0 4 4 0 0 4 4 0 0 7 252 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="dbBundleImageBW">dbBundleImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbBundleImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 42 160 0 0 0 0 0 0 32 32 0 0 0 20 0 0 32 32 0 0 0 4 0 0 42 160 0 0 4 4 0 0 0 0 0 0 5 84 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="dbNonCodePackageImageBW">dbNonCodePackageImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbNonCodePackageImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 10 168 0 0 0 4 0 0 16 0 0 0 0 8 0 0 32 0 0 0 0 16 0 0 64 0 0 0 42 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="dbPackageImageBW">dbPackageImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbPackageImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 21 84 0 0 0 0 0 0 16 4 0 0 0 0 0 0 16 4 0 0 0 0 0 0 16 4 0 0 0 0 0 0 21 84 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="nonCodePackageImageModifiedBW">nonCodePackageImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 0 254 0 0 15 254 0 0 8 254 0 0 16 254 0 0 16 254 0 0 32 16 0 0 32 16 0 0 64 32 0 0 127 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="nonCodePackageImageModifiedC">nonCodePackageImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue green; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 0 0 170 170 21 80 170 0 21 80 170 42 21 80 168 170 21 80 168 170 0 0 162 170 168 168 162 170 168 168 138 170 162 168 128 0 2 168 170 170 170 168 170 170 170 168 170 170 170 168])</body><body package="Store-UI" selector="nonCodePackageImageUnmodifiedBW">nonCodePackageImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 15 252 0 0 8 4 0 0 16 8 0 0 16 8 0 0 32 16 0 0 32 16 0 0 64 32 0 0 127 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="packageImageModifiedBW">packageImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #packageImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 0 254 0 0 31 254 0 0 16 254 0 0 16 254 0 0 16 254 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 31 252 0 0 0 0 0 0 0 0 0 0 ])</body><body package="Store-UI" selector="packageImageModifiedC">packageImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #packageImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 2 put: ColorValue green; at: 3 put: ColorValue black; at: 4 put: ColorValue white; yourself)) usingBits: #[255 255 255 252 255 255 0 0 255 255 21 80 252 0 21 80 252 255 21 80 252 255 21 80 252 255 0 0 252 255 255 204 252 255 255 236 252 255 255 204 252 255 255 204 252 0 0 12 255 255 255 252 255 255 255 252])</body><body package="Store-UI" selector="packageImageUnmodifiedBW">packageImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #packageImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 31 252 0 0 0 0 0 0 0 0 0 0 ])</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="publishPackage">publishPackage	"UIPainter new openOnClass: self andSelector: #publishPackage"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{UserMessage} #key: #PublishingPackage #catalogID: #store #defaultString: 'Publishing Package') 			#min: #(#{Point} 381 377 ) 			#max: #(#{Point} 381 377 ) 			#bounds: #(#{Rectangle} 371 200 752 577 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{LabelSpec} 					#layout: #(#{Point} 12 47 ) 					#label: #(#{UserMessage} #key: #VersionC #catalogID: #store #defaultString: 'Version:') ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 103 0 45 0 -8 1 75 0 ) 					#name: #versionString 					#model: #versionString ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 43 82 ) 					#name: #binarySave 					#model: #binarySave 					#label: #(#{UserMessage} #key: #Binary #catalogID: #store #defaultString: 'Binary') ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 199 82 ) 					#name: #parcelSave 					#model: #parcelSave 					#label: #(#{UserMessage} #key: #Parcel #catalogID: #store #defaultString: 'Parcel') ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 17 0 8 0 -17 1 31 0 ) 					#flags: 0 					#model: #dialogTitle 					#tabable: false 					#alignment: #center 					#isReadOnly: false )				#(#{LabelSpec} 					#layout: #(#{Point} 15 122 ) 					#label: #(#{UserMessage} #key: #BlessinglevelC #catalogID: #store #defaultString: 'Blessing level:') ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -40 0.25 -40 1 41 0.25 -10 1 ) 					#name: #publish 					#model: #publish 					#label: #(#{UserMessage} #key: #Publish #catalogID: #store #defaultString: 'Publish') 					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -40 0.75 -40 1 40 0.75 -10 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#defaultable: true ) 				#(#{TextEditorSpec} 					#layout: #(#{LayoutFrame} 12 0 179 0 -14 1 -50 1 ) 					#name: #blessingComment 					#model: #blessingComment ) 				#(#{LabelSpec} 					#layout: #(#{Point} 15 148 ) 					#label: #(#{UserMessage} #key: #BlessingcommentC #catalogID: #store #defaultString: 'Blessing comment:') ) 				#(#{DividerSpec} 					#layout: #(#{LayoutFrame} 18 0 108 0 -12 1 112 0 ) ) 				#(#{MenuButtonSpec} 					#layout: #(#{LayoutFrame} 152 0 119 0 -15 1 148 0 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) ) ) )</body></methods><methods><class-id>Store.TextDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="briefSpec">briefSpec	"Tools.UIPainter new openOnClass: self andSelector: #briefSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Definition Difference Browser' 			#min: #(#{Core.Point} 50 50 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1540 950 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00316957 2 0 0 0.496038 0 0.992126 ) 					#name: #text1Widget 					#model: #text1 					#menu: #customTextMenu 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.499208 2 0 0 0.99683 0 0.992126 ) 					#name: #text2Widget 					#model: #text2 					#menu: #customTextMenu 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Store.MethodDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="briefSpec">briefSpec	"Tools.UIPainter new openOnClass: self andSelector: #briefSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Method Difference Browser' 			#min: #(#{Core.Point} 50 50 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1540 950 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -1 0.5 -25 1 ) 					#name: #text1Widget 					#model: #text1 					#menu: #customTextMenu 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 2 0 -2 1 -25 1 ) 					#name: #text2Widget 					#model: #text2 					#menu: #customTextMenu 					#tabRequiresControl: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -24 1 -1 0.5 -1 1 ) 					#name: #protocol1 					#model: #protocol1 					#style: #default 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 -24 1 -2 1 -1 1 ) 					#name: #protocol2 					#model: #protocol2 					#style: #default 					#isReadOnly: true 					#type: #text ) ) ) )</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Version Graph' 			#min: #(#Point 589 194 ) 			#bounds: #(#Rectangle 412 517 1001 819 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #'LensGraphView' 					#minorKey: #windowSpec 					#clientKey: #graphView ) ) ) )</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="menuBarSkeleton">menuBarSkeleton	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_LoadDot 								#defaultString: '&amp;Load...' 								#catalogID: #store ) 							#value: #loadPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Merge 								#defaultString: '&amp;Merge' 								#catalogID: #store ) 							#value: #mergePundleVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'Set Blessing Level' 							#value: #setBlessingLevel ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOutDifferencesDots 								#defaultString: 'File Out Differences...' 								#catalogID: #store ) 							#value: #fileOutTwoPundleDiff ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Update 								#defaultString: 'Update' 								#catalogID: #store ) 							#value: #reloadVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #E_xit 								#defaultString: 'E&amp;xit' 								#catalogID: #store ) 							#value: #closeRequest ) ) #(2 1 2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Examine 					#defaultString: 'Examine' 					#catalogID: #store ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse 								#defaultString: 'Browse' 								#catalogID: #store ) 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ListContents 								#defaultString: 'List Contents' 								#catalogID: #store ) 							#value: #listBundleContents ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ListVersions 								#defaultString: '&amp;List Versions' 								#catalogID: #store ) 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithImage 								#defaultString: 'Compare with Image' 								#catalogID: #store ) 							#value: #diffPundleWithImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithParent 								#defaultString: 'Compare with Parent' 								#catalogID: #store ) 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareVersions 								#defaultString: 'Compare Versions' 								#catalogID: #store ) 							#value: #diffTwoPundles ) ) #(2 1 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Graph 					#defaultString: 'Graph' 					#catalogID: #store ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenOneOut 								#defaultString: 'Open One Out' 								#catalogID: #store ) 							#value: #openOneOut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenOneIn 								#defaultString: 'Open One In' 								#catalogID: #store ) 							#value: #openOneIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenFourOut 								#defaultString: 'Open Four Out' 								#catalogID: #store ) 							#value: #open4Out ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenFourIn 								#defaultString: 'Open Four In' 								#catalogID: #store ) 							#value: #open4In ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenAllOut 								#defaultString: 'Open All Out' 								#catalogID: #store ) 							#value: #openAllOut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenAllIn 								#defaultString: 'Open All In' 								#catalogID: #store ) 							#value: #openAllIn ) ) #(2 2 2 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.AbstractComparisonRollupView</class-id> <category>event driven</category><body package="Store-Code Comparison" selector="button1Down">button1Down	&lt;event: #Button1Down&gt;	self hasFocus ifFalse: [self takeKeyboardFocus]</body><body package="Store-Code Comparison" selector="button2Down">button2Down	&lt;event: #Button2Down&gt;	| valueResult menuView |	self hasFocus ifFalse: [self takeKeyboardFocus].	self hasMenu ifFalse: [^self].	menuView := self widgetPolicy menuViewForMenu: self menu.	valueResult := menuView openFromView: self.	valueResult value ifNotNil: [:block | block value]</body><body package="Store-Code Comparison" selector="keyDown:">keyDown: aKeyDown	&lt;event: #KeyDown&gt;	Character cr = aKeyDown keyValue ifTrue: [self toggleExpansion].	Character space = aKeyDown keyValue		ifTrue: 			[self isExpanded				ifTrue: [self cycleThruChanges: aKeyDown]				ifFalse: [self toggleExpansion]].	((Array with: #Right with: Character tab) includes: aKeyDown keyValue)		ifTrue: [self expandDetails].	aKeyDown keyValue == #Left ifTrue: [self collapseDetails].	aKeyDown keyValue == #Down ifTrue: [self focusNext].	aKeyDown keyValue == #Up ifTrue: [self focusPrevious]</body></methods><methods><class-id>Tools.AbstractComparisonRollupView class</class-id> <category>method tags</category><body package="Store-Code Comparison" selector="methodTags">methodTags		&lt;pragmas: #instance&gt;	^#(#itemInMenu:position:)</body></methods><methods><class-id>Tools.BindingBlueprintComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="browseImageLeftMenuItem">browseImageLeftMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^self leftImageReference		ifNotNil: 			[:bindingReference |			self hasSameImageObject				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: bindingReference toolListDisplayString))						value: [self browseImageObject: bindingReference];						yourself]]</body><body package="Store-Code Comparison" selector="browseImageRightMenuItem">browseImageRightMenuItem	&lt;itemInMenu: #(#menu) position: 20.9&gt;	^self rightImageReference		ifNotNil: 			[:bindingReference |			self hasSameImageObject				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: bindingReference toolListDisplayString))						value: [self browseImageObject: bindingReference];						yourself]]</body><body package="Store-Code Comparison" selector="browseImageSameMenuItem">browseImageSameMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^self hasSameImageObject		ifTrue: 			[(MenuItem labeled: #BrowseImage &lt;&lt; #IDE &gt;&gt; 'Browse Image')				value: [self browseImageObject: (self rightImageReference ifNil: [self leftImageReference])];				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison" selector="browseStoreLeftMenuItem">browseStoreLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^self leftStoreObject		ifNotNil: 			[:storeClassInPackage |			(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText						, (self storeObjectVersionLabel: storeClassInPackage))				value: [self browseStoreObject: storeClassInPackage];				yourself]</body><body package="Store-Code Comparison" selector="browseStoreRightMenuItem">browseStoreRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.2&gt;	^self rightStoreObject		ifNotNil: 			[:storeClassInPackage |			(self leftStoreObject ifNotNil: #primaryKey)				= storeClassInPackage primaryKey					ifTrue: [nil]					ifFalse: 						[(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText									, (self storeObjectVersionLabel: storeClassInPackage))							value: [self browseStoreObject: storeClassInPackage];							yourself]]</body><body package="Store-Code Comparison" selector="loadLeftMenuItem">loadLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^self leftStoreObject		ifNotNil: 			[:storeObjectInPackage |			(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText						, (self storeObjectVersionLabel: storeObjectInPackage))				value: [self loadObject: storeObjectInPackage];				yourself]</body><body package="Store-Code Comparison" selector="loadRightMenuItem">loadRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.6&gt;	^self rightStoreObject		ifNotNil: 			[:storeObjectInPackage |			(self leftStoreObject ifNotNil: #primaryKey) = storeObjectInPackage primaryKey				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText								, (self storeObjectVersionLabel: storeObjectInPackage))						value: [self loadObject: storeObjectInPackage];						yourself]]</body><body package="Store-Code Comparison" selector="noImageWarningMenuItem">noImageWarningMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^(MenuItem		labeled: ((#NoImageVersionToBrowser &lt;&lt; #IDE &gt;&gt; 'Not in Image') asText				emphasizeAllWith: (Array with: #italic)))		enabled: [false];		visible: [self rightImageReference isNil and: [self leftImageReference isNil]];		yourself</body><body package="Store-Code Comparison" selector="versionsMenuItem">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 40.9&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visible: [self leftStoreObject notNil or: [self rightStoreObject notNil]];		value: [self openObjectVersions];		yourself</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>resources</category><body package="Store-UI" selector="changeListMenu">changeListMenu	"MenuEditor new openOnClass: self andSelector: #changeListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #FileInOut #catalogID: #store #defaultString: 'File in/out') 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #WriteFile #catalogID: #store #defaultString: 'Write file...') 							#value: #fileOut ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RevertAll #catalogID: #store #defaultString: 'Revert all') 				#nameKey: #replayAllMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #FromHere #catalogID: #store #defaultString: 'From here') 							#value: #doFromHere ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #FromTheTop #catalogID: #store #defaultString: 'From the top') 							#value: #doAll ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RemoveAll #catalogID: #store #defaultString: 'Remove All') 				#value: #removeAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RestoreAll #catalogID: #store #defaultString: 'Restore All') 				#value: #restoreAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #SpawnAll #catalogID: #store #defaultString: 'Spawn All') 				#value: #copyView ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Forget #catalogID: #store #defaultString: 'Forget') 				#value: #forgetAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RevertSelection #catalogID: #store #defaultString: 'Revert selection') 				#value: #doThis ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RemoveSelection #catalogID: #store #defaultString: 'Remove Selection') 				#value: #removeItem ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RestoreSelection #catalogID: #store #defaultString: 'Restore selection') 				#value: #restoreItem ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #SpawnSelection #catalogID: #store #defaultString: 'Spawn selection') 				#value: #spawnBrowserOnSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Conflicts #catalogID: #store #defaultString: 'Conflicts') 				#nameKey: #conflictsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #CheckConflictsSaveAs #catalogID: #store #defaultString: 'Check conflicts, save as...') 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{UserMessage} #key: #CheckWithSystemSaveAs #catalogID: #store #defaultString: 'Check with system, save as...') 							#value: #checkWithSystem ) ) #(2 ) nil ) ) ) #(1 4 1 4 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #WriteFile 								#defaultString: 'Write file...' 								#catalogID: #store ) 							#value: #fileOut ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Revert 					#defaultString: 'Revert' 					#catalogID: #store ) 				#nameKey: #revert 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: 'Selection' 								#catalogID: #store ) 							#value: #doThis ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromTheTop 								#defaultString: 'All from the top' 								#catalogID: #store ) 							#value: #doAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromHereOnDown 								#defaultString: 'All from here on down' 								#catalogID: #store ) 							#value: #doFromHere ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Remove 					#defaultString: 'Remove' 					#catalogID: #store ) 				#nameKey: #remove 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: 'Selection' 								#catalogID: #store ) 							#value: #removeItem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #All 								#defaultString: 'All' 								#catalogID: #store ) 							#value: #removeAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllAbove 								#defaultString: 'All Above' 								#catalogID: #store ) 							#value: #removeAllAbove ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllBelow 								#defaultString: 'All Below' 								#catalogID: #store ) 							#value: #removeAllBelow ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExchangeRemoved 								#defaultString: 'Exchange removed' 								#catalogID: #store ) 							#value: #exchangeRemoved ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSourceAsParent 								#defaultString: 'Same source as parent' 								#catalogID: #store ) 							#value: #removeSameSourceAsParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentCodeThanParent 								#defaultString: 'Different code than parent' 								#catalogID: #store ) 							#value: #removeConflictsWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MethodsNotInParent 								#defaultString: 'Methods not in parent' 								#catalogID: #store ) 							#value: #removeMethodsNotInParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #EverythingNotInParent 								#defaultString: 'Everything not in parent' 								#catalogID: #store ) 							#value: #removeEverythingNotInParent ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangesContainingString 								#defaultString: 'Changes containing string ...' 								#catalogID: #store ) 							#value: #removeChangesContainingString ) ) #(4 1 2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Forget 					#defaultString: 'Forget' 					#catalogID: #store ) 				#nameKey: #forget 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetThese 								#defaultString: 'Forget these' 								#catalogID: #store ) 							#value: #forgetThese ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetAll 								#defaultString: 'Forget all' 								#catalogID: #store ) 							#value: #forgetAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PurgeThese 								#defaultString: 'Purge these' 								#catalogID: #store ) 							#nameKey: #purgeThese 							#value: #purgeThese ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PurgeSelection 								#defaultString: 'Purge selection' 								#catalogID: #store ) 							#nameKey: #purgeSelection 							#value: #purgeSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreSelection 								#defaultString: 'Restore selection' 								#catalogID: #store ) 							#value: #restoreItem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreAll 								#defaultString: 'Restore All' 								#catalogID: #store ) 							#value: #restoreAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreChangesContainingString 								#defaultString: 'Restore changes containing string' 								#catalogID: #store ) 							#value: #restoreChangesContainingString ) ) #(2 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Find 					#defaultString: 'Find' 					#catalogID: #store ) 				#nameKey: #find 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindPackageDots								#defaultString: 'Find Package...' 								#catalogID: #store ) 							#nameKey: #findPackage 							#value: #findPackage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindClassDots 								#defaultString: 'Find Class...' 								#catalogID: #store ) 							#value: #findClass ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindProtocolDots 								#defaultString: 'Find Protocol ...' 								#catalogID: #store ) 							#value: #findProtocol ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindSelectorDots								#defaultString: 'Find Selector ...' 								#catalogID: #store ) 							#value: #findSelector ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnSelection 								#defaultString: 'Spawn selection' 								#catalogID: #store ) 							#value: #spawnBrowserOnSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnAll 								#defaultString: 'Spawn All' 								#catalogID: #store ) 							#value: #copyView ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnOverridesContainingString 								#defaultString: 'Spawn overrides containing string' 								#catalogID: #store ) 							#value: #spawnChangesContainingString ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassMatching 								#defaultString: 'Class matching' 								#catalogID: #store ) 							#nameKey: #classMatching 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #InstanceAndClass 											#defaultString: 'Instance and class' 											#catalogID: #store ) 										#nameKey: #groupClassAndMetaclass 										#value: #groupClassAndMetaclass 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SelectedClassOnly 											#defaultString: 'Selected class only' 											#catalogID: #store ) 										#nameKey: #ungroupClassAndMetaclass 										#value: #ungroupClassAndMetaclass 										#indication: true ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SamePackage 								#defaultString: 'Same package' 								#catalogID: #store ) 							#nameKey: #filterByPackage 							#value: #togglePackageFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameType 								#defaultString: 'Same type' 								#catalogID: #store ) 							#nameKey: #filterByType 							#value: #toggleTypeFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameClass 								#defaultString: 'Same class' 								#catalogID: #store ) 							#nameKey: #filterByClass 							#value: #toggleClassFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameProtocol 								#defaultString: 'Same protocol' 								#catalogID: #store ) 							#nameKey: #filterByProtocol 							#value: #toggleProtocolFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSelector 								#defaultString: 'Same selector' 								#catalogID: #store ) 							#nameKey: #filterBySelector 							#value: #toggleSelectorFilter 							#indication: true ) ) #(4 3 1 5 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show 					#defaultString: 'Show' 					#catalogID: #store ) 				#nameKey: #show 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowCodeComponents 								#defaultString: 'Show code components' 								#catalogID: #store ) 							#nameKey: #showComponent 							#value: #toggleShowComponent 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowProtocol 								#defaultString: 'Show protocol' 								#catalogID: #store ) 							#nameKey: #showProtocol 							#value: #toggleShowProtocol 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowConflicts 								#defaultString: 'Show Conflicts' 								#catalogID: #store ) 							#nameKey: #showConflicts 							#value: #toggleShowConflicts 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Conflicts 								#defaultString: 'Conflicts' 								#catalogID: #store ) 							#nameKey: #showConflicts 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #VerticalView 											#defaultString: 'Vertical view' 											#catalogID: #store ) 										#nameKey: #viewConflictsVertically 										#value: #viewConflictsVertically 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #HorizontalView 											#defaultString: 'Horizontal view' 											#catalogID: #store ) 										#nameKey: #viewConflictsHorizontally 										#value: #viewConflictsHorizontally 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SourceDifferences 											#defaultString: 'Source differences' 											#catalogID: #store ) 										#nameKey: #highlightSourceDifferences 										#value: #highlightSourceDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #CodeDifferences 											#defaultString: 'Code differences' 											#catalogID: #store ) 										#nameKey: #highlightCodeDifferences 										#value: #highlightCodeDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #EmphasiseInList 											#defaultString: 'Emphasise in list' 											#catalogID: #store ) 										#nameKey: #toggleListEmphasis 										#value: #toggleListEmphasis ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #IndicateSameMethods 											#defaultString: 'Indicate same methods' 											#catalogID: #store ) 										#nameKey: #toggleTypesIncludeSame 										#value: #toggleTypesIncludeSame ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #LineEndTreatment 											#defaultString: 'Line-end treatment' 											#catalogID: #store ) 										#nameKey: #lineEndTreatment 										#submenu: #(#{UI.Menu} #(												#(#{UI.MenuItem} 													#rawLabel: 													#(#{Kernel.UserMessage} 														#key: #AsInFile 														#defaultString: 'As in file' 														#catalogID: #store ) 													#nameKey: #lineEndsRaw 													#value: #lineEndsRaw 													#indication: true ) 												#(#{UI.MenuItem} 													#rawLabel: 													#(#{Kernel.UserMessage} 														#key: #ConvertedToCrs 														#defaultString: 'Converted to crs' 														#catalogID: #store ) 													#nameKey: #lineEndsTreated 													#value: #lineEndsTreated 													#indication: true ) ) #(2 ) nil ) ) ) #(2 2 3 ) nil ) ) ) #(3 1 ) nil ) ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 300 400 ) 			#bounds: #(#{Graphics.Rectangle} 206 453 636 953 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 179 0 -1 1 -1 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #standardText ) 				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -98 1 172 0 ) 					#name: #listView 					#model: #selectionInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#toggleRemoveForListController: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #changeListMenuHolder ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 30 ) 							#model: #changeTypeFilterAdaptor 							#label: #(#{UserMessage} #key: #type #catalogID: #store #defaultString: 'type') ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 60 ) 							#model: #classNameFilterAdaptor 							#label: #(#{UserMessage} #key: #class #catalogID: #store #defaultString: 'class') ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 90 ) 							#model: #protocolFilterAdaptor 							#label: #(#{UserMessage} #key: #protocol #catalogID: #store #defaultString: 'protocol') ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 120 ) 							#model: #selectorFilterAdaptor 							#label: #(#{UserMessage} #key: #selector #catalogID: #store #defaultString: 'selector') ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#model: #packageFilterAdaptor 							#label: #(#{UserMessage} #key: #package #catalogID: #store #defaultString: 'package') ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -92 1 17 0 -2 1 169 0 ) ) ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreBrowserCodeTool class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #GoToClass 					#defaultString: 'Go to Class' 					#catalogID: #browser ) 				#nameKey: #'Navigate to Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseClassInNewWindow 					#defaultString: 'Browse Class in New Window' 					#catalogID: #browser ) 				#nameKey: #'Open Browser on Class' 				#value: 				#action: 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseLocal_ImplementorsOfSelector 					#defaultString: 'Browse &amp;Local Implementors of Selector' 					#catalogID: #store ) 				#nameKey: #BrowseImageImplementorsOfSelector 				#value: #browseLocalSelectors 				#enablementSelector: #hasMessageNodeSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseImage_SendersOfSelector 					#defaultString: 'Browse Image &amp;Senders of Selector' 					#catalogID: #store ) 				#nameKey: #'Selected Message References' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseImage_ImplementorsOfSelector 					#defaultString: 'Browse Image &amp;Implementors of Selector' 					#catalogID: #store ) 				#nameKey: #'Selected Message Implementors' 				#value: 				#action: 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#shortcutKeyCharacter: $p 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) ) #(5 4 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreForGlorpNavigator class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="classMenu">classMenu	"Tools.MenuEditor new openOnClass: self andSelector: #classMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVersions 					#defaultString: 'Browse Versions' 					#catalogID: #browser ) 				#nameKey: #'Store Browse Class Versions' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CompareWithDots 					#defaultString: 'Compare With...' 					#catalogID: #browser ) 				#nameKey: #'Store Compare Class Version' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #browser ) 				#nameKey: #'Spawn Class' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAsDots 					#defaultString: 'File Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Global' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Hardcopy 					#defaultString: 'Hardcopy' 					#catalogID: #browser ) 				#value: #printOutClass 				#enablementSelector: #isClassSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#nameKey: #InspectClasses 				#value: #inspectClasses 				#enablementSelector: #isClassSelected ) ) #(2 4 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI" selector="protocolMenu">protocolMenu	"Tools.MenuEditor new openOnClass: self andSelector: #protocolMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindMethodDot 					#defaultString: '&amp;Find Method...' 					#catalogID: #browser ) 				#nameKey: #'Find Method' 				#value: 				#action: 				#shortcutKeyCharacter: $m 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{BrowserIcons} #findMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #browser ) 				#nameKey: #'Spawn Protocol' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #File_OutAsDots 					#defaultString: 'File &amp;Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Protocol' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Hardcopy 					#defaultString: 'Hardcopy' 					#catalogID: #browser ) 				#value: #printOutProtocol 				#enablementSelector: #isProtocolSelected ) ) #(1 3 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI" selector="pundleMenu">pundleMenu	"Tools.MenuEditor new openOnClass: self andSelector: #pundleMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #LoadVersionDots 					#defaultString: 'Load Version' 					#catalogID: #browser ) 				#nameKey: #'Store Load Pundle' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#nameKey: #InspectPundle 				#value: #inspectPundle ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Store 					#defaultString: 'Store' 					#catalogID: #browser ) 				#nameKey: #Versions 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseVersions 								#defaultString: 'Browse Versions' 								#catalogID: #browser ) 							#nameKey: #'Store Browse Pundle Versions' 							#value: 							#action: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithDots 								#defaultString: 'Compare With...' 								#catalogID: #browser ) 							#nameKey: #'Store Compare Pundle Versions' 							#value: 							#action: ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindPackageDots 					#defaultString: 'Find Package...' 					#catalogID: #browser ) 				#nameKey: #'Find Package' 				#value: 				#action: 				#shortcutKeyCharacter: $P 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindNamespaceDots 					#defaultString: 'Find Namespace...' 					#catalogID: #browser ) 				#nameKey: #'Find Name Space' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindClassDots 					#defaultString: '&amp;Find Class...' 					#catalogID: #browser ) 				#nameKey: #'Find Class' 				#value: 				#action: 				#shortcutKeyCharacter: $l 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{BrowserIcons} #findClass ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindSharedVariableDots 					#defaultString: 'Find Shared Variable...' 					#catalogID: #browser ) 				#nameKey: #'Find Shared Variable' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAsDots 					#defaultString: 'File Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Package' 				#value: 				#action: ) ) #(2 1 4 1 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI" selector="selectorMenu">selectorMenu	"Tools.MenuEditor new openOnClass: self andSelector: #selectorMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #LocalImplementors 					#defaultString: '&amp;Local Implementors' 					#catalogID: #store ) 				#nameKey: #'Local Implementors' 				#value: 				#action: 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Implementors 								#defaultString: 'Implementors' 								#catalogID: #browser ) 							#nameKey: #'Local Implementors' 							#value: 							#action:methodName: ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LocalImplementors 								#defaultString: 'Local Implementors' 								#catalogID: #browser ) 							#nameKey: #'Local Implementors Actions' 							#value: #dynamicMenu ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Image_Implementors 					#defaultString: 'Image &amp;Implementors' 					#catalogID: #store ) 				#nameKey: #'Global Implementors' 				#value: 				#action: 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Implementors 								#defaultString: 'Implementors' 								#catalogID: #browser ) 							#nameKey: #'Global Implementors' 							#value: 							#action:methodName: 							#shortcutKeyCharacter: #F7 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{BrowserIcons} #definitionsMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GlobalImplementors 								#defaultString: 'Global Implementors' 								#catalogID: #browser ) 							#nameKey: #'Global Implementors Actions' 							#value: #dynamicMenu ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Store 					#defaultString: 'Store' 					#catalogID: #browser ) 				#nameKey: #Store 				#value: #rbItem 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseVersions 								#defaultString: 'Browse Versions' 								#catalogID: #browser ) 							#nameKey: #'Store Browse Method Versions' 							#value: 							#action: 							#enablementSelector: #isMethod ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BrowseVersions 								#defaultString: 'Browse Versions' 								#catalogID: #browser ) 							#nameKey: #'Store Browse Shared Variable Versions' 							#value: 							#action: 							#enablementSelector: #isData ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithDots 								#defaultString: 'Compare With...' 								#catalogID: #browser ) 							#nameKey: #'Store Compare Method Versions' 							#value: 							#action: 							#enablementSelector: #isMethod ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithDots 								#defaultString: 'Compare With...' 								#catalogID: #browser ) 							#nameKey: #'Store Compare Shared Variable Versions' 							#value: 							#action: 							#enablementSelector: #isData ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #browser ) 				#nameKey: #'Spawn Method' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#nameKey: #InspectSelected 				#value: #inspectSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #File_OutAsDots 					#defaultString: 'File &amp;Out As...' 					#catalogID: #browser ) 				#nameKey: #'File Out Method' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Hardcopy 					#defaultString: 'Hardcopy' 					#catalogID: #browser ) 				#value: #printOutMessage 				#enablementSelector: #isDefinitionSelected ) ) #(1 1 1 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.BlessingLevel class</class-id> <category>interface specs</category><body package="Store-User Management" selector="mainSpec">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #ResetBlessingLevelAndComment #catalogID: #store #defaultString: 'Reset Blessing Level and Comment') 			#min: #(#{Core.Point} 331 321 ) 			#bounds: #(#{Graphics.Rectangle} 159 403 630 883 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -83 1 ) 					#label: #(#{UserMessage} #key: #BundleAndSubcomponents #catalogID: #store #defaultString: 'Bundle and Subcomponents') ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -41 1 -3 1 -39 1 ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -280 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: #(#{UserMessage} #key: #BlessingcommentC #catalogID: #store #defaultString: 'Blessing comment:') ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 19 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -220 1 -11 1 -90 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -50 1 0.5 1 ) 					#model: #allBlessings 					#label: #(#{UserMessage} #key: #SetGlobalBlessingLevelAndComment #catalogID: #store #defaultString: 'Set Global Blessing Level and Comment') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Ok #catalogID: #store #defaultString: 'Ok') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #store #defaultString: 'Help') 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1.0 0 1.0 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.08 ) 							#label: #(#{UserMessage} #key: #BlessinglevelC #catalogID: #store #defaultString: 'Blessing level:') ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 11 223 460 248 ) ) ) ) ) )</body></methods><methods><class-id>Store.Glorp.DefinitionsForListPane class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 900 550 1100 750 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#flags: 15 					#model: #itemsInList 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.Glorp.SharedVariableListPane class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOut 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_Shared 								#defaultString: 'Load &amp;Shared' 								#catalogID: #store ) 							#nameKey: #LoadShared 							#value: #loadShared 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 2 1 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.DBAccess</class-id> <category>initialize-release</category><body package="Store-Database Model" selector="clearPundleCaches">clearPundleCaches	Store.Glorp.StorePundle withAllSubclasses do:		[:each | each initializeCache]</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>interface specs</category><body package="Store-Database" selector="reconnectSpec">reconnectSpec	"UIPainter new openOnClass: self andSelector: #reconnectSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #StoreConnection #catalogID: #store #defaultString: 'Store Connection') 			#min: #(#{Core.Point} 298 234 ) 			#max: #(#{Core.Point} 391 378 ) 			#bounds: #(#{Graphics.Rectangle} 338 193 729 571 ) 			#flags: 8 			#menu: #menuBar 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 234 0 0 1 ) 					#label: #(#{UserMessage} #key: #Username #catalogID: #store #defaultString: 'Username:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 265 0 0 1 ) 					#label: #(#{UserMessage} #key: #Password #catalogID: #store #defaultString: 'Password:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 299 0 0 1 ) 					#label: #(#{UserMessage} #key: #EnvironmentC #catalogID: #store #defaultString: 'Environment:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 37 0 -10 1 156 0 ) 					#name: #messageBox 					#model: #message 					#alignment: #center 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#name: #title 					#label: #(#{UserMessage} #key: #ReconnectingToTheStoreDatabase #catalogID: #store #defaultString: 'Reconnecting to the Store database.') ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 213 0 -16 1 237 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #userName 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 243 0 -16 1 267 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #password 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 278 0 -16 1 302 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #environment 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 204 0 -35 1 286 0 -8 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Connect #catalogID: #store #defaultString: 'Connect') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -97 1 -35 1 -15 1 -8 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{UserMessage} #key: #Detach #catalogID: #store #defaultString: 'Detach') 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 183 ) 					#label: #(#{UserMessage} #key: #DatabaseConnect #catalogID: #store #defaultString: 'Database Connect:') ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 183 369 207 ) 					#name: #whichDriver 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #whichDriverModel ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 150 308 ) 					#name: #saveConnection 					#model: #saveConnection 					#label: #(#{UserMessage} #key: #SaveConnectionInformation #catalogID: #store #defaultString: 'Save Connection Information') ) ) ) )</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>resources</category><body package="Store-UI" selector="repositoryMenu">repositoryMenu	"Tools.MenuEditor new openOnClass: self andSelector: #repositoryMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_BrowsePublishedItems 					#defaultString: '&amp;Browse Published Items' 					#catalogID: #store ) 				#nameKey: #repositoryPublishedItems 				#value: #repositoryPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_MoreRecentlyPublishedItems 					#defaultString: 'Browse &amp;More Recently Published Items' 					#catalogID: #store ) 				#nameKey: #repositoryMoreRecentlyPublishedItems 				#value: #repositoryMoreRecentlyPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PropertiesDots 					#defaultString: '&amp;Properties...' 					#catalogID: #store ) 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDots 					#defaultString: '&amp;New...' 					#catalogID: #store ) 				#nameKey: #repositoryNew 				#value: #repositoryNew ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ImportRepositoriesDots 					#defaultString: '&amp;Import Repositories...' 					#catalogID: #store ) 				#nameKey: #repositoryImport 				#value: #repositoryImport 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ExportRepositoriesDots 					#defaultString: '&amp;Export Repositories...' 					#catalogID: #store ) 				#nameKey: #repositoryExport 				#value: #repositoryExport 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_OpenRepositoryManager 					#defaultString: '&amp;Open Repository Manager' 					#catalogID: #store ) 				#nameKey: #openRepositoryManager 				#value: #openRepositoryManager 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #store ) ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #store ) 			#bounds: #(#{Graphics.Rectangle} 840 525 1040 725 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 0 0 0 1 0 1 ) 					#name: #label 					#flags: 0 					#model: #labelHolder 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #StoreRepositoriesLeIghtClickToManage 						#defaultString: 'Store repositories. Left-click to connect, right-click to manage.' 						#catalogID: #store ) 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} 14 0 0 0.5 0.5 0.5 ) 					#name: #storeIcon 					#label: #storeIcon 					#hasCharacterOrientedLabel: false ) ) ) )</body></methods><methods><class-id>Tools.MethodComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="browseImageLeftMenuItem">browseImageLeftMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^self leftImageMethod		ifNotNil: 			[:imageMethod |			self rightImageMethod = imageMethod				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: imageMethod displayString))						value: [self browseImageMethod: imageMethod];						yourself]]</body><body package="Store-Code Comparison" selector="browseImageRightMenuItem">browseImageRightMenuItem	&lt;itemInMenu: #(#menu) position: 20.9&gt;	^self rightImageMethod		ifNotNil: 			[:imageMethod |			self leftImageMethod = imageMethod				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#Browse1 &lt;&lt; #IDE &gt;&gt; 'Browse &lt;1s&gt;'								expandMacrosWith: imageMethod displayString))						value: [self browseImageMethod: imageMethod];						yourself]]</body><body package="Store-Code Comparison" selector="browseImageSameMenuItem">browseImageSameMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^(MenuItem labeled: #BrowseImage &lt;&lt; #IDE &gt;&gt; 'Browse Image')		visible: 				[self rightImageMethod notNil					and: [self leftImageMethod = self rightImageMethod]];		value: [self browseImageMethod: self rightImageMethod];		yourself</body><body package="Store-Code Comparison" selector="browseStoreLeftMenuItem">browseStoreLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^self leftStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText						, (self storeObjectVersionLabel: storeMethodInPackage))				value: [self browseStoreMethod: storeMethodInPackage];				yourself]</body><body package="Store-Code Comparison" selector="browseStoreRightMenuItem">browseStoreRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.2&gt;	^self rightStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(self leftStoreMethod ifNotNil: #primaryKey)				= storeMethodInPackage primaryKey					ifTrue: [nil]					ifFalse: 						[(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText									, (self storeObjectVersionLabel: storeMethodInPackage))							value: [self browseStoreMethod: storeMethodInPackage];							yourself]]</body><body package="Store-Code Comparison" selector="loadLeftMenuItem">loadLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^self leftStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(self canRevertFrom: self rightImageMethod to: storeMethodInPackage)				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText								, (self storeObjectVersionLabel: storeMethodInPackage))						value: [self loadMethod: storeMethodInPackage];						yourself]]</body><body package="Store-Code Comparison" selector="loadRightMenuItem">loadRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.6&gt;	^self rightStoreMethod		ifNotNil: 			[:storeMethodInPackage |			(self canRevertFrom: self leftImageMethod to: storeMethodInPackage)				ifTrue: [nil]				ifFalse: 					[(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText								, (self storeObjectVersionLabel: storeMethodInPackage))						value: [self loadMethod: storeMethodInPackage];						yourself]]</body><body package="Store-Code Comparison" selector="revertLeftMenuItem">revertLeftMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^(self canRevertFrom: self rightImageMethod to: self leftStoreMethod)		ifTrue: 			[(MenuItem labeled: (#StoreRevertPrefix &lt;&lt; #IDE &gt;&gt; 'Revert ') asText						, (self storeObjectVersionLabel: self leftStoreMethod))				value: 						[#{Store.XChangeSet} value current							revertSelector: self rightImageMethod selector							class: self rightImageMethod implementingClass];				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison" selector="revertRightMenuItem">revertRightMenuItem	&lt;itemInMenu: #(#menu) position: 40.6&gt;	^(self canRevertFrom: self leftImageMethod to: self rightStoreMethod)		ifTrue: 			[(MenuItem labeled: (#StoreRevertPrefix &lt;&lt; #IDE &gt;&gt; 'Revert ') asText						, (self storeObjectVersionLabel: self rightStoreMethod))				value: 						[#{Store.XChangeSet} value current							revertSelector: self leftImageMethod selector							class: self leftImageMethod implementingClass];				yourself]		ifFalse: [nil]</body><body package="Store-Code Comparison" selector="versionsMenuItem">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 40.9&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visible: [self leftStoreMethod notNil or: [self rightStoreMethod notNil]];		value: [self openMethodVersions];		yourself</body></methods><methods><class-id>Store.RepositoryPropertiesDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"UI.FullSpec class new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #RepositoryProperties #catalogID: #store #defaultString: 'Repository Properties') 			#min: #(#{Core.Point} 410 201 ) 			#max: #(#{Core.Point} 410 201 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 922 585 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 15 300 40 ) 					#name: #nameField 					#model: #nameHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 130 45 300 70 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 75 300 100 ) 					#name: #environmentField 					#model: #environmentHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 105 300 130 ) 					#name: #userNameField 					#model: #userNameHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 135 300 160 ) 					#name: #passwordField 					#model: #passwordHolder 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 165 300 190 ) 					#name: #tableOwnerField 					#model: #tableOwnerHolder ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #accept 					#model: #ok 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 40 0 0 1 ) 					#name: #Label1 					#label: #(#{UserMessage} #key: #NameC #catalogID: #store #defaultString: 'Name:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 70 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 130 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 160 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 100 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 190 0 0 1 ) 					#label: #(#{UserMessage} #key: #TableOwner #catalogID: #store #defaultString: 'Table Owner:') ) ) ) )</body></methods><methods><class-id>Tools.StoreRepositoryListPage class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #store #defaultString: 'Unlabeled Canvas') 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 850 672 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines false #allowColumnResizing true #rowSize 25 #showVerticalLines false #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -30 1 ) 					#name: #repositoryListDataset 					#flags: 13 					#model: #repositoryListHolder 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing false ) 							#model: #'repositoryHolder name' 							#label: #(#{UserMessage} #key: #Name #catalogID: #store #defaultString: 'Name') 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'repositoryHolder environment' 							#label: #(#{UserMessage} #key: #Environment #catalogID: #store #defaultString: 'Environment') 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 -3 0.333333 0 1 ) 					#name: #addButton 					#model: #addRepository 					#label: #(#{UserMessage} #key: #AddDots #catalogID: #store #defaultString: 'Add...') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.333333 -25 1 -2 0.666666 0 1 ) 					#name: #removeButton 					#model: #removeRepository 					#label: #(#{UserMessage} #key: #RemoveDots #catalogID: #store #defaultString: 'Remove...') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.666666 -25 1 0 1 0 1 ) 					#name: #propertiesButton 					#model: #repositoryProperties 					#label: #(#{UserMessage} #key: #PropertiesDots #catalogID: #store #defaultString: 'Properties...') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.Pundle</class-id> <category>utilities-repository</category><body package="Store-Database Model" selector="selectStoreVersion">selectStoreVersion 	"Answer the user selected published version of the receiver.	nil if none."	^self selectStoreVersionIn: Store.Glorp.StoreLoginFactory currentStoreSession.</body><body package="Store-Database Model" selector="selectStoreVersionIn:">selectStoreVersionIn: aSession	"Answer the user selected published version of the receiver.	nil if none."	^self class storeDatabaseClass selectStoreVersionOf: self name in: aSession</body></methods><methods><class-id>Store.Pundle</class-id> <category>converting</category><body package="Store-Database Model" selector="asStoreComparisonObjectIn:">asStoreComparisonObjectIn: aSession	^self asStorePundleIn: aSession</body><body package="Store-Database Model" selector="asStorePundle">asStorePundle	| session storePundle |	session := Store.Glorp.StoreLoginFactory currentStoreSession.	storePundle := session		readOneOf: self  storeForGlorpPundleClass		where: [:db | db primaryKey = self primaryKey].	^storePundle</body><body package="Store-Database Model" selector="asStorePundleFromCache">asStorePundleFromCache	| cache session |	session := (cache := self storeForGlorpPundleClass cache) notEmpty 		ifTrue: [cache any session]		ifFalse: [	Store.Glorp.StoreLoginFactory currentStoreSession].	^self storeForGlorpPundleClass cachedItemFor: (self asStorePundleIn: session)</body><body package="Store-Database Model" selector="asStorePundleIn:">asStorePundleIn: aSession	| storePundle |	storePundle := aSession		readOneOf: self  storeForGlorpPundleClass		where: [:db | db primaryKey = self primaryKey].	^storePundle</body><body package="Store-Database Model" selector="cleanse:">cleanse: ignore</body><body package="Store-Database Model" selector="glorpReconciledVersion">glorpReconciledVersion		| pundleModel |	pundleModel := self getImagePundle.	^pundleModel notNil		ifTrue: [pundleModel glorpReconciledVersionFrom: self]		ifFalse: [self asStorePundle]</body><body package="Store-Database Model" selector="glorpReconciledVersionIn:">glorpReconciledVersionIn: aSession		| pundleModel |	pundleModel := self getImagePundle.	^pundleModel notNil		ifTrue: [pundleModel glorpReconciledVersionFrom: self]		ifFalse: [self asStorePundleIn: aSession]</body><body package="Store-Database Model" selector="storeModel">storeModel	^self getImagePundle</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>resources</category><body package="Store-UI" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ImportDots 								#defaultString: '&amp;Import...' 								#catalogID: #store ) 							#nameKey: #fileImport 							#value: #fileImport 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExportDots 								#defaultString: '&amp;Export...' 								#catalogID: #store ) 							#nameKey: #fileSave 							#value: #fileSave 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Close 								#defaultString: '&amp;Close' 								#catalogID: #store ) 							#nameKey: #fileClose 							#value: #fileClose ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Repository 					#defaultString: '&amp;Repository' 					#catalogID: #store ) 				#nameKey: #repository 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDots								#defaultString: '&amp;New...' 								#catalogID: #store ) 							#nameKey: #repositoryNew 							#value: #repositoryNew 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PropertiesDots								#defaultString: '&amp;Properties...' 								#catalogID: #store ) 							#nameKey: #repositoryProperties 							#value: #repositoryProperties 							#enablementSelector: #isRepositorySelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Remove 								#defaultString: '&amp;Remove...' 								#catalogID: #store ) 							#nameKey: #repositoryRemove 							#value: #repositoryRemove 							#enablementSelector: #isRepositorySelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Connect 								#defaultString: '&amp;Connect' 								#catalogID: #store ) 							#nameKey: #repositoryToggleConnection 							#value: #repositoryToggleConnection 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Published_Items 								#defaultString: 'Published &amp;Items' 								#catalogID: #store ) 							#nameKey: #repositoryPublishedItems 							#value: #repositoryPublishedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_MoreRecentItems 								#defaultString: '&amp;More Recent Items' 								#catalogID: #store ) 							#nameKey: #repositoryMoreRecentlyPublishedItems 							#value: #repositoryMoreRecentlyPublishedItems ) ) #(1 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorks 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #store ) 							#nameKey: #helpAbout 							#value: #helpAbout ) ) #(1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="repositoryListMenu">repositoryListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #repositoryListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_NewDots #catalogID: #store #defaultString: '&amp;New...') 				#nameKey: #repositoryNew 				#value: #repositoryNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_PropertiesDots #catalogID: #store #defaultString: '&amp;Properties...') 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#enablementSelector: #isRepositorySelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_Remove #catalogID: #store #defaultString: '&amp;Remove...') 				#nameKey: #repositoryRemove 				#value: #repositoryRemove 				#enablementSelector: #isRepositorySelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_Connect #catalogID: #store #defaultString: '&amp;Connect') 				#nameKey: #repositoryToggleConnection 				#value: #repositoryToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Published_Items #catalogID: #store #defaultString: 'Published &amp;Items') 				#nameKey: #repositoryPublishedItems 				#value: #repositoryPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #_MoreRecentItems #catalogID: #store #defaultString: '&amp;More Recent Items') 				#nameKey: #repositoryMoreRecentlyPublishedItems 				#value: #repositoryMoreRecentlyPublishedItems ) ) #(1 2 3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="toolbarMenu">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ImportDots 					#defaultString: '&amp;Import...' 					#catalogID: #store ) 				#nameKey: #fileImport 				#value: #fileImport 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ImportRepositoriesFromFile 					#defaultString: 'Import repositories from file' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ExportDots 					#defaultString: '&amp;Export...' 					#catalogID: #store ) 				#nameKey: #fileSave 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ExportRepositoriesToFile 					#defaultString: 'Export repositories to file' 					#catalogID: #store  ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDots					#defaultString: '&amp;New...' 					#catalogID: #store ) 				#nameKey: #repositoryNew 				#value: #repositoryNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #CreateANewRepository 					#defaultString: 'Create a new repository' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PropertiesDots 					#defaultString: '&amp;Properties...' 					#catalogID: #store ) 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#enablementSelector: #isRepositorySelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #EditRepositoryProperties 					#defaultString: 'Edit repository properties' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Connect 					#defaultString: '&amp;Connect' 					#catalogID: #store ) 				#nameKey: #repositoryToggleConnection 				#value: #repositoryToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ConnectOrDisconnectTheSelectedRepository 					#defaultString: 'Connect or disconnect the selected repository' 					#catalogID: #store ) ) ) #(2 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #StoreRepositories #catalogID: #store #defaultString: 'Store Repositories') 			#min: #(#{Core.Point} 492 188 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 526 384 956 584 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #toolbarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #allowSorting true #allowColumnReordering false #allowColumnResizing true #showVerticalLines false #rowSize 22 #showHorizontalLines false #rowLabelsAsButtons false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #repositoryDataset 					#flags: 13 					#model: #repositoryListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #repositorySelected 						#doubleClickSelector: #repositoryListDoubleClicked ) 					#menu: #repositoryListMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder isConnected' 							#label: '' 							#labelIsImage: false 							#width: 22 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder name' 							#label: #(#{UserMessage} #key: #Name #catalogID: #store #defaultString: 'Name') 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder environment' 							#label: #(#{UserMessage} #key: #Environment #catalogID: #store #defaultString: 'Environment') 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder userName' 							#label: #(#{UserMessage} #key: #User #catalogID: #store #defaultString: 'User') 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreBrowserDefinitionTool class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#shortcutKeyCharacter: $p 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#shortcutKeyCharacter: $F 				#shortcutModifiers: 2 ) ) #(4 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreBrowserCommentTool class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #browser ) 				#nameKey: #'Do It' 				#value: 				#action: 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Pri_ntIt 					#defaultString: 'Pri&amp;nt it' 					#catalogID: #browser ) 				#nameKey: #'Print It' 				#value: 				#action: 				#shortcutKeyCharacter: $p 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #browser ) 				#nameKey: #'Inspect It' 				#value: 				#action: 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DebugIt 					#defaultString: '&amp;Debug it' 					#catalogID: #browser ) 				#nameKey: #'Debug It' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #browser ) 				#nameKey: #'Copy Selection' 				#value: 				#action: 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #browser ) 				#nameKey: #'Find Text' 				#value: 				#action: 				#shortcutKeyCharacter: $F 				#shortcutModifiers: 2 ) ) #(4 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Browser" selector="horizontalWindowSpec">horizontalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #horizontalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #store #defaultString: 'Unlabeled Canvas') 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1336 1007 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -2 0.33333 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.33333 0 1 2 0.33333 ) 					#name: #splitter 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.33333 0 1 0 1 ) 					#name: #text 					#model: #text 					#menu: #readOnlyCodeMenu 					#tabRequiresControl: true ) ) ) )</body><body package="Store-UI-Browser" selector="verticalWindowSpec">verticalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #verticalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #store #defaultString: 'Unlabeled Canvas') 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1336 1007 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.33333 0 1 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.33333 0 0 2 0.33333 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.33333 0 0 0 1 0 1 ) 					#name: #text 					#model: #text 					#menu: #readOnlyCodeMenu 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Store.RecordVersionsViewer class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="readOnlyCodeMenu">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MergeToolHelp class</class-id> <category>interface specs</category><body package="Store-Merge Management" selector="howToUseHelpSpec">howToUseHelpSpec	"Tools.UIPainter new openOnClass: self andSelector: #howToUseHelpSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #HowToUseMergeTool #defaultString: 'How to Use Merge Tool' #catalogID: #store) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 720 300 1360 900 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -45 1 ) 					#name: #HelpText 					#model: #helpTextHolder 					#tabable: true 					#isReadOnly: false 					#tabRequiresControl: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #CloseButton 					#model: #closeRequest 					#label: #(#{Kernel.UserMessage} #key: #Close #defaultString: 'Close' #catalogID: #store) 					#defaultable: true ) ) ) )</body><body package="Store-Merge Management" selector="iconHelpSpec">iconHelpSpec	"Tools.UIPainter new openOnClass: self andSelector: #iconHelpSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #MergeToolIconsReference #defaultString: 'Merge Tool Icons Reference' #catalogID: #store) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1070 720 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -45 1 ) 					#name: #HelpIconList 					#flags: 12 					#model: #helpIconList 					#tabable: false 					#selectionType: #highlight 					#autoSelect: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #CloseButton 					#model: #closeRequest 					#label: #(#{Kernel.UserMessage} #key: #Close #defaultString: 'Close' #catalogID: #store) 					#defaultable: true ) ) ) )</body><body package="Store-Merge Management" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #MergeToolHelp #defaultString: 'Merge Tool Help' #catalogID: #store) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 698 278 1598 978 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #HelpText 					#model: #helpTextHolder 					#tabable: false 					#isReadOnly: false 					#tabRequiresControl: false ) ) ) )</body></methods><methods><class-id>Store.Glorp.MethodListPane class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOut 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWithIma_ge 								#defaultString: 'Compare With Ima&amp;ge' 								#catalogID: #store ) 							#nameKey: #CompareWithImage 							#value: #compareWithImage 							#enablementSelector: #existsInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_Method 								#defaultString: 'Load &amp;Method' 								#catalogID: #store ) 							#nameKey: #LoadMethod 							#value: #loadMethod 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 3 1 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ScrolledComparisonShell</class-id> <category>event states</category><body package="Store-Code Comparison" selector="mouseWheel:">mouseWheel: aMouseWheel	&lt;event: #MouseWheel&gt;	self scroller		ifNotNil: 			[:scroller |			| delta |			delta := scroller scrollOffsetHolder grid.			scroller				scrollBy: (aMouseWheel up ifTrue: [delta negated] ifFalse: [delta])]</body></methods><methods><class-id>Store.Glorp.NameSpaceListPane class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOut 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_NameSpace 								#defaultString: 'Load &amp;NameSpace' 								#catalogID: #store ) 							#nameKey: #LoadNameSpace 							#value: #loadNameSpace 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 2 1 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.DeletionToolFilterTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #DeletionToolFilters 				#defaultString: 'Deletion Tool Filters' 				#catalogID: #store ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1200 714 1800 954 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 55 0 ) 					#name: #PackageBundleGroupBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #PackageBundleList 						#defaultString: 'Package/Bundle List' 						#catalogID: #store ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 65 0 -5 1 -35 1 ) 					#name: #VersionsListGroup 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsList 						#defaultString: 'Versions List' 						#catalogID: #store ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.3 24 0 1 0 ) 					#name: #NameLikeCheck 					#model: #nameLikeCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #NameLikeColon 						#defaultString: 'Name Like:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 20 0 -50 1 45 0 ) 					#name: #PundleName 					#flags: 40 					#model: #pundleName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.3 91 0 1 0 ) 					#name: #AfterDateCheck 					#model: #afterDateCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #AfterDateColon 						#defaultString: 'After Date:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 88 0 100 0.3 111 0 ) 					#name: #AfterDate 					#flags: 40 					#model: #afterDate 					#type: #date 					#formatString: 'm/d/yy' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.7 91 0 1 0 ) 					#name: #BeforeDateCheck 					#model: #beforeDateCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #BeforeDateColon 						#defaultString: 'Before Date:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.7 88 0 100 0.7 111 0 ) 					#name: #BeforeDate 					#flags: 40 					#model: #beforeDate 					#type: #date 					#formatString: 'm/d/yy' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.301667 131 0 1 0 ) 					#name: #BlessingGreaterThanCheck 					#model: #blessingGreaterThanCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #BlessingGreaterThanColon 						#defaultString: 'Blessing Greater Than:' 						#catalogID: #store ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 128 0 130 0.3 151 0 ) 					#name: #BlessingGreaterThan 					#flags: 40 					#model: #blessingGreaterThan 					#menu: #blessingMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.701667 131 0 1 0 ) 					#name: #BlessingLessThanCheck 					#model: #blessingLessThanCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #LessThanColon 						#defaultString: 'Less Than:' 						#catalogID: #store ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.7 128 0 130 0.7 151 0 ) 					#name: #BlessingLessThan 					#flags: 40 					#model: #blessingLessThan 					#menu: #blessingMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.3 172 0 1 0 ) 					#name: #VersionLikeCheck 					#model: #versionLikeCheck 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionLikeColon 						#defaultString: 'Version Like:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.3 165 0 -50 1 190 0 ) 					#name: #VersionLike 					#flags: 40 					#model: #versionLike ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 -28 1 -90 1 -5 1 ) 					#name: #Cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #dialogs ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -28 1 -5 1 -5 1 ) 					#name: #Ok 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #Ok 						#defaultString: 'Ok' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>interface specs</category><body package="Store-Database" selector="stopSpec">stopSpec	"UIPainter new openOnClass: self andSelector: #stopSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Load  Analyzer' 			#bounds: #(#Rectangle 423 252 773 610 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -35 0.5 -38 1 35 0.5 -5 1 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) ) ) )</body><body package="Store-Database" selector="warningSpec">warningSpec	"UIPainter new openOnClass: self andSelector: #warningSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #LoadAnalyzer #catalogID: #store #defaultString: 'Load  Analyzer') 			#bounds: #(#{Graphics.Rectangle} 332 174 682 532 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 0.5 -38 1 -10 0.5 -5 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Proceed #catalogID: #store #defaultString: 'Proceed') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -38 1 80 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.LoadDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="loadDialogSpec">loadDialogSpec	"UIPainter new openOnClass: self andSelector: #loadDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnpublishedChanges #catalogID: #store #defaultString: 'Unpublished Changes') 			#bounds: #(#{Graphics.Rectangle} 625 421 975 779 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -38 1 80 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 0.5 -38 1 -10 0.5 -5 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Proceed #catalogID: #store #defaultString: 'Proceed') 					#isDefault: false 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Store.ResolutionsListPane class</class-id> <category>interface specs</category><body package="Store-Merge Management" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1517 1028 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #ModSet 					#flags: 7 					#model: #list 					#tabable: true 					#menu: #modificationMenu ) ) ) )</body></methods><methods><class-id>Store.StorePublishDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="activeAreaSpec">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #windowLabel 			#min: #(#Point 265 317 ) 			#max: #(#Point 265 317 ) 			#bounds: #(#Rectangle 260 120 525 437 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 2 0 2 0 -2 1 -2 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="Store-UI" selector="windowNotebookSpec">windowNotebookSpec	"UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#min: #(#{Point} 523 340 ) 			#bounds: #(#{Rectangle} 186 175 762 517 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{TabControlSpec} 					#layout: #(#{LayoutFrame} 2 0 5 0 -6 1 -3 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#rightInset: 120 					#bottomInset: 0 ) ) ) )</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="activeAreaSpec">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 332 332 ) 			#bounds: #(#{Graphics.Rectangle} 276 144 748 624 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 7 0 -2 1 -7 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="Store-UI" selector="filesSpec">filesSpec	"Tools.UIPainter new openOnClass: self andSelector: #filesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PublishPundles 				#defaultString: 'Publish Pundles' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1372 1030 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -75 1 ) 					#name: #fileList 					#model: #files 					#menu: #filesMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 -70 1 ) 					#name: #publishSelectedCheckBox 					#model: #publish 					#label: 'Publish the selected file' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -140 1 -70 1 -10 1 -45 1 ) 					#name: #publishAllYes 					#model: #publishAllYes 					#label: 'Include All' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -140 1 -40 1 -10 1 -15 1 ) 					#name: #publishAllNo 					#model: #publishAllNo 					#label: 'Include Modified Only' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="mainSpec">mainSpec	"Tools.UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 331 321 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 718 385 1356 860 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -25 0.45 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -55 1 -10 1 -30 1 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -55 1 0 1 ) 					#name: #blessingLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #BlessingC 						#defaultString: 'Blessing:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 0 0.45 0 1 ) 					#name: #commentLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #CommentC 						#defaultString: 'Comment:' 						#catalogID: #store ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.45 -10 1 -95 1 ) 					#name: #blessingComment 					#model: #blessingComment 					#tabRequiresControl: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#name: #binarySave 					#model: #binarySave 					#label: 'Publish Binary' ) ) ) )</body><body package="Store-UI" selector="parcelSpec">parcelSpec	"Tools.UIPainter new openOnClass: self andSelector: #parcelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1372 1030 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 'Publish Parcel' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 'Parcel Path:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 -10 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Store options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0787037 0 0.253333 ) 							#name: #bundleStructure 							#model: #bundleStructure 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #bundleStructureChanged ) 							#label: 'Include bundle structure' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.537634 ) 							#name: #databaseLinks 							#model: #databaseLinks 							#label: 'With database links' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.333333 -5 0.5 75 0.333333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Source options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 'Save source file' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 'Hide source on load' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 'Pad source' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.583333 -5 0.5 80 0.583333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Miscellaneous Options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 'Republish' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 'Backup' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 'Overwrite existing files' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0.5 0 0.583333 -10 1 80 0.583333 ) ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 11 0 -55 1 0 1 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionStringColon 						#defaultString: 'Version String:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 -77 1 -145 1 -52 1 ) 					#name: #VersionString 					#flags: 40 					#model: #parcelVersionString ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -77 1 -11 1 -52 1 ) 					#name: #CopyFromPackage 					#flags: 40 					#model: #copyFromPackage 					#label: 					#(#{Kernel.UserMessage} 						#key: #CopyFromPackage 						#defaultString: 'Copy From Package' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="publishSpec">publishSpec	"Tools.UIPainter new openOnClass: self andSelector: #publishSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 420 1192 900 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -75 1 ) 					#name: #itemsList 					#model: #items ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 -65 1 ) 					#name: #publishSelectedCheck 					#model: #publish 					#label: 'Publish currently selected item' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 -40 1 -10 1 -15 1 ) 					#name: #publishAllNo 					#model: #publishAllNo 					#label: 'Include Modified Only' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 -70 1 -10 1 -45 1 ) 					#name: #publishAllYes 					#model: #publishAllYes 					#label: 'Include All Items' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="versionSpec">versionSpec	"Tools.UIPainter new openOnClass: self andSelector: #versionSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 420 1192 900 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -40 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 0 1 ) 							#name: #versionStringBox 							#model: #versionString ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0 0 1 0 1 ) 							#name: #vStringLabel 							#label: 'Version:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -35 1 -95 1 -10 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#model: #allVersions 					#label: 'Apply to All' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="windowNotebookSpec">windowNotebookSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #windowLabel 			#min: #(#{Core.Point} 506 364 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 720 350 1270 900 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -265 1 -35 1 -180 1 -10 1 ) 					#name: #publishButton 					#model: #accept 					#label: 'Publish' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 -35 1 -90 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -35 1 -5 1 -10 1 ) 					#name: #helpButton 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -40 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#labels: #() ) ) ) )</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>resources</category><body package="Store-UI" selector="filesMenu">filesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #filesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #AddFileDots 					#defaultString: 'Add File...' 					#catalogID: #store ) 				#nameKey: #addFile 				#value: #addFile ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RemoveFile 					#defaultString: 'Remove File' 					#catalogID: #store ) 				#nameKey: #removeFile 				#value: #removeFile 				#enablementSelector: #fileIsSelected ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Glorp.UI.GlorpWorkbook</class-id> <category>menus</category><body package="StoreForGlorpVWUI" selector="repositorySubmenu">repositorySubmenu	&lt;submenu: #(#Repository #menus 'Repository')		nameKey: #repositoryMenu		menu: #(#menuBar)		position: 10.03&gt;</body><body package="StoreForGlorpVWUI" selector="toggleLogging">toggleLogging	&lt;menuItem: 'Log SQL' 		nameKey: #sqlLoggingToggle 		enablement: nil 		indication: #isLogging 		menu: #(#menuBar #repositoryMenu) 		position: 30.5&gt;	self logging: self isLogging not.	^self.</body><body package="StoreForGlorpVWUI" selector="toggleLogin">toggleLogin	&lt;menuItem: 'Connected To Repository'		nameKey: #repositoryLogginToggle		enablement: nil		indication: #loggedIn		menu: #(menuBar repositoryMenu)		position: 30.40&gt;	self loggedIn ifTrue: [ self logout ] ifFalse: [ self login ].</body></methods><methods><class-id>Store.Glorp.PundleVersionSelector class</class-id> <category>interface specs</category><body package="Store-Merge Management" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #SelectVersionsToMerge 				#defaultString: 'Select Versions to Merge' 				#catalogID: #store ) 			#min: #(#{Core.Point} 500 200 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 317 512 1280 948 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -2 0.333 -45 1 ) 					#name: #PundleTree 					#model: #pundleList 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #other 					#iconSelectors: #(#toolListIcon ) 					#rootExpander: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.333 25 0 -45 0.666 -45 1 ) 					#name: #VersionList 					#model: #pundleVersions 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 45 0.666 25 0 -10 1 -45 1 ) 					#name: #MergeList 					#model: #mergeList 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.666 50 0 40 0.666 75 0 ) 					#name: #AddButton 					#model: #add 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddRight 						#defaultString: 'Add &gt;' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.666 85 0 40 0.666 110 0 ) 					#name: #RemoveButton 					#model: #remove 					#label: 					#(#{Kernel.UserMessage} 						#key: #RemoveLeft 						#defaultString: '&lt; Remove' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #CancelButton 					#model: #closeRequest 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -180 1 -35 1 -100 1 -10 1 ) 					#name: #AcceptButton 					#flags: 40 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 25 0 0 1 ) 					#name: #pundleTreeLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundlesAndPackages 						#defaultString: 'Bundles and packages:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 2 0.333 25 0 0 1 ) 					#name: #versionListLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsC						#defaultString: 'Versions:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 45 0.666 25 0 0 1 ) 					#name: #mergeListLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #SelectedVersions 						#defaultString: 'Selected versions:' 						#catalogID: #store ) ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreCodeModel class</class-id> <category>tool registration</category><body package="StoreForGlorpBrowserUI" selector="codeComponentToolClass">codeComponentToolClass	&lt;tool: 35&gt;	^StoreCodeComponentPropertiesTool</body><body package="StoreForGlorpBrowserUI" selector="commentToolClass">commentToolClass	&lt;tool: 30&gt;	^StoreBrowserCommentTool</body><body package="StoreForGlorpBrowserUI" selector="compareSourceToolClass">compareSourceToolClass	&lt;tool: 22&gt;	^CompareCodeTool</body><body package="StoreForGlorpBrowserUI" selector="copyrightToolClass">copyrightToolClass	&lt;tool: 36&gt;	^CopyrightNoticeTool</body><body package="StoreForGlorpBrowserUI" selector="definitionToolClass">definitionToolClass	&lt;tool: 40&gt;	^StoreBrowserDefinitionTool</body><body package="StoreForGlorpBrowserUI" selector="overviewToolClass">overviewToolClass	&lt;tool: 1000&gt;	^StoreBrowserOverviewTool</body><body package="StoreForGlorpBrowserUI" selector="sharedVariableToolClass">sharedVariableToolClass	&lt;tool: 10&gt;	^StoreSharedVariableCodeTool</body><body package="StoreForGlorpBrowserUI" selector="sourceToolClass">sourceToolClass	&lt;tool: 20&gt;	^StoreBrowserCodeTool</body></methods><methods><class-id>Store.Glorp.StoreCodeModel class</class-id> <category>status registration</category><body package="StoreForGlorpBrowserUI" selector="basicInfoStatusClass">basicInfoStatusClass	&lt;status: 10&gt;	^SelectionInfoStatus</body><body package="StoreForGlorpBrowserUI" selector="packageStatusClass">packageStatusClass	&lt;status: 20&gt;	^SelectionPackageStatus</body></methods><methods><class-id>Store.FileoutDifferencesDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #FileOutDifferences 				#defaultString: 'File Out Differences' 				#catalogID: #IDE ) 			#bounds: #(#{Graphics.Rectangle} 740 475 940 575 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 50 0 15 0 1 0.5 ) 					#name: #FromLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #FromC 						#defaultString: 'From:' 						#catalogID: #IDE ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 50 0 45 0 1 0.5 ) 					#name: #ToLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ToC 						#defaultString: 'To:' 						#catalogID: #IDE ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -130 1 -40 1 -10 1 -10 1 ) 					#name: #fileoutButton 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #FileOutDots 						#defaultString: 'File Out...' 						#catalogID: #IDE ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -270 1 -40 1 -150 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #IDE ) 					#defaultable: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 1 15 0 -10 1 45 0 ) 					#name: #swapButton 					#flags: 0 					#component: #swapButton ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} 50 0 15 0 0 0.5 ) 					#name: #fromVersionLabel 					#label: #fromVersionLabel 					#style: #default ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} 50 0 45 0 0 0.5 ) 					#name: #toVersionLabel 					#label: #toVersionLabel 					#style: #default ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertyInspector class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="fieldListMenu">fieldListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #fieldListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Dive 					#defaultString: '&amp;Dive' 					#catalogID: #menus ) 				#nameKey: #dive 				#value: #dive ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Back 					#defaultString: '&amp;Back' 					#catalogID: #menus ) 				#nameKey: #back 				#value: #back 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #navigatePrevious ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#nameKey: #editSelectAll 				#value: #selectAllFields 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorIcons} #selectFields ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#nameKey: #copy 				#value: #copySelection 				#enablementSelector: #canCopy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #editCopy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Refresh 					#defaultString: '&amp;Refresh' 					#catalogID: #menus ) 				#nameKey: #refresh 				#value: #refresh ) ) #(3 1 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.SpinnerIcons class</class-id> <category>png imports</category><body package="Store-UI" selector="spin0">spin0	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin0.png'&gt;	&lt;md5sum: #[251 167 206 183 73 100 24 141 251 114 71 219 234 213 150 34]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@70@@@K&lt;@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@E@@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J(@@@C*@@@@: @@@IP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@N(@@@C*@@@@:P@@@CH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@U@@@@EP@@@AT@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@3 @@@N(@@@C*@@@@-0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@D @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AN@@@@: @@@N(@@@C*@@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@U@@@@EP@@@AT@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DT@@@BF@@@@X @@@@ @@@@@@@@@@@@@@@@@@@B1@@@@: @@@N(@@@B)@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@AT@@@@U@@@@D@@@@@@@@@@@@@@@@@@@@@D@@@@T@@@@G @@@@8@@@@@@@@@@@@@@@@@@@@C@@@@20@@@MT@@@CU@@@@/@@@@D\@@@@@@@@@@@@@@B(@@@C_@@@@: @@@GD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@EP@@@AT@@@@H@@@@@@@@@@@@@@@N@@@@IP@@@B(@@@@*@@@@J@@@@@@@@@@@@@@@@@@@@@D@@@B9@@@@5P@@@MT@@@CU@@@@5P@@@JL@@@AS@@@@@@@@@AH@@@@*@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@ @@@@@@@@@H@@@@G0@@@B(@@@@*@@@@J @@@B(@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@BT@@@B*@@@@5@@@@MT@@@CU@@@@5P@@@MT@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@B @@@@*@@@@J @@@B(@@@@*@@@@F0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@) @@@MT@@@CU@@@@5P@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@J @@@B(@@@@*@@@@HP@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@R @@@HH@@@A#@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@G @@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@(@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@0@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@MP@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@P@@@@CT@@@B @@@@0@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@5@@@@P@@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@MP@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@;@@@@^ @@@D&lt;@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@@4@@@@G @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@!P@@@J(@@@B*@@@@* @@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@UP@@@ET@@@AU@@@@P @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@[@@@@J$@@@B*@@@@* @@@J(@@@B#@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@AU@@@@UP@@@ET@@@AU@@@@UP@@@DP@@@@O@@@@@@@@@@@@@@@@@@@@@P@@@H4@@@B*@@@@* @@@J(@@@B*@@@@_0@@@A&lt;@@@@@@@@@C@@@@A,@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@@H@@@@@@@@@BD@@@AA@@@@UP@@@ET@@@AU@@@@UP@@@D(@@@@@@@@@@@@@@@@@@@@B@@@@( @@@J(@@@B*@@@@% @@@C$@@@@@@@@@@@@@@C,@@@BU@@@@%P@@@DX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@Z @@@FT@@@@S@@@@@@@@@@@@@@@\@@@@R0@@@ET@@@AU@@@@TP@@@@D@@@@@@@@@@@@@@@@@@@@7@@@@^ @@@ED@@@@F@@@@@@@@@@@@@@@@@@@@\0@@@IT@@@BU@@@@W@@@@@@@@@@R@@@@Z0@@@F,@@@@R@@@@@@@@@D0@@@A*@@@@Z @@@E@@@@@@@@@@@@@@@@@@@@@C@@@@I0@@@CT@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CH@@@BU@@@@%P@@@IT@@@@6@@@@@@@@@D @@@B@@@@@ @@@@D @@@@@@@@@I @@@F(@@@A*@@@@Z @@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@ 0@@@IT@@@BU@@@@]@@@@@D@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@@@@@@T0@@@F(@@@A*@@@@WP@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DP@@@BU@@@@%P@@@IP@@@@ @@@@@@@@@@@@@@AK@@@@ @@@@H@@@@AK@@@@@@@@@@@@@@@W@@@@Z @@@F(@@@A*@@@@L0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W @@@IT@@@BU@@@@]P@@@@@@@@@@@@@@@@@@@D,@@@B@@@@@ @@@@D,@@@@@@@@@@@@@@@@@@@AC@@@@Z @@@F(@@@AM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@# @@@H@@@@@Z@@@@@@@@@@@@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@@@@@@@@@@@@(@@@AV@@@@YP@@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@A+@@@@Z0@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin1">spin1	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin1.png'&gt;	&lt;md5sum: #[209 78 166 28 104 234 241 108 35 124 73 233 218 65 106 74]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@3 @@@L8@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@H(@@@C5@@@@=P@@@H(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@5P@@@K\@@@@V@@@@@@@@@@@@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@@@@@@@@@@@@H@@@@I@@@@B @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@JL@@@C @@@@8@@@@H4@@@@@@@@@@@@@@@@@@@BP@@@@=P@@@OT@@@BP@@@@@@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z0@@@N@@@@C @@@@70@@@C@@@@@@@@@@@@@@@I@@@@C5@@@@=P@@@I@@@@@@@@@@@@@@@@H@@@@J@@@@B @@@@(@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@1P@@@N@@@@C @@@@+0@@@@D@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@8@@@@N@@@@C @@@@TP@@@@@@@@BJ@@@@=P@@@OT@@@BJ@@@@@@@@@@P@@@@J@@@@B @@@@(@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DH@@@A?@@@@WP@@@@\@@@@@@@@@@@@@@@@@@@B*@@@@8@@@@N@@@@B"@@@@@@@@@BH@@@CN@@@@3 @@@BH@@@@@@@@@A @@@@(@@@@J@@@@B@@@@@@@@@@@@@@@@@@@@@D@@@@O@@@@E0@@@@(@@@@@@@@@@@@@@@@@@@@B@@@@0@@@@L(@@@CJ@@@@, @@@DL@@@@@@@@@@@@@@B @@@CU@@@@8@@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B @@@@(@@@@D@@@@@@@@@@@@@@@K@@@@G@@@@B@@@@@ @@@@G @@@@@@@@@@@@@@@@@@@@D@@@B/@@@@2 @@@L(@@@CJ@@@@2 @@@I(@@@AN@@@@@@@@@AH@@@@(@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@F@@@@F@@@@B@@@@@ @@@@H@@@@B@@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@B!@@@@2P@@@L(@@@CJ@@@@2 @@@L(@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@A&lt;@@@@ @@@@H@@@@B@@@@@ @@@@E@@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@'' @@@L(@@@CJ@@@@2 @@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@H@@@@B@@@@@ @@@@FP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@Q0@@@G0@@@A^@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@E0@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@% @@@KT@@@B5@@@@-P@@@KT@@@B5@@@@-P@@@IX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@MP@@@B0@@@BV@@@@-P@@@KT@@@B5@@@@-P@@@KT@@@B5@@@@% @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@MP@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@K@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@8@@@@\0@@@D,@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@@-@@@@F @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@_P@@@J@@@@B @@@@(@@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@R @@@D(@@@AJ@@@@N @@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@Y @@@I&lt;@@@B @@@@(@@@@J@@@@BY@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@AJ@@@@R @@@D(@@@AJ@@@@R @@@C,@@@@M@@@@@@@@@@@@@@@@@@@@@P@@@HP@@@B @@@@(@@@@J@@@@B @@@@^@@@@A4@@@@@@@@@B0@@@A$@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@H@@@@@@@@@A4@@@@9@@@@R @@@D(@@@AJ@@@@R @@@D@@@@@@@@@@@@@@@@@@@@@B@@@@&amp;@@@@J@@@@B @@@@#P@@@CT@@@@@@@@@@@@@@C\@@@BJ@@@@" @@@DD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.@@@@X@@@@E,@@@@Q@@@@@@@@@@@@@@@Y@@@@PP@@@D(@@@AJ@@@@Q0@@@@D@@@@@@@@@@@@@@@@@@@@4@@@@\0@@@D0@@@@F@@@@@@@@@@@@@@@@@@@@Z0@@@H(@@@BJ@@@@UP@@@@@@@@@P@@@@X @@@FH@@@@P@@@@@@@@@DT@@@A @@@@X@@@@D$@@@@@@@@@@@@@@@@@@@@C@@@@H @@@B8@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@BJ@@@@" @@@H(@@@@2@@@@@@@@@DH@@@A5@@@@]P@@@DH@@@@@@@@@H0@@@F@@@@A @@@@X@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@^P@@@H(@@@BJ@@@@[@@@@@D@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@@@@@@R0@@@F@@@@A @@@@U@@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C&lt;@@@BJ@@@@" @@@H$@@@@^@@@@@@@@@@@@@@AE@@@@]P@@@GT@@@AE@@@@@@@@@@@@@@@U@@@@X@@@@F@@@@A @@@@K @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U0@@@H(@@@BJ@@@@[@@@@@@@@@@@@@@@@@@@@DT@@@A5@@@@]P@@@DT@@@@@@@@@@@@@@@@@@@@=@@@@X@@@@F@@@@AF@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@!@@@@G\@@@@X@@@@@@@@@@@@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@@@@@@@@@@@@$@@@AN@@@@V0@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AB@@@@]P@@@GT@@@AB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@A"@@@@X @@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin10">spin10	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin10.png'&gt;	&lt;md5sum: #[14 197 143 98 164 122 205 164 119 174 215 200 121 130 144 227]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@_P@@@G4@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@EP@@@BU@@@@%P@@@EP@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@^ @@@F @@@@M@@@@@@@@@@@@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@@@@@@@@@@@A8@@@BR@@@@( @@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E4@@@B@@@@@ @@@@ED@@@@@@@@@@@@@@@@@@@AX@@@@%P@@@IT@@@AX@@@@@@@@@@@@@@@@@@@@!P@@@J(@@@B*@@@@Z0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@OP@@@H@@@@B@@@@@_0@@@A0@@@@@@@@@@@@@@E @@@BU@@@@%P@@@E @@@@@@@@@@@@@@BT@@@B)@@@@* @@@J(@@@AN@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@\@@@@H@@@@B@@@@@Y@@@@@D@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@A@@@@!P@@@J(@@@B*@@@@%P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@ @@@@H@@@@B@@@@@K @@@@@@@@AT@@@@%P@@@IT@@@AT@@@@@@@@@C4@@@B*@@@@* @@@J(@@@@9@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@AC@@@@LP@@@@P@@@@@@@@@@@@@@@@@@@A!@@@@ @@@@H@@@@A\@@@@@@@@@AP@@@A=@@@@_P@@@AP@@@@@@@@@ZP@@@J(@@@B*@@@@ 0@@@@@@@@@@@@@@@@@@@@\@@@A[@@@@" @@@C8@@@@@@@@@@@@@@@@@@@@A@@@@YP@@@F(@@@A*@@@@W @@@BL@@@@@@@@@@@@@@A\@@@A:@@@@ @@@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@* @@@J(@@@AC@@@@@@@@@@@@@@A@@@@@*P@@@L@@@@C@@@@@-0@@@@H@@@@@@@@@@@@@@@@@@@A\@@@@Z @@@F(@@@A*@@@@Z @@@ED@@@@)@@@@@@@@@@(@@@@W@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@_@@@@CP@@@@@@@@@#@@@@$@@@@L@@@@C@@@@@0@@@@L@@@@B_@@@@@P@@@@@@@@@@@@@@@@@@@AH@@@AT@@@@Z @@@F(@@@A*@@@@Z @@@F(@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@K @@@C@@@@@0@@@@L@@@@B?@@@@^ @@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@T0@@@F(@@@A*@@@@Z @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@0@@@@L@@@@C@@@@@% @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IP@@@DD@@@@1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AZ@@@@" @@@DL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@Q0@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@UP@@@D\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@5P@@@KD@@@AG@@@@UP@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@Q0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B1@@@@5P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@,P@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@K @@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@F4@@@BO@@@@T @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@L @@@D@@@@A@@@@@P@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@: @@@N(@@@C*@@@@-0@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@JP@@@D@@@@A@@@@@P@@@@D@@@@@=@@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@C*@@@@: @@@N(@@@C*@@@@:P@@@K(@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@CT@@@A@@@@@P@@@@D@@@@A@@@@@L@@@@@0@@@@@@@@@@0@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E,@@@B3@@@@: @@@N(@@@C*@@@@: @@@L,@@@@A@@@@@@@@@@@@@@@A@@@@OP@@@D@@@@A@@@@@N@@@@AT@@@@@@@@@@@@@@AD@@@@*@@@@J @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AN@@@@3 @@@N(@@@C*@@@@70@@@@L@@@@@@@@@@@@@@@@@@@@U@@@@K @@@A8@@@@B@@@@@@@@@@@@@@@@@@@@H@@@@B(@@@@*@@@@F @@@@@@@@@C@@@@D @@@AH@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@Z0@@@IL@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@@*@@@@J @@@B(@@@@O@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@IP@@@B(@@@@*@@@@HP@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@@*@@@@J @@@B(@@@@I@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@B(@@@@*@@@@HP@@@@@@@@@@@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@J@@@@BP@@@@G@@@@@@@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@R@@@@D @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin11">spin11	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin11.png'&gt;	&lt;md5sum: #[38 34 45 172 120 27 226 42 200 101 235 154 172 98 84 217]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@]@@@@GP@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D8@@@BJ@@@@" @@@D8@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@[0@@@E&lt;@@@@K@@@@@@@@@@@@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@@@@@@@@@@@A0@@@BI@@@@&amp;@@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ET@@@A5@@@@]P@@@D(@@@@@@@@@@@@@@@@@@@AQ@@@@" @@@H(@@@AQ@@@@@@@@@@@@@@@@@@@@_P@@@J@@@@B @@@@YP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@GT@@@A5@@@@]P@@@A$@@@@@@@@@@@@@@ED@@@BJ@@@@" @@@ED@@@@@@@@@@@@@@BL@@@B_@@@@(@@@@J@@@@AI@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@Y0@@@GT@@@A5@@@@V0@@@@@@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@A@@@@_P@@@J@@@@B @@@@#P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@''@@@@]P@@@GT@@@A5@@@@J @@@@@@@@AN@@@@" @@@H(@@@AN@@@@@@@@@C(@@@B @@@@(@@@@J@@@@@5@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@@&lt;@@@@K@@@@@L@@@@@@@@@@@@@@@@@@@AY@@@@]P@@@GT@@@AT@@@@@@@@@AL@@@A4@@@@]@@@@AL@@@@@@@@@X0@@@J@@@@B @@@@_@@@@@@@@@@@@@@@@@@@@@X@@@AV@@@@  @@@C,@@@@@@@@@@@@@@@@@@@@A@@@@V0@@@F@@@@A @@@@UP@@@B@@@@@@@@@@@@@@@AT@@@A/@@@@]P@@@C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@(@@@@J@@@@@?@@@@@@@@@@@@@@@&lt;@@@@(@@@@KT@@@B5@@@@+@@@@@H@@@@@@@@@@@@@@@@@@@AS@@@@X@@@@F@@@@A @@@@X@@@@D$@@@@%@@@@@@@@@@$@@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@]@@@@CP@@@@@@@@@!@@@@"@@@@KT@@@B5@@@@-P@@@KT@@@BV@@@@@P@@@@@@@@@@@@@@@@@@@AD@@@AL@@@@X@@@@F@@@@A @@@@X@@@@F@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C @@@J4@@@B5@@@@-P@@@KT@@@B4@@@@\0@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@R0@@@F@@@@A @@@@X@@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@-P@@@KT@@@B5@@@@#P@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H @@@C,@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AT@@@@  @@@C&lt;@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@O @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@R @@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@2 @@@J @@@@&gt;@@@@R @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@O @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@@2 @@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@*@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@I @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@F$@@@BI@@@@S @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@JP@@@CT@@@@5@@@@MP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@8@@@@N@@@@C @@@@+0@@@CD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@H @@@CT@@@@5@@@@MP@@@CT@@@@3@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@C @@@@8@@@@N@@@@C @@@@70@@@KH@@@@''@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@@5@@@@MP@@@CT@@@@5@@@@J@@@@@(@@@@@@@@@@0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@B0@@@@S@@@@@@@@@E\@@@B+@@@@8@@@@N@@@@C @@@@8@@@@LH@@@@A@@@@@@@@@@@@@@@A@@@@L0@@@CT@@@@5@@@@K0@@@AH@@@@@@@@@@@@@@@4@@@@ @@@@H@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A6@@@@=P@@@N$@@@@,@@@@@@@@@@@@@@AK@@@@1 @@@N@@@@C @@@@5P@@@@L@@@@@@@@@@@@@@@@@@@@Q@@@@I @@@A$@@@@B@@@@@@@@@@@@@@@@@@@@FP@@@B@@@@@ @@@@E@@@@@@@@@@A@@@@B@@@@@ @@@@A@@@@@@@@@KD@@@C5@@@@=P@@@K$@@@@@@@@@@@@@@@@@@@@H@@@@Y0@@@H4@@@AI@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@ @@@@H@@@@B@@@@@L@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@V@@@@OT@@@C5@@@@=P@@@EH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@G@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@A@@@@/0@@@OT@@@C5@@@@50@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@ @@@@H@@@@B@@@@@G@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@@@@@@5@@@@=@@@@OT@@@C5@@@@]P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@@@@@B[@@@@=P@@@OT@@@B2@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@G @@@A,@@@@F@@@@@@@@@@@@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@@@@@@@@@@@A @@@CH@@@@:P@@@D&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@H@@@@B@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin12">spin12	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin12.png'&gt;	&lt;md5sum: #[85 180 205 0 151 63 94 162 112 206 53 192 106 180 62 74]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@Z0@@@F,@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@B@@@@@ @@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@YP@@@EX@@@@J@@@@@@@@@@@@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@@@@@@@@@@@A(@@@B@@@@@# @@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D4@@@A*@@@@Z @@@DL@@@@@@@@@@@@@@@@@@@AK@@@@ @@@@H@@@@AK@@@@@@@@@@@@@@@@@@@@]P@@@IT@@@BU@@@@W @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L0@@@F(@@@A*@@@@Z @@@A\@@@@@@@@@@@@@@D,@@@B@@@@@ @@@@D,@@@@@@@@@@@@@@B@@@@BT@@@@%P@@@IT@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@WP@@@F(@@@A*@@@@T0@@@@@@@@@@@@@@R0@@@H@@@@B@@@@@R0@@@@@@@@@A@@@@]@@@@IT@@@BU@@@@ 0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@Z @@@F(@@@A*@@@@I @@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@CX@@@BU@@@@%P@@@IT@@@@2@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@@5@@@@I0@@@@L@@@@@@@@@@@@@@@@@@@AP@@@@Z @@@F(@@@AL@@@@@@@@@AH@@@A+@@@@Z0@@@AH@@@@@@@@@W@@@@IT@@@BU@@@@\0@@@@@@@@@@@@@@@@@@@@X@@@AQ@@@@^ @@@C\@@@@@@@@@@@@@@@@@@@@A@@@@TP@@@ET@@@AU@@@@R0@@@A0@@@@@@@@@@@@@@AL@@@A%@@@@Z @@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AF@@@@%P@@@IT@@@@;@@@@@@@@@@@@@@@9@@@@% @@@J(@@@B*@@@@( @@@@H@@@@@@@@@@@@@@@@@@@AJ@@@@UP@@@ET@@@AU@@@@UP@@@DD@@@@!@@@@@@@@@@ @@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@[@@@@C@@@@@@@@@@_@@@@_0@@@J(@@@B*@@@@* @@@J(@@@BM@@@@@P@@@@@@@@@@@@@@@@@@@@&lt;@@@AD@@@@UP@@@ET@@@AU@@@@UP@@@ET@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@JL@@@B*@@@@* @@@J(@@@B)@@@@[@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@P @@@ET@@@AU@@@@UP@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@* @@@J(@@@B*@@@@!P@@@BT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G @@@CP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AO@@@@^ @@@C,@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@MP@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@P@@@@CT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@0@@@@J@@@@@5@@@@P@@@@D@@@@A@@@@@P@@@@D@@@@A@@@@@MP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@@0@@@@L@@@@C@@@@@0@@@@L@@@@C@@@@@(@@@@@$@@@@%@@@@I @@@BX@@@@&amp;@@@@I @@@BT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@A.@@@@\0@@@GL@@@A3@@@@\0@@@F8@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@G @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@FL@@@BB@@@@R @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@HP@@@B(@@@@*@@@@J @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@5P@@@MT@@@CU@@@@) @@@B&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F0@@@B(@@@@*@@@@J @@@B(@@@@(@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@CU@@@@5P@@@MT@@@CU@@@@5@@@@J(@@@@%@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@@*@@@@J @@@B(@@@@*@@@@G0@@@@ @@@@@@@@@@ @@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@B(@@@@R@@@@@@@@@EL@@@B#@@@@5P@@@MT@@@CU@@@@5P@@@K$@@@@A@@@@@@@@@@@@@@@@@@@@J@@@@B(@@@@*@@@@IP@@@@8@@@@@@@@@@@@@@@ @@@@U@@@@EP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A1@@@@: @@@M&lt;@@@@*@@@@@@@@@@@@@@AG@@@@/@@@@MT@@@CU@@@@20@@@@L@@@@@@@@@@@@@@@@@@@@N@@@@G @@@AP@@@@A@@@@@@@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@CP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J$@@@C*@@@@: @@@KD@@@@@@@@@@@@@@@@@@@@H@@@@X @@@HX@@@AE@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@U@@@@EP@@@AT@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@N(@@@C*@@@@: @@@D8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@D @@@AT@@@@U@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@-0@@@N(@@@C*@@@@3 @@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@U@@@@EP@@@AT@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@:P@@@N(@@@C*@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@AT@@@@U@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BT@@@@: @@@N(@@@B*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@E@@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@B?@@@@70@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin13">spin13	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin13.png'&gt;	&lt;md5sum: #[37 40 97 228 75 230 232 174 138 98 75 45 193 181 186 159]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@X @@@FH@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DH@@@A5@@@@]P@@@DH@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@V0@@@D8@@@@I@@@@@@@@@@@@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@@@@@@@@@@@A @@@A7@@@@!@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DX@@@A @@@@X@@@@C4@@@@@@@@@@@@@@@@@@@AE@@@@]P@@@GT@@@AE@@@@@@@@@@@@@@@@@@@@[@@@@H(@@@BJ@@@@U0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K @@@F@@@@A @@@@X@@@@AT@@@@@@@@@@@@@@DT@@@A5@@@@]P@@@DT@@@@@@@@@@@@@@A8@@@BI@@@@" @@@H(@@@@?@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@U@@@@F@@@@A @@@@R0@@@@@@@@@@@@@@QP@@@GT@@@A5@@@@QP@@@@@@@@@A@@@@[@@@@H(@@@BJ@@@@^P@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@X@@@@F@@@@A @@@@H0@@@@@@@@AB@@@@]P@@@GT@@@AB@@@@@@@@@CH@@@BJ@@@@" @@@H(@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@.@@@@H @@@@L@@@@@@@@@@@@@@@@@@@AI@@@@X@@@@F@@@@AE@@@@@@@@@A@@@@A"@@@@X @@@A@@@@@@@@@@UP@@@H(@@@BJ@@@@Z0@@@@@@@@@@@@@@@@@@@@X@@@AL@@@@\0@@@CP@@@@@@@@@@@@@@@@@@@@A@@@@Q0@@@D(@@@AJ@@@@PP@@@A$@@@@@@@@@@@@@@AD@@@A[@@@@X@@@@B8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AA@@@@" @@@H(@@@@7@@@@@@@@@@@@@@@5@@@@#P@@@J@@@@B @@@@&amp;@@@@@H@@@@@@@@@@@@@@@@@@@A@@@@@R @@@D(@@@AJ@@@@R @@@C$@@@@]@@@@@@@@@@ @@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@Y@@@@B0@@@@@@@@@]@@@@^@@@@J@@@@B @@@@(@@@@J@@@@BD@@@@@P@@@@@@@@@@@@@@@@@@@@4@@@@;@@@@R @@@D(@@@AJ@@@@R @@@D(@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@I$@@@B @@@@(@@@@J@@@@B_@@@@Y @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@N @@@D(@@@AJ@@@@R @@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]@@@@(@@@@J@@@@B @@@@_P@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F @@@B4@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AK@@@@\0@@@C @@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@K@@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@MP@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@% @@@KT@@@B5@@@@-P@@@KT@@@B5@@@@-P@@@IX@@@@,@@@@MP@@@CT@@@@5@@@@MP@@@CT@@@@5@@@@K@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BV@@@@-P@@@KT@@@B5@@@@-P@@@KT@@@B5@@@@% @@@@\@@@@^@@@@H@@@@B@@@@@ @@@@H@@@@A8@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@A(@@@@[P@@@F4@@@A-@@@@[P@@@F @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@E0@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@E8@@@A&lt;@@@@Q0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@FP@@@B@@@@@ @@@@H@@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@2 @@@L(@@@CJ@@@@'' @@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@E@@@@B@@@@@ @@@@H@@@@B@@@@@_@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@CJ@@@@2 @@@L(@@@CJ@@@@2P@@@JD@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@@ @@@@H@@@@B@@@@@ @@@@F@@@@@X@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@B @@@@R@@@@@@@@@D8@@@BZ@@@@2 @@@L(@@@CJ@@@@2 @@@J&lt;@@@@A@@@@@@@@@@@@@@@@@@@@G @@@B@@@@@ @@@@G@@@@@,@@@@@@@@@@@@@@@P@@@@J@@@@B @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A,@@@@8@@@@MT@@@@(@@@@@@@@@@@@@@AC@@@@, @@@L(@@@CJ@@@@0@@@@@H@@@@@@@@@@@@@@@@@@@@J@@@@E0@@@@&lt;@@@@A@@@@@@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@A @@@@@@@@@"@@@@3 @@@L8@@@@"@@@@@@@@@JH@@@C @@@@8@@@@J(@@@@@@@@@@@@@@@@@@@@G@@@@WP@@@G&lt;@@@AB@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@J@@@@B @@@@(@@@@D@@@@@@@@@H(@@@C5@@@@=P@@@H(@@@@@@@@@TP@@@N@@@@C @@@@8@@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@@(@@@@J@@@@B@@@@@@@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@A@@@@+0@@@N@@@@C @@@@1P@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@J@@@@B @@@@(@@@@B@@@@@@@@@@@@@@BP@@@@=P@@@OT@@@BP@@@@@@@@@@@@@@@0@@@@70@@@N@@@@C @@@@Z0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@(@@@@J@@@@B@@@@@@@@@@@@@@@@@@@@I@@@@C5@@@@=P@@@I@@@@@@@@@@@@@@@@@@@@BM@@@@8@@@@N@@@@B#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@B @@@@$@@@@B@@@@@@@@@@@@@@@@@@@@$@@@@OT@@@C5@@@@$@@@@@@@@@@@@@@@@@@@@AX@@@B7@@@@5P@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BJ@@@@=P@@@OT@@@BJ@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@CN@@@@3 @@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin14">spin14	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin14.png'&gt;	&lt;md5sum: #[129 51 45 77 244 69 122 38 78 137 147 179 53 225 37 112]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@VP@@@E$@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@A*@@@@Z @@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@TP@@@DT@@@@H@@@@@@@@@@@@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@@@@@@@@@@@A\@@@A.@@@@^ @@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C8@@@AU@@@@UP@@@CX@@@@@@@@@@@@@@@@@@@@&gt;@@@@Z @@@F(@@@@&gt;@@@@@@@@@@@@@@@@@@@@Y@@@@H@@@@B@@@@@TP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@JP@@@ET@@@AU@@@@UP@@@AH@@@@@@@@@@@@@@C8@@@A*@@@@Z @@@C8@@@@@@@@@@@@@@A0@@@A?@@@@ @@@@H@@@@@;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@R0@@@ET@@@AU@@@@P @@@@@@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@A@@@@Y@@@@H@@@@B@@@@@\@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@UP@@@ET@@@AU@@@@G0@@@@@@@@@&lt;@@@@Z @@@F(@@@@&lt;@@@@@@@@@B8@@@B@@@@@ @@@@H@@@@@+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AT@@@@(@@@@GP@@@@H@@@@@@@@@@@@@@@@@@@A@@@@@UP@@@ET@@@@=@@@@@@@@@@&lt;@@@AY@@@@VP@@@@&lt;@@@@@@@@@S0@@@H@@@@B@@@@@X0@@@@@@@@@@@@@@@@@@@@T@@@AG@@@@Z0@@@C@@@@@@@@@@@@@@@@@@@@@A@@@@OP@@@D@@@@A@@@@@N@@@@AT@@@@@@@@@@@@@@@&lt;@@@AQ@@@@UP@@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@ @@@@H@@@@@3@@@@@@@@@@@@@@@2@@@@ 0@@@IT@@@BU@@@@# @@@@H@@@@@@@@@@@@@@@@@@@@7@@@@P@@@@D@@@@A@@@@@P@@@@CD@@@@Y@@@@@@@@@@\@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@W@@@@B @@@@@@@@@[@@@@\@@@@IT@@@BU@@@@%P@@@IT@@@A;@@@@@P@@@@@@@@@@@@@@@@@@@@,@@@@3@@@@P@@@@D@@@@A@@@@@P@@@@D@@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@H&lt;@@@BU@@@@%P@@@IT@@@BT@@@@W0@@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@L @@@D@@@@A@@@@@P@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@%P@@@IT@@@BU@@@@]@@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E @@@B\@@@@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AF@@@@Z0@@@CP@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@H0@@@B(@@@@*@@@@J @@@B(@@@@*@@@@J @@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#P@@@J(@@@B*@@@@* @@@J(@@@B*@@@@* @@@H4@@@@#@@@@J @@@B(@@@@*@@@@J @@@B(@@@@*@@@@H0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BM@@@@* @@@J(@@@B*@@@@* @@@J(@@@B*@@@@#P@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@C0@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@E(@@@A5@@@@P0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@D@@@@AT@@@@U@@@@EP@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@0@@@@L@@@@C@@@@@% @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@CP@@@AT@@@@U@@@@EP@@@AT@@@@T@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@C@@@@@0@@@@L@@@@C@@@@@/0@@@I$@@@@!@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@U@@@@EP@@@AT@@@@U@@@@D@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BX@@@@Q@@@@@@@@@D,@@@BS@@@@0@@@@L@@@@C@@@@@0@@@@JX@@@@A@@@@@@@@@@@@@@@@@@@@E@@@@AT@@@@U@@@@D0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A''@@@@5P@@@L,@@@@&amp;@@@@@@@@@@@@@@A@@@@@*P@@@L@@@@C@@@@@-0@@@@H@@@@@@@@@@@@@@@@@@@@G@@@@C0@@@@(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@1@@@@LP@@@@ @@@@@@@@@I(@@@CU@@@@5P@@@JD@@@@@@@@@@@@@@@@@@@@G@@@@V@@@@G @@@@&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@HP@@@C*@@@@: @@@HP@@@@@@@@@SP@@@MT@@@CU@@@@5P@@@D\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@A@@@@) @@@MT@@@CU@@@@.0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BJ@@@@: @@@N(@@@BJ@@@@@@@@@@@@@@@.@@@@5@@@@MT@@@CU@@@@Y @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H(@@@C*@@@@: @@@H(@@@@@@@@@@@@@@@@@@@BF@@@@5P@@@MT@@@B[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@@@@@@@@@@@AT@@@B.@@@@20@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BD@@@@: @@@N(@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@CD@@@@1@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin15">spin15	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin15.png'&gt;	&lt;md5sum: #[79 53 36 133 236 34 208 76 154 176 34 90 112 215 135 20]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@TP@@@ED@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CX@@@A @@@@X@@@@CX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@Q0@@@C0@@@@G@@@@@@@@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@@@@@@AT@@@A$@@@@[0@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CX@@@AJ@@@@R @@@B&lt;@@@@@@@@@@@@@@@@@@@@8@@@@X@@@@F@@@@@8@@@@@@@@@@@@@@@@@@@@W@@@@GT@@@A5@@@@R @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H0@@@D(@@@AJ@@@@R @@@A@@@@@@@@@@@@@@@C @@@A @@@@X@@@@C @@@@@@@@@@@@@@A$@@@A5@@@@]P@@@GT@@@@6@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@PP@@@D(@@@AJ@@@@N @@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@V0@@@GT@@@A5@@@@Y0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@R @@@D(@@@AJ@@@@F0@@@@@@@@@6@@@@X@@@@F@@@@@6@@@@@@@@@B(@@@A5@@@@]P@@@GT@@@@''@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@!@@@@F@@@@@H@@@@@@@@@@@@@@@@@@@@8@@@@R @@@D(@@@@5@@@@@@@@@@4@@@AQ@@@@TP@@@@4@@@@@@@@@R@@@@GT@@@A5@@@@V @@@@@@@@@@@@@@@@@@@@T@@@AA@@@@X0@@@B4@@@@@@@@@@@@@@@@@@@@A@@@@L0@@@CT@@@@5@@@@K0@@@AH@@@@@@@@@@@@@@@4@@@AG@@@@R @@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@]P@@@GT@@@@.@@@@@@@@@@@@@@@.@@@@^ @@@H(@@@BJ@@@@!@@@@@H@@@@@@@@@@@@@@@@@@@@.@@@@MP@@@CT@@@@5@@@@MP@@@B$@@@@U@@@@@@@@@@X@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@BP@@@@@@@@@Y@@@@Y0@@@H(@@@BJ@@@@" @@@H(@@@A2@@@@@P@@@@@@@@@@@@@@@@@@@@$@@@@*@@@@MP@@@CT@@@@5@@@@MP@@@CT@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@HP@@@BJ@@@@" @@@H(@@@BI@@@@V@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@JP@@@CT@@@@5@@@@MP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@" @@@H(@@@BJ@@@@[@@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@B@@@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A@@@@@X0@@@C@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@F0@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!P@@@J@@@@B @@@@(@@@@J@@@@B @@@@(@@@@HT@@@@[@@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BE@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@!P@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@A0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@EP@@@A/@@@@O0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B@@@@@(@@@@J@@@@B @@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@-P@@@KT@@@B5@@@@#P@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@A @@@@(@@@@J@@@@B @@@@(@@@@J@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@B5@@@@-P@@@KT@@@B5@@@@-@@@@I@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@J@@@@B @@@@(@@@@J@@@@A0@@@@H@@@@@@@@@D0@@@B0@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BP@@@@P@@@@@@@@@DX@@@BJ@@@@-P@@@KT@@@B5@@@@-P@@@I4@@@@A@@@@@@@@@@@@@@@@@@@@B @@@@(@@@@J@@@@BP@@@@L@@@@@@@@@@@@@@FD@@@C5@@@@=P@@@GL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A!@@@@2 @@@L@@@@@$@@@@@@@@@@@@@@@&lt;@@@@(@@@@KT@@@B5@@@@+@@@@@H@@@@@@@@@@@@@@@@@@@@C@@@@A0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@/P@@@OT@@@C5@@@@%0@@@@@@@@@_@@@@/@@@@K0@@@@_@@@@@@@@@IH@@@CJ@@@@2 @@@I$@@@@@@@@@@@@@@@@@@@@F@@@@T0@@@GH@@@@;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@EH@@@C5@@@@=P@@@OT@@@AX@@@@@@@@@G8@@@C @@@@8@@@@G8@@@@@@@@@RP@@@L(@@@CJ@@@@2 @@@DL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@50@@@OT@@@C5@@@@/0@@@@D@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@A@@@@'' @@@L(@@@CJ@@@@,P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@C5@@@@=P@@@OP@@@@5@@@@@@@@@@@@@@BD@@@@8@@@@N@@@@BD@@@@@@@@@@@@@@@,@@@@2P@@@L(@@@CJ@@@@XP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;0@@@OT@@@C5@@@@0@@@@@@@@@@@@@@@@@@@@HP@@@C @@@@8@@@@HP@@@@@@@@@@@@@@@@@@@B@@@@@2 @@@L(@@@BS@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AO@@@@:P@@@MH@@@@+@@@@@@@@@@@@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@@@@@@@@@@@AP@@@B%@@@@0@@@@DD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A&gt;@@@@8@@@@N@@@@A&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B&lt;@@@@/@@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin16">spin16	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin16.png'&gt;	&lt;md5sum: #[148 244 129 6 148 220 182 105 17 165 171 84 229 113 165 109]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@Q0@@@D\@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@AU@@@@UP@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@OP@@@CP@@@@F@@@@@@@@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@@@@@@AL@@@A[@@@@YP@@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B8@@@A@@@@@P@@@@B @@@@@@@@@@@@@@@@@@@@2@@@@UP@@@ET@@@@2@@@@@@@@@@@@@@@@@@@@T0@@@F(@@@A*@@@@P0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G0@@@D@@@@A@@@@@P@@@@@8@@@@@@@@@@@@@@CH@@@AU@@@@UP@@@CH@@@@@@@@@@@@@@A\@@@A*@@@@Z @@@F(@@@@1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@N@@@@D@@@@A@@@@@L @@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@T0@@@F(@@@A*@@@@WP@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@P@@@@D@@@@A@@@@@E0@@@@@@@@@0@@@@UP@@@ET@@@@0@@@@@@@@@BX@@@A*@@@@Z @@@F(@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@@Z@@@@D0@@@@D@@@@@@@@@@@@@@@@@@@@0@@@@P@@@@D@@@@@.@@@@@@@@@@0@@@AG@@@@Q0@@@@0@@@@@@@@@PP@@@F(@@@A*@@@@T @@@@@@@@@@@@@@@@@@@@T@@@@=@@@@W@@@@B(@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@B(@@@@*@@@@IP@@@@8@@@@@@@@@@@@@@@0@@@@=@@@@P@@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@Z @@@F(@@@@*@@@@@@@@@@@@@@@+@@@@\P@@@H@@@@B@@@@@^ @@@@H@@@@@@@@@@@@@@@@@@@@$@@@@J @@@B(@@@@*@@@@J @@@B@@@@@P@@@@@@@@@@T@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@B@@@@@@@@@@X@@@@X@@@@H@@@@B@@@@@ @@@@H@@@@A*@@@@@P@@@@@@@@@@@@@@@@@@@@\@@@@!@@@@J @@@B(@@@@*@@@@J @@@B(@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@G(@@@B@@@@@ @@@@H@@@@A?@@@@TP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@HP@@@B(@@@@*@@@@J @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@ @@@@H@@@@B@@@@@Y@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@A(@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@&lt;@@@@W@@@@B4@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@DP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@EP@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@%P@@@G0@@@@Q@@@@EP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@@%P@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@_@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@D&lt;@@@A(@@@@N0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@* @@@J(@@@B*@@@@!P@@@BT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@B*@@@@* @@@J(@@@B*@@@@*P@@@H\@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@B(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BL@@@@O@@@@@@@@@DH@@@BB@@@@* @@@J(@@@B*@@@@* @@@IL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E4@@@C*@@@@: @@@F8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A]@@@@0@@@@K\@@@@#@@@@@@@@@@@@@@@9@@@@% @@@J(@@@B*@@@@( @@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-P@@@N(@@@C*@@@@$@@@@@@@@@@]@@@@,0@@@KL@@@@]@@@@@@@@@H,@@@C@@@@@0@@@@ID@@@@@@@@@@@@@@@@@@@@F@@@@S @@@F,@@@@7@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D8@@@C*@@@@: @@@N(@@@AT@@@@@@@@@G @@@CU@@@@5P@@@G @@@@@@@@@QP@@@L@@@@C@@@@@0@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@3 @@@N(@@@C*@@@@-0@@@@D@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@A@@@@% @@@L@@@@C@@@@@*P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F,@@@C*@@@@: @@@N$@@@@2@@@@@@@@@@@@@@A=@@@@5P@@@MT@@@A=@@@@@@@@@@@@@@@)@@@@/0@@@L@@@@C@@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@N(@@@C*@@@@.@@@@@@@@@@@@@@@@@@@@G4@@@CU@@@@5P@@@G4@@@@@@@@@@@@@@@@@@@A9@@@@0@@@@L@@@@BK@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AK@@@@70@@@L$@@@@)@@@@@@@@@@@@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@@@@@@@@@@@AL@@@B]@@@@-0@@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@5P@@@MT@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@B3@@@@,0@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin17">spin17	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin17.png'&gt;	&lt;md5sum: #[77 140 38 6 0 173 144 31 134 135 36 157 10 187 155 197]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@O @@@C8@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@AJ@@@@R @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@L0@@@B,@@@@E@@@@@@@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@@@@@@AD@@@AR@@@@V0@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BX@@@@5@@@@MP@@@BD@@@@@@@@@@@@@@@@@@@@,@@@@R @@@D(@@@@,@@@@@@@@@@@@@@@@@@@@R0@@@F@@@@A @@@@OP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@FP@@@CT@@@@5@@@@MP@@@@,@@@@@@@@@@@@@@B0@@@AJ@@@@R @@@B0@@@@@@@@@@@@@@AT@@@A @@@@X@@@@F@@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@K0@@@CT@@@@5@@@@JP@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@R0@@@F@@@@A @@@@U@@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@MP@@@CT@@@@5@@@@D0@@@@@@@@@*@@@@R @@@D(@@@@*@@@@@@@@@BL@@@A @@@@X@@@@F@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@T@@@@C0@@@@D@@@@@@@@@@@@@@@@@@@@(@@@@MP@@@CT@@@@&amp;@@@@@@@@@@(@@@@&gt;@@@@O @@@@(@@@@@@@@@N0@@@F@@@@A @@@@R @@@@@@@@@@@@@@@@@@@@P@@@@8@@@@U@@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@G @@@B@@@@@ @@@@G@@@@@,@@@@@@@@@@@@@@@(@@@@3@@@@MP@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-@@@@X@@@@F@@@@@&amp;@@@@@@@@@@@@@@@''@@@@Y0@@@GT@@@A5@@@@[0@@@@D@@@@@@@@@@@@@@@@@@@@\@@@@H@@@@B@@@@@ @@@@H@@@@A @@@@L@@@@@@@@@@P@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@B@@@@@@@@@@V@@@@V@@@@GT@@@A5@@@@]P@@@GT@@@A!@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@Y@@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@G@@@@A5@@@@]P@@@GT@@@A5@@@@R @@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@FP@@@B@@@@@ @@@@H@@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@]P@@@GT@@@A5@@@@V0@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@AP@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@U@@@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@B@@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\0@@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@" @@@GL@@@@H@@@@B @@@@(@@@@J@@@@B @@@@(@@@@J@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A3@@@@" @@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@\0@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AV@@@@,@@@@GH@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@D,@@@A"@@@@N@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@6@@@@/0@@@OT@@@C5@@@@=P@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]@@@@(@@@@J@@@@B @@@@_P@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@''@@@@OP@@@C5@@@@=P@@@OT@@@C*@@@@D0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@B @@@@(@@@@J@@@@B @@@@''0@@@G&lt;@@@@\@@@@@@@@@@@@@@@@@@@@@P@@@L,@@@C5@@@@=P@@@OT@@@C5@@@@.@@@@B4@@@@@@@@@D @@@B @@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@BD@@@@N@@@@@@@@@C8@@@A:@@@@(@@@@J@@@@B @@@@(@@@@H,@@@@A@@@@@@@@@@@@@@@C@@@@:P@@@OT@@@C5@@@@6@@@@EH@@@@@@@@@@@@@@E$@@@C @@@@8@@@@F$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AW@@@@-P@@@J0@@@@!@@@@@@@@@@@@@@@5@@@@#P@@@J@@@@B @@@@&amp;@@@@@H@@@@@@@@@@@@@@@@@@@AP@@@@,@@@@GP@@@@I@@@@@@@@@@@@@@@@@@@@+P@@@N@@@@C @@@@" @@@@@@@@@\@@@@* @@@J(@@@@\@@@@@@@@@HL@@@B5@@@@-P@@@H$@@@@@@@@@@@@@@@@@@@@F@@@@RP@@@FP@@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D,@@@C @@@@8@@@@N@@@@AQ@@@@@@@@@GH@@@CJ@@@@2 @@@GH@@@@@@@@@PP@@@KT@@@B5@@@@-P@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@1P@@@N@@@@C @@@@+0@@@@D@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@A@@@@#P@@@KT@@@B5@@@@''0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F\@@@C @@@@8@@@@M&lt;@@@@0@@@@@@@@@@@@@@A7@@@@2 @@@L(@@@A7@@@@@@@@@@@@@@@''@@@@-@@@@KT@@@B5@@@@U0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#P@@@N@@@@C @@@@,@@@@@@@@@@@@@@@@@@@@G\@@@CJ@@@@2 @@@G\@@@@@@@@@@@@@@@@@@@A2@@@@-P@@@KT@@@BC@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@5P@@@L@@@@@(@@@@@@@@@@@@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@@@@@@@@@@@AH@@@BT@@@@+@@@@C(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A2@@@@2 @@@L(@@@A2@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@B*@@@@* @@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin18">spin18	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin18.png'&gt;	&lt;md5sum: #[154 199 236 29 149 57 154 10 86 2 38 244 110 138 162 48]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@M @@@CX@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@A@@@@@P@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@J@@@@BH@@@@D@@@@@@@@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@@@@@@@&lt;@@@AI@@@@TP@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@*@@@@J @@@A,@@@@@@@@@@@@@@@@@@@@&amp;@@@@P@@@@D@@@@@&amp;@@@@@@@@@@@@@@@@@@@@P0@@@ET@@@AU@@@@M @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B(@@@@*@@@@J @@@@$@@@@@@@@@@@@@@BX@@@A@@@@@P@@@@BX@@@@@@@@@@@@@@AH@@@AU@@@@UP@@@ET@@@@''@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@IP@@@B(@@@@*@@@@HP@@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@P @@@ET@@@AU@@@@R0@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N@@@@J @@@B(@@@@*@@@@C0@@@@@@@@@$@@@@P@@@@D@@@@@$@@@@@@@@@A&lt;@@@AU@@@@UP@@@ET@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@M@@@@B @@@@D@@@@@@@@@@@@@@@@@@@@ @@@@J @@@B(@@@@^@@@@@@@@@@$@@@@6@@@@M @@@@$@@@@@@@@@M@@@@ET@@@AU@@@@P @@@@@@@@@@@@@@@@@@@@P@@@@2@@@@S@@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@AT@@@@U@@@@D0@@@@\@@@@@@@@@@@@@@@ @@@@(@@@@J @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@UP@@@ET@@@@"@@@@@@@@@@@@@@@#@@@@W @@@F(@@@A*@@@@YP@@@@D@@@@@@@@@@@@@@@@@@@@R@@@@EP@@@AT@@@@U@@@@EP@@@A@@@@@H@@@@@@@@@@L@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@A0@@@@@@@@@T@@@@S0@@@F(@@@A*@@@@Z @@@F(@@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@Q@@@@EP@@@AT@@@@U@@@@EP@@@AT@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@FT@@@A*@@@@Z @@@F(@@@A*@@@@P0@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@D@@@@AT@@@@U@@@@EP@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@Z @@@F(@@@A*@@@@T0@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@@4@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@1@@@@S@@@@BT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z @@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A*@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@Z @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AR@@@@*@@@@F4@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@DX@@@A[@@@@M@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@-0@@@N(@@@C*@@@@: @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@%P@@@IT@@@BU@@@@]@@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@%P@@@N$@@@C*@@@@: @@@N(@@@C @@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@BU@@@@%P@@@IT@@@BU@@@@%@@@@G\@@@@Z@@@@@@@@@@@@@@@@@@@@@P@@@LH@@@C*@@@@: @@@N(@@@C*@@@@+0@@@B,@@@@@@@@@DP@@@BX@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A&lt;@@@@M@@@@@@@@@C(@@@A2@@@@%P@@@IT@@@BU@@@@%P@@@HD@@@@A@@@@@@@@@@@@@@@C@@@@70@@@N(@@@C*@@@@3 @@@D8@@@@@@@@@@@@@@EP@@@CU@@@@5P@@@FP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AR@@@@* @@@JH@@@@_@@@@@@@@@@@@@@@2@@@@ 0@@@IT@@@BU@@@@# @@@@H@@@@@@@@@@@@@@@@@@@AL@@@@*@@@@F&lt;@@@@H@@@@@@@@@@@@@@@@@@@@)P@@@MT@@@CU@@@@ 0@@@@@@@@@Z@@@@(P@@@JD@@@@Z@@@@@@@@@G,@@@B*@@@@* @@@HD@@@@@@@@@@@@@@@@@@@@E@@@@Q@@@@E4@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D\@@@CU@@@@5P@@@MT@@@AM@@@@@@@@@F0@@@C@@@@@0@@@@F0@@@@@@@@@OP@@@J(@@@B*@@@@* @@@C$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@.0@@@MT@@@CU@@@@) @@@@D@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@A@@@@!P@@@J(@@@B*@@@@%P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@FH@@@CU@@@@5P@@@MP@@@@.@@@@@@@@@@@@@@A1@@@@0@@@@L@@@@A1@@@@@@@@@@@@@@@%@@@@*P@@@J(@@@B*@@@@TP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@! @@@MT@@@CU@@@@)0@@@@@@@@@@@@@@@@@@@GD@@@C@@@@@0@@@@GD@@@@@@@@@@@@@@@@@@@A+@@@@* @@@J(@@@A;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@20@@@K\@@@@&amp;@@@@@@@@@@@@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@@@@@@@@@@@AD@@@BK@@@@( @@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A,@@@@0@@@@L@@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A(@@@B!@@@@(P@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin19">spin19	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin19.png'&gt;	&lt;md5sum: #[30 223 135 192 160 12 92 161 196 129 117 228 207 110 239 113]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@K@@@@B0@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@5@@@@MP@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@G @@@A(@@@@C@@@@@@@@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@@@@@@@4@@@A@@@@@Q0@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@@ @@@@H@@@@AP@@@@@@@@@@@@@@@@@@@@_@@@@MP@@@CT@@@@_@@@@@@@@@@@@@@@@@@@@N @@@D(@@@AJ@@@@K0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@B@@@@@ @@@@H@@@@@\@@@@@@@@@@@@@@A&lt;@@@@5@@@@MP@@@A&lt;@@@@@@@@@@@@@@A@@@@AJ@@@@R @@@D(@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@G@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@N @@@D(@@@AJ@@@@PP@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@H@@@@B@@@@@ @@@@C@@@@@@@@@@^@@@@MP@@@CT@@@@^@@@@@@@@@A,@@@AJ@@@@R @@@D(@@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@F@@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@H@@@@B@@@@@W@@@@@@@@@@\@@@@,@@@@K@@@@@\@@@@@@@@@K @@@D(@@@AJ@@@@NP@@@@@@@@@@@@@@@@@@@@L@@@@.@@@@QP@@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@B @@@@(@@@@J@@@@BP@@@@L@@@@@@@@@@@@@@@X@@@@^@@@@H@@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@R @@@D(@@@@]@@@@@@@@@@@@@@@ @@@@UP@@@F@@@@A @@@@V0@@@@D@@@@@@@@@@@@@@@@@@@@I@@@@B @@@@(@@@@J@@@@B @@@@ @@@@D@@@@@@@@@@L@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@A @@@@@@@@@R@@@@R@@@@F@@@@A @@@@X@@@@F@@@@AO@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@H@@@@B @@@@(@@@@J@@@@B @@@@(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@E0@@@A @@@@X@@@@F@@@@A @@@@OP@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B@@@@@(@@@@J@@@@B @@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@X@@@@F@@@@A @@@@R0@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@X@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-@@@@QP@@@BH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@3@@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@=P@@@L0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@XP@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@]P@@@FD@@@CL@@@@=P@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@3@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A!@@@@]P@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@XP@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AN@@@@(P@@@F$@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@D@@@@AT@@@@L@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@1@@@@+0@@@N@@@@C @@@@8@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@" @@@H(@@@BJ@@@@[@@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@# @@@M&lt;@@@C @@@@8@@@@N@@@@CV@@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@BJ@@@@" @@@H(@@@BJ@@@@"P@@@F8@@@@X@@@@@@@@@@@@@@@@@@@@@P@@@K$@@@C @@@@8@@@@N@@@@C @@@@*@@@@B$@@@@@@@@@D@@@@BP@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A4@@@@M@@@@@@@@@CX@@@A*@@@@" @@@H(@@@BJ@@@@" @@@G @@@@A@@@@@@@@@@@@@@@C@@@@5P@@@N@@@@C @@@@1 @@@D,@@@@@@@@@@@@@@E@@@@CJ@@@@2 @@@E&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AM@@@@(@@@@I @@@@]@@@@@@@@@@@@@@@.@@@@^ @@@H(@@@BJ@@@@!@@@@@H@@@@@@@@@@@@@@@@@@@AI@@@@(P@@@F(@@@@H@@@@@@@@@@@@@@@@@@@@''@@@@L(@@@CJ@@@@_@@@@@@@@@@Y@@@@&amp;@@@@I @@@@Y@@@@@@@@@GL@@@B @@@@(@@@@G$@@@@@@@@@@@@@@@@@@@@E@@@@O0@@@E\@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DL@@@CJ@@@@2 @@@L(@@@AI@@@@@@@@@FX@@@B5@@@@-P@@@FX@@@@@@@@@N @@@J@@@@B @@@@(@@@@CT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@,P@@@L(@@@CJ@@@@'' @@@@D@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@A@@@@_P@@@J@@@@B @@@@#P@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E4@@@CJ@@@@2 @@@L$@@@@,@@@@@@@@@@@@@@A*@@@@-P@@@KT@@@A*@@@@@@@@@@@@@@@#@@@@''0@@@J@@@@B @@@@SP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@L(@@@CJ@@@@'' @@@@@@@@@@@@@@@@@@@F(@@@B5@@@@-P@@@F(@@@@@@@@@@@@@@@@@@@A%@@@@(@@@@J@@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AA@@@@0@@@@J4@@@@$@@@@@@@@@@@@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@@@@@@@@@@@A@@@@BC@@@@&amp;@@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A&amp;@@@@-P@@@KT@@@A&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@BX@@@@&amp;@@@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin2">spin2	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin2.png'&gt;	&lt;md5sum: #[38 243 25 201 152 122 245 92 117 37 27 157 121 61 11 205]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@1@@@@LP@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@HP@@@C*@@@@: @@@HP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AD@@@@20@@@J8@@@@U@@@@@@@@@@@@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I,@@@CU@@@@5P@@@HX@@@@@@@@@@@@@@@@@@@BJ@@@@: @@@N(@@@BJ@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y @@@MT@@@CU@@@@5@@@@B8@@@@@@@@@@@@@@H(@@@C*@@@@: @@@H(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@.0@@@MT@@@CU@@@@) @@@@D@@@@@@@@@" @@@N(@@@C*@@@@" @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AG@@@@5P@@@MT@@@CU@@@@SP@@@@@@@@BD@@@@: @@@N(@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C8@@@A8@@@@V@@@@@\@@@@@@@@@@@@@@@@@@@B!@@@@5P@@@MT@@@BZ@@@@@@@@@B@@@@CD@@@@1@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@J@@@@C0@@@@\@@@@@@@@@@@@@@@@@@@@B@@@@-0@@@L@@@@C@@@@@*P@@@D@@@@@@@@@@@@@@@BX@@@CK@@@@5P@@@F\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@D0@@@AT@@@@U@@@@E@@@@@@@@@@@@@@@@@@@@@D@@@B&amp;@@@@0@@@@L@@@@C@@@@@0@@@@IL@@@AK@@@@@@@@@AD@@@@&amp;@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@D@@@@AT@@@@U@@@@EP@@@AT@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@BD@@@BY@@@@/0@@@L@@@@C@@@@@0@@@@L@@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@AP@@@@U@@@@EP@@@AT@@@@U@@@@CP@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@% @@@L@@@@C@@@@@0@@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@EP@@@AT@@@@U@@@@D@@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@P0@@@GT@@@AZ@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@C0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@#P@@@J(@@@B*@@@@* @@@J(@@@B*@@@@* @@@H4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H0@@@B(@@@@*@@@@J @@@B(@@@@*@@@@J @@@BL@@@BM@@@@* @@@J(@@@B*@@@@* @@@J(@@@B*@@@@#P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@J @@@B(@@@@*@@@@J @@@B(@@@@*@@@@H0@@@A\@@@A!@@@@Y @@@FX@@@A&amp;@@@@Y @@@FD@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@X@@@@FP@@@A$@@@@Y@@@@FP@@@A @@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@4@@@@Z0@@@DX@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A8@@@@''@@@@E @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@]@@@@IT@@@BU@@@@%P@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@P@@@@D@@@@A@@@@@L @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@W0@@@IP@@@BU@@@@%P@@@IT@@@BO@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@A@@@@@P@@@@D@@@@A@@@@@P@@@@CL@@@@K@@@@@@@@@@@@@@@@@@@@@P@@@G,@@@BU@@@@%P@@@IT@@@BU@@@@\@@@@A,@@@@@@@@@B @@@A\@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@G@@@@@@@@@A$@@@@1@@@@P@@@@D@@@@A@@@@@P@@@@C\@@@@@@@@@@@@@@@@@@@@B@@@@# @@@IT@@@BU@@@@ 0@@@CH@@@@@@@@@@@@@@CL@@@B@@@@@ @@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@UP@@@ED@@@@O@@@@@@@@@@@@@@@U@@@@N@@@@D@@@@A@@@@@OP@@@@D@@@@@@@@@@@@@@@@@@@@0@@@@Z0@@@D\@@@@E@@@@@@@@@@@@@@@@@@@@X0@@@H@@@@B@@@@@S0@@@@@@@@@O@@@@VP@@@E$@@@@O@@@@@@@@@C4@@@AU@@@@UP@@@D@@@@@@@@@@@@@@@@@@@@@B@@@@GP@@@B @@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B,@@@B@@@@@ @@@@H@@@@@.@@@@@@@@@C0@@@A*@@@@Z @@@C0@@@@@@@@@G0@@@ET@@@AU@@@@UP@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@\@@@@H@@@@B@@@@@Y@@@@@D@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@@@@@@P @@@ET@@@AU@@@@R0@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C,@@@B@@@@@ @@@@G&lt;@@@@\@@@@@@@@@@@@@@@&gt;@@@@Z @@@F(@@@@&gt;@@@@@@@@@@@@@@@R@@@@UP@@@ET@@@AU@@@@JP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TP@@@H@@@@B@@@@@Y@@@@@@@@@@@@@@@@@@@@C8@@@A*@@@@Z @@@C8@@@@@@@@@@@@@@@@@@@@6@@@@UP@@@ET@@@@&gt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@^ @@@F8@@@@W@@@@@@@@@@@@@@@@@@@@O @@@F(@@@A*@@@@O @@@@@@@@@@@@@@@@@@@@ @@@AE@@@@TP@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@Z @@@F(@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@AY@@@@VP@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin20">spin20	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin20.png'&gt;	&lt;md5sum: #[75 225 64 91 192 72 97 162 58 11 20 245 194 163 238 149]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@H0@@@BL@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@*@@@@J @@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@E@@@@AD@@@@B@@@@@@@@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@@@@@@@,@@@@7@@@@OP@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@U@@@@EP@@@@4@@@@@@@@@@@@@@@@@@@@Y@@@@J @@@B(@@@@Y@@@@@@@@@@@@@@@@@@@@L @@@D@@@@A@@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B @@@AT@@@@U@@@@EP@@@@T@@@@@@@@@@@@@@A$@@@@*@@@@J @@@A$@@@@@@@@@@@@@@@8@@@A@@@@@P@@@@D@@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@D @@@AT@@@@U@@@@D@@@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@L @@@D@@@@A@@@@@N@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@EP@@@AT@@@@U@@@@B@@@@@@@@@@X@@@@J @@@B(@@@@X@@@@@@@@@A\@@@A@@@@@P@@@@D@@@@@U@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@EP@@@AT@@@@O@@@@@@@@@@X@@@@#@@@@H0@@@@X@@@@@@@@@I0@@@D@@@@A@@@@@LP@@@@@@@@@@@@@@@@@@@@L@@@@(@@@@OP@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@T@@@@EP@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@P@@@@D@@@@@Y@@@@@@@@@@@@@@@\@@@@R0@@@ET@@@AU@@@@TP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@AP@@@@@@@@@P@@@@P@@@@ET@@@AU@@@@UP@@@ET@@@AF@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@ED@@@AU@@@@UP@@@ET@@@AU@@@@M @@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@UP@@@ET@@@AU@@@@P @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@OP@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@00@@@N(@@@C*@@@@: @@@N(@@@C*@@@@: @@@LL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@F(@@@A*@@@@Z @@@F(@@@A*@@@@Z @@@E @@@CC@@@@: @@@N(@@@C*@@@@: @@@N(@@@C*@@@@00@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@@Z @@@F(@@@A*@@@@Z @@@F(@@@A*@@@@V@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AJ@@@@&amp;P@@@FL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@C0@@@AN@@@@KP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@) @@@MT@@@CU@@@@5P@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@ @@@@H@@@@B@@@@@Y@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@!0@@@MP@@@CU@@@@5P@@@MT@@@CL@@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@B@@@@@ @@@@H@@@@B@@@@@_0@@@FX@@@@V@@@@@@@@@@@@@@@@@@@@@P@@@K@@@@CU@@@@5P@@@MT@@@CU@@@@(@@@@B\@@@@@@@@@C0@@@BL@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A,@@@@L@@@@@@@@@CH@@@A"@@@@ @@@@H@@@@B@@@@@ @@@@F&lt;@@@@A@@@@@@@@@@@@@@@C@@@@20@@@MT@@@CU@@@@/@@@@D\@@@@@@@@@@@@@@D0@@@C@@@@@0@@@@E(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@%P@@@H8@@@@[@@@@@@@@@@@@@@@+@@@@\P@@@H@@@@B@@@@@^ @@@@H@@@@@@@@@@@@@@@@@@@AE@@@@&amp;P@@@FT@@@@H@@@@@@@@@@@@@@@@@@@@%@@@@L@@@@C@@@@@] @@@@@@@@@W@@@@#0@@@H&lt;@@@@W@@@@@@@@@F0@@@BU@@@@%P@@@GD@@@@@@@@@@@@@@@@@@@@E@@@@N0@@@E@@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@C@@@@@0@@@@L@@@@AE@@@@@@@@@F@@@@B*@@@@* @@@F@@@@@@@@@@M @@@IT@@@BU@@@@%P@@@CH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@*P@@@L@@@@C@@@@@% @@@@D@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@A@@@@]@@@@IT@@@BU@@@@ 0@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E @@@C@@@@@0@@@@K&lt;@@@@)@@@@@@@@@@@@@@A$@@@@* @@@J(@@@A$@@@@@@@@@@@@@@@ @@@@%@@@@IT@@@BU@@@@Q0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^P@@@L@@@@C@@@@@%0@@@@@@@@@@@@@@@@@@@FP@@@B*@@@@* @@@FP@@@@@@@@@@@@@@@@@@@A^@@@@%P@@@IT@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@-0@@@JT@@@@"@@@@@@@@@@@@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@@@@@@@@@@@@&lt;@@@A:@@@@# @@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@A @@@@* @@@J(@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A\@@@BO@@@@#0@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin21">spin21	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin21.png'&gt;	&lt;md5sum: #[200 27 50 26 192 76 12 223 206 166 19 120 44 56 172 49]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F0@@@A,@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@B @@@@ @@@@A@@@@@@@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@@@@@@@$@@@@.@@@@L0@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@@@@@@S@@@@H@@@@B@@@@@S@@@@@@@@@@@@@@@@@@@@J @@@CT@@@@5@@@@HP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@(@@@@J@@@@B @@@@H@@@@@@@@@@@@@@AL@@@@ @@@@H@@@@AL@@@@@@@@@@@@@@@,@@@@5@@@@MP@@@CT@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BP@@@@(@@@@J@@@@B@@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@JP@@@CT@@@@5@@@@K0@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@B @@@@(@@@@J@@@@A@@@@@@@@@@R@@@@H@@@@B@@@@@R@@@@@@@@@AL@@@@5@@@@MP@@@CT@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@BZ@@@@\@@@@@$@@@@@@@@@@@@@@@@@@@@H@@@@B @@@@(@@@@G@@@@@@@@@@P@@@@[@@@@F0@@@@P@@@@@@@@@HP@@@CT@@@@5@@@@JP@@@@@@@@@@@@@@@@@@@@L@@@@#@@@@MP@@@A @@@@@@@@@@@@@@@@@@@@C@@@@:P@@@OT@@@C5@@@@6@@@@EH@@@@@@@@@@@@@@@H@@@@J@@@@B @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@MP@@@CT@@@@U@@@@@@@@@@@@@@@Y@@@@PP@@@D(@@@AJ@@@@Q0@@@@D@@@@@@@@@@@@@@@D@@@CT@@@@=P@@@OT@@@C5@@@@=P@@@K,@@@A_@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@A@@@@@@@@@@N@@@@M0@@@D(@@@AJ@@@@R @@@D(@@@@=@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@CC@@@@=@@@@OT@@@C5@@@@=P@@@OT@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@D\@@@AJ@@@@R @@@D(@@@AJ@@@@K0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@6@@@@/0@@@OT@@@C5@@@@=P@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@R @@@D(@@@AJ@@@@N @@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@U @@@IX@@@A2@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@MP@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@. @@@N@@@@C @@@@8@@@@N@@@@C @@@@8@@@@K(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@E@@@@B:@@@@8@@@@N@@@@C @@@@8@@@@N@@@@C @@@@. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@X@@@@F@@@@A @@@@X@@@@F@@@@A @@@@T@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AG@@@@$P@@@E8@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C\@@@AH@@@@JP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@'' @@@L(@@@CJ@@@@2 @@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@]P@@@GT@@@A5@@@@V0@@@A(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@ @@@@L$@@@CJ@@@@2 @@@L(@@@CA@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@A5@@@@]P@@@GT@@@A5@@@@]P@@@E4@@@@T@@@@@@@@@@@@@@@@@@@@@P@@@J\@@@CJ@@@@2 @@@L(@@@CJ@@@@%0@@@BT@@@@@@@@@C @@@BD@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A$@@@@K@@@@@@@@@B4@@@AY@@@@]P@@@GT@@@A5@@@@]P@@@FT@@@@@@@@@@@@@@@@@@@@B@@@@0@@@@L(@@@CJ@@@@, @@@DL@@@@@@@@@@@@@@D @@@B5@@@@-P@@@ET@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AC@@@@" @@@HP@@@@Y@@@@@@@@@@@@@@@''@@@@Y0@@@GT@@@A5@@@@[0@@@@D@@@@@@@@@@@@@@@@@@@AB@@@@$P@@@F@@@@@G@@@@@@@@@@@@@@@@@@@@#@@@@KT@@@B5@@@@[0@@@@@@@@@V@@@@! @@@HX@@@@V@@@@@@@@@FP@@@BJ@@@@" @@@F @@@@@@@@@@@@@@@@@@@@D@@@@M @@@D$@@@@&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C0@@@B5@@@@-P@@@KT@@@AA@@@@@@@@@E(@@@B @@@@(@@@@E(@@@@@@@@@L @@@H(@@@BJ@@@@" @@@B8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@''0@@@KT@@@B5@@@@#P@@@@D@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@A@@@@[@@@@H(@@@BJ@@@@^P@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@EL@@@B5@@@@-P@@@KP@@@@''@@@@@@@@@@@@@@A^@@@@(@@@@J@@@@A^@@@@@@@@@@@@@@@^@@@@"P@@@H(@@@BJ@@@@P @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\ @@@KT@@@B5@@@@# @@@@@@@@@@@@@@@@@@@E8@@@B @@@@(@@@@E8@@@@@@@@@@@@@@@@@@@AW@@@@" @@@H(@@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@@@@+@@@@I,@@@@ @@@@@@@@@@@@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@@@@@@@@@@@@8@@@A1@@@@!@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AZ@@@@(@@@@J@@@@AZ@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@BF@@@@! @@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin22">spin22	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin22.png'&gt;	&lt;md5sum: #[138 217 82 221 102 111 168 220 14 111 54 32 226 158 46 243]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@D @@@AH@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@@@@@@@\@@@@$@@@@J@@@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@@@@@@@@@@@HP@@@B(@@@@*@@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@U@@@@EP@@@@0@@@@@@@@@@@@@@@$@@@@*@@@@J @@@B(@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@AT@@@@U@@@@C@@@@@@@@@@@@@@@HP@@@B(@@@@*@@@@IP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@EP@@@AT@@@@L@@@@@@@@@@&lt;@@@@*@@@@J @@@B(@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D0@@@BS@@@@Z0@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@R@@@@D @@@@L@@@@@@@@@F @@@B(@@@@*@@@@H@@@@@@@@@@@@@@@@@@@@@H@@@@^@@@@K @@@AT@@@@@@@@@@@@@@@@@@@@C@@@@70@@@N(@@@C*@@@@3 @@@D8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@J @@@B(@@@@Q@@@@@@@@@@@@@@@U@@@@N@@@@D@@@@A@@@@@OP@@@@D@@@@@@@@@@@@@@@D@@@CK@@@@: @@@N(@@@C*@@@@: @@@KL@@@A[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@@0@@@@@@@@@L@@@@L@@@@D@@@@A@@@@@P@@@@D@@@@@5@@@@@@@@@@@@@@@@@@@@@@@@@B @@@B:@@@@:P@@@N(@@@C*@@@@: @@@N(@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@C4@@@A@@@@@P@@@@D@@@@A@@@@@JP@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@-0@@@N(@@@C*@@@@: @@@B(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@P@@@@D@@@@A@@@@@L @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@T @@@H&lt;@@@A-@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@K @@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@,P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@5P@@@KD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q0@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@UP@@@D\@@@B1@@@@5P@@@MT@@@CU@@@@5P@@@MT@@@CU@@@@,P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AG@@@@UP@@@ET@@@AU@@@@UP@@@ET@@@AU@@@@Q0@@@A4@@@A:@@@@ @@@@H@@@@B@@@@@ @@@@G(@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@1@@@@L0@@@CL@@@@3@@@@L0@@@CD@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@AC@@@@" @@@E(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CD@@@AA@@@@IP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@% @@@L@@@@C@@@@@0@@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@Z @@@F(@@@A*@@@@T0@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@^ @@@K&lt;@@@C@@@@@0@@@@L@@@@B8@@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@A*@@@@Z @@@F(@@@A*@@@@Z @@@EP@@@@R@@@@@@@@@@@@@@@@@@@@@P@@@I&lt;@@@C@@@@@0@@@@L@@@@C@@@@@$@@@@BL@@@@@@@@@CP@@@A&lt;@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@A\@@@@J@@@@@@@@@B$@@@AQ@@@@Z @@@F(@@@A*@@@@Z @@@E0@@@@@@@@@@@@@@@@@@@@B@@@@-0@@@L@@@@C@@@@@*P@@@D@@@@@@@@@@@@@@@DL@@@B*@@@@* @@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@ @@@@G(@@@@W@@@@@@@@@@@@@@@#@@@@W @@@F(@@@A*@@@@YP@@@@D@@@@@@@@@@@@@@@@@@@@&gt;@@@@" @@@E,@@@@G@@@@@@@@@@@@@@@@@@@@ 0@@@J(@@@B*@@@@ZP@@@@@@@@@T@@@@_P@@@G4@@@@T@@@@@@@@@E0@@@B@@@@@ @@@@FD@@@@@@@@@@@@@@@@@@@@D@@@@LP@@@DL@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C$@@@B*@@@@* @@@J(@@@@=@@@@@@@@@EP@@@BU@@@@%P@@@EP@@@@@@@@@K @@@H@@@@B@@@@@ @@@@B,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@%P@@@J(@@@B*@@@@!P@@@@D@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@A@@@@Y@@@@H@@@@B@@@@@\@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D8@@@B*@@@@* @@@J$@@@@%@@@@@@@@@@@@@@AX@@@@%P@@@IT@@@AX@@@@@@@@@@@@@@@\@@@@_0@@@H@@@@B@@@@@OP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z0@@@J(@@@B*@@@@!P@@@@@@@@@@@@@@@@@@@E @@@BU@@@@%P@@@E @@@@@@@@@@@@@@@@@@@AQ@@@@ @@@@H@@@@A]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@( @@@IH@@@@^@@@@@@@@@@@@@@@@@@@@V@@@@IT@@@BU@@@@V@@@@@@@@@@@@@@@@@@@@@4@@@A(@@@@^ @@@B$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AT@@@@%P@@@IT@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@A=@@@@_P@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin23">spin23	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin23.png'&gt;	&lt;md5sum: #[148 253 55 156 160 152 165 201 83 161 195 86 164 194 151 8]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@B@@@@@ @@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AO@@@@:P@@@L @@@@X@@@@@@@@@@@@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@@@@@@@@@@@@X@@@@[@@@@G @@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@KH@@@C5@@@@=P@@@I,@@@@@@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@@@@@@@@@@@FP@@@B@@@@@ @@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]P@@@OT@@@C5@@@@=@@@@CT@@@@@@@@@@@@@@@X@@@@J@@@@B @@@@X@@@@@@@@@@@@@@@\@@@@ @@@@H@@@@B@@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@50@@@OT@@@C5@@@@/0@@@@D@@@@@@@@@A @@@@(@@@@J@@@@A @@@@@@@@@@@@@@FP@@@B@@@@@ @@@@G@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AR@@@@=P@@@OT@@@C5@@@@V@@@@@@@@@@F@@@@B @@@@(@@@@F@@@@@@@@@@0@@@@ @@@@H@@@@B@@@@@K@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D$@@@BM@@@@Y0@@@@ @@@@@@@@@@@@@@@@@@@B9@@@@=P@@@OT@@@B1@@@@@@@@@@D@@@@H@@@@B@@@@@D@@@@@@@@@E@@@@B@@@@@ @@@@FP@@@@@@@@@@@@@@@@@@@@H@@@@Y@@@@I @@@AD@@@@@@@@@@@@@@@@@@@@C@@@@5P@@@N@@@@C @@@@1 @@@D,@@@@@@@@@@@@@@B0@@@C)@@@@=P@@@GX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@H@@@@B@@@@@M@@@@@@@@@@@@@@@R@@@@K0@@@CT@@@@5@@@@L0@@@@D@@@@@@@@@@@@@@@D@@@CB@@@@8@@@@N@@@@C @@@@8@@@@J,@@@AW@@@@@@@@@AL@@@@,@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@@0@@@@@@@@@J@@@@J@@@@CT@@@@5@@@@MP@@@CT@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@B\@@@B2@@@@70@@@N@@@@C @@@@8@@@@N@@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@CL@@@@5@@@@MP@@@CT@@@@5@@@@H @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@1@@@@+0@@@N@@@@C @@@@8@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@MP@@@CT@@@@5@@@@JP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@S @@@H$@@@A)@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@I @@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@*@@@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@2 @@@J @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@R @@@C8@@@B(@@@@2 @@@L(@@@CJ@@@@2 @@@L(@@@CJ@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@R @@@D(@@@AJ@@@@R @@@D(@@@AJ@@@@O @@@A0@@@A4@@@@^P@@@G$@@@A9@@@@^P@@@GP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@*@@@@K@@@@B0@@@@,@@@@K@@@@B(@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@?@@@@  @@@EP@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B4@@@@;@@@@H @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@#P@@@KT@@@B5@@@@-P@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@X@@@@F@@@@A @@@@R0@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@\0@@@KP@@@B5@@@@-P@@@KT@@@B-@@@@C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@A @@@@X@@@@F@@@@A @@@@X@@@@D0@@@@Q@@@@@@@@@@@@@@@@@@@@@P@@@IX@@@B5@@@@-P@@@KT@@@B5@@@@"@@@@BD@@@@@@@@@CP@@@A4@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AT@@@@I@@@@@@@@@BT@@@AI@@@@X@@@@F@@@@A @@@@X@@@@EL@@@@@@@@@@@@@@@@@@@@B@@@@+@@@@KT@@@B5@@@@(@@@@C0@@@@@@@@@@@@@@C&lt;@@@B @@@@(@@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8@@@@]P@@@F&lt;@@@@U@@@@@@@@@@@@@@@ @@@@UP@@@F@@@@A @@@@V0@@@@D@@@@@@@@@@@@@@@@@@@@;@@@@  @@@EX@@@@F@@@@@@@@@@@@@@@@@@@@_@@@@J@@@@B @@@@X0@@@@@@@@@S@@@@]@@@@GP@@@@S@@@@@@@@@EP@@@A5@@@@]P@@@E$@@@@@@@@@@@@@@@@@@@@C@@@@K@@@@C0@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CT@@@B @@@@(@@@@J@@@@@:@@@@@@@@@D8@@@BJ@@@@" @@@D8@@@@@@@@@J @@@GT@@@A5@@@@]P@@@B\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@#P@@@J@@@@B @@@@_P@@@@D@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@@@@@@V0@@@GT@@@A5@@@@Y0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D$@@@B @@@@(@@@@I&lt;@@@@#@@@@@@@@@@@@@@AQ@@@@" @@@H(@@@AQ@@@@@@@@@@@@@@@Y@@@@]P@@@GT@@@A5@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@YP@@@J@@@@B @@@@_P@@@@@@@@@@@@@@@@@@@ED@@@BJ@@@@" @@@ED@@@@@@@@@@@@@@@@@@@AJ@@@@]P@@@GT@@@AU@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@&amp;@@@@H$@@@@\@@@@@@@@@@@@@@@@@@@@TP@@@H(@@@BJ@@@@TP@@@@@@@@@@@@@@@@@@@@,@@@A_@@@@[0@@@BX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@AN@@@@" @@@H(@@@AN@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@A4@@@@]@@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin3">spin3	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin3.png'&gt;	&lt;md5sum: #[13 220 48 211 26 134 238 79 241 167 97 172 105 37 95 13]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@/@@@@K0@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@G8@@@C @@@@8@@@@G8@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AA@@@@0@@@@JT@@@@T@@@@@@@@@@@@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@@@@@@@@@@@B,@@@CR@@@@:P@@@D&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IL@@@CJ@@@@2 @@@H@@@@@@@@@@@@@@@@@@@@BD@@@@8@@@@N@@@@BD@@@@@@@@@@@@@@@@@@@@0@@@@OT@@@C5@@@@&amp;0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@XP@@@L(@@@CJ@@@@2P@@@B0@@@@@@@@@@@@@@HP@@@C @@@@8@@@@HP@@@@@@@@@@@@@@CT@@@C4@@@@=P@@@OT@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@,P@@@L(@@@CJ@@@@'' @@@@D@@@@@@@@@!@@@@N@@@@C @@@@!@@@@@@@@@@A@@@@/0@@@OT@@@C5@@@@50@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AC@@@@2 @@@L(@@@CJ@@@@RP@@@@@@@@A&gt;@@@@8@@@@N@@@@A&gt;@@@@@@@@@E @@@C5@@@@=P@@@OT@@@AR@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C,@@@A2@@@@T0@@@@X@@@@@@@@@@@@@@@@@@@BY@@@@2 @@@L(@@@BR@@@@@@@@@A&lt;@@@B&lt;@@@@/@@@@A&lt;@@@@@@@@@%0@@@OT@@@C5@@@@/P@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@A0@@@@L@@@@@@@@@@@@@@@@@@@@B@@@@+@@@@KT@@@B5@@@@(@@@@C0@@@@@@@@@@@@@@BP@@@C@@@@@2 @@@FD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A3@@@@=P@@@OT@@@A!@@@@@@@@@@@@@@@C@@@@BP@@@@(@@@@J@@@@B @@@@@@@@@@@@@@@@@@@@D@@@B]@@@@-P@@@KT@@@B5@@@@-P@@@H(@@@AF@@@@@@@@@A@@@@@$@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@,@@@@D0@@@@@@@@@B@@@@A0@@@@(@@@@J@@@@B @@@@(@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@BP@@@@-@@@@KT@@@B5@@@@-P@@@KT@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@(@@@@J@@@@B @@@@(@@@@J@@@@A @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@#P@@@KT@@@B5@@@@-P@@@BD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B @@@@(@@@@J@@@@B@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@O0@@@F&lt;@@@AT@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@A0@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@!P@@@J@@@@B @@@@(@@@@J@@@@B @@@@(@@@@HT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@A,@@@BE@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@!P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F0@@@AX@@@A\@@@@X@@@@F@@@@A @@@@X@@@@E0@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@R@@@@D0@@@AL@@@@S@@@@D0@@@AH@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@0@@@@X0@@@D@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@@ @@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@[@@@@H(@@@BJ@@@@" @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@MP@@@CT@@@@5@@@@JP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@V@@@@H$@@@BJ@@@@" @@@H(@@@BD@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@5@@@@MP@@@CT@@@@5@@@@MP@@@B(@@@@I@@@@@@@@@@@@@@@@@@@@@P@@@GH@@@BJ@@@@" @@@H(@@@BJ@@@@Y0@@@A$@@@@@@@@@BP@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@F@@@@@@@@@AT@@@@)@@@@MP@@@CT@@@@5@@@@MP@@@B8@@@@@@@@@@@@@@@@@@@@B@@@@!@@@@H(@@@BJ@@@@^ @@@B8@@@@@@@@@@@@@@B8@@@A5@@@@]P@@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@R @@@D\@@@@M@@@@@@@@@@@@@@@R@@@@K0@@@CT@@@@5@@@@L0@@@@D@@@@@@@@@@@@@@@@@@@@-@@@@X0@@@DD@@@@E@@@@@@@@@@@@@@@@@@@@V @@@GT@@@A5@@@@R@@@@@@@@@@M@@@@TP@@@ED@@@@M@@@@@@@@@CT@@@AJ@@@@R @@@C @@@@@@@@@@@@@@@@@@@@B@@@@F@@@@BD@@@@Q@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B\@@@A5@@@@]P@@@GT@@@@*@@@@@@@@@CX@@@A @@@@X@@@@CX@@@@@@@@@F0@@@D(@@@AJ@@@@R @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@Y0@@@GT@@@A5@@@@V0@@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@N @@@D(@@@AJ@@@@PP@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CX@@@A5@@@@]P@@@GT@@@@Y@@@@@@@@@@@@@@@8@@@@X@@@@F@@@@@8@@@@@@@@@@@@@@@P@@@@R @@@D(@@@AJ@@@@H0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R @@@GT@@@A5@@@@W@@@@@@@@@@@@@@@@@@@@C @@@A @@@@X@@@@C @@@@@@@@@@@@@@@@@@@@/@@@@R @@@D(@@@@6@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@[0@@@FP@@@@U@@@@@@@@@@@@@@@@@@@@N@@@@F@@@@A @@@@N@@@@@@@@@@@@@@@@@@@@@\@@@@&lt;@@@@Q0@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@6@@@@X@@@@F@@@@@6@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@AQ@@@@TP@@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin4">spin4	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin4.png'&gt;	&lt;md5sum: #[92 9 195 196 144 131 53 153 239 3 182 62 232 132 198 22]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]@@@@,0@@@KL@@@@]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@G @@@CU@@@@5P@@@G @@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&gt;@@@@-0@@@I4@@@@S@@@@@@@@@@@@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@@@@@@@@@@@B$@@@CI@@@@70@@@D,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H,@@@C@@@@@0@@@@G$@@@@@@@@@@@@@@@@@@@A=@@@@5P@@@MT@@@A=@@@@@@@@@@@@@@@@@@@@.@@@@N(@@@C*@@@@%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@L@@@@C@@@@@/0@@@B$@@@@@@@@@@@@@@G4@@@CU@@@@5P@@@G4@@@@@@@@@@@@@@CH@@@C)@@@@: @@@N(@@@A+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@*P@@@L@@@@C@@@@@% @@@@D@@@@@@@@@_P@@@MT@@@CU@@@@_P@@@@@@@@@A@@@@-0@@@N(@@@C*@@@@3 @@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@0@@@@L@@@@C@@@@@QP@@@@@@@@A8@@@@5P@@@MT@@@A8@@@@@@@@@EP@@@C*@@@@: @@@N(@@@AN@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C\@@@A+@@@@S @@@@X@@@@@@@@@@@@@@@@@@@BQ@@@@0@@@@L@@@@BK@@@@@@@@@A4@@@B3@@@@,0@@@A4@@@@@@@@@$@@@@N(@@@C*@@@@-P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@( @@@J(@@@B*@@@@% @@@C$@@@@@@@@@@@@@@BL@@@B7@@@@0@@@@E4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A.@@@@: @@@N(@@@A]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@BS@@@@* @@@J(@@@B*@@@@* @@@HH@@@AB@@@@@@@@@@&lt;@@@@#@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@*@@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@BG@@@@*P@@@J(@@@B*@@@@* @@@J(@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@!P@@@J(@@@B*@@@@* @@@A&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@N0@@@F @@@AO@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@_@@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@%P@@@G0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@EP@@@AD@@@A&lt;@@@@%P@@@IT@@@BU@@@@%P@@@IT@@@BU@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@EP@@@AT@@@@U@@@@EP@@@AT@@@@U@@@@DP@@@AP@@@AU@@@@VP@@@E$@@@AY@@@@VP@@@ET@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@L@@@@CP@@@@4@@@@M@@@@CP@@@@0@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@-@@@@W@@@@C0@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@Z@@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@Y@@@@H@@@@B@@@@@ @@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@J @@@B(@@@@*@@@@HP@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@TP@@@G&lt;@@@B@@@@@ @@@@H@@@@A:@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@*@@@@J @@@B(@@@@*@@@@J @@@BD@@@@G@@@@@@@@@@@@@@@@@@@@@P@@@F(@@@B@@@@@ @@@@H@@@@B@@@@@X@@@@A @@@@@@@@@B@@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@E@@@@@@@@@A@@@@@ @@@@J @@@B(@@@@*@@@@J @@@BP@@@@@@@@@@@@@@@@@@@@B@@@@^ @@@H@@@@B@@@@@\P@@@B,@@@@@@@@@@@@@@B(@@@A*@@@@Z @@@CH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@P@@@@C4@@@@L@@@@@@@@@@@@@@@N@@@@IP@@@B(@@@@*@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@W@@@@C4@@@@E@@@@@@@@@@@@@@@@@@@@T @@@F(@@@A*@@@@PP@@@@@@@@@L@@@@Q0@@@D\@@@@L@@@@@@@@@B8@@@A@@@@@P@@@@C@@@@@@@@@@@@@@@@@@@@@A@@@@D0@@@A(@@@@N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BL@@@A*@@@@Z @@@F(@@@@&amp;@@@@@@@@@C@@@@AU@@@@UP@@@C@@@@@@@@@@E0@@@D@@@@A@@@@@P@@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@WP@@@F(@@@A*@@@@T0@@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@L @@@D@@@@A@@@@@N@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CD@@@A*@@@@Z @@@F(@@@@W@@@@@@@@@@@@@@@2@@@@UP@@@ET@@@@2@@@@@@@@@@@@@@@N@@@@P@@@@D@@@@A@@@@@G0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P0@@@F(@@@A*@@@@T0@@@@@@@@@@@@@@@@@@@CH@@@AU@@@@UP@@@CH@@@@@@@@@@@@@@@@@@@@(@@@@P@@@@D@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@YP@@@E,@@@@S@@@@@@@@@@@@@@@@@@@@L @@@ET@@@AU@@@@L @@@@@@@@@@@@@@@@@@@@X@@@@4@@@@OP@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@UP@@@ET@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@AG@@@@Q0@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin5">spin5	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin5.png'&gt;	&lt;md5sum: #[182 222 198 221 30 132 188 4 30 126 39 33 229 186 201 75]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@* @@@J(@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@GH@@@CJ@@@@2 @@@GH@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@@@@+@@@@IP@@@@R@@@@@@@@@@@@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@@@@@@@@@@@B @@@C@@@@@5P@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@HL@@@B5@@@@-P@@@GH@@@@@@@@@@@@@@@@@@@A7@@@@2 @@@L(@@@A7@@@@@@@@@@@@@@@@@@@@,@@@@N@@@@C @@@@#P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U0@@@KT@@@B5@@@@-@@@@B\@@@@@@@@@@@@@@G\@@@CJ@@@@2 @@@G\@@@@@@@@@@@@@@C@@@@C_@@@@8@@@@N@@@@A''@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@''0@@@KT@@@B5@@@@#P@@@@D@@@@@@@@@]0@@@L(@@@CJ@@@@]0@@@@@@@@@A@@@@+0@@@N@@@@C @@@@1P@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@-P@@@KT@@@B5@@@@PP@@@@@@@@A2@@@@2 @@@L(@@@A2@@@@@@@@@ED@@@C @@@@8@@@@N@@@@AK@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CP@@@A$@@@@RP@@@@X@@@@@@@@@@@@@@@@@@@BI@@@@-P@@@KT@@@BC@@@@@@@@@A0@@@B*@@@@* @@@A0@@@@@@@@@" @@@N@@@@C @@@@+P@@@@@@@@@@@@@@@@@@@@$@@@A4@@@@,@@@@E@@@@@@@@@@@@@@@@@@@@@B@@@@&amp;@@@@J@@@@B @@@@#P@@@CT@@@@@@@@@@@@@@BD@@@B,@@@@-P@@@E\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A)@@@@8@@@@N@@@@AY@@@@@@@@@@@@@@AR@@@@6@@@@OT@@@C5@@@@:P@@@@L@@@@@@@@@@@@@@@D@@@BK@@@@(@@@@J@@@@B @@@@(@@@@G(@@@@&gt;@@@@@@@@@@8@@@@!@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@(@@@@D @@@@@@@@@-@@@@.@@@@OT@@@C5@@@@=P@@@OT@@@CK@@@@@P@@@@@@@@@@@@@@@@@@@A0@@@A?@@@@''0@@@J@@@@B @@@@(@@@@J@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D0@@@N(@@@C5@@@@=P@@@OT@@@C4@@@@''@@@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@_P@@@J@@@@B @@@@(@@@@A4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@=P@@@OT@@@C5@@@@/0@@@CX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@N@@@@FH@@@AK@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A2@@@@,@@@@EX@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@\0@@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@" @@@GL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@B @@@@(@@@@J@@@@B @@@@ @@@A3@@@@" @@@H(@@@BJ@@@@" @@@H(@@@BJ@@@@\0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@B @@@@(@@@@J@@@@B @@@@(@@@@J@@@@B@@@@AL@@@AO@@@@T0@@@EL@@@AS@@@@T0@@@D&lt;@@@@S@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)@@@@U@@@@C\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@T@@@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@V0@@@GT@@@A5@@@@]P@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@H@@@@B@@@@@ @@@@FP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K@@@@R @@@GT@@@A5@@@@]P@@@GT@@@A0@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@L@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@A$@@@@F@@@@@@@@@@@@@@@@@@@@@@@@@FD@@@A5@@@@]P@@@GT@@@A5@@@@V@@@@AX@@@@@@@@@B@@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@D@@@@@@@@@@0@@@@X@@@@H@@@@B@@@@@ @@@@H@@@@A0@@@@@@@@@@@@@@@@@@@@A@@@@[0@@@GT@@@A5@@@@Y0@@@B\@@@@@@@@@@@@@@BX@@@A @@@@X@@@@B4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@MP@@@CL@@@@J@@@@@@@@@@@@@@@K@@@@G@@@@B@@@@@ @@@@G @@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@U@@@@C @@@@D@@@@@@@@@@@@@@@@@@@@R @@@F@@@@A @@@@N0@@@@@@@@@J@@@@O @@@C8@@@@J@@@@@@@@@BX@@@@5@@@@MP@@@B @@@@@@@@@@@@@@@@@@@@A@@@@C0@@@AP@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@A @@@@X@@@@F@@@@@#@@@@@@@@@B(@@@AJ@@@@R @@@B(@@@@@@@@@D0@@@CT@@@@5@@@@MP@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@U@@@@F@@@@A @@@@R0@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@JP@@@CT@@@@5@@@@K0@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B0@@@A @@@@X@@@@F@@@@@U@@@@@@@@@@@@@@@,@@@@R @@@D(@@@@,@@@@@@@@@@@@@@@K@@@@MP@@@CT@@@@5@@@@FP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@OP@@@F@@@@A @@@@R0@@@@@@@@@@@@@@@@@@@B0@@@AJ@@@@R @@@B0@@@@@@@@@@@@@@@@@@@@!@@@@MP@@@CT@@@@&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@_@@@@V0@@@EH@@@@Q@@@@@@@@@@@@@@@@@@@@K@@@@D(@@@AJ@@@@K@@@@@@@@@@@@@@@@@@@@@T@@@@+@@@@L0@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@R @@@D(@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@&gt;@@@@O @@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin6">spin6	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin6.png'&gt;	&lt;md5sum: #[26 248 239 150 129 234 159 13 132 133 84 185 52 5 111 252]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@(P@@@JD@@@@Z@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@C@@@@@0@@@@F0@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@7@@@@( @@@H,@@@@Q@@@@@@@@@@@@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@@@@@@@@@@@BX@@@B7@@@@20@@@DP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G,@@@B*@@@@* @@@F,@@@@@@@@@@@@@@@@@@@A1@@@@0@@@@L@@@@A1@@@@@@@@@@@@@@@@@@@@)0@@@MT@@@CU@@@@! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@TP@@@J(@@@B*@@@@*P@@@BT@@@@@@@@@@@@@@GD@@@C@@@@@0@@@@GD@@@@@@@@@@@@@@B8@@@CT@@@@5P@@@MT@@@A"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@%P@@@J(@@@B*@@@@!P@@@@D@@@@@@@@@\P@@@L@@@@C@@@@@\P@@@@@@@@@A@@@@) @@@MT@@@CU@@@@.0@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@9@@@@* @@@J(@@@B*@@@@OP@@@@@@@@A,@@@@0@@@@L@@@@A,@@@@@@@@@D4@@@CU@@@@5P@@@MT@@@AG@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@A]@@@@Q@@@@@T@@@@@@@@@@@@@@@@@@@BA@@@@* @@@J(@@@A;@@@@@@@@@A(@@@B!@@@@(P@@@A(@@@@@@@@@ 0@@@MT@@@CU@@@@)P@@@@@@@@@@@@@@@@@@@@ @@@A/@@@@*@@@@D0@@@@@@@@@@@@@@@@@@@@B@@@@# @@@IT@@@BU@@@@ 0@@@CH@@@@@@@@@@@@@@A&lt;@@@B"@@@@* @@@EH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@@5P@@@MT@@@AT@@@@@@@@@@@@@@AN@@@@3 @@@N(@@@C*@@@@70@@@@L@@@@@@@@@@@@@@@D@@@BA@@@@%P@@@IT@@@BU@@@@%P@@@GH@@@@:@@@@@@@@@@4@@@@_@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@&amp;@@@@DP@@@@@@@@@+@@@@+0@@@N(@@@C*@@@@: @@@N(@@@CB@@@@@P@@@@@@@@@@@@@@@@@@@A(@@@A7@@@@%@@@@IT@@@BU@@@@%P@@@IT@@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@N@@@@C*@@@@: @@@N(@@@C)@@@@%P@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@!@@@@]@@@@IT@@@BU@@@@%P@@@A,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*@@@@: @@@N(@@@C*@@@@-0@@@CL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@M@@@@E,@@@AF@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A-@@@@*@@@@EH@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z @@@H@@@@B@@@@@ @@@@H@@@@B@@@@@ @@@@F(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A*@@@@ @@@@H@@@@B@@@@@ @@@@H@@@@B@@@@@Z @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@AI@@@@SP@@@D4@@@AM@@@@SP@@@D$@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@@@@S@@@@CD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@M@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@T0@@@F(@@@A*@@@@Z @@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@EP@@@AT@@@@U@@@@D@@@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@P0@@@F(@@@A*@@@@Z @@@F(@@@A%@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@U@@@@EP@@@AT@@@@U@@@@EP@@@AD@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@E @@@A*@@@@Z @@@F(@@@A*@@@@S0@@@AP@@@@@@@@@A0@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@C@@@@@@@@@@ @@@@P@@@@EP@@@AT@@@@U@@@@EP@@@AH@@@@@@@@@@@@@@@@@@@@A@@@@YP@@@F(@@@A*@@@@W @@@BL@@@@@@@@@@@@@@BH@@@AU@@@@UP@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@J @@@B @@@@H@@@@@@@@@@@@@@@G@@@@D0@@@AT@@@@U@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@S@@@@CH@@@@D@@@@@@@@@@@@@@@@@@@@P @@@ET@@@AU@@@@M@@@@@@@@@@I@@@@M @@@CX@@@@I@@@@@@@@@A8@@@@*@@@@J @@@B@@@@@@@@@@@@@@@@@@@@@A@@@@B @@@@4@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A0@@@AU@@@@UP@@@ET@@@@_@@@@@@@@@BP@@@A@@@@@P@@@@BP@@@@@@@@@C0@@@B(@@@@*@@@@J @@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C@@@@R0@@@ET@@@AU@@@@P @@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@HP@@@B(@@@@*@@@@IP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B\@@@AU@@@@UP@@@ET@@@@R@@@@@@@@@@@@@@@&amp;@@@@P@@@@D@@@@@&amp;@@@@@@@@@@@@@@@I@@@@J @@@B(@@@@*@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M @@@ET@@@AU@@@@P0@@@@@@@@@@@@@@@@@@@BX@@@A@@@@@P@@@@BX@@@@@@@@@@@@@@@@@@@@[@@@@J @@@B(@@@@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[@@@@TP@@@D$@@@@O@@@@@@@@@@@@@@@@@@@@I @@@D@@@@A@@@@@I @@@@@@@@@@@@@@@@@@@@P@@@@"@@@@J@@@@@8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@P@@@@D@@@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@6@@@@M @@@@$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin7">spin7	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin7.png'&gt;	&lt;md5sum: #[203 121 131 233 217 81 204 152 8 242 32 84 91 150 235 103]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Y@@@@&amp;@@@@I @@@@Y@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@FX@@@B5@@@@-P@@@FX@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@&amp;@@@@HL@@@@P@@@@@@@@@@@@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@@@@@@@@@@@BP@@@B-@@@@0@@@@DD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@GP@@@B @@@@(@@@@FT@@@@@@@@@@@@@@@@@@@A*@@@@-P@@@KT@@@A*@@@@@@@@@@@@@@@@@@@@'' @@@L(@@@CJ@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@SP@@@J@@@@B @@@@''0@@@BL@@@@@@@@@@@@@@F(@@@B5@@@@-P@@@F(@@@@@@@@@@@@@@B0@@@CI@@@@2 @@@L(@@@A]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@#P@@@J@@@@B @@@@_P@@@@D@@@@@@@@@Z @@@KT@@@B5@@@@Z @@@@@@@@@A@@@@'' @@@L(@@@CJ@@@@,P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@5@@@@(@@@@J@@@@B @@@@N @@@@@@@@A&amp;@@@@-P@@@KT@@@A&amp;@@@@@@@@@D$@@@CJ@@@@2 @@@L(@@@AC@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B4@@@AW@@@@O0@@@@T@@@@@@@@@@@@@@@@@@@A9@@@@(@@@@J@@@@A3@@@@@@@@@A$@@@BX@@@@&amp;@@@@A$@@@@@@@@@_@@@@L(@@@CJ@@@@''@@@@@@@@@@@@@@@@@@@@@ @@@A*@@@@(P@@@D$@@@@@@@@@@@@@@@@@@@@B@@@@!@@@@H(@@@BJ@@@@^ @@@B8@@@@@@@@@@@@@@A4@@@BX@@@@(@@@@D4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A_@@@@2 @@@L(@@@AP@@@@@@@@@@@@@@AK@@@@1 @@@N@@@@C @@@@5P@@@@L@@@@@@@@@@@@@@@D@@@A8@@@@" @@@H(@@@BJ@@@@" @@@F(@@@@6@@@@@@@@@@4@@@@]@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@$@@@@D@@@@@@@@@@)@@@@*@@@@N@@@@C @@@@8@@@@N@@@@B9@@@@@P@@@@@@@@@@@@@@@@@@@A @@@A.@@@@"P@@@H(@@@BJ@@@@" @@@H(@@@@K@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D @@@MX@@@C @@@@8@@@@N@@@@C_@@@@# @@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@[@@@@H(@@@BJ@@@@" @@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(@@@@8@@@@N@@@@C @@@@+0@@@CD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@L@@@@EP@@@A@@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A)@@@@(P@@@D8@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@XP@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@]P@@@FD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@3@@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@=P@@@L0@@@A!@@@@]P@@@GT@@@A5@@@@]P@@@GT@@@A5@@@@XP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CL@@@@=P@@@OT@@@C5@@@@=P@@@OT@@@C5@@@@3@@@@A@@@@AC@@@@Q @@@DX@@@AF@@@@Q @@@DL@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@BL@@@@$0@@@IL@@@BS@@@@$0@@@H0@@@@"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"@@@@QP@@@B4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@F@@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@R0@@@F@@@@A @@@@X@@@@AD@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@B @@@@(@@@@J@@@@B@@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@I@@@@OP@@@F@@@@A @@@@X@@@@F@@@@A\@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@J@@@@B @@@@(@@@@J@@@@B @@@@ @@@@B@@@@@@@@@@@@@@@@@@@@@@@@@D&lt;@@@A @@@@X@@@@F@@@@A @@@@R@@@@AH@@@@@@@@@A @@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@C@@@@@@@@@@P@@@@H@@@@B @@@@(@@@@J@@@@B @@@@$@@@@@@@@@@@@@@@@@@@@A@@@@V0@@@F@@@@A @@@@UP@@@B@@@@@@@@@@@@@@@A4@@@AJ@@@@R @@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@O@@@@H@@@@A8@@@@F@@@@@@@@@@@@@@@C@@@@BP@@@@(@@@@J@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@_@@@@QP@@@B8@@@@C@@@@@@@@@@@@@@@@@@@@NP@@@D(@@@AJ@@@@K @@@@@@@@@G@@@@K@@@@B0@@@@G@@@@@@@@@A\@@@@ @@@@H@@@@A @@@@@@@@@@@@@@@@@@@@@@@@@AP@@@@X@@@@C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A$@@@AJ@@@@R @@@D(@@@@[@@@@@@@@@A8@@@@5@@@@MP@@@A8@@@@@@@@@C@@@@B@@@@@ @@@@H@@@@@,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@PP@@@D(@@@AJ@@@@N @@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@FP@@@B@@@@@ @@@@G@@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BH@@@AJ@@@@R @@@D(@@@@P@@@@@@@@@@@@@@@_@@@@MP@@@CT@@@@_@@@@@@@@@@@@@@@G@@@@H@@@@B@@@@@ @@@@C0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@K0@@@D(@@@AJ@@@@N @@@@@@@@@@@@@@@@@@@A&lt;@@@@5@@@@MP@@@A&lt;@@@@@@@@@@@@@@@@@@@@T@@@@H@@@@B@@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@Q0@@@D@@@@@M@@@@@@@@@@@@@@@@@@@@G0@@@CT@@@@5@@@@G0@@@@@@@@@@@@@@@@@@@@L@@@@Z@@@@G @@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@MP@@@CT@@@@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@,@@@@K@@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin8">spin8	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin8.png'&gt;	&lt;md5sum: #[186 27 37 147 74 69 221 230 158 198 102 126 70 94 60 138]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W@@@@#0@@@H&lt;@@@@W@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@F@@@@B*@@@@* @@@F@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0@@@@# @@@G(@@@@O@@@@@@@@@@@@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@@@@@@@@@@@BH@@@B%@@@@-0@@@C8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@F0@@@BU@@@@%P@@@E8@@@@@@@@@@@@@@@@@@@A$@@@@* @@@J(@@@A$@@@@@@@@@@@@@@@@@@@@%0@@@L@@@@C@@@@@^P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q0@@@IT@@@BU@@@@%@@@@B@@@@@@@@@@@@@@@FP@@@B*@@@@* @@@FP@@@@@@@@@@@@@@B$@@@B?@@@@0@@@@L@@@@AX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@ 0@@@IT@@@BU@@@@]@@@@@D@@@@@@@@@Y@@@@J(@@@B*@@@@Y@@@@@@@@@@A@@@@% @@@L@@@@C@@@@@*P@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@%P@@@IT@@@BU@@@@M @@@@@@@@A @@@@* @@@J(@@@A @@@@@@@@@DT@@@C@@@@@0@@@@L@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B(@@@AP@@@@N0@@@@T@@@@@@@@@@@@@@@@@@@A1@@@@%P@@@IT@@@A,@@@@@@@@@A\@@@BO@@@@#0@@@A\@@@@@@@@@] @@@L@@@@C@@@@@%@@@@@@@@@@@@@@@@@@@@@ @@@A%@@@@&amp;P@@@DT@@@@@@@@@@@@@@@@@@@@B@@@@^ @@@H@@@@B@@@@@\P@@@B,@@@@@@@@@@@@@@A,@@@BN@@@@%P@@@D @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AZ@@@@0@@@@L@@@@AL@@@@@@@@@@@@@@AG@@@@/@@@@MT@@@CU@@@@20@@@@L@@@@@@@@@@@@@@@D@@@A/@@@@ @@@@H@@@@B@@@@@ @@@@FH@@@@2@@@@@@@@@@0@@@@[@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@#@@@@C0@@@@@@@@@''@@@@(@@@@MT@@@CU@@@@5P@@@MT@@@B0@@@@@P@@@@@@@@@@@@@@@@@@@AX@@@A&amp;@@@@_0@@@H@@@@B@@@@@ @@@@H@@@@@J@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DP@@@L0@@@CU@@@@5P@@@MT@@@CT@@@@!0@@@AL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@Y@@@@H@@@@B@@@@@ @@@@A\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;@@@@5P@@@MT@@@CU@@@@) @@@B&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@KP@@@D8@@@@&lt;@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A#@@@@&amp;P@@@D(@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@V@@@@F(@@@A*@@@@Z @@@F(@@@A*@@@@Z @@@E @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@00@@@N(@@@C*@@@@: @@@N(@@@C*@@@@: @@@LL@@@AX@@@@Z @@@F(@@@A*@@@@Z @@@F(@@@A*@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CC@@@@: @@@N(@@@C*@@@@: @@@N(@@@C*@@@@00@@@@&lt;@@@@=@@@@P@@@@D@@@@A@@@@@P@@@@C4@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@BF@@@@#@@@@H0@@@BL@@@@#@@@@HX@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@^@@@@OP@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@S@@@@P @@@ET@@@AU@@@@UP@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@M @@@ET@@@AU@@@@UP@@@ET@@@AQ@@@@A0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@DX@@@AU@@@@UP@@@ET@@@AU@@@@P@@@@A@@@@@@@@@@AP@@@@0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@TP@@@ET@@@AU@@@@R0@@@A0@@@@@@@@@@@@@@A$@@@A@@@@@P@@@@A8@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@EP@@@AP@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\@@@@OP@@@B @@@@C@@@@@@@@@@@@@@@@@@@@LP@@@D@@@@A@@@@@I0@@@@@@@@@F@@@@H0@@@BL@@@@F@@@@@@@@@@&lt;@@@@U@@@@EP@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AT@@@A@@@@@P@@@@D@@@@@W@@@@@@@@@A @@@@*@@@@J @@@A @@@@@@@@@B@@@@AT@@@@U@@@@EP@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@N@@@@D@@@@A@@@@@L @@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@D@@@@AT@@@@U@@@@D @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A4@@@A@@@@@P@@@@D@@@@@N@@@@@@@@@@@@@@@Y@@@@J @@@B(@@@@Y@@@@@@@@@@@@@@@E@@@@EP@@@AT@@@@U@@@@B @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@J@@@@D@@@@A@@@@@L @@@@@@@@@@@@@@@@@@@A$@@@@*@@@@J @@@A$@@@@@@@@@@@@@@@@@@@@M@@@@EP@@@AT@@@@O@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U@@@@OP@@@C\@@@@K@@@@@@@@@@@@@@@@@@@@FP@@@B(@@@@*@@@@FP@@@@@@@@@@@@@@@@@@@@H@@@@Q@@@@E@@@@@\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@J @@@B(@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@X@@@@#@@@@H0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-UI" selector="spin9">spin9	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'spin9.png'&gt;	&lt;md5sum: #[16 222 9 249 20 9 239 26 21 132 94 34 77 70 246 144]&gt;	^[AlphaCompositedImage image: ((Image extent: 32@32 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@V@@@@! @@@HX@@@@V@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@E(@@@B @@@@(@@@@E(@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@H@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@!@@@@GD@@@@N@@@@@@@@@@@@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@@@@@@@@@@@B@@@@B[@@@@+@@@@C(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@FP@@@BJ@@@@" @@@E\@@@@@@@@@@@@@@@@@@@A^@@@@(@@@@J@@@@A^@@@@@@@@@@@@@@@@@@@@# @@@KT@@@B5@@@@\ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P @@@H(@@@BJ@@@@"P@@@A8@@@@@@@@@@@@@@E8@@@B @@@@(@@@@E8@@@@@@@@@@@@@@B\@@@B4@@@@-P@@@KT@@@AS@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@^P@@@H(@@@BJ@@@@[@@@@@D@@@@@@@@@W @@@J@@@@B @@@@W @@@@@@@@@A@@@@#P@@@KT@@@B5@@@@''0@@@@X@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.@@@@" @@@H(@@@BJ@@@@L @@@@@@@@AZ@@@@(@@@@J@@@@AZ@@@@@@@@@DD@@@B5@@@@-P@@@KT@@@@&lt;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@BX@@@AI@@@@M @@@@P@@@@@@@@@@@@@@@@@@@A(@@@@" @@@H(@@@A$@@@@@@@@@AX@@@BF@@@@! @@@AX@@@@@@@@@[0@@@KT@@@B5@@@@#@@@@@@@@@@@@@@@@@@@@@\@@@A @@@@$P@@@DH@@@@@@@@@@@@@@@@@@@@A@@@@[0@@@GT@@@A5@@@@Y0@@@B\@@@@@@@@@@@@@@A$@@@BD@@@@" @@@DL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AU@@@@-P@@@KT@@@AH@@@@@@@@@@@@@@AC@@@@, @@@L(@@@CJ@@@@0@@@@@H@@@@@@@@@@@@@@@@@@@A%@@@@]P@@@GT@@@A5@@@@]P@@@E$@@@@-@@@@@@@@@@,@@@@Y@@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@!@@@@C @@@@@@@@@%@@@@%0@@@L(@@@CJ@@@@2 @@@L(@@@B''@@@@@P@@@@@@@@@@@@@@@@@@@AP@@@A]@@@@]P@@@GT@@@A5@@@@]P@@@GT@@@@I@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@@LD@@@CJ@@@@2 @@@L(@@@CI@@@@ @@@@AH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@V0@@@GT@@@A5@@@@]P@@@AT@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@$@@@@2 @@@L(@@@CJ@@@@'' @@@B0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@JP@@@D @@@@7@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@D@@@A^@@@@$P@@@D\@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@T@@@@F@@@@A @@@@X@@@@F@@@@A @@@@X@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@. @@@N@@@@C @@@@8@@@@N@@@@C @@@@8@@@@K(@@@AP@@@@X@@@@F@@@@A @@@@X@@@@F@@@@A @@@@T@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B:@@@@8@@@@N@@@@C @@@@8@@@@N@@@@C @@@@. @@@@4@@@@7@@@@N @@@C(@@@@:@@@@N @@@C\@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A&lt;@@@B@@@@@! @@@HX@@@BF@@@@! @@@H@@@@@_@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Z@@@@MP@@@BL@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@GH@@@BV@@@@U @@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@N @@@D(@@@AJ@@@@R @@@@4@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,@@@@=P@@@OT@@@C5@@@@/0@@@CX@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G@@@@K0@@@D(@@@AJ@@@@R @@@D(@@@AG@@@@A @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AL@@@C5@@@@=P@@@OT@@@C5@@@@=@@@@LL@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@C4@@@AJ@@@@R @@@D(@@@AJ@@@@M0@@@@8@@@@@@@@@A@@@@@(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@H@@@@A@@@@@@@@@E&lt;@@@B;@@@@=P@@@OT@@@C5@@@@=P@@@MP@@@@A@@@@@@@@@@@@@@@A@@@@Q0@@@D(@@@AJ@@@@PP@@@A$@@@@@@@@@@@@@@AT@@@@5@@@@MP@@@A$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@@@@B @@@@(@@@@B@@@@@@@@@@@@@@AR@@@@6@@@@OT@@@C5@@@@:P@@@@L@@@@@@@@@@@@@@@@@@@@X@@@@MP@@@BL@@@@C@@@@@@@@@@@@@@@@@@@@JP@@@CT@@@@5@@@@HP@@@@@@@@@D@@@@F0@@@A,@@@@D@@@@@@@@@@\@@@@J@@@@B @@@@ @@@@@@@@@@@@@@@@@@@@I@@@@\@@@@I(@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AH@@@@5@@@@MP@@@CT@@@@S@@@@@@@@@AH@@@@ @@@@H@@@@AH@@@@@@@@@A@@@@@(@@@@J@@@@B @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B@@@@K0@@@CT@@@@5@@@@JP@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@B@@@@@(@@@@J@@@@BP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A @@@@5@@@@MP@@@CT@@@@K@@@@@@@@@@@@@@@S@@@@H@@@@B@@@@@S@@@@@@@@@@@@@@@B@@@@B @@@@(@@@@J@@@@AP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@HP@@@CT@@@@5@@@@J @@@@@@@@@@@@@@@@@@@AL@@@@ @@@@H@@@@AL@@@@@@@@@@@@@@@@@@@@F@@@@B @@@@(@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Q@@@@L0@@@B8@@@@I@@@@@@@@@@@@@@@@@@@@D0@@@B@@@@@ @@@@D0@@@@@@@@@@@@@@@@@@@@D@@@@H@@@@B @@@@L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@R@@@@H@@@@B@@@@@R@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@P@@@@[@@@@F0@@@@P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body></methods><methods><class-id>Store.Glorp.StoreClassAndMethodTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="StoreForGlorpBrowserUI" selector="classesTab">classesTab	&lt;tabDescription: 2&gt;	^(TabPartDescription new)		name: #Class &lt;&lt; #browser &gt;&gt; 'Class';		buildSelector: #buildClassesSubcanvas;		matchSelector: #alwaysEnabled:;		enabledSelector: #enabledExceptForShared:</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>interface specs</category><body package="Store-Merge Management" selector="radioCompareSelectionSpec">radioCompareSelectionSpec	"Tools.UIPainter new openOnClass: self andSelector: #compareWithRadios"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MergeTool 				#defaultString: 'Merge Tool' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 643 530 1235 908 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 0 0.5 0 0.5 ) 					#name: #CompareWithImageRadio 					#model: #compareWithHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #Image 						#defaultString: 'Image' 						#catalogID: #IDE ) 					#select: #conflictsWithImage ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 0 0.5 0.5 0.5 ) 					#name: #CompareWithResolutionRadio 					#model: #compareWithHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #Resolution 						#defaultString: 'Resolution' 						#catalogID: #IDE ) 					#select: #conflictsWithResolution ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 0 0.5 1 0.5 ) 					#name: #CompareWithBaseRadio 					#model: #compareWithHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #Base 						#defaultString: 'Base' 						#catalogID: #IDE ) 					#select: #conflictsWithBase ) ) ) )</body><body package="Store-Merge Management" selector="sideBySideTextSpec">sideBySideTextSpec	"Tools.UIPainter new openOnClass: self andSelector: #sideBySideTextSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MergeTool 				#defaultString: 'Merge Tool' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 840 525 1432 903 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 25 0 0 1 -20 1 ) 					#name: #displayTextID 					#model: #displayText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#validateTextOnExit: ) 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 -2 0.5 -20 1 ) 					#name: #conflictTextID 					#model: #conflictText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#validateTextOnExit: ) 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#conflictTextID radioCompareSelectionCanvas  ConflictProtocol' 					#belowWidgets: '#displayTextID  #SelectionProtocol' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 -20 1 0 1 0 1 ) 					#name: #SelectionProtocol 					#model: #selectionProtocol 					#style: #default 					#isReadOnly: true 					#type: #text ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -20 1 -2 0.5 0 1 ) 					#name: #ConflictProtocol 					#model: #conflictProtocol 					#style: #default 					#isReadOnly: true 					#type: #text ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 25 0 ) 					#name: #radioCompareSelectionCanvas 					#flags: 0 					#minorKey: #radioCompareSelectionSpec ) ) ) )</body><body package="Store-Merge Management" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MergeTool 				#defaultString: 'Merge Tool' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 400 1800 1100 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #toolbarMenuHolder ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.5 30 0.5 ) 					#name: #ModTabs 					#model: #resolutionListTabs 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #resolutionListTabsChanged ) 					#labels: #() ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 21 0 0 1 30 0.5 ) 					#name: #pkgListID 					#flags: 15 					#model: #packageList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #chooseAsResolution ) 					#tabable: true 					#menu: #versionMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 32 0.5 0 1 0 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #sideBySideTextSpec ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0.5 0 1 32 0.5 ) 					#name: #mainHorizontalSplitter 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#ModTabs #pkgListID #ResizingSplitter2' 					#belowWidgets: 'textCanvas' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.5 0 0 1 0.5 30 0.5 ) 					#name: #ResizingSplitter2 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#ModTabs' 					#belowWidgets: '#pkgListID VersionLabel' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 2 0.5 21 0 0 1 ) 					#name: #VersionLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsC 						#defaultString: 'Versions:' 						#catalogID: #store ) ) ) ) )</body></methods><methods><class-id>Store.Glorp.MergeTool class</class-id> <category>resources</category><body package="Store-Merge Management" selector="menuBarMenu">menuBarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Packages 					#defaultString: '&amp;Packages' 					#catalogID: #store ) 				#nameKey: #packagesMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Se_lectPackages 								#defaultString: 'Se&amp;lect Packages...' 								#catalogID: #store ) 							#nameKey: #selectPackages 							#value: #selectPackages ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PublishPackages 								#defaultString: '&amp;Publish Packages...' 								#catalogID: #store ) 							#nameKey: #publishPackages 							#value: #publishPackages 							#enablementSelector: #couldPublishPackages ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Sho_wSummary 								#defaultString: 'Sho&amp;w Summary' 								#catalogID: #store ) 							#nameKey: #showStatus 							#value: #showStatus ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Close 								#defaultString: '&amp;Close' 								#catalogID: #store ) 							#nameKey: #exit 							#value: #exit ) ) #(2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Resolution 					#defaultString: '&amp;Resolution' 					#catalogID: #store ) 				#nameKey: #resolutionMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Unresolve 								#defaultString: '&amp;Unresolve' 								#catalogID: #store ) 							#nameKey: #unresolve 							#value: #unresolve 							#enablementSelector: #canUnresolve 							#shortcutKeyCharacter: #F4 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #unresolved ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SelectAsResolution 								#defaultString: '&amp;Select as Resolution' 								#catalogID: #store ) 							#nameKey: #chooseAsResolution 							#value: #chooseAsResolution 							#enablementSelector: #canResolve 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #resolved ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectAndApply_Resolution 								#defaultString: 'Select and Apply &amp;Resolution' 								#catalogID: #store ) 							#nameKey: #applySelection 							#value: #applySelection 							#enablementSelector: #canResolve ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ApplyResolution 								#defaultString: '&amp;Apply Resolution' 								#catalogID: #store ) 							#nameKey: #applyResolution 							#value: #applyResolution 							#enablementSelector: #canApplyResolution 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applied ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ApplyA_llResolutions 								#defaultString: 'Apply A&amp;ll Resolutions' 								#catalogID: #store ) 							#nameKey: #applyResolved 							#value: #applyResolved 							#enablementSelector: #containsResolvedAndNotApplied 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applyAll ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoNotResolve 								#defaultString: '&amp;Do Not Resolve' 								#catalogID: #store ) 							#nameKey: #DoNotResolve 							#value: #doNotResolve 							#enablementSelector: #canChooseDoNotResolve 							#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #doNotResolve ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Au_toSelectResolution 								#defaultString: 'Au&amp;to Select Resolution' 								#catalogID: #store ) 							#nameKey: #toggleAutoSelectResolution 							#value: #toggleAutoSelectResolution 							#indication: true 							#indicationSelector: #autoSelectResolution ) ) #(1 3 1 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #store ) 				#nameKey: #viewMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_All 								#defaultString: 'Show &amp;All' 								#catalogID: #store ) 							#nameKey: #showAll 							#value: #showAll 							#indication: true 							#indicationSelector: #isShowAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_Conflicts 								#defaultString: 'Show &amp;Conflicts' 								#catalogID: #store ) 							#nameKey: #showConflicts 							#value: #showConflicts 							#indication: true 							#indicationSelector: #isShowConflicts ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_Unresolved 								#defaultString: 'Show &amp;Unresolved' 								#catalogID: #store ) 							#nameKey: #showUnresolved 							#value: #showUnresolved 							#indication: true 							#indicationSelector: #isShowUnresolved ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowSourceDifferences 								#defaultString: 'Show Source Differences' 								#catalogID: #store ) 							#nameKey: #ShowSourceDifferences 							#value: #showSourceDifferences 							#indication: true 							#indicationSelector: #isShowingSourceDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowCodeDifferences 								#defaultString: 'Show Code Differences' 								#catalogID: #store ) 							#nameKey: #ShowCodeDifferences 							#value: #showCodeDifferences 							#indication: true 							#indicationSelector: #isShowingCodeDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Use_FullNames 								#defaultString: 'Use &amp;Full Names' 								#catalogID: #store ) 							#nameKey: #toggleFullNames 							#value: #toggleFullNames 							#indication: true 							#indicationSelector: #isShowLongNames ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #E_xpandTree 								#defaultString: 'E&amp;xpand Tree' 								#catalogID: #store ) 							#value: #expandHierarchy 							#enablementSelector: #canExpandHierarchy ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ZoomTextViews 								#defaultString: '&amp;Zoom Text Views' 								#catalogID: #store ) 							#nameKey: #toggleZoomTextViews 							#value: #toggleZoomTextViews 							#indication: true 							#indicationSelector: #areTextViewsZoomed 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Show_Toolbar 								#defaultString: 'Show &amp;Toolbar' 								#catalogID: #store ) 							#nameKey: #toggleToolbar 							#value: #toggleToolbar 							#indication: true 							#indicationSelector: #isShowingToolbar ) ) #(3 2 1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Browse 					#defaultString: '&amp;Browse' 					#catalogID: #store ) 				#nameKey: #browseMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse_Senders 								#defaultString: 'Browse &amp;Senders' 								#catalogID: #store ) 							#nameKey: #browseSenders 							#value: #browseSenders 							#enablementSelector: #methodSelected 							#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #referenceMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse_Implementors 								#defaultString: 'Browse &amp;Implementors' 								#catalogID: #store ) 							#nameKey: #browseImplementors 							#value: #browseImplementors 							#enablementSelector: #methodSelected 							#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse_Versions 								#defaultString: 'Browse &amp;Versions' 								#catalogID: #store ) 							#nameKey: #browseSenders 							#value: #browseVersions 							#enablementSelector: #canBrowseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenComparisonWith_Base 								#defaultString: 'Open Comparison with &amp;Base' 								#catalogID: #store ) 							#nameKey: #compareWithBase 							#value: #compareWithBase 							#enablementSelector: #versionSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenComparisonWith_Res 								#defaultString: 'Open Comparison with &amp;Resolution' 								#catalogID: #store ) 							#nameKey: #compareWithResolution 							#value: #compareWithResolution 							#enablementSelector: #canCompareWithResolution ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OpenComparisonWithI_mage 								#defaultString: 'Open Comparison with I&amp;mage' 								#catalogID: #store ) 							#nameKey: #compareWithImage 							#value: #compareWithImage 							#enablementSelector: #versionSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Open_ComparisonOfSelected 								#defaultString: 'Open &amp;Comparison of Selected' 								#catalogID: #store ) 							#nameKey: #compare 							#value: #compare 							#enablementSelector: #twoVersionsSelected ) ) #(3 4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #helpMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_HowToUseMergeTool 								#defaultString: '&amp;How to Use Merge Tool' 								#catalogID: #store ) 							#nameKey: #openHelpHowToUse 							#value: #openHelpHowToUse 							#labelImage: #(#{UI.ResourceRetriever} #{GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_IconsReference 								#defaultString: '&amp;Icons Reference' 								#catalogID: #store ) 							#nameKey: #openIconHelp 							#value: #openIconHelp ) ) #(2 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="Store-Merge Management" selector="modificationMenu">modificationMenu	"Tools.MenuEditor new openOnClass: self andSelector: #modificationMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Unresolve 					#defaultString: '&amp;Unresolve' 					#catalogID: #store ) 				#nameKey: #unresolve 				#value: #unresolve 				#enablementSelector: #canUnresolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #unresolved ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Apply_Resolution 					#defaultString: 'Apply &amp;Resolution' 					#catalogID: #store ) 				#nameKey: #applyResolution 				#value: #applyResolution 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applied ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoNotResolve 					#defaultString: '&amp;Do Not Resolve' 					#catalogID: #store ) 				#nameKey: #DoNotResolve 				#value: #doNotResolve 				#enablementSelector: #canChooseDoNotResolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #doNotResolve ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_Senders 					#defaultString: 'Browse &amp;Senders' 					#catalogID: #store ) 				#nameKey: #browseSenders 				#value: #browseSenders 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #referenceMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_Implementors 					#defaultString: 'Browse &amp;Implementors' 					#catalogID: #store ) 				#nameKey: #browseImplementors 				#value: #browseImplementors 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Browse_Versions 					#defaultString: 'Browse &amp;Versions' 					#catalogID: #store ) 				#nameKey: #browseVersions 				#value: #browseVersions 				#enablementSelector: #canBrowseVersions ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #E_xpandTree 					#defaultString: 'E&amp;xpand Tree' 					#catalogID: #store ) 				#nameKey: #expandHierarchy 				#value: #expandHierarchy 				#enablementSelector: #canExpandHierarchy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show_All 					#defaultString: 'Show &amp;All' 					#catalogID: #store ) 				#nameKey: #showAll 				#value: #showAll 				#indication: true 				#indicationSelector: #isShowAll ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show_Conflicts 					#defaultString: 'Show &amp;Conflicts' 					#catalogID: #store ) 				#nameKey: #showConflicts 				#value: #showConflicts 				#indication: true 				#indicationSelector: #isShowConflicts ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ShowUnresol_ved 					#defaultString: 'Show Unresol&amp;ved' 					#catalogID: #store ) 				#nameKey: #showUnresolved 				#value: #showUnresolved 				#indication: true 				#indicationSelector: #isShowUnresolved ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ShowSourceDifferences 					#defaultString: 'Show Source Differences' 					#catalogID: #store ) 				#nameKey: #showSourceDifferences 				#value: #showSourceDifferences 				#indication: true 				#indicationSelector: #isShowingSourceDifferences ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ShowCodeDifferences 					#defaultString: 'Show Code Differences' 					#catalogID: #store ) 				#nameKey: #showCodeDifferences 				#value: #showCodeDifferences 				#indication: true 				#indicationSelector: #isShowingCodeDifferences ) ) #(1 1 1 3 1 3 2 ) nil ) decodeAsLiteralArray</body><body package="Store-Merge Management" selector="toolbarMenu">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Unresolve 					#defaultString: 'Unresolve' 					#catalogID: #store ) 				#nameKey: #unresolve 				#value: #unresolve 				#enablementSelector: #canUnresolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #bigUnresolve ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #UnresolveThisModification 					#defaultString: 'Unresolve this modification' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAsResolution 					#defaultString: 'Select as Resolution' 					#catalogID: #store ) 				#nameKey: #chooseAsResolution 				#value: #chooseAsResolution 				#enablementSelector: #canResolve 				#labelImage: #(#{UI.ResourceRetriever} #{MergeIcons} #bigResolve ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #GenKey25 					#defaultString: 'Select this version as the resolution' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Apply 					#defaultString: 'Apply' 					#catalogID: #store ) 				#nameKey: #applyResolution 				#value: #applyResolution 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #bigApply ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #GenKey24 					#defaultString: 'Apply the current resolution of this modification' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseSenders 					#defaultString: 'Browse Senders' 					#catalogID: #store ) 				#nameKey: #browseSenders 				#value: #browseSenders 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #referenceMethod ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #BrowseSendersOfThisMethod 					#defaultString: 'Browse senders of this method' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseImplementors 					#defaultString: 'Browse Implementors' 					#catalogID: #store ) 				#nameKey: #browseImplementors 				#value: #browseImplementors 				#enablementSelector: #methodSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #GenKey23 					#defaultString: 'Browse implementors of this method' 					#catalogID: #store ) ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="Store-Merge Management" selector="versionMenu">versionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #versionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Unresolve 					#defaultString: '&amp;Unresolve' 					#catalogID: #store ) 				#nameKey: #unresolve 				#value: #unresolve 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #unresolved ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_SelectAsResolution 					#defaultString: '&amp;Select as Resolution' 					#catalogID: #store ) 				#nameKey: #chooseAsResolution 				#value: #chooseAsResolution 				#enablementSelector: #canResolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #resolved ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAndApply_Resolution 					#defaultString: 'Select and Apply &amp;Resolution' 					#catalogID: #store ) 				#nameKey: #applySelection 				#value: #applySelection 				#enablementSelector: #canResolve ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ApplyResolution 					#defaultString: '&amp;Apply Resolution' 					#catalogID: #store ) 				#nameKey: #applyResolution 				#value: #applyResolution 				#enablementSelector: #canApplyResolution 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #applied ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoNotResolve 					#defaultString: '&amp;Do Not Resolve' 					#catalogID: #store ) 				#nameKey: #DoNotResolve 				#value: #doNotResolve 				#enablementSelector: #canResolve 				#labelImage: #(#{UI.ResourceRetriever} #{Store.MergeIcons} #doNotResolve ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #OpenComparisonWith_Base 					#defaultString: 'Open Comparison with &amp;Base' 					#catalogID: #store ) 				#nameKey: #compareWithBase 				#value: #compareWithBase 				#enablementSelector: #versionSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #OpenComparisonWith_Res 					#defaultString: 'Open Comparison with &amp;Resolution' 					#catalogID: #store ) 				#nameKey: #compareWithResolution 				#value: #compareWithResolution 				#enablementSelector: #canCompareWithResolution ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #OpenComparisonWith_Image 					#defaultString: 'Open Comparison with &amp;Image' 					#catalogID: #store ) 				#nameKey: #compareWithImage 				#value: #compareWithImage 				#enablementSelector: #versionSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Open_ComparisonOfSelected 					#defaultString: 'Open &amp;Comparison of Selected' 					#catalogID: #store ) 				#nameKey: #compare 				#value: #compare 				#enablementSelector: #twoVersionsSelected ) ) #(1 3 1 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UserGroups #catalogID: #store #defaultString: 'User Groups') 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 310 212 843 652 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 229 0 -1 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #graphView ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 70 0.5 30 0 -3 1 220 0 ) 					#name: #userListID 					#model: #userList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 30 0 -70 0.5 220 0 ) 					#name: #groupListID 					#model: #groupList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 80 0.5 8 0 ) 					#label: #(#{UserMessage} #key: #GroupMember #catalogID: #store #defaultString: 'Group Member:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 8 ) 					#label: #(#{UserMessage} #key: #Group #catalogID: #store #defaultString: 'Group:') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 42 0 60 0.5 77 0 ) 					#name: #addToGroup 					#model: #addToGroup 					#label: #(#{UserMessage} #key: #Add #catalogID: #store #defaultString: 'Add') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 75 0 60 0.5 110 0 ) 					#name: #removeFromGroup 					#model: #removeFromGroup 					#label: #(#{UserMessage} #key: #Remove #catalogID: #store #defaultString: 'Remove') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 146 0 60 0.5 181 0 ) 					#name: #newUser 					#model: #newUser 					#label: #(#{UserMessage} #key: #NewUser #catalogID: #store #defaultString: 'New User...') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 179 0 60 0.5 214 0 ) 					#name: #newGroup 					#model: #newGroup 					#label: #(#{UserMessage} #key: #NewGroup #catalogID: #store #defaultString: 'New Group...') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="menuBarSkeleton">menuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(1 ) #(#closeRequest ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ResolutionsTreePane class</class-id> <category>interface specs</category><body package="Store-Merge Management" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1517 1028 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #ModSet 					#flags: 7 					#model: #list 					#menu: #modificationMenu 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #other 					#iconSelectors: #(#resolutionIcon #typeIcon ) 					#rootExpander: true ) ) ) )</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>interface specs</category><body package="Store-UI-Browser" selector="definitionSpec">definitionSpec	"Tools.UIPainter new openOnClass: self andSelector: #definitionSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #store #defaultString: 'Unlabeled Canvas') 			#min: #(#{Core.Point} 434 226 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1134 751 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #text 					#menu: #readOnlyCodeMenu 					#tabRequiresControl: true ) ) ) )</body><body package="Store-UI-Browser" selector="horizontalWindowSpec">horizontalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #horizontalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnloadableDefinitionsForPackage #catalogID: #store #defaultString: 'Unloadable Definitions for package:') 			#bounds: #(#{Graphics.Rectangle} 679 105 1315 587 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 1 0.35 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.35 0 1 3 0.35 ) 					#name: #splitter 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'viewers' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 3 0.35 0 1 0 1 ) 					#name: #viewers 					#model: #viewerListHolder 					#labels: #() ) ) ) )</body><body package="Store-UI-Browser" selector="verticalWindowSpec">verticalWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #verticalWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnloadableDefinitionsForPackage #catalogID: #store #defaultString: 'Unloadable Definitions for package:') 			#bounds: #(#{Graphics.Rectangle} 700 525 1336 1007 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.5 0 1 ) 					#name: #selectionModule 					#flags: 0 					#clientKey: #selectionModule ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 2 0.5 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionModule' 					#belowWidgets: 'viewers' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #viewers 					#model: #viewerListHolder 					#labels: #() ) ) ) )</body></methods><methods><class-id>Store.UnloadableDefinitionsViewer class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="definitionMenu">definitionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #definitionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #Load #catalogID: #store #defaultString: 'Load') 				#nameKey: #loadDefinition 				#value: #loadDefinition 				#enablementSelector: #anySelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #FileOutAsDots #catalogID: #store #defaultString: 'File Out As...') 				#nameKey: #fileOut 				#value: #fileOut 				#enablementSelector: #anySelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #RemoveFromPackage #catalogID: #store #defaultString: 'Remove from Package') 				#nameKey: #removeFromPackage 				#value: #removeFromPackage 				#enablementSelector: #anySelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #LoadAll #catalogID: #store #defaultString: 'Load All') 				#nameKey: #loadAll 				#value: #loadAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{UserMessage} #key: #FileOutAll #catalogID: #store #defaultString: 'File Out All...') 				#nameKey: #fileOutAll 				#value: #fileOutAll ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Browser" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Definition 					#defaultString: '&amp;Definition' 					#catalogID: #store ) 				#nameKey: #definition ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Help 								#defaultString: 'Help' 								#catalogID: #store ) 							#nameKey: #briefHelp 							#value: #briefHelp 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Topics 								#defaultString: 'Topics' 								#catalogID: #store ) 							#nameKey: #topics ) ) #(2 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Browser" selector="readOnlyCodeMenu">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ElementView class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="emptyInImage">emptyInImage	"UIMaskEditor new openOnClass: self andSelector: #emptyInImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 20 0 0 0 34 0 0 0 65 0 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs" selector="emptyOutImage">emptyOutImage	"UIMaskEditor new openOnClass: self andSelector: #emptyOutImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 255 128 0 0 65 0 0 0 34 0 0 0 20 0 0 0 8 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs" selector="fullInImage">fullInImage	"UIMaskEditor new openOnClass: self andSelector: #fullInImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 28 0 0 0 62 0 0 0 127 0 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs" selector="fullOutImage">fullOutImage	"UIMaskEditor new openOnClass: self andSelector: #fullOutImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 255 128 0 0 127 0 0 0 62 0 0 0 28 0 0 0 8 0 0 0 0 0 0 0])</body></methods><methods><class-id>Store.Glorp.PackageListPane class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SetBlessingLevelDots 								#defaultString: '&amp;Set Blessing Level...' 								#catalogID: #store ) 							#nameKey: #SetBlessingLevel 							#value: #setBlessingLevel 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOutSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Graph 								#defaultString: '&amp;Graph' 								#catalogID: #store ) 							#nameKey: #Graph 							#value: #graphSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_EnclosingBundles 								#defaultString: '&amp;Enclosing Bundles' 								#catalogID: #store ) 							#nameKey: #enclosingBundles 							#value: #enclosingBundles 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ContainedI_tems 								#defaultString: 'Contained I&amp;tems' 								#catalogID: #store ) 							#nameKey: #ContainedItems 							#value: #containedItems 							#enablementSelector: #selectionIsBundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Load 								#defaultString: '&amp;Load' 								#catalogID: #menus ) 							#nameKey: #Load 							#value: #loadSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_MergeIntoImage 								#defaultString: '&amp;Merge Into Image' 								#catalogID: #store ) 							#nameKey: #Merge 							#value: #mergeIntoImage 							#enablementSelector: #atLeastOneVersionSelectedAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReconcileImageWithSelection 								#defaultString: '&amp;Reconcile Image with Selection' 								#catalogID: #store ) 							#nameKey: #Reconcile 							#value: #reconcile 							#enablementSelector: #oneItemAndInImage ) ) #(3 2 4 3 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.PackageListPane class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 160 568 360 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#flags: 15 					#model: #itemsInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #browseSelectedVersion ) 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UserGroupPrivliges #catalogID: #store #defaultString: 'User / Group Privliges') 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1233 965 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 70 0.5 30 0 -3 1 220 0 ) 					#name: #packageID 					#model: #packageList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange 						#requestValueChangeSelector: #listChange ) 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 30 0 -70 0.5 220 0 ) 					#name: #userGroupListID 					#model: #userGroupList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 70 0.5 8 0 ) 					#name: #pundleLabel 					#label: #(#{UserMessage} #key: #PackageC #catalogID: #store #defaultString: 'Package:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 8 ) 					#name: #Label2 					#label: #(#{UserMessage} #key: #UserGroup #catalogID: #store #defaultString: 'User/Group:') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 37 0 60 0.5 72 0 ) 					#name: #assignOwner 					#model: #assignOwner 					#label: #(#{UserMessage} #key: #MakeOwner #catalogID: #store #defaultString: 'Make Owner') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 84 0 60 0.5 119 0 ) 					#name: #grantRead 					#model: #grantRead 					#label: #(#{UserMessage} #key: #GrantRead #catalogID: #store #defaultString: 'Grant Read') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 131 0 60 0.5 166 0 ) 					#name: #grantPublish 					#model: #grantPublish 					#label: #(#{UserMessage} #key: #GrantPublish #catalogID: #store #defaultString: 'Grant Publish') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 178 0 60 0.5 213 0 ) 					#name: #revokeRights 					#model: #revokeRights 					#label: #(#{UserMessage} #key: #RevokeRights #catalogID: #store #defaultString: 'Revoke Rights') 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 227 0 -3 1 0 0.978972 ) 					#name: #privilegeText 					#model: #privilegeText 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="menuBarSkeleton">menuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(1 ) #(#closeRequest ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 					#(#{Kernel.UserMessage} 						#key: #_Edit 						#defaultString: '&amp;Edit' 						#catalogID: #UIPainter)				#nameKey: #Edit 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&lt;new item&gt;' 							#value: #textMenu ) ) #(1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #listTitle 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1650 1050 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 1 -1 0.32 ) 					#name: #ListOfThings 					#minorKey: #listSpec 					#clientKey: #listOfThings ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0.32 -1 1 -25 1 ) 					#name: #DefinitionText 					#model: #definition 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -1 0.32 -1 1 1 0.32 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'ListOfThings' 					#belowWidgets: 'DefinitionText' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -23 1 -1 1 -1 1 ) 					#name: #Status 					#model: #status 					#style: #default 					#isReadOnly: true 					#type: #text ) ) ) )</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool class</class-id> <category>resources</category><body package="Store-UI" selector="textMenu">textMenu	"Tools.MenuEditor new openOnClass: self andSelector: #textMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#nameKey: #copySelection 				#value: #copySelection 				#enablementSelector: #atLeastOnePundleVersionSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #find 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #findNext 				#value: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAll 					#defaultString: 'Select All' 					#catalogID: #menus ) 				#enablementSelector: #atLeastOnePundleVersionSelected 				#nameKey: #selectEntireText 				#value: #selectEntireText ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #listTitle 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 375 200 1125 700 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 25 0 -1 1 -1 0.37 ) 					#name: #ListOfThings 					#flags: 0 					#minorKey: #listSpec 					#clientKey: #listOfThings ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 26 0.37 -1 1 0 1 ) 					#name: #DefinitionText 					#model: #definition 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 -1 0.37 -1 1 1 0.37 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'ListOfThings' 					#belowWidgets: 'commentLabel DefinitionText' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 1 0.4 2 0 ) 					#name: #versionsLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsC 						#defaultString: 'Versions:' 						#catalogID: #labels ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 1 0.4 3 0.37 ) 					#name: #commentLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #CommentC 						#defaultString: 'Comment:' 						#catalogID: #labels ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 25 0 -1 0.4 -1 1 ) 					#name: #selectionTool 					#clientKey: #searchModule ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 2 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundlesAndPackagesC 						#defaultString: 'Bundles and Packages:' 						#catalogID: #labels ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.4 25 0 1 0.4 -1 1 ) 					#name: #ResizingSplitter2 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'selectionTool' 					#belowWidgets: 'versionsLabel ListOfThings commentLabel ResizingSplitter1 DefinitionText' ) ) ) )</body></methods><methods><class-id>Store.Glorp.PublishedPundleVersionsTool class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Packages 					#defaultString: '&amp;Packages' 					#catalogID: #UIPainter ) 				#nameKey: #Packages 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&lt;new item1&gt;' 							#value: #packagesMenu ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Comment 					#defaultString: '&amp;Comment' 					#catalogID: #UIPainter ) 				#nameKey: #Comment 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&lt;new item2&gt;' 							#value: #textMenu ) ) #(1 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="packagesMenu">packagesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packagesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Refresh 					#defaultString: 'Refresh' 					#catalogID: #store ) 				#nameKey: #UpdatePundleItems 				#value: #refreshList ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-02 keyboard accelerators</category><body package="Store-Code Comparison" selector="_0599Gap">_0599Gap	&lt;paragraph&gt;	^PixelSpace height: 15</body><body package="Store-Code Comparison" selector="_0600Header">_0600Header	&lt;paragraph&gt;	^self		sectionHeader: #comparisonHelpKeyboardHeader &gt;&gt; 'Keyboard Accelerators'				&lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0605ShiftClickHeader">_0605ShiftClickHeader	&lt;paragraph&gt;	^self graphic: (self				keyboardOne: 'Shift'				two: nil				clickOver: ComparisonIcons seePackage)		explanation: #comparisonHelpKeyboardShiftClickHeader				&gt;&gt; 'Enable the selected package only; disable all other packages in the header band.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0606ShiftClick">_0606ShiftClick	&lt;paragraph&gt;	^self graphic: (self				keyboardOne: 'Shift'				two: nil				clickOver: ComparisonIcons collapsed)		explanation: #comparisonHelpKeyboardShiftClick				&gt;&gt; 'Toggles not only the current element''s expansion, but causes all elements at the same level and in same section to match the end state of the target. Handy for show/hide all the changes in given block.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0607ShiftOptionClick">_0607ShiftOptionClick	&lt;paragraph&gt;	^self		graphic: (VisualRow withAll: (Array						with: (self keyboardGraphic: 'Shift')						with: (self keyboardGraphic: 'Alt')						with: (VisualStack with: ComparisonIcons collapsed								with: ComparisonIcons mouseClick)))		explanation: #comparisonHelpKeyboardShiftAltClick				&gt;&gt; 'Toggles not only the current element''s expansion, but causes all visible elements at the same level to match the end state of the target. Handy to show/hide everything in one click.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0610DownArrow">_0610DownArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Down' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardDownArrow				&gt;&gt; 'Advances focus to the next downward visible element.' &lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0611UpArrow">_0611UpArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Up' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardUpArrow				&gt;&gt; 'Advances focus to the next upward visible element.' &lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0612RightArrow">_0612RightArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Right' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardRightArrowOrTab				&gt;&gt; 'Expands the current element, if it is collapsed.' &lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0613LeftArrow">_0613LeftArrow	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Left' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardLeftArrow				&gt;&gt; 'Collapses the current element, if it is expanded.' &lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0614Tab">_0614Tab	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Tab' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardRightArrowOrTab				&gt;&gt; 'Expands the current element, if it is collapsed.' &lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0615Return">_0615Return	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Enter' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardReturn				&gt;&gt; 'Toggles the current element''s expanded state.' &lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0616Space">_0616Space	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Space' two: nil clickOver: nil)		explanation: #comparisonHelpKeyboardSpace				&gt;&gt; 'Cycle to next change. Advances focus to next expandable element and expands it, collapses the current if expanded.'					&lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0617ShiftSpace">_0617ShiftSpace	&lt;paragraph&gt;	^self graphic: (self keyboardOne: 'Shift' two: 'Space' clickOver: nil)		explanation: #comparisonHelpKeyboardShiftSpace				&gt;&gt; 'Cycle to previous change. Advances focus to previous expandable element and expands it, collapses the current if expanded.'					&lt;&lt; #IDE</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-10 general icons</category><body package="Store-Code Comparison" selector="_0699Gap">_0699Gap	&lt;paragraph&gt;	^PixelSpace height: 15</body><body package="Store-Code Comparison" selector="_0700Header">_0700Header	&lt;paragraph&gt;	^self sectionHeader: #comparisonHelpIconHeader &lt;&lt; #IDE &gt;&gt; 'Icon Reference'</body><body package="Store-Code Comparison" selector="_0710Modify">_0710Modify	&lt;paragraph&gt;	^self graphic: ComparisonIcons modify		explanation: #comparisonHelpIconGeneralModify &lt;&lt; #IDE				&gt;&gt; 'Methods, package properties, or shared variable initializers that were changed.'</body><body package="Store-Code Comparison" selector="_0720Add">_0720Add	&lt;paragraph&gt;	^self graphic: ComparisonIcons add		explanation: #comparisonHelpIconGeneralAdd &lt;&lt; #IDE				&gt;&gt; 'Methods, package properties, or shared variable initializers that were added.'</body><body package="Store-Code Comparison" selector="_0730Remove">_0730Remove	&lt;paragraph&gt;	^self graphic: ComparisonIcons remove		explanation: #comparisonHelpIconGeneralRemove &lt;&lt; #IDE				&gt;&gt; 'Methods, package properties, or shared variable initializers that were removed.'</body><body package="Store-Code Comparison" selector="_0740Category">_0740Category	&lt;paragraph&gt;	^self graphic: ComparisonIcons moveCategory		explanation: #comparisonHelpIconGeneralMoveCategory &lt;&lt; #IDE				&gt;&gt; 'Methods or shared variables which were moved to a different category.'</body><body package="Store-Code Comparison" selector="_0750Package">_0750Package	&lt;paragraph&gt;	^self graphic: ComparisonIcons movePackage		explanation: #comparisonHelpIconGeneralMovePackage &lt;&lt; #IDE				&gt;&gt; 'Methods, classes, namespaces, or shared variables which were moved to a different package.'</body><body package="Store-Code Comparison" selector="_0760MoreInfo">_0760MoreInfo	&lt;paragraph&gt;	^self graphic: ComparisonIcons moreInfoHandle		explanation: #comparisonHelpIconGeneralMoreInfo &lt;&lt; #IDE				&gt;&gt; 'More info in popup which shows category/namespace/package information, when mouse rests over this icon.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-15 code component icons</category><body package="Store-Code Comparison" selector="_1300Header">_1300Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconCodeComponents &lt;&lt; #IDE				&gt;&gt; 'Code Component Icons'</body><body package="Store-Code Comparison" selector="_1310PackageProperties">_1310PackageProperties	&lt;paragraph&gt;	^self graphic: ComparisonIcons packageProperties		explanation: #comparisonHelpIconPackageProperties &lt;&lt; #IDE				&gt;&gt; 'Grouping icon for one or more property changes to a given package.'</body><body package="Store-Code Comparison" selector="_1320BundleProperties">_1320BundleProperties	&lt;paragraph&gt;	^self graphic: ComparisonIcons bundleProperties		explanation: #comparisonHelpIconBundleProperties &lt;&lt; #IDE				&gt;&gt; 'Grouping icon for one or more property changes to a given bundle.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-13 class icons</category><body package="Store-Code Comparison" selector="_1000Header">_1000Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconClassHeader &lt;&lt; #IDE				&gt;&gt; 'Class Specific Icons'</body><body package="Store-Code Comparison" selector="_1010Superclass">_1010Superclass	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifySuperclass		explanation: #comparisonHelpIconModifySuperclass &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class''s superclass.'</body><body package="Store-Code Comparison" selector="_1020BehaviorType">_1020BehaviorType	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyBehaviorType		explanation: #comparisonHelpIconModifyBehaviorType &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class''s type (e.g. #none, #objects, #ephemeron, #bytes, etc).'</body><body package="Store-Code Comparison" selector="_1030InstanceVariables">_1030InstanceVariables	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyInstanceVariables		explanation: #comparisonHelpIconModifyInstanceVariables &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in the class''s instance variables.'</body><body package="Store-Code Comparison" selector="_1040ClassInstanceVariables">_1040ClassInstanceVariables	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyClassInstanceVariables		explanation: #comparisonHelpIconModifyClassInstanceVariables &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in the class''s class instance variables.'</body><body package="Store-Code Comparison" selector="_1050Attributes">_1050Attributes	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyClassAttributes		explanation: #comparisonHelpIconModifyClassAttributes &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class''s attributes array.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-11 binding icons</category><body package="Store-Code Comparison" selector="_0800Header">_0800Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconAllObjects &lt;&lt; #IDE				&gt;&gt; 'Class/Namespace/Shared Variable Icons'</body><body package="Store-Code Comparison" selector="_0810IsPrivate">_0810IsPrivate	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyIsPrivate		explanation: #comparisonHelpIconModifyIsPrivate &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in an object''s private status.'</body><body package="Store-Code Comparison" selector="_0820Add">_0820Add	&lt;paragraph&gt;	^self graphic: ComparisonIcons addedBindingOverlay		explanation: #comparisonHelpIconAddOverlay &lt;&lt; #IDE				&gt;&gt; 'Placed over some icons when the class/share/namespace is entirely new.'</body><body package="Store-Code Comparison" selector="_0830Remove">_0830Remove	&lt;paragraph&gt;	^self graphic: ComparisonIcons removedBindingOverlay		explanation: #comparisonHelpIconRemoveOverlay &lt;&lt; #IDE				&gt;&gt; 'Placed over some icons when the class/share/namespace is entirely removed.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-14 shared variable icons</category><body package="Store-Code Comparison" selector="_1100Header">_1100Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconSharedVariableHeader &lt;&lt; #IDE				&gt;&gt; 'Shared Variable Specific Icons'</body><body package="Store-Code Comparison" selector="_1110IsConstant">_1110IsConstant	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyIsConstant		explanation: #comparisonHelpIconModifyIsConstant &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a shared variable''s contstant status.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-12 namespace icons</category><body package="Store-Code Comparison" selector="_0900Header">_0900Header	&lt;paragraph&gt;	^self subsectionHeader: #comparisonHelpIconClassAndNamespaceHeader &lt;&lt; #IDE				&gt;&gt; 'Class &amp; Namespace Specific Icons'</body><body package="Store-Code Comparison" selector="_0910Comment">_0910Comment	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyComment		explanation: #comparisonHelpIconModifyComment &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class or namespace''s comment.'</body><body package="Store-Code Comparison" selector="_0920Imports">_0920Imports	&lt;paragraph&gt;	^self graphic: ComparisonIcons modifyImports		explanation: #comparisonHelpIconModifyImports &lt;&lt; #IDE				&gt;&gt; 'Indicates a change in a class or namespace''s imports.'</body></methods><methods><class-id>Tools.ComparisonUsersManual</class-id> <category>paragraphs-01 overview</category><body package="Store-Code Comparison" selector="_0400Header">_0400Header	&lt;paragraph&gt;	^self sectionHeader: #comparisonHelpOverviewHeader &gt;&gt; 'Overview' &lt;&lt; #IDE</body><body package="Store-Code Comparison" selector="_0410Explanation">_0410Explanation	&lt;paragraph&gt;	^self graphic: (PixelSpace width: 16)		explanation: #comparisonHelpOverviewExplanation &lt;&lt; #IDE				&gt;&gt; 'The comparison tool is broken into two parts.A header band at the top of the comparison tool shows the packages for which actual differences were found. In some cases, this may be a smaller subset than the original inputs specified. The green check/red disable icon to the left of each row can be used to enable whether changes for that packages are shown in the main comparison area.The main comparison area below the header band shows code changes, grouped by classes, and other code structuring elements. They may be expanded and collapsed to show/hide more details.'</body></methods><methods><class-id>Tools.ComparisonUsersManual class</class-id> <category>tags</category><body package="Store-Code Comparison" selector="paragraphTag">paragraphTag	&lt;pragmas: #instance&gt;	^#(#paragraph)</body></methods><methods><class-id>Store.MergeIcons class</class-id> <category>png imports</category><body package="Store-Merge Management" selector="add">add	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'add.png'&gt;	&lt;md5sum: #[71 51 229 168 198 120 205 222 117 116 146 100 74 123 200 40]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@PAA0EKA4@G"@1.CJH[  :ZCWPM[0%PBRDCG0L@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@HSP# LIPP?&lt;S%//?9?/''????????????+&gt;.#&lt; LE.)@-(B1P@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@G0JW0+&gt;SZ(S?&gt;K87_?Z==W?0.67?;[**/&gt;9:*??3_KD?&gt;[;8/&gt;08J[_CGHLH0@@@@@@@@@@@@@@@@@@@E$HR #&gt;DY(Q?:S!%_&gt;R7G3?X\\V?5N6EO="-#/?X+T:?5C@E_=:4U''?)NJT?6;DR]\JX@(L@@@@@@@@@@(@@ C(CW(M?4^7EO=[01W?MK$T?1R3EO=7/6C???????G4;?&lt;R)QK?EKXT?4.?E_=%1"/?DY(Q 0L]@0@@@@A^A# F?0&gt;MC?&lt;(,AO?EKLT?1N.D?&lt;S+!O?[+5Q???????0=N??D*DR?1N-D?&lt;S,AO?K[LT?1J$D.\KX0,J@@@@(@)[B/&lt;P#1C?D*DR?1F D_=P*1O?R*4S?9?L%_??????&gt;_+8?4&amp;''D/=M+AO?Q:TR?1J$D/&lt;Q&amp;1G?CW0MNP@@@K8JW@+?C8$O?1BSDO=@(1K??????????????????????????????????????=_&amp;5_&lt;P$1C?DH&lt;P?05:CU,@@@B:BULI?0:BC/&lt;O" ??MY0Q???????????????????????????????????????T9MK?C8$O?0&gt;IC?&lt;M]@5\@@@@%@T0A_&lt;M^ 7?C(PN?0:DC/&lt;N!@;?C8 O?6Z-S???????&lt;OS/?09?C/&lt;O! ??C(DN?0:EC/&lt;N P;&gt;B6$KN0@@@D(@@@C?CF4L?0:@C/&lt;N P;?C8XO?0&gt;LC?=[+C''??????&gt;?3;/&lt;N!@;?C8(O?0:DC/&lt;N @;?CW(M8@]@A1T@@@@C@@@@40]BA?&lt;M^ 7?CW0M?09&gt;C/&lt;N  ;?TJH_??+:&gt;/?$:^O?CW0M?0:AC/&lt;M_@7?CW0M?01+CHT@@@@A@@@@@@@@@C(@@@C7B%8J?09&gt;C/&lt;N_ ;?C''&lt;N?05:C_&lt;M]@7?CWXM?09&gt;C/&lt;N_P;?C(@N?054C\,EJ0TZ@@@@@@@@@@@@@@@@@@@@UP@@@OLJW@+?C''8N?0:EC/&lt;N!@;?C(LN?0:DC/&lt;N!P;?C(PN?012CL&lt;EK0T0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@2@@@@.0T+A_,KYP/?CWXM?09=C/&lt;M^ 7?CF&lt;L:0!NBIX@@@@!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@/@@@@[@@@@H$@@@BE@@@@W @@@BX@@@@E@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-Merge Management" selector="applied">applied	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'applied.png'&gt;	&lt;md5sum: #[92 255 20 177 35 92 101 89 8 170 228 172 221 7 84 248]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???2[XM/&gt;@75/?,&gt;U&lt;?&gt;[*%_?&amp;;I;?,&gt;*U?8C%_O&lt;&amp;75/?@O???0C???&lt;@????@O???0C???&lt;@????@\$@&gt;WCSGO?664_??&gt;M1???+&amp;_??&lt;+/???WL???2.???:9''?=.M1?7C[Q?&lt;A413?@O???0C???&lt;@????@[0@:[WJ@O/?5BK??=5N???%^/??;*[???[R???=&gt;_??=-K??&gt;:&amp;???%^/??7T;?-]P"?0GJ@O,@????@O???7B;@N#?2PC9?=L_???\R/??9GW??&gt;2^???31O??==_???OD???,''/??:9+??=9U???SG?=02PC9@O???2Z+@]O6.PC%?&lt;X@=_?QD???6S/??&gt;A"???''!O??;I???&gt;:*???,''???:9#???;;???=&lt;???64''?=,X@=RZ9@NV@)0GN?;PA7/?A@N??3PC&gt;?=P$???[Q_??8FK??&gt;Q6???&amp;__??9G_???#Z????????==_??&lt;8E?/?A@N=?-@G^,:DB1?&gt;-@][?. C&amp;?&lt;T@=O?OA/??5BO??=$:???\R/??7T???&gt;*T?????????//??= 4???E@OS?. C&amp;,:4A5.ZZ@+;?) GM?;DA6?&gt;;@N#?32;6?&lt;4@?/?QD_??41;??= 9???&lt;&lt;/???????&gt;Z@???E@OS?.0C(?;DA6&gt;Z&amp;@\7&amp;$ J4?94B0_&gt;''@\??-!G\??//?_?]]?[?1 C5?&lt;$@&gt;_?.+/7???????SP?_?AA^;?.PC%?;DA6/&gt;''@\?&amp;''PKA,8$C*O&gt;S@+W?''@KA?&lt;EQ7O???????????=]0;??PTN????????;:???ELN#?,0G]?:4A5_&gt;%@\3?''@KA,9LB-XA?@93?"@N(?9DB,?&gt;Y@+7?4HG"????????????&gt;/C=???????V N+?* GR?:XA3_&gt; @,W?&amp;PJ=?9DB,7&gt;H@: &amp;^0NW=''4C&amp;/&gt;E@:S?#PN-?9LB-_?L ]7????????????-4OS?(@_D?90B0O&gt;X@+/?$0J5?84C+_ZE@:P&amp;_PNZ@O???7A;@9_?^0NW?8@C''_&gt;E@:S?" N*?&lt;ZA5??=&gt;/7?)SK@?9@B,_&gt;M@:;?" N*?8TC)O&gt;@@950^0NW@O???0C???&lt;A^0NW-W,C%?=;@9_?^0NW?70C&amp;_=?@93?&amp;3^3?8HC(O&gt;A@9??_0N\?70C&amp;_=;@9^5^0NW@W,C%0C???&lt;@????@O???0E;@9]0^0NW='',C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?Y;@9]0^0NW@W,C%0C???&lt;@????@O???0C???&lt;@????@O???2Y;@9^@^0NW,7,C%&gt;Y;@9_&amp;^0NW,7,C%8A;@9\&amp;^0NW@O???0C???&lt;@????@O???0@a')))] once</body><body package="Store-Merge Management" selector="applyAll">applyAll	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'applyAll.png'&gt;	&lt;md5sum: #[145 206 119 52 193 243 145 188 149 70 17 242 37 0 15 225]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????N-HV?:?^T??%:H_?9^2^?:?(!?&lt;:7%O?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????^LP@&lt;?7VJ/??87C???B4???:9???&lt;KS??^M0?7#VJ/&lt;@????@O???0C???&lt;@????@O???0C???&lt;:41[?0]%K&gt;??$^_;?:)K??&gt;Y&gt;???*%/??=\;??&gt;&gt;0???41/?=6#??N,P@&lt; C???&lt;@????@O???0C???=81@C2?]X*???#\O??&lt;KS???+''???0-O??87C??==[???53_???N7??=L\?:&gt;=@N(@????@O???3+RE/?A6T/;?&gt;Q9?/?*$/??9'';??&gt;*U???53/??;;C???SF???ZPO??&lt;,W&lt;?==Z???C@OK%, G\@O???7#D@OO=5"+??&gt;M0???0-O??&gt;._???B4???#\O??75/???WM???&lt;;_??413??&lt;04&lt;O&gt;?@N3?, G]9ZLB2S*-@][=1@C2?=T%???"Z/??;*''???WN???/,O??=L[??=)@???21_3?75+??&lt;L@&lt;/&gt;3@=7?* GR?9&lt;B1Z&gt;R@+R/*@GO?;4@:/?PB???64W??&gt;Q3???''!/??=\7???3-???SGO??23S0?;&lt;@;O&gt;2@]7?( KH?9PB-?6K@:0: @N]9Y8B0?&gt;2@]3?11C3?=DP???WL_??87K????????_V/??00C2?;LC7O&gt;*@]K?''0KE?84B+?5&gt;@9-8^0NW@O???&gt;VR@+S?(0KI?&gt;BW&lt;_?%%?_?2P+7??#^?/?+)_3?/0C,?;HA7_&gt;"@,#?%@J7?8,C+LE&lt;@9$:^0NW@O???0C???&gt;/ 0N!?9HB-O&gt;:R]W??_#&gt;??OX&gt;_?89?3?-1O]?:(A4/&gt;_@,W?#PJ.?W8C&amp;7!;@)\@????@O???0C???&lt;@????N'',C%?6@@97?"0N,?;II2??&lt;=?7?.5GT?9(B//&gt;T@+_?"0N,0W0C&amp;#);AIT@????@O???0C???&lt;@????@O???0C???=8^0NW?W,C%?=&gt;@9/?%".0?8TC(?&gt;C@:G=_ N[^G,C%0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???3);@9^/^0NW9W,C%&gt;U;@9^/^0NWN'',C%0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0@a')))] once</body><body package="Store-Merge Management" selector="bigApply">bigApply	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'bigApply.png'&gt;	&lt;md5sum: #[250 19 222 247 79 187 80 28 16 208 28 103 218 247 16 229]&gt;	^[AlphaCompositedImage image: ((Image extent: 24@24 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???1[]S?=K8V_?_&gt;U&lt;?;K)#/?&amp;:9+?9.2^?;K+&amp;/=?:X;?R&gt;U&lt;?1[!Y?&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;D5R[?_])B??+ W/??9W#??&gt;&amp;P???-)/??&lt;[[???J=???1-/??;Z[??&gt;&amp;P??+%^O==8E;?AM)B?0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???2''QD_?J5";??=1J???!Y???98S??&gt;2_???1./??=-C???#[???64O??&lt;[+??&gt;2_???''!O??8V_?2-1J?2''VK/&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????W,(@&gt;?_QD???53G??=5N???"[O??:H''??&gt;:&amp;???31O??&gt;^G???79???98_??&lt;&lt;S??&gt;:&amp;???("_??8&amp;3??=5N??_WL_=^4QO?@O???0C???&lt;@????@O???0C???&lt;)0PC.=&lt;(@&gt;/?QD/??52???=1L???"Z/??:H_??&gt;6#???2/???==''???+&amp;???76_??&lt;+???&gt;6#???(!???8&amp;+??=1L???WK??74QK?J\(@&gt; C???&lt;@????@O???0R6@^GJ0@C-?&lt;$@&gt;O?PC_??5"+??=-F??? X/??9''7??&gt;.W???/+???&lt;&lt;G???SH???30_??;:???&gt;.W???'' /??&lt;[+??&gt;A ???VJ/??4@7?2,$@&gt;@S@@N4@????@O???764@]??/PC*?&lt;X@=_?NA_??5BC??=$;???^U_??86;??&gt;^D???+%???;ZW??&gt;:*???-)_??:9_??&gt;^D???2/_?????????=???/+O??4QO??&lt;X@=W6=@N(@????E* A4O*1@]/?. C&amp;?&lt;L@&lt;_?K@O3?4QO??=X,???[QO??75/??&gt;M.???&amp;_/??:H#??&gt;"L???("O??9'';??&gt;"J?????_?????????????30???20G&lt;?&lt;L@&lt;_*:@NXV,PG[R:TA3O&gt;.@]_?- G!?;&lt;@;O?G@O[?3 O??=LZ???WLO??64S??=9U??? X/??8&amp;/??&gt;M.???"Z???8FS???''^??????????????75???TIO??10C6?;&lt;@;O&gt;6@^EK+ GW_:DB1?&gt;)@]G?, G\?;(@9/?A@N??2PC8?&lt;&lt;F???SF/??5"3??=$:???[Q/??7D7??=5O???\S_??:9+??????????????????&gt;M.???I@O#?0PC/?;(@9/&gt;2@]1?*PGQ,)0B0_&gt;$@\/?+@GU?;PA7/&gt;;@N#?0 C0?&lt;$@&gt;O?N@/??4QK??=P_???VJ_??52???=\1???\R????__?????????????&lt;;???&lt;$A&gt;O?B@OC?.0C(?;PA7/&gt;,@]V2)@GK9)\B.?&gt;_@,S?)0GN?:8A5?&gt;5@]??.0C''?=MK=O?MG/[?20C;?&lt;8C???PCO??4QG??=DS???3/??????????????==O??3RG6?&lt;D@;?&gt;;@N_?-PG_?:8A5?&gt;''@\;&amp;''0KD9)HB-O&gt;Y@+7?(@KF?:\A3?&gt;.@]_?-PW_??W\&gt;??66?3?2A+2?&lt;X@=_?H@O#?2 C:?=9^?O?????????????????[Z/[?/ C+?;$@9_&gt;4@];?+ GW?:\A3?&gt; @,[&amp;&amp;PJ=,(0C+O&gt;S@+W?&amp; J&gt;?:@B1/&gt;&amp;@\7?26G$????????????=M_;?&lt;HV:?&gt;?@N3?1QS/??+,?/???????????&gt;:&gt;&gt;_&gt;9@^W?-PG ?;DA6?&gt;,@]S?) GM?:@B1/&gt;Z@+:2$0J5_8TC)O&gt;L@:7?$0J5?9$B/O&gt;_@,S?3WW"??????????????????KS&gt;_&gt;;ENK?9ZS4?????????????OS&gt;?;4"8_&gt;0@]+?+PGU?:$A4O&gt;$@,+?''0KD?9$B/O&gt;S@+U?#@N-R7&lt;C''O&gt;E@:S?"0N,?9DB,?&gt;V@++?&amp;0K@?=BA8/?????????????????47/''?????????????????36/&amp;?:(A4/&gt;''@\;?)@KJ?:@B1_&gt;[@,C?% J:?9DB,?&gt;K@:1K!PN$E'',C%?)&gt;@9/?!@N"?8$C*_&gt;N@:??$0J5?9\B.??M ]?????????????????????????????(/?G?( OH?:@B1/&gt;^@,O?&amp;0J??9\B.?&gt;S@+W?# N/?8$C*_*D@:HV_ N[@O???75;@9_?_@NX?8DC''?&gt;F@:W?" N*?88C+?&gt;R@+S?2(G[??????????????????/4?O&gt;''H&lt;[?&amp;PJ&lt;?9\B./&gt;U@+_?$ J4?88C+?&gt;J@:+?! N%?8DC''75&lt;@9 @????@O???0Q;@9_J^0NW?7,C%?=&gt;@9+?  N ?8TC)O&gt;I@:#?"0N,?&lt;ZA5????????????;9+4/&gt;P@+G?#0N0?84C+/&gt;K@:3?"PN(?8TC)O&gt;B@:C?_ NZ2'',C%0Q;@9\@????@O???0C???&lt;)^0NW=7,C%?=;@9_?^0NW?70C&amp;_=?@97?  N ?8PC(/?B ]K?8K?(?8\D)/&gt;F@:W?!PN$?8PC(/&gt;B@:C?_0N]?70C&amp;_=;@9_7^0NWJW,C%0C???&lt;@????@O???0C???&lt;@????W'',C%?];@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=&lt;@9#?!AB^?74C&amp;/==@9''?_@NX?7,C%?=;@9_?^0NW?7,C%?];@9]^^0NW@O???0C???&lt;@????@O???0C???&lt;@????@O???2%;@9_J^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW2'',C%2%;@9\@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;D^0NW_W,C%?);@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?=;@9_?^0NW?7,C%?);@9]=^0NWAG,C%0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???1Y;@9]K^0NW_7,C%;I;@9_&amp;^0NW9'',C%;I;@9]?^0NWR7,C%1Y;@9\@????@O???0C???&lt;@????@O???0C???&lt;@????')))] once</body><body package="Store-Merge Management" selector="bigResolve">bigResolve	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'bigResolve.png'&gt;	&lt;md5sum: #[179 110 167 90 101 102 45 196 132 249 142 26 78 28 253 43]&gt;	^[AlphaCompositedImage image: ((Image extent: 24@24 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???=E"X&amp;LRCH2L C???&lt;C@J+?P0"7?70F*_=.A9''?N0RJ?0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???4I4]GS?.K";?5=_XG EM%[HA*+??0":??&lt;G+O??A)3??0VM?&lt;DD_/&lt;1AV7?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???55EQT_?''):!?8:N$N,$UW+?A:[??0"6??&lt;H,O??A:C??0VP??&lt;D _?=@7G?&amp;@I!?1H@U_&lt;@????@O???1L@T_&gt;8@V_?LPU8?0C???&lt;@????@O???0C???&lt;@????@O???0  HBC''[6=2?;2&lt;/?="X6W"BI[+?0"2??&lt;H-O??A:S??0ZU??&lt;E!_??AGW??0I&amp;??TAU/?H@D_?/ AD?? AT???@&amp;O?,@M2?0C???&lt;@????@O???0C???&lt;@????@O???0C???=3PDAC?9.[''_&gt;Q$YO''I51=?0".??&lt;H.O??A:#??0ZX??&lt;E"_??AG''??0M*??&lt;BV/??@D/??0A@??&lt;AS???@%???0M/?3DE__&lt;@????@O???0C???&lt;@????@O???0C???&lt;KE1\W:65-[/&gt;?/&lt;K?Y&amp;])8P"^;O&lt;H./??A:3??0Z\??&lt;E#_??AG7??0M.??&lt;BW/??@T;??0@???&lt;ASO??@%/??0M+?;@D^/&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????^38&gt;O/&gt;W%9+?%YVW9B!! _&lt;H-/??BKC??0^ ??&lt;E$_??AHG??0M2??&lt;BX/??@UO??0AC??&lt;@RO??@U_??0I''??&lt;D]/&lt;1AX_?@O???0C???&lt;@????@O???0C???&lt;@????C1DQD_A)ZV/?0,KE?6%*[M&lt;H).;?BKS??0^$??&lt;F%_??AXW??0Q6??&lt;BY/??@U[??0AG??&lt;@QO??@UO??0I#??&lt;C\/&gt;0AHK?@O???0C???&lt;@????@O???0C???&lt;@????@O???8L:N#+?%IRV?9"X&amp;-&lt;+Y8S?BK#??0^(??&lt;F&amp;_??AX''??0Q:??&lt;CZ/??@%+??0AK??&lt;@PO??@T???0I_??&lt;C[/??AG;?LPVM?0C???&lt;@????@O???0C???&lt;@????@O???1LMCP73YVU''?;&gt;?0/=-[''C^BJ?/?0^,?&lt;@G''_&gt;JA(3?-0Q=??&lt;C[/??@%;??0EO??&lt;@O???@T/??0I[??&lt;CZ/??AG+?,@RJ?0C???&lt;@????@O???0C???&lt;@????@O???0C???&gt;KM3\9?9BP$?&gt;[&amp;9;[K&amp;2E] &amp;/?0C???&lt;@????@O???3XE\_&gt;4@VK??0ES??&lt;@P???@D_??0EW??&lt;BY/??AG[??0VF?2&lt;E$/&lt;@????@O???0C???&lt;@????@O???0C???&lt;XB0,K=6I"X?&gt;;.;;?\WE2Q1XVE C???&lt;@????@O???0C???&lt;@????O0AU?=@@Q???@DO??0ES??&lt;BX??-@7K?\0RC?0X@ O&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????$3H2MO&gt;M#X??''9&gt;"1DUER@C???&lt;@????@O???0C???&lt;@????@O???0H@ O&lt;:@C;?V@AN?4HDX_&lt;D@HC?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????GP$IB_%^W&amp;C?.K";?7Q4]$@\GA0@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???9,0LCC?"X&amp;K?:J")[5IRT(@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???2L@@@C&lt;V5-\?;R4-?=8^G$9G1&lt;_@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&gt;#KB0-?8ZF"O&gt;&amp;)*&amp;6ST5N@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;)@@@@?U]WV_&gt;1,[S?^7-=L2L#H0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????*2 (J/&gt;B (S?***,+5APT C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????L@TEA_=TUEW?+Z60?(B@ Q0$IBP@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???:\%IR[?_7&gt;A;:6-,@9[V5,@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0L@@@A]TEARK*2,+@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????')))] once</body><body package="Store-Merge Management" selector="bigUnresolve">bigUnresolve	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'bigUnresolve.png'&gt;	&lt;md5sum: #[1 41 95 129 190 190 86 13 34 167 223 132 32 105 222 109]&gt;	^[AlphaCompositedImage image: ((Image extent: 24@24 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???1 =OS5NOS4= 34=O[ =OS70O#8&gt;&lt;C8&gt;O+ =OS6COS4=S#4=OQ =OS4@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;FOS4=!34=O_4=OS7?OS4=?#&lt;?O?5QTUG?Y6]''?6]''Y?5QTUG&gt;O3&lt;??34=O_4=OS6GOS4=A#4=OPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???2&lt;=OS7TO#8&gt;?34=O_=(ZF#?"8.K?9*Z&amp;/&gt;\''I3?&amp;9.[?9.[&amp;?&gt;[&amp;9/?&amp;Y&amp;Y?8.K"?=&amp;Y&amp;[?OS4=5C8&gt;O"&lt;=OS4@????@O???0C???&lt;@????@O???0C???&lt;@????Y#4=O_,&gt;O#;&lt;RD!H?8NC ?&gt;Z&amp;)+?&amp;I"X?9^W%?&gt;U%YW?%YVU?9VU%_&gt;U%YW?%YVU?9ZV%/&gt;X&amp;I#? (JB?D]GQ?,&gt;O#9&amp;OS4=@O???0C???&lt;@????@O???0C???&lt;/OS4=&gt;38&gt;O/=[V5/?%IRT?9"X&amp;O&gt;V%)[?%IRT?9JR$/&gt;#(:O?,[F1?;J2,/&gt;$)JS?$)JR?9JR$/&gt;T%IS?%)ZV?9JR$/=ZV%+;O#8&gt;K34=OPC???&lt;@????@O???0X=OS7TO#8&gt;?D!HRO&gt;V%)[?&amp;)*Z?9"X&amp;O&gt;V%)[?.[&amp;9??[6=/??????????????????????&lt;/K2?;V5-_&gt;T%IS?%)ZV?9"X&amp;O&gt;T%IS&lt;RD!H5C8&gt;O X=OS4@????@O???8\=OS7?OS4=?8"H"O&gt;_''9??''Y6]?9.[&amp;?&gt;Y&amp;Y''?2&lt;/K?????????????_7=??????????????????3&lt;?O&gt;(*J#?&amp;Y&amp;Y?9.[&amp;?&gt;]''Y7?!(ZF?34=OX\=OS4@????FC4=O_4=OS7?Z6-+?:R$)O&gt;"(*K?(ZF!?9&gt;_''?&gt;^'');?3L3L?=+Z6/&gt;/+:??''Y6]?:2,+O?9&gt;_''????????????G1&lt;_?''):^?9&gt;_''?&gt;!(ZG?(:N#?6-+Z?4=OS4XOS4=S#4=O_&lt;=OS7?%9^W?:&amp;)*_&gt;''):_?)*Z&amp;?:V%)_&gt;$)JS?)JR$?:J"(/&gt;"(*K?(*J"?:F!(_?''9&gt;_????????????K2&lt;/?)JR$?:V%)_&gt;&amp;)*[?*J"(?9ZV%/&lt;=OS5NOS4= 34=O_9@PDC?+J2,?::.+/&gt;-+Z7?+J2,?:.+*?&gt;***+?*Z&amp;)?:&amp;)*_&gt;)*Z''?*J"(?;&gt;?/??&gt;?/;???????;&gt;?/&gt;9.[''?****?:.+*?&gt;,+J3?+Z6-?:.+*?9@PDBCOS4=.C4=O_5XVE#?-KR4?;N3,?&gt;3,;O?,+J2?;F1,_&gt;0,KC?,KB0?:&gt;/+?&gt;/+:??0&lt;OC??3&lt;?O???????????=ST5O&gt;0,KC?,KB0?;F1,_&gt;2,+K?,;N3?;N3,?5WU5^8OS4=&lt;C8&gt;O/=5]WW?.+*:?;&amp;9._&gt;8.K#?.K"8?;^7-?&gt;7-;_?-+Z6?;Z6-/?@0LC?&gt;/+:????????????7]7]?;Z6-/&gt;6-+[?-;^7?;^7-?&gt;8.K#?.[&amp;9?;&amp;9._=5]WW0O#8&gt;&lt;C8&gt;O/=9^W''?0LC@?;&gt;?/?&gt;?/;??/+:&gt;?;6=/_&gt;=/[7?/[6=?;2&lt;/O? 8NC????????????,;N3?/K2&lt;?;2&lt;/O&gt;=/[7?/[6=?;6=/_&gt;&gt;/+;?/;&gt;??&lt;C@0O=8^G#0O#8&gt;.C4=O_5]WU7?1,[F?&lt;[F1/?E1\W?1LSD?&lt;SD1O?C0&lt;O?0&lt;OC?&lt;KB0/?Z6-+?9^W%?&gt;W%9_?S4=O?0,KB?&lt;OC0??C0&lt;O?0&lt;OC?&lt;SD1O?D1LS?1\WE?&lt;[F1/5]WU68OS4= 34=O_9@PDC?2,+J?&lt;3L3O?K2&lt;/?2&lt;/K?&lt;+J2/?J2,+?2\''I?&lt;''I2_?N3,;?4MCP?=CP4O?L3L3?2\''I?&lt;''I2_?J2,+?2,+J?&lt;+J2/?K2&lt;/?3L3L?&lt;''I2_9@PDBCOS4=S#4=O_&lt;=OS7?/[6=?=KR4/?R4-K?4]GQ?=GQ4_?P4MC?4MCP?=CP4O?0&lt;OC????????????&amp;9.[?4MCP?=CP4O?P4MC?4]GQ?=GQ4_?Q4]G?4-KR?;2&lt;/O&lt;=OS5NOS4=FC4=O_4=OS7?"X&amp;I?=#X6O?X6M#?5=_W?=_W5??W5=_?5=_W?=_W5??2&lt;/K????????????):^''?5=_W?=_W5??W5=_?5=_W?=_W5??X6M#?6M#X?8&amp;I"_4=OS4XOS4=@O???8\=OS7?O#8&gt;?;&gt;?/??^7-;?7-;^?=;^7/?]7]7?7]7]?=7]7_?4=OS????????????-;^7?7]7]?=7]7_?]7]7?7]7]?=;^7/?^7-;?/;&gt;??38&gt;O(\=OS4@????@O???0X=OS7TO#8&gt;?EYVU/?_7=??9^W%?&gt;S$9O?$9NS?9NS$?&gt;O#8??#8&gt;O?8&gt;O#?&gt;O#8??#8&gt;O?8&gt;O#?&gt;S$9O?$9NS?9NS$?&gt;S$9O?^7-;&lt;U%YV5C8&gt;O X=OS4@????@O???0C???&lt;/OS4=&gt;38&gt;O/=?_7??8.K"?&gt;#(:O?(:N#?:N#(?&gt;#(:O?(:N#?:N#(?&gt;#(:O?(:N#?:N#(?&gt;#(:O?(:N#?:N#(?&gt;K"8/=?_7?;O#8&gt;K34=OPC???&lt;@????@O???0C???&lt;@????Y#4=O_,&gt;O#;&lt;U5]W?&lt;#H2O?*:.+?:.+*?&gt;+*:/?*:.+?:.+*?&gt;+*:/?*:.+?:.+*?&gt;+*:/?*:.+?2L#H?E]WU?,&gt;O#9&amp;OS4=@O???0C???&lt;@????@O???0C???&lt;@????@O???2&lt;=OS7TO#8&gt;?38&gt;O/&gt;T%IS?4=OS?&gt;''):_?+:&gt;/?:&gt;/+?&gt;/+:??+:&gt;/?:^'')?=OS4?&gt;T%IS?O#8&gt;5C8&gt;O"&lt;=OS4@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;FOS4=!34=O_4=OS7?OS4=?$IBP/5)ZV''?$)JR?9JR$/5)ZV''&gt;P$IB?34=O_4=OS6GOS4=A#4=OPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???1 =OS5NOS4= 34=O[ =OS70O#8&gt;&lt;C8&gt;O+ =OS6COS4=S#4=OQ =OS4@????@O???0C???&lt;@????@O???0C???&lt;@????')))] once</body><body package="Store-Merge Management" selector="modify">modify	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'modify.png'&gt;	&lt;md5sum: #[72 3 131 105 145 49 119 189 151 180 108 206 108 233 77 0]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@P@FB1K@D*H"@AL2*H\Y-6Z@C/I[0AW''2H@J48@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ED@VZO PH72?&lt;;&amp;???????????????????2&gt;_?&lt;$\[?)@AS01T@BQD@@@@@@@@@@@@@@@@@@@@@@@@@@G4@Z\C&gt;ZZ;??&gt;75???)&lt;???5&gt;/??&lt;;&amp;???Q9???7.;???K8???B7??_@D/PI@@@@@@@@@@@@@@@@@@@@E(@U)7&gt;NH/??;?]??&gt;55???&amp;L#??8N;??=;-???_[_??87B??&gt;%3???0];??9CD?=\@U+4L@@@@@@@@@@,@E2+)@FS(?7R3??&gt;N0/??\;G??56$??=R&amp;???SY_??4&gt;Y??=W''???Y:+??8F:??&gt;Q0???KXC? 0@*SP@@@@A_@DZ@?0A\??=Y(_??VZG???????=A#/??N8''??3&gt;M??&lt;?#_??PH;??4NQ????????X*_??3NC?&gt; @[LTJ@@@@(PA%._&lt;@X???BUW??4^W?_???????????4^W?_=G%?7?Q9_=?4^W?_???????????2!9??&lt;@UO??@G_-NP@@@K8@Z\C?@HO??0A0??=X''N;?????????????????^+S4?7*4=O????????????????&lt;@ZO??@G[??0BB;%,@B@&gt;:@FJ4?0BH&gt;O&lt;@"???PH/+?????????????????0A=9O&lt;@_^S?????????????????@H#9?0BK?/&lt;@_.Y\@@@@$0@&gt;\/&lt;@ .7?@H#9?0BC&lt;O???????????0A=9O&lt;@_^W?@G7$?0A=9_???????????0BH&gt;O&lt;@!?[&gt;@GWVN0@@@D$@C1/?@G_Z?0BD&lt;_&lt;@!_O??????0BG=?&lt;@!?_?@H_7?0BG=?&lt;@"O#?@H_6??????&lt;@!OG?@HG,70AO$AP@@@@C@@@@4PAP$?&lt;@_._?@HG,?0BB;_&lt;@ ?C?@HS2?0BD&lt;_&lt;@!OK?@HO0?0BB;/&lt;@ .7?@HK-?0A658L@C!$A@@@@@@@@@C @@@C6@F"??0BA:?&lt;@ .7?@HG+?0BB;_&lt;@ .7?@HK-?0BB;_&lt;@ ^/?@HK-?0A:7&lt;$@NFXX@@@@@@@@@@@@@@@@@@@@TP@@@OD@YK_?@G7%?0BC&lt;O&lt;@ ?C?@HK.?0BC&lt;O&lt;@ ?C?@HK-?0A76\0@NV$.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@- @3W/$@Z,K?@G_Y?0A:8O&lt;@^M3?@GOS:@AT&amp;YH@DR@^@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@T@@@@*@@@@Y @@@HP@DA9?@@8YV@@@@BL@@@@D@@@@@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-Merge Management" selector="move">move	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'move.png'&gt;	&lt;md5sum: #[237 46 53 216 42 68 14 118 233 146 53 136 217 138 240 217]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@A&lt;UA@@_EPP@G1TD@A&lt;UA@P/G0UKX$DJ"H9^C*J([1FZ''6$P[7!OCBENM@ @G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UAEA3S@3 )&amp;8Q??[V(_?;;=/??_#/??;9&lt;_?;;][&lt;;J(&gt;)IQ"C1R"Z1@@G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UAG1:TP3&gt;-'' R??+(2??99LC?=L:N??SM#_?54IS?==2/??/,4/?32(__''V PH&gt;*"K@@_EPP@G1TD@A&lt;UAE%5SP3&gt;*F&lt;Q??KD]??/.E7?4(,U?&gt;:3T_?&gt;&gt;/O?&lt;K-#?&lt;^DEO?+)#W?&lt;,Q9?&gt;&amp;\G]^WY@&lt;L:*@%@A&lt;UA@(5H0[(#%8N?;=&gt;D?&gt;&lt;_AO?-G\R?:52D_?*(BW??/3:??;&lt;&gt;O?21G''?.G(R?&lt;&amp;EEO?N"AW?*F&lt;Q &gt;BTE @_EPQ^ZDTK?9%%C?&gt;+\QG?$&amp;DO?9I!C?&gt;RXP??:*@%??;&lt;&gt;/?&gt;?O+??/38??[W)O&gt;1]QK?/78S?:=4D.^LWP8J:*H,(HAUC_&gt;]ZAC?''6$P??;9&lt;_?&gt;?O+??/38??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+?&gt;.#K?:-1D_&gt;([1G?#E4NN_B;X;:@UP7?%VLO?9I!C??&gt;&gt;_G??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&lt;&lt;&gt;S?)&amp;8Q?8%[C%/-+TR: ETM?9I!C?&gt;LWP;??_#/??;&lt;&gt;O?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+?==2/?9Q"C?&gt;CU05\;J-@%II!C?&gt;IV0;?!U M??;9&lt;_?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O+??/3:??;&lt;&gt;/?&gt;?O#?&lt;,Q9?89^C/&gt;PW0;&gt;^D&lt;LN?G@[$+J!QS?_EHM?8UXC_&gt;LWP;?#E4N?81]C/&gt;*\AG??/3:??;&lt;&gt;/?&gt;&gt;?[?::T2?81]C/&gt;NW ;?"U,N8GMLCAW/-% C%VLO48AUC_&gt;GVP;?"U,N?81]C/&gt;PW0;?*7DQ??;&lt;&gt;/?==./?)&amp;8Q?81]C/&gt;LWP;?#E4N?7)QCHWJ!QPA''V P@A&lt;UAC+-+4''7^D&lt;L?81]C/&gt;LWP;?#E4N?:)0D_?::\;?%VLO?81]C/&gt;LWP;?#%8N?8MWC\-3S@0Z&lt;,Q9@A&lt;UA@@_EPP@G1TDU^6/Q?M8S03?#E4N?9I!C?&gt;YYP??$&amp;DO?9I!C?&gt;RXP??$&amp;DO?8EUC\=3S@00&lt;,U:@A&lt;UA@@_EPP@G1TD@A&lt;UA@@_EPP2&lt;K1%.8UXC_-8S03?!U M?81]C/&gt;IV0;? ETM:7UMCIZ+\QD!&lt;,Y&lt;@A&lt;UA@@_EPP@G1TD@A&lt;UA@@_EPP@G1TD@A&lt;UA@WN"AT/&lt;[=,[N*!I8''J!QRE4(,UW.2)N2[21G\E3( U@A&lt;UA@@_EPP@G1TD@A&lt;UA@@a')))] once</body><body package="Store-Merge Management" selector="remove">remove	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'remove.png'&gt;	&lt;md5sum: #[102 212 105 10 137 195 5 220 107 214 246 119 240 125 68 194]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@PDABYKG05&lt;"DT1.JI%VMZZVT/M[2&lt;Q''BDSBU\@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@E@%DIO XEGX?&lt;3J&gt;O?6=_;?&gt;/''&gt;??''9?/?*:_3&lt;&amp;YO,)C8U01QOSGX@@@@@@@@@@@@@@@@@@@@@@@@@@G0#D:/&gt;^F7(?&gt;_&amp;?O?#8_/?4=G:?&lt;7J&gt;_?N2?''?6='';?&gt;+)?O?B/?#_R"7PH8VC*0@@@@@@@@@@@@@@@E$&amp;DI_&gt;U#?"?;&gt;;=?&gt;3,N_?)JC!?9BE&lt;_&gt;I_?G?#HK1?9NK&lt;/&gt;4,-''?/[''7?9&amp;R&lt;=]CE,,L XBK@@@@@@(EAR;(JQ[J?8M9&lt;O&gt;W$.S?:N#.??S4=?&gt;A^]3?ZUW,?6!V;O&gt;:.NG??/;&gt;?;:&lt;7/&gt;W#?K?TSG% 7)33P@]GQ5^G@:C?3\X7O=0X^7?$X3W??7=?_??????=OS7?7]/4_&gt;4,.C??/;&gt;???????]7N3?]F#%?5\::^\.E\DJ!(ZG(A$T,?&lt;1F^G?RQ''%?5@,9?&gt;F MW??_7=???????=?_7??/;&gt;???????[6./?VT_X?5@(9?&lt;&gt;F^W?E![MNZV$0K8TEK#?FA#\?2XY8?&lt;5F^W?MA''#?7973??&gt;?/;????????????\6&gt;+?O1_N?3\Y9_&lt;/F^S?FQ''#?1XV3U.P#\N:EAR4?1\W5_&lt;XFM3?FA#^?1\W5O&gt;()]7??/;&gt;????????????=OS7?5QC2?&lt;XFM7?FA#]?1 X6/&lt;UE\Q\#X*&lt;%C$T._&lt;VE,+?E1_U?1XV3O&gt;!''-/??/;&gt;???????_7&gt;+??O3&lt;???????3&lt;?[?PAWC?1\W5_&lt;WE=O&gt;EAR6N:*)/T) V);?EAR;?1\W3?=#V\''??/;&gt;???????Q3&gt;''?EQW@?5YH1??&lt;?O7??????&gt;7-=O&lt;TEK/?E![J8ADQ''!V (J@CRT!M41LS,O&lt;VE,#?EQW@?:Z#7O?M2&gt;#?EQV&gt;?1\W3?&lt;VE,7?SC#D??W4&gt;O&lt;8E[3?E![I?1PT-8U!WJLASD1L@@@@@C*O#[''7D1N.?1XV2_&lt;UE\C?EQV=?1XV2/&lt;VE,+?E![J?1XV2_&lt;TEK[?E![I?1TU/&lt;,PDILZ,;N3@@@@@@@@@@@@E1\WUX:K0?LSD:/?EQWD?1\W3/&lt;WE&lt;;?E![M?1XV3O&lt;VE,7?E![J?1PT.,&lt;PDIH0,+J8@AXVE @@@@@@@@@@@@@@@@@]GQ42)JJ:.2$R(?,SD:3?EAR:?1TU0O&lt;UE[??EAR5:1DQ''IYNQ9X!-+V7@A8^G @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@U*Z&amp;(/*Z"6[G-8,H%]U:ZEX%2$W(^E*"Z1,[LEZ&amp;)*@@@@@@@@@@@@@@@@@@@@@@@a')))] once</body><body package="Store-Merge Management" selector="resolved">resolved	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'resolved.png'&gt;	&lt;md5sum: #[197 163 36 206 221 192 224 49 179 30 219 122 236 239 12 45]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&gt;-0&lt;OF-#8&gt;O$$I)_*9BK[?9P^_?8 E"O&lt;''@7C?@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????6''1&lt;_/&gt;C 8W^A9W*?0"9??&lt;G)_??AX;??0Q6?&lt;LBW?= @D#?S0AK?&lt;4BX/&lt;4AG''?@O???0C???&lt;@????@O???6L6M#[?/[7@8"9  /&lt;H,???A:/??0ZT??&lt;D_O??@&amp;W??0EN??&lt;@Q_??@%3?-@M4?0C???&lt;@????@O???0C???&lt;E@@@@8W]7^_&gt;H"H+\BJC+?0"1??&lt;F&amp;/??AHK??0M+??&lt;AT???@C???0EV??&lt;C[/&lt;4AXW?@O???0C???&lt;@????@O???6(0LCO?.K":7SE("O&lt;H-???A9???0VH??&lt;C\_??@%''??0AB??&lt;ATO??@6#?-@Q??0C???&lt;@????@O???0C???&lt;GIBP$9WI2]O&gt;M#YCZBJ3-?0^%??&lt;E#/??AG_??0I_??&lt;@RO??@D+??0I"??&lt;D^_&lt;4AYC?@O???0C???&lt;@????@O???7@+J2;?,+J56CU0"8TG*?&lt;LA)S?NPQ=?;,BY_??@T;??0AD??&lt;BWO??@7O?,0VJ?0C???&lt;@????@O???0C???&lt;JF!(Z:V5-[?&gt;R$)UDB0,K@O???0C???&lt;@????Q0ET?&lt; @O/?$@U[?% M-?2$E!O&lt;@????@O???0C???&lt;@????@O???7\''I2_?+Z600EIRT C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;MI2\'';V]''Z_&gt;X&amp;I(&lt;DQDQ@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???78"H"K?*J"*.E]WVPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;PHB@ &lt;VI"Y_&gt;]''Z@4FQ$Y@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???8P[F17?(*J%*%5]W0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;SJB (3E5]W(J#(:T@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0@a')))] once</body><body package="Store-Merge Management" selector="unresolved">unresolved	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'unresolved.png'&gt;	&lt;md5sum: #[214 166 157 2 216 133 105 9 111 185 28 101 158 232 223 30]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 32 bitsPerPixel: 32 palette: (FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???2T=OS6EO#8&gt;1TIBP/I@PDC2PDA@1TIBP(T&gt;O#8%OS4=@O???0C???&lt;@????@O???0C???&lt;@????@#4=OWP?O3?5P$IB&gt;65-[_&gt;B (K?%YVU?9RT%O&gt;B (K;[F1,=TIBP''P?O3&lt;BOS4=@O???0C???&lt;@????@#4=O\QAPTG4UEQT?8&gt;O#?&gt;Y&amp;Y''?%9^W?9VU%_&gt;U%YW?%YVU?9ZV%/&gt;M#X74T5MS1DEAPPH=OS4@????@O???7P?O3?4UEQT?9*Z&amp;/&gt;X&amp;I#?):^''?=+Z6/?-;^7?9&gt;_''?&lt;''I2_&gt;]''Y7?%YVU?9^W%?QST5M4O3&lt;?@O???2T=OS75P$IB?9RT%O&gt;^'');?&amp;9.[?;6=/_?9&gt;_''?8NC ??C0&lt;O??????6]''Y?9"X&amp;O&gt;[&amp;9/?$)JR=TIBP"T=OS6EO#8&gt;&gt;7I2\/&gt;&amp;)*[?)JR$?:J"(/&gt;+*:/?)JR$?9&gt;_''?&gt;0,KC???????+:&gt;/&gt; (JC?(*J"?:R$)O-1\WFEO#8&gt;1TIBP/&gt;P$IC?+*:.?:2,+O&gt;+*:/?*Z&amp;)?:&amp;)*_&gt;)*Z''?8NC ???????!8^G?*Z&amp;)?:.+*?&gt;,+J3?#8&gt;O1TIBP/I@PDC?+Z6-?;Z6-/&gt;5-[W?-KR4?;N3,?&gt;3,;O?7=?_???????0&lt;OC?-;^7?;N3,?&gt;4-KS?-[V5?:.+*?I@PDC2PDA@?;V5-_&gt;?/;??/+:&gt;?;6=/_&gt;=/[7?0\GA????????????0&lt;OC?;2&lt;/O&gt;=/[7?/[6=?;:&gt;//&gt;4-KS2PDA@1TIBP/&gt;&amp;)*[?2\''I?&lt;#H2O?G1&lt;_?1,[F?&lt;_G1??O3&lt;??3&lt;?O?&lt;[F1/?F1,[?1&lt;_G?&lt;_G1??H2L#?)ZV%1TIBP(T&gt;O#;&lt;#X6M?=KR4/?Q4]G?4]GQ?=CP4O?V5-[????????????P4MC?4MCP?=CP4O?Q4]G?4-KR?H6M#XT&gt;O#8%OS4==TYFQ/?L3L3?6=/[?=+Z6/?Z6-+?7=?_????????????6]''Y?=+Z6/?Z6-+?6=/[?&lt;3L3OUFQ$X%OS4=@O???7P?O3?6[6=/?&gt;O#8??$9NS?9NS$?&gt;O#8??#8&gt;O?8&gt;O#?&gt;O#8??$9NS?9NS$?&gt;O#8?Y/[6=4O3&lt;?@O???0C???&lt;BOS4=1DEAP_Y1\WG?6]''Y?&gt;''):_?):^''?:^'')?&gt;''):_?):^''?:^'')?=''Y6_Y1\WGDPTEA@#4=OPC???&lt;@????@O???0H=OS54O3&lt;?=T]GQ?6]''Y7?0,KB?=?_7??_7=??0,KB?Y6]''_UGQ4]4O3&lt;?@#4=OPC???&lt;@????@O???0C???&lt;@????@O???2T=OS6EO#8&gt;1TIBP/I@PDC2PDA@1TIBP(T&gt;O#8%OS4=@O???0C???&lt;@????@O???0@a')))] once</body></methods><methods><class-id>Store.MergeIcons class</class-id> <category>resources</category><body package="Store-Merge Management" selector="doNotResolve">doNotResolve	"UIMaskEditor new openOnClass: self andSelector: #doNotResolve"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7291 7098)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4497 2344)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7034 7034 7034)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7548 7548 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7163 6231)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7998 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 8191 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8062 8191 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 8094 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4400 4207 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7805 7805 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5267 4689 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 7227 7227)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8094 8062 8062)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4914 4914 4914)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7291 7452 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 8191 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7869 7612)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6263 6295 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4464 4207 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7420 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8158 8158 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7901 7869 7837)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7869 7869 7869)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4336 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7966 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6713 6713)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7387 6617)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@8B@ HB@ D@@@@@@@@@@@HBG@@@@@XB@ P@@@@@@@HPD!DQDQDQF TB@0@@@@HPDQDHB@ HBADQD@HK@A\BB@ HB@ HB@ HBADPC@@BDA@P@@ HB@ HB@@PD@HX@!@PD1LSD1LSD1LSD1@P@ HPA1L@@@@@@@@@@ALGA0HBA1@S@@@@@@@@@@@SD@\B@ \PD1LSD1LSD1LSD1@G@ HGDA@PDA@PDA@PDA@PDATI@ \PDA@PDA@PDA@PD@(V@@HPDA@PDA@PDA@PD@HU@@@@@!@PDA@GDA@PD@H[@@@@@@@B@ \GA0\GD@HM@@@@@@@@@A BC1PY@ HX@@@@@@@a'))))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 224 0 0 28 120 0 0 63 252 0 0 127 254 0 0 255 254 0 0 247 239 0 0 255 255 0 0 240 15 0 0 240 15 0 0 255 255 0 0 255 255 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0])))</body><body package="Store-Merge Management" selector="unapplied">unapplied	"UIMaskEditor new openOnClass: self andSelector: #unapplied"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7677 8062)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 7709 8030)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(803 803 803)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 6970 6970)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7998 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7773 8094)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5749 5749 5749)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7773 7773)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8126 8030 8126)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 3276 3276)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2055 2055 2055)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8062 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7934 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8030 8158)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7901 7805)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7805 8126)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'C0&lt;OC0PDB@ IA@PIC0&lt;OC0&lt;ODPPLB@PDA@PDB@PQC0&lt;ODP KC@ DBPTDA@ KBADOC0 MCP0HA@PDA@PHB04HC0$KCP4MC@ HB@ HC!HMCPPKCP4MCP,LC@ HA@8DCP4HB04MCP4KB0,LB@8NC@4MB04MCP4MB0,KB0\NB@4MCP4@@@@L@P KB0 NA@0C@04CB0@@C@8NC@0ND@0C@0LCC@ @@@@HC 8BC  C@0LCB0 I@@@@@@ NC PL@0LC@0,DC0 @@@@LB@(L@@@@@@,HC0&lt;QB0@@@@@@@@@@@@,KDP&lt;OC1DHB0@@@@@@@@,HDP&lt;OC0&lt;OC0$HC@,KC@ IC0&lt;OC0@a'))))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 223 0 0 255 223 0 0 255 191 0 0 243 127 0 0 249 127 0 0 252 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0])))</body><body package="Store-Merge Management" selector="unapplyable">unapplyable	"UIMaskEditor new openOnClass: self andSelector: #unapplyable"	&lt;resource: #image&gt;	^OpaqueImage		figure: (CachedImage on: ((Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5332 5267 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4689 4625 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3372 3372 3372)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4818 4818 4753)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7773 7452)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6488 6488 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6199 6199 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4529 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5910 5910 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4946 4882 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4368 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5974 5910 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4015 3983 3950)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4689 4689)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 7741 7612)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5717 5717)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7452 7452 7323)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 3886 3886)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4561 4561 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6584 6552 6488)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5107 5043 4978)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3404 3404)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7773 7773 7644)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6809 6745)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 4207 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4625 4561 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3950 3950 3918)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7580 7580 7484)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 3629 3629)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7644 7644 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 4240 4175)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4432 4368 4368)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5396 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6070 6070)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7516 7516 7387)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4272 4207)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5010 4272 2633)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3693 3693 3661)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5203 5203)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 3950 2409)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5396 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5524 5524 5460)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LZJ@@@@@@#@0LC@0LC@0LCGA,@@@@@@@@@@@@#@0LC@20$H0@@@@@@@@@@A@LC@0LYCRH#@@@@@@@@@@@#@0LC@0DNJ"L@@@@@@@@@A@LC@0LQF0$D@@@@@@@@@@@#@0LC@1\RI2LFA@@@@@@@A@LC@0L EA@J@0LCA@@@ABLC@0LC@0TLGPLC@0LC@0LC@0LC@0L^G0,H@0LC@0LC@0LC@0LC@1T#HPLC@0LC@0LC@0LC@0L%FA\G@0LC@0LC@0LC@0LC@2X)@ LC@0LC@0LC@0LC@0LSC1XC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0@a'))))		shape: (CachedImage on: ((Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 0 0 0 127 248 0 0 127 248 0 0 127 252 0 0 63 252 0 0 63 254 0 0 31 254 0 0 30 62 0 0 14 0 0 0 15 0 0 0 7 0 0 0 7 128 0 0 3 128 0 0 3 128 0 0 0 0 0 0])))</body></methods><methods><class-id>Store.Glorp.PundleVersionPane</class-id> <category>menu</category><body package="Store-UI" selector="compareBundleStructuresItem">compareBundleStructuresItem	&lt;itemInMenu: #(#listMenu) position: 60.9&gt;	^(MenuItem		labeled: #CompareBundleStructure &gt;&gt; 'Compare Bundle Structure' &lt;&lt; #IDE)		visible: [self hasTwoBundlesSelected];		value: [self compareBundleStructures]</body></methods><methods><class-id>Store.Glorp.PundleVersionPane class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ContainedI_tems 								#defaultString: 'Contained I&amp;tems' 								#catalogID: #store ) 							#nameKey: #ContainedItems 							#value: #containedItems 							#enablementSelector: #selectionIsBundle ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_EnclosingBundles 								#defaultString: '&amp;Enclosing Bundles' 								#catalogID: #store ) 							#nameKey: #enclosingBundles 							#value: #enclosingBundles 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Load 								#defaultString: '&amp;Load' 								#catalogID: #menus ) 							#nameKey: #Load 							#value: #loadSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_MergeIntoImage 								#defaultString: '&amp;Merge Into Image' 								#catalogID: #store ) 							#nameKey: #Merge 							#value: #mergeIntoImage 							#enablementSelector: #atLeastOneVersionSelectedAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReconcileImageWithSelection 								#defaultString: '&amp;Reconcile Image with Selection' 								#catalogID: #store ) 							#nameKey: #Reconcile 							#value: #reconcile 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SetBlessingLevelDots 								#defaultString: '&amp;Set Blessing Level...' 								#catalogID: #store ) 							#nameKey: #SetBlessingLevel 							#value: #setBlessingLevel 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOutSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOut_DifferencesDots 								#defaultString: 'File Out &amp;Differences...' 								#catalogID: #store ) 							#value: #fileOutDifferences 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenVersionsList 								#defaultString: '&amp;Open Versions List' 								#catalogID: #store ) 							#value: #openVersionsList 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Graph 								#defaultString: '&amp;Graph' 								#catalogID: #store ) 							#nameKey: #Graph 							#value: #graphSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_UpdateVersionsList 								#defaultString: '&amp;Update Versions List' 								#catalogID: #store ) 							#value: #updateVersionsList 							#enablementSelector: #atLeastOnePundleSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CompareWithImage 								#defaultString: '&amp;Compare with Image' 								#catalogID: #store ) 							#value: #compareWithImage 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CompareWith_Parent 								#defaultString: 'Compare with &amp;Parent' 								#catalogID: #store ) 							#value: #compareWithParent 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) ) #(4 3 1 4 1 4 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="mainSpec">mainSpec	"Tools.UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ResetBlessingLevelDots 				#defaultString: 'Reset Blessing Level...' 				#catalogID: #store ) 			#min: #(#{Core.Point} 471 480 ) 			#max: #(#{Core.Point} 471 480 ) 			#bounds: #(#{Graphics.Rectangle} 515 210 986 690 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -35 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundleAndComponents 						#defaultString: 'Bundle and Components' 						#catalogID: #store ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -10 1 -20 0.5 ) 					#name: #itemsList 					#flags: 15 					#model: #items 					#multipleSelections: false 					#selectionType: #checkMark ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 0 1 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #BlessinglevelC 								#defaultString: 'Blessing level:' 								#catalogID: #store ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -10 0.5 -10 1 15 0.5 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #BlessingcommentC 								#defaultString: 'Blessing comment:' 								#catalogID: #store ) ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 20 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 20 0.5 -10 1 -50 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #allBlessings 					#label: 					#(#{Kernel.UserMessage} 						#key: #SetGlobalBlessingLevelAndComment 						#defaultString: 'Set Global Blessing Level and Comment' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="publishSpec">publishSpec	"Tools.UIPainter new openOnClass: self andSelector: #publishSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PublishPundles 				#defaultString: 'Publish Pundles' 				#catalogID: #store ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 514 210 986 690 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -5 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundleAndComponents 						#defaultString: 'Bundle and Components' 						#catalogID: #store ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 35 0 -10 1 -160 1 ) 					#name: #itemsList 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #RestModifedPundles 								#defaultString: 'Reset Modified Pundles' 								#catalogID: #store ) ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 10 0 -5 0.5 ) 							#name: #publishAllYes 							#model: #publishAllYes 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetAll 								#defaultString: 'Reset All' 								#catalogID: #store ) 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 0.5 0.5 0 ) 							#name: #publishAllNo 							#model: #publishAllNo 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetOnlyModified 								#defaultString: 'Reset Only Modified' 								#catalogID: #store ) 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} -10 1 -5 0.5 1 0 ) 							#name: #resetBundleOnly 							#model: #resetBundleOnly 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetBundleOnly 								#defaultString: 'Reset Bundle Only' 								#catalogID: #store ) 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -150 1 -10 1 -80 1 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #CurrentSelection 								#defaultString: 'Current Selection' 								#catalogID: #store ) ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 10 0 -5 0.5 ) 							#name: #publishYes 							#model: #publish 							#label: 							#(#{Kernel.UserMessage} 								#key: #ResetSelection 								#defaultString: 'Reset Selection' 								#catalogID: #store ) 							#select: true ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} -10 1 -5 0.5 1 0 ) 							#name: #publishNo 							#model: #publish 							#label: 							#(#{Kernel.UserMessage} 								#key: #DoNotReset 								#defaultString: 'Do Not Reset' 								#catalogID: #store ) 							#select: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 -70 1 -10 1 -20 1 ) ) ) ) ) )</body></methods><methods><class-id>Tools.SingleMethodView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="browseImageMenuItem">browseImageMenuItem	&lt;itemInMenu: #(#menu) position: 20.1&gt;	^(MenuItem labeled: #BrowseImage &lt;&lt; #IDE &gt;&gt; 'Browse Image')		visible: [self imageMethod notNil];		value: [self browseImageMethod: self imageMethod];		yourself</body><body package="Store-Code Comparison" selector="browseStoreMenuItem">browseStoreMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^self storeMethod		ifNotNil: 			[:storeMethodInPackage |			(MenuItem labeled: (#StoreBrowsePrefix &lt;&lt; #IDE &gt;&gt; 'Browse ') asText						, (self storeObjectVersionLabel: storeMethodInPackage))				value: [self browseStoreMethod: storeMethodInPackage];				yourself]</body><body package="Store-Code Comparison" selector="loadMenuItem">loadMenuItem	&lt;itemInMenu: #(#menu) position: 40.5&gt;	^self storeMethod		ifNotNil: 			[:storeMethodInPackage |			(MenuItem labeled: (#StoreLoadPrefix &lt;&lt; #IDE &gt;&gt; 'Load ') asText						, (self storeObjectVersionLabel: storeMethodInPackage))				value: [self loadMethod: storeMethodInPackage];				yourself]</body><body package="Store-Code Comparison" selector="versionsMenuItem">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 40.9&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		visible: [self storeMethod notNil];		value: [self openMethodVersions: (Array with: self storeMethod definition)];		yourself</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool class</class-id> <category>resources</category><body package="Store-UI" selector="bundleMenu">bundleMenu	"Tools.MenuEditor new openOnClass: self andSelector: #bundleMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllBundleVersions 				#enablementSelector: #bundleIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllBundleVersions 				#enablementSelector: #bundleIsSelected ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="bundleVersionsMenu">bundleVersionsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #bundleVersionsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectForRemoval 					#defaultString: 'Select For Removal' 					#catalogID: #store ) 				#nameKey: #SelectForRemoval 				#value: #selectBundleVersionForRemoval 				#enablementSelector: #atLeastOneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractThisVersionForRemoval 					#defaultString: 'Retract Version Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractThisVersion 				#value: #retractThisBundleVersion 				#enablementSelector: #atLeastOneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllBundleVersions 				#enablementSelector: #bundleIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllBundleVersions 				#enablementSelector: #bundleIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ViewContainedItems 					#defaultString: 'View Contained Items' 					#catalogID: #store ) 				#nameKey: #ViewContainedItems 				#value: #viewContainedItems 				#enablementSelector: #oneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ViewEnclosingBundles 					#defaultString: 'View Enclosing Bundles' 					#catalogID: #store ) 				#nameKey: #ViewEnclosingBundles 				#value: #viewEnclosingBundles 				#enablementSelector: #oneBundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseBundle 					#defaultString: 'Browse Bundle' 					#catalogID: #store ) 				#nameKey: #BrowseBundle 				#value: #browseBundle 				#enablementSelector: #oneBundleVersionIsSelected ) ) #(2 2 2 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="packageMenu">packageMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packageMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllPackageVersions 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllPackageVersions 				#enablementSelector: #packageIsSelected ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="packageVersionsMenu">packageVersionsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packageVersionsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectForRemoval 					#defaultString: 'Select For Removal' 					#catalogID: #store ) 				#nameKey: #SelectForRemoval 				#value: #selectPackageVersionForRemoval 				#enablementSelector: #atLeastOnePackageVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractThisVersionForRemoval 					#defaultString: 'Retract Version Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractThisVersion 				#value: #retractThisPackageVersion 				#enablementSelector: #atLeastOnePackageVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SelectAllVersionsForRemoval 					#defaultString: 'Select All Versions For Removal' 					#catalogID: #store ) 				#nameKey: #SelectAllForRemoval 				#value: #selectAllPackageVersions 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllPackageVersions 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ViewEnclosingBundles 					#defaultString: 'View Enclosing Bundles' 					#catalogID: #store ) 				#nameKey: #ViewEnclosingBundles 				#value: #viewEnclosingBundles 				#enablementSelector: #packageIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowsePackage 					#defaultString: 'Browse Package' 					#catalogID: #store ) 				#nameKey: #BrowsePackage 				#value: #browsePackage 				#enablementSelector: #onePackageVersionIsSelected ) ) #(2 2 1 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="targetedPundlesMenu">targetedPundlesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #targetedPundlesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractThisVersionForRemoval 					#defaultString: 'Retract Version Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractThisVersion 				#value: #retractThisPundleVersion 				#enablementSelector: #atLeastOnePundleVersionIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RetractAllVersionsTargetedForRemoval 					#defaultString: 'Retract All Versions Targeted For Removal' 					#catalogID: #store ) 				#nameKey: #RetractAllVersions 				#value: #retractAllPundleVersions ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MarkPundlesForDeletionTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="bundlesPage">bundlesPage	"Tools.UIPainter new openOnClass: self andSelector: #bundlesPage"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 900 550 1401 914 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.4 -35 1 ) 					#name: #BundlesList 					#flags: 15 					#model: #bundles 					#menu: #bundleMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 0 0 0 1 -35 1 ) 					#name: #BundleVersions 					#flags: 15 					#model: #bundleVersions 					#menu: #bundleVersionsMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -210 1 -28 1 -110 1 -5 1 ) 					#name: #ClearFilter 					#model: #clearFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClearFilter 						#defaultString: 'Clear Filter' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -105 1 -28 1 -5 1 -5 1 ) 					#name: #EditFilter 					#model: #editFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #EditFilterDots 						#defaultString: 'Edit Filter...' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="packagesPage">packagesPage	"Tools.UIPainter new openOnClass: self andSelector: #packagesPage"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 749 562 1250 926 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.4 -35 1 ) 					#name: #PackagesList 					#flags: 15 					#model: #packages 					#menu: #packageMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 0 0 0 1 -35 1 ) 					#name: #PackageVersions 					#flags: 15 					#model: #packageVersions 					#menu: #packageVersionsMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -210 1 -28 1 -110 1 -5 1 ) 					#name: #ClearFilter 					#model: #clearFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClearFilter 						#defaultString: 'Clear Filter' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -105 1 -28 1 -5 1 -5 1 ) 					#name: #EditFilter 					#model: #editFilter 					#label: 					#(#{Kernel.UserMessage} 						#key: #EditFilterDots 						#defaultString: 'Edit Filter...' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MarkPackagesBundlesForRemoval 				#defaultString: 'Mark Repository Packages &amp; Bundles For Removal' 				#catalogID: #store ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 882 309 1682 1009 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 1 0 0.6 ) 					#name: #PundleChooser 					#model: #pundleTabs 					#labels: #('Bundles' 'Packages' ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0.6 -2 1 -35 1 ) 					#name: #TargetedPundles 					#model: #targetedPundles 					#menu: #targetedPundlesMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -540 1 -30 1 -410 1 -5 1 ) 					#name: #StartGarbageCollector 					#model: #startGarbageCollector 					#label: 					#(#{Kernel.UserMessage} 						#key: #StartGarbageCollector 						#defaultString: 'Start Garbage Collector' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -405 1 -30 1 -275 1 -5 1 ) 					#name: #ApplyChanges 					#flags: 40 					#model: #applyChanges 					#label: 					#(#{Kernel.UserMessage} 						#key: #ApplyChanges 						#defaultString: 'Apply Changes' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -270 1 -30 1 -140 1 -5 1 ) 					#name: #CancelChanges 					#flags: 40 					#model: #cancelChanges 					#label: 					#(#{Kernel.UserMessage} 						#key: #CancelChanges 						#defaultString: 'Cancel Changes' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -30 1 -5 1 -5 1 ) 					#name: #Close 					#model: #closeWindow 					#label: 					#(#{Kernel.UserMessage} 						#key: #Close 						#defaultString: 'Close' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="mainSpec">mainSpec	"Tools.UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Bundle' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1178 876 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 25 0 0 1 ) 					#name: #versionLabel 					#label: 'Version:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -10 1 50 0 ) 					#name: #versionString 					#model: #versionString ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 75 0 0 1 ) 					#name: #levelLabel 					#label: 'Blessing level:' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 75 0 -10 1 100 0 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 125 0 -10 1 -40 1 ) 					#name: #blessingComment 					#model: #blessingComment 					#tabRequiresControl: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#name: #binarySave 					#model: #binarySave 					#label: 'Publish Binary' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 125 0 0 1 ) 					#name: #bCommentLabel 					#label: 'Blessing comment:' ) ) ) )</body><body package="Store-UI" selector="parcelSpec">parcelSpec	"Tools.UIPainter new openOnClass: self andSelector: #parcelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1320 1030 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 11 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 'Publish Parcel' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.129032 ) 							#label: 'Parcel Path:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 0 1 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 50 0 -11 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Source options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 'Save source file' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 'Hide source on load' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 'Pad source' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -80 0.5 5 0.3 80 0.5 85 0.3 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Miscellaeonous Options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 'Republish' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 'Backup' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 'Overwrite existing files' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -80 0.5 0 0.583333 80 0.5 80 0.583333 ) ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 11 0 -55 1 0 1 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionStringColon 						#defaultString: 'Version String:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 -77 1 -145 1 -52 1 ) 					#name: #VersionString 					#flags: 40 					#model: #parcelVersionString ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -77 1 -11 1 -52 1 ) 					#name: #CopyFromPackage 					#flags: 40 					#model: #copyFromPackage 					#label: 					#(#{Kernel.UserMessage} 						#key: #CopyFromPackage 						#defaultString: 'Copy From Package' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.Glorp.BundleTreePane class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 900 550 1100 750 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#model: #itemsInList 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.Glorp.BundleTreePane class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SetBlessingLevelDots 								#defaultString: '&amp;Set Blessing Level...' 								#catalogID: #store ) 							#nameKey: #SetBlessingLevel 							#value: #setBlessingLevel 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutDots 								#defaultString: '&amp;File Out...' 								#catalogID: #store ) 							#nameKey: #FileOut 							#value: #fileOutSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Graph 								#defaultString: '&amp;Graph' 								#catalogID: #store ) 							#nameKey: #Graph 							#value: #graphSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_EnclosingBundles 								#defaultString: '&amp;Enclosing Bundles' 								#catalogID: #store ) 							#nameKey: #enclosingBundles 							#value: #enclosingBundles 							#enablementSelector: #onlyOneItemSelected ) ) #(3 2 2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser</class-id> <category>menus</category><body package="StoreForGlorpBrowserUI" selector="toolsMenuToggleStatusBarItem">toolsMenuToggleStatusBarItem	&lt;itemInMenu: #(#toolsMenu) position: 50.20&gt;	^(MenuItem labeled: #toggleStatusBar &lt;&lt; #browser &gt;&gt; 'Status Bar')		indication: [self codeModel isStatusBarEnabled];		value: [self codeModel toggleStatusBar]</body><body package="StoreForGlorpBrowserUI" selector="toolsMenuToggleToolbarItem">toolsMenuToggleToolbarItem	&lt;itemInMenu: #(#toolsMenu) position: 50.10&gt;	^(MenuItem labeled: #Toolbar &lt;&lt; #browser &gt;&gt; 'Toolbar')		indication: [self showToolbar];		value: [self toggleToolbar]</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser class</class-id> <category>resources</category><body package="StoreForGlorpBrowserUI" selector="findMenu">findMenu	"Tools.MenuEditor new openOnClass: self andSelector: #findMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ClassVariableNamespaceDots 					#defaultString: '&amp;Class/Variable/Name Space...' 					#catalogID: #browser ) 				#nameKey: #'Find Global Name' 				#value: 				#action: 				#shortcutKeyCharacter: $l 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findClass ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_MethodDots 					#defaultString: '&amp;Method...' 					#catalogID: #browser ) 				#nameKey: #'Find Method' 				#value: 				#action: 				#shortcutKeyCharacter: $m 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ImplementorsMatchingDots 					#defaultString: 'Implementors Matching...' 					#catalogID: #browser ) 				#nameKey: #'Implementors Matching' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #MethodsWithStringsMatchingDots 					#defaultString: 'Methods with Strings Matching...' 					#catalogID: #browser ) 				#nameKey: #'Methods with Strings Matching' 				#value: 				#action: ) ) #(2 1 1 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI" selector="helpMenu">helpMenu	"Tools.MenuEditor new openOnClass: self andSelector: #helpMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Help 					#defaultString: 'Help' 					#catalogID: #browser ) 				#nameKey: #'Context Help' 				#value: 				#action: 				#shortcutKeyCharacter: #F1 				#shortcutModifiers: 0 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Topics 					#defaultString: '&amp;Topics' 					#catalogID: #browser ) 				#nameKey: #'Refactoring Browser Help' 				#value: 				#action: ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI" selector="toolbarMenu">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CreateBuffer 					#defaultString: 'Create Buffer' 					#catalogID: #browser ) 				#nameKey: #'Create Buffer' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #newView ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindClassVariableNameSpace 					#defaultString: 'Find Class/Variable/Name Space' 					#catalogID: #browser ) 				#nameKey: #'Find Global Name' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findClass ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindMethod 					#defaultString: 'Find Method' 					#catalogID: #browser ) 				#nameKey: #'Find Method' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #findMethod ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Implementors 					#defaultString: 'Implementors' 					#catalogID: #browser ) 				#nameKey: #'Local Implementors' 				#value: 				#action: 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #definitionsMethod ) ) ) #(1 1 2 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI" selector="toolsMenu">toolsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CodeModelToolsMenu 					#defaultString: 'Code Model Tools Menu' 					#catalogID: #browser ) 				#nameKey: #'Code Model Tools Menu' 				#value: #dynamicMenu ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="StoreForGlorpBrowserUI" selector="viewMenu">viewMenu	"Tools.MenuEditor new openOnClass: self andSelector: #viewMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Zoom 					#defaultString: '&amp;Zoom' 					#catalogID: #browser ) 				#nameKey: #'Zoom Specifications' 				#value: #dynamicMenu 				#shortcutKeyCharacter: $Z 				#shortcutModifiers: 8 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewView 					#defaultString: '&amp;New View' 					#catalogID: #browser ) 				#nameKey: #'Create Buffer' 				#value: 				#action: 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 3 				#labelImage: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #newView ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RemoveCurrentView 					#defaultString: '&amp;Remove Current View' 					#catalogID: #browser ) 				#nameKey: #'Remove Buffer' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Buffers 					#defaultString: 'Buffers' 					#catalogID: #browser ) 				#nameKey: #Buffers 				#value: #dynamicMenu ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_MoreBuffers 					#defaultString: '&amp;More Buffers' 					#catalogID: #browser ) 				#nameKey: #'More Buffers' 				#value: 				#action: 				#enablementSelector: #has10orMoreCodeTools ) ) #(1 2 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.StoreRefactoringBrowser class</class-id> <category>interface specs</category><body package="StoreForGlorpBrowserUI" selector="findWindowSpec">findWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #findWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #browser ) 			#bounds: #(#{Graphics.Rectangle} 680 435 970 465 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -315 1 13 0 1 0.5 ) 					#name: #findLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #FindC 						#defaultString: 'Find:' 						#catalogID: #browser ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} -310 1 0 0 0 1 25 0 ) 					#name: #find 					#model: #findHolder 					#tabable: true 					#isReadOnly: false 					#comboList: #findList ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{UI.AlignmentOrigin} -180 0.5 12 0 0.5 0.5 ) 					#name: #storeLabelImage 					#label: #storeLabelImage 					#hasCharacterOrientedLabel: false ) ) ) )</body></methods><methods><class-id>Store.Glorp.StoreNameSpaceItemTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="StoreForGlorpBrowserUI" selector="instanceVariableTab">instanceVariableTab	"Don't do this one for Store."	&lt;tabDescription: 7&gt;	^nil</body></methods><methods><class-id>Store.PrerequisiteSelector class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PrerequsiteSelection 				#defaultString: 'Prerequisite Selection' 				#catalogID: #store ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1344 794 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 30 0 -5 1 -40 1 ) 					#name: #PrereqList 					#flags: 15 					#model: #selections 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #useSelection ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#name: #PromptLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ChoosePackagePrereq 						#defaultString: 'Choose a Package version to fullfill prerequiste:' 						#catalogID: #store ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 -30 1 113 0 -5 1 ) 					#name: #ActionButton1 					#model: #quitLoading 					#label: 					#(#{Kernel.UserMessage} 						#key: #QuitLoading 						#defaultString: 'Quit Loading' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 -30 1 224 0 -5 1 ) 					#name: #TryParcel 					#model: #tryParcel 					#label: 					#(#{Kernel.UserMessage} 						#key: #TryParcel 						#defaultString: 'Try Parcel' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 228 0 -30 1 334 0 -5 1 ) 					#name: #ActionButton3 					#model: #skipPrerequisite 					#label: 					#(#{Kernel.UserMessage} 						#key: #SkipPrerequisite 						#defaultString: 'Skip Prerequisite' 						#catalogID: #store ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 338 0 -30 1 -5 1 -5 1 ) 					#name: #ActionButton4 					#model: #useSelection 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseSelection 						#defaultString: 'Use Selection' 						#catalogID: #store ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.Glorp.ClassListPane class</class-id> <category>resources</category><body package="Store-UI" selector="mainMenu">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Action 					#defaultString: '&amp;Action' 					#catalogID: #store ) 				#nameKey: #Action 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #store ) 							#nameKey: #Browse 							#value: #browseSelectedVersion 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#nameKey: #InspectSelected 							#value: #inspectSelected 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOut_OnlyClassDefinition 								#defaultString: 'File &amp;Out Only Class Definition' 								#catalogID: #store ) 							#nameKey: #FileOutOnlyClassDefinition 							#value: #fileOutOnlyClassDefinition 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOutClass 								#defaultString: '&amp;File Out Class' 								#catalogID: #store ) 							#nameKey: #FileOutClass 							#value: #fileOutClass 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_WIthDots 								#defaultString: 'Compare &amp;With...' 								#catalogID: #store ) 							#nameKey: #CompareWith 							#value: #compareSelectionWith 							#enablementSelector: #onlyOneItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Compare_Versions 								#defaultString: 'Compare &amp;Versions' 								#catalogID: #store ) 							#nameKey: #CompareVersions 							#value: #compareVersions 							#enablementSelector: #onlyTwoItemsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LoadOnlyClass_Definition 								#defaultString: 'Load Only Class &amp;Definition' 								#catalogID: #store ) 							#nameKey: #LoadOnlyClassDefinition 							#value: #loadOnlyClassDefinition 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Load_Class 								#defaultString: 'Load &amp;Class' 								#catalogID: #store ) 							#nameKey: #LoadClass 							#value: #loadClass 							#enablementSelector: #oneItemAndInImage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Containing_PackagesDots 								#defaultString: 'Containing &amp;Packages...' 								#catalogID: #store ) 							#nameKey: #ContainingPackages 							#value: #containingPackages 							#enablementSelector: #onlyOneItemSelected ) ) #(2 2 2 2 1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.Glorp.ClassListPane class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 160 568 360 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #SelectionList 					#flags: 15 					#model: #itemsInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #browseSelectedVersion ) 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>interface specs</category><body package="Store-DB-Broker" selector="reconnectSpec">reconnectSpec	"UIPainter new openOnClass: self andSelector: #reconnectSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #StoreConnection #catalogID: #store #defaultString: 'Store Connection') 			#min: #(#{Core.Point} 298 234 ) 			#max: #(#{Core.Point} 391 378 ) 			#bounds: #(#{Graphics.Rectangle} 317 195 708 573 ) 			#flags: 8 			#menu: #menuBar 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 234 0 0 1 ) 					#label: #(#{UserMessage} #key: #Username #catalogID: #store #defaultString: 'Username:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 265 0 0 1 ) 					#label: #(#{UserMessage} #key: #Password #catalogID: #store #defaultString: 'Password:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 299 0 0 1 ) 					#label: #(#{UserMessage} #key: #EnvironmentC #catalogID: #store #defaultString: 'Environment:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 37 0 -10 1 156 0 ) 					#name: #messageBox 					#model: #message 					#alignment: #center 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#label: #(#{UserMessage} #key: #ReconnectingToTheStoreDatabase #catalogID: #store #defaultString: 'Reconnecting to the Store database.') ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 213 0 -16 1 237 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #userName 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 243 0 -16 1 267 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #password 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 278 0 -16 1 302 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #environment 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 204 0 -35 1 286 0 -8 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Connect #catalogID: #store #defaultString: 'Connect') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -97 1 -35 1 -15 1 -8 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{UserMessage} #key: #Detach #catalogID: #store #defaultString: 'Detach') 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 183 ) 					#label: #(#{UserMessage} #key: #DatabaseConnect #catalogID: #store #defaultString: 'Database Connect:') ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 183 369 207 ) 					#name: #whichDriver 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #whichDriverModel ) ) ) )</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>interface specs</category><body package="Store-DB-BaseObjects" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #ConnectToDatabase #catalogID: #store #defaultString: 'Connect to Database') 			#min: #(#{Core.Point} 426 245 ) 			#max: #(#{Core.Point} 426 245 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1066 757 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 14 320 38 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 56 310 79 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 85 310 109 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 114 310 138 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 140 143 310 167 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 140 204 220 227 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: #(#{UserMessage} #key: #Save #catalogID: #store #defaultString: 'Save...') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 230 204 310 227 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: #(#{UserMessage} #key: #Delete #catalogID: #store #defaultString: 'Delete') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'Connect' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #database ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 10 46 320 239 ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 196 0 0 1 ) 					#label: #(#{UserMessage} #key: #TableOwner #catalogID: #store #defaultString: 'Table Owner:') ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 173 310 196 ) 					#name: #tableOwnerCombo 					#model: #tableOwnerHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #tableOwnerChanged ) 					#isReadOnly: false 					#comboList: #tableOwnerListHolder ) ) ) )</body></methods><methods><class-id>Store.StoreLoggingTool class</class-id> <category>resources</category><body package="Store-Base" selector="windowMenu">windowMenu	"Tools.MenuEditor new openOnClass: self andSelector: #windowMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save...' 								#catalogID: #store ) 							#value: #saveOutput ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ClearLog 								#defaultString: '&amp;Clear log' 								#catalogID: #store ) 							#value: #clear ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus -- Class</category><body package="Store-Difference Management" selector="browseMainClassMenuItem">browseMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 10.1&gt;	^(MenuItem labeled: [#AmpBrowseVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Browse Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canActOnMainClass and: [self namespaceNotSelected]]];		value: #browseMainClass</body><body package="Store-Difference Management" selector="browseOtherClassMenuItem">browseOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 10.2&gt;	^(MenuItem labeled: [#B_rowseVersionIn1s &lt;&lt; #store &gt;&gt; 'B&amp;rowse Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canActOnOtherClass and: [self namespaceNotSelected]]];		value: #browseOtherClass</body><body package="Store-Difference Management" selector="fileOutMainClassMenuItem">fileOutMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 20.1&gt;	^(MenuItem labeled: [#AmpFileOutVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;File Out Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canFileOutMainClass]];		value: #fileOutMainClass</body><body package="Store-Difference Management" selector="fileOutOtherClassMenuItem">fileOutOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 20.2&gt;	^(MenuItem labeled: [#F_ileOutVersionIn1s &lt;&lt; #store &gt;&gt; 'F&amp;ile Out Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self canFileOutOtherClass]];		value: #fileOutOtherClass</body><body package="Store-Difference Management" selector="loadMainClassMenuItem">loadMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 30.1&gt;	^(MenuItem labeled: [#AmpLoadVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Load Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		enablement: [self packageIsInImage and: [self classObjectIsSelected and: [self canActOnMainClass]]];		visible: [self mainPackageIsPseudo not];		value: #loadMainClass</body><body package="Store-Difference Management" selector="loadOtherClassMenuItem">loadOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 30.2&gt;	^(MenuItem labeled: [#L_oadVersionIn1s &lt;&lt; #store &gt;&gt; 'L&amp;oad Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		enablement: [self packageIsInImage and: [self classObjectIsSelected and: [self canActOnOtherClass]]];		visible: [self otherPackageIsPseudo not];		value: #loadOtherClass</body><body package="Store-Difference Management" selector="packagesContainingMainClassMenuItem">packagesContainingMainClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 40.1&gt;	^(MenuItem labeled: [#AmpPackagesContainingVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Packages Containing Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self mainClassIsNotExtension]];		value: #packagesContainingMainObject</body><body package="Store-Difference Management" selector="packagesContainingOtherClassMenuItem">packagesContainingOtherClassMenuItem	&lt;itemInMenu: #(#mainMenu #AmpClass) position: 40.2&gt;	^(MenuItem labeled: [#PackagesAmpContainingVersionIn1s &lt;&lt; #store &gt;&gt; 'Packages &amp;Containing Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: [self classObjectIsSelected and: [self otherClassIsNotExtension]];		value: #packagesContainingOtherObject</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus -- Definition</category><body package="Store-Difference Management" selector="fileOutMainDefinitionMenuItem">fileOutMainDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 20.1&gt;	^(MenuItem labeled: [#AmpFileOutVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;File Out Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		enablement: #canFileOutMainDefinitions;		value: #fileOutMainDefinitions</body><body package="Store-Difference Management" selector="fileOutOtherDefinitionMenuItem">fileOutOtherDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 20.2&gt;	^(MenuItem labeled: [#F_ileOutVersionIn1s &lt;&lt; #store &gt;&gt; 'F&amp;ile Out Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		enablement: #canFileOutOtherDefinitions;		value: #fileOutOtherDefinitions</body><body package="Store-Difference Management" selector="loadMainDefinitionMenuItem">loadMainDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 30.1&gt;	^(MenuItem labeled: [#AmpLoadVersionIn1s &lt;&lt; #store &gt;&gt; '&amp;Load Version In &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		enablement: [self packageIsInImage and: [self canLoadMainDefinitions]];		visible: [self mainPackageIsPseudo not];		value: #loadMainDefinitions</body><body package="Store-Difference Management" selector="loadOtherDefinitionMenuItem">loadOtherDefinitionMenuItem	&lt;itemInMenu: #(#mainMenu #AmpDefinition) position: 30.2&gt;	^(MenuItem labeled: [#L_oadVersionIn1s &lt;&lt; #store &gt;&gt; 'L&amp;oad Version In &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		enablement: [self packageIsInImage and: [self canLoadOtherDefinitions]];		visible: [self otherPackageIsPseudo not];		value: #loadOtherDefinitions</body></methods><methods><class-id>Store.ComparePackages</class-id> <category>menus -- Package</category><body package="Store-Difference Management" selector="browseMainPackageMenuItem">browseMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 10.1&gt;	^(MenuItem labeled: [#AmpBrowseVersion1s &lt;&lt; #store &gt;&gt; '&amp;Browse Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #browseMainPackage</body><body package="Store-Difference Management" selector="browseOtherPackageMenuItem">browseOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 10.2&gt;	^(MenuItem labeled: [#B_rowseVersion1s &lt;&lt; #store &gt;&gt; 'B&amp;rowse Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #browseOtherPackage</body><body package="Store-Difference Management" selector="compareMainMenuItem">compareMainMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 30.10&gt;	^(MenuItem labeled: [#AmpCompareVersion1stoDots &lt;&lt; #store &gt;&gt; '&amp;Compare Version &lt;1s&gt; to...' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #compareMainPackage</body><body package="Store-Difference Management" selector="compareOtherMenuItem">compareOtherMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 30.20&gt;	^(MenuItem labeled: [#C_ompareVersion1stoDots &lt;&lt; #store &gt;&gt; 'C&amp;ompare Version &lt;1s&gt; to...' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #compareOtherPackage</body><body package="Store-Difference Management" selector="fileOutDifferencesMainToOtherMenuItem">fileOutDifferencesMainToOtherMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 30.10&gt;	^(MenuItem labeled: [#AmpDifferencesBetween1sand2s &lt;&lt; #store &gt;&gt; '&amp;Differences Between &lt;1s&gt; and &lt;2s&gt;' 		expandMacrosWith: self mainPackageVersionName		with: self otherPackageVersionName])			visible: [self otherPackageIsPseudo not and: [self mainPackageIsPseudo not]];			value: #fileOutMainToOtherPackageDifference</body><body package="Store-Difference Management" selector="fileOutDifferencesOtherToMainMenuItem">fileOutDifferencesOtherToMainMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 30.20&gt;	^(MenuItem labeled: [#Di_fferencesBetween1sand2s &lt;&lt; #store &gt;&gt; 'Di&amp;fferences Between &lt;1s&gt; and &lt;2s&gt;' 		expandMacrosWith: self otherPackageVersionName		with: self mainPackageVersionName])			visible: [self otherPackageIsPseudo not and: [self mainPackageIsPseudo not]];			value: #fileOutOtherToMainPackageDifference</body><body package="Store-Difference Management" selector="fileOutMainPackageMenuItem">fileOutMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 10.10&gt;	^(MenuItem labeled: [#AmpFileOutVersion1s &lt;&lt; #store &gt;&gt; '&amp;File Out Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #fileOutMainPackage</body><body package="Store-Difference Management" selector="fileOutOtherPackageMenuItem">fileOutOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpFileOut) position: 10.20&gt;	^(MenuItem labeled: [#F_ileOutVersion1s &lt;&lt; #store &gt;&gt; 'F&amp;ile Out Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #fileOutOtherPackage</body><body package="Store-Difference Management" selector="graphMainMenuItem">graphMainMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 20.10&gt;	^(MenuItem labeled: [#AmpGraphVersion1s &lt;&lt; #store &gt;&gt; '&amp;Graph Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		visible: [self mainPackageIsPseudo not];		value: #graphMainVersion</body><body package="Store-Difference Management" selector="graphOtherMenuItem">graphOtherMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage #AmpVersions) position: 20.20&gt;	^(MenuItem labeled: [#G_raphVersion1s &lt;&lt; #store &gt;&gt; 'G&amp;raph Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		visible: [self otherPackageIsPseudo not];		value: #graphOtherVersion</body><body package="Store-Difference Management" selector="loadMainPackageMenuItem">loadMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.10&gt;	^(MenuItem labeled: [#AmpLoadVersion1s &lt;&lt; #store &gt;&gt; '&amp;Load Version &lt;1s&gt;' expandMacrosWith: self mainPackageVersionName])		enablement: #canLoadMainPackage;		visible: [self mainPackageIsPseudo not];		value: #loadMainPackage</body><body package="Store-Difference Management" selector="loadOtherPackageMenuItem">loadOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.20&gt;	^(MenuItem labeled: [#L_oadVersion1s &lt;&lt; #store &gt;&gt; 'L&amp;oad Version &lt;1s&gt;' expandMacrosWith: self otherPackageVersionName])		enablement: #canLoadOtherPackage;		visible: [self otherPackageIsPseudo not];		value: #loadOtherPackage</body><body package="Store-Difference Management" selector="mergeMainPackageMenuItem">mergeMainPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.30&gt;	^(MenuItem labeled: [#AmpMergeVersion1s &lt;&lt; #store &gt;&gt; '&amp;Merge Version &lt;1s&gt; Into Image' expandMacrosWith: self mainPackageVersionName])		enablement: #packageIsInImageButNotActualImage;		visible: [self mainPackageIsPseudo not];		value: #mergeMainIntoImage</body><body package="Store-Difference Management" selector="mergeOtherPackageMenuItem">mergeOtherPackageMenuItem	&lt;itemInMenu: #(#mainMenu #AmpPackage) position: 30.40&gt;	^(MenuItem labeled: [#M_ergeVersion1s &lt;&lt; #store &gt;&gt; 'M&amp;erge Version &lt;1s&gt; Into Image' expandMacrosWith: self otherPackageVersionName])		enablement: #packageIsInImage;		visible: [self otherPackageIsPseudo not];		value: #mergeOtherIntoImage</body></methods><methods><class-id>Store.ComparePackages class</class-id> <category>interface specs</category><body package="Store-Difference Management" selector="alternateSpec">alternateSpec	"Tools.UIPainter new openOnClass: self andSelector: #alternateSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Compare Packages' 			#min: #(#{Core.Point} 400 300 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 917 438 1717 1038 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 0.3 -2 1 ) 					#name: #Packages 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 210 0.3 -10 0.45 ) 					#name: #SharedSelection 					#label: 'Shared Variables' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25 0.3 -10 0.45 ) 					#name: #InstanceSelection 					#label: 'Instance' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 120 0.3 -10 0.45 ) 					#name: #ClassSelection 					#label: 'Class' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.3 -12 0.45 0 1 -10 0.45 ) 					#name: #TopVsBottom 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'TopGroup' 					#belowWidgets: 'BottomGroup InstanceSelection ClassSelection SharedSelection' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.3 2 0 2 0.3 -2 1 ) 					#name: #PackagesVsEverything 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'Packages' 					#belowWidgets: 'TopGroup BottomGroup TopVsBottom InstanceSelection ClassSelection SharedSelection' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 							#name: #ClassesAndPseudo 							#useModifierKeys: true 							#selectionType: #highlight ) 						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 							#name: #MethodsOrProperties 							#useModifierKeys: true 							#selectionType: #highlight ) 						#(#{UI.ResizingSplitterSpec} 							#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 							#name: #TopSplitter 							#horizontal: false 							#minAboveSize: 30 							#minBelowSize: 30 							#aboveWidgets: 'ClassesAndPseudo' 							#belowWidgets: 'MethodsOrProperties' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 2 0.3 2 0 0 1 -15 0.45 ) 						#name: #TopGroup ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 -20 1 ) 							#name: #FromDefinition 							#tabRequiresControl: true ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 -20 1 ) 							#name: #ToDefinition 							#tabRequiresControl: true ) 						#(#{UI.ResizingSplitterSpec} 							#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 							#name: #BottomSplitter 							#horizontal: false 							#minAboveSize: 30 							#minBelowSize: 30 							#aboveWidgets: 'FromDefinition FromProtocol' 							#belowWidgets: 'ToDefinition ToProtocol' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 -20 1 -2 0.5 0 1 ) 							#name: #FromProtocol 							#isReadOnly: true 							#type: #text ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.5 -20 1 0 1 0 1 ) 							#name: #ToProtocol 							#isReadOnly: true 							#type: #text ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 2 0.3 15 0.45 -2 1 -2 1 ) 						#name: #BottomGroup ) ) ) ) )</body><body package="Store-Difference Management" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window: #(#{UI.WindowSpec}			#label: #(#{UserMessage}				#key: #ComparePackages				#catalogID: #store				#defaultString: 'Compare Packages')			#min: #(#{Core.Point} 300 300)			#max: #(#{Core.Point} 0 0)			#bounds: #(#{Graphics.Rectangle} 160 448 860 1148)			#flags: 4			#menu: #mainMenu)		#component: #(#{UI.SpecCollection}			#collection: #(#(#{UI.SequenceViewSpec}				#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 1 -36 0.2)				#name: #Packages				#model: #comparedPackages				#menu: #packageMenu				#useModifierKeys: true				#selectionType: #highlight) #(#{UI.ResizingSplitterSpec}				#layout: #(#{Graphics.LayoutFrame} 2 0 -36 0.2 -2 1 -32 0.2)				#name: #PackagesVsEverything				#horizontal: true				#minAboveSize: 30				#minBelowSize: 30				#aboveWidgets: 'Packages'				#belowWidgets: 'CompareGroup') #(#{UI.CompositeSpecCollection}				#collection: #(#(#{UI.RadioButtonSpec}					#layout: #(#{Graphics.LayoutOrigin} 13 0 -73 0.4)					#name: #InstanceSelection					#model: #selectionType					#label: #(#{UserMessage}						#key: #Instance						#catalogID: #store						#defaultString: 'Instance')					#select: #instance) #(#{UI.RadioButtonSpec}					#layout: #(#{Graphics.LayoutOrigin} 108 0 -73 0.4)					#name: #ClassSelection					#model: #selectionType					#label: 'Class'					#select: #class) #(#{UI.RadioButtonSpec}					#layout: #(#{Graphics.LayoutOrigin} 203 0 -73 0.4)					#name: #SharedSelection					#model: #selectionType					#label: #(#{UserMessage}						#key: #SharedVariables						#catalogID: #store						#defaultString: 'Shared Variables')					#select: #shared) #(#{UI.ResizingSplitterSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0 -75 0.4 0 1 -73 0.4)					#name: #TopVsBottom					#horizontal: true					#minAboveSize: 30					#minBelowSize: 30					#aboveWidgets: 'TopGroup'					#belowWidgets: 'BottomGroup InstanceSelection ClassSelection SharedSelection') #(#{UI.CompositeSpecCollection}					#collection: #(#(#{UI.SequenceViewSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1)						#name: #ClassesAndPseudo						#model: #classesAndProperties						#menu: #classesMenu						#useModifierKeys: true						#selectionType: #highlight) #(#{UI.SequenceViewSpec}						#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1)						#name: #MethodsOrProperties						#model: #methodsOrProperties						#menu: #methodsMenu						#multipleSelections: true						#useModifierKeys: true						#selectionType: #highlight) #(#{UI.ResizingSplitterSpec}						#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1)						#name: #TopSplitter						#horizontal: false						#minAboveSize: 30						#minBelowSize: 30						#aboveWidgets: 'ClassesAndPseudo'						#belowWidgets: 'MethodsOrProperties'))					#compositeSpec: #(#{UI.CompositeSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -79 0.4)						#name: #TopGroup)) #(#{UI.CompositeSpecCollection}					#collection: #(#(#{UI.TextEditorSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 -20 1)						#name: #FromDefinition						#model: #fromDefinition						#menu: #definitionMenu						#isReadOnly: false						#tabRequiresControl: true) #(#{UI.TextEditorSpec}						#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 -20 1)						#name: #ToDefinition						#model: #toDefinition						#menu: #definitionMenu						#tabRequiresControl: true) #(#{UI.ResizingSplitterSpec}						#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1)						#name: #BottomSplitter						#horizontal: false						#minAboveSize: 30						#minBelowSize: 30						#aboveWidgets: 'FromDefinition FromProtocol'						#belowWidgets: 'ToDefinition ToProtocol') #(#{UI.InputFieldSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 -20 1 -2 0.5 0 1)						#name: #FromProtocol						#model: #fromProtocol						#menu: #noMenu						#isReadOnly: true						#type: #text) #(#{UI.InputFieldSpec}						#layout: #(#{Graphics.LayoutFrame} 2 0.5 -20 1 0 1 0 1)						#name: #ToProtocol						#model: #toProtocol						#menu: #noMenu						#isReadOnly: true						#type: #text))					#compositeSpec: #(#{UI.CompositeSpec}						#layout: #(#{Graphics.LayoutFrame} 0 0 -53 0.4 0 1 0 1)						#name: #BottomGroup)))				#compositeSpec: #(#{UI.CompositeSpec}					#layout: #(#{Graphics.LayoutFrame} 2 0 -32 0.2 -2 1 -2 1)					#name: #CompareGroup)))))</body></methods><methods><class-id>Tools.ClassBlueprintComparisonView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="storeExtensionWarningMenuItem">storeExtensionWarningMenuItem	&lt;itemInMenu: #(#menu) position: 40.1&gt;	^(MenuItem		labeled: ((#StoreExtensionOnly &lt;&lt; #IDE &gt;&gt; 'Class Extension Only') asText				emphasizeAllWith: (Array with: #italic)))		enabled: [false];		visible: [self rightStoreObject isNil and: [self leftStoreObject isNil]];		yourself</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="StoreForGlorpBrowserUI" selector="classHierarchyPackageTab">classHierarchyPackageTab	"Don't do for Store."	&lt;tabDescription: 2&gt;	^nil</body><body package="StoreForGlorpBrowserUI" selector="namespaceHierarchyPackageTab">namespaceHierarchyPackageTab	"Don't do for Store."	&lt;tabDescription: 3&gt;	^nil</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>event driven</category><body package="Store-Code Comparison" selector="button2Down">button2Down	&lt;event: #Button2Down&gt;	| valueResult menuView |	menuView := self widgetPolicy menuViewForMenu: self menu.	valueResult := menuView openFromView: self.	valueResult value ifNotNil: [:block | block value].	menuTarget := nil</body></methods><methods><class-id>Tools.PackageComparisonHeaderView</class-id> <category>menu</category><body package="Store-Code Comparison" selector="browseMenuItem">browseMenuItem	&lt;itemInMenu: #(#menu) position: 10.1&gt;	^(MenuItem labeled: #Browse &lt;&lt; #IDE &gt;&gt; 'Browse')		value: [self browseMenuTarget];		yourself</body><body package="Store-Code Comparison" selector="fileoutMenuItem">fileoutMenuItem	&lt;itemInMenu: #(#menu) position: 30.2&gt;	^(MenuItem		labeled: (#FileoutDifferencesFrom1s &lt;&lt; #IDE				&gt;&gt; 'File Out Differences from &lt;1s&gt;'					expandMacrosWith: self menuTargetCompliment version))		hidden: [self menuTargetCompliment isNil];		value: [self fileoutChangesToGetToMenuTarget];		yourself</body><body package="Store-Code Comparison" selector="loadMenuItem">loadMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^(MenuItem labeled: #Load &lt;&lt; #IDE &gt;&gt; 'Load')		hidden: [menuTarget isImageModel];		value: 			[menuTarget canLoadNewOrReplaceExistingVersion ifTrue: 				[[menuTarget loadSrc] withStoreFeedbackOn: self topComponent]];		yourself</body><body package="Store-Code Comparison" selector="publishMenuItem">publishMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^(MenuItem labeled: #PublishDots &lt;&lt; #IDE &gt;&gt; 'Publish...')		visible: [menuTarget isImageModel];		value: [DbRegistry doIfOnlineImage: [menuTarget storeInDB]];		yourself</body><body package="Store-Code Comparison" selector="versionsMenuItem">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 10.5&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		hidden: [menuTarget isImageModel];		value: [Store.Glorp.DefinitionForListTool forVersionsOfPackage: menuTarget];		yourself</body></methods><methods><class-id>Tools.PackageComparisonHeaderView class</class-id> <category>method tags</category><body package="Store-Code Comparison" selector="methodTags">methodTags		&lt;pragmas: #instance&gt;	^#(#itemInMenu:position:)</body></methods><methods><class-id>Store.Glorp.StoreCodeComponentPropertiesTool</class-id> <category>registered properties</category><body package="StoreForGlorpBrowserUI" selector="miscProperties">miscProperties	&lt;property: 200&gt;	^StoreCodeComponentInspectPropertiesTool new codeModel: codeModel</body><body package="StoreForGlorpBrowserUI" selector="summaryProperty">summaryProperty		&lt;property: 10&gt;	^CodeComponentSummaryTool codeModel: codeModel</body></methods><methods><class-id>Store.CommentPrompt class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #BlessingLevel #catalogID: #store #defaultString: 'Blessing level') 			#bounds: #(#{Graphics.Rectangle} 512 384 958 629 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 11 ) 					#label: #(#{UserMessage} #key: #BlessinglevelC #catalogID: #store #defaultString: 'Blessing level:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 63 0 -9 1 -57 1 ) 					#model: #text 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 38 ) 					#label: #(#{UserMessage} #key: #CommentC #catalogID: #store #defaultString: 'Comment:') ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -190 0.5 203 0 -126 0.5 233 0 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #Accept #catalogID: #store #defaultString: 'Accept') 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 126 0.5 203 0 190 0.5 233 0 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #store #defaultString: 'Cancel') 					#isDefault: false 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 8 0 -9 1 33 0 ) 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) ) ) )</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>menu</category><body package="Store-UI" selector="browseMenuItem">browseMenuItem	&lt;itemInMenu: #(#menu) position: 10.1&gt;	^(MenuItem labeled: #Browse &lt;&lt; #IDE &gt;&gt; 'Browse')		value: [self browseMenuTarget];		yourself</body><body package="Store-UI" selector="compareMenuItem">compareMenuItem	&lt;itemInMenu: #(#menu) position: 40.2&gt;	^(MenuItem labeled: #Compare &lt;&lt; #IDE &gt;&gt; 'Compare')		visible: [self isSelectedPeerDifferent];		value: 				[| tool |				tool := PackageComparisonTool							compareFromAll: (Array with: self selectedCodeComponent)							toAll: (Array with: self selectedCodeComponentPeer).				self isLeftSideSelection ifFalse: [tool swapSides]];		yourself</body><body package="Store-UI" selector="fileoutMenuItem">fileoutMenuItem	&lt;itemInMenu: #(#menu) position: 30.2&gt;	^(MenuItem		labeled: (#FileoutDifferencesFrom1s &lt;&lt; #IDE				&gt;&gt; 'File Out Differences from &lt;1s&gt;'					expandMacrosWith: self selectedCodeComponentPeer version))		visible: [self isSelectedPeerDifferent];		value: [self fileoutChangesToGetToMenuTarget];		yourself</body><body package="Store-UI" selector="loadMenuItem">loadMenuItem	&lt;itemInMenu: #(#menu) position: 20.5&gt;	^(MenuItem labeled: #Load &lt;&lt; #IDE &gt;&gt; 'Load')		hidden: [self selectedCodeComponent isImageModel];		value: 				[self selectedCodeComponent canLoadNewOrReplaceExistingVersion					ifTrue: 						[[self selectedCodeComponent loadSrc]							withStoreFeedbackOn: self topComponent]];		yourself</body><body package="Store-UI" selector="versionsMenuItem">versionsMenuItem	&lt;itemInMenu: #(#menu) position: 10.5&gt;	^(MenuItem labeled: #Versions &lt;&lt; #IDE &gt;&gt; 'Versions')		hidden: [self selectedCodeComponent isImageModel];		value: 				[Store.Glorp.DefinitionForListTool					forVersionsOfPackage: self selectedCodeComponent];		yourself</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView</class-id> <category>event states</category><body package="Store-UI" selector="button2Down:">button2Down: aButton2DownEvent	&lt;event: #Button2Down&gt;	| menuView valueResult |	self mouseMoved: aButton2DownEvent.	targetView ifNil: [^self].	self isPressed: true.	menuView := self widgetPolicy menuViewForMenu: self menu.	valueResult := menuView openFromView: self.	valueResult value ifNotNil: [:block | block value].	self isPressed: false</body><body package="Store-UI" selector="mouseExit">mouseExit	&lt;event: #MouseExit&gt;	isPressed ifFalse: [self targetView: nil]</body><body package="Store-UI" selector="mouseMoved:">mouseMoved: aMouseMoveEvent	&lt;event: #MouseMoved&gt;	| myPoint |	myPoint := self globalPointToLocal: aMouseMoveEvent point.	self targetView: (self children				detect: [:each | each frame containsPoint: myPoint]				ifNone: [nil])</body></methods><methods><class-id>Store.Glorp.BundleStructureComparisonView class</class-id> <category>method tags</category><body package="Store-UI" selector="methodTags">methodTags		&lt;pragmas: #instance&gt;	^#(#itemInMenu:position:)</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Store-UI" selector="applied16x16">applied16x16	"UIMaskEditor new openOnClass: self andSelector: #applied16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 7131 7388)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3501 5075)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 7227 7549)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 3212 4690)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 3276 4754)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1767 2409 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7003 7163 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 7195 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 3212 4658)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7067 7259 7581)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 3244 4754)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2827 3855 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3533 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 2377 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2473 3405 4979)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2249 3084 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7003 7195 7484)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2152 2955 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 3276 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7099 7292 7613)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 2698 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2184 3019 4401)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3662 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1767 2409 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 3694 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2795 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1799 2473 3598)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2730 3758 5493)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2249 3052 4465)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 2570 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2891 4208)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1542 2088 3052)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3533 5172)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1478 2024 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 2666 3887)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 3630 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1992 2730 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2762 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1574 2184 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 2216 3244)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2281 3148 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 2538 3726)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1927 2666 3855)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 2377 3469)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2216 3019 4401)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@PDA@PDA@PDA@PDA@PDA@PDA@PDADA@PDA@A@PDA@PDA@PD-A@HYCA$BAB4A@PDA@PDRB2P\GA0\GBPKD DA@PDAGP4WE1\WE1\TCQ4A@PDAF $!HRD!HRDJB (IF DA@QTSC0LOC0&lt;C@0LOD1TA@PD^AP HBALHB@ SD0T^@PDAF24)DQDQDQD)JR$-F0DA@R0%E!XGA0\VE!XVIR0A@PDAFA(_G0@_G1&lt;_F! A@PDA@R\NH2X&amp;I"X&amp;H08''@PDA@PDAHB FJ",*A"  @PDA@PDA@PDAH"H"H"HA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P@a'))</body><body package="Store-UI" selector="applied16x16mask">applied16x16mask	"UIMaskEditor new openOnClass: self andSelector: #applied16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 31 240 0 0 63 248 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 63 248 0 0 63 248 0 0 31 240 0 0 7 192 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="classMethod16x16">classMethod16x16	"UIMaskEditor new openOnClass: self andSelector: #classMethod16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1349 1574)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 6585 7099)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2281 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 6232 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 4626 5782)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 5043 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3309 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 1959 2313)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2987 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1445 1638 1927)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3855 3855 3855)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4915 5429 6328)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 4015 4722)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3598 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 2666 3116)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5846 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 4240 5525)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 3887 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3373 3822 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(996 1124 1317)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6585 6842 7292)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ ,B@ HBCPHB@ HB@ HB@ ,BB0HBD1TS@ HB@ HB@ ,B@ HKC DA@P8B@ HB@ ,B@ HBA0PBA@HDA0HB@ ,B@ HBBQ@B@ HB@!@I@ ,B@ HBC00LC@HL@ 0LC@&lt;BB0HB@ HCA HB@ HBA LB@ HK@ HB@  E@ TBAP B@ HB@ ,B@ HKB!DQDP(B@ HB@ HBB0HK@ H@D @B@ HB@ HB@ HK@ HB@!PB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @a'))</body><body package="Store-UI" selector="classMethod16x16mask">classMethod16x16mask	"UIMaskEditor new openOnClass: self andSelector: #classMethod16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 4 32 0 0 14 112 0 0 31 248 0 0 63 252 0 0 127 254 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 14 112 0 0 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="instanceMethod16x16">instanceMethod16x16	"UIMaskEditor new openOnClass: self andSelector: #instanceMethod16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1349 1574)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 6585 7099)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2281 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 6232 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 4626 5782)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 5043 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 3309 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 1959 2313)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2987 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1445 1638 1927)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3855 3855 3855)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4915 5429 6328)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 4015 4722)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3598 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 2666 3116)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5846 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 4240 5525)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 3887 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3373 3822 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(996 1124 1317)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6585 6842 7292)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ 4B@ HBB0HB@ HB@ HB@!LUD0HBB0HK@ HB@ HB@ 8A@PDNB0HB@ ,B@ HB@ \D@ PBA@\B@ HBB0HB@ $P@ HB@ HPBPHB@ HK@ &lt;LC@0BC@HLC@0O@ HB@ ,B@0XB@ HB@ XC@ HB@ ,B@ HHAPHE@ TH@ HB@ ,B@ HB@ (QDQDJB0HB@ ,B@ HB@ HB@AH@@ HK@ ,B@ HB@ HB@ HT@ HB@ ,B@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ HB@ @a'))</body><body package="Store-UI" selector="instanceMethod16x16mask">instanceMethod16x16mask	"UIMaskEditor new openOnClass: self andSelector: #instanceMethod16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 4 32 0 0 14 112 0 0 31 248 0 0 63 252 0 0 127 254 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 14 112 0 0 4 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="modificationAdd16x16">modificationAdd16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationAdd16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 3019 3630)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1767 3148)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 3630 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1670 2281 3341)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 3212 3694)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(964 1574 3052)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2152 2795 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(771 1349 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 4112 6585)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1959 3180 6232)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 6135 7388)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1927 2538 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5236 6553 7549)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1413 2024 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 5204 7035)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3341 3758)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 5686 7227)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 4658 6810)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'APTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEDA@PD@TEAPTEAPTEAPTEAPPMCPPEAPTEAPTEAPTEAPT@B0,@APTEAPTEAPTEA0\GA1DQA0\GA0TEAPTEAP0OC0&lt;OC0&lt;OC00EAPTEAPTCD!HRD!HRD!HCAPTEAPTEC 8NC $IC 8NC TEAPTEAPTEAPDB@ DEAPTEAPTEAPTEAPTFB (FAPTEAPTEAPTEAPTEB@ HB@TEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAP@a'))</body><body package="Store-UI" selector="modificationAdd16x16mask">modificationAdd16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationAdd16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 3 192 0 0 3 192 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 3 192 0 0 3 192 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="modificationChange16x16">modificationChange16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationChange16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 835 835)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 3565 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2827 1735 1735)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 1124 1124)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7581 5686 5686)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 1413 1413)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3148 2505 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 2827 2827)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2345 578 578)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3212 2698 2698)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2923 1992 1992)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7324 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 2281 2281)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 26 17 17 17 17 161 17 17 30 225 17 17 30 225 17 17 30 94 17 17 229 225 17 17 27 221 177 27 221 177 17 17 19 204 195 60 204 49 17 17 22 34 97 22 34 97 17 17 20 132 17 17 72 65 17 17 16 1 17 17 16 1 17 17 25 17 17 17 17 145 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17 17])</body><body package="Store-UI" selector="modificationChange16x16mask">modificationChange16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationChange16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 16 8 0 0 24 24 0 0 28 56 0 0 30 120 0 0 31 248 0 0 30 120 0 0 28 56 0 0 24 24 0 0 16 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="modificationMove16x16">modificationMove16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationMove16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2281 2827 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3919 6521)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5975 7324 7870)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(835 1349 2634)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 6071 7356)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 2249 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1124 1638 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1413 1959 2859)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2505 3084 3309)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2698 3276 3373)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2538 3084)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 3244 6264)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5429 6746 7613)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4112 5396 7099)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(578 1092 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 4658 6810)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0(J@0LC@0LC@0LC@0LC@0LI@ $I@0LC@0LC@0LC@0LC@@4MCP@@@0LC@0LC@0LC@0XEAPTEAPXF@0LC@0LC@0LFC 8NC 8NC XC@0LC@0LCBA@PDA@PB@ C@0LC@0LC@0\A@PDGA0LC@0LC@0LC@0LDC@PD@0LC@0LC@0LC@0LCC0&lt;C@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0@a'))</body><body package="Store-UI" selector="modificationMove16x16mask">modificationMove16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationMove16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 12 0 0 0 15 0 0 0 15 192 0 0 15 240 0 0 15 248 0 0 15 240 0 0 15 192 0 0 15 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="modificationRemove16x16">modificationRemove16x16	"UIMaskEditor new openOnClass: self andSelector: #modificationRemove16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2249 1670 1670)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1992 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2281 1767 1767)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2313 1863 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 3565 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 739 739)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2184 1542 1542)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7549 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2056 1221 1221)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7356 5139 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 3019 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 4626 4626)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 5942 5942)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1927 899 899)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 2505 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 1992 1992)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 4112 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1767 482 482)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1799 578 578)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 1381 1381)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LCA@LC@0LCA@LC@0LC@0LC@ 4B@0LC@ 4B@0LC@0LC@@ HB@@C@@ HB@@C@0LC@0LGB (JA0(JB \C@0LC@0LC@1PLC@0LCAPC@0LC@0LC@0LCBQDQDP$C@0LC@0LC@0LCBPTEAPTEBPLC@0LC@0LCC ,KB08KB0,N@0LC@0LCA &lt;OC0XCA &lt;OC0XC@0LC@0LSDALC@0LSDALC@0LC@0LC@1HC@0LC@1HC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0@a'))</body><body package="Store-UI" selector="modificationRemove16x16mask">modificationRemove16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modificationRemove16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 8 32 0 0 28 112 0 0 62 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 15 224 0 0 31 240 0 0 62 248 0 0 28 112 0 0 8 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="resolved16x16">resolved16x16	"UIMaskEditor new openOnClass: self andSelector: #resolved16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 5846 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 6296 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3084 5043 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2827 4658 2795)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 5589 3341)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 6199 3726)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3244 5332 3212)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4336 7131 4272)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2762 4561 2730)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4401 7292 4369)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3983 6553 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 5686 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 4369 2634)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 4979 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3373 5525 3309)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 6456 3887)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 7388 4433)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4850 8030 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 4947 2987)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4626 7613 4561)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4112 6746 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3855 6360 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4144 6842 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3052 5043 3019)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2570 4240 2570)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3662 6039 3630)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3148 5172 3116)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 5782 3469)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4079 6713 4047)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 5396 3244)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4658 7645 4593)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4144 6778 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3887 6424 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4690 7741 4626)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4176 6874 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 5621 3373)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 7870 4722)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@PDA@PDA@PDA@PDA@PDA@PDA@PDADA@PDA@A@PDA@PDA@PDVEP("D"HJEQXA@PDA@PDFHAP%IRT%IQP A DA@PDAHQD_G1&lt;_G1&lt;_DRDA@PDA@A4QDQDQDQDQDQD]@@DA@RP#B@ HB@ HB@ HH2PA@PD^E2L#H2L#H2L#H1\^@PDAF0HKB0,KB0,KB0,BF0DA@QLL@ HB@ HB@ HBCALA@PDAF@@ZF!(ZF!(Z@A A@PDA@P$NAQ0\GA0\AP8I@PDA@PDACPPXA0&lt;GF@PM@PDA@PDA@PDAFQ$YFQ$A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@PDA@P@a'))</body><body package="Store-UI" selector="resolved16x16mask">resolved16x16mask	"UIMaskEditor new openOnClass: self andSelector: #resolved16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 31 240 0 0 63 248 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 63 248 0 0 63 248 0 0 31 240 0 0 7 192 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="unresolved16x16">unresolved16x16	"UIMaskEditor new openOnClass: self andSelector: #unresolved16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7067 7067 7067)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6328 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6938 7035)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7581 7613)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7870 7870 7870)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 3533 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7934 7934)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 4144 4401)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 5396 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6456 6456 6456)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7259 7324)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 6007 6135)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8159 8159 8159)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 3244 3533)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7420 7420)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 7870 7902)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 3855 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 4465 4690)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 5075 5268)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 5718 5846)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'APTEAPTEAPTEAPTEAPTEAPTEAPTEB0,KB0,EAPTEAPTEAPTKBQ@DC PPBP,EAPTEAPTK@@\MD1HJC@\@B0TEAPTEBP\MC0&lt;FC1HEA0$EAPTEB1@ED0&lt;MAP O@PTPB0TEAP,DAP0BDPLRC00EA@,EAPTKC TEAPLFC1PEAP8KAPTEB0PEAPTUC1PEAPTDB0TEAP,PAPTE@!TCAPTED@,EAPTEBP\EAQLO@ TEA0$EAPTEAP,@A0TSC0HEA0@KAPTEAPTEB0$PA@8DD@$KAPTEAPTEAPTEB0,KB0,EAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAP@a'))</body><body package="Store-UI" selector="unresolved16x16mask">unresolved16x16mask	"UIMaskEditor new openOnClass: self andSelector: #unresolved16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 31 240 0 0 63 248 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 63 248 0 0 63 248 0 0 31 240 0 0 7 192 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.VisualLauncherToolDock</class-id> <category>component definitions</category><body package="Store-UI" selector="miniRepositoryManager">miniRepositoryManager	&lt;component: 20 class: #{Store.MiniRepositoryManager} spec: #windowSpec&gt;	^self newTool: Store.MiniRepositoryManager</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="Store-UI" selector="notifyDefinitionForListTool">notifyDefinitionForListTool	"DefinitionForListTool has an interest in #earlySystemInstallation.   When that event occurs,	 it will clear out any open browsers."	&lt;triggerAtSystemEvent: #earlySystemInstallation&gt;	Store.Glorp.DefinitionForListTool cleanUpObsoleteInstances</body><body package="Store-UI" selector="notifyPublishedPundleVersionsTool">notifyPublishedPundleVersionsTool	"DefinitionForListTool has an interest in #earlySystemInstallation.   When that event occurs,	 it will clear out any open browsers."	&lt;triggerAtSystemEvent: #earlySystemInstallation&gt;	Store.Glorp.PublishedPundleVersionsTool cleanUpObsoleteInstances</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>system information</category><body package="Store-UI" selector="printBundlesOn:">printBundlesOn: aStream	&lt;systemInformation: 2.1&gt;	aStream nextPutAllText: (#Bundles &lt;&lt; #store &gt;&gt; 'Bundles:') asText allBold.	self printNamesAndVersionsOf: Store.Registry allBundles on: aStream.	aStream cr</body><body package="Store-UI" selector="printPackagesOn:">printPackagesOn: aStream	&lt;systemInformation: 2.2&gt;	aStream nextPutAllText: (#PackagesC &lt;&lt; #store &gt;&gt; 'Packages:') asText allBold.	self printNamesAndVersionsOf: Store.Registry allPackages on: aStream.	aStream cr</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="store05ParcelDirectory">store05ParcelDirectory	&lt;setting: #(store parcelDirectory)&gt;	^(DirectorySetting on: Store.PundleAccess aspect: #parcelDirectory)		default: Filename currentDirectory asLogicalFileSpecification asString;		label: #ParcelDirectory &lt;&lt; #store  &gt;&gt; 'Parcel Directory';		helpText:  #ParcelDirectoryHelp &lt;&lt; #store  &gt;&gt; 'When publishing a pundle, one can optionally choose to publish a parcel for the pundle.  This setting is the directory that will be those parcels are published.  When loading a bundle that has been published binary into the database, this directory is also used to create a subdirectory store the parcel sources file. The name of the subdirectory will be the database identifier for the database that the pundle was loaded from.'</body><body package="Store-UI" selector="store10FilesLoadingPromptPolicy">store10FilesLoadingPromptPolicy	&lt;setting: #(store files promptingPolicy)&gt;	^((EnumerationSetting 				choices: #(alwaysDownload neverDownload prompt)				labels: (Array 							with: (#DownloadWithoutPrompting &lt;&lt; #store &gt;&gt; 'Download without prompting')							with: (#NeverDownload &lt;&lt; #store &gt;&gt; 'Never Download')							with: (#PromptWhenDownloading &lt;&lt; #store &gt;&gt; 'Prompt when downloading')))			on: Store.Policies filePolicy aspect: #downloadPreference)		label: #WhenLoadingBundlesLabel &lt;&lt; #store &gt;&gt;'When loading bundles that have files';		helpText: #FileLoadingPromptPolicy &lt;&lt; #store &gt;&gt; 'When a bundle has files associated with it, you have three choices on what to do with those files.  You can download the files without being asked, never download files or be asked which files you want downloaded.'</body><body package="Store-UI" selector="store14UseNewCompareTool">store14UseNewCompareTool	&lt;setting: #(#store #useNewCompareTool)&gt;	^(BooleanSetting on: #{Store.ComparePackages.UseNewCompareTool})		label: #UseNewCompareTool &lt;&lt; #labels &gt;&gt; 'Use New Compare Tool';		helpText: ''</body><body package="Store-UI" selector="store15FilesLoadingUseDownloadDirectory">store15FilesLoadingUseDownloadDirectory	&lt;setting: #(store files useDownloadDirectory)&gt;	^(BooleanSetting on: Store.Policies filePolicy aspect: #useDownloadDirectory)		label: #UseDownloadDirectory &lt;&lt; #store &gt;&gt; 'Use Download Directory';		default: Filename currentDirectory asLogicalFileSpecification;		helpText: #UseDownloadDirectoryHelp &lt;&lt; #store &gt;&gt; 'If checked use the download directory.'</body><body package="Store-UI" selector="store15UseFastComparison">store15UseFastComparison	&lt;setting: #(store useFastComparison)&gt;	^(BooleanSetting on: Store.PundleModel aspect: #useChangeSetsForCompare)		label: #UseFastComparison &lt;&lt; #labels &gt;&gt; 'Use fast comparison';		helpText: #store15UseFastComparison &lt;&lt; #dialogs &gt;&gt; 'This option chooses how Store determines changes that need to be published.  When on, Store uses change sets, when off, it compares code in the image with the database.Usually fast comparison should be turned on.  This results in much faster performance when publishing and when comparing a loaded package with a version in the database.Occasionally you may encounter a bug that causes the change set of a package to enter an incorrect state.  In this case, publishing the package may not publish all changed definitions, and comparing the in-image package with a database version may likewise fail to compute the correct result.To cause the publish and compare operations to ignore the damaged change set, turn this setting off.  This forces these operations to compare the in-image version directly with the database version rather than consulting the change set to find out what has changed since the package was loaded.'</body><body package="Store-UI" selector="store20FilesLoadingDownloadDirectory">store20FilesLoadingDownloadDirectory	&lt;setting: #(store files downloadDirectory)&gt;	^(DirectorySetting on: Store.Policies filePolicy aspect: #downloadDirectory)		label: #DownloadDirectory &lt;&lt; #store &gt;&gt; 'Download Directory';		default: Filename currentDirectory asLogicalFileSpecification;		helpText: #DownloadDirectoryHelp &lt;&lt; #store &gt;&gt; 'This the directory that where files that are downloaded from a bundle are stored.  If the files being downloaded have use a SystemVariable (for example: ''$(VARIABLE)/file.txt'') then the variable will be ignored, and the download directory will be used instead.'</body><body package="Store-UI" selector="store20WarnOnNewerPundle">store20WarnOnNewerPundle	&lt;setting: #(#store #publishingPolicy #warnOnNewer)&gt;	^(BooleanSetting on: #{Store.Glorp.StoreObject} value aspect: #warnIfNewerVersionPublished)		label: #WarnOnNewerVersionPublished &lt;&lt; #labels &gt;&gt; 'Display a warning when publishing if a newer version exists';		default: false;		helpText: #WarnOnNewerVersionPublishedHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled, if a newer version of the item you are about to publish exists in the repository, a dialog will open allowing you to choose whether or not to proceed to publish your version. This gives you the opportunity to examine the changes in the newer version before publishing your work should you choose to not proceed.'</body><body package="Store-UI" selector="store50NewClassPackage">store50NewClassPackage	&lt;setting: #(store packageDefaults newClassPackage)&gt;	^((EnumerationSetting 		keys: #(#current #prompt)		choices: #(true false)		labels: (Array with: (#Current &lt;&lt; #store &gt;&gt; 'Current') with: (#Prompt &lt;&lt; #store &gt;&gt; 'Prompt'))) 			on: (Store.StoreSettings preferenceModelFor: #newClassUseCurrent)) 			label: #ForANewClass &lt;&lt; #store &gt;&gt; 'For a new class'</body><body package="Store-UI" selector="store50UseShadowLoading">store50UseShadowLoading	&lt;setting: #(store #loadingPolicy useShadowLoading)&gt;	^(BooleanSetting on: Store.DBAccess aspect: #useAtomicLoader)		default: true;		label: #useAtomicLoader &lt;&lt; #labels &gt;&gt; 'Use the atomic loader';		helpText: #useAtomicLoaderHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will load use the atomic loader when loading packages and bundles from a database.  The atomic loader allows you to load code that might otherwise not be loadable under normal loading.'</body><body package="Store-UI" selector="store51UseAnalysisLoader">store51UseAnalysisLoader	&lt;setting: #(store #loadingPolicy useAnalysisLoader)&gt;	^(BooleanSetting on: Store.DBAccess aspect: #useAnalysisLoader)		default: true;		label: #useAtomicAnalysisLoader &lt;&lt; #labels &gt;&gt; 'Use the atomic analysis loader';		helpText: #useAtomicAnalysisLoaderHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled along with the atomic loader, Store will load use an analysis loader, which will analyze the component(s) being loaded, and attempt to process all the definitions in as few passes as possible'</body><body package="Store-UI" selector="store52NewMethodPackage">store52NewMethodPackage	&lt;setting: #(store packageDefaults newMethodPackage)&gt;	^((EnumerationSetting 		choices: #(#currentINAU #currentINUTCP #useTCP #useTCPIC #useTCPICON #alwaysAsk)		labels: (Array 				with: (#Current &lt;&lt; #store &gt;&gt; 'Current') 				with: (#CurrentOrClassPackage &lt;&lt; #store &gt;&gt; 'Current or class package') 				with: (#ClassPackage &lt;&lt; #store &gt;&gt; 'Class package') asString) , 					(Array 						with: (#ClassIfSameAsCurrent &lt;&lt; #store &gt;&gt; 'Class if same as current') 						with: (#ClassIfSameAsCurrentOrNone &lt;&lt; #store &gt;&gt; 'Class if same as current or none') 						with: (#AlwaysPrompt &lt;&lt; #store &gt;&gt; 'Always prompt') )) 			on: (Store.StoreSettings preferenceModelFor: #methodPlacement)) 			label: #ForANewMethod &lt;&lt; #store &gt;&gt; 'For a new method'</body><body package="Store-UI" selector="store54NewSharedPackage">store54NewSharedPackage	&lt;setting: #(store packageDefaults newSharedPackage)&gt;	^((EnumerationSetting 		choices: #(#currentINAU #currentINUTCP #useTCP #useTCPIC #useTCPICON #alwaysAsk)		labels: (Array 				with: (#Current &lt;&lt; #store &gt;&gt; 'Current') 				with: (#CurrentOrClassPackage &lt;&lt; #store &gt;&gt; 'Current or class package') 				with: (#ClassPackage &lt;&lt; #store &gt;&gt; 'Class package') asString) , 					(Array 						with: (#ClassIfSameAsCurrent &lt;&lt; #store &gt;&gt; 'Class if same as current') 						with: (#ClassIfSameAsCurrentOrNone &lt;&lt; #store &gt;&gt; 'Class if same as current or none')						with: (#AlwaysPrompt &lt;&lt; #store &gt;&gt; 'Always prompt'))) 			on: (Store.StoreSettings preferenceModelFor: #datumPlacement)) 			label: #ForANewVariable &lt;&lt; #store &gt;&gt; 'For a new variable'</body><body package="Store-UI" selector="store58WarnOnUpdatingUnchangedPackage">store58WarnOnUpdatingUnchangedPackage	&lt;setting: #(store packageDefaults warnOnUpdatingUnchanged)&gt;	^(BooleanSetting 		on: Store.Policies packagePolicy		aspect: #warnOnFirstModification)			label: #warnOnUpdatingUnchangedPackage &lt;&lt; #labels &gt;&gt; 'Warn before updating an unchanged package';			default: false;			helpText: #warnOnUpdatingUnchangedPackageHelp &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will ask you if you wish to change an unchanged package during load. Otherwise it will simply make the change and continue loading'</body><body package="Store-UI" selector="store60AllowBinaryLoading">store60AllowBinaryLoading	&lt;setting: #(store loadingPolicy allowBinaryLoading)&gt;	^(BooleanSetting on: Store.Policies publishPolicy aspect: #allowBinaryLoading)		label: #allowBinaryLoading &lt;&lt; #labels &gt;&gt; 'Allow binary loading';		helpText: #store60AllowBinaryLoading &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will load binary all packages that were saved binary. When disabled, Store will load source code in all cases.'</body><body package="Store-UI" selector="store80IncludePackageIntoFileout">store80IncludePackageIntoFileout		&lt;setting: #(#store #includePackageIntoFileout)&gt;	| adaptor |	adaptor := (PluggableAdaptor on: (Store.StoreSettings preferenceModelFor: #fileoutOption))		getBlock: [:model | model value]		putBlock:			[:model :value | 			model value: value.			value == #always 				ifTrue: [Registry installCallBacksForFileout] 				ifFalse: [Registry removeCallBacksForFileout]]		updateBlock: [:model :aspect :parameter | true].	^((EnumerationSetting		choices: #(#never #storeOnly #always)		labels: (Array 			with: #Never &lt;&lt; #store &gt;&gt; 'Never' 			with: #ForPackageFileouts &lt;&lt; #store &gt;&gt; 'For package fileouts' 			with: #Always &lt;&lt; #store &gt;&gt; 'Always'))				on: adaptor) label: #FileOutPackageInformation &lt;&lt; #store &gt;&gt; 'File out package information'</body><body package="Store-UI" selector="store80ReconnectOnRestart">store80ReconnectOnRestart	&lt;setting: #(#store #reconnectOnRestart)&gt;	^((EnumerationSetting 			choices: #(#disconnect #prompt #reconnect)			labels: (Array					with: (#DisconnectOption &lt;&lt; #store &gt;&gt; 'Do not reconnect to the Store database')					with: (#PromptOption &lt;&lt; #store &gt;&gt; 'Prompt to reconnect with last saved profile' )					with: (#ReconnectOption &lt;&lt; #store &gt;&gt; 'Automatically reconnect with last saved profile' )))		on: Store.StoreDevelopmentSystem aspect: #reconnectAction)		label: #ReconnectOnRestart &lt;&lt; #store &gt;&gt; 'Reconnect action on restart';		helpText: #ReconnectOnRestartHelpText &lt;&lt; #store &gt;&gt; 'This setting determines what action Store takes on restarting an image that was connected to a Store database when saved.  There are three options, disconnect, prompt, and reconnect.  If the setting is "disconnect," Store will remain disconnected.  If the setting is "reconnect," Store will attempt to reconnect using the same profile as the saved connection.  If the setting is "prompt," Store will prompt the user to reconnect, using as default the same profile as the saved connection.'</body><body package="Store-UI" selector="store80StoreIILoadFailOption">store80StoreIILoadFailOption	&lt;setting: #(store loadingPolicy storeIILoadFailOption)&gt;	^((EnumerationSetting 			choices: #(#loadButNotify #load #displayDialog #fail)			labels: (Array					with: (#LoadButNotifyOption &lt;&lt; #store &gt;&gt; 'Complete the load but open a tool to manage errors')					with: (#LoadOption &lt;&lt; #store &gt;&gt; 'Ignore errors and load what can be loaded' )					with: (#DisplayDialogOption &lt;&lt; #store &gt;&gt; 'Open a dialog to ask what to do')					with: (#FailOption &lt;&lt; #store &gt;&gt; 'Load only if there are no errors' )))		on: Store.AtomicLoader.LoadFailedOption)		label: #FailOptionPrompt &lt;&lt; #store &gt;&gt; 'How should load errors be handled?';		helpText: #FailOptionText &lt;&lt; #store &gt;&gt; 'This setting controls what will happen when errors are encountered in the process of loading a package or bundle.  The first two options WILL modify the system.  The third option will allow you to decide what to do before the system is changed.  The last option will leave the system unchanged.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storeFilesDownloadingPage">storeFilesDownloadingPage	&lt;settingsPage: #(store files)&gt;	|directory useDownload|	directory := DirectorySettingModule on: (self settingWithId: #(store files downloadDirectory)).	useDownload := BooleanSettingModule on: (self settingWithId: #(store files useDownloadDirectory)).	^ModularSettingsPage new		label: #FilesDownloadingPolicy &lt;&lt; #labels &gt;&gt; 'Files Downloading';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		addAllSettings: (self settingsWithPrefix: #(store files)					except: #(useDownloadDirectory downloadDirectory));		addModule: useDownload;		addModule: directory;		when: useDownload valueHolder valueSatisfies: [:v | v = true] enable: directory</body><body package="Store-UI" selector="storeLoadingPolicy">storeLoadingPolicy	&lt;settingsPage: #(#store #loadingPolicy)&gt;	^ModularSettingsPage new		label: #LoadingPolicyLoading &lt;&lt; #store &gt;&gt; 'Loading Policies';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store loadingPolicy))</body><body package="Store-UI" selector="storePackageDefaultPage">storePackageDefaultPage	&lt;settingsPage: #(store packageDefaults)&gt;	^ModularSettingsPage new		label: #StoreDefaultPackage &lt;&lt; #labels &gt;&gt; 'Default Package';		icon: (ListIconLibrary visualFor: #store);		settings: (self settingsWithPrefix: #(store packageDefaults))</body><body package="Store-UI" selector="storePage">storePage	&lt;settingsPage: #(store)&gt;	^ModularSettingsPage new		label: #Store &lt;&lt; #labels &gt;&gt; 'Store';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storePrerequisitesBlessingLevel">storePrerequisitesBlessingLevel	&lt;setting: #(#store #prerequisites #blessingLevel ) position: 10  &gt;	| levels choices labels keys |	levels := Store.Policies blessingPolicy blessings asSortedCollection.	choices := levels collect: [:each | each level].	labels := levels collect: [:each | each name].	keys := levels collect: [:each | each level printString asSymbol].	^((EnumerationSetting		keys: keys		choices: choices		labels: labels)		on: Store.Policies prerequisitePolicy aspect: #blessingLevel)		label: #WithBlessingLevelAtLeast &lt;&lt; #store &gt;&gt; '...with blessing level at least'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storePrerequisitesPage">storePrerequisitesPage	&lt;settingsPage: #(store prerequisites)&gt;	| version level |	version := EnumerationSettingRadioModule 				on: (self settingWithId: #(#store #prerequisites #versionSelection)).	level := EnumerationSettingModule 				on: (self settingWithId: #(#store #prerequisites #blessingLevel)).	^(ModularSettingsPage new)		label: #Prerequisites &lt;&lt; #labels &gt;&gt; 'Prerequisites';		icon: (ListIconLibrary visualFor: #store);		addModule: version;		addModule: level;		when: version valueHolder valueSatisfies: [:v | v = #latest] enable: level;		useRadioButtonsForEnumerations;		addAllSettings: (self settingsWithPrefix: #(#store #prerequisites)					except: #(#versionSelection #blessingLevel))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storePrerequisitesSeachOrder">storePrerequisitesSeachOrder	&lt;setting: #(store prerequisites searchOrder) position: 20 &gt;	^((EnumerationSetting choices: #(#pundlesFirst #parcelsFirst)		labels: (Array 				with: (#SearchBundlesAndPackagesFirst &lt;&lt; #store &gt;&gt; 'Search bundles and packages first')				with: (#SearchParcelsFirst &lt;&lt; #store &gt;&gt; 'Search parcels first'))) 			on: Store.Policies prerequisitePolicy			aspect: #searchOrder) 			label: #ToLoadAnyPrerequisite &lt;&lt; #store &gt;&gt; 'To load #any prerequisite'</body><body package="Store-UI" selector="storePrerequisitesVersionSelection">storePrerequisitesVersionSelection	&lt;setting: #(store prerequisites versionSelection) position: 30 &gt;	^((EnumerationSetting choices: #(#ask #latest)		labels: (Array with: (#AlwaysPromptForVersion &lt;&lt; #store &gt;&gt; 'Always prompt for version') with: (#LoadLatestVersion &lt;&lt; #store &gt;&gt; 'Load latest version...'))) 			on: Store.Policies prerequisitePolicy			aspect: #versionSelection) 			label: #WhenLoadingAPrerequisite &lt;&lt; #store &gt;&gt; 'When loading a prerequisite'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storePublishingPolicy">storePublishingPolicy	&lt;settingsPage: #(store publishingPolicy)&gt;	^ModularSettingsPage new		label: #PublishingPolicy &lt;&lt; #labels &gt;&gt; 'Publishing Policy';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store publishingPolicy))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storeRepositories">storeRepositories	&lt;setting: #(store repositories)&gt;	^StoreRepositoryListSetting new</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storeRepositoriesPage">storeRepositoriesPage	&lt;settingsPage: #(store repositories)&gt;	^StoreRepositoryListPage new		label: #StoreRepositories &lt;&lt; #labels &gt;&gt; 'Repositories';		icon: (ListIconLibrary visualFor: #store);		setting: (self settingWithId: #(store repositories))</body><body package="Store-UI" selector="storeTableSpacesPage">storeTableSpacesPage	&lt;settingsPage: #(store tableSpaces)&gt;	^ModularSettingsPage new		label: #StoreTableSpaces &lt;&lt; #labels &gt;&gt; 'Table Spaces';		icon: (ListIconLibrary visualFor: #store);		settings: (self settingsWithPrefix: #(store tableSpaces))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="tableSpaces20ForBlobs">tableSpaces20ForBlobs	&lt;setting: #(store tableSpaces tableSpaces20ForBlobs)&gt;	^(StringSetting on: Store.Policies tableSpacePolicy aspect: #blobTableSpace)		label: #TableSpaceForBlobs &lt;&lt; #store &gt;&gt; 'Blobs';		helpText: #TableSpaceForBlobsHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which Blob and Binary Blob objects are stored'</body><body package="Store-UI" selector="tableSpaces30ForMethods">tableSpaces30ForMethods	&lt;setting: #(store tableSpaces tableSpaces30ForMethods)&gt;	^(StringSetting on: Store.Policies tableSpacePolicy aspect: #methodsTableSpace)		label: #Methods &lt;&lt; #store &gt;&gt; 'Methods';		helpText: #TableSpaceForMethodsHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which Methods are stored'</body><body package="Store-UI" selector="tableSpaces40ForUserInfo">tableSpaces40ForUserInfo	&lt;setting: #(store tableSpaces tableSpaces40ForUserInfo)&gt;	^(StringSetting on: Store.Policies tableSpacePolicy aspect: #userAndOwnershipTableSpace)		label: (#TableSpaceForUserInfo &lt;&lt; #store &gt;&gt; 'Ownership and Privileges');		helpText: #TableSpaceForUserPrivHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which user privileges and owerhship information is stored'</body><body package="Store-UI" selector="tableSpaces50Other">tableSpaces50Other	&lt;setting: #(store tableSpaces #tableSpaces50Other)&gt;	^(StringSetting on: Store.Policies tableSpacePolicy aspect: #defaultTableSpace)		label: #TableSpaceOther &lt;&lt; #store &gt;&gt; 'All Other Tables';		helpText: #TableSpaceDefaultHelpText &lt;&lt; #dialogs &gt;&gt; 'This is the database table space in which all tables are created other than the ones that are specified'</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI" selector="administration">administration	&lt;submenu: #(#_Administration #store '&amp;Administration')		nameKey: #administration		menu: #(#menuBar #store)		position: 90.01&gt;</body><body package="Store-UI" selector="browseClassDefinitions">browseClassDefinitions	&lt;menuItem: #(#ClassNamedDots #store 'Class named...') 		icon: nil 		nameKey: #browseClassDefinitions 		enablement: #areAttached 		indication: nil 		menu: #(#menuBar #store #browseDefinitions) 		position: 90.04&gt;	| name list matches targetName session |	name := Dialog request: (#ClassNameMatching &lt;&lt; #store &gt;&gt; 'Class name matching') asString.	name isEmpty ifTrue: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Store.Gathering for: name) started.	matches := Store.Glorp.StoreClassDefinition allNamesMatching: name in: session.	(Store.Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	matches isEmpty ifTrue: 		[^self noItemsOfType: (#ClassName &lt;&lt; #store &gt;&gt; 'Class name') asString match: name].	(targetName := self selectNameFrom: matches chooseTitle: (#ClassName &lt;&lt; #store &gt;&gt; 'Class name') asString) ifNil: [^self].	[(Store.Gathering for: targetName) started.	list := Store.Glorp.StoreClassDefinitionInPackage allVersionsWithName: targetName in: session.	(Store.Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	list isEmpty ifTrue: 		[^Dialog warn: (#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.' expandMacrosWith: targetName)].	Store.Glorp.DefinitionForListTool forClasses: list</body><body package="Store-UI" selector="browseDefinitions">browseDefinitions	&lt;submenu: #(#Browse_Definitions #store 'Browse &amp;Definitions')		nameKey: #browseDefinitions		menu: #(#menuBar #store)		position: 20.09&gt;</body><body package="Store-UI" selector="browseNameSpaceDefinitions">browseNameSpaceDefinitions	&lt;menuItem: #(#NameSpaceNamedDots #store 'NameSpace named...')		icon: nil		nameKey: #browseNameSpaceDefinitions		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.10&gt;	| name list session matches targetName |	name := Dialog request: (#NameSpaceNameMatching &lt;&lt; #store &gt;&gt; 'NameSpace name matching') asString.	name isEmpty ifTrue: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Store.Gathering for: name) started.	matches := Store.Glorp.StoreNameSpace allNamesMatching: name in: session.	(Store.Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	matches isEmpty ifTrue: 		[^self noItemsOfType: (#NameSpaceName &lt;&lt; #store &gt;&gt; 'NameSpace name') asString match: name].	(targetName := self selectNameFrom: matches chooseTitle: (#NameSpaceName &lt;&lt; #store &gt;&gt; 'NameSpace name') asString) ifNil:		[^self].	[(Store.Gathering for: targetName) started.	list := Store.Glorp.StoreNamespaceInPackage allVersionsWithName: targetName in: session.	(Store.Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	list isEmpty 		ifTrue: 			[^Dialog warn: ((#_1sHasNotBeenPublished &lt;&lt; #store &gt;&gt; '&lt;1s&gt; has not been published.') expandMacrosWith: targetName)].	Store.Glorp.DefinitionForListTool forNameSpaces: list</body><body package="Store-UI" selector="browseSelector">browseSelector	&lt;menuItem: #(#SelectorNamedDots #store 'Selector named...')		icon: nil		nameKey: #browseSelector		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.06&gt;	| name list classes className session matches targetName |	name := Dialog request: (#SelectorNameMatching &lt;&lt; #store &gt;&gt; 'Selector name matching') asString.	name isEmpty ifTrue: [^self].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Store.Gathering for: name) started.	matches := Store.Glorp.StoreMethod allNamesMatching: name in: session.	(Store.Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	matches isEmpty ifTrue: 		[^self noItemsOfType: (#SelectorName &lt;&lt; #store &gt;&gt; 'Selector name') asString match: name].	(targetName := self selectNameFrom: matches chooseTitle: (#SelectorName &lt;&lt; #store &gt;&gt; 'Selector name') asString) ifNil: [^self].	[(Store.Gathering for: targetName) started.	list := Store.Glorp.StoreMethodInPackage allVersionsWithName: targetName in: session.	classes := list collect: [:each | each classNameWithMeta asSymbol].	classes := classes asSet asSortedCollection asOrderedCollection.	(Store.Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	className := classes size == 1		ifTrue: [classes first]		ifFalse: 			[Dialog 				choose: ((#_1sInWhichClassDots &lt;&lt; #store &gt;&gt; '#&lt;1s&gt; in which class...') expandMacrosWith: targetName)				fromList: classes 				values: classes				lines: 10 				cancel: [^nil]				for: self mainWindow].	[(Store.Gathering for: className) started.	list := Store.Glorp.StoreMethodInPackage allVersionsWithName: targetName inClass: className in: session.	(Store.Gathering for: className) finished] withStoreFeedbackOn: self mainWindow.	Store.Glorp.DefinitionForListTool forMethods: list.</body><body package="Store-UI" selector="browseStatic">browseStatic	&lt;menuItem: #(#SharedVariableNamedDots #store 'Shared Variable named...')		icon: nil		nameKey: #browseStatic		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.08&gt;	| name list owners owner session matches targetName typeString |	name  := Dialog request: (#SharedVariableNameMatching &lt;&lt; #store &gt;&gt; 'Shared Variable name matching') asString.	name isEmpty ifTrue: [ ^self ].	session := Store.Glorp.StoreLoginFactory currentStoreSession.	[(Store.Gathering for: name) started.	matches := Store.Glorp.StoreSharedVariable allNamesMatching: name in: session.	(Store.Gathering for: name) finished] withStoreFeedbackOn: self mainWindow.	typeString := (#SharedVariableName &lt;&lt; #store &gt;&gt; 'Shared Variable name') asString.	matches isEmpty ifTrue: 		[^self noItemsOfType: typeString match: name].	(targetName := self selectNameFrom: matches chooseTitle: typeString) ifNil: [^self].	[(Store.Gathering for: targetName) started.	list := Store.Glorp.StoreSharedVariableInPackage allVersionsWithName: targetName in: session.	owners := list collect: [:each | each absoluteOwnerName asSymbol].	owners := owners asSet asSortedCollection asOrderedCollection.	(Store.Gathering for: targetName) finished] withStoreFeedbackOn: self mainWindow.	owner := owners size == 1		ifTrue: [owners first]		ifFalse: 			[Dialog 				choose: ((#_1sInWhichClassOrNameSpaceDots &lt;&lt; #store &gt;&gt; '#&lt;1s&gt; in which Class or NameSpace...')  expandMacrosWith: name )				fromList: owners 				values: owners				lines: 10 				cancel: [^nil]				for: self mainWindow ].	[(Store.Gathering for: owner) started.	list := Store.Glorp.StoreSharedVariableInPackage allVersionsWithName: targetName inOwner: owner in: session.	(Store.Gathering for: owner) finished] withStoreFeedbackOn: self mainWindow.	Store.Glorp.DefinitionForListTool forSharedVariables: list.</body><body package="Store-UI" selector="browseUnpackaged">browseUnpackaged	&lt;menuItem: #(#Browse_Unpackaged #store 'Browse &amp;Unpackaged')		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 20.07&gt;	Store.PundleAccess moveUnpackagedToNullPackage.	Refactory.Browser.RefactoringBrowser openOnEnvironment:  (Refactory.Browser.PundleEnvironment new pundles: (List with: Store.Registry nullPackage))</body><body package="Store-UI" selector="bundleOwnershipManagement">bundleOwnershipManagement	&lt;menuItem: #(#_BundleOwnership #store '&amp;Bundle Ownership')		icon: nil		nameKey: #bundleOwnershipManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.05&gt;	Store.DbRegistry 		doIfImageAdministrator: [Store.BundlePrivilegeGraph open]		label: (#manageBundleOwnership &lt;&lt; #store &gt;&gt; 'manage bundle ownership') asString</body><body package="Store-UI" selector="checkConsistency">checkConsistency	&lt;menuItem: #(#CheckConsistency #store 'Check Consistency')		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 90.99&gt;	| strm warning |	strm := WriteStream on: String new.	Cursor wait showWhile: [Registry checkConsistencyOn: strm].	warning := strm contents.	Dialog warn: 			(warning size = 0 				ifTrue: 					[#EverythingChecksOutFine &lt;&lt; #store &gt;&gt; 'Everything checks out fine']				ifFalse: [warning])</body><body package="Store-UI" selector="currentPackage">currentPackage	&lt;menuItem: #(#_CurrentPackage #store '&amp;Current Package...')		icon: nil 		nameKey: #currentPackage		menu: #(#menuBar #store)		position: 50.05&gt;	| pkg |	pkg := Registry currentPackage.	pkg := PackageChooser 				chooseOrAdd: (#CurrentPackage1s &lt;&lt; #store &gt;&gt; 'Current Package: &lt;1s&gt;' 						expandMacrosWith: pkg name)				withDefault: pkg				onCancelDo: [^self].	Registry currentPackage: pkg</body><body package="Store-UI" selector="openGarbageCollectionDialog">openGarbageCollectionDialog	&lt;menuItem: #(#_GarbageCollection #store '&amp;Garbage Collection')		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.99&gt;	DbRegistry connectedProfile isNil		ifFalse: [Store.MarkPundlesForDeletionTool open]		ifTrue: [Dialog warn: (#YouMustBeConnectedForGarbageCollection &lt;&lt; #store &gt;&gt; 'You must be connected to a repository in order to open the garbage collection tool')]</body><body package="Store-UI" selector="openLoadedItems">openLoadedItems	&lt;menuItem: #(#_LoadedItems #store '&amp;Loaded Items')		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 20.01&gt;	Store.Glorp.PublishedPundleVersionsTool openOnAllLoadedPundles</body><body package="Store-UI" selector="openPublishedItems">openPublishedItems	&lt;menuItem: #(#_PublishedItems #store '&amp;Published Items')		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 20.02&gt;	DbRegistry doIfOnlineImage: 		[Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundles]</body><body package="Store-UI" selector="openRecentPublishedItems">openRecentPublishedItems	&lt;menuItem: '&amp;More Recently Published Items'		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 20.05&gt;	DbRegistry doIfOnlineImage: 		[Store.Glorp.PublishedPundleVersionsTool openRecentPublishedItems]</body><body package="Store-UI" selector="openUISettings">openUISettings	&lt;menuItem: #(#_Settings #store '&amp;Settings')		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 50.01&gt;	SettingsManager 		openOrRaise: VisualWorksSettings 		selectPage: #(#store)</body><body package="Store-UI" selector="packageOwnershipManagement">packageOwnershipManagement	&lt;menuItem: #(#Package_Ownership #store 'Package &amp;Ownership')		icon: nil		nameKey: #packageOwnershipManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.05&gt;	Store.DbRegistry 		doIfImageAdministrator: [Store.PrivilegeGraph open]		label: (#manageOwnership &lt;&lt; #store &gt;&gt; 'manage ownership') asString</body><body package="Store-UI" selector="removeDatabaseLinks">removeDatabaseLinks	&lt;menuItem: #(#RemoveDatabaseLinks #store 'Remove Database Links...')		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 90.10&gt;	Store.Registry removeDatabaseLinks.</body><body package="Store-UI" selector="renameBundleInDatabase">renameBundleInDatabase	&lt;menuItem: #(#RenameBundleInDatabase #store 'Rename Bundle in Database...')		icon: nil		nameKey: #renameBundle		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.10&gt;	Store.DbRegistry 		doIfImageAdministrator: 			[(Dialog confirm: (#RenamingABundleInTNttttttttContinue &lt;&lt; #store &gt;&gt; 'Renaming a bundle in the database will require all existing images to rename to match.&lt;nttttttt&gt;Continue?') expandMacros) ifFalse: [^self].			Store.Glorp.StoreBundle rename]		label: (#renameBundles &lt;&lt; #store &gt;&gt; 'rename bundles') asString</body><body package="Store-UI" selector="renamePackageInDatabase">renamePackageInDatabase	&lt;menuItem: #(#RenamePackageInDatabase #store 'Rename Package in Database...')		icon: nil		nameKey: #renamePackage		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.11&gt;	Store.DbRegistry 		doIfImageAdministrator: 			[(Dialog confirm: (#RenamingAPackageInNttttttttContinue &lt;&lt; #store &gt;&gt; 'Renaming a package in the database will require all existing images to rename to match.&lt;nttttttt&gt;Continue?') expandMacros) ifFalse: [^self].			Store.Glorp.StorePackage rename]		label: (#renamePackages &lt;&lt; #store &gt;&gt; 'rename packages') asString</body><body package="Store-UI" selector="store">store	&lt;submenu: #(#St_ore #store 'St&amp;ore')		nameKey: #store		menu: #(#menuBar)		position: 10.035&gt;</body><body package="Store-UI" selector="switchDatabases">switchDatabases	&lt;menuItem: #(#SwitchDatabases #store 'Switch Databases')		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 90.08&gt;	Store.Registry switchDatabases.</body><body package="Store-UI" selector="toggleStoreRepositoryConnection">toggleStoreRepositoryConnection	&lt;menuItem: #toggleStoreConnectionItemLabel		nameKey: nil		menu: #(#menuBar #store)		position: 10.5&gt;	DbRegistry isConnected 		ifTrue: [DbRegistry disconnect]		ifFalse: [DbRegistry restoreConnection]</body><body package="Store-UI" selector="userGroupManagement">userGroupManagement	&lt;menuItem: #(#UserGroup_Management #store 'User/Group &amp;Management')		icon: nil		nameKey: #userGroupManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.03&gt;	Store.DbRegistry 		doIfImageAdministrator: [Store.GroupGraph open]		label: (#manageUserGroups &lt;&lt; #store &gt;&gt; 'manage user/groups') asString</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="Store-Database Model" selector="glorpCopyIn:">glorpCopyIn: aDictionary	"For non-storeForGlorp objects, just copy normally"	^self copy.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Store-Database Model" selector="isImageObject">isImageObject	^true</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-Database Model" selector="compareToPundle:">compareToPundle: aPundleRecord	| info |	^( info := self databaseInformationFor: aPundleRecord dbIdentifier ) == nil		ifTrue: [#notLoaded]		ifFalse: 			[info dbTrace = aPundleRecord primaryKey				ifTrue:					[( self hasBeenModifiedIn: aPundleRecord dbIdentifier )						ifTrue: [#modified]						ifFalse: [#same]]				ifFalse: [#notSame]]</body><body package="Store-Database Model" selector="hasRelatedParcel">hasRelatedParcel	^false</body><body package="Store-Database Model" selector="isVersionLoaded">isVersionLoaded	^true</body><body package="Store-Database Model" selector="sameAsImage">sameAsImage	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="Store-Database Model" selector="hasRelatedParcel">hasRelatedParcel	^self storeForGlorpPundleClass hasRelatedParcelFor: self</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="StoreForGlorpBrowserUI" selector="notifyStoreBrowser">notifyStoreBrowser	"StoreRefactoringBrowser has an interest in #earlySystemInstallation.   When that event occurs,	 it will clear out any open browsers."	&lt;triggerAtSystemEvent: #earlySystemInstallation&gt;	Store.Glorp.StoreRefactoringBrowser cleanUpObsoleteInstances</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="StoreForGlorpVWUI" selector="storeClassChangesIn">storeClassChangesIn	&lt;itemInMenu: #(#classMenu #Store) position: 10.02&gt;	^(MenuItem labeled: #BrowseAllMethodChanges &lt;&lt; #store &gt;&gt; 'Browse All Method Changes')		value: #storeClassChanges;		enablement: #isClassSelected</body><body package="StoreForGlorpVWUI" selector="storeLoadPackageOrBundle">storeLoadPackageOrBundle	&lt;itemInMenu: #(#pundleMenu) 	position: 20.009&gt;	^(MenuItem labeled: #LoadPackageOrBundleDots &lt;&lt; #store &gt;&gt; 'Load Package or Bundle...')		value: [self dbRegistry doIfOnlineImage: [Store.Glorp.PublishedPundleVersionsTool openOnAllPublishedPundles]]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="StoreForGlorpVWUI" selector="openStoreForGlorpWorkbook">openStoreForGlorpWorkbook	&lt;menuItem: #(#StoreWorkbookDots #store 'Store Workbook...')		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 21.5&gt;	Glorp.UI.StoreWorkbook openRequestingDatabase.</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-Merge Management" selector="mergeBranchBlessingCommentHistoryPolicy">mergeBranchBlessingCommentHistoryPolicy	&lt;setting: #(#store #mergePolicy #includeBranchBlessingCommentHistoryPolicy)&gt;	^(BooleanSetting on: Store.Policies aspect: #includeBranchBlessingCommentHistory)		default: true;		label: #IncludeBranchBlessingCommentHistory &lt;&lt; #store &gt;&gt; 'Include branch blessing comment history';		helpText: #includeBranchBlessingCommentHistoryPolicy &lt;&lt; #store &gt;&gt; 'This setting determines if the branch blessing comments are included in the blessing comment of the final merged package.'</body><body package="Store-Merge Management" selector="mergeToolMaxInitialTreeSizePolicy">mergeToolMaxInitialTreeSizePolicy	&lt;setting: #(#store #mergePolicy #mergeToolMaxInitialTreeSizePolicy)&gt;	^(((IntegerSetting min: 1)) 		on: Store.Policies aspect: #mergeToolMaxInitialTreeSize)		label: #MergeToolMaxTreeLabel &lt;&lt; #store &gt;&gt; 'Merge Tool max initial tree size';		helpText: #mergeToolMaxInitialTreeSize &lt;&lt; #store &gt;&gt; 'This setting is used to determine the number of items to display in the merge tool modifications tree view when the modifications list size is changed.'</body><body package="Store-Merge Management" selector="mergeToolWarnsBeforeClosing">mergeToolWarnsBeforeClosing	&lt;setting: #(#store #mergePolicy #warnBeforeAbandoningUnpublished)&gt;	^(BooleanSetting on: Store.Glorp.MergeTool aspect: #warnBeforeAbandoningUnpublished)		default: true;		label: #warnBeforeAbandoningUnpublished &lt;&lt; #store &gt;&gt; 'Warn before abandoning unpublished merge results.';		helpText: #warnBeforeAbandoningUnpublishedHelp &lt;&lt; #store &gt;&gt; 'This setting determines if closing the merge tool prior to publishing brings up a warning about unpublished changes.'</body><body package="Store-Merge Management" selector="storeIntegratedBlessingChangePolicy">storeIntegratedBlessingChangePolicy	&lt;setting: #(#store #mergePolicy #integratedBlessingChangePolicy)&gt;	^((EnumerationSetting 			choices: #(#dontChange #change)			labels: (Array with: (#DontChangeBlessingLevel &lt;&lt; #store &gt;&gt; 'Don''t change the blessing level') with: (#ChangeBlessingLevel &lt;&lt; #store &gt;&gt; 'Change blessing level to "Integrated"' )))		on: Store.Policies aspect: #integratedBlessingChangePolicy)		label: #IntegratedBlessingChangePolicyLabel &lt;&lt; #store &gt;&gt; 'Integrated Blessing Change Policy';		helpText: #integratedBlessingChangePolicy &lt;&lt; #store &gt;&gt; 'This setting determines if the blessing level of an integrated version is changed to "Integrated" or left unchanged when the merge tool publishes merged packages.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-Merge Management" selector="storeMergePolicyPage">storeMergePolicyPage	&lt;settingsPage: #(store mergePolicy)&gt;	^ModularSettingsPage new		label: #MergePolicy &lt;&lt; #store &gt;&gt; 'Merge Policy';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store mergePolicy))</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-Merge Management" selector="openNewMergeTool">openNewMergeTool	&lt;menuItem: #(#Merge_Tool #store 'Merge &amp;Tool')		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store )		position: 20.17&gt;	Store.Glorp.MergeTool open.</body></methods><initialize><class-id>Store.AbstractTool</class-id></initialize><initialize><class-id>Store.VersionGraph</class-id></initialize><initialize><class-id>Store.DBAccess</class-id></initialize><initialize><class-id>Store.MiniRepositoryManager</class-id></initialize><initialize><class-id>Store.Pundle</class-id></initialize><initialize><class-id>Store.Bundle</class-id></initialize><initialize><class-id>Store.RecordVersionsViewer</class-id></initialize><initialize><class-id>Store.StoreSettings</class-id></initialize><initialize><class-id>Store.Package</class-id></initialize><initialize><class-id>Store.PublishPundleDialog</class-id></initialize><initialize><class-id>Store.GroupGraph</class-id></initialize><initialize><class-id>Store.PublishMergeDialog</class-id></initialize><initialize><class-id>Store.UnloadableDefinitionsViewer</class-id></initialize><initialize><class-id>Store.ElementView</class-id></initialize><initialize><class-id>Store.PrivilegeGraph</class-id></initialize><initialize><class-id>Store.BlessingDialog</class-id></initialize><initialize><class-id>Store.PublishPackageDialog</class-id></initialize><initialize><class-id>Store.SQLBroker</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>AbstractBinaryObjectStorage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream platformDescription initialPosition readerClass writerClass sourceMode readerMap writerMap nextIndex registry versionReaders classVarLists expectCycles mapXeroxToUnicode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GeneralMethodDefinition</name><environment>Tools</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>GenericSettingDescriptor</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id position definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>LDMElementView</name><environment>Lens</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents element hasIn hasOut povIcons firstPovIconX touchFlag selected label recycle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><class><name>LogEnvironment</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debugStream debugCategories debugClasses trace logFileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><class><name>VWDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driverSession preparedStatements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-VW3</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>BOSSAbstractWriter</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bodies currentClass nextRecentClass bodySize nilIndex traceClasses registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Override</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenMethod</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>AbstractBrowserEnvironment</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label searchStrings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-Environments</package></attributes></class><class><name>PundleEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleNames packageNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>ChangeSet</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectChanges objectRemoves componentChanges specialDoIts initializationOrder </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>NamedChangeSet</name><environment>Tools</environment><super>Kernel.ChangeSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeSetName lastChange lastFileOut lastFileOutName dirty comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>FileBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName list myPattern selectionState autoRead lastModified currentFileEncoding defaultEncodings patternAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>AssemblerCodeStream</name><environment>Kernel</environment><super>Kernel.ByteCodeStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodClass needsFrame hybrid forContext method innerBlocks allowNewLiterals copiedVars segments owner outerStream </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Assembler</package></attributes></class><class><name>HintedCodeStream</name><environment>Kernel</environment><super>Kernel.AssemblerCodeStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>finalNumTemps forNonImmediate forNonSubclassable allSourceMaps blockIndex nextBlockIndex makeFullBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>VisualLauncherToolDock</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tools </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>ClassNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>OverridenClass</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>SelectorEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classSelectors metaClassSelectors initializers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>ComponentDescription</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbIdentifier id componentName fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BundleDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ClassAndMethodTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors methods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>Model</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PseudoRecord</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-ImageModel</category><attributes><package>PackageCategories</package></attributes></class><class><name>ClassEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceBehaviorNames classBehaviorNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>PundleNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.HierarchyPundleNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>DatabaseConnectionInformation</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle dbIdentifier dbTrace dbTimestamp changeSet versionString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DatabaseConnectionBundleInformation</name><environment>Store</environment><super>Store.DatabaseConnectionInformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentDescriptions fileDescriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>AbstractChangeList</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value listName changes selectionIndex list filter removed filterList filterKey changeDict checkSystem fieldList selectionInList verticalConflicts differencesMode classesDistinct menuBar menus </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.MalformedSignal			</imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><class><name>PundleAccess</name><environment>Store</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages bundles modelDictionary currentPackage nullPackage containedItemsCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SourceFileFormat</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectProperties methodProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>XMLSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state docName cachedFile cachedParser </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Kernel-Support</category><attributes><package>XML-source</package></attributes></class><class><name>ClassDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullClassName meta cachedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>CodeComponentInspectPropertiesTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inspector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>StoreError</name><environment>Store</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>ConnectionDialog</name><environment>Database</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionProfileListHolder connectionProfileHolder databaseListHolder databaseHolder environmentListHolder environmentHolder userNameListHolder userNameHolder passwordHolder currentProfileHolder </inst-vars><class-inst-vars>lastUsedProfile </class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><class><name>AbstractRefactoringBrowser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator toolbarMenuHolder findHolder findList toolsetsList dispatcher </inst-vars><class-inst-vars>showToolbarHolder </class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>CodeWriter</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects classes extendedClasses extensionMethods exclusionset definedBindings scopeZones currentClass objectSpace analysisTracer symbolNum stringNum byteArrayNum floatNum doubleNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbObjectNum arbClassNum stream sourceStream sourceName hideOnLoad pointer currentKey properties prerequisites namedObjects newSourceKeys dateString timeString scratchDictionary codeComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ChunkSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>BindingReference</name><environment>Kernel</environment><super>Kernel.GeneralBindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseClass environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>GlorpError</name><environment>Glorp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><class><name>CannotFindSession</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMisc</package></attributes></class><class><name>DatabasePlatform</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types converters useBinding reservedWords functions characterEncoding </inst-vars><class-inst-vars>converterRepository </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>OverridenNameSpace</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>MethodDefinitionEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NameSpaceOfClass</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>BehaviorBuilderRecord</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instVarNames instVarMap newClass oldSuperclass superclass targetClass archive newSubclassList oldSubclassList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>XChangeSet</name><environment>Store</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>other properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>XMainChangeSet</name><environment>Store</environment><super>Store.XChangeSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>reorganizeSystem specialDoIts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>DatumDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey nameSpaceName className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>CodeComponentTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>True</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ClassExtensionDescriptor</name><environment>Store</environment><super>Store.ClassDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>AbsentClassImporterMetaclass</name><environment>Kernel</environment><super>Core.Metaclass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extraInstVars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>ProtocolEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass protocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>CodeReader</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream pointer format parcelName versionString dateString timeString numNamedObjects numClasses numExtensionMethods definedObjects definedBindings definedExternals classes classSelectors categories packageEnvironment packageUndeclared extensionMethods objectSpaceSize objectSpace symbolNum twoByteSymbolNum stringNum twoByteStringNum byteArrayNum floatNum doubleNum fixedNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbClassNum arbObjectNum messageSendIndices properties userStringsNum namedObjects namedObjectsNum postLoadObjects streamDir sourceFile hideSource importMaps overriddenExtensions versionSelectionBlock warningSuppressionBlock preReadBlock currentSuperclass mustRecompile lateOperations updates tempSourceFile compilationManager </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>MethodInstallationRecord</name><environment>Tools</environment><super>Tools.MethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ComponentChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType componentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>AbstractCodeModel</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator lockPolicy state isZoomed tabList statusPanel tools </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>Navigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment state dispatcher parts partsDictionary menus showOnlyFiltered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>AbstractBrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Navigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>LogicalFilename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>LensBrowsingToolModel</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>LDM-Framework</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>PostgreSQLPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>SQLite3Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Login</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>database username password connectString name schema secure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>LoggingTool</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><class><name>PropertyChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><class><name>SelectorProtocolNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>NameSpaceItemTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type showProtocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>Panel</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layoutAlgorithm isInUpdate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>RBInitializerDefinition</name><environment>Refactory.Browser</environment><super>Tools.InitializerDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-Environments</package></attributes></class><class><name>NameSpaceChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SharedVariableProtocolNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>Access</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingPolicy mergePolicy packagePolicy versionPolicy publishPolicy ownershipPolicy prerequisitePolicy filePolicy tableSpacePolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>PackageModelSubModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ComponentDefinitionChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionName definitionChange </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>PortableFilename</name><environment>OS</environment><super>OS.LogicalFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>SharedVariableNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>MultiSelectionSequenceView</name><environment>UI</environment><super>UI.SequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections lastSelectionIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Workbook</name><environment>Tools</environment><super>Tools.AbstractWorkspace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pageHolder lastInstalledPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><class><name>BrowserOverviewTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ClassBuilder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>records </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>CodeComponentInspectorField</name><environment>Refactory.Browser</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>MethodDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol fullClassName meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>Parcel</name><environment>Kernel</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects definedClasses definedBindings classSelectors namedObjects dirty loaded </inst-vars><class-inst-vars>parcels classParcelMap parcelFileInfoCache parcelFileDirectoryCache dependents </class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>List</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents collection limit collectionSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>SourceNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>LDMIndentedListBuilder</name><environment>Lens</environment><super>Lens.LDMAbstractVisualBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bottom referenceConnections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><class><name>BrowserDefinitionTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ConnectionProfile</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name driverClassName environment userName password originalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>BOSSAbstractReader</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingClasses compiledCode deferredSends </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>DB2Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>MetaclassBuilderRecord</name><environment>Kernel</environment><super>Kernel.BehaviorBuilderRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>VariableBinding</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value usage category environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>AccessPlatform</name><environment>Glorp</environment><super>Glorp.SQLServerPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>OraclePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Label</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text attributes width offset needsScan fontPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>ClassChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodChanges metaMethodChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>AbstractNavigatorState</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundles objectNameReferences type protocols definitions properties nameSpaceName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>NameSpaceDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>DefClassModel</name><environment>Store</environment><super>Store.PackageModelSubModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package fullClassSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SelectorNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><class><name>PartListAbstractInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driver segmentListHolder fieldListHolder textHolder dragController undoHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>ComponentSelectorChange</name><environment>Kernel</environment><super>Kernel.ComponentSubDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>DefNameSpaceModel</name><environment>Store</environment><super>Store.PackageModelSubModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package name environmentString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>CodeComponentPropertiesTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertiesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>ComponentStaticChange</name><environment>Kernel</environment><super>Kernel.ComponentSubDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>BrowserCommentTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>AlphaBlendedIcons</name><environment>Smalltalk</environment><super>Core.Assets</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Resources</package></attributes></class><class><name>ComponentLoadedChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class></st-source>