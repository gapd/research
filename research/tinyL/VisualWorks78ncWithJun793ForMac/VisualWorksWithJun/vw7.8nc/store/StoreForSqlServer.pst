<?xml version="1.0"?><st-source><!-- Name: StoreForSqlServerNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: Store adds team development and version control tools and facilities to the VisualWorks development environment.Load this parcel to use Store with a SQL Server repository -  all other Store parcels will be loaded automatically.Further information on Store can be found in the "Source Code Management Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 256657DevelopmentPrerequisites: #(#(#parcel 'Database' '') #(#parcel 'ODBCEXDI' '') #(#parcel 'StoreBase' ''))PackageName: StoreSqlServerParcel: #('StoreSqlServer')ParcelName: StoreForSqlServerPrerequisiteParcels: #(#('Database' '') #('ODBCEXDI' '') #('StoreBase' ''))PrintStringCache: (7.7 - 4,dwallen)Version: 7.7 - 4Date: 10:20:15 AM February 5, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.8 (feb10.1) of February 5, 2010 on February 5, 2010 at 10:20:15 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MS_SQLServerConnection</name><environment>Database</environment><super>Database.ODBCConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreSqlServer</category><attributes><package>StoreSqlServer</package></attributes></class><comment><class-id>Database.MS_SQLServerConnection</class-id><body>MS_SQLServerConnection is a specialized class that allows one to connect to MS SQL Server using Store.</body></comment><class><name>SQLServerBroker</name><environment>Store</environment><super>Store.SQLBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreSqlServer</category><attributes><package>StoreSqlServer</package></attributes></class><comment><class-id>Store.SQLServerBroker</class-id><body>Interface to SqlServer database.Class Variables:	Signals	&lt;ExceptionSet of signals&gt;  SqlServer signals.</body></comment><class><name>SQLAssistSQLServer</name><environment>Store</environment><super>Store.SQLAssist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreSqlServer</category><attributes><package>StoreSqlServer</package></attributes></class><comment><class-id>Store.SQLAssistSQLServer</class-id><body>Sql generator for SqlServer.</body></comment><class><name>NTAuthenticatedConnection</name><environment>Smalltalk</environment><super>Database.MS_SQLServerConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NT_Authenticate</category><attributes><package>StoreSqlServer</package></attributes></class><comment><class-id>NTAuthenticatedConnection</class-id><body>NTAuthenticatedConnection is a specialized class that allows one to connect to MS SQL Server with Store, but using NT Authentication to validate the user. This feature must be enabled at the server.</body></comment><class><name>NTAuthenticatedBroker</name><environment>Store</environment><super>Store.SQLServerBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreSqlServer</category><attributes><package>StoreSqlServer</package></attributes></class><comment><class-id>Store.NTAuthenticatedBroker</class-id><body>NTAuthenticatedBroker is the Store broker which uses an NTAuthenticatedConnection.</body></comment><shared-variable><name>Signals</name><environment>Store.SQLServerBroker</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>StoreSqlServer</package></attributes></shared-variable><methods><class-id>Database.MS_SQLServerConnection class</class-id> <category>accessing</category><body package="StoreSqlServer" selector="kind">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'MS_SQL Server'</body><body package="StoreSqlServer" selector="storeBroker">storeBroker	"Answer a broker class for Store"	^Store.SQLServerBroker</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>accessing</category><body package="StoreSqlServer" selector="currentTimestampSQLString">currentTimestampSQLString	^'SELECT GETUTCDATE()'</body><body package="StoreSqlServer" selector="databaseName">databaseName	^'MS_SQLServer'</body><body package="StoreSqlServer" selector="fullSeqTableName:">fullSeqTableName: aClass	^ (self fullTableName: aClass), 'Seq'</body><body package="StoreSqlServer" selector="fullTableName:">fullTableName: aClass	^ aClass databaseName, '.', (self tableNameWithPrefix: aClass)</body><body package="StoreSqlServer" selector="getBlobData:">getBlobData: aData	^ReadStream on: aData</body><body package="StoreSqlServer" selector="indexNameFor:">indexNameFor: aClass	^(self fullTableName: aClass), aClass indexName.</body><body package="StoreSqlServer" selector="needsSequenceFor:">needsSequenceFor: aClass	^ false</body><body package="StoreSqlServer" selector="sequenceGeneratorSession:forClass:">sequenceGeneratorSession: session forClass: aClass	| newSession |	session notNil ifTrue: [ session dismiss].	^self safelyExecuteBlock: [		newSession := self getNewSession.		newSession bindOutput: nil;				bindInput: nil;				prepare: ( self nextIDQuery: aClass );				blockFactor: 1.		newSession	]</body><body package="StoreSqlServer" selector="tableOwner">tableOwner	^ DbRegistry tablePrefix</body><body package="StoreSqlServer" selector="useDatabase:">useDatabase: dbName	[		self processSQL: ( 'USE  '  ,  dbName  ) asString.	]	on: Error	do: [ :exception | 			 Dialog warn: (self messageFor: exception). 			exception pass	]</body><body package="StoreSqlServer" selector="useDatabaseForClass:">useDatabaseForClass: aClass	self useDatabase: aClass databaseName</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>private</category><body package="StoreSqlServer" selector="executeSQL:">executeSQL: aString	self sessionExecute: [ :session |				session prepare: aString.				session execute.	].</body><body package="StoreSqlServer" selector="sessionExecute:">sessionExecute: aBlock	| session |	Cursor database showWhile:[		[	session := self connection getSession connect.			session blockFactor: 1.			aBlock value: session.			session disconnect.		]		on: self connectionClass  externalDatabaseErrorSignal		do: [ :exception | 			Dialog warn: (self messageFor: exception).			exception return		].	].</body><body package="StoreSqlServer" selector="typeToStringMap">typeToStringMap	^( Dictionary new)		 at: #String put: 'varchar (255) null';		 at: #PrimaryKey put: 'int not null';		 at: #PrimaryKeyInteger put: 'int not null';		 at: #PrimaryKeyString put: 'varchar (255) not null';		 at: #PrimaryKeyShortString put: 'varchar (50) not null';		 at: #PrimaryKeyChar put: 'char(1)';		 at: #Text put: 'text null';		 at: #Long put: 'int null';		 at: #BinData put: 'image';		 at: #Integer put: 'int null';		 at: #Char put: 'char(1)';		 at: #String32 put: 'varchar (32)' ;		yourself.</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>error handling</category><body package="StoreSqlServer" selector="alreadyExistErrors">alreadyExistErrors	^ Array with: self objectAlreadyExistisErrorNumber			with: self indexAlreadyInTableErrorNumber</body><body package="StoreSqlServer" selector="brokerSignals">brokerSignals	^Signals isNil 		ifTrue: [ Signals := self signalCollection]		ifFalse: [ Signals ]</body><body package="StoreSqlServer" selector="databaseAlreadyExistsErrorNumber">databaseAlreadyExistsErrorNumber	^ 1801</body><body package="StoreSqlServer" selector="databaseDoesntExistErrorNumber">databaseDoesntExistErrorNumber	^ 911</body><body package="StoreSqlServer" selector="doesNotExistErrors">doesNotExistErrors	^ Array with: self objectAlreadyGoneErrorNumber			with: self indexDoesntExistInSystemCatalogErrorNumber</body><body package="StoreSqlServer" selector="indexAlreadyInTableErrorNumber">indexAlreadyInTableErrorNumber	^ 1913</body><body package="StoreSqlServer" selector="indexDoesntExistInSystemCatalogErrorNumber">indexDoesntExistInSystemCatalogErrorNumber	^ 3703</body><body package="StoreSqlServer" selector="invalidObjectErrorNumber">invalidObjectErrorNumber	^ 208</body><body package="StoreSqlServer" selector="loginAlreadyExistsErrorNumber">loginAlreadyExistsErrorNumber	^ 15025</body><body package="StoreSqlServer" selector="objectAlreadyExistisErrorNumber">objectAlreadyExistisErrorNumber	^ 2714</body><body package="StoreSqlServer" selector="objectAlreadyGoneErrorNumber">objectAlreadyGoneErrorNumber	^ 3701</body><body package="StoreSqlServer" selector="signalCollection">signalCollection	^ ( ExceptionSet new: 4) 					add: self connectionClass unableToExecuteSQLSignal;		add: self connectionClass connectionNotOpenSignal;		add: self connectionClass externalDatabaseInformationSignal;		add: self connectionClass unableToPrepareSignal;		yourself</body><body package="StoreSqlServer" selector="userAlreadyExistsInDBErrorNumber">userAlreadyExistsInDBErrorNumber	^ 15023</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>drop objects</category><body package="StoreSqlServer" selector="dropDatabase:">dropDatabase: dbName	Transcript show: 'Dropping database ' , dbName; cr.	self process:  'USE master'.	[		self processSQL:  ('DROP database ' , dbName) asString.		Transcript show: 'Database dropped'; cr.	]	on: 	Error	do: [ :exception | | err |			(( err := exception parameter first ) notNil			and: [ err dbmsErrorCode == self databaseDoesntExistErrorNumber])				ifTrue: 					[  Dialog warn: (self messageFor: exception). 					exception pass].		Dialog warn: (self messageFor: exception).	]</body><body package="StoreSqlServer" selector="dropDatabaseFor:">dropDatabaseFor: aClass	self dropDatabase: aClass databaseName.</body><body package="StoreSqlServer" selector="dropIndexForClass:">dropIndexForClass: aClass	self dropIndexForClass: aClass 			index: aClass indexName.</body><body package="StoreSqlServer" selector="dropIndexForClass:index:">dropIndexForClass: aClass index: aName 	self useDatabaseForClass: aClass.	self 		performDrop: [self processSQL: 'DROP INDEX ' , (self tableNameWithPrefix: aClass) , '.' , aName] 		for: aClass name , aName</body><body package="StoreSqlServer" selector="dropLogin:">dropLogin: aName	Transcript show: 'Dropping login ' , aName; cr.	self process:  ' USE  master'.	[		self processSQL:  ('EXEC sp_droplogin ', aName )	]	on: 	Error	do: [ :exception | 		Dialog warn: (self messageFor: exception).		exception pass	]</body><body package="StoreSqlServer" selector="dropSequenceForClass:">dropSequenceForClass: aClass	self dropTable: (self fullSeqTableName: aClass)</body><body package="StoreSqlServer" selector="dropTableForClass:">dropTableForClass: aClass 	self dropTable: ( self fullTableName: aClass)</body><body package="StoreSqlServer" selector="dropUser:">dropUser: aName	Transcript show: 'Dropping user ' , aName; cr.	[		self processSQL:  ('EXEC sp_dropuser ', aName )	]	on: 	Error	do: [ :exception | 		Dialog warn: (self messageFor: exception).		exception pass	]</body><body package="StoreSqlServer" selector="dropViewForClass:">dropViewForClass: aClass	self useDatabaseForClass: aClass.	self dropView: ( self  tableNameWithPrefix: aClass).</body><body package="StoreSqlServer" selector="performDrop:for:">performDrop: aBlock for: aName 	[		aBlock value	]	on:  self connectionClass unableToExecuteSQLSignal	do: [ :exception | | err |		((err := exception parameter at: 1) dbmsErrorCode == self objectAlreadyGoneErrorNumber		or: [ err dbmsErrorCode == self indexDoesntExistInSystemCatalogErrorNumber])			ifTrue: 				[ Transcript show:  aName, ' already gone.'; cr.				exception return ]			ifFalse: 				[Dialog warn: (self messageFor: exception). 				exception pass]	].</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>create objects 6.5</category><body package="StoreSqlServer" selector="addUserToDB">addUserToDB	self addUserToDatabase: self fileNameForBlobs.	self addUserToDatabase: self fileNameForClasses.</body><body package="StoreSqlServer" selector="addUserToDatabase:">addUserToDatabase: aDatabase	self addUser: self tableOwner  toDatabase: aDatabase.	self processSQL:  'GRANT CREATE TABLE, CREATE VIEW, CREATE DEFAULT,  CREATE PROCEDURE TO ', self tableOwner.</body><body package="StoreSqlServer" selector="createDatabase:onDevice:">createDatabase: dbName onDevice: aDeviceName	"Creates a new database. You must be in the master database to create a new database."	"Device Is the logical name of the database device on which you want to put a database"	Transcript show: 'Create database ' , dbName, ' on device ', aDeviceName; cr.	self  processSQL: ( 'CREATE DATABASE '  ,  dbName, '  ON ', aDeviceName) asString.</body><body package="StoreSqlServer" selector="createDatabase:onDevice:logOn:">createDatabase: dbName onDevice: aDeviceName logOn: aLogDevice	"Creates a new database. You must be in the master database to create a new database."	"Device Is the logical name of the database device on which you want to put a database"	"Log device is the name of the device that stores the database log"	Transcript show: 'Create database ' , dbName, ' on device ', aDeviceName, ' log on ', aLogDevice; cr.	self  processSQL: ( 'CREATE DATABASE '  ,  dbName, '  ON ', aDeviceName, ' LOG ON ', aLogDevice) asString.</body><body package="StoreSqlServer" selector="createDatabase:onDevice:logOn:databaseSize:">createDatabase: dbName onDevice: aDeviceName logOn: aLogDevice databaseSize: size	"Creates a new database. You must be in the master database to create a new database."	"Device Is the logical name of the database device on which you want to put a database"	"Log device is the name of the device that stores the database log"	Transcript show: 'Create database ' , dbName, ' on device ', aDeviceName, ' log on ', aLogDevice; cr.	self  processSQL: ( 'CREATE DATABASE '  ,  dbName, '  ON ', aDeviceName, ' = ', (self spaceStringFor: size), '  LOG ON ', aLogDevice) asString.</body><body package="StoreSqlServer" selector="createDatabaseDevice65:path:devNumber:size:">createDatabaseDevice65: aName path: aPath devNumber: aNumber size: aSize	"Creates a device on which a database or multiple databases can be placed. A device is an operating-system file that SQL Server pre-allocates for database use.devNumber - Is the virtual device number. This number must be unique among the database devices associated with SQL Server. Values can be from 1 through 255; 0 is reserved for the MASTER database device. "	|  aStream |	Transcript show: 'Create database device ' , aName, ' path ', aPath; cr.	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'DISK INIT NAME = ' ,  aName, 						', PHYSNAME = ''',  aPath,						''',  VDEVNO = '.	aNumber printOn: aStream.	aStream nextPutAll: ',  SIZE = ', (self spaceStringFor: (self spaceIn2KFor: aSize)).	self process: 'USE MASTER' asString.	self process: aStream contents.</body><body package="StoreSqlServer" selector="createPhysicalSpaces65">createPhysicalSpaces65	"Create the  SQL Server device spaces used by Store."	| aDict path account |	aDict := Dictionary new.	(self getParamsForDBDevices: aDict) isNil ifTrue: [ ^ false].	path := aDict at: #path.		path isEmpty ifTrue: [ ^false ].	[	account := self isNewAccountCreated.	 	"creating a Blob log device for Blob database"		self  createDatabaseDevice: ( aDict at: #logBlobName)			path: (path asFilename constructString: ( aDict at: #logBlobName))			devNumber: (aDict at: #logBlobDev)			size:  self spaceForLogs.		self createDatabase: ( aDict at: #logBlobName)  onDevice: ( aDict at: #logBlobName).		 "creating a Class log device for Class database"		self  createDatabaseDevice: ( aDict at: #logClassName)			path: (path asFilename constructString: ( aDict at: #logClassName))			devNumber: (aDict at: #logClassDev)			size:  self spaceForLogs.		self createDatabase: ( aDict at: #logClassName)  onDevice: ( aDict at: #logClassName).			"creating database for BLOB"		self  createDatabaseDevice: ( aDict at: #blobName)			path:  (path asFilename constructString: ( aDict at: #blobName))			devNumber:  (aDict at: #blobDev)			size: self spaceForBlobs.		self createDatabase: ( aDict at: #blobName)			onDevice: ( aDict at: #blobName)			logOn: ( aDict at: #logBlobName) 			databaseSize: self spaceForBlobs.			"creating database for classes"		self  createDatabaseDevice: ( aDict at: #className) 			path: (path asFilename constructString: ( aDict at: #className))			devNumber: (aDict at: #classDev)			size: self spaceForClasses.		self createDatabase: ( aDict at: #className) 			onDevice: ( aDict at: #className) 			logOn: ( aDict at: #logClassName) 			databaseSize: self spaceForClasses.			account ifTrue: [ self addUserToDB].	] on: Error do: [ :exp | Dialog warn: exp description. ^false ].	^true.</body><body package="StoreSqlServer" selector="getParamsForDBDevices:">getParamsForDBDevices: aDict	| path blobDevName 	classDevName blobDevNumber classDevNumber spec  logBlobDevName logBlobDevNumber  logClassDevName logClassDevNumber |	path := nil asValue.	blobDevName  := (self fileNameForBlobs, '.dat') asValue.	classDevName  := (self fileNameForClasses, '.dat') asValue.	logBlobDevName  := (self fileNameForBlobs, 'Log.dat') asValue.	logClassDevName  := (self fileNameForClasses, 'Log.dat') asValue.	blobDevNumber := 20 asValue.	classDevNumber := 21 asValue.	logBlobDevNumber := 22 asValue.	logClassDevNumber := 23 asValue.	spec := self createDevicesSpec.	[ | dialog  res |	res := false.	dialog := SimpleDialog new.	dialog builder aspectAt: #path put: path.	dialog builder aspectAt: #blobDevName put: blobDevName.	dialog builder aspectAt: #classDevName put: classDevName.	dialog builder aspectAt: #logBlobDevName put: logBlobDevName.	dialog builder aspectAt: #logClassDevName put: logClassDevName.	dialog builder aspectAt: #blobDevNumber put: blobDevNumber.	dialog builder aspectAt: #classDevNumber put: classDevNumber.	dialog builder aspectAt: #logBlobDevNumber put: logBlobDevNumber.	dialog builder aspectAt: #logClassDevNumber put: logClassDevNumber.	dialog builder add: (UISpecification from: spec).	dialog preOpen. 	dialog builder openDialog.	dialog accept value		ifFalse: 			[^nil ].	path value isNil 		ifTrue:			[ Dialog			warn: 'You must specify path to create devices.'			for: dialog builder window.]		ifFalse: 			[res := true.			aDict	at: #blobName put: blobDevName value;				at: #className put: classDevName value;				at: #blobDev put: blobDevNumber value;				at: #classDev put: classDevNumber value;				at: #logBlobName put: logBlobDevName value;				at: #logClassName put: logClassDevName value;				at: #logBlobDev put: logBlobDevNumber value;				at: #logClassDev put: logClassDevNumber value;				at: #path put: path value.].	res	] whileFalse.	^aDict.</body><body package="StoreSqlServer" selector="spaceForBlobsN">spaceForBlobsN"MB"	^ 16</body><body package="StoreSqlServer" selector="spaceForClassesN">spaceForClassesN"MB"	^32</body><body package="StoreSqlServer" selector="spaceIn2KFor:">spaceIn2KFor: aNumber	"Specifies the size, in 2K blocks, of the database device. 	If you are planning to use the new database device to create a new database, the minimum size is 1 	MB." 	^ aNumber * 1024 / 2</body><body package="StoreSqlServer" selector="spaceStringFor:">spaceStringFor: aNumber	| aStream |		aStream := (String new: 5) writeStream.	aNumber printOn: aStream.	^ aStream contents.</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>private-accessing</category><body package="StoreSqlServer" selector="dismissSession:">dismissSession: aSession	^ aSession dismiss</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>grant statements</category><body package="StoreSqlServer" selector="availableGrantedPermissions">availableGrantedPermissions	"Lists permissions granted. When permissions are granted on a table or a view, the permission list can include one or more of the following items: "	^ 'SELECT,  INSERT,  DELETE,  UPDATE' asString</body><body package="StoreSqlServer" selector="availableGrantedStatements">availableGrantedStatements		"Lists statements granted. The statement list can include the following statements"	^ #('CREATE DATABASE'  'CREATE DEFAULT' 'CREATE PROCEDURE' 'CREATE RULE' 'CREATE TABLE' 'CREATE VIEW' 'DUMP DATABASE'  'DUMP TRANSACTION')</body><body package="StoreSqlServer" selector="grant:on:columnList:to:">grant: aPermissionList on: aTableName columnList: aColumnList  to: aUserNameList	"Assigns permissions to users."	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	aStream nextPutAll:  (' ON ' , aTableName,  ' ( ' ).	aColumnList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	aStream nextPutAll:  ( ' ) ', ' TO ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.		self processGrantStatement: aStream contents.</body><body package="StoreSqlServer" selector="grantDBAccess:">grantDBAccess: aDatabase		self grantDBAccess: aDatabase to: self tableOwner.	self processGrantStatement:  'GRANT CREATE TABLE, CREATE VIEW, CREATE DEFAULT,  CREATE PROCEDURE TO ', self tableOwner.</body><body package="StoreSqlServer" selector="grantDBAccess:to:">grantDBAccess: aDatabase to: anAccount	"Adds a security account in the current database "	Transcript show: 'Granting DB access ' , anAccount, ' to DB ', aDatabase; cr.	self useDatabase: aDatabase.	self processGrantStatement: ( 'EXEC sp_grantdbaccess '  ,  anAccount, ', ',  anAccount ) asString.</body><body package="StoreSqlServer" selector="grantForClass:permissions:columns:toUsers:">grantForClass: aClass permissions: aPermissionList columns: aColumnList toUsers: aUserNameList 		self useDatabaseForClass: aClass.	super		grantForClass: aClass		permissions: aPermissionList		columns: aColumnList		toUsers: aUserNameList</body><body package="StoreSqlServer" selector="grantForClass:permissions:toUsers:">grantForClass: aClass permissions: aPermissionList toUsers: aUserNameList	self useDatabaseForClass: aClass.	super grantForClass: aClass permissions: aPermissionList toUsers: aUserNameList.</body><body package="StoreSqlServer" selector="grantForSeqClass:permissions:toUsers:">grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList	self useDatabaseForClass: aClass.	super grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList</body><body package="StoreSqlServer" selector="grantSequencePermissionsOn:">grantSequencePermissionsOn: aClass 	"Do nothing"</body><body package="StoreSqlServer" selector="processGrantStatement:">processGrantStatement: aString	[		self processSQL:  aString	]	on: Error	do: [ :exception | 		(exception parameter first dbmsErrorCode == self userAlreadyExistsInDBErrorNumber) 			ifTrue: 				[ Transcript show:  exception parameter first dbmsErrorString; cr.				exception return ]			ifFalse: 				[ Dialog warn: (self messageFor: exception). 				DbRegistry goOffLine.				exception pass ]		]</body><body package="StoreSqlServer" selector="revokeDBAccess:account:">revokeDBAccess: aDatabase account: anAccount	"Revokes a security account from the current database "	Transcript show: 'Revoke DB access ' , anAccount, ' from DB ', aDatabase; cr.	self useDatabase: aDatabase.	self process: ( 'EXEC sp_revokedbaccess  '  ,  anAccount, ', ',  anAccount ) asString.</body><body package="StoreSqlServer" selector="revokeForClass:permissions:fromUsers:">revokeForClass: aClass permissions: aPermissionList fromUsers: aUserNameList	self useDatabaseForClass: aClass.	super revokeForClass: aClass permissions: aPermissionList fromUsers: aUserNameList</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>performance tuning</category><body package="StoreSqlServer" selector="createNonClusteredIndex:onTable:columns:">createNonClusteredIndex: anIndex onTable: aTableName columns: aColumnsString"Creates an index on a given table that either changes the physical ordering of the table or provides the optimizer with a logical ordering of the table to increase efficiency for queries. When creating an index for the primary key, use the table- and column-level PRIMARY KEY constraint provided with the CREATE TABLE statement. "	self process: ('CREATE NONCLUSTERED INDEX ' , anIndex, ' ON ' , aTableName, '( ', aColumnsString, ' )') asString.</body><body package="StoreSqlServer" selector="dropIndex:onTable:">dropIndex: anIndex onTable: aTableName	"Removes an index from a database."	self process: ('DROP INDEX ' , aTableName, '.', anIndex) asString.</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>queries</category><body package="StoreSqlServer" selector="newSQLFor:">newSQLFor: aClass	^ self sqlAssistClass newSQLFor: aClass table: (self fullTableName: aClass)</body><body package="StoreSqlServer" selector="nextIDQuery:">nextIDQuery: aClass	"Return the auto-sequenced IDENTITY column value most recently inserted.	SQLServer assigned unique IDENTITY when row was inserted. This method retrieves it."	^  'SELECT @@IDENTITY'</body><body package="StoreSqlServer" selector="sqlAssistClass">sqlAssistClass	^SQLAssistSQLServer</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>create objects</category><body package="StoreSqlServer" selector="addIdentityFor:">addIdentityFor: aColumn	" For #PrimaryKey columns we add identity property. 	Identity columns are commonly used in conjunction with PRIMARY KEY constraints to serve as the unique row identifier for the table. "	^ (aColumn equivalentTo: 'primarykey' ignoreCase:  true)		ifTrue: [ ' IDENTITY (1,1) ']		ifFalse: [ String new]</body><body package="StoreSqlServer" selector="addLogin:">addLogin: aName		self addLogin: aName password: aName</body><body package="StoreSqlServer" selector="addLogin:password:">addLogin: aName password: aPass	"Create SQL Server login account"	Transcript show: 'Add login for ' , aName; cr.	self process:  'USE  master'.	[		self processSQL: ( 'EXEC sp_addlogin '  ,  aName, ', ', aPass  ) asString.	] 	on: Error	do: [ :exception | | err |		((err := exception parameter first) dbmsErrorCode == self loginAlreadyExistsErrorNumber)			ifTrue: 				[ Transcript show:  err dbmsErrorString; cr.				exception return ]			ifFalse: 				[Dialog warn: (self messageFor: exception). 				exception pass]	].</body><body package="StoreSqlServer" selector="addRoleToDB:">addRoleToDB: aDatabase	"Add the roles to the database"	Transcript show: 'Add the role to the db ' , aDatabase; cr.	self useDatabase: aDatabase.	self process: ( 'EXEC sp_addrole '  ,  self tableOwner  ) asString.</body><body package="StoreSqlServer" selector="addRoleToDB:role:">addRoleToDB: aDatabase role: aName	"Add the roles to the database"	Transcript show: 'Add the role to the db ' , aDatabase; cr.	self useDatabase: aDatabase.	self process: ( 'EXEC sp_addrole '  ,  aName  ) asString.</body><body package="StoreSqlServer" selector="addUser:toDatabase:">addUser: anUser toDatabase: aDatabase	"Add a username with the same login ID"	Transcript show: 'Add user ' , anUser, 'To database ', aDatabase; cr.	self useDatabase: aDatabase.	self process: ( 'EXEC sp_adduser '  ,  anUser ) asString.</body><body package="StoreSqlServer" selector="addUser:toGroup:">addUser: anUser toGroup: grName	"Add the login accounts as database user accounts"	Transcript show: 'Add user ' , anUser, ' to group ', grName; cr.	self process: ( 'EXEC sp_adduser '  ,  anUser, ', ', anUser, ', ', grName  ) asString.</body><body package="StoreSqlServer" selector="addUser:toGroup:toDatabase:">addUser: anUser toGroup: grName toDatabase: dbName	"Add the login accounts as database user accounts"	Transcript show: 'Add user ' , anUser, ' to group ', grName, ' to database ' , dbName; cr.	self process: ('USE ',  dbName) asString.	self process: ( 'EXEC sp_adduser '  ,  anUser, ', ', anUser, ', ', grName  ) asString.</body><body package="StoreSqlServer" selector="addUserGroup:toDatabase:">addUserGroup: grName toDatabase: dbName	"Add  user groups"	Transcript show: 'Add user group ' , grName, ' to database ', dbName; cr.	self process: ('USE ',  dbName) asString.	self process: ( 'EXEC sp_adduser '  ,  grName) asString.</body><body package="StoreSqlServer" selector="chooseSQLServerVersion">chooseSQLServerVersion	^ Dialog 		choose: 'What SQL Server version do you want?' 		fromList: #('SQLServer 6.5' 'SQLServer 7') 		values: #(65 7) 		lines: 8 		cancel: [#noChoice]</body><body package="StoreSqlServer" selector="createDatabase:onDevice:size:">createDatabase: dbName onDevice: aDeviceName size: size 	"Creates a new database. You must be in the master database to create a new database.	Device Is the logical name of the database device on which you want to put a database."	| createStatement |	Transcript show: 'Creating database ' , dbName; cr.	createStatement := self sqlForColationOn: aDeviceName size: size name: dbName.	[self processSQL: createStatement] 		on: Error		do: 			[:exception | 			| errors messageStream |			messageStream := (String new: 100) writeStream.			((errors := exception parameter) notNil and: [errors isEmpty not]) 				ifTrue: 					[errors first dbmsErrorCode == self databaseAlreadyExistsErrorNumber ifTrue: 						[Transcript show: errors first dbmsErrorString; cr.						exception return].					errors do: [:each | messageStream nextPutAll: each dbmsErrorString; cr]]				ifFalse: [messageStream nextPutAll: exception errorString; cr].			Dialog warn: messageStream contents.			exception pass]</body><body package="StoreSqlServer" selector="createDatabaseSequence:">createDatabaseSequence: aClass " Do nothing "</body><body package="StoreSqlServer" selector="createDatabaseTable:">createDatabaseTable: aClass	"Creates a new table."	"database.[owner].]table_name - table name Is the name of the new table. Table names must conform to the rules for identifiers and must be unique within the database and for its owner."	| aKeyCollection aStream |	aKeyCollection := OrderedCollection new.	aStream := (String new: 100) writeStream.	aStream nextPutAll: (self createDatabaseTableColumnsFor: aClass keyNames: aKeyCollection).	aStream nextPutAll: (self createTablePrimaryKeySectionFor: aClass keys: aKeyCollection).	self createTable: (self fullTableName: aClass) columns: ' (', aStream contents, ') '.</body><body package="StoreSqlServer" selector="createLogin">createLogin	self addLogin: self tableOwner</body><body package="StoreSqlServer" selector="createMethodRetrievalIndex:">createMethodRetrievalIndex: aClass"Creates an index on a given table that either changes the physical ordering of the table or provides the optimizer with a logical ordering of the table to increase efficiency for queries."	self createIndex: aClass indexName 			onTable: (self fullTableName: aClass) 			columns: aClass indexColumnNames</body><body package="StoreSqlServer" selector="createNewAccount">createNewAccount	"Create the  SQL Server security account."	| str res |	(self tableOwner equivalentTo: 'dbo' ignoreCase:  true) ifTrue: [ ^ false].	str := (String new: 50) writeStream. 	str nextPutAll: 'Press Yes to create a new account: ', self tableOwner, ' password: ', self tableOwner;cr.	str nextPutAll: 'Press No to use the dbo account';cr.	str nextPutAll:'Press Cancel  to cancel the installation'.		res := Dialog		choose: str contents		labels: (Array with: 'Yes' with: 'No'  with: 'Cancel')		values: #(#yes #no #cancel)		default: #maybe.	res == #yes ifTrue: [	self createLogin. ^ true].	res == #no ifTrue: [ DbRegistry updateTablePrefix: 'dbo'. ^ false].	res == #cancel ifTrue: [ Error raiseSignal: 'Installation was canceled'].</body><body package="StoreSqlServer" selector="createNewAccountDialog">createNewAccountDialog	"Create the  SQL Server security account."	|dialog  account password spec |	(self tableOwner equivalentTo: 'dbo' ignoreCase:  true) ifTrue: [ ^ false].	account := self tableOwner asValue.	password := self tableOwner asValue.	spec := self createNewAccountSpec.		dialog := SimpleDialog new.	dialog builder aspectAt: #account put: account.	dialog builder aspectAt: #password put: password.	dialog builder add: (UISpecification from: spec).	dialog preOpen. 	dialog builder openDialog.	dialog value inspect."	^ account value isNil 		ifTrue:			[ ]		ifFalse: 			[	at: #account put: account value;				at: #password  put: password value;			].""		res := Dialog		choose: str contents		labels: (Array with: 'Yes' with: 'No'  with: 'Cancel')		values: #(#yes #no #cancel)		default: #maybe.	res == #yes ifTrue: [	self createLogin. ^ true].	res == #no ifTrue: [ DbRegistry updateTablePrefix: 'dbo'. ^ false].	res == #cancel ifTrue: [ Error raiseSignal: 'Installation was canceled']."</body><body package="StoreSqlServer" selector="createPhysicalSpaces">createPhysicalSpaces	"Create the  SQL Server device spaces used by Store."	^self createPhysicalSpaces7"	res := self chooseSQLServerVersion.	res == 7		ifTrue: 			[ ^self createPhysicalSpaces7].	res == 65		ifTrue: 			[ ^self createPhysicalSpaces65].	^ false."</body><body package="StoreSqlServer" selector="createPhysicalSpaces7">createPhysicalSpaces7	"Create the  SQL Server device spaces used by Store."	| path blobName className account |	path := Dialog request: 'Please, enter directory for the data files.' initialAnswer: ''.	path isEmpty ifTrue: [ ^false ].	blobName := path asFilename constructString: self fileNameForBlobs, '.mdf'.	className := path asFilename constructString: self fileNameForClasses, '.mdf'.	^ [ 	account := self isNewAccountCreated.		"creating database for BLOB"		self createDatabase:  self fileNameForBlobs onDevice: blobName 	size: self spaceForBlobs.		"creating database for classes"		self createDatabase: self fileNameForClasses onDevice: className size: self spaceForClasses.		account ifTrue: [ self grantDBAccess ].		true	] on: Error do: [ :exp |  false ].</body><body package="StoreSqlServer" selector="createSourcesViewForClass:">createSourcesViewForClass: aClass"Creates a virtual table that represents an alternative way of looking at the data in one or more tables. You can use views as security mechanisms by granting permission on a view but not on underlying tables."	self useDatabaseForClass: aClass.	self createView: ( self tableNameWithPrefix: aClass )		selectStatement: ( self createViewSelectWithSourcesSQLForClass: aClass ). 	self grantForClass: aClass  permissions: #('SELECT')  toUsers: #('PUBLIC').</body><body package="StoreSqlServer" selector="createTablePrimaryKeySectionFor:keys:">createTablePrimaryKeySectionFor: aClass keys: aKeyCollection	| aStream pkStream |	aStream := (String new: 100 ) writeStream.	aKeyCollection isEmpty 		ifFalse: 			[aStream nextPutAll: 'PRIMARY KEY CLUSTERED('.			pkStream := (String new: 100) writeStream.			aKeyCollection do: [:each | pkStream nextPutAll: each , ', '].			pkStream skip: -2.			aStream nextPutAll: pkStream contents , ')'; cr.		].	^ aStream contents.</body><body package="StoreSqlServer" selector="createViewForClass:">createViewForClass: aClass"Creates a virtual table that represents an alternative way of looking at the data in one or more tables. You can use views as security mechanisms by granting permission on a view but not on underlying tables."	self useDatabaseForClass: aClass.	self createView: ( self tableNameWithPrefix: aClass )		selectStatement: (self createViewSelectSQLForClass: aClass).</body><body package="StoreSqlServer" selector="createViewSelectWithSourcesSQLForClass:">createViewSelectWithSourcesSQLForClass: aClass	"Create the sql for a view that retrieves method comments in a join"	"Modified so that it could keep better track of which columns were associated with which table, 	permitting the possibility of a view which joined the same table twice, and to allow the view class 	to specify which table the definition key was in"	| aStream linkClasses mainClass definitionClasses refColumnNames allColumnNames items allColumns |	aStream := (String new: 100) writeStream.	linkClasses := aClass subCollectionClasses.	mainClass := aClass referencedClass.	definitionClasses := aClass definitionClasses.	refColumnNames := self allColumnsFor: mainClass.	allColumnNames := self allColumnsFor: aClass.	items := OrderedCollection new.	refColumnNames do: [:each | items add: each -&gt; ((self tableNameWithPrefix: mainClass), '.', each)].	1 to: linkClasses size do: 		[ :i |  | eachLink eachDef defColumnNamesForViewList defColumnNamesForMatching linkColumnNames |		eachLink := linkClasses at: i.		eachDef := definitionClasses at: i.			defColumnNamesForViewList := (aClass aliasedDefReferenceColumnNamesCollection at: i) asOrderedCollection.		defColumnNamesForMatching := (aClass defReferenceColumnNamesCollection at: i) asOrderedCollection.		refColumnNames := refColumnNames select: [:each | allColumnNames includes: each].		defColumnNamesForMatching size to: 1 by: -1 do: 			[ :j |			(allColumnNames includes: (defColumnNamesForMatching at: j))				ifFalse: 					[ defColumnNamesForMatching removeIndex: j.					defColumnNamesForViewList removeIndex: j					]			].		linkColumnNames := (self allColumnsFor: eachLink) select: [:each | allColumnNames includes: each].		linkColumnNames do: [:each | items add: each -&gt; ((self tableNameWithPrefix: eachLink), '.', each)].		defColumnNamesForMatching with: defColumnNamesForViewList do: [:instVarName :columnName | 			items add: instVarName -&gt; ((self fullTableName: eachDef), '.', columnName)]].	allColumns := self allColumnsFor: aClass.	allColumns do: 		[ :each |  | match |			match := items detect: [:eachAssociation | eachAssociation key = each] ifNone: [nil].			match isNil 				ifFalse: 					[						aStream nextPutAll: match value.					each == allColumns last 						ifFalse: [ aStream nextPutAll: ', ' ]					] 		].	self printTableListAndWhereClauseForViewWithSourcesFrom: mainClass 			to: definitionClasses 			via: linkClasses 			for: aClass on: aStream. 	^ aStream contents</body><body package="StoreSqlServer" selector="defWhereClauseFor:withDefClass:">defWhereClauseFor: aClass withDefClass: defClass	| position defRefClass column defIsOptional |	position := aClass definitionClasses indexOf: defClass.	defRefClass := aClass definitionReferenceClasses at: position.	column := aClass definitionReferenceColumns at: position.	defIsOptional := aClass definitionsAreOptional at: position.	^'(', (self tableNameWithPrefix: defRefClass) , '.'		, (self columnName: column for: defClass), 		 ' = ', 		 (self fullTableName: defClass) , '.'		, (self columnName: 'primaryKey' for: defClass), 		((defIsOptional not or: [self ansiOuterJoins]) ifTrue: [')'] ifFalse: [' (+))']).</body><body package="StoreSqlServer" selector="grantDBAccess">grantDBAccess	self grantDBAccess: self fileNameForBlobs.	self grantDBAccess: self fileNameForClasses.</body><body package="StoreSqlServer" selector="installPhysicalSpaces">installPhysicalSpaces	"Create the  SQL Server device spaces used by Store."	| path blobName className account baseFilename | 	DbRegistry goToScript		ifFalse: [ (Dialog confirm: 'Create data files?')  ifFalse: [ ^true ]].	path := Dialog request: 'Please, enter directory for the databases.' initialAnswer: ''.	path isEmpty ifTrue: [ ^nil ]. 	baseFilename := (path includes: Filename getSeparator)		ifTrue: [path asFilename]		ifFalse: [(path includes: UnixFilename getSeparator)			ifTrue: [UnixFilename named: path]			ifFalse: [PCFilename named: path]].	blobName := baseFilename constructString: self fileNameForBlobs, '.mdf'.	className := baseFilename constructString: self fileNameForClasses, '.mdf'.	Transcript show: ' '; cr. 	Transcript show: 'Starting installation...';cr. 	^ [ 	account := self isNewAccountCreated.		"creating database for BLOB"		self createDatabase:  self fileNameForBlobs onDevice: blobName 	size: self spaceForBlobs.		"creating database for classes"		self createDatabase: self fileNameForClasses onDevice: className size: self spaceForClasses.		account ifTrue: [ self grantDBAccess ].		true	] on: Error do: [ :exp |  nil ].</body><body package="StoreSqlServer" selector="isLoginExist:">isLoginExist: aName 	self process:  ' USE  master'.	^ [		self processSQL: ( 'EXEC sp_addlogin '  ,  aName, ', ', aName  ) asString.		self processSQL:  ('EXEC sp_droplogin ', aName ).		false	] 	on: Error	do: [ :exception | | err | 		((err := exception parameter first) dbmsErrorCode == self loginAlreadyExistsErrorNumber)			ifTrue: 				[ Transcript show:  err dbmsErrorString; cr.				exception return: true]			ifFalse:				[exception return: false]	].</body><body package="StoreSqlServer" selector="isNewAccountCreated">isNewAccountCreated	(self tableOwner equivalentTo: 'dbo' ignoreCase:  true) ifTrue: [ ^ false]. 	^ DbRegistry goToScript 		ifFalse: 			[(self isLoginExist: self tableOwner)				ifTrue: [  true]				ifFalse: [ self createNewAccount ]]		ifTrue: [self createLogin. true ]</body><body package="StoreSqlServer" selector="printTableListAndWhereClauseForViewWithSourcesFrom:to:via:for:on:">printTableListAndWhereClauseForViewWithSourcesFrom: mainClass to: definitionClasses via: linkClasses for: aClass on: aStream 	aStream nextPutAll: '	FROM '.	aStream nextPutAll: (self tableNameWithPrefix: mainClass).	self ansiOuterJoins 		ifTrue: 			[ linkClasses with: definitionClasses do: 				[ :eachLink :eachDefinition |  | defIsOptional |				defIsOptional := aClass definitionsAreOptional 							at: (linkClasses indexOf: eachLink).				defIsOptional 					ifTrue: [aStream nextPutAll: ' LEFT OUTER JOIN ']					ifFalse: [aStream nextPutAll: ' JOIN '].				aStream nextPutAll: (self tableNameWithPrefix: eachLink).				aStream nextPutAll: ' ON ('.				aStream nextPutAll: (self 							collWhereClauseFor: aClass							from: mainClass							collClass: eachLink).				aStream nextPutAll: ') '.				defIsOptional 					ifTrue: [aStream nextPutAll: ' LEFT OUTER JOIN ']					ifFalse: [aStream nextPutAll: ' JOIN '].				aStream nextPutAll: (self fullTableName: eachDefinition).				aStream nextPutAll: ' ON ('.				aStream 					nextPutAll: (self defWhereClauseFor: aClass withDefClass: eachDefinition).				aStream nextPutAll: ') ']			]		ifFalse: 			[ aStream nextPutAll: ', '.			linkClasses , definitionClasses do: 				[:each | 				aStream nextPutAll: (self tableNameWithPrefix: each).				each == definitionClasses last ifFalse: [aStream nextPutAll: ', ']].			aStream nextPutAll: '			WHERE '.				linkClasses with: definitionClasses do: 					[ :eachLink :eachDefinition | 					eachLink == linkClasses first ifFalse: [aStream nextPutAll: ' AND '].					aStream nextPutAll: (self 						collWhereClauseFor: aClass						from: mainClass						collClass: eachLink).					aStream nextPutAll: ' AND ' 						, (self defWhereClauseFor: aClass withDefClass: eachDefinition)				]			]</body><body package="StoreSqlServer" selector="spaceForLogs">spaceForLogs	^ 8</body><body package="StoreSqlServer" selector="sqlForColationOn:size:name:">sqlForColationOn: aDeviceName size: size name: dbName 	^'CREATE DATABASE ' , dbName , ' ON  ( NAME = ' , dbName , '_dat, ' , ' FILENAME = ''' , aDeviceName , ''', ' , ' SIZE = ' , size , ') COLLATE Latin1_General_CS_AS'</body><body package="StoreSqlServer" selector="sqlForNoColationOn:size:name:">sqlForNoColationOn: aDeviceName size: size name: dbName 	^'CREATE DATABASE ' , dbName , ' ON  ( NAME = ' , dbName , '_dat, ' , ' FILENAME = ''' , aDeviceName , ''', ' , ' SIZE = ' , size , ')'</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>connection class</category><body package="StoreSqlServer" selector="connectionClass">connectionClass	^Store.MS_SQLServerConnection</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>sql processing</category><body package="StoreSqlServer" selector="nextIDForClass:">nextIDForClass: aClass 	"Answer the next number in the sequence established for artifact.	Coerce to Integer (current ODBC mapping yields fixed point)."	^(super nextIDForClass: aClass) asInteger</body></methods><methods><class-id>Store.SQLAssistSQLServer</class-id> <category>private</category><body package="StoreSqlServer" selector="removePrimaryKeyColumn:">removePrimaryKeyColumn: anArray" In SQL Server #PrimaryKey column is identity type. It will be inserted automaticaly"	^ anArray select: [ :col | 		(col equivalentTo: 'primarykey' ignoreCase:  true) not ]</body><body package="StoreSqlServer" selector="removePrimaryKeyValue:">removePrimaryKeyValue: anArray" In SQL Server #PrimaryKey column is identity type. It will be inserted automaticaly"	^ anArray select: [ :col | 		(col equivalentTo: ':primarykey' ignoreCase:  true) not ]</body></methods><methods><class-id>NTAuthenticatedConnection</class-id> <category>private-execution</category><body package="StoreSqlServer" selector="acquireExternal:">acquireExternal: aPassword 	"Assume that the current user is recognized by	the server using NT authorization.Verify that stated	user name is correct, and replace the username	and password logon strings with blanks so that	NT authorization can take place."	| xif rc name pw env  szDSN szUID szAuthStr env1 nm1 pw1 |	xif := self class xif.	self username = self authenticatedUserName		ifFalse: [self class authenticationFailureSignal raise].	name := ''.	[ name isString ] whileFalse:		[ name := self class requiredUsernameSignal raiseRequest ].	pw := ''. "aPassword."	[ pw isString ] whileFalse:		[ pw := self class requiredPasswordSignal raiseRequest  ].	(env := self environment) isNil ifTrue:		[ env := self class defaultEnvironment ].	[ env isString ] whileFalse:		[ env := self class requiredEnvironmentSignal raiseRequest  ].	env := self class mapLogical: env.	"Get required handles."	HenvLock critical: [ self unprotectedAllocConnect ].	[ "Begin unwind protection (level 1) -- ensure release of connection handle on failure."	[ "Begin unwind protection (level 2) -- ensure release of pointers on success or failure."	szDSN := (env1 := env asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	szUID := (nm1 := name asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	szAuthStr := (pw1 := pw asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	rc := xif SQLConnect: self hdbc			with: szDSN			with: env1 size			with: szUID			with: nm1 size			with: szAuthStr			with: pw1 size.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rc; 			nextPutAll: ' = SQLConnect( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix:16);			nextPutAll: ', szDSN = '; nextPutAll: env; 			nextPutAll: ', szUID = '; nextPutAll: name; 			nextPutAll: ', szAuthStr = ******* )'.		self class trace: self emitTrace].	"End unwind protection (level 2)" ]		valueNowOrOnUnwindDo: 			[ szAuthStr notNil ifTrue: [ szAuthStr freePointer ].			szUID notNil ifTrue: [ szUID freePointer ]. 			szDSN notNil ifTrue: [ szDSN freePointer ] ].	(rc == xif SQL_SUCCESS 	or: [rc == xif  SQL_SUCCESS_WITH_INFO]) ifFalse:		[| errs |		errs := self getConnectionErrors.		^self class unableToConnectToSQLserverSignal raiseWith: errs].	"End unwind protection (level 1)" ]		valueOnUnwindDo:			[ "Some failure is causing unwind, don't keep the handles."			HenvLock critical: [ self unprotectedFreeConnect ] ].	"Enter autocommit mode on the transaction."	self singleStatementTransactions.	"Set the correct isolation level for this connect"	"self setIsolationLevel: (SupportedIsolationLevels at: isolationLevel)."</body></methods><methods><class-id>NTAuthenticatedConnection</class-id> <category>private-authentication</category><body package="StoreSqlServer" selector="authenticatedUserName">authenticatedUserName	^OSSystemSupport new getVariable: 'USERNAME'</body></methods><methods><class-id>NTAuthenticatedConnection class</class-id> <category>accessing</category><body package="StoreSqlServer" selector="kind">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'MS_SQL_NT Authenticated'</body></methods><methods><class-id>Store.NTAuthenticatedBroker class</class-id> <category>connection class</category><body package="StoreSqlServer" selector="connectionClass">connectionClass	^Store.NTAuthenticatedConnection</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>binding</category><body package="StoreSqlServer" selector="bindForInputOld">bindForInputOld	"Prepare the receiver to put data for an unbound parameter."	fParamType := bufferSession class xif SQL_PARAM_INPUT.	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse:[ self free].	"Allocate CPointers to hold data and the size of the data "	self mallocUsingSelector: bufferSession class xif mallocSelector.	"For unbound buffers the data it represents is sent only when the server requests it. 	To facilitate this process we only bind the receiver's index so that the server can later	specify which instance of the receiver that it wants data for."	self at: 1 putInteger: bufferIndex.	pcbValue contents: bufferSession class xif SQL_DATA_AT_EXEC.		^super bindInputExternal</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>private-binding</category><body package="StoreSqlServer" selector="bindInputExternalOld">bindInputExternalOld	 "Bind the contents of the receiver to the server."	| rc xif  valueStream |	xif := bufferSession class xif. 	valueStream := ReadStream on: bufferValue. 	[valueStream atEnd ]		whileFalse: 			[ "Ensure that proper conversion takes place." 			self at: 1 put: (valueStream nextAvailable:  (bufferSession getDataChunkSize min: cbColDef)).			rc := xif SQLPutData: bufferSession hstmt					 		with: bufferPointer					 		with: cbColDef.   "pcbValue contents."			(bufferSession traceLevel &gt;= 3 ) 				ifTrue:					[ (bufferSession  traceStream)					 	print: rc;  nextPutAll: ' = SQLPutData( hstmt = ';				 		nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);					 	nextPutAll: ', rgbValue = ';					 	nextPutAll: (bufferPointer  referentAddress printStringRadix: 16);					 	nextPutAll: ', cbValue = '; print: pcbValue contents;					 	nextPutAll: ' )'.						bufferSession class trace: bufferSession emitTrace 					].					 (rc == xif SQL_ERROR or: [ rc == xif SQL_SUCCESS_WITH_INFO ]) 						ifTrue:					 		[| errs |							 	errs := bufferSession getStatementErrors.								errs inspect.							^bufferSession class connectionClass unableToBindSignal raiseWith: errs 							] 			].</body><body package="StoreSqlServer" selector="bindOutputExternalOld">bindOutputExternalOld	 "Retrieve data from unbound result column. We only copy up to maxBytesToCopy"	| rc xif copyIndex maxBytesToCopy cbValue |	xif := bufferSession class xif.	copyIndex := 0.	cbValue := cbValueMax. 	bufferValue := OrderedCollection new: 0.	maxBytesToCopy := (bufferSession getMaxLongData min: cbColDef ).	[copyIndex &gt;= maxBytesToCopy ]		whileFalse: [ cbValue := ((maxBytesToCopy - copyIndex) min: cbValueMax).					rc := xif SQLGetData: bufferSession hstmt									with: bufferIndex									with: self fCType									with: bufferPointer									with: cbValue									with: pcbValue.					(bufferSession traceLevel &gt;= 3 ) ifTrue: 						[(bufferSession  traceStream)						print: rc;  nextPutAll: ' = SQLGetData( hstmt = ';						nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);						nextPutAll: ' )'.						bufferSession class trace: bufferSession emitTrace ].					((rc == xif SQL_ERROR ) or: [ rc == xif SQL_SUCCESS_WITH_INFO ] )  ifTrue:						[ | errs |						errs := bufferSession getStatementErrors.						(errs at: 1) sqlState = '01004'							ifTrue: ["Data was truncated. Ensure that we don't copy more									than maxBytesToCopy."									pcbValue contents: (maxBytesToCopy min: cbValueMax) ]							ifFalse: [ ^bufferSession class connectionClass unableToBindSignal raiseWith: errs ] ].					((rc == xif SQL_SUCCESS ) or: [ rc == xif SQL_NO_DATA_FOUND ])						ifTrue: ["All the data for the receiver has been received. 							    Ensure that we don't copy more than maxBytesToCopy."							    pcbValue contents: (maxBytesToCopy min: pcbValue contents).							    copyIndex := maxBytesToCopy + 1. ]						ifFalse: [ copyIndex := copyIndex + cbValue].					"Convert the data chunk to an appropriate object and add it."					bufferValue add: super value]</body><body package="StoreSqlServer" selector="getData">getData	 "Retrieve data from unbound result column. We only copy up to maxBytesToCopy"	| rc xif copyIndex maxBytesToCopy cbValue |	xif := bufferSession class xif.	copyIndex := 0.	cbValue := cbValueMax. 	bufferValue := OrderedCollection new: 0.	maxBytesToCopy := bufferSession getMaxLongData min: cbColDef.	[copyIndex &gt;= maxBytesToCopy ]		whileFalse: [ cbValue := ((maxBytesToCopy - copyIndex) min: cbValueMax).					rc := xif SQLGetData: bufferSession hstmt									with: bufferIndex									with: self fCType									with: bufferPointer									with: cbValue									with: pcbValue.					(bufferSession traceLevel &gt;= 3 ) ifTrue: 						[(bufferSession  traceStream)						print: rc;  nextPutAll: ' = SQLGetData( hstmt = ';						nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);						nextPutAll: ' )'.						bufferSession class trace: bufferSession emitTrace ].					((rc == xif SQL_ERROR ) or: [ rc == xif SQL_SUCCESS_WITH_INFO ] )  ifTrue:						[ | errs |						errs := bufferSession getStatementErrors.						(errs at: 1) sqlState = '01004'							ifTrue: ["Data was truncated. Ensure that we don't copy more									than maxBytesToCopy."									pcbValue contents: (maxBytesToCopy min: cbValueMax) ]							ifFalse: [ ^bufferSession class connectionClass unableToBindSignal raiseWith: errs ] ].					((rc == xif SQL_SUCCESS ) or: [ rc == xif SQL_NO_DATA_FOUND ])						ifTrue: ["All the data for the receiver has been received. 							    Ensure that we don't copy more than maxBytesToCopy."							    pcbValue contents: (maxBytesToCopy min: pcbValue contents).							    copyIndex := maxBytesToCopy + 1. ]						ifFalse: [ copyIndex := copyIndex + cbValue].					"Convert the data chunk to an appropriate object and add it."					bufferValue add: super value]</body><body package="StoreSqlServer" selector="putData">putData	 "Bind the contents of the receiver to the server."	| rc xif  valueStream chunkSize streamToPut |	xif := bufferSession class xif. 	valueStream := ReadStream on: bufferValue. 	chunkSize := bufferSession getDataChunkSize min: cbColDef.	[valueStream atEnd ]		whileFalse: 			[ "Ensure that proper conversion takes place." 			streamToPut := valueStream nextAvailable:  chunkSize.			self at: 1 put: streamToPut.			rc := xif SQLPutData: bufferSession hstmt					 		with: bufferPointer					 		with: streamToPut size.			(bufferSession traceLevel &gt;= 3 ) 				ifTrue:					[ (bufferSession  traceStream)					 	print: rc;  nextPutAll: ' = SQLPutData( hstmt = ';				 		nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);					 	nextPutAll: ', rgbValue = ';					 	nextPutAll: (bufferPointer  referentAddress printStringRadix: 16);					 	nextPutAll: ', cbValue = '; print: pcbValue contents;					 	nextPutAll: ' )'.						bufferSession class trace: bufferSession emitTrace 					].					 (rc == xif SQL_ERROR or: [ rc == xif SQL_SUCCESS_WITH_INFO ]) 						ifTrue:					 		[| errs |							 	errs := bufferSession getStatementErrors.								errs inspect.							^bufferSession class connectionClass unableToBindSignal raiseWith: errs 							] 			].</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>accessing</category><body package="StoreSqlServer" selector="value:">value: aStream	cbColDef :=  aStream contents size.   	bufferValue := aStream contents.	super value: bufferValue.	self bindInputExternal.</body></methods><methods><class-id>Database.ODBCBuffer</class-id> <category>accessing</category><body package="StoreSqlServer" selector="bufferValue">bufferValue	^bufferValue</body><body package="StoreSqlServer" selector="value:">value: aValue	bufferValue := aValue.	super value: bufferValue.</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-answer set</category><body package="StoreSqlServer" selector="getLargeObjectData">getLargeObjectData	self rowBuffers do: 		[ :buf | (buf isKindOf: ODBCLargeObjectBuffer)				ifTrue: [ buf getData. ]		].</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-execution</category><body package="StoreSqlServer" selector="getParameterValueAddress:">getParameterValueAddress:  prgbValue	"SQLParamData is used in conjunction with SQLPutData to supply parameter data at statement execution time."	| xif rc  |	xif := self class xif.    	rc := xif SQLParamData: self hstmt with: prgbValue.	(traceLevel &gt;= 3) 		ifTrue:			[ (self traceStream)			print: rc;  nextPutAll: ' = SQLParamData( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ',  prgbValue= ';			nextPutAll: (prgbValue  referentAddress printStringRadix: 16);			nextPutAll: ' )'.			self class trace: self emitTrace ]. 	^(rc == xif SQL_ERROR) 		ifTrue:			[| errs |		 	errs := self getStatementErrors.		 	self class connectionClass unableToBindSignal raiseWith: errs ]		ifFalse: [ rc ].</body></methods><methods><class-id>Store.SQLServerBroker class</class-id> <category>interface specs</category><body package="StoreSqlServer" selector="createDevicesSpec">createDevicesSpec	"UIPainter new openOnClass: self andSelector: #createDevicesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Creating databases' 			#min: #(#{Core.Point} 465 470 ) 			#max: #(#{Core.Point} 465 470 ) 			#bounds: #(#{Graphics.Rectangle} 295 152 760 622 ) 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 18 11 ) 					#label: 'To create database devices, please, specify the information:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 23 49 ) 					#label: 'Directory:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 101 ) 					#label: 'Device name:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 186 ) 					#label: 'Device name:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 124 ) 					#label: 'Virtual device number:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 211 ) 					#label: 'Virtual device number:' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 19 80 446 161 ) 					#label: 'Device for Blobs' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 19 163 446 244 ) 					#label: 'Device for Classes' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 378 428 450 452 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 299 428 371 452 ) 					#model: #accept 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 120 49 444 75 ) 					#name: #path 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #path ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 94 404 118 ) 					#name: #blobDevName 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #blobDevName ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 128 296 152 ) 					#name: #blobDevNumber 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #blobDevNumber 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 179 404 203 ) 					#name: #classDevName 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #classDevName ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 213 295 237 ) 					#name: #classDevNumber 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #classDevNumber 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 275 ) 					#label: 'Device name:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 302 ) 					#label: 'Virtual device number:' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 19 249 446 330 ) 					#label: 'Device for Blob Log' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 264 404 288 ) 					#name: #logBlobDevName 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #logBlobDevName ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 299 296 323 ) 					#name: #logBlobDevNumber 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #logBlobDevNumber 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 352 404 376 ) 					#name: #logClassDevName 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #logClassDevName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 363 ) 					#label: 'Device name:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 52 390 ) 					#label: 'Virtual device number:' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 19 337 446 418 ) 					#label: 'Device for Classes Log' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 194 386 296 410 ) 					#name: #logClassDevNumber 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #logClassDevNumber 					#type: #number ) ) ) )</body><body package="StoreSqlServer" selector="createNewAccountSpec">createNewAccountSpec	"UIPainter new openOnClass: self andSelector: #createNewAccountSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Creating new account' 			#min: #(#{Core.Point} 317 216 ) 			#max: #(#{Core.Point} 317 216 ) 			#bounds: #(#{Graphics.Rectangle} 354 276 671 492 ) 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 27 16 ) 					#label: 'Enter new account name and password, and press OK. ' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 25 102 ) 					#label: 'Account Name:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 33 136 ) 					#label: 'Password:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 109 98 282 123 ) 					#name: #account 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #account ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 109 132 282 157 ) 					#name: #password 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #password ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 12 78 295 172 ) 					#label: 'New Account' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 25 35 ) 					#label: 'Press No to use the dbo account. ' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 116 184 198 205 ) 					#model: #accept 					#label: 'Create' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 184 292 205 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>SQLBroker</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><class><name>ODBCConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hdbcHolder supportedFunctions generalInformationCache unicodeEncoding sqlConnectionOptionCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><class><name>ODBCBuffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferValue bufferIndex bufferSession fParamType cbColDef ibScale cbValueMax pcbValue getSelector putSelector unicode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Private-ODBC Buffers</category><attributes><package>ODBCEXDI</package></attributes></class><class><name>SQLAssist</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName tableClass sqlStream alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><class><name>ODBCSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmtHolder resultsCache bindValuePointers mustResendQueryHolder fetchLongResultsAnyOrder maxLongData sqlStatementOptionCache queryIsPROC unicode encoding unicodeEncoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><class><name>ODBCLargeObjectBuffer</name><environment>Database</environment><super>Database.ODBCBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Private-ODBC Buffers</category><attributes><package>ODBCEXDI</package></attributes></class></st-source>