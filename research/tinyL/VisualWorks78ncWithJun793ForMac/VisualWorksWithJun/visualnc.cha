<?xml version="1.0"?><st-source><time-stamp>From VisualWorks® Personal Use Edition, 7.8 of 2011年3月30日 on 2012年9月4日 at 21:41:14</time-stamp><comment><name-space-id>KSU</name-space-id><body>Copyright 2008-2012 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><comment><name-space-id>SSK</name-space-id><body>Copyright 2008-2011 SSK (Smalltalk Studies in Kyoto). All Right Reserved.</body></comment><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><methods><class-id>Core.Object</class-id> <category>prolog</category><body package="Kernel-Objects" selector="car">car	self == nil ifTrue: [^nil].	self error: 'send message car to atom'</body><body package="Kernel-Objects" selector="cdr">cdr	self == nil ifTrue: [^nil].	self error: 'send message cdr to atom'</body><body package="Kernel-Objects" selector="cons:">cons: anObject 	^JunPrologList car: self cdr: anObject</body><body package="Kernel-Objects" selector="consp">consp	^false</body><body package="Kernel-Objects" selector="isJunPrologEntity">isJunPrologEntity	self == nil ifTrue: [^true].	(self isKindOf: Number)		ifTrue: [^true].	^false</body><body package="Kernel-Objects" selector="isJunPrologVariable">isJunPrologVariable	^false</body><body package="Kernel-Objects" selector="printJunPrologOn:">printJunPrologOn: aStream 	self == nil		ifTrue: 			[aStream nextPutAll: '[]'.			^self].	(self isKindOf: Number)		ifTrue: 			[self printOn: aStream.			^self].	aStream nextPut: ${.	self printOn: aStream.	aStream nextPut: $}</body><body package="Kernel-Objects" selector="printJunPrologOn:level:">printJunPrologOn: aStream level: anInteger 	self printJunPrologOn: aStream</body><body package="Kernel-Objects" selector="printJunPrologString">printJunPrologString	| aStream |	aStream := WriteStream on: (String new: 20).	self printJunPrologOn: aStream.	^aStream contents</body></methods><methods><class-id>Core.Point class</class-id> <category>instance creation</category><body package="Graphics-Geometry" selector="fromUser">fromUser	"Point fromUser."	| aPoint |	Cursor crossHair		showWhile: 			[[InputState default mouseButtons &gt; 0] whileFalse.			aPoint := InputState default mousePoint.			[InputState default mouseButtons &gt; 0] whileTrue].	^aPoint</body></methods><methods><class-id>Graphics.Polyline class</class-id> <category>instance creation</category><body package="Graphics-Geometry" selector="fromUser">fromUser	"Polyline fromUser."	| oldPoint newPoint aStream |	Cursor crossHair		showWhile: 			[[InputState default mouseButtons &gt; 0] whileFalse.			oldPoint := InputState default mousePoint.			newPoint := oldPoint.			aStream := WriteStream on: (Array new: 1024).			aStream nextPut: newPoint.			[InputState default mouseButtons &gt; 0]				whileTrue: 					[JunApplicationModel displayPendingInvalidation.					newPoint := InputState default mousePoint.					newPoint = oldPoint						ifTrue: [Time millisecondClockValue \\ 100 = 0 ifTrue: [Screen default									displayShape: aStream contents									at: Point zero									forMilliseconds: 20]]						ifFalse: 							[aStream nextPut: newPoint.							Screen default								displayShape: aStream contents								at: Point zero								forMilliseconds: 20.							oldPoint := newPoint]].			[InputState default mouseButtons &gt; 0] whileTrue].	^self vertices: aStream contents</body></methods><methods><class-id>Graphics.Circle class</class-id> <category>instance creation</category><body package="Graphics-Geometry" selector="fromUser">fromUser	"Circle fromUser."	| startPoint aCenter oldPoint endPoint aCircle |	Cursor crossHair		showWhile: 			[[InputState default mouseButtons &gt; 0] whileFalse.			startPoint := InputState default mousePoint.			oldPoint := startPoint.			endPoint := oldPoint.			aCenter := self center: startPoint radius: 1.			aCircle := self center: startPoint radius: 0.			[InputState default mouseButtons &gt; 0]				whileTrue: 					[JunApplicationModel displayPendingInvalidation.					endPoint := InputState default mousePoint.					aCircle := self center: startPoint radius: (endPoint dist: startPoint) rounded.					endPoint = oldPoint						ifTrue: [Time millisecondClockValue \\ 100 = 0								ifTrue: 									[Screen default										displayShape: aCenter asPolyline vertices										at: Point zero										forMilliseconds: 20.									Screen default										displayShape: aCircle asPolyline vertices										at: Point zero										forMilliseconds: 20]]						ifFalse: 							[Screen default								displayShape: aCenter asPolyline vertices								at: Point zero								forMilliseconds: 20.							Screen default								displayShape: aCircle asPolyline vertices								at: Point zero								forMilliseconds: 20.							oldPoint := endPoint]].			[InputState default mouseButtons &gt; 0] whileTrue].	^aCircle</body></methods><methods><class-id>Graphics.LineSegment class</class-id> <category>instance creation</category><body package="Graphics-Geometry" selector="fromUser">fromUser	"LineSegment fromUser."	| startPoint oldPoint endPoint lineSegment |	Cursor crossHair		showWhile: 			[[InputState default mouseButtons &gt; 0] whileFalse.			startPoint := InputState default mousePoint.			oldPoint := startPoint.			endPoint := oldPoint.			lineSegment := self from: startPoint to: endPoint.			JunApplicationModel displayPendingInvalidation.			[InputState default mouseButtons &gt; 0]				whileTrue: 					[JunApplicationModel displayPendingInvalidation.					endPoint := InputState default mousePoint.					lineSegment := self from: startPoint to: endPoint.					endPoint = oldPoint						ifTrue: [Time millisecondClockValue \\ 100 = 0 ifTrue: [Screen default									displayShape: lineSegment asPointArray									at: Point zero									forMilliseconds: 20]]						ifFalse: 							[Screen default								displayShape: lineSegment asPointArray								at: Point zero								forMilliseconds: 20.							oldPoint := endPoint]].			[InputState default mouseButtons &gt; 0] whileTrue].	^lineSegment</body></methods><methods><class-id>Graphics.EllipticalArc class</class-id> <category>instance creation</category><body package="Graphics-Geometry" selector="fromUser">fromUser	"EllipticalArc fromUser."	| startPoint aCenter oldPoint endPoint aRectangle ellipticalArc |	Cursor crossHair		showWhile: 			[[InputState default mouseButtons &gt; 0] whileFalse.			startPoint := InputState default mousePoint.			oldPoint := startPoint.			endPoint := oldPoint.			aCenter := self center: startPoint radius: 1.			ellipticalArc := self boundingBox: (startPoint extent: 0 @ 0).			[InputState default mouseButtons &gt; 0]				whileTrue: 					[JunApplicationModel displayPendingInvalidation.					endPoint := InputState default mousePoint.					aRectangle := Rectangle vertex: startPoint - (endPoint - startPoint) vertex: startPoint + (endPoint - startPoint).					aRectangle := aRectangle align: aRectangle center with: startPoint.					(startPoint x &lt;= endPoint x and: [startPoint y &lt;= endPoint y])						ifTrue: [ellipticalArc := self										boundingBox: aRectangle										startAngle: 0										sweepAngle: 90].					(startPoint x &gt; endPoint x and: [startPoint y &lt;= endPoint y])						ifTrue: [ellipticalArc := self										boundingBox: aRectangle										startAngle: 90										sweepAngle: 90].					(startPoint x &gt; endPoint x and: [startPoint y &gt; endPoint y])						ifTrue: [ellipticalArc := self										boundingBox: aRectangle										startAngle: 180										sweepAngle: 90].					(startPoint x &lt;= endPoint x and: [startPoint y &gt; endPoint y])						ifTrue: [ellipticalArc := self										boundingBox: aRectangle										startAngle: 270										sweepAngle: 90].					endPoint = oldPoint						ifTrue: [Time millisecondClockValue \\ 100 = 0								ifTrue: 									[Screen default										displayShape: aCenter asPolyline vertices										at: Point zero										forMilliseconds: 20.									Screen default										displayShape: ellipticalArc asPolyline vertices										at: Point zero										forMilliseconds: 20]]						ifFalse: 							[Screen default								displayShape: aCenter asPolyline vertices								at: Point zero								forMilliseconds: 20.							Screen default								displayShape: ellipticalArc asPolyline vertices								at: Point zero								forMilliseconds: 20.							oldPoint := endPoint]].			[InputState default mouseButtons &gt; 0] whileTrue].	^ellipticalArc</body></methods><methods><class-id>Graphics.OpaqueImage class</class-id> <category>instance creation</category><body package="Graphics-Images" selector="fromUser">fromUser	"OpaqueImage fromUser."	"| opaqueImage aWindow | 	opaqueImage := OpaqueImage fromUser. 	aWindow := ScheduledWindow new. 	aWindow minimumSize: opaqueImage extent. 	aWindow component: opaqueImage. 	aWindow open 	"	| pointArray aFigure aShape minPoint maxPoint aRectangle aPixmap graphicsContext |	pointArray := Polyline fromUser vertices.	pointArray isEmpty		ifTrue: 			[aFigure := Image						extent: 0 @ 0						depth: Screen default colorDepth						palette: Screen default colorPalette.			aShape := aFigure copy.			aShape := aShape convertToPalette: MappedPalette whiteBlack.			aShape palette: CoveragePalette monoMaskPalette.			^OpaqueImage figure: aFigure shape: aShape].	JunApplicationModel displayPendingInvalidation.	pointArray first = pointArray last		ifFalse: 			[pointArray := pointArray copyWith: pointArray first.			Screen default				displayShape: pointArray				at: Point zero				forMilliseconds: 10].	minPoint := nil.	maxPoint := nil.	pointArray		do: 			[:aPoint | 			minPoint isNil				ifTrue: [minPoint := aPoint]				ifFalse: [minPoint := aPoint min: minPoint].			maxPoint isNil				ifTrue: [maxPoint := aPoint]				ifFalse: [maxPoint := aPoint max: maxPoint]].	aRectangle := minPoint corner: maxPoint.	aFigure := Screen default completeContentsOfArea: aRectangle.	aPixmap := Pixmap extent: aRectangle extent.	[Cursor execute		showWhile: 			[graphicsContext := aPixmap graphicsContext.			graphicsContext paint: ColorValue white.			graphicsContext displayRectangle: aPixmap bounds.			graphicsContext paint: ColorValue black.			graphicsContext displayPolygon: pointArray at: aRectangle origin negated.			aShape := aPixmap asImage]]		ensure: [aPixmap close].	aShape := aShape convertToPalette: MappedPalette whiteBlack.	aShape palette: CoveragePalette monoMaskPalette.	^OpaqueImage figure: aFigure shape: aShape</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>accessing</category><body package="System-Support" selector="getEnvironmentVariable:">getEnvironmentVariable: varName 	"Get an environment variable's value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	^SetEnv readSetEnv at: varName ifAbsent: [	^OSSystemSupport concreteClass new getVariable: varName]</body><body package="System-Support" selector="getEnvironmentVariable:ifAbsent:">getEnvironmentVariable: varName ifAbsent: errorBlock	"Get an environment variable's value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	^SetEnv readSetEnv at: varName ifAbsent: [	^OSSystemSupport concreteClass new		getVariable: varName		ifAbsent: errorBlock]</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>changing</category><body package="System-Support" selector="changed:">changed: aSymbol 	aSymbol = #returnFromSnapshot 		ifTrue: 			[(			[(SimpleHelp 				helpString: 'CINCOM SYSTEMS, INC.SOFTWARE LICENSE AGREEMENTFOR CINCOM SMALLTALK PERSONAL USE IMPORTANT NOTICE:  READ THE TERMS AND CONDITIONS OF THIS LICENSE AGREEMENT CAREFULLY BEFORE PROCEEDING TO USE THIS COMPUTER SOFTWARE AND THE ACCOMPANYING USER DOCUMENTATION (THE "PRODUCT"). THE PRODUCT IS COPYRIGHTED AND ITS USE IS LICENSED (NOT SOLD).  BY DOWNLOADING AND/OR INSTALLING THE PRODUCT ON A COMPUTER AND USING THE PRODUCT, YOU ARE ACCEPTING AND AGREEING TO THE TERMS OF THIS LICENSE AGREEMENT.  IF YOU ARE NOT WILLING TO BE BOUND BY THE TERMS AND CONDITIONS OF THIS LICENSE AGREEMENT, YOU SHOULD NOT DOWNLOAD OR, USE THE PRODUCT AND PROMPTLY DELETE, DESTROY OR RETURN THE PRODUCT.  THIS LICENSE AGREEMENT REPRESENTS THE ENTIRE AGREEMENT CONCERNING THE PRODUCT BETWEEN YOU AND CINCOM SYSTEMS, INC. (REFERRED TO HEREIN AS "LICENSOR"), AND THIS AGREEMENT SUPERSEDES ANY PRIOR PROPOSALS, REPRESENTATIONS, OR UNDERSTANDING BETWEEN THE PARTIES PERTAINING TO THE PRODUCTS GOVERNED BY THIS LICENSE AGREEMENT.	1. License Grant.  Licensor hereby grants to you, the individual, and you do hereby accept, a nonexclusive and nontransferable license to use the Product only as is authorized in this License Agreement.  The Product may be used or accessed by only you only at a single location on computers owned, leased or otherwise controlled by you in the manner and subject to the terms set forth in this License Agreement.  You agree that you will not, assign, sublicense, transfer, pledge, lease, rent, allow access to or share your rights under this License Agreement.  You agree that your rights under this License Agreement does not cover the use of the Products for any revenue generating purpose or operation of any business venture and are not to pass to a successor through merger or consolidation.  You agree that you may not reverse assemble, reverse compile, reverse engineer or otherwise translate the Product.  You agree that you receive no rights other than those expressly granted to you in this License Agreement	You may make one copy of the Product for the purpose of backup in the event the Product is damaged or destroyed.  Any such copies of the Product shall include Licensor''s copyright and other proprietary notices.  Execpt as authorized under this paragraph, no copies of the Product or any portions thereof may be made by you or any person under your authority or control.	U.S. Government Restricted Rights:  Licensor provides the Product with RESTRICTED RIGHTS.  Use, duplication, or disclosure by the U.S. Government or any agency or instrumentality thereof is subject to restrictions set forth in subparagraphs (c) (1) and (2) of the Commercial Computer Software - Restricted Rights clause at 48 C.F.R. 52.227-19, or any successor provision, as applicable. The Contractor/Manufacturer is Cincom Systems, Inc., 55 Merchant Street, Cincinnati, Ohio  45246.	2. Licensor''s Rights.  You acknowledge and agree that the Product is a proprietary product of Licensor protected under U.S. copyright law and international treaty provisions.  You further acknowledge and agree that all right, title, and interest in and to the Product, including associated intellectual property rights, are and shall remain with Licensor. This License Agreement does not convey to you an interest in or to the Product, but only a limited right of use revocable in accordance with the terms of this License Agreement.	3. License Fees.  This license is granted to you for your personal use only.  Therefore, no license fees are involved, unless you breach the terms and conditions of this Agreement. Upon any such breach you shall pay Licensor any and all applicable damages relating to the breach, including, but not limited to the applicable license fees for the Product for your nonconforming use.	4. Term.  This License Agreement is effective upon delivery of the Product to you and will remain in effect until terminated.  You may terminate this License Agreement at any time.  Licensor may terminate this License Agreement upon your breach of any term hereof.  Upon termination by Licensor, you agree to discontinue usage and return or destroy all copies and portions of the Product.	5. Limited Warranty. THE PRODUCT IS LICENSED "AS IS," AND LICENSOR DISCLAIMS ANY AND ALL OTHER WARRANTIES, WHETHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.	6. Limitation of Liability.  Licensor''s cumulative liability to you or any other party for any loss or damages resulting from any claims, demands, or actions arising out of or relating to this Agreement will not exceed the total amount paid by you to Licensor.  In no event shall Licensor be liable for any indirect, incidental, consequential, special, or exemplary damages or lost profits, even if Licensor has been advised of the possibility of such damages.  THE ABOVE LIMITATION OR EXCLUSION MAY NOT BE ALLOWED BY ALL JURISDICTIONS.	7. Trademark.  The trademarks and copyrights listed in this License Agreement, on the Product, or related documentation are trademarks and copyrights of Licensor.  No right, license, or interest to such trademarks and copyrights is granted hereunder, and you agree that no such right, license, or interest shall be asserted by you with respect to such trademarks and copyrights.	8. Governing Law.  This License Agreement shall be construed and governed in accordance with the laws of the State of Ohio.	9. Costs of Litigation.  If any action is brought by either party to this License Agreement against the other party regarding the subject matter hereof, the prevailing party shall be entitled to recover, in addition to any other relief granted, reasonable attorney fees and expenses of litigation.	10. Severability.  Should any term of this License Agreement be declared void or unenforceable by any court of competent jurisdiction, such declaration shall have no effect on the remaining terms hereof.	11. No Waiver.  The failure of either party to enforce any rights granted hereunder or to take action against the other party in the event of any breach hereunder shall not be deemed a waiver by that party as to subsequent enforcement of such or any other such rights or any subsequent actions in the event of future breaches.	12. Export.  Licensee shall ensure that neither the Cincom Products, commodities, technology, or software, nor any direct product thereof are exported, directly or indirectly, in violation of the export laws and regulations of the United States of America including the Export Administration Regulations.  Diversion contrary to U.S. law is prohibited.  If you have any questions about this License Agreement, or if you have any questions or comments about the Product, please contact your local Cincom sales office.') 					openInterface: #licenseSpec] 					on: UserInterrupt					do: [:exception | exception resume]) ifFalse: [ObjectMemory quitPrimitive]].	super changed: aSymbol</body></methods><methods><class-id>SetEnv class</class-id> <category>class initialization</category><body package="(none)" selector="initialize">initialize	"SetEnv initialize."	self install</body><body package="(none)" selector="install">install	"SetEnv install."	SystemUtils class compile: 'getEnvironmentVariable: varName 	"Get an environment variable''s value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	^SetEnv readSetEnv at: varName ifAbsent: [	^OSSystemSupport concreteClass new getVariable: varName]' classified: 'accessing'.	SystemUtils class compile: 'getEnvironmentVariable: varName ifAbsent: errorBlock	"Get an environment variable''s value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	^SetEnv readSetEnv at: varName ifAbsent: [	^OSSystemSupport concreteClass new		getVariable: varName		ifAbsent: errorBlock]' classified: 'accessing'</body><body package="(none)" selector="obsolete">obsolete	self uninstall.	super obsolete</body><body package="(none)" selector="uninstall">uninstall	"SetEnv uninstall."	SystemUtils class compile: 'getEnvironmentVariable: varName 	"Get an environment variable''s value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	^OSSystemSupport concreteClass new getVariable: varName' classified: 'accessing'.	SystemUtils class compile: 'getEnvironmentVariable: varName ifAbsent: errorBlock	"Get an environment variable''s value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	^OSSystemSupport concreteClass new		getVariable: varName		ifAbsent: errorBlock' classified: 'accessing'</body></methods><methods><class-id>SetEnv class</class-id> <category>string and character</category><body package="(none)" selector="getChar:">getChar: aStream 	| char |	aStream atEnd		ifTrue: [char := nil]		ifFalse: 			[char := aStream next.			char = Character lf				ifTrue: [char := Character cr]				ifFalse: [char = Character cr ifTrue: [aStream peek = Character lf ifTrue: [aStream next]]]].	^char</body><body package="(none)" selector="getLine:">getLine: aStream 	| stream char |	stream := WriteStream on: (String new: 128).	char := self getChar: aStream.	[char notNil and: [char ~= Character cr]]		whileTrue: 			[stream nextPut: char.			char := self getChar: aStream].	(char notNil and: [char = Character cr])		ifTrue: [stream nextPut: char].	^stream contents</body><body package="(none)" selector="separate:dividers:">separate: separateCollection dividers: dividerCollection 	"SetEnv separate: #(a b c d e f g h) dividers: #(d f)."	| indexCollection index intervalCollection s e result |	indexCollection := OrderedCollection new.	indexCollection add: 0.	index := 1.	separateCollection		do: 			[:each | 			(dividerCollection includes: each)				ifTrue: [indexCollection add: index].			index := index + 1].	indexCollection add: separateCollection size + 1.	intervalCollection := OrderedCollection new.	1 to: indexCollection size - 1		do: 			[:i | 			s := indexCollection at: i.			e := indexCollection at: i + 1.			intervalCollection add: (s + 1 to: e - 1)].	result := OrderedCollection new.	intervalCollection do: [:interval | interval size &gt; 0 ifTrue: [result add: (separateCollection copyFrom: interval first to: interval last)]].	^result</body><body package="(none)" selector="separators">separators	"SetEnv separators."	| stream |	stream := WriteStream on: (String new: 4).	stream nextPut: Character space.	stream nextPut: Character tab.	stream nextPut: Character cr.	stream nextPut: Character lf.	^stream contents</body></methods><methods><class-id>SetEnv class</class-id> <category>private</category><body package="(none)" selector="readSetEnv">readSetEnv	"SetEnv readSetEnv."	| aDictionary aFilename aStream aString aCollection aKey aValue anIndex |	aDictionary := Dictionary new.	aFilename := 'SetEnv.txt' asFilename.	aFilename exists ifFalse: [^aDictionary].	aFilename isReadable ifFalse: [^aDictionary].	aStream := aFilename readStream.	[[aStream atEnd]		whileFalse: 			[aString := self getLine: aStream.			aCollection := self separate: aString dividers: self separators.			(aCollection size &gt;= 3 and: [aCollection first asLowercase = 'setenv'])				ifTrue: 					[aKey := aCollection at: 2.					aValue := aString copyFrom: (aString findString: (aCollection at: 3)									startingAt: 1)								to: aString size.					anIndex := aValue reverse findFirst: [:aCharacter | aCharacter isSeparator not].					anIndex &gt; 0 ifTrue: [aValue := aValue copyFrom: 1 to: aValue size - (anIndex - 1)].					aValue size &gt;= 2 ifTrue: [((aValue first = $' and: [aValue last = $'])							or: [aValue first = $" and: [aValue last = $"]])							ifTrue: [aValue := aValue copyFrom: 2 to: aValue size - 1]].					aDictionary at: aKey put: aValue]]]		ensure: [aStream close].	^aDictionary</body><body package="(none)" selector="setEnv">setEnv	"SetEnv setEnv."	self errorSignal handle: [:exception | exception return]		do: [self readSetEnv				keysAndValuesDo: 					[:key :value | 					SystemUtils setEnvironmentVariable: key value: value.					Transcript cr; show: 'setenv'; space; show: key asString; space.					(value asString detect: [:char | char isSeparator]						ifNone: [nil]) isNil						ifTrue: [Transcript show: value asString]						ifFalse: [Transcript show: value printString]]]</body></methods><methods><class-id>KSU.ProgramManager class</class-id> <category>accessing</category><body package="KSU-System" selector="bundle">bundle	"KSU.ProgramManager bundle."	^Store.Registry bundleNamed: #KSU</body><body package="KSU-System" selector="bundles">bundles	"KSU.ProgramManager bundles."	^self bundle allItems select: [:each | each isBundle]</body><body package="KSU-System" selector="classes">classes	"KSU.ProgramManager classes."	| aBundle |	aBundle := self bundle.	^aBundle allClasses collect: [:each | each actual]</body><body package="KSU-System" selector="implementedMethods">implementedMethods	"KSU.ProgramManager implementedMethods."	| aCollection |	aCollection := OrderedCollection new.	self classes do: 			[:aClass |			aClass selectors do: [:aSymbol | aCollection add: aClass -&gt; aSymbol].			aClass class selectors do: [:aSymbol | aCollection add: aClass class -&gt; aSymbol]].	^aCollection</body><body package="KSU-System" selector="namespace">namespace	"KSU.ProgramManager namespace."	| aNameSpace |	aNameSpace := Smalltalk at: #KSU.	(aNameSpace isKindOf: NameSpace) ifFalse: [^nil].	^aNameSpace</body><body package="KSU-System" selector="packages">packages	"KSU.ProgramManager packages."	^self bundle allItems select: [:each | each isPackage]</body></methods><methods><class-id>KSU.ProgramManager class</class-id> <category>comments</category><body package="KSU-System" selector="commentString">commentString	"KSU.ProgramManager commentString."	^'Copyright 2008-2012 KSU (Kyoto Sangyo University). All Right Reserved.'</body><body package="KSU-System" selector="propagateComment">propagateComment	"KSU.ProgramManager propagateComment."	| aString |	aString := self commentString.	self classes do: [:aClass | aClass comment: aString].	self bundle allItems do: [:each | each comment: aString].	self namespace comment: aString</body></methods><methods><class-id>KSU.ProgramManager class</class-id> <category>saving</category><body package="KSU-System" selector="save">save	"KSU.ProgramManager save."	| aBundle dateString timeString aDirectory aFilename aFileManager |	aBundle := self bundle.	dateString := JunCalendarModel stringFromDate select: [:each | each isDigit].	timeString := JunCalendarModel stringFromTime select: [:each | each isDigit].	[(aDirectory := JunSystem homeDirectory construct: 'Desktop') exists ifFalse: [self error: String new]]		on: self errorSignal		do: [:exception | aDirectory := Filename defaultDirectory directory].	aFilename := aDirectory construct: 'KSU_' , dateString , '_' , timeString , '.st'.	Cursor write showWhile: 			[aFileManager := SourceCodeStream write: aFilename.						[aBundle fileOutOn: aFileManager.			self writeClassInitializeOn: aFileManager.			self writeTimeStampOn: aFileManager]					ensure: [aFileManager close]]</body></methods><methods><class-id>KSU.ProgramManager class</class-id> <category>documents</category><body package="KSU-System" selector="doclet">doclet	"KSU.ProgramManager doclet."	| classCollection aDoclet toDirectory fromDirectory |	classCollection := self classes.	aDoclet := KSU.TextDoclet codePrint: classCollection.	fromDirectory := aDoclet instVarAt: (aDoclet class allInstVarNames indexOf: 'toDirectory').	toDirectory := fromDirectory directory construct: 'doclet'.	toDirectory exists		ifTrue: 			[toDirectory directoryContents do: [:each | (toDirectory construct: each) delete].			toDirectory delete].	fromDirectory renameTo: toDirectory.	JunURL browse: (toDirectory construct: 'index.html') asURI asString.	^aDoclet</body></methods><methods><class-id>KSU.ProgramManager class</class-id> <category>metrics</category><body package="KSU-System" selector="linesOfCode">linesOfCode	"KSU.ProgramManager linesOfCode inspect."	| linesOfCode aString |	linesOfCode := 0.	self classes do: 			[:aClass |			aString := KSU.TextDoclet codePrintStringOf: aClass.			linesOfCode := linesOfCode + (aString select: [:each | each = Character cr]) size].	^linesOfCode</body></methods><methods><class-id>KSU.ProgramManager class</class-id> <category>private</category><body package="KSU-System" selector="makeBackups:forFilename:">makeBackups: howMany forFilename: aFilename	(howMany to: 1 by: -1) do: 			[:n |			| anArray bakFilename |			anArray := Filename splitExtension: aFilename asString.			n &lt;= 1				ifTrue: [bakFilename := aFilename]				ifFalse: 					[bakFilename := (anArray first , (n - 1) printString , aFilename extension)								asFilename].			bakFilename exists				ifTrue: 					[| oldFilename |					oldFilename := (anArray first , n printString , aFilename extension)								asFilename.					bakFilename copyTo: oldFilename]]</body><body package="KSU-System" selector="writeClassInitializeOn:">writeClassInitializeOn: aFileManager	(self classes select: [:aClass | aClass class selectors includes: #initialize]) do: 			[:aClass |			| aStream |			aStream := aFileManager ensureOpen: aFileManager target.			aStream cr.			aStream cr.			aStream nextPutAll: '&lt;initialize&gt;'.			aStream				cr;				nextPutAll: '&lt;class-id&gt;';				nextPutAll: aClass shortName;				nextPutAll: '&lt;/class-id&gt;';				cr.			aStream nextPutAll: '&lt;/initialize&gt;']</body><body package="KSU-System" selector="writeTimeStampOn:">writeTimeStampOn: aFileManager	| aStream |	aStream := aFileManager ensureOpen: aFileManager target.	aStream cr.	aStream cr.	aStream nextPutAll: '&lt;do-it&gt;'.	aStream cr.	JunSourceCodeSaver writeStampOn: aStream.	aStream cr.	aStream nextPutAll: '&lt;/do-it&gt;'</body></methods><methods><class-id>KSU.Example class</class-id> <category>examples</category><body package="KSU-Example" selector="example1">example1	"KSU.Example example1."	</body></methods><methods><class-id>SSK.ProgramManager class</class-id> <category>accessing</category><body package="SSK-System" selector="bundle">bundle	"SSK.ProgramManager bundle."	^Store.Registry bundleNamed: #SSK</body><body package="SSK-System" selector="bundles">bundles	"SSK.ProgramManager bundles."	^self bundle allItems select: [:each | each isBundle]</body><body package="SSK-System" selector="classes">classes	"SSK.ProgramManager classes."	| aBundle |	aBundle := self bundle.	^aBundle allClasses collect: [:each | each actual]</body><body package="SSK-System" selector="implementedMethods">implementedMethods	"SSK.ProgramManager implementedMethods."	| aCollection |	aCollection := OrderedCollection new.	self classes do: 			[:aClass |			aClass selectors do: [:aSymbol | aCollection add: aClass -&gt; aSymbol].			aClass class selectors do: [:aSymbol | aCollection add: aClass class -&gt; aSymbol]].	^aCollection</body><body package="SSK-System" selector="namespace">namespace	"SSK.ProgramManager namespace."	| aNameSpace |	aNameSpace := Smalltalk at: #SSK.	(aNameSpace isKindOf: NameSpace) ifFalse: [^nil].	^aNameSpace</body><body package="SSK-System" selector="packages">packages	"SSK.ProgramManager packages."	^self bundle allItems select: [:each | each isPackage]</body></methods><methods><class-id>SSK.ProgramManager class</class-id> <category>comments</category><body package="SSK-System" selector="commentString">commentString	"SSK.ProgramManager commentString."	^'Copyright 2008-2011 SSK (Smalltalk Studies in Kyoto). All Right Reserved.'</body><body package="SSK-System" selector="propagateComment">propagateComment	"SSK.ProgramManager propagateComment."	| aString |	aString := self commentString.	self classes do: [:aClass | aClass comment: aString].	self bundle allItems do: [:each | each comment: aString].	self namespace comment: aString</body></methods><methods><class-id>SSK.ProgramManager class</class-id> <category>saving</category><body package="SSK-System" selector="save">save	"SSK.ProgramManager save."	| aBundle dateString timeString aDirectory aFilename aFileManager |	aBundle := self bundle.	dateString := JunCalendarModel stringFromDate select: [:each | each isDigit].	timeString := JunCalendarModel stringFromTime select: [:each | each isDigit].	[(aDirectory := JunSystem homeDirectory construct: 'Desktop') exists ifFalse: [self error: String new]]		on: self errorSignal		do: [:exception | aDirectory := Filename defaultDirectory directory].	aFilename := aDirectory construct: 'SSK_' , dateString , '_' , timeString , '.st'.	Cursor write showWhile: 			[aFileManager := SourceCodeStream write: aFilename.						[aBundle fileOutOn: aFileManager.			self writeClassInitializeOn: aFileManager.			self writeTimeStampOn: aFileManager]					ensure: [aFileManager close]]</body></methods><methods><class-id>SSK.ProgramManager class</class-id> <category>documents</category><body package="SSK-System" selector="doclet">doclet	"SSK.ProgramManager doclet."	| classCollection aDoclet toDirectory fromDirectory |	classCollection := self classes.	aDoclet := SSK.TextDoclet codePrint: classCollection.	fromDirectory := aDoclet				instVarAt: (aDoclet class allInstVarNames indexOf: 'toDirectory').	toDirectory := fromDirectory directory construct: 'doclet'.	toDirectory exists		ifTrue: 			[toDirectory directoryContents				do: [:each | (toDirectory construct: each) delete].			toDirectory delete].	fromDirectory renameTo: toDirectory.	JunURL browse: (toDirectory construct: 'index.html') asURI asString.	^aDoclet</body></methods><methods><class-id>SSK.ProgramManager class</class-id> <category>metrics</category><body package="SSK-System" selector="linesOfCode">linesOfCode	"SSK.ProgramManager linesOfCode inspect."	| linesOfCode aString |	linesOfCode := 0.	self classes do: 			[:aClass |			aString := SSK.TextDoclet codePrintStringOf: aClass.			linesOfCode := linesOfCode						+ (aString select: [:each | each = Character cr]) size].	^linesOfCode</body></methods><methods><class-id>SSK.ProgramManager class</class-id> <category>private</category><body package="SSK-System" selector="makeBackups:forFilename:">makeBackups: howMany forFilename: aFilename	(howMany to: 1 by: -1) do: 			[:n |			| anArray bakFilename |			anArray := Filename splitExtension: aFilename asString.			n &lt;= 1				ifTrue: [bakFilename := aFilename]				ifFalse: 					[bakFilename := (anArray first , (n - 1) printString , aFilename extension)								asFilename].			bakFilename exists				ifTrue: 					[| oldFilename |					oldFilename := (anArray first , n printString , aFilename extension)								asFilename.					bakFilename copyTo: oldFilename]]</body><body package="SSK-System" selector="writeClassInitializeOn:">writeClassInitializeOn: aFileManager	(self classes select: [:aClass | aClass class selectors includes: #initialize]) do: 			[:aClass |			| aStream |			aStream := aFileManager ensureOpen: aFileManager target.			aStream cr.			aStream cr.			aStream nextPutAll: '&lt;initialize&gt;'.			aStream				cr;				nextPutAll: '&lt;class-id&gt;';				nextPutAll: aClass shortName;				nextPutAll: '&lt;/class-id&gt;';				cr.			aStream nextPutAll: '&lt;/initialize&gt;']</body><body package="SSK-System" selector="writeTimeStampOn:">writeTimeStampOn: aFileManager	| aStream |	aStream := aFileManager ensureOpen: aFileManager target.	aStream cr.	aStream cr.	aStream nextPutAll: '&lt;do-it&gt;'.	aStream cr.	JunSourceCodeSaver writeStampOn: aStream.	aStream cr.	aStream nextPutAll: '&lt;/do-it&gt;'</body></methods><methods><class-id>KSU.TextDoclet class</class-id> <category>examples</category><body package="KSU-Tool" selector="example1">example1	"KSU.TextDoclet example1."	| aDirectory aDoclet |	JunUniFileModel requestDirectoryName		ifNil: [^nil]		ifNotNil: [:fileModel | aDirectory := fileModel asFilename].	aDoclet := TextDoclet dive: aDirectory pattern: '*.java'.	aDoclet generate.	^aDoclet</body><body package="KSU-Tool" selector="example2">example2	"KSU.TextDoclet example2."	| classCollection aDoclet |	classCollection := (Array with: TextDoclet with: Example with: ProgramManager)				, (Array with: Point with: Rectangle with: LineSegment).	aDoclet := TextDoclet codePrint: classCollection.	^aDoclet</body></methods><methods><class-id>KSU.TextDoclet class</class-id> <category>defaults</category><body package="KSU-Tool" selector="defaultDestinationDirectory">defaultDestinationDirectory	"KSU.TextDoclet defaultDestinationDirectory."	^JunSystem homeDirectory construct: 'Desktop'</body><body package="KSU-Tool" selector="defaultDivingLevel">defaultDivingLevel	"KSU.TextDoclet defaultDivingLevel."	^10</body><body package="KSU-Tool" selector="defaultEncoding">defaultEncoding	"KSU.TextDoclet defaultEncoding."	^#UTF_8</body><body package="KSU-Tool" selector="defaultTabStop">defaultTabStop	"KSU.TextDoclet defaultTabStop."	^4</body></methods><methods><class-id>KSU.TextDoclet class</class-id> <category>instance creation</category><body package="KSU-Tool" selector="dive:pattern:">dive: aDirectory pattern: aString	| aDoclet |	aDoclet := self new.	aDoclet		fromDirectory: aDirectory		textFiles: (JunFileModel				dive: aDirectory				level: self defaultDivingLevel				pattern: aString)		toDirectory: (self defaultDestinationDirectory				construct: aDirectory tail , '_' , (JunCalendarModel stringFromDateAndTime select: [:each | each isDigit])).	^aDoclet</body></methods><methods><class-id>KSU.TextDoclet class</class-id> <category>utilities</category><body package="KSU-Tool" selector="codePrint:">codePrint: classCollection	"KSU.TextDoclet codePrint: (KSU.ProgramManager classes)."	| aString aDirectory aCollection aDoclet |	aString := String new.	classCollection do: [:aClass | aString := aString , aClass name] separatedBy: [aString := aString , '_'].	aString size &gt; 50 ifTrue: [aString := aString copyFrom: 1 to: 50].	JunControlUtility		assert: 			[[(aDirectory := aString asFilename) exists] whileTrue: [aString := aString , '_'].			aDirectory makeDirectory.			aCollection := OrderedCollection new]		do: 			[classCollection do: 					[:aClass |					| aFilename |					aString := aClass fullName collect: [:aCharacter | aCharacter = $. ifTrue: [$_] ifFalse: [aCharacter]].					aFilename := aDirectory construct: aString , '.st'.					aCollection add: aFilename.					JunControlUtility						assert: [(aFilename withEncoding: self defaultEncoding) writeStream]						do: [:aStream | TextDoclet codePrintStringOf: aClass on: aStream]						ensure: [:aStream | aStream close]].			aDoclet := TextDoclet dive: aDirectory pattern: '*.st'.			aDoclet generate]		ensure: 			[aCollection do: [:aFilename | aFilename delete].			aDirectory delete].	^aDoclet</body><body package="KSU-Tool" selector="codePrintStringOf:">codePrintStringOf: theClass	"KSU.TextDoclet codePrintStringOf: KSU.TextDoclet."	| aString |	JunControlUtility		assert: [(String new: 1024) writeStream]		do: 			[:aStream |			self codePrintStringOf: theClass on: aStream.			aString := aStream contents]		ensure: [:aStream | (aStream respondsTo: #close) ifTrue: [aStream close]].	^aString</body><body package="KSU-Tool" selector="codePrintStringOf:on:">codePrintStringOf: theClass on: theStream	"KSU.TextDoclet codePrintStringOf: KSU.TextDoclet on: (Transcript clear; yourself)."	| aBlock aString |	aBlock :=			[:aClass :aStream |			| anOrganization aBoolean |			80 timesRepeat: [aStream nextPutAll: '='].			2 timesRepeat: [aStream cr].			aStream nextPutAll: aClass definition.			2 timesRepeat: [aStream cr].			anOrganization := aClass organization.			aBoolean := true.			aClass selectors asSortedCollection do: 					[:aSelector |					| aCode |					aBoolean						ifTrue: 							[80 timesRepeat: [aStream nextPutAll: '='].							2 timesRepeat: [aStream cr].							aBoolean := false]						ifFalse: 							[60 timesRepeat: [aStream nextPutAll: '-'].							2 timesRepeat: [aStream cr]].					aStream						nextPutAll: aClass fullName;						nextPutAll: ' method for ';						nextPutAll: (anOrganization categoryOfElement: aSelector) asString printString.					2 timesRepeat: [aStream cr].					aCode := aClass sourceMethodAt: aSelector.					aStream nextPutAll: aCode.					2 timesRepeat: [aStream cr]]].	JunControlUtility		assert: [(String new: 1024) writeStream]		do: 			[:aStream |			| aClass |			aClass := theClass isMeta ifTrue: [theClass soleInstance] ifFalse: [theClass yourself].			aBlock value: aClass value: aStream.			aBlock value: aClass class value: aStream.			80 timesRepeat: [aStream nextPutAll: '='].			aStream cr.			aString := aStream contents]		ensure: [:aStream | (aStream respondsTo: #close) ifTrue: [aStream close]].	theStream nextPutAll: aString.	^aString</body></methods><methods><class-id>SSK.TextDoclet class</class-id> <category>examples</category><body package="SSK-Tool" selector="example1">example1	"SSK.TextDoclet example1."	| aDirectory aDoclet |	JunUniFileModel requestDirectoryName		ifNil: [^nil]		ifNotNil: [:fileModel | aDirectory := fileModel asFilename].	aDoclet := TextDoclet dive: aDirectory pattern: '*.java'.	aDoclet generate.	^aDoclet</body><body package="SSK-Tool" selector="example2">example2	"SSK.TextDoclet example2."	| classCollection aDoclet |	classCollection := (Array with: TextDoclet with: Example with: ProgramManager)				, (Array with: Point with: Rectangle with: LineSegment).	aDoclet := TextDoclet codePrint: classCollection.	^aDoclet</body></methods><methods><class-id>SSK.TextDoclet class</class-id> <category>defaults</category><body package="SSK-Tool" selector="defaultDestinationDirectory">defaultDestinationDirectory	"SSK.TextDoclet defaultDestinationDirectory."	^JunSystem homeDirectory construct: 'Desktop'</body><body package="SSK-Tool" selector="defaultDivingLevel">defaultDivingLevel	"SSK.TextDoclet defaultDivingLevel."	^10</body><body package="SSK-Tool" selector="defaultEncoding">defaultEncoding	"SSK.TextDoclet defaultEncoding."	^#UTF_8</body><body package="SSK-Tool" selector="defaultTabStop">defaultTabStop	"SSK.TextDoclet defaultTabStop."	^4</body></methods><methods><class-id>SSK.TextDoclet class</class-id> <category>instance creation</category><body package="SSK-Tool" selector="dive:pattern:">dive: aDirectory pattern: aString	| aDoclet |	aDoclet := self new.	aDoclet		fromDirectory: aDirectory		textFiles: (JunFileModel				dive: aDirectory				level: self defaultDivingLevel				pattern: aString)		toDirectory: (self defaultDestinationDirectory				construct: aDirectory tail , '_' , (JunCalendarModel stringFromDateAndTime select: [:each | each isDigit])).	^aDoclet</body></methods><methods><class-id>SSK.TextDoclet class</class-id> <category>utilities</category><body package="SSK-Tool" selector="codePrint:">codePrint: classCollection	"SSK.TextDoclet codePrint: (SSK.ProgramManager classes)."	| aString aDirectory aCollection aDoclet |	aString := String new.	classCollection do: [:aClass | aString := aString , aClass name] separatedBy: [aString := aString , '_'].	aString size &gt; 50 ifTrue: [aString := aString copyFrom: 1 to: 50].	JunControlUtility		assert: 			[[(aDirectory := aString asFilename) exists] whileTrue: [aString := aString , '_'].			aDirectory makeDirectory.			aCollection := OrderedCollection new]		do: 			[classCollection do: 					[:aClass |					| aFilename |					aString := aClass fullName collect: [:aCharacter | aCharacter = $. ifTrue: [$_] ifFalse: [aCharacter]].					aFilename := aDirectory construct: aString , '.st'.					aCollection add: aFilename.					JunControlUtility						assert: [(aFilename withEncoding: self defaultEncoding) writeStream]						do: [:aStream | TextDoclet codePrintStringOf: aClass on: aStream]						ensure: [:aStream | aStream close]].			aDoclet := TextDoclet dive: aDirectory pattern: '*.st'.			aDoclet generate]		ensure: 			[aCollection do: [:aFilename | aFilename delete].			aDirectory delete].	^aDoclet</body><body package="SSK-Tool" selector="codePrintStringOf:">codePrintStringOf: theClass	"SSK.TextDoclet codePrintStringOf: SSK.TextDoclet."	| aString |	JunControlUtility		assert: [(String new: 1024) writeStream]		do: 			[:aStream |			self codePrintStringOf: theClass on: aStream.			aString := aStream contents]		ensure: [:aStream | (aStream respondsTo: #close) ifTrue: [aStream close]].	^aString</body><body package="SSK-Tool" selector="codePrintStringOf:on:">codePrintStringOf: theClass on: theStream	"SSK.TextDoclet codePrintStringOf: SSK.TextDoclet on: (Transcript clear; yourself)."	| aBlock aString |	aBlock :=			[:aClass :aStream |			| anOrganization aBoolean |			80 timesRepeat: [aStream nextPutAll: '='].			2 timesRepeat: [aStream cr].			aStream nextPutAll: aClass definition.			2 timesRepeat: [aStream cr].			anOrganization := aClass organization.			aBoolean := true.			aClass selectors asSortedCollection do: 					[:aSelector |					| aCode |					aBoolean						ifTrue: 							[80 timesRepeat: [aStream nextPutAll: '='].							2 timesRepeat: [aStream cr].							aBoolean := false]						ifFalse: 							[60 timesRepeat: [aStream nextPutAll: '-'].							2 timesRepeat: [aStream cr]].					aStream						nextPutAll: aClass fullName;						nextPutAll: ' method for ';						nextPutAll: (anOrganization categoryOfElement: aSelector) asString printString.					2 timesRepeat: [aStream cr].					aCode := aClass sourceMethodAt: aSelector.					aStream nextPutAll: aCode.					2 timesRepeat: [aStream cr]]].	JunControlUtility		assert: [(String new: 1024) writeStream]		do: 			[:aStream |			| aClass |			aClass := theClass isMeta ifTrue: [theClass soleInstance] ifFalse: [theClass yourself].			aBlock value: aClass value: aStream.			aBlock value: aClass class value: aStream.			80 timesRepeat: [aStream nextPutAll: '='].			aStream cr.			aString := aStream contents]		ensure: [:aStream | (aStream respondsTo: #close) ifTrue: [aStream close]].	theStream nextPutAll: aString.	^aString</body></methods><methods><class-id>SSK.Example class</class-id> <category>examples</category><body package="SSK-Example" selector="example1">example1	"SSK.Example example1."	</body></methods><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><methods><class-id>Core.Point</class-id> <category>converting</category><body package="Graphics-Geometry" selector=",">, aNumber 	^Jun3dPoint		x: self x		y: self y		z: aNumber</body></methods><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><methods><class-id>Core.Number</class-id> <category>converting</category><body package="Magnitude-Numbers" selector=",">, aNumber 	^Jun2dPoint		x: self		y: aNumber</body><body package="Magnitude-Numbers" selector="asDegrees">asDegrees 	^JunAngle degrees: self</body><body package="Magnitude-Numbers" selector="asRadians">asRadians 	^JunAngle radians: self</body></methods><class><name>Pixmap</name><environment>Graphics</environment><super>Graphics.UnmappableSurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><methods><class-id>Graphics.Pixmap</class-id> <category>accessing</category><body package="OS-Window System" selector="renderingContext">renderingContext	^JunOpenGLRenderingContext on: self</body></methods><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><methods><class-id>Graphics.Window</class-id> <category>accessing</category><body package="OS-Window System" selector="renderingContext">renderingContext	^JunOpenGLRenderingContext on: self</body></methods><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="UIBuilder-Support" selector="columnedListView:into:">columnedListView: spec into: builder 	| lv model menu performer dropSourceCallbacks |	model := spec modelInBuilder: builder.	lv := (spec multipleSelections				ifTrue: [self columnedMultiSelectionListViewClass]				ifFalse: [self columnedListViewClass]) new.	lv model: model listHolder.	spec hasHorizontalScrollBar ifTrue: [lv measureWidth: true].	lv selectionChannel: model selectionIndexHolder.	spec selectionType == #checkMark ifTrue: [lv checkedSelection].	spec multipleSelections ifTrue: [spec useModifierKeys			ifTrue: [lv controller: self compliantColumnedMultiSelectControllerClass new]			ifFalse: [lv controller: self simpleColumnedMultiSelectControllerClass new]].	(menu := spec getMenuIn: builder) == nil ifFalse: [lv controller menuHolder: menu].	(performer := spec getPerformerIn: builder) == nil ifFalse: [lv controller performer: performer].	self setStyleOf: lv to: spec style.	self		setDispatcherOf: lv		fromSpec: spec		builder: builder.	spec tabable		ifTrue: 			[lv widgetState isTabStop: true.			builder sendKeyboardTo: lv]		ifFalse: 			[lv widgetState canTakeFocus: true.			lv controller keyboardProcessor: builder keyboardProcessor].	lv widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [lv widgetState isVisible: spec initiallyVisible].	dropSourceCallbacks := spec dropSourceCallbacksOrNilInBuilder: builder.	dropSourceCallbacks == nil		ifFalse: 			[lv controller dragDropCallbacks: dropSourceCallbacks.			lv controller selectOnDownWithDrag: spec selectOnDownIfDragEnabled].	builder component: lv.	self manufactureGeneralWrapperFor: spec into: builder.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>implementation classes</category><body package="UIBuilder-Support" selector="columnedListViewClass">columnedListViewClass	^JunColumnedListView</body><body package="UIBuilder-Support" selector="columnedMultiSelectionListViewClass">columnedMultiSelectionListViewClass	^JunColumnedListMultiSelectionView</body><body package="UIBuilder-Support" selector="compliantColumnedMultiSelectControllerClass">compliantColumnedMultiSelectControllerClass	^JunColumnedListEmulatedController</body></methods><class><name>JunWglInterface</name><environment>Jun</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Jun.JunWglInterfaceDictionary.*			</imports><category>Jun-OpenGL-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>opengl32.dll</item> <item>glu32.dll</item> <item>gdi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Jun</package></attributes></class><methods><class-id>Jun.JunWglInterface</class-id> <category>procedures-wglext</category><body package="Jun" selector="wglGetProcAddressOfWglChoosePixelFormatARB:">wglGetProcAddressOfWglChoosePixelFormatARB: arg	&lt;C: PFNWGLCHOOSEPIXELFORMATARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglCreatePbufferARB:">wglGetProcAddressOfWglCreatePbufferARB: arg	&lt;C: PFNWGLCREATEPBUFFERARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglDestroyPbufferARB:">wglGetProcAddressOfWglDestroyPbufferARB: arg	&lt;C: PFNWGLDESTROYPBUFFERARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglGetExtensionsStringARB:">wglGetProcAddressOfWglGetExtensionsStringARB: arg	&lt;C: PFNWGLGETEXTENSIONSSTRINGARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglGetPbufferDCARB:">wglGetProcAddressOfWglGetPbufferDCARB: arg	&lt;C: PFNWGLGETPBUFFERDCARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglGetPixelFormatAttribfvARB:">wglGetProcAddressOfWglGetPixelFormatAttribfvARB: arg	&lt;C: PFNWGLGETPIXELFORMATATTRIBFVARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglGetPixelFormatAttribivARB:">wglGetProcAddressOfWglGetPixelFormatAttribivARB: arg	&lt;C: PFNWGLGETPIXELFORMATATTRIBIVARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglQueryPbufferARB:">wglGetProcAddressOfWglQueryPbufferARB: arg	&lt;C: PFNWGLQUERYPBUFFERARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body><body package="Jun" selector="wglGetProcAddressOfWglReleasePbufferDCARB:">wglGetProcAddressOfWglReleasePbufferDCARB: arg	&lt;C: PFNWGLRELEASEPBUFFERDCARBPROC  __stdcall  wglGetProcAddress(LPCSTR)&gt;	^self externalAccessFailed</body></methods><class><name>ProgramManager</name><environment>KSU</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>KSU-System</category><attributes><package>KSU-System</package></attributes></class><comment><class-id>KSU.ProgramManager</class-id><body>Copyright 2008-2012 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><class><name>Example</name><environment>KSU</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>KSU-Example</package></attributes></class><comment><class-id>KSU.Example</class-id><body>Copyright 2008-2012 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><class><name>ProgramManager</name><environment>SSK</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SSK-System</category><attributes><package>SSK-System</package></attributes></class><comment><class-id>SSK.ProgramManager</class-id><body>Copyright 2008-2011 SSK (Smalltalk Studies in Kyoto). All Right Reserved.</body></comment><class><name>TextDoclet</name><environment>KSU</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fromDirectory textFiles toDirectory htmlFiles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>KSU-Tool</package></attributes></class><comment><class-id>KSU.TextDoclet</class-id><body>Copyright 2008-2012 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><methods><class-id>KSU.TextDoclet</class-id> <category>generating</category><body package="KSU-Tool" selector="genarateHTMLs">genarateHTMLs	| aCollection theLength aString aLength aFilename |	aCollection := OrderedCollection new.	theLength := fromDirectory asString size.	textFiles do: 			[:each |			aString := each copyFrom: theLength + 2 to: each size.			aLength := aString asFilename extension size.			aString := aString copyFrom: 1 to: aString size - aLength.			aString := aString , '.html'.			aCollection add: aString.			Transcript				cr;				show: aString.			aFilename := toDirectory construct: aString.			self convert: each asFilename to: aFilename].	htmlFiles := aCollection asArray</body><body package="KSU-Tool" selector="genarateIndexHTML">genarateIndexHTML	| aCollection aFilename |	aCollection := OrderedCollection new.	htmlFiles do: 			[:each |			| pathCollection targetString |			pathCollection := each asFilename components asArray.			pathCollection := pathCollection copyFrom: 1 to: pathCollection size - 1.			targetString := (Filename splitExtension: each asFilename tail) first.			aCollection add: each -&gt; (Array with: pathCollection with: targetString)].	JunControlUtility		assert: 			[aFilename := toDirectory construct: 'index.html'.			(aFilename withEncoding: self class defaultEncoding) writeStream]		do: 			[:aStream |			aStream nextPutAll: (self headerString: 'Index').			aCollection with: (1 to: aCollection size)				do: 					[:each :no |					| aString theString |					aString := no printString.					aCollection size printString size - aString size timesRepeat: [aString := ' ' , aString].					aStream nextPutAll: '&lt;a name="line.'.					aStream nextPutAll: no printString.					aStream nextPutAll: '"&gt;'.					aStream nextPutAll: aString.					aStream nextPutAll: '&lt;/a&gt;: '.					theString := String new.					each value first do: 							[:it |							aString := JunStringUtility htmlCanonicalString: it , '.'.							aStream nextPutAll: aString.							theString := theString , aString].					aStream nextPutAll: '&lt;a name="'.					aStream nextPutAll: theString , each value last.					aStream nextPutAll: '" href="'.					aStream nextPutAll: each key.					aStream nextPutAll: '"&gt;'.					aString := JunStringUtility htmlCanonicalString: each value last.					aStream nextPutAll: aString.					aStream nextPutAll: '&lt;/a&gt;'.					aStream cr].			aStream nextPutAll: self footerString.			Transcript				cr;				nextPutAll: '(JunURL browse: ';				nextPutAll: aFilename asURI asString printString;				nextPutAll: ')';				flush]		ensure: [:aStream | aStream close]</body><body package="KSU-Tool" selector="generate">generate	Transcript		cr;		cr;		cr;		show: self class name , ' on ' , JunCalendarModel stringFromDate , ' at '					, JunCalendarModel stringFromTime.	self generateDirectories.	self genarateHTMLs.	self genarateIndexHTML</body><body package="KSU-Tool" selector="generateDirectories">generateDirectories	| aLength aString aFilename aDirectory |	self generateDirectory: toDirectory.	aLength := fromDirectory asString size.	textFiles do: 			[:each |			aString := each copyFrom: aLength + 2 to: each size.			aFilename := toDirectory construct: aString.			aDirectory := aFilename head asFilename.			self generateDirectory: aDirectory]</body><body package="KSU-Tool" selector="generateDirectory:">generateDirectory: targetDirectory	| aCollection aDirectory aString |	aCollection := OrderedCollection new.	aDirectory := targetDirectory.	aString := aDirectory asString.	[aString ~= aDirectory head] whileTrue: 			[aCollection addFirst: aDirectory.			aDirectory := (aString := aDirectory head) asFilename].	aCollection do: [:each | each exists ifFalse: [each makeDirectory]]</body></methods><methods><class-id>KSU.TextDoclet</class-id> <category>converting</category><body package="KSU-Tool" selector="convert:to:">convert: sourceFilename to: destinationFilename	| fromStream aCollection aString toStream aStream |	JunControlUtility		assert: 			[fromStream := (sourceFilename withEncoding: self class defaultEncoding) readStream.			aCollection := OrderedCollection new]		do: 			[Cursor read showWhile: 					[[fromStream atEnd not] whileTrue: 							[aString := JunStringUtility getLine: fromStream.							aCollection add: aString]]]		ensure: [fromStream close].	JunControlUtility		assert: [toStream := (destinationFilename withEncoding: self class defaultEncoding) writeStream]		do: 			[Cursor write showWhile: 					[toStream nextPutAll: (self headerString: (Filename splitExtension: destinationFilename tail) first).					aCollection with: (1 to: aCollection size)						do: 							[:each :no |							aString := no printString.							aCollection size printString size - aString size timesRepeat: [aString := ' ' , aString].							toStream nextPutAll: '&lt;a name="line.'.							toStream nextPutAll: no printString.							toStream nextPutAll: '"&gt;'.							toStream nextPutAll: aString.							toStream nextPutAll: '&lt;/a&gt;: '.							aString := JunStringUtility htmlCanonicalString: each.							aStream := String new writeStream.							aString do: 									[:aCharacter |									aCharacter = Character tab										ifTrue: [self class defaultTabStop timesRepeat: [aStream nextPut: Character space]]										ifFalse: [aStream nextPut: aCharacter]].							aString := aStream contents.							toStream nextPutAll: aString].					toStream nextPutAll: self footerString]]		ensure: [toStream close]</body><body package="KSU-Tool" selector="footerString">footerString	^'&lt;/pre&gt;&lt;hr&gt;&lt;p&gt;This document was generated by '		, self class fullName		, ' on ' , JunCalendarModel stringFromDate		, ' at ' , JunCalendarModel stringFromTime		, '.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</body><body package="KSU-Tool" selector="headerString:">headerString: titleString	^'&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html lang="ja"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;meta http-equiv="Content-Style-Type" content="text/css"&gt;&lt;link rev="made" href="http://www.cc.kyoto-su.ac.jp/~atsushi/"&gt;&lt;link rel="index" href="index.html"&gt;&lt;style type="text/css"&gt;&lt;!--body {     background-color : #ffffff;     margin : 20px;     padding : 10px;     font-family : serif;     font-size : 10pt;}--&gt;&lt;/style&gt;&lt;title&gt;'		, titleString , '&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;'</body></methods><methods><class-id>KSU.TextDoclet</class-id> <category>private</category><body package="KSU-Tool" selector="fromDirectory:textFiles:toDirectory:">fromDirectory: sourceDirectory textFiles: fileCollection toDirectory: destinationDirectory	fromDirectory := sourceDirectory.	textFiles := fileCollection.	toDirectory := destinationDirectory</body></methods><class><name>TextDoclet</name><environment>SSK</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fromDirectory textFiles toDirectory htmlFiles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SSK-Tool</package></attributes></class><comment><class-id>SSK.TextDoclet</class-id><body>Copyright 2008-2011 SSK (Smalltalk Studies in Kyoto). All Right Reserved.</body></comment><methods><class-id>SSK.TextDoclet</class-id> <category>generating</category><body package="SSK-Tool" selector="genarateHTMLs">genarateHTMLs	| aCollection theLength aString aLength aFilename |	aCollection := OrderedCollection new.	theLength := fromDirectory asString size.	textFiles do: 			[:each |			aString := each copyFrom: theLength + 2 to: each size.			aLength := aString asFilename extension size.			aString := aString copyFrom: 1 to: aString size - aLength.			aString := aString , '.html'.			aCollection add: aString.			Transcript				cr;				show: aString.			aFilename := toDirectory construct: aString.			self convert: each asFilename to: aFilename].	htmlFiles := aCollection asArray</body><body package="SSK-Tool" selector="genarateIndexHTML">genarateIndexHTML	| aCollection aFilename |	aCollection := OrderedCollection new.	htmlFiles do: 			[:each |			| pathCollection targetString |			pathCollection := each asFilename components asArray.			pathCollection := pathCollection copyFrom: 1 to: pathCollection size - 1.			targetString := (Filename splitExtension: each asFilename tail) first.			aCollection add: each -&gt; (Array with: pathCollection with: targetString)].	JunControlUtility		assert: 			[aFilename := toDirectory construct: 'index.html'.			(aFilename withEncoding: self class defaultEncoding) writeStream]		do: 			[:aStream |			aStream nextPutAll: (self headerString: 'Index').			aCollection with: (1 to: aCollection size)				do: 					[:each :no |					| aString theString |					aString := no printString.					aCollection size printString size - aString size timesRepeat: [aString := ' ' , aString].					aStream nextPutAll: '&lt;a name="line.'.					aStream nextPutAll: no printString.					aStream nextPutAll: '"&gt;'.					aStream nextPutAll: aString.					aStream nextPutAll: '&lt;/a&gt;: '.					theString := String new.					each value first do: 							[:it |							aString := JunStringUtility htmlCanonicalString: it , '.'.							aStream nextPutAll: aString.							theString := theString , aString].					aStream nextPutAll: '&lt;a name="'.					aStream nextPutAll: theString , each value last.					aStream nextPutAll: '" href="'.					aStream nextPutAll: each key.					aStream nextPutAll: '"&gt;'.					aString := JunStringUtility htmlCanonicalString: each value last.					aStream nextPutAll: aString.					aStream nextPutAll: '&lt;/a&gt;'.					aStream cr].			aStream nextPutAll: self footerString.			Transcript				cr;				nextPutAll: '(JunURL browse: ';				nextPutAll: aFilename asURI asString printString;				nextPutAll: ')';				flush]		ensure: [:aStream | aStream close]</body><body package="SSK-Tool" selector="generate">generate	Transcript		cr;		cr;		cr;		show: self class name , ' on ' , JunCalendarModel stringFromDate , ' at '					, JunCalendarModel stringFromTime.	self generateDirectories.	self genarateHTMLs.	self genarateIndexHTML</body><body package="SSK-Tool" selector="generateDirectories">generateDirectories	| aLength aString aFilename aDirectory |	self generateDirectory: toDirectory.	aLength := fromDirectory asString size.	textFiles do: 			[:each |			aString := each copyFrom: aLength + 2 to: each size.			aFilename := toDirectory construct: aString.			aDirectory := aFilename head asFilename.			self generateDirectory: aDirectory]</body><body package="SSK-Tool" selector="generateDirectory:">generateDirectory: targetDirectory	| aCollection aDirectory aString |	aCollection := OrderedCollection new.	aDirectory := targetDirectory.	aString := aDirectory asString.	[aString ~= aDirectory head] whileTrue: 			[aCollection addFirst: aDirectory.			aDirectory := (aString := aDirectory head) asFilename].	aCollection do: [:each | each exists ifFalse: [each makeDirectory]]</body></methods><methods><class-id>SSK.TextDoclet</class-id> <category>converting</category><body package="SSK-Tool" selector="convert:to:">convert: sourceFilename to: destinationFilename	| fromStream aCollection aString toStream aStream |	JunControlUtility		assert: 			[fromStream := (sourceFilename withEncoding: self class defaultEncoding) readStream.			aCollection := OrderedCollection new]		do: 			[Cursor read showWhile: 					[[fromStream atEnd not] whileTrue: 							[aString := JunStringUtility getLine: fromStream.							aCollection add: aString]]]		ensure: [fromStream close].	JunControlUtility		assert: [toStream := (destinationFilename withEncoding: self class defaultEncoding) writeStream]		do: 			[Cursor write showWhile: 					[toStream nextPutAll: (self headerString: (Filename splitExtension: destinationFilename tail) first).					aCollection with: (1 to: aCollection size)						do: 							[:each :no |							aString := no printString.							aCollection size printString size - aString size timesRepeat: [aString := ' ' , aString].							toStream nextPutAll: '&lt;a name="line.'.							toStream nextPutAll: no printString.							toStream nextPutAll: '"&gt;'.							toStream nextPutAll: aString.							toStream nextPutAll: '&lt;/a&gt;: '.							aString := JunStringUtility htmlCanonicalString: each.							aStream := String new writeStream.							aString do: 									[:aCharacter |									aCharacter = Character tab										ifTrue: [self class defaultTabStop timesRepeat: [aStream nextPut: Character space]]										ifFalse: [aStream nextPut: aCharacter]].							aString := aStream contents.							toStream nextPutAll: aString].					toStream nextPutAll: self footerString]]		ensure: [toStream close]</body><body package="SSK-Tool" selector="footerString">footerString	^'&lt;/pre&gt;&lt;hr&gt;&lt;p&gt;This document was generated by '		, self class fullName		, ' on ' , JunCalendarModel stringFromDate		, ' at ' , JunCalendarModel stringFromTime		, '.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</body><body package="SSK-Tool" selector="headerString:">headerString: titleString	^'&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html lang="ja"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;meta http-equiv="Content-Style-Type" content="text/css"&gt;&lt;link rev="made" href="http://www.cc.kyoto-su.ac.jp/~atsushi/"&gt;&lt;link rel="index" href="index.html"&gt;&lt;style type="text/css"&gt;&lt;!--body {     background-color : #ffffff;     margin : 20px;     padding : 10px;     font-family : serif;     font-size : 10pt;}--&gt;&lt;/style&gt;&lt;title&gt;'		, titleString , '&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;'</body></methods><methods><class-id>SSK.TextDoclet</class-id> <category>private</category><body package="SSK-Tool" selector="fromDirectory:textFiles:toDirectory:">fromDirectory: sourceDirectory textFiles: fileCollection toDirectory: destinationDirectory	fromDirectory := sourceDirectory.	textFiles := fileCollection.	toDirectory := destinationDirectory</body></methods><class><name>Example</name><environment>SSK</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SSK-Example</package></attributes></class><comment><class-id>SSK.Example</class-id><body>Copyright 2008-2011 SSK (Smalltalk Studies in Kyoto). All Right Reserved.</body></comment><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Users/aoki/Desktop/VisualWorks78ncWithJun793ForMac/VisualWorksWithJun/visualnc.im' 'September 4, 2012' '9:41:14 PM')""An image file /Users/aoki/Desktop/VisualWorks78ncWithJun793ForMac/VisualWorksWithJun/visualnc.im was created at 21:41:14 on 2012年9月4日."</do-it><do-it>| sourceCodeString scanTokens |sourceCodeString := '            | aaa bbb ccc ddd |            aaa := 10.            bbb := 20.            ccc := 30.            ddd := aaa + (bbb * ccc).            ^ddd        '.scanTokens := Scanner new scanTokens: sourceCodeString.Transcript clear.scanTokens    do: [:scanToken | Transcript show: scanToken printString]    separatedBy: [Transcript space].^scanTokens</do-it><do-it>| sourceCodeString methodNodeHolder parseTree |sourceCodeString := '            | aaa bbb ccc ddd |            aaa := 10.            bbb := 20.            ccc := 30.            ddd := aaa + (bbb * ccc).            ^ddd        '.methodNodeHolder := Compiler new    parseNoPattern: sourceCodeString readStream    in: Object    notifying: nil.parseTree := JunParseTree    node: methodNodeHolder node    class: Object    code: sourceCodeString.parseTree show.^parseTree</do-it><do-it>| sourceCodeString methodNodeHolder parseTree |sourceCodeString := '            | aaa bbb ccc ddd |            aaa := 10.            bbb := 20.            ccc := 30.            ddd := aaa + (bbb * ccc) - 5.            ^ddd        '.methodNodeHolder := Compiler new    parseNoPattern: sourceCodeString readStream    in: Object    notifying: nil.parseTree := JunParseTree    node: methodNodeHolder node    class: Object    code: sourceCodeString.parseTree show.^parseTree</do-it><do-it>| sourceCodeString methodNodeHolder compiledMethod byteCodes |sourceCodeString := '            | aaa bbb ccc ddd |            aaa := 10.            bbb := 20.            ccc := 30.            ddd := aaa + (bbb * ccc).            ^ddd        '.methodNodeHolder := Compiler new    parseNoPattern: sourceCodeString readStream    in: Object    notifying: nil.compiledMethod := methodNodeHolder generate.byteCodes := compiledMethod bytes.Transcript clear.byteCodes    do: [:byteCode | Transcript show: (byteCode printStringRadix: 16)]    separatedBy: [Transcript space].^byteCodes</do-it><do-it>| sourceCodeString methodNodeHolder compiledMethod symbolicCodes |sourceCodeString := '            | aaa bbb ccc ddd |            aaa := 10.            bbb := 20.            ccc := 30.            ddd := aaa + (bbb * ccc).            ^ddd        '.methodNodeHolder := Compiler new    parseNoPattern: sourceCodeString readStream    in: Object    notifying: nil.compiledMethod := methodNodeHolder generate.symbolicCodes := compiledMethod symbolic.Transcript clear.Transcript show: symbolicCodes.^symbolicCodes</do-it><do-it>| sourceCodeString methodNodeHolder compiledMethod symbolicCodes |sourceCodeString := '            ^10 + (20 * 30)        '.methodNodeHolder := Compiler new    parseNoPattern: sourceCodeString readStream    in: Object    notifying: nil.compiledMethod := methodNodeHolder generate.symbolicCodes := compiledMethod symbolic.Transcript clear.Transcript show: symbolicCodes.^symbolicCodes</do-it><component-property><name>KSU</name> <type>bundle</type><property>comment</property> <value>'Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.'</value></component-property><component-created><name>KSU-Template</name> <type>package</type></component-created><component-property><name>KSU-Template</name> <type>package</type><property>comment</property> <value>'Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.'</value></component-property><bundle-structure><name>KSU</name> <structure>#(#(#package 'KSU-System') #(#package 'KSU-Example') #(#package 'KSU-Tool') #(#package 'KSU-Template'))</structure></bundle-structure><bundle-structure><name>KSU</name> <structure>#(#(#package 'KSU-System') #(#package 'KSU-Example') #(#package 'KSU-Tool') #(#package 'KSU-Template'))</structure></bundle-structure><comment><name-space-id>KSU</name-space-id><body>Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><class><name>WhatTime</name><environment>KSU</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputMode showDate showWeekday showSeconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>KSU-Template</category><attributes><package>KSU-Template</package></attributes></class><comment><class-id>KSU.WhatTime</class-id><body>Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><methods><class-id>KSU.WhatTime class</class-id> <category>interface specs</category><body package="KSU-Template" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'ボタンたち' 			#min: #(#{Core.Point} 400 220 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1079 610 1479 830 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #() ) )</body></methods><methods><class-id>KSU.WhatTime class</class-id> <category>examples</category><body package="KSU-Template" selector="example1">example1	"KSU.WhatTime example1."	| anApplication |	anApplication := KSU.WhatTime new.	anApplication open.	^anApplication</body></methods><methods><class-id>KSU.WhatTime class</class-id> <category>resources</category><body package="KSU-Template" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'ファイル' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '終了' 							#value: #closeRequest ) ) #(1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>KSU.WhatTime</class-id> <category>aspects</category><body package="KSU-Template" selector="showDate">showDate	showDate ifNil: [showDate := false asValue].	^showDate</body></methods><methods><class-id>KSU.WhatTime</class-id> <category>aspects</category><body package="KSU-Template" selector="showSeconds">showSeconds	showSeconds ifNil: [showSeconds := false asValue].	^showSeconds</body></methods><methods><class-id>KSU.WhatTime</class-id> <category>aspects</category><body package="KSU-Template" selector="showWeekday">showWeekday	showWeekday ifNil: [showWeekday := false asValue].	^showWeekday</body></methods><methods><class-id>KSU.WhatTime</class-id> <category>aspects</category><body package="KSU-Template" selector="outputMode">outputMode	outputMode ifNil: [outputMode := 'トランスクリプト' asValue].	^outputMode</body></methods><methods><class-id>KSU.WhatTime</class-id> <category>actions</category><body package="KSU-Template" selector="tellTime">tellTime	"KSU.WhatTime new tellTime."	| aTime aDate aStream aString |	aTime := Time now.	aDate := Date today.	aStream := String new writeStream.	self showDate value		ifTrue: 			[aStream				nextPutAll: aDate year printString;				nextPutAll: '年';				nextPutAll: aDate monthIndex printString;				nextPutAll: '月';				nextPutAll: aDate dayOfMonth printString;				nextPutAll: '日'].	self showWeekday value		ifTrue: 			[aStream				nextPutAll: '(';				nextPutAll: (#('月' '火' '水' '木' '金' '土' '日') at: aDate weekdayIndex);				nextPutAll: ')'].	aStream		nextPutAll: aTime hours printString;		nextPutAll: '時';		nextPutAll: aTime minutes printString;		nextPutAll: '分'.	self showSeconds value		ifTrue: 			[aStream				nextPutAll: aTime seconds printString;				nextPutAll: '秒'].	aString := aStream contents.	aStream close.	self outputMode value = 'トランスクリプト'		ifTrue: 			[Transcript				cr;				show: aString]		ifFalse: [Dialog warn: aString]</body></methods><methods><class-id>KSU.WhatTime</class-id> <category>initialize-release</category><body package="KSU-Template" selector="initialize">initialize	super initialize.	outputMode := nil.	showDate := nil.	showWeekday := nil.	showSeconds := nil.	^self</body></methods><do-it>| aCollection |(aCollection := OrderedCollection new)	add: #url: -&gt; 'http://www.cc.kyoto-su.ac.jp/~atsushi/Programs/WhatTime/WhatTime.st';	add: #comment: -&gt; 'Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.';	add: #bundle: -&gt; #KSU;	add: #package: -&gt; 'KSU-Template';	add: #nameSpace: -&gt; #KSU;	add: #category: -&gt; 'KSU-Template';	add: #class: -&gt; #{KSU.WhatTime};	add: #protocol: -&gt; #examples;	add: #selector: -&gt; #example1;	add: #execute: -&gt; [#{KSU.WhatTime} value example1];	yourself.JunSystem	perform: ((aCollection collect: [:each | each key]) inject: String new			into: [:selector :key | selector , key]) asSymbol	withArguments: (aCollection collect: [:each | each value]) asArray</do-it><methods><class-id>KSU.WhatTime class</class-id> <category>interface specs</category><body package="KSU-Template" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'ボタンたち' 			#min: #(#{Core.Point} 400 220 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 760 489 1160 709 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 128 40 266 56 ) 					#name: #tellTime 					#label: 'いま何時かしら？' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 88 ) 					#name: #showDate 					#label: '日付' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 128 ) 					#name: #showWeekday 					#label: '曜日' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 168 ) 					#name: #showSeconds 					#label: '秒' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 208 112 ) 					#name: #dialog 					#label: 'ダイアログ' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 208 152 ) 					#name: #transcript 					#label: 'トランスクリプト' ) ) ) )</body></methods><do-it>KSU.WhatTime example1.</do-it><methods><class-id>KSU.WhatTime class</class-id> <category>interface specs</category><body package="KSU-Template" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'ボタンたち' 			#min: #(#{Core.Point} 400 220 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 760 490 1160 710 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 128 40 266 56 ) 					#name: #tellTime 					#model: #tellTime 					#label: 'いま何時かしら？' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 88 ) 					#name: #showDate 					#label: '日付' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 128 ) 					#name: #showWeekday 					#label: '曜日' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 168 ) 					#name: #showSeconds 					#label: '秒' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 208 112 ) 					#name: #dialog 					#label: 'ダイアログ' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 208 152 ) 					#name: #transcript 					#label: 'トランスクリプト' ) ) ) )</body></methods><do-it>KSU.WhatTime example1.</do-it><methods><class-id>KSU.WhatTime class</class-id> <category>interface specs</category><body package="KSU-Template" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'ボタンたち' 			#min: #(#{Core.Point} 400 220 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 760 490 1160 710 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 128 40 266 56 ) 					#name: #tellTime 					#model: #tellTime 					#label: 'いま何時かしら？' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 88 ) 					#name: #showDate 					#model: #showDate 					#label: '日付' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 128 ) 					#name: #showWeekday 					#model: #showWeekday 					#label: '曜日' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 88 168 ) 					#name: #showSeconds 					#model: #showSeconds 					#label: '秒' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 208 112 ) 					#name: #dialog 					#model: #outputMode 					#label: 'ダイアログ' 					#select: 'ダイアログ' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 208 152 ) 					#name: #transcript 					#model: #outputMode 					#label: 'トランスクリプト' 					#select: 'トランスクリプト' ) ) ) )</body></methods><do-it>KSU.WhatTime example1.</do-it><do-it>KSU.ProgramManager save.</do-it><component-property><name>KSU</name> <type>bundle</type><property>comment</property> <value>'Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.'</value></component-property><component-created><name>KSU-Template</name> <type>package</type></component-created><component-property><name>KSU-Template</name> <type>package</type><property>comment</property> <value>'Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.'</value></component-property><bundle-structure><name>KSU</name> <structure>#(#(#package 'KSU-System') #(#package 'KSU-Example') #(#package 'KSU-Tool') #(#package 'KSU-Template'))</structure></bundle-structure><bundle-structure><name>KSU</name> <structure>#(#(#package 'KSU-System') #(#package 'KSU-Example') #(#package 'KSU-Tool') #(#package 'KSU-Template'))</structure></bundle-structure><comment><name-space-id>KSU</name-space-id><body>Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><component-property><name>KSU-Template</name> <type>package</type><property>comment</property> <value>'Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.'</value></component-property><class><name>ColorCMY</name><environment>KSU</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cyanGauge magentaGauge yellowGauge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>KSU-Template</category><attributes><package>KSU-Template</package></attributes></class><comment><class-id>KSU.ColorCMY</class-id><body>Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.</body></comment><methods><class-id>KSU.ColorCMY class</class-id> <category>interface specs</category><body package="KSU-Template" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '減法混色' 			#min: #(#{Core.Point} 512 160 ) 			#max: #(#{Core.Point} 512 160 ) 			#bounds: #(#{Graphics.Rectangle} 1023 719 1535 879 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #() ) )</body></methods><methods><class-id>KSU.ColorCMY class</class-id> <category>examples</category><body package="KSU-Template" selector="example1">example1	"KSU.ColorCMY example1."	| anApplication |	anApplication := KSU.ColorCMY new.	anApplication open.	^anApplication</body></methods><methods><class-id>KSU.ColorCMY class</class-id> <category>resources</category><body package="KSU-Template" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'ファイル' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '終了' 							#value: #closeRequest ) ) #(1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>aspects</category><body package="KSU-Template" selector="yellowGauge">yellowGauge	yellowGauge		ifNil: 			[yellowGauge := 0.5 asValue.			yellowGauge compute: [:aValue | self updateColorYellow: aValue]].	^yellowGauge</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>aspects</category><body package="KSU-Template" selector="cyanGauge">cyanGauge	cyanGauge		ifNil: 			[cyanGauge := 0.5 asValue.			cyanGauge compute: [:aValue | self updateColorCyan: aValue]].	^cyanGauge</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>aspects</category><body package="KSU-Template" selector="magentaGauge">magentaGauge	magentaGauge		ifNil: 			[magentaGauge := 0.5 asValue.			magentaGauge compute: [:aValue | self updateColorMagenta: aValue]].	^magentaGauge</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>accessing</category><body package="KSU-Template" selector="color">color	| aColor |	aColor := ColorValue				cyan: (0 max: (self cyanGauge value min: 1))				magenta: (0 max: (self magentaGauge value min: 1))				yellow: (0 max: (self yellowGauge value min: 1)).	^aColor</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>private</category><body package="KSU-Template" selector="updateColor">updateColor	self builder		ifNotNil: 			[:aBuilder |			aBuilder window				ifNotNil: 					[:aWindow |					aWindow						background: self color;						display]]</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>private</category><body package="KSU-Template" selector="updateColorCyan:">updateColorCyan: aValue	InputState default altDown		ifTrue: 			[self magentaGauge value = aValue ifFalse: [self magentaGauge value: aValue].			self yellowGauge value = aValue ifFalse: [self yellowGauge value: aValue]].	self updateColor</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>private</category><body package="KSU-Template" selector="updateColorYellow:">updateColorYellow: aValue	InputState default altDown		ifTrue: 			[self cyanGauge value = aValue ifFalse: [self cyanGauge value: aValue].			self magentaGauge value = aValue ifFalse: [self magentaGauge value: aValue]].	self updateColor</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>private</category><body package="KSU-Template" selector="updateColorMagenta:">updateColorMagenta: aValue	InputState default altDown		ifTrue: 			[self cyanGauge value = aValue ifFalse: [self cyanGauge value: aValue].			self yellowGauge value = aValue ifFalse: [self yellowGauge value: aValue]].	self updateColor</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>interface opening</category><body package="KSU-Template" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self updateColor</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>initialize-release</category><body package="KSU-Template" selector="initialize">initialize	super initialize.	cyanGauge := nil.	magentaGauge := nil.	yellowGauge := nil.	^self</body></methods><do-it>| aCollection |(aCollection := OrderedCollection new)    add: #url: -&gt; 'http://www.cc.kyoto-su.ac.jp/~atsushi/Programs/ColorCMY/ColorCMY.st';    add: #comment: -&gt; 'Copyright 2008-2011 KSU (Kyoto Sangyo University). All Right Reserved.';    add: #bundle: -&gt; #KSU;    add: #package: -&gt; 'KSU-Template';    add: #nameSpace: -&gt; #KSU;    add: #category: -&gt; 'KSU-Template';    add: #class: -&gt; #{KSU.ColorCMY};    add: #protocol: -&gt; #examples;    add: #selector: -&gt; #example1;    add: #execute: -&gt; [#{KSU.ColorCMY} value example1];    yourself.JunSystem    perform: ((aCollection collect: [:each | each key]) inject: String new            into: [:selector :key | selector , key]) asSymbol    withArguments: (aCollection collect: [:each | each value]) asArray</do-it><methods><class-id>KSU.ColorCMY class</class-id> <category>interface specs</category><body package="KSU-Template" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '減法混色' 			#min: #(#{Core.Point} 512 160 ) 			#max: #(#{Core.Point} 512 160 ) 			#bounds: #(#{Graphics.Rectangle} 732 674 1244 834 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 40 28 ) 					#name: #cyanLabel 					#label: 'シアン　：' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 40 64 ) 					#name: #magentaLabel 					#label: 'マゼンタ：' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 40 104 ) 					#name: #yellowLabel 					#label: 'イエロー：' ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 104 25 204 47 ) 					#name: #cyanGauge 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6143 8191 8191 ) ) 					#model: #cyanGauge 					#alignment: #center 					#type: #number 					#low: 0 					#high: 1 					#interval: 0.01 ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 104 65 204 87 ) 					#name: #magentaGauge 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 6143 8191 ) ) 					#model: #magentaGauge 					#alignment: #center 					#type: #number 					#low: 0 					#high: 1 					#interval: 0.01 ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.Rectangle} 104 105 204 127 ) 					#name: #yellowGauge 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 8191 6143 ) ) 					#model: #yellowGauge 					#alignment: #center 					#type: #number 					#low: 0 					#high: 1 					#interval: 0.01 ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.Rectangle} 224 -15 496 88 ) 					#name: #cyanPercent 					#isOpaque: true 					#model: #cyanGauge 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.Rectangle} 224 17 496 128 ) 					#name: #magentaPercent 					#isOpaque: true 					#model: #magentaGauge 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) 				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.Rectangle} 224 72 496 157 ) 					#name: #yellowPercent 					#isOpaque: true 					#model: #yellowGauge 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) ) ) )</body></methods><do-it>KSU.ColorCMY example1.</do-it><do-it>KSU.ColorCMY example1.</do-it><methods><class-id>KSU.ColorCMY class</class-id> <category>resources</category><body package="KSU-Template" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'ファイル' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '検査' 							#value: #Inspect ) 						#(#{UI.MenuItem} 							#rawLabel: '終了' 							#value: #closeRequest ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><do-it>KSU.ColorCMY example1.</do-it><methods><class-id>KSU.ColorCMY class</class-id> <category>resources</category><body package="KSU-Template" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'ファイル' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '検査' 							#value: #inspect ) 						#(#{UI.MenuItem} 							#rawLabel: '終了' 							#value: #closeRequest ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>KSU.ColorCMY</class-id> <category>accessing</category><body package="KSU-Template" selector="color">color	| aColor |	aColor := ColorValue				cyan: (0 max: (self cyanGauge value min: 1))				magenta: (0 max: (self magentaGauge value min: 1))				yellow: (0 max: (self yellowGauge value min: 1)).	^aColor</body></methods><do-it>KSU.ColorCMY example1.</do-it><do-it>ObjectMemory allObjects</do-it><do-it>KSU.ColorCMY example1.</do-it><do-it>ObjectMemory allObjects</do-it><do-it>self select: [ :anObject | anObject class = KSU.ColorCMY]</do-it><do-it>self select: [ :anObject | anObject class = KSU.ColorCMY]</do-it><do-it>self cyanGauge value: 1.0</do-it><do-it>self cyanGauge value: 1.0</do-it>