<?xml version="1.0"?><st-source><!-- Name: Tools-HoverHelpNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: Allows Views to provide StateMachine based Hover Help windows.DbIdentifier: bear73DbTrace: 115786DevelopmentPrerequisites: #(#(#any 'Interface-Announcements' '') #(#any 'Tools-State Machine' ''))PackageName: Tools-HoverHelpParcel: #('Tools-HoverHelp')ParcelName: Tools-HoverHelpPrintStringCache: (7.5.1 dec07.2 - 1,bobw)Version: 7.6Pre-Unload Block: 	[:package | 	HoverHelpAssistant allGeneralInstances		do: [ :each | each uninstall ] ]Date: 9:41:47 pm March 3, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 8, 2008 on March 3, 2008 at 9:41:47 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HelpInterrupted</name><environment>UI</environment><super>UI.VisualPartAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Announcements</category><attributes><package>Tools-HoverHelp</package></attributes></class><comment><class-id>UI.HelpInterrupted</class-id><body>I am announced when the HoverHelp system detects any mouse click which should interrupt a help armed state or cancel a currently open HoverHelpWindow.</body></comment><class><name>HoverHelpWindow</name><environment>UI</environment><super>UI.TransientWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current targetView lastCloseTime </class-inst-vars><imports></imports><category>Tools-HoverHelp</category><attributes><package>Tools-HoverHelp</package></attributes></class><comment><class-id>UI.HoverHelpWindow</class-id><body>HoverHelpWindow implements a singleton reusable instance of a hover help window.  We keep track of the latest hover help window close time so that the TooltipAssistant can avoid the initial delay to open its tooltip when tooltips for other widgets have already opened.  Under normal mouse movement, this would include such things as neighboring toolbar widgets or overlays on list items.  It does not hurt that with very fast mouse movement this delay avoidance will apply to all hover help popups within the application window.HoverHelp consumers that implement a delay before the help window initially opens, must install the view using reserveFor: as soon as the state machine enters its delay.  Otherwise we will are unable to interrupt the state machine delay and hover help windows can pop up and steal focus from the current window.Class Instance Variables:	current	&lt;HoverHelpWindow&gt;	the singleton window	targetView	&lt;View&gt; the view associated with the currently open hover help window	lastCloseTime 	&lt;Time&gt;	the time in milliseconds when the last hover help window was recycled (closed), or nil</body></comment><class><name>HoverHelpAssistant</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>view stateMachine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-HoverHelp</category><attributes><package>Tools-HoverHelp</package></attributes></class><comment><class-id>UI.HoverHelpAssistant</class-id><body>HoverHelpAssistant is the abstract superclass for hover help suppliers.Subclasses must implement the following messages:	initialize-release		initializeInstance Variables:	view	&lt;VisualPart&gt;	the view with which the hover help content is associated</body></comment><class><name>HoverHelpSensor</name><environment>UI</environment><super>UI.EventSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-HoverHelp</category><attributes><package>Tools-HoverHelp</package></attributes></class><comment><class-id>UI.HoverHelpSensor</class-id><body>HoverHelpSensor detects certain keyboard events which must be passed to the parent window.</body></comment><class><name>TooltipAssistant</name><environment>UI</environment><super>UI.HoverHelpAssistant</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tooltip </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-HoverHelp</category><attributes><package>Tools-HoverHelp</package></attributes></class><comment><class-id>UI.TooltipAssistant</class-id><body>TooltipAssistant implements a standard hover help window for a View.The stateMachine for this assistant consists of three states:	cold - not hovering over a view, or not displaying tooltip content	armed - hovering over a view which can display tooltip content	reaper - displaying the tooltip contentThere are four asynchronous inputs which may drive changes from one state to the next:	FrameEntered - An Announcement we get from our view when it becomes the currentMouseConsumer	FrameExited - An Announcement we get from our view when it ceases to be the currentMouseConsumer	HelpInterrupted - An Announcement we synthesize when we get any kind of UI interaction that indicates we're not just sitting around reading tooltips	&lt;timeout&gt; - This is not an announcement, but some of the states have actions that occur after a delay if nothing else happens.We move to the "armed" state when the mouse enters a view that has a tooltip to display.  If we linger in that state for longer than 800 ms, the tooltip opens and we enter the "reaper" state wherein there is an open tooltip.  We return to the "cold" state and remove the tooltip after a five second delay or when the mouse leaves the view. Instance Variables:	tooltip	&lt;BlockClosure | CharacterArray | UndefinedObject, VisualComponent&gt;	basically this is nil OR any object that responds to asTooltipGraphicFor:. See implementors of said message.If tooltip is a BlockClosure, it must be a single argument block which receives the associated View.</body></comment><methods><class-id>UI.HoverHelpWindow</class-id> <category>private</category><body package="Tools-HoverHelp" selector="sensorClass">sensorClass	^HoverHelpSensor</body><body package="Tools-HoverHelp" selector="tooltipDisplayBox">tooltipDisplayBox	"Preferentially align the left edge of the help window with the current mouse location and the top edge with the bottom of the mouse pointer box. Make sure the result fits the screen!"		| mouse extent origin |	mouse := self sensor state mousePoint.	extent := component preferredBounds extent.	origin := mouse + (0 @ 18).	origin y &gt; Screen default bounds bottom		ifTrue: [origin := mouse - (0 @ (2 + extent y))].	^Screen default makeRectangleVisible: (origin extent: extent)</body></methods><methods><class-id>UI.HoverHelpWindow</class-id> <category>testing</category><body package="Tools-HoverHelp" selector="canProcessEvent">canProcessEvent	^false</body><body package="Tools-HoverHelp" selector="isInvalid">isInvalid	^component isNil or: [handle isNil]</body></methods><methods><class-id>UI.HoverHelpWindow</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="label">label	^(#HoverHelp &lt;&lt; #dialogs &gt;&gt; 'HoverHelp')</body><body package="Tools-HoverHelp" selector="targetController">targetController	"Answer the controller of the window whose widget I am serving, 	or nil if it cannot be determined."	^self class targetView ifNotNil: [ :target | target controller ]</body><body package="Tools-HoverHelp" selector="targetView">targetView	"Answer the widget I am serving, or nil if it cannot be determined."	^self class targetView</body><body package="Tools-HoverHelp" selector="targetWindowSensor">targetWindowSensor	"Answer the sensor of the window whose widget I am serving, 	or nil if it cannot be determined."	^ self targetController ifNotNil: [ :target | target sensor windowSensor ]</body></methods><methods><class-id>UI.HoverHelpWindow</class-id> <category>events</category><body package="Tools-HoverHelp" selector="windowEventDispatcher">windowEventDispatcher	^self</body></methods><methods><class-id>UI.HoverHelpWindow</class-id> <category>initialize-release</category><body package="Tools-HoverHelp" selector="recycle">recycle	component ifNotNil: [ self releaseComponent ].	mapped ifTrue: [ handle ifNotNil: [ self unmap ] ].	self unscheduleWindow.</body></methods><methods><class-id>UI.HoverHelpWindow</class-id> <category>opening/closing</category><body package="Tools-HoverHelp" selector="open">open	self		map;		scheduleWindow;		display.</body><body package="Tools-HoverHelp" selector="openTooltip:">openTooltip: aVisualGraphic	component ifNotNil: [ :part | part invalidateNow ].	self 			component: (CompositePart new add: aVisualGraphic in: (0@0 corner: 1@1));		displayBox: self tooltipDisplayBox.	component bounds: self bounds.	self open.</body></methods><methods><class-id>UI.HoverHelpWindow class</class-id> <category>instance creation</category><body package="Tools-HoverHelp" selector="current">current	(current isNil or: [ current isInvalid ]) ifTrue: [		current := self newIn: (0@0 extent: 1@1) withType: #popUp ].	^ current</body></methods><methods><class-id>UI.HoverHelpWindow class</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="targetView">targetView	^ targetView.</body></methods><methods><class-id>UI.HoverHelpWindow class</class-id> <category>testing</category><body package="Tools-HoverHelp" selector="isCloseRecent">isCloseRecent		^ lastCloseTime		ifNil: [ false ]		ifNotNil: [ Time millisecondClockValue - lastCloseTime &lt; 800 ].</body></methods><methods><class-id>UI.HoverHelpWindow class</class-id> <category>initialize-release</category><body package="Tools-HoverHelp" selector="recycle">recycle	"self recycle"	current ifNotNil: [ :fb | fb recycle ].	"Give focus back to the targetView's window, if it is still open, when this one closes."	targetView ifNotNil: [ 		targetView topComponent ifNotNil: [ :win | win isOpen ifTrue: [			win becomeActive ] ].		targetView := nil ].</body><body package="Tools-HoverHelp" selector="reset">reset	"self reset"	self recycle.	lastCloseTime := nil.	current := nil.</body></methods><methods><class-id>UI.HoverHelpWindow class</class-id> <category>opening/closing</category><body package="Tools-HoverHelp" selector="closeFor:">closeFor: anObject	targetView == anObject		ifTrue:			[self recycle.			lastCloseTime := Time millisecondClockValue].</body><body package="Tools-HoverHelp" selector="openTooltip:for:">openTooltip: aTooltipGraphic for: requestingView	"Open a tooltip with location relative to the current mouse position."	targetView := requestingView.	^ self current openTooltip: aTooltipGraphic.</body><body package="Tools-HoverHelp" selector="reserveFor:">reserveFor: anObject	"As soon as a state machine is active, ie. waiting for its delay timeout, even though the hover help window is not yet open, remember a potential HoverHelp consumer so its state machine can be interrupted."		targetView := anObject.</body><body package="Tools-HoverHelp" selector="unreserve">unreserve	"A state machine is no longer waiting for its delay timeout, and we will not need to interrupt it."		targetView := nil.</body></methods><methods><class-id>UI.HoverHelpWindow class</class-id> <category>announcements</category><body package="Tools-HoverHelp" selector="noticeInterruptEvent">noticeInterruptEvent	"Interrupt any active or pending help activity."	targetView ifNotNil: [ :target | target announceHelpInterrupted ].</body><body package="Tools-HoverHelp" selector="noticeMouseMoved:">noticeMouseMoved: aPoint	"The mouse has changed position.  Check if we should terminate any active or pending help activity."	self targetView ifNotNil: [ :aView |		(aView containsPoint: aPoint)			ifFalse: [ aView announceHelpInterrupted ] ].</body></methods><methods><class-id>UI.HoverHelpAssistant</class-id> <category>private</category><body package="Tools-HoverHelp" selector="buildStateMachine">buildStateMachine	"Establish the states and the required action block for each subscribed anouncement	 that requires a state transition."	^self subclassResponsibility</body><body package="Tools-HoverHelp" selector="log:">log: aString	"A handy little tool to debug state switches. All the key state transition methods throughout the class are instrumented to print an event log.	 Because that log is the easiest - if not the only - way to debug state transitions, if you don't need it, it is wiser to make this method a no-op rather than remove the instrumentation.	 Writing to the Transcript can fail at early stages of image startup, so the method has to protect against that."	"[Transcript		space;		show: aString printString]		on: Error		do: [:ex | ex return]"</body><body package="Tools-HoverHelp" selector="subscriptions">subscriptions	"Answer a collection of Announcement subclasses to which the assistant must subscribe on behalf of the VisualPart.	 Each subclass must override this method to provide the subscriptions required by its own part.  	 Some assistants may manage subscriptions only on behalf of other components, in which case this collection may simply be nil."	^ nil.</body><body package="Tools-HoverHelp" selector="uninstall">uninstall	view tooltip: nil.	stateMachine := nil.</body></methods><methods><class-id>UI.HoverHelpAssistant</class-id> <category>initialize-release</category><body package="Tools-HoverHelp" selector="initialize">initialize	self buildStateMachine.</body><body package="Tools-HoverHelp" selector="onView:">onView: aView	view := aView.	self subscriptions		ifNotNil: [:subs | stateMachine subscribeTo: subs from: view].</body><body package="Tools-HoverHelp" selector="release">release	view unsubscribe: stateMachine.	stateMachine release.	super release.</body></methods><methods><class-id>UI.HoverHelpAssistant class</class-id> <category>instance creation</category><body package="Tools-HoverHelp" selector="new">new	^super new initialize</body><body package="Tools-HoverHelp" selector="on:">on: aView	^self new onView: aView</body></methods><methods><class-id>UI.HoverHelpSensor</class-id> <category>event processing</category><body package="Tools-HoverHelp" selector="eventButtonPress:">eventButtonPress: event	"Mac requires this event to be explicitly redirected to the main window. 	 On other platforms mouse clicks are redirected by the VM but doing it explicitly does no harm."	[ self targetWindowSensor ifNotNil: [ :targetSensor | targetSensor eventButtonPress: event ] ]		on: Error		do: [ Transcript cr; show: 'HoverHelpSensor&gt;&gt;eventButtonPress:'; flush ].</body><body package="Tools-HoverHelp" selector="eventKeyPress:">eventKeyPress: event	"All keyboard events should go to the window I am serving	so the user typing while the help popup is open is not lost."	[ self targetWindowSensor ifNotNil: [ :targetSensor | targetSensor eventKeyPress: event ] ]		on: Error		do: [ Transcript cr; show: 'HoverHelpSensor&gt;&gt;eventKeyPress:'; flush ].</body><body package="Tools-HoverHelp" selector="eventKeyRelease:">eventKeyRelease: event	"All keyboard events should go to the window I am serving	so the user typing while the help popup is open is not lost."	[ self targetWindowSensor ifNotNil: [ :targetSensor | targetSensor eventKeyRelease: event ] ]		on: Error		do: [ Transcript cr; show: 'HoverHelpSensor&gt;&gt;eventKeyRelease:'; flush ].</body><body package="Tools-HoverHelp" selector="eventMouseMoved:">eventMouseMoved: event	"The event is not a MouseMovedEvent so we can't rely on the event's globalPoint."	[ HoverHelpWindow noticeMouseMoved: InputState default mousePoint. ]		on: Error		do: [ Transcript cr; show: 'HoverHelpSensor&gt;&gt;eventMouseMoved:'; flush ].</body></methods><methods><class-id>UI.HoverHelpSensor</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="targetWindowSensor">targetWindowSensor	"We only want to pass events along if the window is alive."	^ window ifNotNil: [ :win | 		(win isInvalid not and: [ win isOpen ])			ifTrue: [ win targetWindowSensor ]			ifFalse: [ nil ] ].</body></methods><methods><class-id>UI.TooltipAssistant</class-id> <category>private</category><body package="Tools-HoverHelp" selector="buildStateMachine">buildStateMachine		| coldState armedState reaperState |	stateMachine := StateMachine new.	"The first state defined becomes the initial state."	coldState := stateMachine newState: #cold.	armedState := stateMachine newState: #armed.	reaperState := stateMachine newState: #reaper.	coldState		on: FrameEntered			do: [self coldFrameEntered].	armedState		on: HelpInterrupted			do: [self armedHelpInterrupted];		on: FrameExited			do: [self armedFrameExited];		afterMilliseconds: 800			do: [self armedTimeout].	reaperState		on: HelpInterrupted			do: [self reaperHelpInterrupted];		on: FrameExited			do: [self reaperFrameExited];		afterMilliseconds: 5000			do: [self reaperTimeout].	stateMachine start.</body><body package="Tools-HoverHelp" selector="isMyWindowActive">isMyWindowActive		^view isOpen and: [view topComponent == Window currentWindow]</body><body package="Tools-HoverHelp" selector="reserveWindow">reserveWindow	HoverHelpWindow reserveFor: view.</body><body package="Tools-HoverHelp" selector="shouldOpenTooltipNow">shouldOpenTooltipNow		self log: (#shouldOpenNow, '=', HoverHelpWindow isCloseRecent printString).	^ HoverHelpWindow isCloseRecent.</body><body package="Tools-HoverHelp" selector="subscriptions">subscriptions	^ FrameEntered, FrameExited, HelpInterrupted.</body><body package="Tools-HoverHelp" selector="tooltipGraphic">tooltipGraphic		^ [ self tooltip ifNotNil: [:supplier | supplier asTooltipGraphicFor: view ] ]		on: Error		do: [ :ex | Transcript cr; show: (#errTooltipGraphic &lt;&lt; #dialogs &gt;&gt; 'Error building tooltipGraphic: &lt;1s&gt;'					expandMacrosWith: ex errorString); flush ].</body><body package="Tools-HoverHelp" selector="unreserveWindow">unreserveWindow	HoverHelpWindow unreserve.</body></methods><methods><class-id>UI.TooltipAssistant</class-id> <category>initialize-release</category><body package="Tools-HoverHelp" selector="release">release	self closeTooltip.	super release.</body></methods><methods><class-id>UI.TooltipAssistant</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="closeTooltip">closeTooltip	HoverHelpWindow closeFor: view.</body><body package="Tools-HoverHelp" selector="hasTooltip">hasTooltip	^ self tooltipGraphic notNil.</body><body package="Tools-HoverHelp" selector="openTooltip">openTooltip	self tooltipGraphic		ifNotNil: [ :tip | HoverHelpWindow openTooltip: tip for: view ].</body><body package="Tools-HoverHelp" selector="tooltip">tooltip	^ tooltip.</body><body package="Tools-HoverHelp" selector="tooltip:">tooltip: anObject	tooltip := anObject.</body></methods><methods><class-id>UI.TooltipAssistant</class-id> <category>transitions</category><body package="Tools-HoverHelp" selector="armedFrameExited">armedFrameExited	self unreserveWindow.		self log: #coldArmedExit.	stateMachine reset.</body><body package="Tools-HoverHelp" selector="armedHelpInterrupted">armedHelpInterrupted		self unreserveWindow.		self log: #coldArmedInterrupt.	stateMachine reset.</body><body package="Tools-HoverHelp" selector="armedTimeout">armedTimeout		self isMyWindowActive		ifTrue:			[self openTooltip.			self log: #reaper.			stateMachine enterStateNamed: #reaper]		ifFalse:			[self unreserveWindow.			self log: #coldArmedTimeout.			stateMachine reset]</body><body package="Tools-HoverHelp" selector="coldFrameEntered">coldFrameEntered	"Be sure to respect the focus of the window containing the requesting view."	view topComponent isActive ifFalse: [^self].	self hasTooltip		ifTrue:			[self shouldOpenTooltipNow				ifTrue: [self armedTimeout]				ifFalse:					[self reserveWindow.					self log: #armed.					stateMachine enterStateNamed: #armed]]</body><body package="Tools-HoverHelp" selector="reaperFrameExited">reaperFrameExited		self closeTooltip.	self log: #coldReaperExit.	stateMachine reset.</body><body package="Tools-HoverHelp" selector="reaperHelpInterrupted">reaperHelpInterrupted		self closeTooltip.	self log: #coldReaperInterrupt.	stateMachine reset.</body><body package="Tools-HoverHelp" selector="reaperTimeout">reaperTimeout		self closeTooltip.	self log: #coldReaperTimeout.	stateMachine reset.</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="helpText:">helpText: aStringOrText	"This is the old API, use tooltip: instead. It's here for bw compatibility."	self tooltip: aStringOrText.</body></methods><methods><class-id>UI.ProgressWidgetView</class-id> <category>initialize-release</category><body package="Tools-HoverHelp" selector="helpText:">helpText: aStringOrText	"This is the old API, use tooltip: instead. It's here for bw compatibility."	self tooltip: aStringOrText.</body></methods><methods><class-id>UI.SliderView</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="helpText:">helpText: aStringOrText	"This is the old API, use tooltip: instead. It's here for bw compatibility."	self tooltip: aStringOrText.</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>tooltips</category><body package="Tools-HoverHelp" selector="addTooltipAssistant">addTooltipAssistant	^ self addTooltipAssistant: TooltipAssistant.</body><body package="Tools-HoverHelp" selector="addTooltipAssistant:">addTooltipAssistant: anAssistantClass	^ self		propertyAt: #tooltipAssistant		put: (anAssistantClass on: self).</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>announcements</category><body package="Tools-HoverHelp" selector="announceHelpInterrupted">announceHelpInterrupted	"Something has happened that should interrupt any TooltipAssistant processing."	self announce: (HelpInterrupted for: self)</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="tooltip">tooltip	^ self tooltipAssistant ifNotNil: [:assistant | assistant tooltip].</body><body package="Tools-HoverHelp" selector="tooltip:">tooltip: anObject	"Set the tooltip of the reciever to be anObject. If anObject is nil, clear out the tooltip assistant. anObject may be any object that responds to asTooltipGraphicFor:. Currently this includes CharacterArrays (Strings, Text, etc), full blown VisualComponents (or Parts), UserMessages, or BlockClosures that return any of the previous types.We maintain one and only one tooltip assistant, keeping it in the lazy properties registry.While this is implemented in VisualPart, intercepting mouse/keyboard/window events depends on counterpart Controller behavior, so tooltips are only meaningful to do for a View object -- for now."	anObject		ifNil:			[self tooltipAssistant				ifNotNil:					[:assistant | 					assistant release.					self propertyAt: #tooltipAssistant put: nil]]		ifNotNil:			[(self tooltipAssistant ifNil: [self addTooltipAssistant]) tooltip:					anObject]</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>tooltips</category><body package="Tools-HoverHelp" selector="tooltipAssistant">tooltipAssistant	^ self propertyAt: #tooltipAssistant.</body></methods><methods><class-id>UI.SequenceView</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="helpText:">helpText: aStringOrText	"This is the old API, use tooltip: instead. It's here for bw compatibility."	self tooltip: aStringOrText.</body></methods><methods><class-id>UI.WidgetPolicy</class-id> <category>colors</category><body package="Tools-HoverHelp" selector="tooltipBackgroundColor">tooltipBackgroundColor	^ColorValue red: 1.0 green: 1.0 blue: 0.75</body><body package="Tools-HoverHelp" selector="tooltipBorderColor">tooltipBorderColor	^ColorValue black</body><body package="Tools-HoverHelp" selector="tooltipTextColor">tooltipTextColor	^ColorValue black</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="asTooltipGraphicFor:">asTooltipGraphicFor: aVisualPart	"Coerce the receiver into a graphic that is suitable for display in a hover help tooltip window. in this case, evaluate the receiver (a block) with aVisualPart as an optional argument. The block may return an object that is still not a graphic thing (e.g. aString), so repeat the application again, and make sure we don't get hung up on nils."	^(self cull: aVisualPart)		ifNotNil: [:blockResult | blockResult asTooltipGraphicFor: aVisualPart]</body></methods><methods><class-id>UI.MotifWidgetPolicy</class-id> <category>colors</category><body package="Tools-HoverHelp" selector="tooltipBackgroundColor">tooltipBackgroundColor	^ColorValue red: 0.933333 green: 0.882353 blue: 0.70</body></methods><methods><class-id>Kernel.UserMessage</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="asTooltipGraphicFor:">asTooltipGraphicFor: aVisualPart	"Coerce the receiver into a graphic that is suitable for display in a hover help tooltip window. For this receiver, convert to a string and let that finish the job."	^self asString asTooltipGraphicFor: aVisualPart</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="asTooltipGraphicFor:">asTooltipGraphicFor: aVisualPart	"Coerce the receiver into a graphic that is suitable for display in a hover help tooltip window. For this receiver, this is self. Other classes may do more, see implementors of this method for variants."	^self</body></methods><methods><class-id>UI.LabeledButtonView</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="helpText:">helpText: aStringOrText	"This is the old API, use tooltip: instead. It's here for bw compatibility."	self tooltip: aStringOrText.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="Tools-HoverHelp" selector="asTooltipGraphicFor:">asTooltipGraphicFor: aVisualPart	"Coerce the receiver into a graphic that is suitable for display in a hover help tooltip window. For text like objects, it is to build a graphic with the classic yellowish background and dark border. Consult the current policies of aVisualPart to get this right for the current look."	| text widgetPolicy |	widgetPolicy := aVisualPart widgetPolicy.	text := ComposedText		withText: self		style: widgetPolicy lookPolicyClass systemTextStyle.	^VisualBlock		block:			[:gc :box | 			gc				paint: widgetPolicy tooltipBorderColor;				displayRectangle: box;				paint: widgetPolicy tooltipBackgroundColor;				intersectClip: (box insetBy: 1);				displayRectangle: box;				paint: widgetPolicy tooltipTextColor;				display: text					at: 4 @ 2]		bounds: (Point zero extent: text bounds extent + (8 @ 4))</body></methods><methods><class-id>UI.MacOSXWidgetPolicy</class-id> <category>colors</category><body package="Tools-HoverHelp" selector="tooltipBackgroundColor">tooltipBackgroundColor	^ColorValue red: 1.0 green: 1.0 blue: 0.825</body><body package="Tools-HoverHelp" selector="tooltipBorderColor">tooltipBorderColor	^ColorValue brightness: 0.7</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>ProgressWidgetView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>axis lastValue position reverse area helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>EventSensor</name><environment>UI</environment><super>UI.ApplicationWindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collapseEvents queueLocked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class><class><name>TransientWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component paintPreferences isEventDriven controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>WidgetPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>defaultWidgetColors </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>SequenceView</name><environment>UI</environment><super>UI.SelectionView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visualBlock selectedVisualBlock measureWidth cachedWidth helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>SliderView</name><environment>UI</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>axis markerBlock markerLength marker color1 color2 markerBorder rangeMap helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>MotifWidgetPolicy</name><environment>UI</environment><super>UI.WidgetPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category><attributes><package>UILooks-Motif</package></attributes></class><class><name>VisualPartAnnouncement</name><environment>UI</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>part </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Announcements</category><attributes><package>Interface-Announcements</package></attributes></class><class><name>MacOSXWidgetPolicy</name><environment>UI</environment><super>UI.MacWidgetPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MacOSX</category><attributes><package>UILooks-MacOSX</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>UserMessage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString key catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>LabeledButtonView</name><environment>UI</environment><super>UI.BasicButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label textStyle helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>TextEditorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class></st-source>