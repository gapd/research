<?xml version="1.0"?><st-source><!-- Name: CEBundleName: CEComment: This Parcel contains the support code making VisualWorks compatible with WindowsCE devices.10 - InputState opens a context menu when a mouse button stays pressed at the same point for at least a second 11 - when using the mouse hold context menu feature, a red circle is displayed right before the context menu is opened12 - the red circle is removed using pixmap operations rather than to invalidate the whole window13 - try to show/hide the wait cursor16 - make full screen the default on PocketPC17 - fix race conditions in ScheduledWindow>>openIn: and the red circle code18 - on CE devices CEFilename is the default Filename class, 19 - enlarged the pixmap for red-circle-background-restore20 - added a setting entry on the 'Look and Feel' page to enable/disable the right mouse button emulation (red circle), default is off21 - use SHFullScreen to open Software Input Panel on PocketPC22 - perform ObjectMemory class>>bringAllWindowsToFront only on CE,	adapt SocketAccessor>>getPendingError for CE23 - modified SocketAccessor>>getPendingError such thatthe behaviour for other platforms is unchanged24 - Tap-and-Hold only on CE,	open software keyboard behaviour improved	changed patterns  to match new platform string25 - tap-and-hold-events should not generate additional button press / release events.26 - improved red circle code28 - various fixes to support twobyte characters in file names30 - Unicode enabled InputManager, font name string;       use pragma for startup code for RedButtonEmulation31 - added ObjectMemory class>>vmIsUnicode;	 fixed Windowlabel encoding33 - adaptions for 7.4.1Parcel: #('CE')ParcelName: CEDate: 3:29:07 am March 30, 2006 --><time-stamp>From VisualWorks®, Pre-Release 7.4.1 (mar06.3) of 20. März 2006 on 30. März 2006 at 3:29:07</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>InputState</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y bitState shiftState ctrlState lockState metaState metaKeyState otherMetaKey1State lastClick eventDispatcher lastDownPoint lastUpPoint lastUpButton lastWindow contextMenuDelay delayedEvent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>CE</package></attributes></class><comment><class-id>UI.InputState</class-id><body>Class InputState flattens the mouse motion and mouse button state into booleans for polling InputSensors.  Keyboard shift, control and meta are also flattened. Instance Variables:	x	&lt;Integer&gt;  mouse coordinate	y	&lt;Integer&gt;  mouse coordinate	bitState	&lt;Integer&gt;  vector of all the mouse buttons	shiftState	&lt;Integer&gt;  state of the left shift key	ctrlState	&lt;Integer&gt;  state of the control key	lockState	&lt;Integer&gt;  state of the caps-lock key	metaState	&lt;Integer&gt;  vector of all the modifier key states	metaKeyState	&lt;Integer&gt;  state of the meta key	otherMetaKey1State	&lt;Integer&gt;  state of the 2nd meta key	activitySemaphore	&lt;Semaphore&gt;  used to halt polling when no input is available	lastEventTime	&lt;Integer&gt;  millisecond time of the last input event	eventDispatcher	&lt;Object | nil&gt; an object which dispatches general events--those events not bound to a particular window.  The object, if not nil, must respond to #dispatchEvent:.	lastDownPoint	&lt;Point&gt;	The mouse position the last time a mouse button was pressed	lastUpPoint		&lt;point&gt;	The mouse position the last time a mouse button was released	lastUpButton    &lt;Integer&gt; The last button releasedClass Variables:	CtrlMask &lt;Integer&gt;  bits of metaState vector specifying control key state	DefaultState	&lt;InputState&gt;  usual input state for windows	DoubleClickTimeout	&lt;Integer&gt;  milliseconds between two clicks of a double click	FunctionKeyNames	&lt;Array&gt;  maps function key codes to Symbols	FunctionKeyValues	&lt;Array&gt;  	InputProcess	&lt;Process&gt;  dispatches input events	InputSemaphore	&lt;Semaphore&gt;  signalled on input events	InterruptKey	&lt;Integer&gt;  input encoding of the interrupt key	LockMask &lt;Integer&gt;  bits of metaState vector specifying lock key state	MetaFunctionKeyMap	&lt;Integer&gt; maps function key codes to Booleans as to whether a key is a modifier key	MetaMask &lt;Integer&gt;  bits of metaState vector specifying meta key state	OtherMeta1Mask &lt;Integer&gt;  bits of metaState vector specifying other meta (1) key state	PollingTimeout &lt;Integer&gt;	number of milliseconds to wait for input before sleeping	ShiftMask &lt;Integer&gt;  bits of metaState vector specifying shift key state	GrabProtect &lt;Semaphore&gt;	guarantees mutual exclusive access to GrabQueue.	GrabQueue	&lt;OrderedCollection&gt;	a queue of windows that are grabbing mouse input. 				The last item in the collection is the current grab object.</body></comment><class><name>WinCESystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			OS.WinCESystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles><item>sipapi.h</item></includeFiles><includeDirectories><item></item></includeDirectories><libraryFiles><item>coredll.dll</item> <item>aygshell.dll</item></libraryFiles><libraryDirectories><item>\Windows</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>CE Base</package></attributes></class><comment><class-id>OS.WinCESystemSupport</class-id><body>This class provides access to Windows CE-specific functionality.</body></comment><class><name>CEFilename</name><environment>OS</environment><super>OS.NTFSFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>CE Base</package></attributes></class><comment><class-id>OS.CEFilename</class-id><body>Refines class PCFilename to add CE file system specific behavior.On CE no current working directory and hence no relative filenamesexist. CEFilename keeps the working directory in a shared variable andso allows relative filenames.</body></comment><shared-variable><name>RightMouseButtonEmulationActive</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>button emulation</category><initializer>false</initializer><attributes><package>CE</package></attributes></shared-variable><shared-variable><name>RightMouseButtonEmulation</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>button emulation</category><initializer>true</initializer><attributes><package>CE</package></attributes></shared-variable><shared-variable><name>CurrentDirectoryString</name><environment>OS.CEFilename</environment><private>false</private><constant>false</constant><category>current settings</category><initializer>'\'</initializer><attributes><package>CE Base</package></attributes></shared-variable><methods><class-id>UI.InputState</class-id> <category>private dispatching</category><body package="CE" selector="send:eventButtonPress:">send: window eventButtonPress: event 	| focusWindow thisClick |	self changeWindowOrigin: window andSwapButtonsNow: event.	lastDownPoint := x @ y.	self setStateFromVector: (event at: 8).	(focusWindow := self focusWindowOr: window) ifNil: [^self].	event at: 2 put: focusWindow key.	thisClick := event at: 9.	((event at: 7) = 1 and: [self startContextWaitProcessWith: event for: focusWindow]) ifTrue: [^self].	((lastUpButton anyMask: self mouseButtons) and: 		[lastClick + self class doubleClickTimeout &gt; thisClick and: 		[(lastDownPoint - lastUpPoint) abs &lt;= (2 @ 2)]]) 			ifTrue: [focusWindow sensor eventDoubleClick: event]			ifFalse: [focusWindow sensor eventButtonPress: event].	lastClick := thisClick</body><body package="CE" selector="send:eventButtonRelease:">send: window eventButtonRelease: event 	| focusWindow |	contextMenuDelay ifNotNil: 			[self stopContextMenuDelay].	self changeWindowOrigin: window andSwapButtonsNow: event.	lastUpPoint := x @ y.	self setStateFromVector: (event at: 8).	lastUpButton := 1 bitShift: (event at: 7) - 1.	(focusWindow := self focusWindowOr: window) ifNil: [^self].	event at: 2 put: focusWindow key.	focusWindow sensor eventButtonRelease: event</body><body package="CE" selector="send:eventMouseMoved:">send: window eventMouseMoved: event	| focusWindow |	contextMenuDelay ifNotNil: 			[(x@y dist: lastDownPoint) &gt; 3 ifTrue:[self stopContextMenuDelay]].	self changeWindowOrigin: window andSwapButtons: event.	window ifNil: [^self processUnboundEvent: event].	focusWindow := self focusWindowOr: window.	focusWindow ifNil: [^self sendMouseTransition: focusWindow].	event at: 2 put: focusWindow key.	focusWindow sensor eventMouseMoved: event.	focusWindow ~= lastWindow ifTrue: [self sendMouseTransition: focusWindow]</body><body package="CE" selector="startContextWaitProcessWith:for:">startContextWaitProcessWith: event for: focusWindow 	"This forks a process doing a lot of things:		1. wait for 650 ms		2. continue only if this delay wasn't canceled		3. draw a small red circle arround the mouse position to warn the user that a menu is about to come up		4. wait another 650 ms		5. restore the area where the circle was drawn		6. continue only if the second delay wasn't canceled		7. send the event as a release button event, otherwise we cannot open a menu		8. convert the event into a middle mouse button pressed event, and send it.		9. nill out the delayedEvent if the fake event was sent since we don't wat to send it after we open the menu	The delays are stored in instVar contextMenuDelay, which is accesses by 'process:' to clear and 	cancel the delay if another event is to be processed while the delay is running."	self class rbEmulationEnabledActive ifFalse: [^false].	delayedEvent := event.	contextMenuDelay := Delay forMilliseconds: 650.		[	[| copiedEvent |	copiedEvent := event copy.	contextMenuDelay wait.	contextMenuDelay ifNotNil: 			[| gc pixmap focusPoint |						[| pixExtent square |			gc := focusWindow graphicsContext.			pixExtent := 19 @ 18.			pixmap := Pixmap extent: pixExtent.			square := 0 @ 0 extent: 14 @ 14.			gc paint: ColorValue red.			gc lineWidth: 2.			focusPoint := lastDownPoint - focusWindow globalOrigin - (7 @ 7).			pixmap graphicsContext 				copyRectangularArea: (0 @ 0 extent: pixExtent)				from: gc				sourceOffsetX: focusPoint x - 2				y: focusPoint y - 1				destinationOffsetX: 0				y: 0.			gc 				displayArcBoundedBy: square				startAngle: 0				sweepAngle: 360				at: focusPoint.			gc flush.			(contextMenuDelay := Delay forMilliseconds: 650) wait] 					ensure: [gc notNil &amp; pixmap notNil ifTrue: 								[gc displayPixmap: pixmap at: focusPoint - (2 @ 1).								gc flush]].			contextMenuDelay ifNotNil: 					[copiedEvent at: 7 put: 2.	"make it middle mouse button and ctrl down, then send it off to the window sensor, it should pop up a menu"					copiedEvent at: 8 put: ((copiedEvent at: 8) bitOr: CtrlMask).					focusWindow sensor eventButtonPress: copiedEvent.					delayedEvent := nil]]] 			on: Error			do: [:s | ]] 			forkAt: 51.	^true</body><body package="CE" selector="stopContextMenuDelay">stopContextMenuDelay	| window thisClick |	contextMenuDelay disable.	contextMenuDelay := nil.	delayedEvent ifNil: [^self].	window := Window findRegistrant: (delayedEvent at: 2).	(window := self focusWindowOr: window) ifNil: [^self].	thisClick := delayedEvent at: 9.	((lastUpButton anyMask: self mouseButtons) and: 		[lastClick + self class doubleClickTimeout &gt; thisClick and: 		[(lastDownPoint - lastUpPoint) abs &lt;= (2 @ 2)]]) 			ifTrue: [window sensor eventDoubleClick: delayedEvent]			ifFalse: [window sensor eventButtonPress: delayedEvent].	lastClick := thisClick</body></methods><methods><class-id>UI.InputState class</class-id> <category>accessing</category><body package="CE" selector="rbEmulationEnabled">rbEmulationEnabled	^RightMouseButtonEmulation</body><body package="CE" selector="rbEmulationEnabled:">rbEmulationEnabled: aBoolean	RightMouseButtonEmulation := aBoolean</body><body package="CE" selector="rbEmulationEnabledActive">rbEmulationEnabledActive	^RightMouseButtonEmulationActive</body><body package="CE" selector="rbEmulationEnabledActive:">rbEmulationEnabledActive: aBoolean	RightMouseButtonEmulationActive := aBoolean</body></methods><methods><class-id>UI.InputState class</class-id> <category>system startup</category><body package="CE" selector="postStartup">postStartup	"Clean up after a snapshot"	self rbEmulationEnabledActive: (self rbEmulationEnabled		and: ['* ce *' match: OSHandle currentPlatformID]).</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>types</category><body package="CE Base" selector="BOOL">BOOL	&lt;C: typedef long BOOL&gt;</body><body package="CE" selector="CLSID">CLSID	&lt;C: typedef void * CLSID&gt;</body><body package="CE Base" selector="DWORD">DWORD	&lt;C: typedef unsigned long DWORD&gt;</body><body package="CE Base" selector="HANDLE">HANDLE	&lt;C: typedef void * HANDLE&gt;</body><body package="CE Base" selector="HWND">HWND	&lt;C: typedef void * HWND&gt;</body><body package="CE" selector="IMENUMINFO">IMENUMINFO	&lt;C: typedef struct tagIMENUMINFO IMENUMINFO&gt;</body><body package="CE" selector="IMENUMPROC">IMENUMPROC	&lt;C: typedef int (* IMENUMPROC)(IMENUMINFO * )&gt;</body><body package="CE" selector="IMWINDOWPOS">IMWINDOWPOS	&lt;C: typedef struct tagIMWINDOWPOS IMWINDOWPOS&gt;</body><body package="CE" selector="LPBYTE">LPBYTE	&lt;C: typedef unsigned char * LPBYTE&gt;</body><body package="CE Base" selector="LPCWSTR">LPCWSTR	&lt;C: typedef wchar_t * LPCWSTR&gt;</body><body package="CE Base" selector="LPSTR">LPSTR	&lt;C: typedef char * LPSTR&gt;</body><body package="CE Base" selector="LPVOID">LPVOID	&lt;C: typedef void * LPVOID&gt;</body><body package="CE Base" selector="LPWSTR">LPWSTR	&lt;C: typedef wchar_t * LPWSTR&gt;</body><body package="CE" selector="PIMENUMINFO">PIMENUMINFO	&lt;C: typedef struct tagIMENUMINFO * PIMENUMINFO&gt;</body><body package="CE" selector="RECT">RECT	&lt;C: typedef struct _RECT RECT&gt;</body><body package="CE" selector="SIPINFO">SIPINFO	&lt;C: typedef struct tagSIPINFO SIPINFO&gt;</body><body package="CE Base" selector="wchar_t">wchar_t	&lt;C: typedef short wchar_t&gt;</body><body package="CE Base" selector="WORD">WORD	&lt;C: typedef unsigned short  WORD&gt;</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>structs</category><body package="CE Base" selector="PROCESS_INFORMATION">PROCESS_INFORMATION	"Describes a created process and its main thread."	&lt;C: struct PROCESS_INFORMATION {			HANDLE hProcess;			HANDLE hThread;			DWORD dwProcessId;			DWORD dwThreadId;		}&gt;</body><body package="CE" selector="tagIMENUMINFO">tagIMENUMINFO	&lt;C: struct tagIMENUMINFO {			unsigned short szName[260];			CLSID clsid;		}&gt;</body><body package="CE" selector="tagIMWINDOWPOS">tagIMWINDOWPOS	&lt;C: struct tagIMWINDOWPOS {			int x, y, cx, cy;		}&gt;</body><body package="CE" selector="tagSIPINFO">tagSIPINFO	&lt;C: struct tagSIPINFO {			unsigned long cbSize, fdwFlags;			RECT rcVisibleDesktop, rcSipRect;			unsigned long dwImDataSize;			void * pvImData;		}&gt;</body><body package="CE" selector="_RECT">_RECT	&lt;C: struct _RECT {			long left, top, right, bottom;		}&gt;</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>procedures</category><body package="CE" selector="regCreateKey:named:result:disposition:">regCreateKey: hKey named: lpSubKey result: phkResult disposition: lpdwDisposition 		"Shortcut for RegCreateKey"	^self RegCreateKey: hKey 			named: lpSubKey gcCopyToHeapUnicode			reserved: 0 			class: nil 			options: 0 			sam: self writeAccessMask  			security: nil 			result: phkResult 			disposition: lpdwDisposition.</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>utilities</category><body package="CE" selector="hideSIP">hideSIP	| pSipInfo result |	self halt.	pSipInfo := self SIPINFO calloc.	pSipInfo memberAt: #cbSize put: pSipInfo type referentType dataSize.	result := self SipGetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].	pSipInfo memberAt: #fdwFlags put: ((pSipInfo memberAt: #fdwFlags) bitAnd: self SIPF_ON value bitInvert).	result := self SipSetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].</body><body package="CE Base" selector="setCurrentDirectory:">setCurrentDirectory: pathName	"Set the current working directory."CEFilename setCurrentDirectory: pathName</body><body package="CE" selector="showSIP">showSIP	| pSipInfo result |	pSipInfo := self SIPINFO calloc.	pSipInfo memberAt: #cbSize put: pSipInfo type referentType dataSize.	result := self SipGetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].	pSipInfo memberAt: #fdwFlags put: ((pSipInfo memberAt: #fdwFlags) bitOr: SIPF_ON value).	result := self SipSetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].</body><body package="CE" selector="showSIPFor:">showSIPFor: aWindow	^self SHFullScreen: aWindow windowHandle with: SHFS_SHOWSIPBUTTON value</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>private- accessing</category><body package="CE" selector="createPath:in:">createPath: path in: key	"Iterate through a path and create each branch under a key."	| errorCode newKey initialKey disposition |	initialKey := key.	disposition := CIntegerType long newInFixedSpace.	newKey := CVoidType void pointerType newInFixedSpace.	path do:		[ :subKey |		errorCode :=  self regCreateKey: initialKey asInteger  			named: subKey result: newKey disposition: disposition. 		errorCode = self ERROR_SUCCESS ifFalse: [^nil].		initialKey := newKey contents].	^newKey</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>constants</category><body package="CE" selector="ERROR_SUCCESS">ERROR_SUCCESS	^0</body><body package="CE" selector="HKEY_CLASSES_ROOT">HKEY_CLASSES_ROOT	^16r80000000</body><body package="CE" selector="REG_SZ">REG_SZ	^1</body><body package="CE" selector="SIP_DOWN">SIP_DOWN	^1</body><body package="CE" selector="SIP_FORCEDOWN">SIP_FORCEDOWN	^2</body><body package="CE" selector="SIP_INPUTDIALOG">SIP_INPUTDIALOG	^4</body><body package="CE" selector="SIP_UNCHANGED">SIP_UNCHANGED	^3</body><body package="CE" selector="SIP_UP">SIP_UP	^0</body><body package="CE" selector="writeAccessMask">writeAccessMask	"defined by WinNT API"	^131078</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>accessing</category><body package="CE" selector="registerVisualworksExtension">registerVisualworksExtension	"self new registerVisualworksExtension"	self setVariableWithRoot: self HKEY_CLASSES_ROOT path: (Array with: '.im') key: 'Default'  value: 'visual_im'.	self setVariableWithRoot: self HKEY_CLASSES_ROOT 		path: (Array with: 'visual_im' with: 'shell' with:'open' with:'command')		 key: 'Default'		 value: ('"',CEnvironment commandLine first,'"  "%1"').</body><body package="CE" selector="removeVariableWithRoot:path:name:ifAbsent:">removeVariableWithRoot: rootValue path: path name: parameterName ifAbsent: errorBlock	"Remove the value of the named parameter, which must be a string.  If not 	 present in registry, return value of errorBlock."	| key errorCode voidPointerType stream |	key := (voidPointerType := CVoidType void pointerType) newInFixedSpace.	key contents: (voidPointerType cast: rootValue).	stream := WriteStream on: (String new: 64).	path do: [:each | stream nextPutAll: each] separatedBy: [stream nextPut: $\]. 	errorCode :=		self			RegOpenKeyEx: key contents			subKey: stream contents			options: 0			access: self KEY_SET_VALUE			result: key.	errorCode = self ERROR_SUCCESS ifFalse: [^errorBlock value].	errorCode := self RegDeleteValueW: key contents name: parameterName.	self RegCloseKey: key contents.	errorCode = self ERROR_SUCCESS ifFalse: [^errorBlock value]</body><body package="CE" selector="setVariableWithRoot:path:key:value:">setVariableWithRoot: rootValue path: path key: subkey value: value	"Set the value in the registry of subkey, which value must be a string.  	 Answer whether the operation was successful."	| key newKey errorCode voidPointerType|	key := (voidPointerType := CVoidType void pointerType) newInFixedSpace.	key contents: (voidPointerType cast: rootValue).	newKey := self createPath: path in: key contents.	newKey == nil ifTrue: [^false].	errorCode :=		self			RegSetValueEx: newKey contents asInteger			name: subkey gcCopyToHeapUnicode			reserved: 0			type: self REG_SZ			data: value gcCopyToHeapUnicode			size: (value size + 1) * 2.	^errorCode = self ERROR_SUCCESS</body><body package="CE" selector="windowDecorationRectangle">windowDecorationRectangle	^0@0 corner: 0@0</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>defines</category><body package="CE" selector="IM_NARROWIMAGE">IM_NARROWIMAGE	&lt;C: #define IM_NARROWIMAGE 2	&gt;</body><body package="CE" selector="IM_POSITION">IM_POSITION	&lt;C: #define IM_POSITION 0	&gt;</body><body package="CE" selector="IM_WIDEIMAGE">IM_WIDEIMAGE	&lt;C: #define IM_WIDEIMAGE 1	&gt;</body><body package="CE" selector="MAX_PATH">MAX_PATH	&lt;C: #define MAX_PATH 260	&gt;</body><body package="CE" selector="SHFS_SHOWSIPBUTTON">SHFS_SHOWSIPBUTTON	&lt;C: #define SHFS_SHOWSIPBUTTON          0x0004	&gt;</body><body package="CE" selector="SIPF_DOCKED">SIPF_DOCKED	&lt;C: #define SIPF_DOCKED 0x00000002	&gt;</body><body package="CE" selector="SIPF_LOCKED">SIPF_LOCKED	&lt;C: #define SIPF_LOCKED 0x00000004	&gt;</body><body package="CE" selector="SIPF_OFF">SIPF_OFF	&lt;C: #define SIPF_OFF 0x00000000	&gt;</body><body package="CE" selector="SIPF_ON">SIPF_ON	&lt;C: #define SIPF_ON 0x00000001	&gt;</body><body package="CE" selector="SIP_STATUS_AVAILABLE">SIP_STATUS_AVAILABLE	&lt;C: #define SIP_STATUS_AVAILABLE 1	&gt;</body><body package="CE" selector="SIP_STATUS_UNAVAILABLE">SIP_STATUS_UNAVAILABLE	&lt;C: #define SIP_STATUS_UNAVAILABLE 0	&gt;</body><body package="CE" selector="SPI_GETCURRENTIM">SPI_GETCURRENTIM	&lt;C: #define SPI_GETCURRENTIM 227	&gt;</body><body package="CE" selector="SPI_GETSIPINFO">SPI_GETSIPINFO	&lt;C: #define SPI_GETSIPINFO 225	&gt;</body><body package="CE" selector="SPI_SETCOMPLETIONINFO">SPI_SETCOMPLETIONINFO	&lt;C: #define SPI_SETCOMPLETIONINFO 223	&gt;</body><body package="CE" selector="SPI_SETCURRENTIM">SPI_SETCURRENTIM	&lt;C: #define SPI_SETCURRENTIM 226	&gt;</body><body package="CE" selector="SPI_SETSIPINFO">SPI_SETSIPINFO	&lt;C: #define SPI_SETSIPINFO 224	&gt;</body></methods><methods><class-id>OS.WinCESystemSupport class</class-id> <category>utilities</category><body package="CE Base" selector="CreateProcess:arguments:">CreateProcess: aProgramNameString arguments: anArgumentString 	"Create a new process with a specific argument list. 	Answer aCCompositePointer to a PROCESS_INFORMATION struct.	The example is intended to run on PocketPC 2003."	"self CreateProcess: 'iexplore.exe' arguments: ' \Windows\agdefault.htm'"	^self		CreateProcess: aProgramNameString		arguments: anArgumentString		creationFlags: 0.</body><body package="CE Base" selector="CreateProcess:arguments:creationFlags:">CreateProcess: aProgramNameString arguments: anArgumentString creationFlags: creationFlags 	"Create a new detached process with a specific argument list and creationFlags. 	Answer aCCompositePointer to a PROCESS_INFORMATION struct."	| interface processInfo |	interface := self new.	processInfo := interface PROCESS_INFORMATION gcMalloc.	interface		CreateProcess: (aProgramNameString ifNil: [nil] ifNotNil: [aProgramNameString gcCopyToHeapUnicode])		commandLine: anArgumentString gcCopyToHeapUnicode		pSecurity: nil		tSecurity: nil		inheritHandles: 0		creationFlags: creationFlags		environment: nil		currentDirectoryName: nil		startupInfo: nil		processInfo: processInfo.	^processInfo</body><body package="CE Base" selector="libraryFilesSearchSignals">libraryFilesSearchSignals	^ExternalLibraryHolder libraryNotFoundSignal</body></methods><methods><class-id>OS.CEFilename</class-id> <category>private</category><body package="CE Base" selector="named:">named: n 	(n isEmpty not and: [n first == self separator or: [n includes: $:]])		ifTrue: [^super named: n]		ifFalse: 			[| path |			path := self class getDefaultDirectory asString.			path last == self separator 				ifTrue: [^super named: path , n]				ifFalse: [^super named: path , (String with: self separator) , n]]</body></methods><methods><class-id>OS.CEFilename class</class-id> <category>parsing</category><body package="CE Base" selector="bytesFor:">bytesFor: char	"Answer number of unicode character to encode this character."	^1</body><body package="CE Base" selector="isBadCharacter:">isBadCharacter: char	"Answer if this character is illegal for a platform pathname string."	"Assume nobody likes unprintable characters."	| cv |	cv := char asInteger.	cv &lt; 32 "space" ifTrue: [^true].	cv = 8r177 "del" ifTrue: [^true].	^(self badCharacterList includes: char)</body></methods><methods><class-id>OS.CEFilename class</class-id> <category>private</category><body package="CE Base" selector="currentDirectoryString">currentDirectoryString	"Return the platform-specific token that represents the current directory"	^CurrentDirectoryString copy</body><body package="CE Base" selector="hookupTo:">hookupTo: pn	"The receiver has become the default class for  Filename.  Get prepared."	(ObjectMemory dependents includes: self) ifFalse:		[ObjectMemory addDependent: self].	String.PrimitiveArgumentClass := TwoByteString.	self setCwd</body><body package="CE Base" selector="setCwd">setCwd	"set current working directory at startup time.	The current working directory is the one where the image was loaded from.	If no image was specified in the commandLine, use the executable"	"self setCwd"	| commandLine fileName |	commandLine := CEnvironment commandLine.	fileName := commandLine detect: [:s | '*.im' match: s] ifNone: [commandLine first].	self setCurrentDirectory: fileName asFilename head</body><body package="CE Base" selector="update:">update: anAspect 	anAspect == #returnFromSnapshot ifTrue: [self setCwd]</body></methods><methods><class-id>OS.CEFilename class</class-id> <category>utilities</category><body package="CE Base" selector="encodeFilename:">encodeFilename: aString	^aString asTwoByteString</body><body package="CE Base" selector="volumes">volumes	^Array with: '\'</body></methods><methods><class-id>OS.CEFilename class</class-id> <category>accessing</category><body package="CE Base" selector="getDefaultDirectory">getDefaultDirectory	^CurrentDirectoryString</body><body package="CE Base" selector="setCurrentDirectory:">setCurrentDirectory: aFileName	CurrentDirectoryString := aFileName asString</body></methods><methods><class-id>UI.InputManager class</class-id> <category>initialization</category><body package="CE Base" selector="platformHookup">platformHookup	"This is sent when VisualWorks starts up. A manager that is appropriate 	 for the platform must be chosen at this time to handle setlocale 	 requests. However, the NilInputManager may still be installed 	 as the default if the current locale so specifies."	| platform |	Default := nil.	platform := self platformName.	"Use WindowsInputManager only when not running on CE	 (avoiding unicode bugs in WindowsInputManager)."	(platform = 'MS-Windows'	 and: [('* ce *' match: OSHandle currentPlatformID) not]) ifTrue: 		[| wim |		wim := #{WindowsInputManager} value.		wim initializeEncoder.		^Default := PlatformManager := wim new].	"Use X11InputManager only when running X11R5 or better."	(platform = 'X11' 	 and: [(ObjectMemory objectRegisteredWithEngineFor: 'XlibSpecificationRelease') &gt;= 5]) ifTrue: 		[^PlatformManager := #{X11InputManager} value new].	PlatformManager := NullInputManager new</body></methods><methods><class-id>OS.Filename class</class-id> <category>class initialization</category><body package="CE Base" selector="hookupFor:withID:">hookupFor: ps withID: id	"hook-up default subclasses."	| dpc |	dpc := id = 'unix' ifTrue: [('*MacOSX*' match: ps ignoreCase: false)				ifTrue: [MacOSXFilename]				ifFalse: [UnixFilename]]			ifFalse:	[id = 'mac' ifTrue: [MacFilename]			ifFalse:	[(#('dos' 'os2' 'win32') includes: id) 				ifTrue: [('* ce *' match: ps) 						ifTrue: [CEFilename]						ifFalse: [PCFilename]]			ifFalse:	[self]]].	self defaultClass: dpc.	dpc hookupTo: ps.</body></methods><methods><class-id>OS.OSSystemSupport class</class-id> <category>instance creation</category><body package="CE Base" selector="concreteClassFrom:">concreteClassFrom: platformArray	"Answer the specific subclass that interfaces to the OS described by	 the supplied platformArray."	| platformSymbol version |	platformSymbol := platformArray at: 1.	#unix == platformSymbol ifTrue: 		[('*macOSX*' match: (platformArray at: 2))			ifFalse: [^#{UnixSystemSupport} value]			ifTrue:   [^#{MacOSXSystemSupport} value]].	#os2 == platformSymbol		ifTrue: [^#{OS2SystemSupport} value].	#win32 == platformSymbol		ifTrue:			[| stream os |			stream := (platformArray at: 2) readStream.			stream skipThrough: Character space.			version := stream upTo: Character space.			os := stream upTo: Character space. "Should be end of string."			^os = 'win32s'				ifTrue: [('V3.*' match: version)					ifTrue: [#{Win32sSystemSupport} value]					ifFalse: [#{Win95SystemSupport} value]]				ifFalse: [os = '95'					ifTrue: [#{Win95SystemSupport} value]					ifFalse: [os = 'ce' ifTrue: [#{WinCESystemSupport} value]							ifFalse:[#{WinNTSystemSupport} value]]]].	#mac == platformSymbol		ifTrue:			[| stream |			stream := (platformArray at: 2) readStream.			stream				skipThrough: Character space;				skipThrough: Character space;				skipThrough: Character space.			^stream peek == $P				ifTrue: [#{PowerMacSystemSupport} value]				ifFalse: [#{MacSystemSupport} value]].	^#unknown.</body></methods><methods><class-id>Core.ByteEncodedString class</class-id> <category>class initialization</category><body package="CE Base" selector="initialize">initialize	"ByteEncodedString initialize"	StringClasses := Dictionary new.	StringClasses at: 'Mac' put: #{MacString}.	StringClasses at: 'ISO8859L1' put: #{ISO8859L1String}.	StringClasses at: 'IBMCP850' put: #{OS2String}.	UnsupportedCharacterError		notifierString: (#errCharacterNotSupported &lt;&lt; #dialogs &gt;&gt; 'This character is not supported by this class of string');		nameClass: self message: #unsupportedCharacterSignal</body></methods><methods><class-id>Core.ByteEncodedString class</class-id> <category>system startup</category><body package="CE Base" selector="install">install	| className stringClass nm |	className := self platformStringPreference first.	className changeClassTo: ByteString.	stringClass := (StringClasses at: className) value.	self defaultPlatformClass: stringClass.	PrimitiveArgumentClass := ObjectMemory vmIsUnicode								ifTrue: [TwoByteString]								ifFalse: [ByteArray].	PrimitiveArgumentClass bePreferredClassWithEncoding:		stringClass encoder decodingMap copy</body></methods><methods><class-id>OS.PCFilename class</class-id> <category>class initialization</category><body package="CE Base" selector="initialize">initialize	"Initialize the dictionary of file system classes for the known File Systems.	 Edit this when a new known file system is added.  NT has quite a lot of	 names for file systems and more may be found."	"PCFilename initialize"	(FsDict := Dictionary new) 		at: 'CDFS' put: HPFSFilename;		at: 'DOS' put: FATFilename;		at: 'FAT' put: FATFilename;		at: 'FAT32' put: FATFilename;		at: 'HPFS' put: HPFSFilename;		at: 'LAN' put: FATFilename;		at: 'NETWARE' put: FATFilename;		at: 'NetWare' put: FATFilename;		at: 'NFS' put: HPFSFilename;		at: '*NT5CSC' put: NTFSFilename;		at: 'NTFS' put: NTFSFilename;		at: 'NWCOMPA' put: FATFilename;		at: 'NWCOMPAT' put: FATFilename;		at: 'NWFS' put: FATFilename;		at: 'Samba' put: FATFilename;		at: 'VINES' put: FATFilename;		at: 'CEFS' put: CEFilename.	^self</body></methods><methods><class-id>Core.TwoByteString class</class-id> <category>system startup</category><body package="CE Base" selector="bePreferredClassWithEncoding:">bePreferredClassWithEncoding: anEncoding	"Register the receiver with the VM as the preferred String class.	anEncoding is a TwoByteString of size 256, that specifies, for any	given byte value, what Character that byte should represent"	&lt;primitive: 341&gt;	^self primitiveFailed</body></methods><methods><class-id>OS.IOAccessor class</class-id> <category>utilities</category><body package="CE Base" selector="convertSimpleStringForPlatform:">convertSimpleStringForPlatform: aString	"Convert aString, which has a single- or double-byte encoding,	to conform to the platform's default encoding."	ObjectMemory vmIsUnicode ifTrue:		[aString isByteIndexed ifFalse:[^aString]].	^aString asByteArrayEncoding: #default</body></methods><methods><class-id>Graphics.Window class</class-id> <category>class initialization</category><body package="CE Base" selector="initializeLabelEncodings">initializeLabelEncodings	"Each element of the collection is an Array of four elements		- pattern to compare against OSHandle currentPlatformID		- pattern to compare against Locale current name		- pattern to compare against Locale current defaultEncoding		- if all three patterns match, the encoding to use for window labels"	LabelEncoding := OrderedCollection new.	LabelEncoding add: #('* hp *' 'C' '*' #HP_Roman8).	LabelEncoding add: #('* ucs2 *' '*' '*' #UCS_2).</body></methods><methods><class-id>Graphics.Window</class-id> <category>accessing</category><body package="CE Base" selector="label:iconLabel:">label: aString iconLabel: anIconString	"Convert string into platform encoding and set the label for this window,	 if supported by the window manager."	| encoding |	encoding := self class defaultWindowLabelEncoding.	encoding =  #UCS_2 ifTrue: [^self primLabel: (aString asString) iconLabel: (anIconString asString)].	^self		primLabel: (aString asString asByteArrayEncoding: encoding)		iconLabel: (anIconString asString asByteArrayEncoding: encoding)</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>testing</category><body package="CE Base" selector="vmIsUnicode">vmIsUnicode	^[self objectRegisteredWithEngineFor: 'vmIsUnicode'] on: Error do: [: error | false]</body></methods><methods><class-id>UI.ScheduledWindow class</class-id> <category>defaults</category><body package="CE" selector="windowTopLeftHeadroom">windowTopLeftHeadroom	"Answer a point specifying how much headroom to use for title	decoration in automatic window placement. The default is 10-pixel 	left border and 30-pixel title bar height"	^Screen default rendererName == #'MS-Windows' 		ifTrue: 			[[OSSystemSupport concreteClass new windowDecorationRectangle origin] 				on: Error				do: [:ex | ex return: 10 @ 30]]		ifFalse: [10 @ 30]</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>scheduling</category><body package="CE" selector="openIn:">openIn: aRectangle	"Open and schedule the receiver in aRectangle."	| newBounds |	self setDisplayBox: (newBounds := Screen default makeRectangleVisible: aRectangle).	self privateOpenForced: true.	self extentEvent: self extent.	Cursor normal show.	^newBounds</body></methods><methods><class-id>UI.WindowManager</class-id> <category>event processing</category><body package="CE" selector="processNextEvent">processNextEvent	| event |	event := eventQueue next.	activeController := event activeWindowController.	"need this for debugging"	self safelyDispatchForWindowManager: event.	self repairDamages.	event isExposeEvent ifTrue: [event window setupKeyboard].	Processor yield.	^event</body></methods><methods><class-id>UI.TransientWindow</class-id> <category>private</category><body package="CE" selector="setupKeyboard">setupKeyboard	^self</body></methods><methods><class-id>UI.ExposeEvent</class-id> <category>testing</category><body package="CE" selector="isExposeEvent">isExposeEvent	^true</body></methods><methods><class-id>UI.Event</class-id> <category>testing</category><body package="CE" selector="isExposeEvent">isExposeEvent	^false</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>accessing</category><body package="CE" selector="getPendingError">getPendingError	"Return the value of my pending error option. 	This can be checked before performing operations on me to verify 	that some previous operation hasn't resulted in a SOL_SOCKET-level 	error which could cause subsequent operations to signal an 	exception. On most CE devices this getSockOpt call is not supported,	so we provide the current errorCode instead."	| ba |	('*win* ce *' match: OSHandle currentPlatformID) ifTrue:		[^self getPendingErrorOnCE].	ba := self getOptionsLevel: self class SOL_SOCKET name: self class SO_ERROR.	ba changeClassTo: UninterpretedBytes.	^ba unsignedLongAt: 1</body><body package="CE" selector="getPendingErrorOnCE">getPendingErrorOnCE	"Return the value of my pending error option. 	This can be checked before performing operations on me to verify 	that some previous operation hasn't resulted in a SOL_SOCKET-level 	error which could cause subsequent operations to signal an 	exception. On most CE devices this getSockOpt call is not supported,	so we provide the current errorCode instead."	| ba oldError |	oldError := self errorCode. oldError isNil ifTrue:[oldError := 0].	[ba := self getOptionsLevel: self class SOL_SOCKET name: self class SO_ERROR] on: OsIllegalOperation do: [:exception | ^oldError].	ba changeClassTo: UninterpretedBytes.	^ba unsignedLongAt: 1</body></methods><methods><class-id>Graphics.ScreenGraphicsContext</class-id> <category>primitives-curves</category><body package="CE" selector="roundedPrimDisplayArcBBoxOrigin:extent:startAngle:sweepAngle:">roundedPrimDisplayArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle 	"Display an elliptical arc defined by the bounding rectangle of the 	ellipse and by the starting angle and angle of sweep for the arc. 		The bounding rectangle is specified by the coordinates of its top left 	corner and by its width and height. The angles are specified in 	degrees, with positive angles indicating clockwise displacements, 	negative angles counterclockwise. The startAngle specifies that 	starting angular position for the arc, measured from three o'clock. 	The sweep angle specifies the angular path of the arc relative to 	the starting angle. The angles are specified in the (possibly skewed) 	coordinate system of the ellipse. For example, the angle between 	three o'clock and a line from the center of the ellipse to the top 	right corner of the bounding rectangle is always 45 degrees, even if 	the bounding rectangle is not square.	The points have already been rounded and the angles already	converted to Floats.		Use the current line width, cap style, and paint."	&lt;primitive: 990&gt;	" We have already rounded all the points,	so the primitive must be unable to handle	some other aspect of the drawing operation.	Fall back to general-case code. "	self displayGeneralArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle</body><body package="CE" selector="roundedPrimDisplayWedgeBBoxOrigin:extent:startAngle:sweepAngle:">roundedPrimDisplayWedgeBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle 	"Display an elliptical wedge bounded by a zero-width arc and the 	zero-width line segments from the center of the ellipse to the ends 	of the arc. 		The bounding arc is defined by the bounding rectangle of the ellipse 	and by the starting angle and angle of sweep for the arc. The 	bounding rectangle is specified by the coordinates of its top left 	corner and by its width and height. The angles are specified in 	degrees, with positive angles indicating clockwise displacements, 	negative angles counterclockwise. The startAngle specifies that 	starting angular position for the arc, measured from three o'clock. 	The sweep angle specifies the angular path of the arc relative to 	the starting angle. The angles are specified in the (possibly skewed) 	coordinate system of the ellipse. For example, the angle between 	three o'clock and a line from the center of the ellipse to the top 	right corner of the bounding rectangle is always 45 degrees, even if 	the bounding rectangle is not square. 		Use the current paint.	The coordinates have already been rounded and the angles converted	to floats."	&lt;primitive: 991&gt;	(EllipticalArc boundingBox: (originPoint extent: extentPoint) startAngle: startAngle sweepAngle: sweepAngle) asPolyline asFiller displayOn: self</body></methods><methods><class-id>Graphics.Window class</class-id> <category>private</category><body package="CE" selector="encodeWindowTypeSpecification:">encodeWindowTypeSpecification: aWindowType 	"Answer the encoded version of this window type specification."	('* PocketPC*' match: OSHandle currentPlatformID) ifTrue:		[^(#(#popUp #dialog #normalX #modelessDialog #imageModalDialog #reserved #postedMenu #normal)			indexOf: aWindowType			ifAbsent: [3]) - 1].	^(#(#popUp #dialog #normal #modelessDialog #imageModalDialog #reserved #postedMenu)		indexOf: aWindowType		ifAbsent: [3]) - 1</body></methods><methods><class-id>Graphics.Window</class-id> <category>private</category><body package="CE" selector="setupKeyboard">setupKeyboard		('* PocketPC*' match: OSHandle currentPlatformID) ifTrue:		[WinCESystemSupport new showSIPFor: self ].	^self</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>system startup</category><body package="CE" selector="bringAllWindowsToFront">bringAllWindowsToFront	InputState postStartup.	('* ce *' match: OSHandle currentPlatformID) ifTrue: 		[Window allGeneralInstances do: [:x | x isOpen ifTrue: [x raise]]]</body></methods><methods><class-id>Core.SystemEventInterest class</class-id> <category>dependencies-pragma</category><body package="CE" selector="redButtonEmulation">redButtonEmulation	&lt;triggerAtSystemEvent: #earlySystemInstallation&gt;	InputState postStartup</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-look and feel</category><body package="CE" selector="lookAndFeel60rightButtonEmulation">lookAndFeel60rightButtonEmulation	&lt;setting: #(lookAndFeel rightButtonEmulation)&gt;	^(BooleanSetting on: InputState aspect: #rbEmulationEnabled)		default: #false;		label: #RightButtonEmulation &lt;&lt; #labels &gt;&gt; 'Right Mouse button emulation for Windows CE';		helpText: #RightButtonEmulationHelpText &lt;&lt; #dialogs &gt;&gt; 'This setting controls the right mouse button emulation designed for the Windows CE platform. If enabled, a normal mouse button selection, where the mouse isn''t moved in any direction, will first draw a small red circle arround the mouse point, and if enough time has elapsed, the middle mouse menu is poped up. The red circle is removed, if the mouse is moved or the button is released in time.Because Windows CE devices normally have no mouse, but only a stylus, this setting should be switched on if application are to be deployed on Windows CE.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="CE" selector="lookAndFeelPage">lookAndFeelPage	&lt;settingsPage: #(lookAndFeel) position: -30&gt;	^ModularSettingsPage new		label: #LookAndFeel &lt;&lt; #labels &gt;&gt; 'Look and Feel';		icon: (ListIconLibrary visualFor: #window);		addAllSettings: 			(self settingsWithPrefix: #(lookAndFeel) 				except: #(windowPlacement mouseButtonOrder rightButtonEmulation));		useRadioButtonsForEnumerations;		addSetting:			(self settingWithId: #(lookAndFeel windowPlacement));		addSetting:			(self settingWithId: #(lookAndFeel mouseButtonOrder));		addSetting:			(self settingWithId: #(lookAndFeel rightButtonEmulation))</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>procedures</category><body package="CE Base" selector="CreateProcess:commandLine:pSecurity:tSecurity:inheritHandles:creationFlags:environment:currentDirectoryName:startupInfo:processInfo:">CreateProcess: imageName commandLine: commandLine pSecurity: lpsaProcess tSecurity: lpsaThread inheritHandles: inheritHandles creationFlags: creationFlags environment: environment currentDirectoryName: currentDirectoryName startupInfo: startupInfo processInfo: processInfo	"Create a new process running in a separate address space. n.b., we use CreateProcessW	(the UNICODE/wide version) rather than CreateProcessA (the ANSI version) since CE implements	only the unicode versions. This differs from the other Windows versions.	Unused structs are replaced by 'void *' types.	Description: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wcekernl/html/_wcesdk_win32_createprocess.asp"	&lt;C: BOOL CreateProcessW( 					LPCWSTR imageName,					LPCWSTR commandLine,					void * lpsaProcess, 					void * lpsaThread,					BOOL inheritHandles,					DWORD creationFlags,					LPVOID environment,					LPWSTR currentDirectoryName,					void * startupInfo,					struct PROCESS_INFORMATION *processInfo)&gt;</body><body package="CE Base" selector="GetLastError">GetLastError	&lt;C:DWORD GetLastError(void)&gt;</body><body package="CE" selector="RegCreateKey:named:reserved:class:options:sam:security:result:disposition:">RegCreateKey: hKey named: lpSubKey reserved: reserved class: lpClass options: dwOptions sam: samDesired security: lpSecurityAttributes result: phkResult disposition: lpdwDisposition 	&lt;C: long RegCreateKeyExW(unsigned long hKey,									wchar_t *  lpSubKey,									unsigned long  reserved,										wchar_t *lpClass,									unsigned long  dwOptions,									unsigned long  samDesired,									void * lpSecurityAttributes,									void ** phkResult,									unsigned long * lpdwDisposition)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="RegDeleteValueW:name:">RegDeleteValueW: hKey name: lpszValueName	&lt;C: long RegDeleteValueW(void * hKey, WORD *lpszValueName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="RegSetValueEx:name:reserved:type:data:size:">RegSetValueEx: hKey name: lpszValueName reserved: dwReserved type: dwType data: lpbData size: cbData	&lt;C: long RegSetValueExW( unsigned long hKey,								wchar_t *lpszValueName,								unsigned long dwReserved,								unsigned long dwType,								unsigned char *lpbData,								unsigned long cbData)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SHFullScreen:with:">SHFullScreen: hwndRequester with: dwState	&lt;C:__bool int SHFullScreen(HWND hwndRequester, DWORD dwState)&gt;</body><body package="CE" selector="SHSipPreferenceForWindow:state:">SHSipPreferenceForWindow: windowHandle state: sipState	&lt;C: __bool int SHSipPreference(HWND windowHandle,int sipState)&gt;</body><body package="CE" selector="SipEnumIM:">SipEnumIM: arg	&lt;C: int SipEnumIM(IMENUMPROC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SipGetCurrentIM:">SipGetCurrentIM: arg	&lt;C: int SipGetCurrentIM(CLSID * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SipRegisterNotification:">SipRegisterNotification: arg	&lt;C: int SipRegisterNotification(void * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SipSetCurrentIM:">SipSetCurrentIM: arg	&lt;C: int SipSetCurrentIM(CLSID * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SipSetDefaultRect:">SipSetDefaultRect: arg	&lt;C: int SipSetDefaultRect(RECT * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SipSetInfo:">SipSetInfo: arg	&lt;C: __bool int SipSetInfo(SIPINFO * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SipShowIM:">SipShowIM: arg	&lt;C: int SipShowIM(unsigned long)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="CE" selector="SipStatus:">SipStatus: argArray	&lt;C: unsigned long SipStatus(...)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>utilities</category><body package="CE" selector="SHSipPreference:with:">SHSipPreference:  windowHandle with: st	&lt;C:__bool int SHSipPreference (HWND windowHandle, int st)&gt;</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>accessing</category><body package="CE" selector="SipGetInfo:">SipGetInfo: arg	&lt;C: _bool int SipGetInfo(SIPINFO * )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><initialize><class-id>Core.ByteEncodedString</class-id></initialize><initialize><class-id>OS.PCFilename</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>TransientWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component paintPreferences isEventDriven controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>NTFSFilename</name><environment>OS</environment><super>OS.PCFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class><class><name>ScreenGraphicsContext</name><environment>Graphics</environment><super>Graphics.GraphicsContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>OSSystemSupport</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			OS.OSSystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Support</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Event</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time initiator window </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class><class><name>ExposeEvent</name><environment>UI</environment><super>UI.ResizeEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttonNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class><class><name>WindowManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windows activeController interruptLock outstandingMetaOrDamage openInProgress eventQueue baseProcess dontFilterEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class></st-source>