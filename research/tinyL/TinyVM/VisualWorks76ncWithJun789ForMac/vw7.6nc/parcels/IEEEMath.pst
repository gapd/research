<?xml version="1.0"?><st-source><!-- Name: IEEE MathNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel provids support for IEEE 754 floating-point infinities and not-a-numbers.It defines methods required for the base image to go with the engine's -ieeefp (a.k.a.'IEEEFloatingPointPrimitives') option.  It provides for printing the IEEE special numbers,computing a hash value for them, and handles the error when you try to truncate them.To use this you must both load the parcel and either start the engine with the -ieeefpcommand-line switch, or arrange to evaluate	ObjectMemory registerObject: true withEngineFor: 'IEEEFloatingPointPrimitives'before any floating-point primitives are executed.  The engine responds to -ieeefp(and 'IEEEFloatingPointPrimitives') by arranging that the floating-point primitiveswill produce Infs and NaNs according to the IEEE 754 standard, instead of failing.DbIdentifier: bear73DbTrace: 119926HideSource: falsePackageName: IEEE MathParcel: #('IEEE Math')ParcelName: IEEE MathPrintStringCache: (1.3,bobw)SaveSource: trueVersion: 7.6Date: 12:29:02 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 12:29:02 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.LimitedPrecisionReal class</class-id> <category>constants access</category><body package="IEEE Math" selector="negativeInfinity">negativeInfinity	"Answer floating point number representing negative infinity."	^self unity negated / self zero</body><body package="IEEE Math" selector="notANumber">notANumber	"Answer a suitable IEEE Not-A-Number value."	^self zero / self zero</body><body package="IEEE Math" selector="positiveInfinity">positiveInfinity	"Answer floating point number representing positive infinity."	^self unity / self zero</body></methods><methods><class-id>Core.LimitedPrecisionReal class</class-id> <category>accessing</category><body package="IEEE Math" selector="printStringForNegativeInfinity">printStringForNegativeInfinity	"Return the print string for positive infinity."	^'-' , self printStringForPositiveInfinity</body><body package="IEEE Math" selector="printStringForNotANumber">printStringForNotANumber	"Return the print string for positive infinity."	^'NaN'</body><body package="IEEE Math" selector="printStringForPositiveInfinity">printStringForPositiveInfinity	"Return the print string for positive infinity."	^'INF'</body></methods><methods><class-id>Core.LimitedPrecisionReal class</class-id> <category>constants access</category><body package="IEEE Math" selector="specialIEEENumberExponent">specialIEEENumberExponent	"Answer the value of the exponent for floating-point Infinities and Not-a-Numbers.	 This is IEEE-specific.  Note that the value is the value answered by the exponent	 primitive, not the actual bit-pattern."	self subclassResponsibility</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>testing</category><body package="IEEE Math" selector="isInfinity">isInfinity	"Answer if the receiver is an IEEE infinity representation."	^self - self ~= 0 and: [self isNaN not]</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>private</category><body package="IEEE Math" selector="isNaN">isNaN	"Answer if the receiver represents an IEEE NAN (Not a Number)." 	^self ~= self</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>testing</category><body package="IEEE Math" selector="isNegativeInfinity">isNegativeInfinity	"Answer if the receiver represents an IEEE negative infinity."	^self &lt; 0 and: [self - self ~= 0]</body><body package="IEEE Math" selector="isPositiveInfinity">isPositiveInfinity	"Answer if the receiver represents an IEEE positive infinity."	^self &gt; 0 and: [self - self ~= 0]</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>private</category><body package="IEEE Math" selector="isSpecialValue">isSpecialValue	"Answer if the receiver represents an IEEE special value."	^self - self ~= 0</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>printing</category><body package="IEEE Math" selector="printOn:">printOn: aStream 	"Append to the argument, aStream, a literal form of the receiver 	using a reasonable number of significant digits."	(self printSpecialsOn: aStream)		ifFalse: [self printOn: aStream digits: self defaultNumberOfDigits]</body><body package="IEEE Math" selector="printOn:printPolicy:">printOn: aStream printPolicy: aNumberPrintPolicy 	"Append to the argument, aStream, a literal form of the receiver 	using a reasonable number of significant digits."	(self printSpecialsOn: aStream)		ifFalse: [self				printOn: aStream				digits: self defaultNumberOfDigits				printPolicy: aNumberPrintPolicy]</body><body package="IEEE Math" selector="printSpecialsOn:">printSpecialsOn: aStream 	"If the value is a speciall IEEE value, print it instead. Answer whether such was the case."	self isSpecialValue ifFalse: [^false].	self isPositiveInfinity ifTrue:		[aStream nextPutAll: self class printStringForPositiveInfinity.		 ^true].	self isNegativeInfinity ifTrue:		[aStream nextPutAll: self class printStringForNegativeInfinity.		 ^true].	self isNaN ifTrue:		[aStream nextPutAll: self class printStringForNotANumber.		 ^true].	self error: #UnknownSpecialValue &lt;&lt; #dialogs &gt;&gt; 'unknown special value'</body></methods><methods><class-id>Core.Float class</class-id> <category>constants access</category><body package="IEEE Math" selector="specialIEEENumberExponent">specialIEEENumberExponent	"Answer the value of the exponent for single precision Infinities and Not-a-Numbers.	 This is IEEE-specific.  Note that the value is the value answered by the exponent	 primitive, not the actual bit-pattern."	^128</body></methods><methods><class-id>Core.Float</class-id> <category>comparing</category><body package="IEEE Math" selector="hash">hash	"Try to have a hash function that matches integers.	The assumption is that for hashing, other rationals	will convert themselves to Floats or Doubles to hash,	so we'll have good hash functions for them."	| truncated |	self isSpecialValue ifTrue: [^self hashOfBytes].	truncated := self truncated.	^self = truncated		ifTrue: [truncated hash]		ifFalse: [^self hashOfBytes]</body><body package="IEEE Math" selector="hashOfBytes">hashOfBytes	"Answer the hash value calculated from the bytes that encode the receiver"	| answer |	answer := 0.	1 to: 4 do:		[:each |			| eachByteValue sBoxValue |			eachByteValue := self basicAt: each.			sBoxValue := self bretMulveySubstitutionBox30Bits at: eachByteValue + 1.			answer := answer bitXor: sBoxValue		].	^answer</body></methods><methods><class-id>Core.Float</class-id> <category>truncation and round off</category><body package="IEEE Math" selector="truncated">truncated	"Answer a SmallInteger equal to the value of the receiver	without its fractional part. Fail if the truncated value cannot be	represented as a SmallInteger.  In that case, the code below will	compute a LargeInteger truncated value."	&lt;primitive: 51&gt;	^self isSpecialValue 		ifTrue: 			[self class 				raise: #domainErrorSignal				receiver: self				selector: #truncated				errorString: #errCannotTruncate &lt;&lt; #dialogs 						&gt;&gt; 'Cannot truncate Infinities or NaNs']		ifFalse: 			[| max |			max := SmallInteger maxVal // 2 + 1.			(self quo: max asFloat) * max + (self rem: max asFloat) truncated]</body></methods><methods><class-id>Core.Float</class-id> <category>arithmetic</category><body package="IEEE Math" selector="\\">\\ aNumber 	"Answer the receiver modulo aNumber; which is a Number m such 	that m has the same sign as aNumber, the absolute value of m is 	less than the absolute value of aNumber, and there exists an Integer 	k such that (k * aNumber + m) equals the receiver (e.g., 9\\4 = 1, 	-9\\4 = 3, 9\\-4 = -3, 0.9\\0.4 = 0.1)."	^[super \\ aNumber]		on: DomainError do: [:ex | ex return: ((self isZero and: [aNumber isInfinity])				ifTrue: [self class zero]				ifFalse: [self class notANumber])]"the inherited behavior 	^self - (self // aNumber * aNumber)will break on IEEE specials when // tries to truncate"</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="IEEE Math" selector="isInfinity">isInfinity	"Answer if the receiver is an IEEE infinity representation."	^false</body><body package="IEEE Math" selector="isNegativeInfinity">isNegativeInfinity	"Answer if the receiver is an IEEE negative infinity representation. "	"Floats normally get this message, but need to handle case when an Integer sneaks in"	^false</body><body package="IEEE Math" selector="isPositiveInfinity">isPositiveInfinity	"Answer if the receiver is an IEEE positive infinity representation. "	"Floats normally get this message, but need to handle case when an Integer sneaks in"	^false</body></methods><methods><class-id>Core.Double class</class-id> <category>constants access</category><body package="IEEE Math" selector="specialIEEENumberExponent">specialIEEENumberExponent	"Answer the value of the exponent for double precision Infinities and Not-a-Numbers.	 This is IEEE-specific.  Note that the value is the value answered by the exponent	 primitive, not the actual bit-pattern."	^1024</body></methods><methods><class-id>Core.Double</class-id> <category>comparing</category><body package="IEEE Math" selector="hash">hash	"Try to have a hash function that matches integers.	The assumption is that for hashing, other rationals	will convert themselves to Floats or Doubles to hash,	so we'll have good hash functions for them."	| truncated |	self isSpecialValue ifTrue: [^self hashOfBytes].	truncated := self truncated.	self = truncated ifTrue: [^truncated hash].	self canBeConvertedToFloat ifTrue: [^self asFloat hash].	^self hashOfBytes</body><body package="IEEE Math" selector="hashOfBytes">hashOfBytes	"Answer the hash value calculated from the bytes that encode the receiver"	| answer |	answer := 0.	1 to: 8 do:		[:each |			| eachByteValue sBoxValue |			eachByteValue := self basicAt: each.			sBoxValue := self bretMulveySubstitutionBox30Bits at: eachByteValue + 1.			answer := answer bitXor: sBoxValue		].	^answer</body></methods><methods><class-id>Core.Double</class-id> <category>truncation and round off</category><body package="IEEE Math" selector="truncated">truncated	"Answer a SmallInteger equal to the value of the receiver     	without its fractional part. Fail if the truncated value cannot be    	represented as a SmallInteger.  In that case, the code below will   	compute a LargeInteger truncated value"	&lt;primitive: 571&gt;	^self isSpecialValue 		ifTrue: 			[self class 				raise: #domainErrorSignal				receiver: self				selector: #truncated				errorString: #errCannotTruncate &lt;&lt; #dialogs 						&gt;&gt; 'Cannot truncate Infinities or NaNs']		ifFalse: 			[| max quo rem |			max := SmallInteger maxVal // 2 + 1.			quo := self quo: max asDouble.			rem := self - (quo * max asDouble).	"in-line rem to avoid exponential number of quos"			quo * max + rem truncated]</body></methods><methods><class-id>Core.Double</class-id> <category>arithmetic</category><body package="IEEE Math" selector="\\">\\ aNumber 	"Answer the receiver modulo aNumber; which is a Number m such 	that m has the same sign as aNumber, the absolute value of m is 	less than the absolute value of aNumber, and there exists an Integer 	k such that (k * aNumber + m) equals the receiver (e.g., 9\\4 = 1, 	-9\\4 = 3, 9\\-4 = -3, 0.9\\0.4 = 0.1)."	^[super \\ aNumber]		on: DomainError do: [:ex | ex return: ((self isZero and: [aNumber isInfinity])				ifTrue: [self class zero]				ifFalse: [self class notANumber])]"the inherited behavior 	^self - (self // aNumber * aNumber)will break on IEEE specials when // tries to truncate"</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>testing</category><body package="IEEE Math" selector="isNegativeInfinity">isNegativeInfinity	"Answer if the receiver represents an IEEE negative infinity.	 Since the SmallDouble range exclude NaN and Inf simply answer false."	^false</body><body package="IEEE Math" selector="isPositiveInfinity">isPositiveInfinity	"Answer if the receiver represents an IEEE positive infinity.	 Since the SmallDouble range exclude NaN and Inf simply answer false."	^false</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>private</category><body package="IEEE Math" selector="isSpecialValue">isSpecialValue	"Answer if the receiver represents an IEEE special value.  Since SmallDouble values exclude	 NaN and Inf simply answer false."	^false</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>