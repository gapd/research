<?xml version="1.0"?><st-source><!-- Name: ScriptingSupportNotice: Copyright © 2008 Cincom Systems, Inc.  All Rights Reserved.Comment: This adds support for scripting using the image. The basic thing it defines is a subsystem that will look for script arguments or a script file name. Typical usage is something like  visual scripting.im scriptfile.ston Windows, you need to use the console engine, so, e.g. from the image directory  ..\bin\win\vwntconsole.exe scripting.im scriptfile.stFor a complete list of options, use the -h command-line argument. For an interactive shell, use -i.To run this from a plain starting image, you can use, e.g.  visual visual.im -nogui -pcl "Scripting Support" <scripting commands>In addition to allowing code to be run, this contains a few experimental things to make scripting easier. The first of those is the & operator. This is something to make building up collections easier. You get tired of doing  aCollection, (Array with: aThing) even in the normal image. In scripts it''s even worse. So you can do  aCollection & aThingand even  aThing & anotherThing(unless aThing is a boolean). That exception is a little odd, but we liked the semantics of & as a selector for that purpose well enough that we thought it was worthwhile.DbIdentifier: bear73DbTrace: 120367PackageName: ScriptingSupportParcel: #('ScriptingSupport')PrintStringCache: (1.25,bobw)Version: 7.6Date: 12:44:59 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 12:44:59 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Scripting</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Scripting Support</category><attributes><package>ScriptingSupport</package></attributes></name-space><class><name>ScriptRunner</name><environment>Scripting</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment myUndeclareds myUndeclaredsImport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scripting Support</category><attributes><package>ScriptingSupport</package></attributes></class><comment><class-id>Scripting.ScriptRunner</class-id><body>This is the object to be used as "self" when running scripts. It provides a number of utility methods that scripts can invoke, and has a namespace that includes temporary script variables.</body></comment><class><name>ScriptingConsole</name><environment>Scripting</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scriptRunner prompt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scripting Support</category><attributes><package>ScriptingSupport</package></attributes></class><comment><class-id>Scripting.ScriptingConsole</class-id><body>This runs the read-eval-print loop from the command line for Smalltalk scripting.Instance Variables:	prompt	&lt;Boolean&gt;	Should we use a prompt when running the interactive console.	scriptRunner	&lt;ScriptRunner&gt;	The thing we will actually use to run the code.</body></comment><class><name>ScriptingCompilerErrorHandler</name><environment>Scripting</environment><super>Kernel.NonInteractiveCompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CommandLine Smalltalk</category><attributes><package>ScriptingSupport</package></attributes></class><comment><class-id>Scripting.ScriptingCompilerErrorHandler</class-id><body>This is a non-interactive compiler error handler, but does not use the Undeclared Namespace for undeclared variables. Instead it will use the ScriptRunner's namespace. It also will react to ambiguous bindings by just using the preferred one.Instance Variables:	runner		&lt;ScriptRunner&gt;		The script runner who is using this handler. We use this to find environment to use for the undeclared variables.</body></comment><class><name>ScriptingSystem</name><environment>Scripting</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scripts scriptName shouldQuit commandLine scriptRunner debug useStandardIn prompt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scripting Support</category><attributes><package>ScriptingSupport</package></attributes></class><comment><class-id>Scripting.ScriptingSystem</class-id><body>This handles running smalltalk scripts from the command line.Instance Variables:	commandLine	&lt;SequenceableCollection&gt;	Caches our command line information.	debug	&lt;Boolean&gt;	The value of the debug flag. If true, and there's an error, we become headfull and open a debugger.	prompt	&lt;Boolean&gt;	If in interactive mode, should we issue a prompt, or just stay quiet.	scriptName	&lt;String | nil&gt;	The name of the script we expect to run.	scriptRunner	&lt;ScriptRunner&gt;	The script runner we will use to actually run things.	scripts	&lt;(Collection of: String)&gt;	The set of scripts we will run when we set up this system.	shouldQuit	&lt;Boolean&gt;	Should we quit after we finish running our scripts.	useStandardIn	&lt;Boolean&gt;	This is set if we're told to run a script file, but there is no file. In that case, when we get to that point, read from standard in to find out what to do.</body></comment><methods><class-id>Scripting.ScriptRunner</class-id> <category>convenience</category><body package="ScriptingSupport" selector="include:">include: fileName	"Run the named script."	| stream |	stream := fileName asFilename readStream.	[self fileInFrom: stream] ensure: [stream close].	^fileName.</body><body package="ScriptingSupport" selector="print:">print: anObject	"A convenience method for printing the object to our output."	Stdout print: anObject; flush.</body><body package="ScriptingSupport" selector="use:">use: parcelName	"Ensure that the parcel by this name (either the parcel name, or the file path to it) is loaded."	Parcel loadParcelByName: parcelName.	^parcelName.</body></methods><methods><class-id>Scripting.ScriptRunner</class-id> <category>printing</category><body package="ScriptingSupport" selector="printOn:">printOn: aStream	"We deliberately print ourselves as nothing, so that in interactive scripting, if we call a method on us that returns self, it won't clutter things up. Consider, e.g. (self print: 42)."	^self.</body></methods><methods><class-id>Scripting.ScriptRunner</class-id> <category>compiling</category><body package="ScriptingSupport" selector="compile:">compile: aStream	"Compile the text using a compiler error handler that will ignore certain kinds of errors and not try to do anything at all in the GUI."	| compiler method source|	compiler := Compiler new.	source := self skipOverHashBangInScripts: aStream.	method := compiler		compile: source		in: nil		allowReceiver: true		class: self class		environment: self doitEnvironment		noPattern: true		notifying: nil		ifFail: [nil]		handler: (ScriptingCompilerErrorHandler new runner: self).	method isNil ifFalse: [method sourcePointer: source].	^method.</body><body package="ScriptingSupport" selector="doitEnvironment">doitEnvironment	"We run the scripts in a namespace that behaves in a workspace-like way. That is, it imports all namespaces, and we also use it to store any undeclared variables in the scripts."		| imports |	environment isNil ifFalse: [^environment].	imports := self importsForAllNamespaces.	environment := WorkspaceVariablePool new.	myUndeclareds := NameSpace new.	myUndeclaredsImport := GeneralNameSpaceImport simpleName: 'ScriptUndeclared' in: environment.	imports := imports , (Array with: myUndeclaredsImport).	environment at: #ScriptUndeclared put: myUndeclareds.	environment importsObjects: imports.		"A special flag for a quit 'command'."	environment at: #quit put: Object new.	^environment</body><body package="ScriptingSupport" selector="fileInFrom:">fileInFrom: aStream	| method |	method := self compile: aStream.	method isNil ifTrue: [^nil].	^[[self performMethod: method] 			on: DuplicateBindingsError do: [:ex | ex resume: ex suggestedBinding]] 			on: Error do: [:ex | self reportError: ex].</body><body package="ScriptingSupport" selector="importsForAllNamespaces">importsForAllNamespaces		| allNamespaces |	allNamespaces := Root allNameSpaces copyWithout: Undeclared.	^allNamespaces		collect: [:each | GeneralNameSpaceImport pathString: each fullName]</body><body package="ScriptingSupport" selector="interactiveDebug:">interactiveDebug: anException	"Become headfull and open a regular debugger on the exception."	| debugger |	debugger := Smalltalk at: #DebuggerService ifAbsent: [^false].	HeadlessImage current isHeadless ifTrue: [HeadlessImage current becomeHeadfull].	debugger openOnException: anException.	^true.</body><body package="ScriptingSupport" selector="reportError:">reportError: anException	"Dump the error out to the transcript using the verbose form we get from the debugger, but truncating the stack to only print from the unbound method that is the script forward."	ScriptingSystem current debug ifTrue: [(self interactiveDebug: anException) ifTrue: [^self]].	HeadlessImage current		dumpStackToTranscriptUsingDebuggerService: anException initialContext		label: anException description		stopWhen: [:each | each method isBlockMethod not and: [each method selector = #unboundMethod]].	anException return: nil.</body><body package="ScriptingSupport" selector="skipOverHashBangInScripts:">skipOverHashBangInScripts: aStream	"Given a stream, and if it's at the beginning, if we see it starts with #!, skip to the end of that line, assuming this is the Unix convention of having a line like#!visual"	aStream position = 0 ifFalse: [^aStream contents].	aStream peek = $# ifFalse: [^aStream contents].	aStream next.	aStream peek = $! ifFalse: [aStream reset. ^aStream contents].	aStream skipThrough: Character cr.	^aStream upToEnd.</body><body package="ScriptingSupport" selector="updateImports">updateImports	"Update the doitEnviornment's list of imports.  #addImport will not add pre-existing imports."	environment isNil ifTrue: [^self].	self importsForAllNamespaces do: [:import | environment addImport: import].	"Make sure our undeclared list comes last."	environment removeImport: myUndeclaredsImport.	environment addImport: myUndeclaredsImport.</body></methods><methods><class-id>Scripting.ScriptRunner</class-id> <category>accessing</category><body package="ScriptingSupport" selector="myUndeclareds">myUndeclareds	^myUndeclareds</body><body package="ScriptingSupport" selector="myUndeclareds:">myUndeclareds: aNamespace	myUndeclareds := aNamespace</body></methods><methods><class-id>Scripting.ScriptingConsole</class-id> <category>running</category><body package="ScriptingSupport" selector="bannerString">bannerString	^'Welcome to the interactive Smalltalk console'.</body><body package="ScriptingSupport" selector="commandLoop">commandLoop	prompt		ifTrue:			[Stdout				nextPutAll: self bannerString;				flush].	[true]		whileTrue:			[prompt				ifTrue:					[Stdout						nextPutAll: '] ';						flush].			self runCommand: self getNextLine].</body><body package="ScriptingSupport" selector="getNextLine">getNextLine	"Grab the next line from Stdin. If it ends with a \, then keep appending the next line to it. Otherwise evaluate it."	| line nextLine continued |	line := ''.	Stdin atEnd ifTrue: [ObjectMemory quit].	[nextLine := Stdin through: Character cr.	continued := (nextLine size &gt; 1) and: [(nextLine at: nextLine size - 1)		= self lineContinuationCharacter].	continued ifTrue: [nextLine := nextLine copyFrom: 1 to: nextLine size - 2].	line := line , nextLine.	continued] whileTrue.	^line.</body><body package="ScriptingSupport" selector="lineContinuationCharacter">lineContinuationCharacter	^$\.</body><body package="ScriptingSupport" selector="printResult:">printResult: anObject	"Print the resulting of executing the command. In most cases this is just the printString, but optimize the special cases of self and Transcript"	| string |	string := self specialCasePrintStringFor: anObject.	prompt ifTrue: [Stdout nextPutAll: '=&gt; '].	Stdout nextPutAll: string.	Stdout cr</body><body package="ScriptingSupport" selector="runCommand:">runCommand: aString	"Run the command, and if there's an error, dump a stack. This is probably redundant for most cases, because the scriptRunner also handles errors, but will catch, for example, errors in printString-ing the value."	[| value |	value := scriptRunner fileInFrom: aString readStream.	self printResult: value] 		on: UnhandledException do: [:ex | scriptRunner reportError: ex].</body><body package="ScriptingSupport" selector="specialCasePrintStringFor:">specialCasePrintStringFor: anObject	"If we have a special way of printing some object, or something special to do when we print the object, check for it here."	anObject == Transcript		ifTrue: [^'Transcript'].	"If this is the special quit flag, and the value of that variable hasn't been changed, then quit the image."	(anObject class == Object and: [anObject == (scriptRunner doitEnvironment at: #quit)]) ifTrue: [ObjectMemory quit].	^anObject printString.</body></methods><methods><class-id>Scripting.ScriptingConsole</class-id> <category>accessing</category><body package="ScriptingSupport" selector="prompt">prompt	^prompt</body><body package="ScriptingSupport" selector="prompt:">prompt: anObject	prompt := anObject</body></methods><methods><class-id>Scripting.ScriptingConsole</class-id> <category>initialize-release</category><body package="ScriptingSupport" selector="initialize">initialize	scriptRunner := ScriptRunner new.	prompt := true.</body></methods><methods><class-id>Scripting.ScriptingConsole class</class-id> <category>instance creation</category><body package="ScriptingSupport" selector="new">new	^super new initialize.</body></methods><methods><class-id>Scripting.ScriptingCompilerErrorHandler</class-id> <category>accessing</category><body package="ScriptingSupport" selector="runner">runner	^runner.</body><body package="ScriptingSupport" selector="runner:">runner: scriptRunner	runner := scriptRunner</body></methods><methods><class-id>Scripting.ScriptingCompilerErrorHandler</class-id> <category>error handling</category><body package="ScriptingSupport" selector="addBindingFor:">addBindingFor: association		association key: association key asSymbol.	runner myUndeclareds simpleAddBinding: association.	(runner myUndeclareds bindingFor: association key)		value: association value.	^true.</body><body package="ScriptingSupport" selector="duplicateBindings:in:from:">duplicateBindings: varName in: node from: codeStream	"For duplicate bindings, just use the one the system suggests."	^[runner doitEnvironment bindingFor: varName]		on: DuplicateBindingsError do: [:ex | ex return: ex suggestedBinding].</body><body package="ScriptingSupport" selector="syntaxError:at:">syntaxError: message at: sourcePosition	"On a syntax error, print the source code with the indicator to the output rather than the default of bringing up a window."	|  errorText |	source reset.	errorText := WriteStream on: String new.	errorText 		nextPutAll: 'ERROR: ';		nextPutAll: (source next: sourcePosition - 1);		space; 		nextPutAll: message;		nextPutAll: source upToEnd;		cr;		nextPutAll: '--------------------------------------------------------------------';			cr.	HeadlessImage current stackDumpStream nextPutAll: errorText contents; flush.	^self abort.</body><body package="ScriptingSupport" selector="undeclared:in:from:">undeclared: association in: node from: codeStream	"Automatically declare variables into the scriptRunner's namespace."		^[self addBindingFor: association]		on: Error		do: [:ex | super undeclaredStore: association in: node from: codeStream].</body><body package="ScriptingSupport" selector="undeclaredStore:in:from:">undeclaredStore: association in: assignNode from: codeStream 	"Automatically declare variables into the scriptRunner's namespace."	^[self addBindingFor: association] 			on: Error			do: 				[:ex | 				super 					undeclaredStore: association					in: assignNode					from: codeStream]</body></methods><methods><class-id>Scripting.ScriptingSystem</class-id> <category>initialize/release</category><body package="ScriptingSupport" selector="initialize">initialize	super initialize.	self reset.</body></methods><methods><class-id>Scripting.ScriptingSystem</class-id> <category>accessing</category><body package="ScriptingSupport" selector="argumentsVariableName">argumentsVariableName	"Return the variable name under which we will store the script's arguments (if any) in the namespace in which the script runs."	^'arguments'.</body><body package="ScriptingSupport" selector="commandLine:">commandLine: anObject	commandLine := anObject</body><body package="ScriptingSupport" selector="debug">debug	^debug</body><body package="ScriptingSupport" selector="debug:">debug: anObject	debug := anObject</body><body package="ScriptingSupport" selector="noPrompt">noPrompt	prompt := false.</body><body package="ScriptingSupport" selector="prompt">prompt	^prompt</body><body package="ScriptingSupport" selector="prompt:">prompt: aBoolean	prompt := aBoolean</body><body package="ScriptingSupport" selector="scriptName">scriptName	^scriptName</body><body package="ScriptingSupport" selector="scriptName:">scriptName: aString	scriptName := aString</body><body package="ScriptingSupport" selector="scriptRunner">scriptRunner	scriptRunner isNil ifTrue: [scriptRunner := ScriptRunner new].	^scriptRunner.</body><body package="ScriptingSupport" selector="scriptRunner:">scriptRunner: aScriptRunner	scriptRunner := aScriptRunner.</body><body package="ScriptingSupport" selector="scripts">scripts	"Return our list of scripts. The lazy initialization is important, because 7.5 or earlier with non-shadow loading can cause incorrect initialization when the current system is reset on each instanceMethodsChanged."	^scripts isNil		ifTrue: [scripts := #()]		ifFalse: [scripts]</body><body package="ScriptingSupport" selector="shouldQuit">shouldQuit	"Return a variable indicating if we should quit the image when this system finishes setting up. The lazy initialization is important, because 7.5 or earlier with non-shadow loading can cause incorrect initialization when the current system is reset on each instanceMethodsChanged."	^shouldQuit isNil		ifTrue: [shouldQuit := false]		ifFalse: [shouldQuit]</body><body package="ScriptingSupport" selector="shouldQuit:">shouldQuit: aBoolean	shouldQuit := aBoolean</body></methods><methods><class-id>Scripting.ScriptingSystem</class-id> <category>private-activate/deactivate</category><body package="ScriptingSupport" selector="commandLine">commandLine	"We want the full command line, rather than the one we've overridden in the normal Subsystem code."	commandLine isNil ifTrue: [		commandLine := CEnvironment commandLine].	^commandLine.</body><body package="ScriptingSupport" selector="findCommandLineScript">findCommandLineScript	"Look at the command line for file names directly following the image name when there is no '--' command-line option ."	| position argument |	position := CommandLineInterest new findStartPositionForImageOptionsIn: self commandLine.	position &gt; self commandLine size ifTrue: [^self].	argument := self commandLine at: position .	(argument notEmpty and: [(argument first ~= $-) and: ['*.st' match: argument]])			ifTrue: [				scriptName := argument.				self scriptRunner doitEnvironment 					at: self argumentsVariableName 					put: (self commandLine copyFrom: position + 1 to: self commandLine size).				shouldQuit := true].</body><body package="ScriptingSupport" selector="runActivationActions">runActivationActions	self findCommandLineScript.	super runActivationActions.</body><body package="ScriptingSupport" selector="runScript:">runScript: aFilename	| stream |	[stream := (aFilename asFilename withEncoding: #Source) readStream.	self scriptRunner fileInFrom: stream]		ensure: [stream close].</body></methods><methods><class-id>Scripting.ScriptingSystem</class-id> <category>default actions</category><body package="ScriptingSupport" selector="checkScriptFile">checkScriptFile	scriptName isNil ifTrue: [^self].	scriptName asFilename definitelyExists		ifFalse: [			HeadlessImage current stackDumpStream nextPutAll: 'smalltalk: No such file or directory -- ', scriptName.			HeadlessImage current stackDumpStream cr; cr; flush.			scriptName := nil].</body><body package="ScriptingSupport" selector="pauseAction">pauseAction		"If we're about to save the image, clear out our script options."	super pauseAction.	self reset.</body><body package="ScriptingSupport" selector="quitIfAppropriate">quitIfAppropriate	"If we're at a point where we should now quit the image (because the shouldQuit variable has been set by someone) then quit."	self shouldQuit ifTrue: [ObjectMemory quit].</body><body package="ScriptingSupport" selector="reset">reset	"Reset our variables to make sure we don't somehow save the image with values in them that would be re-run on startup or re-activation of this sytem."	scriptName := nil.	scripts := OrderedCollection new.	shouldQuit := false.	commandLine := nil.	scriptRunner := ScriptRunner new.	debug := false.	useStandardIn := false.	prompt := true.</body><body package="ScriptingSupport" selector="setUp">setUp	"On setup, run our scripts, either from the command line directly, or from files. If we've run some, then quit the image."	super setUp.	self checkScriptFile.	[scriptName isNil ifFalse: [self runScript: scriptName].	useStandardIn ifTrue: [self scriptRunner fileInFrom: Stdin].	self scripts do: [:each | self scriptRunner fileInFrom: each readStream]]		ensure:			[self quitIfAppropriate.			self reset].</body></methods><methods><class-id>Scripting.ScriptingSystem</class-id> <category>command line options</category><body package="ScriptingSupport" selector="runInteractiveConsole">runInteractiveConsole	"Start an interactive console"	| interpreter |	interpreter := ScriptingConsole new.	interpreter prompt: self prompt.	interpreter commandLoop.</body></methods><methods><class-id>Scripting.ScriptingSystem</class-id> <category>prerequisites</category><body package="ScriptingSupport" selector="prerequisiteSystems">prerequisiteSystems	^Array with: RuntimeSystem.</body></methods><methods><class-id>Scripting.ScriptingSystem class</class-id> <category>initialize-release</category><body package="ScriptingSupport" selector="disableHeadlessTranscriptToFile">disableHeadlessTranscriptToFile	HeadlessImage current transcriptToFileHeadless: false.</body><body package="ScriptingSupport" selector="disableHeadlessTranscriptToStdout">disableHeadlessTranscriptToStdout	HeadlessImage current transcriptToStandardOutHeadless: false.</body><body package="ScriptingSupport" selector="initialize">initialize	"self initialize"		self setUpOutput.	(Parcel dependents includes: self)		ifFalse: [Parcel addDependent: self].	(ChangeSet dependents includes: self)		ifFalse: [ChangeSet addDependent: self].	super initialize.</body><body package="ScriptingSupport" selector="obsolete">obsolete	Parcel removeDependent: self.	ChangeSet removeDependent: self.	super obsolete.</body><body package="ScriptingSupport" selector="postLoad:">postLoad: aParcel	"We have been loaded. Our initialization may not get called until much later, if at all, and we need to do these steps early, in case we're being loaded from a parcel."	super postLoad: aParcel.	self setUpOutput.	(ChangeSet dependents includes: self)		ifFalse: [ChangeSet addDependent: self].</body><body package="ScriptingSupport" selector="redirectStackDumpsToStderr">redirectStackDumpsToStderr	HeadlessImage current stackDumpStream: Stderr.</body><body package="ScriptingSupport" selector="setUpOutput">setUpOutput		self disableHeadlessTranscriptToFile.	self disableHeadlessTranscriptToStdout.	self redirectStackDumpsToStderr.</body></methods><methods><class-id>Scripting.ScriptingSystem class</class-id> <category>image preparation</category><body package="ScriptingSupport" selector="prepareScriptingImage">prepareScriptingImage	"Save our an image under the name smalltalk.im which runs headless and will run scripting commands when started up."	"		ScriptingSystem prepareScriptingImage"		self setUpOutput.	^HeadlessImage current saveHeadless: true to: 'smalltalk'.</body></methods><methods><class-id>Scripting.ScriptingSystem class</class-id> <category>updating</category><body package="ScriptingSupport" selector="update:with:from:">update: aSymbol with: arguments from: anObject	"If a namespace is added, add it to our imports, if we have a scriptRunner already set up."	(#(#parcelLoaded #parcelUpdated #loadParcel: #addNameSpace:attributes:)  includes: aSymbol) ifTrue: [		self current scriptRunner isNil ifFalse: [			self current scriptRunner updateImports]].</body></methods><methods><class-id>Core.Association</class-id> <category>scripting</category><body package="ScriptingSupport" selector="&amp;">&amp; anObject	"Create a new collection with anObject appended to it. When sent to an object (including a string), create a new collection containing the two objects. That is, don't concatenate the strings. When sent to an association, it constructs a dictionary. In other cases it creates an Array.	#('zero') &amp; 'one' 	Dictionary new &amp; (3-&gt;4)	(3-&gt;4) &amp; (5-&gt;6)		1 &amp; 2	'abc' &amp; 'def'  "	^Dictionary with: self with: anObject.</body></methods><methods><class-id>Core.Collection</class-id> <category>scripting</category><body package="ScriptingSupport" selector="&amp;">&amp; anObject	"Create a new collection with anObject appended to it. When sent to an object (including a string), create a new collection containing the two objects. That is, don't concatenate the strings. When sent to an association, it constructs a dictionary. In other cases it creates an Array.	#('zero') &amp; 'one' 	Dictionary new &amp; (3-&gt;4)	(3-&gt;4) &amp; (5-&gt;6)		1 &amp; 2	'abc' &amp; 'def'  "	^self copyWith: anObject.</body></methods><methods><class-id>Core.Collection</class-id> <category>adding</category><body package="ScriptingSupport" selector="copyWith:">copyWith: anObject	^self copy add: anObject; yourself.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>accessing</category><body package="ScriptingSupport" selector="stackDumpStream">stackDumpStream	(stackDumpStream isNil or: [(stackDumpStream respondsTo: #closed) and: [stackDumpStream closed]]) ifTrue: [^Transcript].	^stackDumpStream</body></methods><methods><class-id>Core.Subsystem</class-id> <category>private-activate/deactivate</category><body package="ScriptingSupport" selector="basicCommandLine">basicCommandLine	^CEnvironment commandLine.</body><body package="ScriptingSupport" selector="commandLine">commandLine	"We force the command line for other subsystems so that they ignore the script arguments, and the script can define it's own things that shadow base system command-line options if it wants to."	^self basicCommandLine readStream upTo: '--'.</body></methods><methods><class-id>Core.Object</class-id> <category>scripting</category><body package="ScriptingSupport" selector="&amp;">&amp; anObject	"Create a new collection with anObject appended to it. When sent to an object (including a string), create a new collection containing the two objects. That is, don't concatenate the strings. When sent to an association, it constructs a dictionary. In other cases it creates an Array.	#('zero') &amp; 'one' 	Dictionary new &amp; (3-&gt;4)	(3-&gt;4) &amp; (5-&gt;6)		1 &amp; 2	'abc' &amp; 'def'  "	^Array with: self with: anObject.</body></methods><methods><class-id>Kernel.CompilerErrorHandler</class-id> <category>initialize-release</category><body package="ScriptingSupport" selector="environment">environment	^environment.</body></methods><methods><class-id>Kernel.DuplicateBindingsError</class-id> <category>constants</category><body package="ScriptingSupport" selector="defaultResumeValue">defaultResumeValue	"We want to be able to use the suggested binding as the default when we force a resume, not just when the defaultAction runs."	^suggestedBinding.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>scripting</category><body package="ScriptingSupport" selector="&amp;">&amp; anObject	"Create a new collection with anObject appended to it. When sent to an object (including a string), create a new collection containing the two objects. That is, don't concatenate the strings. If you want concatenation, use the $, operator. However, strings are treated specially in that if you &amp; a string and a character, you treat the string as a collection and build a new one including that character. In all other cases, building a new string and concatenating would fail, so we fall back to the object treatment. This is intended for scripting, so we try to do what you mean at the expense of consistency. When sent to an association, it constructs a dictionary. In other cases it creates an Array.	#('zero') &amp; 'one' 	Dictionary new &amp; (3-&gt;4)	(3-&gt;4) &amp; (5-&gt;6)		1 &amp; 2	'abc' &amp; 'def'  	'abc' &amp; $d	'abc' &amp; 4"	^anObject class == Character		ifTrue: [self , (Array with: anObject)]		ifFalse: [Array with: self with: anObject].</body></methods><methods><class-id>Scripting.ScriptingSystem</class-id> <category>command line options</category><body package="ScriptingSupport" selector="e:">e: argumentStream	"Run the (single-line) argument. "	&lt;option: '-e'&gt;	scriptName := nil.	scripts add: argumentStream next.	shouldQuit := true.</body><body package="ScriptingSupport" selector="help:">help: argumentStream	"Print our help for our options."	&lt;option: '-h'&gt;		| stream |	stream := HeadlessImage current stackDumpStream.	stream nextPutAll: 'Usage: vm scripting.im [switches] [--] [programfile] [arguments]'.	stream cr; nextPutAll: '  -e ''command''	One line of script. Several -e''s allowed. Omit programfile]'.	stream cr; nextPutAll: '  -h ''command''	Print this help.'.		stream cr; nextPutAll: '  -i		Start an interactive console'.	stream cr; nextPutAll: '  -noprompt	If in interactive mode, run with no prompt. Otherwise ignored.'.	stream cr; nextPutAll: '  -debug	If we get an error, open a GUI debugger'.	stream cr; nextPutAll: '  -nodebug	If we get an error, do not open a GUI debugger (the default)'.	stream cr; nextPutAll: '  --		Indicates the program file to run. If none, read from stdin.'.	stream cr; cr; flush.	shouldQuit := true.</body><body package="ScriptingSupport" selector="interactive:">interactive: argumentStream	"Start an interactive console"	&lt;option: '-i'&gt;	scripts add: 'ScriptingSystem current runInteractiveConsole'.</body><body package="ScriptingSupport" selector="noPrompt:">noPrompt: argumentStream	"If running an interactive console, don't have a prompt. This is useful for piping in scripts that are to be run line by line."	&lt;option: '-noPrompt'&gt;	&lt;option: '-noprompt'&gt;	self noPrompt.</body><body package="ScriptingSupport" selector="script:">script: argumentStream	"The item following -- in the command line is treated as the program file to run. If there's nothing following, we read standard in for the program."	&lt;option: '--'&gt;	scriptName := argumentStream next.	scriptName isNil ifTrue: [useStandardIn := true].	self scriptRunner doitEnvironment at: self argumentsVariableName put: argumentStream upToEnd.	shouldQuit := true.</body><body package="ScriptingSupport" selector="shouldDebug:">shouldDebug: argumentStream	"Open a debugger when we get an error."	&lt;option: '-debug'&gt;	debug := true.</body><body package="ScriptingSupport" selector="shouldNotDebug:">shouldNotDebug: argumentStream	"Don't open a debugger when we encounter an error."	&lt;option: '-nodebug'&gt;	debug := false.</body></methods><initialize><class-id>Scripting.ScriptingSystem</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>DuplicateBindingsError</name><environment>Kernel</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suggestedBinding </inst-vars><class-inst-vars>ambiguousReferencesExist </class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>HeadlessImage</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isTerminating startupFilename transcriptFilename currentlyHeadless shouldSaveHeadless transcriptToStandardOut transcriptToStandardOutHeadless transcriptToFile transcriptToFileHeadless suspendedProcesses stackDumpStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><class><name>CompilerErrorHandler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failBlock retryBlock class selector errorHandlers environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>NonInteractiveCompilerErrorHandler</name><environment>Kernel</environment><super>Kernel.CompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>