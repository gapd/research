<?xml version="1.0"?><st-source><!-- Name: RBSUnitExtensionsNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This package adds an extension to the Source code tool. Whenever a test case is selected, it allows you to run that test case from the browser.DbIdentifier: bear73DbTrace: 113342DevelopmentPrerequisites: #(#(#any 'Browser-BrowserUI' '') #(#any 'SUnit' ''))PackageName: RBSUnitExtensionsParcel: #('RBSUnitExtensions')ParcelName: RBSUnitExtensionsPrerequisiteParcels: #(#('Browser-BrowserUI' '') #('SUnit' ''))PrintStringCache: (RB4xx - 4,bobw)Version: 7.6Date: 12:52:30 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 12:52:30 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SUnitStatusBar</name><environment>Refactory.Browser</environment><super>UI.Panel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCount defects codeModel </inst-vars><class-inst-vars></class-inst-vars><imports>			private XProgramming.SUnit.*			</imports><category>Browser-Code Tools</category><attributes><package>RBSUnitExtensions</package></attributes></class><comment><class-id>Refactory.Browser.SUnitStatusBar</class-id><body>An addition to the Browser's set of CodeTools.The tool allows Run, Debug, or Profile of concrete subclasses of TestCase, by single or multi-select of individual test selectors, classes, protocols, packages, parcels or categories.  The tool obeys the #isAbstract and #shouldInheritSelectors directives on individual classes, allowing a concrete class to inherit either all or none of the test selectors in its superclass hierarchy (up to, but not including TestCase).Note that the test selector inheritance feature of the TestCase class is, contrary to standard Smalltalk expectations, NOT automatic.  A class must explicitly specify that it is to be considered an abstract test case (#isAbstract) or that, as a concrete class, it wishes to inherit tests from its superclasses (#shouldInheritSelectors).  The directive #shouldInheritSelectors is meaningless (and ignored) for abstract test cases, since their test selectors cannot be run directly from the abstract class.Instance Variables:	codeTool		&lt;CodeTool&gt;					the tool	selectionPolicy	&lt;CodeToolSelectionPolicy&gt;	the corresponding selectionPolicy</body></comment><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>updating</category><body package="RBSUnitExtensions" selector="debugButton">debugButton	^self partAt: 5</body><body package="RBSUnitExtensions" selector="listDefectsButton">listDefectsButton	^self partAt: 3</body><body package="RBSUnitExtensions" selector="profileButton">profileButton	^self partAt: 4</body><body package="RBSUnitExtensions" selector="runButton">runButton	^self partAt: 6</body><body package="RBSUnitExtensions" selector="runDefectsButton">runDefectsButton	^self partAt: 2</body><body package="RBSUnitExtensions" selector="setTestLabel:">setTestLabel: aString	| widget |	widget := self labelWidget.	widget widget labelString: aString.	widget repairDamage</body><body package="RBSUnitExtensions" selector="touch">touch	self		updateTestLabel;		updateButtons;		updateIsActive</body><body package="RBSUnitExtensions" selector="update:with:from:">update: aspectSymbol with: parameter from: sender	(testCount notNil and: [testCount &gt; 0]) ifTrue:		[testCount := testCount - 1.		self setTestLabel: ((#TestsRemaining1p &lt;&lt; #browser &gt;&gt; 'Tests Remaining : &lt;1p&gt;') expandMacrosWith: testCount)].</body><body package="RBSUnitExtensions" selector="updateButtons">updateButtons	self		updateRunButtons;		updateDefectButtons</body><body package="RBSUnitExtensions" selector="updateDefectButtons">updateDefectButtons	| enable |	enable := self defectsExist.	self runDefectsButton isEnabled: enable.	self listDefectsButton isEnabled: enable</body><body package="RBSUnitExtensions" selector="updateIsActive">updateIsActive	| isCurrentlyActive |	isCurrentlyActive := self canRunTests.	isCurrentlyActive = (self propertyAt: #isActive) ifTrue: [^self].	self propertyAt: #isActive put: isCurrentlyActive.	self changedPreferredBounds: nil</body><body package="RBSUnitExtensions" selector="updateRunButtons">updateRunButtons	| canRun |	canRun := self canRunTests.	self profileButton isEnabled: (canRun and: [self isProfilerLoaded]).	self debugButton isEnabled: canRun.	self runButton isEnabled: canRun</body><body package="RBSUnitExtensions" selector="updateTestLabel">updateTestLabel	| label |	self isAbstractClassSelected		ifTrue: [ 			self updateForAbstract.			label := (#NotRunAbstractTest &lt;&lt; #browser &gt;&gt; 'Abstract test class, cannot run') ] 		ifFalse: [			self updateForNotRun.			label := (#NotRunC1pTests &lt;&lt; #browser &gt;&gt; 'Not run: &lt;1p&gt; tests') 							expandMacrosWith: self testCases size ].	self setTestLabel: label</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>private</category><body package="RBSUnitExtensions" selector="classTestCases">classTestCases	"Answer all runnable test cases for the selected class or classes."	^self testCasesFor: codeModel selectedClasses.</body><body package="RBSUnitExtensions" selector="parcelTestCases">parcelTestCases	"Answer all runnable test cases for all classes in			the selected parcel or parcels."	^codeModel parcels		inject: Set new		into:			[:sum :eachPundle | 			sum				addAll: (self testCasesFor: eachPundle definedClasses);				yourself]</body><body package="RBSUnitExtensions" selector="parcelTestCasesExist">parcelTestCasesExist	"Answer if runnable test cases exist in any classes in the selected parcel or parcels."	^codeModel parcels anySatisfy:		[:any |		self testCasesExistInAny: any definedClasses]</body><body package="RBSUnitExtensions" selector="protocolTestCases">protocolTestCases	"Answer all runnable test cases for the selected protocol or protocols."	codeModel selectedClass ifNil: [^OrderedCollection new].	^codeModel protocols		inject: Set new		into:			[:sum :each | 			sum				addAll:						(self								testCasesForSelectors:									(self										testSelectorsForClass: codeModel selectedClass										protocol: each));				yourself]</body><body package="RBSUnitExtensions" selector="pundleTestCases">pundleTestCases	"Answer all runnable test cases for all classes in			the selected pundle or pundles."	^codeModel pundles		inject: Set new		into:			[:sum :eachPundle | 			sum				addAll: (self testCasesFor: eachPundle definedClasses);				yourself]</body><body package="RBSUnitExtensions" selector="pundleTestCasesExist">pundleTestCasesExist	"Answer if runnable test cases exist in classes in the selected pundle or pundles."	^codeModel pundles anySatisfy:		[:any |		self testCasesExistInAny: any definedClasses]</body><body package="RBSUnitExtensions" selector="selectorTestCases">selectorTestCases	"Answer all runnable test cases for the selected selectors."	^self testCasesForSelectors: codeModel selectors</body><body package="RBSUnitExtensions" selector="setFailedLabel">setFailedLabel	self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed').	self updateForFailed</body><body package="RBSUnitExtensions" selector="setLabelColor:">setLabelColor: aColorValue	| label |	label := self labelWidget.	label		lookPreferences: (label lookPreferences backgroundColor: aColorValue)</body><body package="RBSUnitExtensions" selector="setPassedLabel">setPassedLabel	self setTestLabel: (#Passed &lt;&lt; #browser &gt;&gt; 'Passed').	self updateForPassed</body><body package="RBSUnitExtensions" selector="testCases">testCases	codeModel selector notNil ifTrue: [^self selectorTestCases].	codeModel protocol notNil ifTrue: [^self protocolTestCases].	codeModel selectedClass notNil ifTrue: [^self classTestCases].	codeModel parcel notNil ifTrue: [^self parcelTestCases].	codeModel pundle notNil ifTrue: [^self pundleTestCases].	^#()</body><body package="RBSUnitExtensions" selector="testCasesExistInAny:">testCasesExistInAny: classesCollection	"Answer if there are any test cases in the classes listed in the argument."	^classesCollection anySatisfy:		[:any | (self testSelectorsForClass: any) notEmpty]</body><body package="RBSUnitExtensions" selector="testCasesFor:">testCasesFor: classesCollection	"Answer all runnable test cases for the collection of classes."	^classesCollection 		inject: Set new		into: 			[:sum :each | 			sum				addAll: ((self testSelectorsForClass: each) collect: [:sel | each selector: sel]);				yourself]</body><body package="RBSUnitExtensions" selector="testCasesForSelectors:">testCasesForSelectors: selectors 	| testSelectors |	testSelectors := self testSelectorsForClass: codeModel selectedClass.	^(selectors select: [:each | testSelectors includes: each]) 		collect: [:each | codeModel selectedClass selector: each]</body><body package="RBSUnitExtensions" selector="testSelectorsForClass:">testSelectorsForClass: aClass	"Answer an OrderedCollection of runnable test selectors for aClass,		obeying the #isAbstract and #shouldInheritSelectors designation,		provided it is a subclass of TestCase."	^ ((aClass inheritsFrom: TestCase) not or: [ aClass isAbstract ])			ifTrue: [ OrderedCollection new ]			ifFalse: [ aClass shouldInheritSelectors				ifTrue: [aClass allTestSelectors]				ifFalse: [aClass testSelectors] ].</body><body package="RBSUnitExtensions" selector="testSelectorsForClass:protocol:">testSelectorsForClass: aClass protocol: aProtocol	"Answer an OrderedCollection of runnable test selectors in aProtocol for aClass,		obeying the #isAbstract and #shouldInheritSelectors designation,		provided it is a subclass of TestCase."	^((aClass inheritsFrom: TestCase) not or: [aClass isAbstract])		ifTrue: [OrderedCollection new]		ifFalse:			[aClass shouldInheritSelectors				ifTrue:					[(aClass withAllSuperclasses)						removeAll: TestCase withAllSuperclasses;						inject: Set new							into:								[:sum :each | 								sum									addAll: (codeModel environment selectorsFor: aProtocol in: each);									yourself]]				ifFalse: [codeModel environment selectorsFor: aProtocol in: aClass]]</body><body package="RBSUnitExtensions" selector="updateForAbstract">updateForAbstract	self setLabelColor: nil</body><body package="RBSUnitExtensions" selector="updateForFailed">updateForFailed	self setLabelColor: ColorValue red</body><body package="RBSUnitExtensions" selector="updateForNotRun">updateForNotRun	self setLabelColor: nil</body><body package="RBSUnitExtensions" selector="updateForPassed">updateForPassed	self setLabelColor: ColorValue green.	defects := nil</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>initialize-release</category><body package="RBSUnitExtensions" selector="actionDriver:">actionDriver: anActionSelector	^(PluggableAdaptor on: false asValue)		getBlock: [:m | m value]		putBlock: [:m :v | self perform: anActionSelector]		updateBlock: [:m :a :p | true]</body><body package="RBSUnitExtensions" selector="addButtons">addButtons	| button |	#(#runDefects #listDefects #profileTests #debugTests #runTests)		with: #('Run Defects' 'List Defects' 'Profile' 'Debug' 'Run')		do:			[:action :label | 			button := self lookPolicy actionButtonClass model: (self actionDriver: action).			button labelString: action &gt;&gt; label &lt;&lt; #browser.			self add: button].	self subparts last beDefault</body><body package="RBSUnitExtensions" selector="addLabel">addLabel	| label |	label := self lookPolicy passiveLabelClass new.	label widgetState isOpaque: true.	self add: ((WidgetWrapper on: label) widget: label)</body><body package="RBSUnitExtensions" selector="buttonCount">buttonCount	^self subparts size - 1 max: 0</body><body package="RBSUnitExtensions" selector="codeModel:">codeModel: aCodeModel	codeModel := aCodeModel</body><body package="RBSUnitExtensions" selector="initialize">initialize	super initialize.	self setLayout.	self addLabel.	self addButtons.	self setDesiredHeight.	self propertyAt: #row put: -1</body><body package="RBSUnitExtensions" selector="setDesiredHeight">setDesiredHeight	| maxHeight |	maxHeight := (self subparts collect: [:each | each preferredBounds height])		fold: [:a :b | a max: b].	self propertyAt: #desiredHeight put: maxHeight</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>actions</category><body package="RBSUnitExtensions" selector="debugTests">debugTests	| failed |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Debugging &lt;&lt; #browser &gt;&gt; 'Debugging').	failed := false.	testCount := self testCases size.	[[self testCases do: 		[:each | 		each debug.			(testCount notNil and: [testCount &gt; 0]) ifTrue:			[testCount := testCount - 1.			self setTestLabel: ((#TestsRemaining1p &lt;&lt; #browser&gt;&gt; 'Tests Remaining : &lt;1p&gt;') expandMacrosWith: testCount)]]] 		on: TestResult failure , TestResult error		do: 			[:ex | 			failed := true.			ex pass]] 			ifCurtailed: [self setFailedLabel].	failed ifTrue: [self setFailedLabel] ifFalse: [self setPassedLabel]</body><body package="RBSUnitExtensions" selector="listDefects">listDefects	| testToDebug |	(defects isNil or: [defects isEmpty]) ifTrue: [^self].	testToDebug := Dialog 		choose: (#ChooseATestToDebug &lt;&lt; #browser &gt;&gt; 'Choose A Test To Debug')		fromList: (defects collect: [:each | each printString])		values: defects		lines: 8 		cancel: []		for: Dialog defaultParentWindow.	testToDebug ifNotNil: [:value | value debug]</body><body package="RBSUnitExtensions" selector="profileTests">profileTests	| profiler |	profiler := #{TimeProfiler} valueOrDo: [nil].	profiler isNil 		ifTrue: [^self warn: (#ProfilerNotLoadedLoad &lt;&lt; #browser &gt;&gt; 'Profiler not loaded. Load the "AT Profiling" parcel.')].	profiler profile: [self runTests]</body><body package="RBSUnitExtensions" selector="runDefects">runDefects	| suite result |	(defects isNil or: [defects isEmpty]) ifTrue: [^self].	suite := TestSuite new.	defects do: [:each | suite addTest: each].	testCount := defects size.	suite addDependent: self.	result := [suite run] ifCurtailed: [self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed')].	self 		setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'				expandMacrosWith: result hasPassed				with: result runCount				with: result failureCount				with: result errorCount).	codeModel navigate.	result hasPassed 		ifTrue: [self updateForPassed]		ifFalse: 			[defects := result defects.			self updateForFailed].	self updateDefectButtons</body><body package="RBSUnitExtensions" selector="runTests">runTests	| suite result |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Running &lt;&lt; #browser &gt;&gt; 'Running').	suite := TestSuite new.	self testCases do: [:each | suite addTest: each].	testCount := self testCases size.	suite addDependent: self.	result := [suite run] ifCurtailed: 		[self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed')].	self 		setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'				expandMacrosWith: result hasPassed				with: result runCount				with: result failureCount				with: result errorCount).	codeModel navigate.	result hasPassed 		ifTrue: [self updateForPassed]		ifFalse: 			[defects := result defects.			self updateForFailed].	self updateDefectButtons</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>testing</category><body package="RBSUnitExtensions" selector="canRunTests">canRunTests	^self isAbstractClassSelected not and: [self testCasesExist]</body><body package="RBSUnitExtensions" selector="codeComponentIncludesTest:">codeComponentIncludesTest: aCodeComponent 	^aCodeComponent definedClasses anySatisfy: [:each | each inheritsFrom: TestCase]</body><body package="RBSUnitExtensions" selector="defectsExist">defectsExist	^defects notNil and: [defects notEmpty]</body><body package="RBSUnitExtensions" selector="hasTestsSelected">hasTestsSelected	(codeModel selectedClasses 		anySatisfy: [:each | each inheritsFrom: TestCase]) ifTrue: [^true].	codeModel objectNames notEmpty ifTrue: [^false].	(codeModel parcels 		anySatisfy: [:each | self codeComponentIncludesTest: each]) ifTrue: [^true].	^codeModel pundles 		anySatisfy: [:each | self codeComponentIncludesTest: each]</body><body package="RBSUnitExtensions" selector="isAbstractClassSelected">isAbstractClassSelected	^codeModel selectedClass notNil		and:			[(codeModel selectedClass respondsTo: #isAbstract)				and: [codeModel selectedClass isAbstract]]</body><body package="RBSUnitExtensions" selector="isProfilerLoaded">isProfilerLoaded	#{TimeProfiler} valueOrDo: [^false].	^true</body><body package="RBSUnitExtensions" selector="shouldNotRunTests">shouldNotRunTests	^self canRunTests not</body><body package="RBSUnitExtensions" selector="testCasesExist">testCasesExist	codeModel selector notNil ifTrue: [^self selectorTestCases notEmpty].	codeModel protocol notNil ifTrue: [^self protocolTestCases notEmpty].	codeModel selectedClass notNil ifTrue: [^self classTestCases notEmpty].	codeModel parcel notNil ifTrue: [^self parcelTestCasesExist].	codeModel pundle notNil ifTrue: [^self pundleTestCasesExist].	^false</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>accessing</category><body package="RBSUnitExtensions" selector="labelWidget">labelWidget	^components first</body><body package="RBSUnitExtensions" selector="lookPolicy">lookPolicy	^self widgetPolicy lookPolicyClass new</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>displaying</category><body package="RBSUnitExtensions" selector="displayOn:">displayOn: aGC	self canRunTests ifTrue: [super displayOn: aGC]</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>private-layout</category><body package="RBSUnitExtensions" selector="boxForButtonAt:in:">boxForButtonAt: index in: rectangle	| width |	width := self buttonWidthIn: rectangle.	^(rectangle right - ((self subparts size - index + 1) * width))		@ rectangle top extent: width @ rectangle height</body><body package="RBSUnitExtensions" selector="boxForLabelIn:">boxForLabelIn: rectangle	^rectangle origin		corner:			(rectangle right - (self buttonCount * (self buttonWidthIn: rectangle)))				@ rectangle bottom</body><body package="RBSUnitExtensions" selector="buttonWidthIn:">buttonWidthIn: aRectangle	| width |	aRectangle width isZero ifTrue: [^0].	width := self defaultButtonWidth.	width * self subparts size &gt; aRectangle width		ifTrue: [^aRectangle width / self subparts size].	^width</body><body package="RBSUnitExtensions" selector="defaultButtonWidth">defaultButtonWidth	^(self subparts allButFirst: 1)		inject: 0		into: [:accum :each | accum max: each preferredBounds width]</body><body package="RBSUnitExtensions" selector="setLayout">setLayout	self		partFramingBlock:			[:rectangle :part :index | 			index = 1				ifTrue: [self boxForLabelIn: rectangle]				ifFalse: [self boxForButtonAt: index in: rectangle]]</body></methods><methods><class-id>Refactory.Browser.CodeModel class</class-id> <category>status parts</category><body package="RBSUnitExtensions" selector="sunitStatusBarClass">sunitStatusBarClass	&lt;status&gt;	^SUnitStatusBar</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Panel</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layoutAlgorithm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-BaseUI</package></attributes></class></st-source>