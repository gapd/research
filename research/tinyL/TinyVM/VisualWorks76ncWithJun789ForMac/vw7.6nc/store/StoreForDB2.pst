<?xml version="1.0"?><st-source><!-- Name: StoreForDB2Notice: Copyright © 2008 Cincom Systems, Inc.  All Rights Reserved.Comment: The DB2/UDB Connect, originally written by Anthony Boris <anthonyvb@yandex.ru>.This parcel contains the interface that allows StORE to work with a DB2/UDB database (7.x and higher). - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Copyright: The contents of this file are subject to the ParcPlace Public License Version 1.0 (the "License"); you may not use this file except incompliance with the License. You may obtain a copy of the License at http://www.parcplace.com/support/opensource/PPL-1.0.htmlSoftware distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. Seethe License for the specific language governing rights and limitations under the License.The Original Code is the DB2/UDB Connect.The Initial Developer of the Original Code is Anthony Boris.Portions created by Anthony Boris are Copyright (C) 2000-2005. All Rights Reserved.Contributor(s): Anthony BorisDbIdentifier: bear73DbTrace: 73708DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'DB2EXDI' '') #(#any 'StoreBase' ''))PackageName: StoreForDB2Parcel: #('StoreForDB2')ParcelName: StoreForDB2PrerequisiteParcels: #(#('Database' '') #('DB2EXDI' '') #('StoreBase' ''))PrintStringCache: (1.0,yli)Version: 7.6Post-Load Block: 	[ :pkg |  Store.DB2Broker initialize.]Date: 1:13:03 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 1:13:03 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DB2SQLAssist</name><environment>Store</environment><super>Store.SQLAssist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB2</category><attributes><package>StoreForDB2</package></attributes></class><comment><class-id>Store.DB2SQLAssist</class-id><body>Sql generator for DB2/UDB 7.1</body></comment><class><name>DB2SQLAssist72</name><environment>Store</environment><super>Store.DB2SQLAssist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB2</category><attributes><package>StoreForDB2</package></attributes></class><comment><class-id>Store.DB2SQLAssist72</class-id><body>Sql generator for DB2/UDB 7.2</body></comment><class><name>DB2Broker</name><environment>Store</environment><super>Store.SQLBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB2</category><attributes><package>StoreForDB2</package></attributes></class><comment><class-id>Store.DB2Broker</class-id><body>Interface to DB2/UDB database.Class Variables:	Signals	&lt;ExceptionSet of signals&gt;  DB2 signals.</body></comment><class><name>DB2Broker72</name><environment>Store</environment><super>Store.DB2Broker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB2</category><attributes><package>StoreForDB2</package></attributes></class><comment><class-id>Store.DB2Broker72</class-id><body>Interface to DB2/UDB 7.2 database.Class Variables:	Signals	&lt;ExceptionSet of signals&gt;  DB2 signals.</body></comment><class><name>DB2Connection72</name><environment>Smalltalk</environment><super>Database.DB2Connection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB2</category><attributes><package>StoreForDB2</package></attributes></class><shared-variable><name>MaxLongBytes</name><environment>Store.DB2Broker</environment><private>false</private><constant>false</constant><category>properties</category><initializer>3990</initializer><attributes><package>StoreForDB2</package></attributes></shared-variable><shared-variable><name>Signals</name><environment>Store.DB2Broker</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>StoreForDB2</package></attributes></shared-variable><shared-variable><name>UseTableSpaceSpecification</name><environment>Store.DB2Broker</environment><private>false</private><constant>false</constant><category>properties</category><initializer>false</initializer><attributes><package>StoreForDB2</package></attributes></shared-variable><shared-variable><name>IdentityOption</name><environment>Store.DB2Broker</environment><private>false</private><constant>false</constant><category>properties</category><attributes><package>StoreForDB2</package></attributes></shared-variable><methods><class-id>Store.DB2SQLAssist</class-id> <category>special</category><body package="StoreForDB2" selector="recordsWithSourcesIn:butNotIn:">recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey "copied from ViewRecord&gt;&gt;recordsWithSourcesIn: butNotIn: "	| table2 |	self selectAll;		where;		column: #packageRef equalTo: aPrimaryKey printString;		and;  column: #primaryKey; in;		beginClause;		addString:			( tableClass subCollectionClass newSQL 			alias: 'T1';			select: ( Array with: tableClass childReference );			leftJoin: (table2 := tableClass subCollectionClass newSQL alias: 'T2');				column: tableClass childReference equalTo: (table2 joinedColumn: tableClass childReference);				and;				addString: (table2 joinedColumn: #packageRef);				equal;				addString: (bPrimaryKey printString);			where;			column: #packageRef equalTo: aPrimaryKey printString;			and;			addString: (table2 joinedColumn: tableClass childReference);			isNull)		endClause;		yourself.	^ sqlStream contents</body></methods><methods><class-id>Store.DB2SQLAssist</class-id> <category>private</category><body package="StoreForDB2" selector="removePrimaryKeyColumn:">removePrimaryKeyColumn: anArray" In DB2 v7 #PrimaryKey column is identity type. It will be inserted automaticaly"	^ anArray select: [ :col | 		(col equivalentTo: 'primarykey' ignoreCase:  true) not ]</body><body package="StoreForDB2" selector="removePrimaryKeyValue:">removePrimaryKeyValue: anArray" In DB2 v7 #PrimaryKey column is identity type. It will be inserted automaticaly"	^ anArray select: [ :col | 		(col equivalentTo: ':primarykey' ignoreCase:  true) not ]</body><body package="StoreForDB2" selector="valuesFor:">valuesFor: aValuesString	sqlStream nextPutAll: ' VALUES ( ', aValuesString, ' )'.	^sqlStream contents</body></methods><methods><class-id>Store.DB2SQLAssist72</class-id> <category>private</category><body package="StoreForDB2" selector="removePrimaryKeyColumn:">removePrimaryKeyColumn: anArray" In DB2 v7 #PrimaryKey column is identity type. It will be inserted automaticaly"	^ anArray</body><body package="StoreForDB2" selector="removePrimaryKeyValue:">removePrimaryKeyValue: anArray" In DB2 v7 #PrimaryKey column is identity type. It will be inserted automaticaly"	^ anArray</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>create objects</category><body package="StoreForDB2" selector="addIdentityFor:">addIdentityFor: aColumn	" For #PrimaryKey columns we add identity property. 	Identity columns are commonly used in conjunction with PRIMARY KEY constraints to serve as the unique row identifier for the table. "	^ (aColumn equivalentTo: 'primarykey' ignoreCase:  true)		ifTrue: [' GENERATED ', IdentityOption key, ' AS IDENTITY (START WITH ', IdentityOption value printString,' )']		ifFalse: [ String new]</body><body package="StoreForDB2" selector="addPrimaryKey:onTable:">addPrimaryKey: aKeyString onTable: aTableName	"Add primary key constraint on table"	self performCreate: [	self processSQL: 'ALTER TABLE ', aTableName, ' ADD CONSTRAINT  PK PRIMARY KEY (' , aKeyString, ')']		for: aTableName</body><body package="StoreForDB2" selector="createDatabaseSequence:">createDatabaseSequence: aClass " Do nothing "</body><body package="StoreForDB2" selector="createDatabaseTable:">createDatabaseTable: aClass 	"Create a new table."	| aKeyCollection aStream pkStream columnsString |	aKeyCollection := OrderedCollection new.	aStream := (String new: 100) writeStream.	aStream nextPutAll: (self createDatabaseTableColumnsFor: aClass				keyNames: aKeyCollection).	"aStream nextPutAll: (self createTablePrimaryKeySectionFor: aClass keys: aKeyCollection)."	aStream skip: -2.	columnsString := ' ( ' , aStream contents , ' ) '.	UseTableSpaceSpecification 				ifTrue: 					[columnsString := columnsString , ' in ' , aClass db2TableSpaceName , ' index in ' 						, aClass db2TableSpaceName].	self createTable: (self fullTableName: aClass) columns: columnsString.	pkStream := (String new: 100) writeStream.	aKeyCollection do: [:each | pkStream nextPutAll: each , ', '].	pkStream skip: -2.	self 		createUniqueIndex: (self tableName: aClass) , '_PK'		onTable: (self tableNameWithPrefix: aClass)		columns: pkStream contents.	self addPrimaryKey: pkStream contents		onTable: (self tableNameWithPrefix: aClass)</body><body package="StoreForDB2" selector="createDatabaseTableColumnsFor:keyNames:">createDatabaseTableColumnsFor: aClass keyNames: aKeyCollection	"Creates column list for a new table."	| fdTypes stringMap aStream aType str |	stringMap := self typeToStringMap.	fdTypes := aClass fieldTypes.	aStream := (String new: 100) writeStream.	aStream cr.	aClass columnNames		do: 			[:each | 			aType := fdTypes at: each ifAbsent: [#String].			(self isPrimaryKeyType: aType) ifTrue: [aKeyCollection addLast: each].			aStream nextPutAll: '     ', each , '  ' , (stringMap at: aType).			aStream nextPutAll: ( self addIdentityFor: each).			aStream nextPutAll:  ', '; cr].	"currently, we are add primary key later"	"aKeyCollection isEmpty 		ifTrue:			[aStream skip: -2.			aStream nextPut: $ .]."	aStream skip: -2. 	aStream nextPut: $ .	str := aStream contents.	aClass name =  #FileRecord ifTrue: [str := str copyReplaceAll: '3990' with: '3000'].	^ str.</body><body package="StoreForDB2" selector="createIndex:onTable:columns:">createIndex: indName onTable: aTable columns: aNameCollection	"Length of indexname in DB2 limited 18 chars. Don't best, but it work"	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE INDEX ' , (self db2IndexName: indName), ' ON ' , aTable, ' ( '.	aNameCollection 		do: [ :each | aStream nextPutAll: each, ', ' ].	aStream skip: -2.	aStream nextPutAll: ' )'.	self performCreate: [ self processSQL: aStream contents. ]		for: (aTable, '  ', indName)</body><body package="StoreForDB2" selector="createPhysicalSpaces">createPhysicalSpaces	^self installPhysicalSpaces</body><body package="StoreForDB2" selector="createSourcesViewForClass:">createSourcesViewForClass: aClass	self createView: (self tableNameWithPrefix: aClass)		selectStatement: (self createViewSelectWithSourcesSQLForClass: aClass).	self grantForClass: aClass  permissions: #('SELECT')  toUsers: #('PUBLIC').</body><body package="StoreForDB2" selector="createUniqueIndex:onTable:columns:">createUniqueIndex: indName onTable: aTable columns: aString	| aStream | 	aStream:=(String new: 100) writeStream.	aStream nextPutAll: 'CREATE UNIQUE INDEX ' ,  (self db2IndexName: indName), ' ON ' , aTable, ' ( ', aString, ')' .	self == DB2Broker ifTrue: [aStream nextPutAll: ' ALLOW REVERSE SCANS ' ]. "best access plan for 'select max(primaryKey)' expression"	self performCreate: [ self processSQL: aStream contents]		for: (aTable, '  ', indName)</body><body package="StoreForDB2" selector="createViewForClass:">createViewForClass: aClass	self createView: ( self tableNameWithPrefix: aClass)			selectStatement: (self createViewSelectSQLForClass: aClass).</body><body package="StoreForDB2" selector="installPhysicalSpaces">installPhysicalSpaces	^true</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>error handling</category><body package="StoreForDB2" selector="alreadyExistErrors">alreadyExistErrors	^ Array with: self objectAlreadyExistisErrorNumber			with: self indexAlreadyInTableErrorNumber			with: self primaryKeyAlreadyInTableErrorNumber</body><body package="StoreForDB2" selector="brokerSignals">brokerSignals	^Signals isNil 		ifTrue: [ Signals := self signalCollection]		ifFalse: [ Signals ]</body><body package="StoreForDB2" selector="doesNotExistErrors">doesNotExistErrors	^ Array with: self objectAlreadyGoneErrorNumber</body><body package="StoreForDB2" selector="indexAlreadyInTableErrorNumber">indexAlreadyInTableErrorNumber	^605</body><body package="StoreForDB2" selector="objectAlreadyExistisErrorNumber">objectAlreadyExistisErrorNumber	^ -601</body><body package="StoreForDB2" selector="objectAlreadyGoneErrorNumber">objectAlreadyGoneErrorNumber	^-204</body><body package="StoreForDB2" selector="primaryKeyAlreadyInTableErrorNumber">primaryKeyAlreadyInTableErrorNumber	^-624</body><body package="StoreForDB2" selector="signalCollection">signalCollection	^ ( ExceptionSet new: 4) 					add: self connectionClass unableToExecuteSQLSignal;		add: self connectionClass connectionNotOpenSignal;		add: self connectionClass externalDatabaseInformationSignal;		add: self connectionClass unableToPrepareSignal;		yourself</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>connection class</category><body package="StoreForDB2" selector="connectionClass">connectionClass	^DB2Connection</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>version</category><body package="StoreForDB2" selector="copyright">copyright	^'The "Store for DB2/UDB" allow use StORE with DB2/UDB for code storage.	Copyright (C) 2000-2003  Anthony Boris (avb@cssc.tat.ru)'</body><body package="StoreForDB2" selector="softwareVersion">softwareVersion		^'Store for DB2/UDB version 7.2 (DB2/UDB Connect edition)'</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>accessing</category><body package="StoreForDB2" selector="databaseName">databaseName	^'DB2/UDB'</body><body package="StoreForDB2" selector="fullTableName:">fullTableName: aClass	^self tableNameWithPrefix: aClass</body><body package="StoreForDB2" selector="getBlobData:">getBlobData: aData	^aData</body><body package="StoreForDB2" selector="indexNameFor:">indexNameFor: aClass	^(self tableNameWithPrefix: aClass), aClass indexName.</body><body package="StoreForDB2" selector="maxLongBytes">maxLongBytes	^MaxLongBytes</body><body package="StoreForDB2" selector="maxLongBytes:">maxLongBytes: aNumber"Set max size of 'Blob' fields: for example - 	3990 for 4K pages;	8000 for 8K pages;	16000 for 16K pages;	32000 for 32K pages"	MaxLongBytes := aNumber</body><body package="StoreForDB2" selector="maxSqlString">maxSqlString	"Answer the maximum length of a sql string"	^32000</body><body package="StoreForDB2" selector="needsSequenceFor:">needsSequenceFor: aClass	"false for v7 "	^false</body><body package="StoreForDB2" selector="sequenceGeneratorSession:forClass:">sequenceGeneratorSession: session forClass: aClass	^self safelyExecuteBlock: [		session isNil			ifTrue: 				[ | newSession |				newSession := self getNewSession.				newSession bindOutput: nil;					bindInput: nil;					prepare: ( self nextIDQuery: aClass );					blockFactor: 1.				newSession				]			ifFalse:				[ session ]	]</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>private</category><body package="StoreForDB2" selector="db2IndexName:">db2IndexName: aName	"length of index name limited 18 chars "	^self tablePrefix, '.', (aName copyFrom: 1 to: (18 min: aName size))</body><body package="StoreForDB2" selector="initialize">initialize	"self initialize"	super initialize.	self dontUseTableSpaceSpecification.	IdentityOption := 'ALWAYS' -&gt; 1	"option-&gt;start value"</body><body package="StoreForDB2" selector="runStatsFor:">runStatsFor: aClass	DB2Manager new runStats: (self fullTableName: aClass) statsOption: #SQL_STATS_ALL shared: true indexes: nil</body><body package="StoreForDB2" selector="typeToStringMap">typeToStringMap	^( Dictionary new)		 at: #String put: 'varchar (255) ';		 at: #PrimaryKey put: 'int not null';		 at: #PrimaryKeyInteger put: 'int not null';		 at: #PrimaryKeyString put: 'varchar (255) not null';		 at: #PrimaryKeyShortString put: 'varchar (50) not null';		 at: #PrimaryKeyChar put: 'char(1) not null';		 at: #Text put: 'long varchar ';		 at: #Long put: 'int ';		 at: #BinData put: ('varchar(&lt;1p&gt;) for bit data ' expandMacrosWith: self maxLongBytes);		 at: #Integer put: 'int ';		 at: #Char put: 'char(1)';		 at: #String32 put: 'varchar (32)' ;		yourself.</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>private-accessing</category><body package="StoreForDB2" selector="dismissSession:">dismissSession: aSession	^ aSession dismiss</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>services</category><body package="StoreForDB2" selector="dontUseTableSpaceSpecification">dontUseTableSpaceSpecification	UseTableSpaceSpecification := false.</body><body package="StoreForDB2" selector="extendTablespaces">extendTablespaces"grow tablespace container size""self extendTablespaces"DbRegistry reconnect: true.[ 	 Transcript show: 'Grow tablespace conatiner size  ' ; cr.		self  processSQL: 'ALTER TABLESPACE NEWBERN1 EXTEND  (ALL 20 M )'.		self  processSQL: 'ALTER TABLESPACE NEWBERN2 EXTEND  (ALL 20 M )'.	] 	on: Error 	do: [ :exp |   Transcript show: exp description.  ^true].	^true.</body><body package="StoreForDB2" selector="updateStatistics">updateStatistics	"self updateStatistics"	DbRegistry reconnect: true.	Transcript show: 'Collect statistics...'; cr.	DbRegistry connection begin.	Package dbTables do: 			[:aClass | 			Transcript				show: 'RUNSTATS ON ' , aClass name; cr.			self runStatsFor: aClass].	DbRegistry connection commit.	Transcript show: 'Done !'; cr.</body><body package="StoreForDB2" selector="useTableSpaceSpecification">useTableSpaceSpecification	UseTableSpaceSpecification := true.</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>drop objects</category><body package="StoreForDB2" selector="dropDatabase:">dropDatabase: dbName	(Dialog confirm: 'Drop tablespace ', dbName, '?') ifFalse: [^true].	Transcript show: 'Dropping tablespace ' , dbName; cr.	[		self processSQL:  ('DROP TABLESPACE ' , dbName) asString.		Transcript show: 'Tablespace dropped'; cr.	]	on: 	Error	do: [ :exception | | err | 			(( err := exception parameter first ) notNil			and: [ err dbmsErrorCode == self objectAlreadyGoneErrorNumber])				ifTrue: 					[  Dialog warn: (self messageFor: exception). 					exception return]. "pass ? "		Dialog warn: (self messageFor: exception).	]</body><body package="StoreForDB2" selector="dropDatabaseFor:">dropDatabaseFor: aClass	"need more work - when used existing tablespaces named distinct from NEWBERN1/2 this don't work"	self dropDatabase: aClass databaseName.</body><body package="StoreForDB2" selector="dropIndexForClass:">dropIndexForClass: aClass	self dropIndexForClass: aClass 			index: aClass indexName.</body><body package="StoreForDB2" selector="dropIndexForClass:index:">dropIndexForClass: aClass index: aName	self performDrop: [self processSQL: 'DROP INDEX ' ,   (self db2IndexName: aName)]		for: (aClass name, aName)</body><body package="StoreForDB2" selector="dropPrimaryKeyOnTable:">dropPrimaryKeyOnTable: aTableName	"Drop primary key constraint on table"	self performCreate: [	self processSQL: 'ALTER TABLE ', aTableName, ' DROP PRIMARY KEY ']		for: aTableName</body><body package="StoreForDB2" selector="dropSequenceForClass:">dropSequenceForClass: aClass</body><body package="StoreForDB2" selector="dropTableForClass:">dropTableForClass: aClass 		self dropTable: (self tableNameWithPrefix: aClass)</body><body package="StoreForDB2" selector="dropUser:">dropUser: aName"Not yet supported "	self halt:'Not yet supported ' .</body><body package="StoreForDB2" selector="dropViewForClass:">dropViewForClass: aClass	self dropView: ( self  tableNameWithPrefix: aClass).</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>performance tuning</category><body package="StoreForDB2" selector="dropIndex:onTable:">dropIndex: anIndex onTable: aTableName	"Removes an index from a database."	self process: ('DROP INDEX ' , aTableName, '.', anIndex) asString.</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>sql processing</category><body package="StoreForDB2" selector="getAnswerFromSession:bindInput:">getAnswerFromSession: getSessionBlock bindInput: bindInputBlock 		^self safelyExecuteBlock: 		[ | session ans res |		session := getSessionBlock value.		bindInputBlock value: session.		ans := session execute; answer.		ans == #noAnswerStream ifFalse: [ res := ans upToEnd ].		DbRegistry printDebug: 'Output'; printDebug: res.		^ res.		]</body><body package="StoreForDB2" selector="process:bindInput:bindOutput:usingSession:">process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session	| res ans |	"Return the result not the answer stream."	self isConnectionAlive ifFalse: [self currentlyNotConnectedSignal raise].	session bindInput: inputObj.	session bindOutput: outputObj.	session prepare: sqlString. 	ans := session execute; answer.	ans == #noAnswerStream ifFalse: [res := ans upToEnd].	DbRegistry printDebug: 'Output'; printDebug: res.	^ res</body><body package="StoreForDB2" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock 	"Catch errors that arise"	(DbRegistry connectionOrNil == nil or: [DbRegistry isOnline not]) 		ifTrue: [^self currentlyNotConnectedSignal raiseSignal].	^	[[Cursor database showWhile: [aBlock value]] on: self brokerSignals		do: 			[:exception | 			DbRegistry debug ifTrue: [self halt].			Transcript show: (self messageFor: exception).			DbRegistry goOffLine.			(Dialog confirm: 'Currently disconnected. Do you want to reconnect?') 				ifTrue: [DbRegistry reconnect ifTrue: [exception retry]].			self currentlyNotConnectedSignal raiseSignal]] 			on: UnhandledException			do: 				[:ex | 				self processPublishException: ex note: ''.				self currentlyNotConnectedSignal raiseSignal.				^nil]</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>grant statements</category><body package="StoreForDB2" selector="grant:on:columnList:to:">grant: aPermissionList on: aTableName columnList: aColumnList  to: aUserNameList	"Assigns permissions to users.	DB2 does not currently support granting 'SELECT' permissions to individual columns, so the GRANT applies to all columns in aTableName."	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'GRANT '.	aPermissionList do: [:each | aStream nextPutAll: each , ', '].	aStream skip: -2.	aStream nextPutAll: ' ON ' , aTableName.	aStream nextPutAll: ' TO '.	aUserNameList do: [:each | aStream nextPutAll: each , ', '].	aStream skip: -2.	self processGrantStatement: aStream contents	"aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	aStream nextPutAll:  (' ON ' , aTableName,  ' ( ' ).	aColumnList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	aStream nextPutAll:  ( ' ) ', ' TO ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	"</body><body package="StoreForDB2" selector="grantForClass:permissions:columns:toUsers:">grantForClass: aClass permissions: aPermissionList columns: aList toUsers: aUserNameList	self grant:aPermissionList		on: (self tableNameWithPrefix: aClass)		columnList: aList		to: aUserNameList</body><body package="StoreForDB2" selector="grantForSeqClass:permissions:toUsers:">grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList	"Don't need for v7"	^true	"super grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList"</body><body package="StoreForDB2" selector="processGrantStatement:">processGrantStatement: aString"need more work"	[		self processSQL:  aString	]	on: Error	do: [ :exception | 		"(exception parameter first dbmsErrorCode == self userAlreadyExistsInDBErrorNumber) 			ifTrue: 				[ Transcript show:  exception parameter first dbmsErrorString; cr.				exception return ]"			false ifFalse: 				[ Dialog warn: (self messageFor: exception). 				DbRegistry goOffLine.				exception pass ]		]</body></methods><methods><class-id>Store.DB2Broker class</class-id> <category>queries</category><body package="StoreForDB2" selector="newSQLFor:">newSQLFor: aClass	^ self sqlAssistClass newSQLFor: aClass		table:  (self tableNameWithPrefix: aClass)</body><body package="StoreForDB2" selector="nextIDQuery:">nextIDQuery: aClass 	^(self newSQLFor: aClass) selectMax: #(#primaryKey)</body><body package="StoreForDB2" selector="sqlAssistClass">sqlAssistClass	^DB2SQLAssist</body></methods><methods><class-id>Store.DB2Broker72 class</class-id> <category>create objects</category><body package="StoreForDB2" selector="addIdentityFor:">addIdentityFor: aColumn	" For #PrimaryKey columns we add identity property. 	Identity columns are commonly used in conjunction with PRIMARY KEY constraints to serve as the unique row identifier for the table. "	^String new</body><body package="StoreForDB2" selector="createDatabaseSequence:">createDatabaseSequence: aClass 	self performCreate: 			[self 				processSQL: 'CREATE SEQUENCE ' , (self sequenceNameWithPrefix: aClass)]		for: aClass name</body></methods><methods><class-id>Store.DB2Broker72 class</class-id> <category>connection class</category><body package="StoreForDB2" selector="connectionClass">connectionClass	^DB2Connection72</body></methods><methods><class-id>Store.DB2Broker72 class</class-id> <category>accessing</category><body package="StoreForDB2" selector="databaseName">databaseName	^'DB2/UDB 7.2 or high'</body><body package="StoreForDB2" selector="needsSequenceFor:">needsSequenceFor: aClass	^aClass needsSequence</body><body package="StoreForDB2" selector="permissionsForSequence">permissionsForSequence	"Answer an array of permissions to grant to sequence tables."	^#( 'USAGE' ).</body></methods><methods><class-id>Store.DB2Broker72 class</class-id> <category>drop objects</category><body package="StoreForDB2" selector="dropSequenceForClass:">dropSequenceForClass: aClass 	Transcript show: 'Dropping sequence for ' , aClass name; cr.	self performDrop: [self processSQL: 'DROP SEQUENCE ' , (self sequenceNameWithPrefix: aClass), ' RESTRICT']		for: aClass name</body></methods><methods><class-id>Store.DB2Broker72 class</class-id> <category>grant statements</category><body package="StoreForDB2" selector="grantForSeqClass:permissions:toUsers:">grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList"Copied from SQLBroker"	self grant: aPermissionList on: (' SEQUENCE ', (self sequenceNameWithPrefix: aClass)) to: aUserNameList.</body></methods><methods><class-id>Store.DB2Broker72 class</class-id> <category>queries</category><body package="StoreForDB2" selector="nextIDQuery:">nextIDQuery: aClass	^ self sqlAssistClass new		newSQLStream;		valuesFor: ( 'NEXTVAL FOR ', (self sequenceNameWithPrefix: aClass ))</body><body package="StoreForDB2" selector="sqlAssistClass">sqlAssistClass	^DB2SQLAssist72</body></methods><methods><class-id>DB2Connection72 class</class-id> <category>class initialization</category><body package="StoreForDB2" selector="initialize">initialize	"DB2Connection72 initialize"		super initialize.</body></methods><methods><class-id>DB2Connection72 class</class-id> <category>accessing</category><body package="StoreForDB2" selector="kind">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'DB2/UDB 7.2 Store '</body><body package="StoreForDB2" selector="storeBroker">storeBroker	"Answer a broker class for Store"	^Store.DB2Broker72</body></methods><methods><class-id>Store.DBObject class</class-id> <category>installation</category><body package="StoreForDB2" selector="db2TableSpaceName">db2TableSpaceName	"Answer a name of a tablespace the table should live in. If the default tablespace is acceptable 	answer nil."	^'NEWBERN2'</body></methods><methods><class-id>Store.Blob class</class-id> <category>installation</category><body package="StoreForDB2" selector="db2TableSpaceName">db2TableSpaceName	"Answer a name of a tablespace the table should live in. If the default tablespace is acceptable 	answer nil."	^'NEWBERN1'</body></methods><initialize><class-id>Store.DB2Broker</class-id></initialize><initialize><class-id>DB2Connection72</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>DB2Connection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hdbcHolder supportedFunctions generalInformationCache blobHstmt </inst-vars><class-inst-vars>apiXif apiXifMap </class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><class><name>SQLAssist</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName tableClass sqlStream alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><class><name>SQLBroker</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class></st-source>