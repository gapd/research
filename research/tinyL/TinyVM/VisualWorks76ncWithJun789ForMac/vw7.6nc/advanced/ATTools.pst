<?xml version="1.0"?><st-source><!-- Name: AT ToolsNotice: Copyright © 2002, 2001, 2000,1999 Cincom Systems, Inc.  All Rights Reserved.Comment: Contains the Full Protocol Browser and the WindowBrowser.The Full Protocol Browser is an extended version of the System Browser. In addition to the standard capabilities, it enables you to include superclass and subclass protocol in the message category and message views.The WindowBrowser is the Inspector for Windows.  It lets the user inspect the  components and subcomponents in a window, and see the structure of a window.DbIdentifier: bear73DbTrace: 61624DevelopmentPrerequisites: #(#(#any 'AT Support' ''))PackageName: AT ToolsPackageName:: AT ToolsParcel: #('AT Tools')ParcelName: AT ToolsPrerequisiteParcels: #(#('AT Support' ''))PrintStringCache: (7.5 - 1.0,bobw)Version: 7.5Pre-Unload Block: 	[:package | ]Date: 1:03:10 pm April 3, 2007 --><time-stamp>From VisualWorks®, 7.5 of April 3, 2007 on April 3, 2007 at 1:03:10 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>FullProtocolBrowserHelper</name><environment>Tools</environment><super>Tools.ProtocolBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hierarchyDepth hierarchyList supers subs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Tools</category><attributes><package>AT Tools</package></attributes></class><comment><class-id>Tools.FullProtocolBrowserHelper</class-id><body>FullProtocolBrowserHelper allows you to filter the various protocols that in the hierarchy of the selectedclass.Instance Variables:	hierarchyDepth &lt;OrderedCollection of: (Association key: Class value: Integer)&gt;	a collection of class/depth pairs for the classes in the hierarchy of the selected class.	hierarchyList	 &lt;MultiSelectionInList&gt; those classes in the hierarchy that are, at present, selected.	supers 		&lt;ValueHolder on: Boolean&gt; true if superclasses are automaticly selected.	subs 		&lt;ValueHolder on: Boolean&gt; true if subclasses are automaticly selected.Class Variables:SelectedEmphasis	&lt;Array&gt;	An emphasis array that is used when the protocol is defined in the selected class</body></comment><class><name>FullSelectorBrowserHelper</name><environment>Tools</environment><super>Tools.SelectorBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hierarchyDepth hierarchyList supers subs showClassNames showDupes userFilter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Tools</category><attributes><package>AT Tools</package></attributes></class><comment><class-id>Tools.FullSelectorBrowserHelper</class-id><body>FullSelectorBrowserHelper allows you to filter the various selectors that in the hierarchy of the selectedclass.Instance Variables:	hierarchyDepth &lt;OrderedCollection of: (Association key: Class value: Integer)&gt;	a collection of class/depth pairs for the classes in the hierarchy of the selected class.	hierarchyList	 &lt;MultiSelectionInList&gt; those classes in the hierarchy that are, at present, selected.	supers 		&lt;ValueHolder on: Boolean&gt; true if superclasses are automaticly selected.	subs 		&lt;ValueHolder on: Boolean&gt; true if subclasses are automaticly selected.	showClassNames 	&lt;ValueHolder on: Boolean&gt; true if class names should be displayed.	showDupes 	&lt;ValueHolder on: Boolean&gt; true if overridden selectors should be displayed.Class Variables:SelectedEmphasis	&lt;Array&gt;	An emphasis array that is used when the protocol is defined in the selected class</body></comment><class><name>FullBrowserTabApplication</name><environment>Tools</environment><super>Tools.NamespaceTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Tools</category><attributes><package>AT Tools</package></attributes></class><comment><class-id>Tools.FullBrowserTabApplication</class-id><body>FullBrowserTabApplication is a new BrowserTabApplication that allows one the capability to see methods in theselected class's hierarchy.  To accomplish this it uses a FullSelectorBrowserHelper and a FullProtocolBrowserHelper.</body></comment><class><name>OutlineBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outlineSelectionInList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Tools</category><attributes><package>AT Tools</package></attributes></class><comment><class-id>Tools.OutlineBrowser</class-id><body>OutlineBrowser is an abstract class used to view an expandable, collapsable treeCollaborators:	OutlineSelectionInList	TreeObjectHolderInstance Variables: 	outlineSelectionInList	&lt;OutlineSelectionInList&gt;	used to track the current selection</body></comment><shared-variable><name>SelectedEmphasis</name><environment>Tools.FullSelectorBrowserHelper</environment><private>false</private><constant>false</constant><category>Emphasis</category><attributes><package>AT Tools</package></attributes></shared-variable><shared-variable><name>SelectedEmphasis</name><environment>Tools.FullProtocolBrowserHelper</environment><private>false</private><constant>false</constant><category>Emphasis</category><attributes><package>AT Tools</package></attributes></shared-variable><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>accessing</category><body package="AT Tools" selector="hierarchyList">hierarchyList	^hierarchyList isNil		ifTrue: [hierarchyList := MultiSelectionInList new]		ifFalse: [hierarchyList]</body><body package="AT Tools" selector="subs">subs	^subs</body><body package="AT Tools" selector="supers">supers	^supers</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>protocol list</category><body package="AT Tools" selector="computeProtocolList:">computeProtocolList: currentClass	"Answer the sequenceable collection containing the message categories that 	the receiver accesses from the currently selected classes"	| protocols |	self recomputeHierarchyFor: currentClass.	protocols := Set new.	currentClass organization categories do: [:cat | protocols add: (cat)].	self currentClasses do:		[:cl | protocols addAll: (cl organization categories collect: [:cat | cat ])].	^protocols asSortedCollection asList</body><body package="AT Tools" selector="computeProtocolList:recomputeHierarchy:">computeProtocolList: currentClass recomputeHierarchy: recomputeBool 	"Answer the sequenceable collection containing the message categories that 	the receiver accesses from the currently selected classes. If recomputeBool is true, then recompute 	the hierarchy"	| protocols |	recomputeBool ifTrue: [self recomputeHierarchyFor: currentClass].	protocols := Set new.	currentClass organization categories do: [:cat | protocols add: cat].	self currentClasses do: [:cl | protocols addAll: (cl organization categories collect: [:cat | cat])].	^protocols asSortedCollection asList</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>initialize-release</category><body package="AT Tools" selector="initialize">initialize	super initialize.	supers := false asValue.	subs := false asValue.	self supers onChangeSend: #supersChange to: self.	self subs onChangeSend: #subsChange to: self</body><body package="AT Tools" selector="release">release	self retractInterestIn: self supers for: self.	self retractInterestIn: self subs for: self.	super release</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>private</category><body package="AT Tools" selector="currentClasses">currentClasses	^self hierarchyList selections</body><body package="AT Tools" selector="recomputeHierarchyFor:">recomputeHierarchyFor: theClass	"If nil, then empty out hierarchyDepth and hierarchyList.  If a class name, then	set up hierarchyDepth to be an ordered collection of associations from	class to indentation level and set up selection based on supers and subs."	|  block hl |	theClass isNil		ifTrue:			[hierarchyDepth := nil.			hl := List new.]		ifFalse:			[hierarchyDepth := OrderedCollection new.			hl := List new.			theClass withAllSuperclasses reverse				do: [:cl | hierarchyDepth add: cl -&gt; 0.						hl add: cl].			block :=				[:cl :depth |				hierarchyDepth add: cl -&gt; depth.				hl add: cl.				cl subclasses do: [:cl2 | block value: cl2 value: depth+1]].			theClass subclasses do: [:cl3 | block value: cl3 value: 1]].	self hierarchyList list: hl.	self recomputeSelectionsFor: theClass.</body><body package="AT Tools" selector="recomputeHierarchySelections">recomputeHierarchySelections	self recomputeSelectionsFor: self targetClassOrNameSpace.</body><body package="AT Tools" selector="recomputeSelectionsFor:">recomputeSelectionsFor: classOrNil 	| thisIndex objectIndex selectionIndexes |	objectIndex := 0.	classOrNil isNil ifTrue: [^self].	1 to: hierarchyDepth size		do: 			[:i | 			| cl |			cl := (hierarchyDepth at: i) key.			cl == classOrNil ifTrue: [thisIndex := i].			cl == Object ifTrue: [objectIndex := i]].	selectionIndexes := (1 to: hierarchyDepth size) asSet.	(classOrNil ~~ Object and: [objectIndex ~= 0]) ifTrue: [selectionIndexes remove: objectIndex].	supers value ifFalse: [objectIndex + 1 to: thisIndex - 1 do: [:i | selectionIndexes remove: i]].	subs value ifFalse: [thisIndex + 1 to: hierarchyDepth size do: [:i | selectionIndexes remove: i]].	self hierarchyList selectionIndexes: selectionIndexes</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>aspect changes</category><body package="AT Tools" selector="subsChange">subsChange	self recomputeHierarchySelections.	self updateListFull</body><body package="AT Tools" selector="supersChange">supersChange	self recomputeHierarchySelections.	self updateListFull.</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>menu accessing</category><body package="AT Tools" selector="buildViewMenu:">buildViewMenu: aMenu 	| menu |	menu := self class defTypeMenu.	#(#supers #subs)		do: 			[:aSymbol | 			| menuItem |			menuItem := menu atNameKey: aSymbol.			menuItem indication: (self perform: aSymbol) value.			menuItem				value: 					[| selectorHelper |					selectorHelper := self nextModule currentHelper.					(self perform: aSymbol)						value: (self perform: aSymbol) value not.					(selectorHelper perform: aSymbol)						value: (selectorHelper perform: aSymbol) value not]].	#(#showDupes #showClassNames)		do: 			[:aSymbol | 			| menuItem selectorHelper |			selectorHelper := self nextModule currentHelper.			menuItem := menu atNameKey: aSymbol.			menuItem indication: (selectorHelper perform: aSymbol) value.			menuItem				value: 					[(selectorHelper perform: aSymbol)						value: (selectorHelper perform: aSymbol) value not.					selectorHelper updateListFull]].	(menu atNameKey: #selectHierarchyFilter)		value: [self selectHierarchyFilter].	aMenu addPart: menu</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>list accessing</category><body package="AT Tools" selector="updateListFull">updateListFull	| target |	target := self targetClassOrNameSpace.	target == nil ifTrue: [^module setNewList: List new].	target isForNameSpace ifTrue: [^super updateListFull].	module setNewList: (self computeProtocolList: target recomputeHierarchy: true).	self nextModule currentHelper userFilter: nil.</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>emphasis</category><body package="AT Tools" selector="textEmphasisForItem:">textEmphasisForItem: aListItem 	"Bold the protocol if it is actually selected"	| target |	target := self selectedClassOrNameSpace.	target == nil ifTrue: [^super textEmphasisForItem: aListItem].	((self currentClasses includes: target) and: [(target organization categories includes: aListItem)]) 		ifTrue: [^self class selectedEmphasis].	^super textEmphasisForItem: aListItem</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>actions</category><body package="AT Tools" selector="selectHierarchyFilter">selectHierarchyFilter	| userSelections |	userSelections := SimpleDialog new				chooseMultiple: (#WhichOnesDoYouWant &lt;&lt; #advanced &gt;&gt; 'Which ones do you want?')				fromList: self hierarchyList list				values: self hierarchyList list				initialSelections: self currentClasses				buttons: #()				values: #()				lines: 15				cancel: [#noChoice]				for: Dialog defaultParentWindow.	userSelections = #noChoice ifTrue: [^self].	self hierarchyList selections: userSelections.	module setNewList: (self computeProtocolList: self targetClassOrNameSpace recomputeHierarchy: false).	self nextModule currentHelper userFilter: userSelections.</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper class</class-id> <category>class initialization</category><body package="AT Tools" selector="initialize">initialize	"FullProtocolBrowserHelper initialize"	"for my sanity"	SelectedEmphasis := #(#bold)</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper class</class-id> <category>accessing</category><body package="AT Tools" selector="selectedEmphasis">selectedEmphasis	^SelectedEmphasis</body><body package="AT Tools" selector="selectedEmphasis:">selectedEmphasis: emphasisArray	"Tools.FullProtocolBrowserHelper selectedEmphasis: (Array with: #bold with: #color-&gt;ColorValue olive)"	"Tools.FullProtocolBrowserHelper selectedEmphasis: #(#bold)"	SelectedEmphasis := emphasisArray</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>accessing</category><body package="AT Tools" selector="hierarchyList">hierarchyList	^hierarchyList isNil		ifTrue: [hierarchyList := MultiSelectionInList new]		ifFalse: [hierarchyList]</body><body package="AT Tools" selector="showClassNames">showClassNames	^showClassNames</body><body package="AT Tools" selector="showDupes">showDupes	^showDupes</body><body package="AT Tools" selector="subs">subs	^subs</body><body package="AT Tools" selector="supers">supers	^supers</body><body package="AT Tools" selector="userFilter:">userFilter: aSetOfClassesOrNil	userFilter := aSetOfClassesOrNil</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>private</category><body package="AT Tools" selector="currentClasses">currentClasses	^self hierarchyList selections</body><body package="AT Tools" selector="recomputeHierarchy">recomputeHierarchy	|target|	target := self targetClassOrNameSpace.	(target == nil or: [target isForNameSpace]) ifTrue: [^self].	self recomputeHierarchyFor: target</body><body package="AT Tools" selector="recomputeHierarchyFor:">recomputeHierarchyFor: theClass	"If nil, then empty out hierarchyDepth and hierarchyList.  If a class name, then	set up hierarchyDepth to be an ordered collection of associations from	class to indentation level and set up selection based on supers and subs."	|  block hl |	theClass isNil		ifTrue:			[hierarchyDepth := nil.			hl := List new.]		ifFalse:			[hierarchyDepth := OrderedCollection new.			hl := List new.			theClass withAllSuperclasses reverse				do: [:cl | hierarchyDepth add: cl -&gt; 0.						hl add: cl].			block :=				[:cl :depth |				hierarchyDepth add: cl -&gt; depth.				hl add: cl.				cl subclasses do: [:cl2 | block value: cl2 value: depth+1]].			theClass subclasses do: [:cl3 | block value: cl3 value: 1]].	self hierarchyList list: hl.	self recomputeSelectionsFor: theClass.</body><body package="AT Tools" selector="recomputeHierarchySelections">recomputeHierarchySelections	self recomputeHierarchy.	self recomputeSelectionsFor: self targetClassOrNameSpace.</body><body package="AT Tools" selector="recomputeSelectionsFor:">recomputeSelectionsFor: classOrNil 	"Recompute the selected set based on the current hierarchy and the states	of the super and sub buttons."	| thisIndex objectIndex selectionIndexes |	objectIndex := 0.	classOrNil isNil ifTrue: [^self].	1 to: hierarchyDepth size		do: 			[:i | 			| cl |			cl := (hierarchyDepth at: i) key.			cl == classOrNil ifTrue: [thisIndex := i].			cl == Object ifTrue: [objectIndex := i]].		userFilter isNil ifFalse: [^self hierarchyList selections: userFilter].	selectionIndexes := (1 to: hierarchyDepth size) asSet.	(classOrNil ~~ Object and: [objectIndex ~= 0]) ifTrue: [selectionIndexes remove: objectIndex].	supers value ifFalse: [objectIndex + 1 to: thisIndex - 1 do: [:i | selectionIndexes remove: i]].	subs value ifFalse: [thisIndex + 1 to: hierarchyDepth size do: [:i | selectionIndexes remove: i]].	self hierarchyList selectionIndexes: selectionIndexes.</body><body package="AT Tools" selector="textForItem:">textForItem: aListEntry 	"aListEntry is an assocation between a symbol and class"	| writeStream |	self showClassNames value ifFalse: [^aListEntry displayString asText].	writeStream := (String new: 20) writeStream.	writeStream nextPutAll: aListEntry displayString.	writeStream nextPutAll: ' ('.	aListEntry value printOn: writeStream.	writeStream nextPut: $).	^writeStream contents asText</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>initialize-release</category><body package="AT Tools" selector="initialize">initialize	super initialize.	supers := false asValue.	subs := false asValue.	showDupes := true asValue.	showClassNames := false asValue.	self supers onChangeSend: #supersChange to: self.	self subs onChangeSend: #subsChange to: self</body><body package="AT Tools" selector="release">release	self retractInterestIn: self supers for: self.	self retractInterestIn: self subs for: self.	super release</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>list accessing</category><body package="AT Tools" selector="definitionOf:">definitionOf: anItem 	| target |	anItem isSymbol ifTrue: [^super definitionOf: anItem].	target := self selectedClassOrNameSpace.	target == nil ifTrue: [^nil].	"Actually we don't use the selectedClassOrNameSpace here because anItem knows its class"	^(self isData or: [target isForNameSpace])		ifTrue: [BindingReference simpleName: anItem in: target]		ifFalse: [MethodDefinition class: anItem value selector: anItem key]</body><body package="AT Tools" selector="updateListFull">updateListFull	| target |	target := self targetClassOrNameSpace.	(target == nil or: [self protocols == nil or: [self protocols isEmpty]])		ifTrue: [^module setNewList: List new].		target isForNameSpace ifTrue: [^super updateListFull].	module setNewList: (self computeSelectorListFor: target) asList</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>text processing</category><body package="AT Tools" selector="acceptText:from:">acceptText: text from: textController 	"The Browser's text pane is trying to be accepted. The receiver is 	sent #acceptText:from: and it must decided if it is appropriate to 	respond to it. If a method is being accepted (indicated by a 	selection that is non-nil) then we need to double check with the 	user to ensure that the method gets accepted into the correct 	class. This is because with the APOK full browser, you could 	have selected a method from a class different then the currently 	selected class."	| message |	 "I have no selection to understand what to do with what is being accepted, return nil to indicate that."	self selection isNil ifTrue: [^nil].	self targetClass == self selectedClassOrNameSpace 		ifTrue: [^super acceptText: text from: textController].	message := (#ThisMethodWillBeAcceptedIntoClass1p &lt;&lt; #advanced &gt;&gt; 'This method will be accepted into class &lt;1p&gt;. Are you sure this is what you want?') 		expandMacrosWith: self targetClass.	^(Dialog confirm: message for: textController view)		ifTrue: [super acceptText: text from: textController]		ifFalse: [false]</body><body package="AT Tools" selector="acceptTextForMethod:from:">acceptTextForMethod: text from: textController	"We want to return an association for the FullSelectorBrowserHelper when it gets selected"	^(super acceptTextForMethod: text from: textController)-&gt;self targetClass</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>aspect changes</category><body package="AT Tools" selector="subsChange">subsChange	self recomputeHierarchySelections.	self updateListFull</body><body package="AT Tools" selector="supersChange">supersChange	self recomputeHierarchySelections.	self updateListFull.</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>selections</category><body package="AT Tools" selector="targetClass">targetClass	"The selector's implementing class, which might not be the selected class"	| choice def obj |	choice := self selection.	def := self definitionOf: choice.	obj := def implementingClass.	^( obj ~~ nil and: [ obj isForClass ] )		ifTrue: [ obj ]</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>emphasis</category><body package="AT Tools" selector="textEmphasisForItem:">textEmphasisForItem: anItem 	"We want to bold the anItem if it is actually defined in target's class instead of one of its super or 	subclasses"	| target |	target := self selectedClassOrNameSpace.	target == nil ifTrue: [^super textEmphasisForItem: anItem].	anItem value == target ifTrue: [^self class selectedEmphasis].	^super textEmphasisForItem: anItem</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper</class-id> <category>selector list</category><body package="AT Tools" selector="computeSelectorListFor:">computeSelectorListFor: aTarget	| coll mySels orderDict order selList |	self recomputeHierarchyFor: aTarget.	coll := OrderedCollection new.	mySels := aTarget organization listAtCategoriesNamed: self protocols.	orderDict := Dictionary new.	"Mapping of class to order in currentClasses"	order := 0.	self currentClasses do:		[:cl | | set |		orderDict at: cl put: (order := order + 1).		set := Set new.		(cl organization listAtCategoriesNamed: self protocols) do:			[:sel | set add: (sel -&gt; cl)].		cl selectors do:			[:sel | (mySels includes: sel) ifTrue:				[set add: (sel -&gt; cl)]].		coll addAll: set].	self showDupes value ifFalse:		[| coll2 iSet |	"Take the last of any duplicates.  Assumes that currentClasses is ordered"		coll2 := OrderedCollection new.		iSet := IdentitySet new. 		coll reverseDo:			[:assn |			((iSet includes: assn key) not 				or: [assn value inheritsFrom: aTarget superclass])				ifTrue: [coll2 addLast: assn.  iSet add: assn key]].		coll := coll2].	selList := coll asSortedCollection:		[:s1 :s2 | "Sort alphabetically, and within duplicates in hierarchy order"		s1 key = s2 key			ifTrue: [(orderDict at: s2 value) &gt; (orderDict at: s1 value)]			ifFalse: [s1 &lt; s2]].	selList := selList asList.	^selList</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper class</class-id> <category>class initialization</category><body package="AT Tools" selector="initialize">initialize	"FullSelectorBrowserHelper initialize"	"for my sanity"	SelectedEmphasis := #(#bold)</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper class</class-id> <category>accessing</category><body package="AT Tools" selector="selectedEmphasis">selectedEmphasis	^SelectedEmphasis</body><body package="AT Tools" selector="selectedEmphasis:">selectedEmphasis: emphasisArray	"Tools.FullSelectorBrowserHelper selectedEmphasis: (Array with: #bold with: #color-&gt;ColorValue olive)"	"Tools.FullSelectorBrowserHelper selectedEmphasis: #(#bold)"	SelectedEmphasis := emphasisArray</body></methods><methods><class-id>Tools.FullBrowserTabApplication</class-id> <category>componentBuilding</category><body package="AT Tools" selector="protocolsComponent">protocolsComponent	^SimpleBrowserModule new		specName: #listSpecProtocols;		helperType: FullProtocolBrowserHelper.</body><body package="AT Tools" selector="selectorsComponent">selectorsComponent	^SimpleBrowserModule new		helperType: FullSelectorBrowserHelper</body></methods><methods><class-id>Tools.FullBrowserTabApplication</class-id> <category>components</category><body package="AT Tools" selector="windowLabel">windowLabel	^(#FullBrowser &lt;&lt; #advanced &gt;&gt; 'Full Browser') asString</body></methods><methods><class-id>Tools.OutlineBrowser</class-id> <category>expand contract</category><body package="AT Tools" selector="contractFully">contractFully	"Contract the current selection and all of its descendants to a single item."	self contractFully: self outlineSelectionInList selectionIndexInFull</body><body package="AT Tools" selector="contractFully:">contractFully: anItemIndex 	"Contract the item and all of its descendants to a single item, and let 	the items know if they have hidden chidren."	anItemIndex == 0 ifFalse: [Cursor execute			showWhile: 				[| selectionInList |				selectionInList := self outlineSelectionInList.				(selectionInList fullList at: anItemIndex) hasHiddenChildren.				selectionInList disableGroup: anItemIndex.				self centerOutlineIndex: selectionInList selectionIndex]]</body><body package="AT Tools" selector="expand">expand	"Expand the current selection and all of its immediate children."	self expand: self outlineSelectionInList selectionIndexInFull</body><body package="AT Tools" selector="expand:">expand: anItemIndex 	"Expand the item all of its immediate children, and let the items 	know if they have hidden chidren."	anItemIndex == 0 ifFalse: [Cursor execute			showWhile: 				[| selectionInList childBlock children |				selectionInList := self outlineSelectionInList.				childBlock := selectionInList childBlock.				children := childBlock value: anItemIndex.				children					do: 						[:index | 						| item |						item := selectionInList fullList at: index.						(selectionInList enabled: index)							ifFalse: [item hasHiddenChildren: item leaf not]].				(selectionInList fullList at: anItemIndex) noHiddenChildren.				selectionInList enableItems: children.				self centerOutlineIndex: selectionInList selectionIndex]]</body><body package="AT Tools" selector="expandFully">expandFully	"Expand the current selection and all of its descendants."	self expandFully: self outlineSelectionInList selectionIndexInFull</body><body package="AT Tools" selector="expandFully:">expandFully: anItemIndex 	"Expand the item all of its children to a single item, and let the items 	know if they have hidden chidren."	anItemIndex == 0 ifFalse: [Cursor execute			showWhile: 				[| selectionInList |				selectionInList := self outlineSelectionInList.				(selectionInList fullList at: anItemIndex) noHiddenChildren.				(self outlineSelectionInList groupBlock value: anItemIndex)					do: 						[:index | 						| item |						item := selectionInList fullList at: index.						item noHiddenChildren].				self outlineSelectionInList enableGroup: anItemIndex.				self centerOutlineIndex: selectionInList selectionIndex]]</body></methods><methods><class-id>Tools.OutlineBrowser</class-id> <category>interface opening</category><body package="AT Tools" selector="postBuildWith:">postBuildWith: aBuilder 	"The items aren't straight text, so we need to 'draw' them with these blocks."	| visualBlock selectedVisualBlock |	visualBlock := [:view :index | BoundedWrapper on: (((view model value at: index) asLabel) attributes: view textStyle; offset: 2 @ 0)].	selectedVisualBlock := 			[:view :index | 			| rw |			rw := ReversingWrapper on: (visualBlock value: view value: index).			rw reverse setValue: true.			rw].	((self builder componentAt: #outlineSelectionInList) widget) visualBlock: visualBlock; selectedVisualBlock: selectedVisualBlock</body></methods><methods><class-id>Tools.OutlineBrowser</class-id> <category>initialize-release</category><body package="AT Tools" selector="initialize">initialize	"Initialize a new browser for the outline"	"This overrides what the painter wants there, a selectionInList."	outlineSelectionInList := OutlineSelectionInList new.	super initialize.	self outlineSelectionInList listHolder onChangeSend: #enabledSetChanged to: self</body><body package="AT Tools" selector="with:childBlock:">with: aSequenceableCollection childBlock: childBlock 	"Initialize a new browser for the outline with this collection and this 	childBlock."	outlineSelectionInList childBlock: childBlock; list: aSequenceableCollection</body><body package="AT Tools" selector="with:childBlock:enabled:">with: aSequenceableCollection childBlock: childBlock enabled: enabledIndexSet 	"Initialize a new browser for the outline with this collection and this 	childBlock."	outlineSelectionInList childBlock: childBlock; list: aSequenceableCollection enabledSet: enabledIndexSet</body></methods><methods><class-id>Tools.OutlineBrowser</class-id> <category>aspects</category><body package="AT Tools" selector="outlineSelectionInList">outlineSelectionInList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^outlineSelectionInList isNil		ifTrue:			[outlineSelectionInList := SelectionInList new]		ifFalse:			[outlineSelectionInList]</body></methods><methods><class-id>Tools.OutlineBrowser</class-id> <category>protected updates</category><body package="AT Tools" selector="centerOutlineIndex:">centerOutlineIndex: anInteger 	"Make the element at anInteger visible and centered in the outline view. This 	should really be in SequenceView or the like, but since it isn't, we do 	something about it here for now."	| outlineView range rangeHalf |	self builder isNil ifTrue: [^self].	"Make sure all previous scrolling and selecting is finished before we scroll"	self builder window displayPendingInvalidation.	"Reach inside the SequenceView and compute the amount to scroll"	outlineView := (self builder componentAt: #outlineSelectionInList) widget.	range := outlineView visibleIntervalForBounds: outlineView bounds.	rangeHalf := range last + range first - 1 // 2.	rangeHalf = anInteger ifTrue: [^self].	anInteger &lt; rangeHalf 		ifTrue: [^outlineView scrollBy: 0 @ (rangeHalf - anInteger * outlineView lineGrid)].	outlineView scrollBy: 0 @ (anInteger - rangeHalf * outlineView lineGrid) negated</body><body package="AT Tools" selector="enabledSetChanged">enabledSetChanged	"We get this after expand, expandfully, and contract"</body></methods><methods><class-id>Tools.OutlineBrowser class</class-id> <category>examples</category><body package="AT Tools" selector="example1">example1	"OutlineBrowser example1"	| childBlock indentBlock collection indentedCollection |	collection := #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) asList.	indentedCollection := collection copy.	childBlock := [:index | (#(#(1) #(2 9) #(3 6) #(4 5) #() #() #(7 8) #() #() #(10 13) #(11 12) #() #() #(14 15) #() #()) at: index + 1) asSet].	indentBlock := 			[:index :depth | 			| children |			children := childBlock value: index.			children do: [:childIndex | indentBlock value: childIndex value: depth , '  '].			indentedCollection at: index put: (TreeObjectHolder					string: depth					value: (collection at: index)					leaf: children isEmpty)].	indentBlock value: 1 value: ''.	self open window model with: indentedCollection childBlock: childBlock</body><body package="AT Tools" selector="exampleSieve:">exampleSieve: limit 	"OutlineBrowser exampleSieve: 120"	| childBlock collection |	collection := (1 to: limit) asList collect: [:each | TreeObjectHolder string: '' value: each leaf: false].	childBlock := 			[:factor | 			| multiple multiples |			multiple := factor * 2.			multiples := Set new.			[multiple &lt;= limit]				whileTrue: 					[multiples add: multiple.					multiple := multiple + factor].			multiples].	self open window model with: collection childBlock: childBlock</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>menus accessing</category><body package="AT Tools" selector="actionsForMultiSelect">actionsForMultiSelect	|aList|	aList := super actionsForMultiSelect asList.	aList add: #diffs.	^aList</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser class</class-id> <category>actions</category><body package="AT Tools" selector="openNormalFull">openNormalFull	"self openNormalFull"	^(self new) 		initializeForTabApplications: (Array with: FullBrowserTabApplication); 		open</body><body package="AT Tools" selector="openOnSystemFull">openOnSystemFull	"self openOnSystemFull"	^(self new) 		initializeForTabApplications: (Array with: ParcelTabApplication with: FullBrowserTabApplication); 		open</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>menus accessing</category><body package="AT Tools" selector="actionsForMultiSelect">actionsForMultiSelect	|aList|	aList := super actionsForMultiSelect asList.	aList add: #diffs.	^aList</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper</class-id> <category>actions</category><body package="AT Tools" selector="findAllMethodAndSelectAlphabetic">findAllMethodAndSelectAlphabetic	"Prompt the user for a method pattern, then show a menu of the methods 	matching that pattern implemented by any visible class.  	Select the chosen one."	&lt;menuItem: #(#FindInHierarchy #advanced 'Find In Hierarchy...')		nameKey: nil		menu: #(#listMenu)		position: 30.50&gt;	| pattern selNClassColl chosenAssn |	pattern := Dialog request: (#FindMethod &lt;&lt; #advanced &gt;&gt; 'Find method:') initialAnswer: '*' for: self interfaceWindow.	pattern isEmpty ifTrue: [^self].	selNClassColl := OrderedCollection new.	self currentClasses do:		[:cl |		cl selectors do:			[:sel |			(pattern match: sel) ifTrue: [selNClassColl add: sel -&gt; cl]]].	selNClassColl isEmpty ifTrue: [^Dialog warn: (#NoMatchingMessages &lt;&lt; #advanced &gt;&gt; 'No matching messages') for: self interfaceWindow].	selNClassColl := selNClassColl asSortedCollection:		[:a1 :a2 |		a1 key = a2 key			ifTrue: [a2 value inheritsFrom: a1 value]			ifFalse: [a1 &lt; a2]].	chosenAssn := Dialog			choose: (#MatchingMethods &lt;&lt; #advanced &gt;&gt; 'Matching methods')			fromList: (selNClassColl collect:					[:assn | | text |					text := (assn key asString, ' (', assn value name, ') ') asText.					assn value == self selectedClassOrNameSpace ifTrue: [text := text emphasizeAllWith: self class selectedEmphasis].					text])			values: selNClassColl			lines: 20			cancel: [^self]			for: self interfaceWindow.	self module selection: (chosenAssn value whichCategoryIncludesSelector: chosenAssn key).	self nextModule selection: chosenAssn.</body></methods><methods><class-id>Tools.FullProtocolBrowserHelper class</class-id> <category>resources</category><body package="AT Tools" selector="defTypeMenu">defTypeMenu	"MenuEditor new openOnClass: self andSelector: #defTypeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Supers' 				#nameKey: #supers ) 			#(#{UI.MenuItem} 				#rawLabel: 'Subs'				#nameKey: #subs ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show Duplicates' 				#nameKey: #showDupes ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show Name' 				#nameKey: #showClassNames ) 			#(#{UI.MenuItem} 				#rawLabel: 'Select Hierarchy Filter...' 				#nameKey: #selectHierarchyFilter ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FullSelectorBrowserHelper class</class-id> <category>resources</category><body package="AT Tools" selector="defTypeMenu">defTypeMenu	"MenuEditor new openOnClass: self andSelector: #defTypeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Supers' 				#nameKey: #supers ) 			#(#{UI.MenuItem} 				#rawLabel: 'Subs'				#nameKey: #subs ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show Duplicates' 				#nameKey: #showDupes ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show Name' 				#nameKey: #showClassNames ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.OutlineBrowser class</class-id> <category>interface specs</category><body package="AT Tools" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#bounds: #(#Rectangle 660 436 1118 784 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 1 0 1 0 -1 1 -1 1 ) 					#name: #outlineSelectionInList 					#flags: 15 					#model: #outlineSelectionInList 					#menu: #outlineMenu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Tools.OutlineBrowser class</class-id> <category>resources</category><body package="AT Tools" selector="outlineMenu">outlineMenu	"MenuEditor new openOnClass: self andSelector: #outlineMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #expand #defaultString: 'expand' #catalogID: #advanced)				#nameKey: #expand 				#value: #expand ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #expandFully #defaultString: 'expand fully' #catalogID: #advanced)				#nameKey: #expandFully 				#value: #expandFully ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #contractFully #defaultString: 'contract fully' #catalogID: #advanced)				#nameKey: #contractFully 				#value: #contractFully ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>actions</category><body package="AT Tools" selector="diffs">diffs	&lt;menuItem: 'Diffs...'		nameKey: #diffs		menu: #(#listMenu)		position: 60.045&gt;	|sels m1 m2 diffy|	sels := self selections.	(sels isNil 	or: [(sels isEmpty	or: [sels size ~= 2])])		ifTrue: [^self].		m1 := self definitionOf: (sels at: 1).	m2 := self definitionOf: (sels at: 2).	diffy := (Differator newOn: m1 sourceCode and: m2 sourceCode).	diffy diffModeHolder value: #Smalltalk.	diffy open</body></methods><initialize><class-id>Tools.FullProtocolBrowserHelper</class-id></initialize><initialize><class-id>Tools.FullSelectorBrowserHelper</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ProtocolBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NamespaceTabApplication</name><environment>Tools</environment><super>Tools.BrowserTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>MethodsBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>MethodListBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label baseList initialSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>SelectorBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class></st-source>