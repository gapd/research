<?xml version="1.0"?><st-source><!-- Name: AT Profiling UINotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains the user interface components of the Advanced Tools profilers.  Both user interface and core components must be loaded in an image used to initiate profiling runs or to examine profiling results, irrespective of whether a profiled process is local or remote.  The TimeProfiler and the AllocationProfiler are used to profile, respectively, the time and space usage of a single process.  The corresponding multi-profilers attempt to profile all processes instead of one.  Note that all profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  See the code comments for more information.  Note that the new profilers should not be loaded over the old profiling code in 'AT Profiling'.This package was based on code contributed by Florin Mateoc, created with valuable assistance from his colleague Kerry LeClue, and once shipped as 'ATProfilingEnhancements'.  Florin also contributed to the validation of this package.  Florin's original code included a refactoring of the original VisualWorks profiler, once shipped as 'ATProfiling', and several modifications to the that profiler, to improve accuracy, decrease overhead, report more details, and improve the lists of target primitives.  It also included the multi-process profilers.DbIdentifier: bear73DbTrace: 55241DevelopmentPrerequisites: #(#(#package 'AT Profiling Core' '') #(#package 'AT Tools' ''))PackageName: AT Profiling UIParcel: #('AT Profiling UI')ParcelName: AT Profiling UIPrerequisiteParcels: #(#('AT Profiling Core' '') #('AT Tools' ''))PrintStringCache: (73 22,bobw)Version: 7.4Pre-Unload Block: 	[:pkg| Profiler preUnloadFor: pkg ]Date: 1:45:52 pm December 5, 2005 --><time-stamp>From VisualWorks®, 7.4 of December 5, 2005 on December 5, 2005 at 1:45:52 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ProfileOutlineBrowser</name><environment>Tools</environment><super>Tools.OutlineBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cutoff findNextMenu processedReports profiler reports viewingMode viewingModeList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Profiling</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.ProfileOutlineBrowser</class-id><body>ProfileOutlineBrowser implements a user interfaceused to view the results of a profiling run.Instance Variables:	cutoff				&lt;ValueHolder on: Integer&gt; 						any MessageTallies that consume less resource than ''cutoff'' will not be displayed.	findNextMenu		&lt;UndefinedObject | Array of: Symbol&gt;						an Array of the selectors of the methods 'probed' during the collaborating ProfilerCore's execution	processedReports	&lt;Dictionary&gt; 						those versions of the reports, indexed by report keys and already modified by the 'cutoff' value, that are ready for display or printing	profiler				&lt;Profiler&gt;						the Profiler that, in collaboration with a ProfilerCore,  generated the execution profile presented in this ProfileOutlineBrowser	reports				&lt;Array&gt;							of Associations between report keys and reports	viewingMode		&lt;AspectAdaptor&gt;						on the current selection in 'viewingModeList'	viewingModeList		&lt;SelectionInList&gt;						holding a List of the keys of the several available reports</body></comment><class><name>ProfileBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>focus tallies source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Profiling</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.ProfileBrowserHelper</class-id><body>ProfileBrowserHelper is a collaborator of ProfileOutlineBrowser.Instance Variables:	focus	&lt;MessageTally | MessageTallyDescription&gt;	the current selected node	tallies	&lt;List&gt;	the displayed MessageTallys or MessageTallyDescriptions	source	&lt;MessageTally | MessageTallyDescription&gt;	the original root from which the tallies were derived</body></comment><class><name>TreeBuilder</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>childDictionary rootList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Profiling</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.TreeBuilder</class-id><body>TreeBuilder supports dynamic tree construction.  Its API supports return of a list of the nodes in the tree, along with a block that, when evaluated, supplies the child indices given the parent index.  New nodes may be supplied in any root-to-leaf order, and this class will organize it as a depth-first tree.Instance Variables:	childDictionary	&lt;Dictionary&gt;					with an Association for each node, where the 'key' is the node and the 'value' is a List of the node's children	rootList			&lt;List&gt;					a list of all the roots of the trees in the forest</body></comment><class><name>Profiler</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>core samplingIntervalAdaptor textModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.Profiler</class-id><body>A Profiler supplies both an optional user interface and a non-optional programmatic interface for initiating profiling runs.  A Profiler always has a ProfilerCore, usually co-located, as a collaborator.  When a profiling run is finished, reports are usually presented in a ProfileOutlineBrowser, but may also be written to a file.   By default, a Profiler is always co-located with the presenting ProfileOutlineBrowser.  See the methods in the class side 'public api' protocol for examples.  If you understand the default, instructional text presented in the Profiler user interfaces, evaluate 'Profile showTemplates: true' to see standard code templates instead.Subclasses must implement the following messages:	accessing		sampleUnitName	reporting		reportTotalsOn:Instance Variables:	core					&lt;ProfileCore&gt;							the collaborating ProfilerCore	samplingIntervalAdaptor	&lt;PluggableAdaptor&gt;							on the samplingInterval of the applicable ProfilerCore	textModel				&lt;EvaluationHolder | String &gt;							containing the text to be evaluated, if a profiling run is invoked using the optional user interface</body></comment><class><name>AllocationProfiler</name><environment>Tools</environment><super>Tools.Profiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.AllocationProfiler</class-id><body>AllocationProfiler is the concrete class of Profiler used for space allocation profiling.  Note that all profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.</body></comment><class><name>MultiAllocationProfiler</name><environment>Tools</environment><super>Tools.AllocationProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.MultiAllocationProfiler</class-id><body>MultiAllocationProfiler is the concrete class of Profiler used for multi-process space allocation profiling.  Users are urged to remember that all the profilers rely upon a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  Multi-process profilers will distribute the probes used to estimate resource consumption over several processes, rather than one, mayhaps unevenly.  Also, running multi-process profilers will cause garbage collection and other maintenance processes to be run more frequently than otherwise.  These facts should be kept firmly in view when setting up multi-process profiling runs and when estimating the reliability of their results.  Within these limitations, multi-process profilers have proven useful in tuning web applications involving many hundreds of  processes.</body></comment><class><name>TimeProfiler</name><environment>Tools</environment><super>Tools.Profiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.TimeProfiler</class-id><body>TimeProfiler is the concrete class of Profiler used for time profiling.  Note that all profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.</body></comment><class><name>MultiTimeProfiler</name><environment>Tools</environment><super>Tools.TimeProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.MultiTimeProfiler</class-id><body>MultiTimeProfiler is the concrete class of Profiler used for multi-process time profiling.  Users are urged to remember that all the profilers rely upon a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  Multi-process profilers will distribute the probes used to estimate resource consumption over several processes, rather than one, mayhaps unevenly.  Also, running multi-process profilers will cause garbage collection and other maintenance processes to be run more frequently than otherwise.  These facts should be kept firmly in view when setting up multi-process profiling runs and when estimating the reliability of their results.  Within these limitations, multi-process profilers have proven useful in tuning web applications involving many hundreds of  processes.</body></comment><shared-variable><name>FocusEmphasis</name><environment>Tools.ProfileBrowserHelper</environment><private>false</private><constant>false</constant><category>local globals</category><initializer>#(#bold)</initializer><attributes><package>AT Profiling UI</package></attributes></shared-variable><shared-variable><name>ShowTemplates</name><environment>Tools.Profiler</environment><private>false</private><constant>false</constant><category>template control</category><attributes><package>AT Profiling UI</package></attributes></shared-variable><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>accessing</category><body package="AT Profiling UI" selector="acceptCutoff">acceptCutoff	"Invoked by the 'apply cutoff' button, to cause the list to be recomputed.  Flush the findNext menu at the same time."	self reports value: ( profiler profileSummaryFilter: self cutoffValue ).	findNextMenu := nil</body><body package="AT Profiling UI" selector="viewingModes">viewingModes	"Answer what modes are available"	^self reports value keys asSortedCollection</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>menu messages</category><body package="AT Profiling UI" selector="browseImplementors">browseImplementors	MethodCollector new		browseAllImplementorsOf: self outlineSelectionInList selection value selector</body><body package="AT Profiling UI" selector="browseMessages">browseMessages	| mc sel |	mc := MethodCollector new.	mc interfaceWindow: builder window.	sel := mc		showMenu: self outlineSelectionInList selection value method allSymbolLiterals asSortedCollection		prompt: (#FindAllImplementorsOf &lt;&lt; #advanced &gt;&gt; 'Find all implementors of...').	sel == nil ifTrue: [^self].	mc browseAllImplementorsOf: sel</body><body package="AT Profiling UI" selector="browseSenders">browseSenders	MethodCollector new browseAllReferencesTo:				self outlineSelectionInList selection value selector</body><body package="AT Profiling UI" selector="findNext:">findNext: aSelector	"Select the next item in the list with the supplied selector."	| start limit |	start := outlineSelectionInList selectionIndex + 1.	limit := outlineSelectionInList list size.	start &gt; limit ifTrue: [start := 1].	start to: limit do:		[:i|		(outlineSelectionInList list at: i) value selector == aSelector ifTrue:			[^outlineSelectionInList selectionIndex: i]].	1 to: start - 1 do:		[:i|		(outlineSelectionInList list at: i) value selector == aSelector ifTrue:			[^outlineSelectionInList selectionIndex: i]].</body><body package="AT Profiling UI" selector="spawnCurrent">spawnCurrent	"Spawn a browser on the receiver's current selection."	self outlineSelectionInList selection == nil		ifTrue: [^self].	( ProfileBrowserHelper source: self outlineSelectionInList selection value root )		browseTally: self outlineSelectionInList selection value</body><body package="AT Profiling UI" selector="spawnTextReport">spawnTextReport	"Transform the profiler's report into textual form so that it can be edited"	| stream textView topView |	stream := TextStream on: String new.	profiler reportTotalsOn: stream.	stream cr.	self printReport: #tree on: stream.	self printReport: #totals on: stream.	self viewingModes		removeAll: #( tree totals );		do: [:name | self printReport: name on: stream].	stream cr.	textView := ComposedTextView model: (ValueHolder with: stream contents).	textView displayObject textStyle: (TextAttributes styleNamed: #fixed).	topView := ScheduledWindow new.	topView controller model: textView model.	topView component: (LookPreferences edgeDecorator on: textView).	topView label: ((#x1sProfile &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; profile')			expandMacrosWith: profiler core description).	topView minimumSize: 200 @ 150.	topView icon: (Icon constantNamed: #workspace).	topView open</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>aspects</category><body package="AT Profiling UI" selector="cutoff">cutoff	^cutoff</body><body package="AT Profiling UI" selector="reports">reports	"... the reports generated by the profiler core."	^reports</body><body package="AT Profiling UI" selector="viewingMode">viewingMode	^viewingMode</body><body package="AT Profiling UI" selector="viewingModeList">viewingModeList	^viewingModeList</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>private</category><body package="AT Profiling UI" selector="cutoffValue">cutoffValue	^( profiler tally * self cutoff value ) rounded</body><body package="AT Profiling UI" selector="nullReport">nullReport	^Array		with: List new		with: []		with: Set new</body><body package="AT Profiling UI" selector="processExtraReport:named:">processExtraReport: list named: aSymbol	"Some report has changed, but it's just a list of strings, or better be."	| listAndBlock newList listSize |	newList := list collect: [:tally | TreeObjectHolder					string: ''					value: tally					leaf: true].	listSize := list size.	listAndBlock := Array				with: newList				with: [:each | each == 0						ifTrue: [1 to: listSize]						ifFalse: [#()]]				with: (1 to: listSize) asSet.	self processedReports value at: aSymbol put: listAndBlock</body><body package="AT Profiling UI" selector="processPriorityTreeReport:">processPriorityTreeReport: tree	"Tree has changed, so redo the tree and list"	| depthDictionary roots listAndBlock |	depthDictionary := IdentityDictionary new.	roots := tree				collect:					[:tally |					depthDictionary at: tally put: ''.					TreeObjectHolder						string: ''						value: tally						leaf: true].	listAndBlock := (TreeBuilder roots: roots				childBlock:					[:node |					| parentDepth childDepth |					parentDepth := depthDictionary at: node value.					childDepth := parentDepth , '  '.					node leaf: false.					(node value childrenOver: self cutoffValue)						collect:							[:tally |							depthDictionary at: tally put: childDepth.							TreeObjectHolder								string: childDepth								value: tally								leaf: true]]) depthFirstListAndBlock.	self processedReports value at: #'tree grouped by priority' put: (Array			with: (listAndBlock at: 1)			with: (listAndBlock at: 2)			with: (1 to: depthDictionary size) asSet)</body><body package="AT Profiling UI" selector="processReports">processReports	"Reports has changed, so redo the tree and totals and generate a	 change on the processed reports, and force the findNextMenu to	 be recomputed."	| rs rks |	rs := self reports value.	rks := rs keys.	Cursor execute showWhile:		[	self processTreeReport: ( rs at: #tree ).			self processTotalsReport: ( rs at: #totals ).			( rks includes:#'tree grouped by priority' )				ifTrue:	[ self processPriorityTreeReport: ( rs at: #'tree grouped by priority' ) ].			profiler stringReportKeys do:				[ :k | ( self viewingModes includes: k )						ifTrue: [ self processExtraReport: (self reports value at: k ) named: k ] ].			self processedReports value: self processedReports value.			findNextMenu := nil]</body><body package="AT Profiling UI" selector="processTotalsReport:">processTotalsReport: list	"The 'totals' report has changed, so redo the processed list."	^self processExtraReport: list named: #totals</body><body package="AT Profiling UI" selector="processTreeReport:">processTreeReport: tree	"Tree has changed, so redo the tree and list"	| depthDictionary roots listAndBlock |	depthDictionary := IdentityDictionary new.	roots := tree				collect:					[:tally |					depthDictionary at: tally put: ''.					TreeObjectHolder						string: ''						value: tally						leaf: true].	listAndBlock := (TreeBuilder roots: roots				childBlock:					[:node |					| parentDepth childDepth |					parentDepth := depthDictionary at: node value.					childDepth := parentDepth , '  '.					node leaf: false.					(node value childrenOver: self cutoffValue)						collect:							[:tally |							depthDictionary at: tally put: childDepth.							TreeObjectHolder								string: childDepth								value: tally								leaf: true]]) depthFirstListAndBlock.	self processedReports value at: #tree put: (Array			with: (listAndBlock at: 1)			with: (listAndBlock at: 2)			with: (1 to: depthDictionary size) asSet)</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>initialize-release</category><body package="AT Profiling UI" selector="initialize">initialize	super initialize.	cutoff := ( 2 /100 ) asValue.	viewingModeList := SelectionInList with: ( List with: #tree ).	viewingMode := viewingModeList selectionHolder.	self viewingMode value: #tree.	reports := Array new asValue.	self reports onChangeSend: #processReports to: self.	self viewingMode onChangeSend: #changed to: self.	self processedReports onChangeSend: #changed to: self.	self viewingMode onChangeSend: #resetMenu to: self.	self outlineSelectionInList selectionIndexHolder onChangeSend: #resetMenu to: self.</body><body package="AT Profiling UI" selector="on:">on: aProfiler	"Set the receiver's tree to be aTree."	| set |	profiler := aProfiler.	set := aProfiler reportKeys.	set removeAll: viewingModeList list.	viewingModeList list addAll: ( set asSortedCollection ).	(self builder aspectAt: #totalsReport) value: aProfiler totalsReport.	self reports value: ( aProfiler profileSummaryFilter: self cutoffValue ).</body><body package="AT Profiling UI" selector="release">release	super release.	self reports retractInterestsFor: self.	self viewingMode retractInterestsFor: self.	self processedReports retractInterestsFor: self.	self outlineSelectionInList selectionIndexHolder retractInterestsFor: self.</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="preBuildWith:">preBuildWith: aBuilder	"This message is sent by the builder prior to beginning construction	of either a SubCanvas or a complete window."	super preBuildWith: aBuilder.	aBuilder aspectAt: #totalsReport put: String new asValue.</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>menu item disabling</category><body package="AT Profiling UI" selector="resetMenu">resetMenu	"enable/disable menu items based on the current viewingMode and	the presence or absence of a selection."	| menu vmv |	menu := self builder menuAt: #outlineMenu.	vmv := self viewingMode value.	( vmv == #tree or: [ vmv == #'tree grouped by priority' ] )		ifTrue:			[self outlineSelectionInList selection isNil				ifTrue:					[menu menuItems do: [:item | item disable].					(menu atNameKey: #expandFully) enable.					(menu atNameKey: #findNextMenu) enable]				ifFalse: [menu menuItems do: [:item | item enable]].			^self].	self viewingMode value == #totals		ifTrue:			[self outlineSelectionInList selection isNil				ifTrue:					[menu menuItems do: [:item | item disable].					(menu atNameKey: #findNextMenu) enable]				ifFalse:					[menu menuItems do: [:item | item enable].					(menu atNameKey: #expand) disable.					(menu atNameKey: #expandFully) disable.					(menu atNameKey: #contractFully) disable].			^self].	menu menuItems do: [:item | item disable]</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>changing</category><body package="AT Profiling UI" selector="changed">changed	| vmv processedReport |	vmv := self viewingMode value.	processedReport := ( vmv isNil )							ifTrue:	[ self nullReport ]							ifFalse:	[ self processedReports value at: vmv ].	self with: ( processedReport at: 1 )		childBlock: ( processedReport at: 2 )		enabled: ( processedReport at: 3 ).	findNextMenu := nil</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>private aspects</category><body package="AT Profiling UI" selector="findNextMenu">findNextMenu	"Prompt the user for the next selector to select."	| list selector |	findNextMenu isNil ifTrue:		[list := Set new: outlineSelectionInList list size.		outlineSelectionInList list do:			[:node|			list add: node value selector].		findNextMenu := list asSortedCollection asArray].	selector := Dialog					choose: (#SelectMethod &lt;&lt; #advanced &gt;&gt; 'Select method')					fromList: findNextMenu values: findNextMenu					buttons: #() values: #()					lines: (32 min: findNextMenu size)					cancel: []					for: nil.	selector notNil ifTrue: [self findNext: selector]</body><body package="AT Profiling UI" selector="processedReports">processedReports	"The tree and flat report generated by the profile"	^( processedReports isNil )		ifTrue:	[ processedReports := Dictionary new asValue ]		ifFalse:	[ processedReports ]</body></methods><methods><class-id>Tools.ProfileOutlineBrowser</class-id> <category>printing</category><body package="AT Profiling UI" selector="printReport:on:">printReport: reportID on: aStream	| name processedReport lines displayedLines |	name := String fromString: reportID.	name at: 1 put: name first asUppercase.	aStream cr; nextPutAll: ((#asterisks1s &lt;&lt; #advanced &gt;&gt; '** &lt;1s&gt; **')			expandMacrosWith: name); cr.	processedReport := self processedReports value at: reportID.	lines := processedReport at: 1.	displayedLines := processedReport at: 3.	(displayedLines asSortedCollection)		do: [:index | aStream print: (lines at: index); cr]</body></methods><methods><class-id>Tools.ProfileOutlineBrowser class</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="openOutlineBrowserOn:label:">openOutlineBrowserOn: aProfiler label: aString	"The opening interface for this browser has a different protocol than the usual ApplicationModel as part of its history.  ... altered to answer a builder, like other interface opening methods"	| bldr window |	bldr := self open.	window := bldr window.	window label: aString.	window model on: aProfiler.	^bldr</body></methods><methods><class-id>Tools.ProfileBrowserHelper</class-id> <category>selections</category><body package="AT Profiling UI" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#messageTally</body><body package="AT Profiling UI" selector="targetClassOrNameSpace">targetClassOrNameSpace	"The receiver holds a list of MessageTallies. Instances of these	always have a class."	^self selection isNil		ifTrue: [nil]		ifFalse: [self selection methodClass]</body></methods><methods><class-id>Tools.ProfileBrowserHelper</class-id> <category>private</category><body package="AT Profiling UI" selector="decorate:">decorate: aMessageTally	| index i1 off |	index := tallies identityIndexOf: aMessageTally.	i1 := tallies identityIndexOf: focus.	off := ( index &lt; i1 )			ifTrue:	[ 0 ]			ifFalse: [ ( index &gt; i1 )						ifTrue:	[ 48 ]						ifFalse:	[ 24 ] 					].	^( super decorate: aMessageTally ) offset: off@0</body><body package="AT Profiling UI" selector="definitionOf:">definitionOf: aMessageTally	^MessageTallyDefinition new tally: aMessageTally</body><body package="AT Profiling UI" selector="textEmphasisForItem:">textEmphasisForItem: anItem	^anItem == focus		ifTrue:	[ self class focusEmphasis ]		ifFalse:	[ super textEmphasisForItem: anItem ]</body></methods><methods><class-id>Tools.ProfileBrowserHelper</class-id> <category>accessing</category><body package="AT Profiling UI" selector="focus:">focus: aMessageTally	focus := aMessageTally</body><body package="AT Profiling UI" selector="source">source	^source</body><body package="AT Profiling UI" selector="source:">source: aMessageTally	source := aMessageTally</body><body package="AT Profiling UI" selector="tallies:">tallies: aList	tallies := aList</body><body package="AT Profiling UI" selector="windowLabel">windowLabel	^focus printString</body></methods><methods><class-id>Tools.ProfileBrowserHelper</class-id> <category>list accessing</category><body package="AT Profiling UI" selector="updateListFull">updateListFull	| ctxts |	ctxts := List new: 100.	ctxts addAll: tallies.	module setNewList: ctxts</body></methods><methods><class-id>Tools.ProfileBrowserHelper</class-id> <category>actions</category><body package="AT Profiling UI" selector="spawnMethod">spawnMethod	"Spawn a new browser like us"	( self class source: source)		browseTally: ( source detect: [ :x | x = module selection ] ifNone: [] )</body></methods><methods><class-id>Tools.ProfileBrowserHelper</class-id> <category>utility</category><body package="AT Profiling UI" selector="browseSpawnList:withFocus:">browseSpawnList: aCollection withFocus: aMessageTally	self tallies: aCollection.	self focus: aMessageTally.	FullSystemBrowser new		components: ( Array with: ( SimpleBrowserModule new helper: self ) );		open</body><body package="AT Profiling UI" selector="browseTally:">browseTally: aMessageTally	| spawnList node |	spawnList := OrderedCollection new: 11.	node := self integrateTalliesForNode: aMessageTally intoCollection: spawnList.	self browseSpawnList: spawnList withFocus: node</body><body package="AT Profiling UI" selector="integrateTalliesForNode:intoCollection:">integrateTalliesForNode: targetMessageTally intoCollection: aCollection	| copyMT rootMT targetMT pSet cSet pT pS tT tS cF |	"I.  Set up working root and target message tallies."	copyMT := targetMessageTally root copy.	rootMT := ( ( MessageTally new )					class: copyMT methodClass					method: copyMT method )						tally: copyMT tally;						samples: copyMT samples;						yourself.	targetMT := ( MessageTally new )					class: targetMessageTally methodClass					method: targetMessageTally method.	"II.  Pass 1 :Classify nodes as parents or children of the target, and set links."	( copyMT )		classifyFromWith: targetMT 		parents: ( pSet := Set new: 7 )		children: ( cSet := Set new: 7 ).	pSet do:		[ :mt |	mt parent: rootMT.				rootMT receivers at: mt method put: mt 		].	targetMT parent: pSet asSortedCollection last.	cSet do:		[ :mt |	mt parent: targetMT.				targetMT receivers at: mt method put: mt		].	"III.  Pass 2 : Integrate the data."	( cSet isEmpty not )		ifTrue:	[ ( copyMT ) integrateChildrenFrom: targetMT children: cSet ].	( copyMT ) integrateParentsFrom: targetMT parents: pSet.	"IV. No children fix-ups."	( cSet isEmpty )		ifTrue:	[	pT := pSet inject: 0 into: [ :x : y | x + y tally ].					pS := pSet inject: 0 into: [ :x :y | x + y samples ].				 	targetMT  bump: pT samples: pS.					cF := ( copyMT copy )								name: ( #noChildren &lt;&lt; #advanced &gt;&gt; '&lt;no children&gt;' ) asString;								parent: targetMT;								yourself.					cSet add: cF.					targetMT receivers at: cF method put: cF.				].	"V. Primitive fix-ups."	( cSet isEmpty not )		ifTrue:	[	pT := pSet inject: 0 into: [ :x : y | x + y tally ].					pS := pSet inject: 0 into: [ :x :y | x + y samples ].					tT := targetMT tally.					tS := targetMT samples.					( ( pT &gt; tT ) and: [ ( ( pT - tT ) / pT ) &gt; 0.001 ] )					ifTrue:	[ 	targetMT tally: pT; samples: pS.								cF := ( copyMT copy )										name: (#primitives &lt;&lt; #advanced &gt;&gt; 'primitives') asString;										parent: targetMT;										tally: pT - tT;										samples: pS - tS;										yourself.								cSet add: cF.								targetMT receivers at: cF method put: cF.							]				].	"VI.  Organize output and return."	aCollection addAll: pSet asSortedCollection.	aCollection add: targetMT.	aCollection addAll: targetMT receivers values asSortedCollection.	^targetMT</body></methods><methods><class-id>Tools.ProfileBrowserHelper class</class-id> <category>class initialization</category><body package="AT Profiling UI" selector="initialize">initialize	"ProfileBrowserHelper initialize"	FocusEmphasis := #(#bold).</body></methods><methods><class-id>Tools.ProfileBrowserHelper class</class-id> <category>public api</category><body package="AT Profiling UI" selector="browseTally:">browseTally: aMessageTally	"Spawn a browser on the receiver's current selection."	( self source: aMessageTally root ) browseTally: aMessageTally</body><body package="AT Profiling UI" selector="focusEmphasis">focusEmphasis	^FocusEmphasis</body><body package="AT Profiling UI" selector="focusEmphasis:">focusEmphasis: emphasisArray	"ProfileBrowserHelper focusEmphasis: (Array with: #bold with: #color-&gt;ColorValue darkMagenta)"	"ProfileBrowserHelper focusEmphasis: #(#bold)"	FocusEmphasis := emphasisArray</body></methods><methods><class-id>Tools.ProfileBrowserHelper class</class-id> <category>instance creation</category><body package="AT Profiling UI" selector="source:">source: aMessageTally	^( self new )		source: aMessageTally;		yourself</body></methods><methods><class-id>Tools.TreeBuilder</class-id> <category>node adding</category><body package="AT Profiling UI" selector="child:parent:">child: childNode parent: parentNode	"Add the node as a child of the given parent"	(childDictionary at: parentNode)		add: childNode.	childDictionary at: childNode put: List new.</body><body package="AT Profiling UI" selector="root:">root: aRootNode	"Add the node as a root"	rootList add: aRootNode.	childDictionary at: aRootNode put: List new</body></methods><methods><class-id>Tools.TreeBuilder</class-id> <category>initialize-release</category><body package="AT Profiling UI" selector="initialize">initialize	rootList := List new.	childDictionary := Dictionary new.</body></methods><methods><class-id>Tools.TreeBuilder</class-id> <category>reading</category><body package="AT Profiling UI" selector="depthFirstListAndBlock">depthFirstListAndBlock	"Return a list of the nodes in depth first order and a block that	indicates the child indices in the list"	| depthFirstNodeList indexDictionary nodeBlock |	depthFirstNodeList := List new.	indexDictionary := Dictionary new.	nodeBlock :=			[:aNodeList :parentIndex |			indexDictionary at: parentIndex put: List new.			aNodeList				do:					[:eachNode |					| thisNodeIndex |					depthFirstNodeList add: eachNode.					thisNodeIndex := depthFirstNodeList size.					(indexDictionary at: parentIndex)						add: thisNodeIndex.					(childDictionary at: eachNode) isEmpty						ifTrue: [eachNode leaf: true].					nodeBlock value: (childDictionary at: eachNode)						value: thisNodeIndex]].	nodeBlock value: rootList value: 0.	^Array with: depthFirstNodeList with: [:index | indexDictionary at: index]</body></methods><methods><class-id>Tools.TreeBuilder class</class-id> <category>examples</category><body package="AT Profiling UI" selector="example1">example1	"self example1"	"The numbers from 1 to 10 with the parent being the lowest factor"	| builder |	builder := self new.	builder initialize.	builder root: '1'.	builder child: '2' parent: '1'.	builder child: '3' parent: '1'.	builder child: '5' parent: '1'.	builder child: '7' parent: '1'.	builder child: '4' parent: '2'.	builder child: '6' parent: '2'.	builder child: '8' parent: '2'.	builder child: '9' parent: '3'.	builder child: '10' parent: '2'.	^builder depthFirstListAndBlock</body></methods><methods><class-id>Tools.TreeBuilder class</class-id> <category>instance creation</category><body package="AT Profiling UI" selector="new">new	^super new initialize</body><body package="AT Profiling UI" selector="roots:childBlock:">roots: aCollection childBlock: aBlock	| tree childBlock |	tree := self new.	aCollection do: [:eachRoot | "Given the collection of roots and a block that given a node will		return all the children, build a tree."		tree root: eachRoot].	childBlock :=			[:aNode |			| children |			children := aBlock value: aNode.			children				do:					[:aChild |					tree child: aChild parent: aNode.					childBlock value: aChild]].	aCollection do: childBlock.	^tree</body></methods><methods><class-id>Tools.Profiler</class-id> <category>accessing</category><body package="AT Profiling UI" selector="core">core	^core</body><body package="AT Profiling UI" selector="howMany">howMany	"... added for backward compatibility in the public api."	^self samplingInterval</body><body package="AT Profiling UI" selector="maxSamplingInterval">maxSamplingInterval	"Answer an appropriate upper bound for sampleSize"	^core maxSamplingInterval</body><body package="AT Profiling UI" selector="sampleUnitName">sampleUnitName	"Answer a string describing what units of measure the receiver uses to measure resources. For example, TimeProfilers measure 'milliseconds', and AllocationProfilers measure 'bytes'."	^self subclassResponsibility</body><body package="AT Profiling UI" selector="samplingInterval">samplingInterval	"Answer the amount that will trigger a sample of the execution, in appropriate units"	^samplingIntervalAdaptor value</body><body package="AT Profiling UI" selector="tally">tally	^core tally</body></methods><methods><class-id>Tools.Profiler</class-id> <category>reporting</category><body package="AT Profiling UI" selector="labelForReportNamed:">labelForReportNamed: aReportId	( aReportId = #tree )		ifTrue:	[ ^#treeViewMode &lt;&lt; #tools &gt;&gt; 'Tree' ].	( aReportId = #totals )		ifTrue:	[ ^#totalsViewMode &lt;&lt; #tools &gt;&gt; 'Totals' ].	^aReportId</body><body package="AT Profiling UI" selector="profileSummaryFilter:">profileSummaryFilter: limit	"Answer a dictionary which maps a summary title to a SequenceableCollection of report fields for that summary."	| rootTally flatSummary |	rootTally := core rootTally.	flatSummary := Set new: 128.	rootTally addLocalUsageInto: flatSummary.	^Dictionary new		at: #tree put: ( Array with: rootTally );		at: #totals put: ( flatSummary select: [:node | node tally &gt; limit] ) asSortedCollection;		yourself</body><body package="AT Profiling UI" selector="reportKeys">reportKeys	^Set withAll: #( #totals #tree )</body><body package="AT Profiling UI" selector="reportOn:cutoffPercent:">reportOn: aStream cutoffPercent: percent	"Write a profile report on the supplied stream."	core tally = 0		ifTrue:	[	aStream nextPutAll: (#noSamples &lt;&lt; #advanced &gt;&gt; 'no samples') asString				]		ifFalse:	[	self reportTotalsOn: aStream.					aStream cr; cr.					core rootTally fullPrintOn: aStream cutoff: percent				]</body><body package="AT Profiling UI" selector="reportTotalsOn:">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	self subclassResponsibility</body><body package="AT Profiling UI" selector="stringReportKeys">stringReportKeys	^Set withAll: #( #'space usage' )</body><body package="AT Profiling UI" selector="totalsReport">totalsReport	| stream |	stream := ( String new: 256 ) writeStream.	self reportTotalsOn: stream.	^stream contents</body></methods><methods><class-id>Tools.Profiler</class-id> <category>aspects</category><body package="AT Profiling UI" selector="samplingIntervalAdaptor">samplingIntervalAdaptor	^samplingIntervalAdaptor</body><body package="AT Profiling UI" selector="textModel">textModel	^( textModel isNil )		ifTrue:	[ textModel := String new asValue ]		ifFalse:	[ textModel ]</body></methods><methods><class-id>Tools.Profiler</class-id> <category>initialize-release</category><body package="AT Profiling UI" selector="initialize">initialize	super initialize.	core := self class coreClass new.	samplingIntervalAdaptor := ( PluggableAdaptor on: core )							getBlock:	[:m | m samplingInterval ] 							putBlock: [:m :v | m samplingInterval: v ]							updateBlock: [:m :a :p | true ].	textModel := ( EvaluationHolder new ) object: self</body><body package="AT Profiling UI" selector="release">release	super release.	core release</body></methods><methods><class-id>Tools.Profiler</class-id> <category>public api</category><body package="AT Profiling UI" selector="howMany:">howMany: amount	"... added for backward compatibility in the public api."	self samplingInterval: amount</body><body package="AT Profiling UI" selector="profile:">profile: aBlock	^self profile: aBlock onExitDo: self class defaultExitBlock</body><body package="AT Profiling UI" selector="profile:onExitDo:">profile: aBlock onExitDo: exitBlock	self reinitializeCore.	self core targetBlock: aBlock.	self class coreClass 		coreStart: self		onExitDo: exitBlock.	^aBlock		ensure: [ self class stopProfiling ]</body><body package="AT Profiling UI" selector="profile:reportTo:">profile: theBlock reportTo: filename	^self 		profile: theBlock 		onExitDo: ( self class defaultFileBlock: filename )</body><body package="AT Profiling UI" selector="reinitializeCore">reinitializeCore	| samplingInterval |	samplingInterval := self samplingInterval. 	core  		stopWatching;  		initialize; 		samplingInterval: samplingInterval</body><body package="AT Profiling UI" selector="samplingInterval:">samplingInterval: anInteger	"Set the amount of resource to be consumed before sampling."	samplingIntervalAdaptor value: anInteger</body><body package="AT Profiling UI" selector="stopProfiling">stopProfiling	self class stopProfiling</body></methods><methods><class-id>Tools.Profiler</class-id> <category>private</category><body package="AT Profiling UI" selector="accept">accept	"Be a good model for dialog views"</body></methods><methods><class-id>Tools.Profiler</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="labelFor:">labelFor: aKey	( aKey == #sampleUnitName )		ifTrue:	[ ^self sampleUnitName ].	( aKey == #maxSamplingInterval )		ifTrue: [ ^self maxSamplingInterval printString ].	^nil</body><body package="AT Profiling UI" selector="postBuildWith:">postBuildWith: aBuilder	"Alter the performer in the text window to be the controller."	| textModelController |	super postBuildWith: aBuilder.	( aBuilder componentAt: #sampleSizeSlider) widget 		rangeMap:	( RangeMap						start: 1						stop: self maxSamplingInterval						grid: 1).	aBuilder window label: ((#Profile1s &lt;&lt; #advanced &gt;&gt; 'Profile &lt;1s&gt;')			expandMacrosWith: core description).	textModelController := ( aBuilder componentAt: #textModel ) widget controller.	textModelController performer: textModelController</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI" selector="activeProfilerCore">activeProfilerCore	^self coreClass activeProfilerCore</body><body package="AT Profiling UI" selector="coreClass">coreClass	self subclassResponsibility</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>testing</category><body package="AT Profiling UI" selector="needsSafeRebinding">needsSafeRebinding	^true</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>parcel load/unload/save</category><body package="AT Profiling UI" selector="preUnloadFor:">preUnloadFor: aParcel	"Close any open applications implemented by this parcel."	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>public api</category><body package="AT Profiling UI" selector="defaultExitBlock">defaultExitBlock	^[ :spy | ProfileOutlineBrowser 				openOutlineBrowserOn: spy 				label: ((#x1sProfile &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; profile')			expandMacrosWith: spy core description)	]</body><body package="AT Profiling UI" selector="defaultFileBlock:">defaultFileBlock: aFilename	^[ :spy |	| fs |			fs := aFilename writeStream.			[	fs timeStamp; cr.				spy 					reportOn: fs 					cutoffPercent: 1			] ensure: [ fs close ]	]</body><body package="AT Profiling UI" selector="profile:">profile: theBlock	"Set a block up for profiling and open a ProfileOutlineBrowser containing the report.  Do not use this method to invoke 'multi' profilers."	"((( AllocationProfiler profile: [ 10 timesRepeat: [ ScheduledControllers restore ] ] )))"	"((( TimeProfiler profile: [ 10 timesRepeat: [ ScheduledControllers restore ] ] )))"	^self		profile: theBlock 		onExitDo: self defaultExitBlock</body><body package="AT Profiling UI" selector="profile:onExitDo:">profile: theBlock onExitDo: exitBlock	self coreClass 		coreStart: ( self on: theBlock ) 		onExitDo: exitBlock.	^theBlock		ensure: [ self stopProfiling ]</body><body package="AT Profiling UI" selector="profile:reportTo:">profile: theBlock reportTo: aFilenameOrString	"Set a block up for profiling and write the report on the supplied file.  Answer the block's value."	"((( AllocationProfiler profile: [ 10 timesRepeat: [ 5000 factorial ] ] reportTo: 'factorial.rpt' asFilename )))"	"((( TimeProfiler profile: [ 10 timesRepeat: [ 5000 factorial ] ] reportTo: 'factorial.rpt' asFilename )))"	self 		profile: theBlock 		onExitDo: ( self defaultFileBlock: aFilenameOrString asFilename )</body><body package="AT Profiling UI" selector="stopProfiling">stopProfiling	self coreClass coreStopProfiling</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>abstract resources</category><body package="AT Profiling UI" selector="textModelMenu">textModelMenu	^Menu new		addPart: ParagraphEditor editGroup;		addPart: ParagraphEditor evaluateGroup;		addPart: ParagraphEditor hardcopyGroup;		yourself</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>instance creation</category><body package="AT Profiling UI" selector="new">new	"Answer a new Profiler, properly initialized.  Catch the simple error of using the abstract class."	( self == Profiler )		ifTrue: [ ^self error: (#ProfilerIsAnAbstractClassUseAConcreteSubclass &lt;&lt; #advanced &gt;&gt; 'Profiler is an abstract class.  Use a concrete subclass.') ].	^super new</body><body package="AT Profiling UI" selector="on:">on: aBlock	"Answer a new Profiler, ready to spy on the supplied block."	| n |	n := self new.	n core targetBlock: aBlock.	^n</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="basicText">basicText	^(#BasicText &lt;&lt; #advanced &gt;&gt; '"Profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  A profiling run is adequate if it takes enough samples to produce estimates accurate enough to justify decision.  (The number of samples actually taken is the first item reported after a standard profiling run, in the upper left hand corner of the spawned ProfilerOutlineBrowser.)  The required number of samples required increases with the extent of the resources consumed by the profiled process, and with an increase in the degree of discrimination required.  You may increase the number of samples by either raising the number of repetitions or lowering the sampling interval.  If you wish to compare several alternative implementations, use the same number of repetitions and the same sampling interval in the profiling run of each.  You may increase the relative precision of sequentially executed, comparative runs by evaluating ''ObjectMemory globalGarbageCollect'' before each."') asString</body><body package="AT Profiling UI" selector="demonstrationText:">demonstrationText: iterationCount	^(#DemonstrationText &lt;&lt; #advanced &gt;&gt; '"The three runs below profile alternative approaches to String construction.  Evaluate each test separately and compare the results."	"mere concatenation"	"((( self				samplingInterval: 3;			profile:	[ &lt;1p&gt; timesRepeat:						[ | str |  str := ''''. 256 timesRepeat: [ str := str, ''~'' ] ] ] )))"	"conventionally allocated WriteStream"	"((( self				samplingInterval: 3;			profile:	[ &lt;1p&gt; timesRepeat:						[ | str |  str := WriteStream on: ( String new ).								256 timesRepeat: [ str nextPut: $~ ] ] ] )))"	"WriteStream allocated with a decent estimate of the expected size"	"((( self				samplingInterval: 3;			profile:	[ &lt;1p&gt; timesRepeat:						[ | str |  str := WriteStream on: ( String new: 192 ).								256 timesRepeat: [ str nextPut: $~ ] ] ] )))"')		expandMacrosWithArguments: ( Array with: iterationCount )</body><body package="AT Profiling UI" selector="multiText">multiText	^(#MultiText &lt;&lt; #advanced &gt;&gt; '"Profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  In multi-profilers, the samples are distributed over several processes rather than one.  This fact should be kept in view when setting up multi-profiling runs or evaluating the reliability of their reports.  To exercise the &lt;1p&gt;, select and evaluate the following expressions, separately, and in order.  More than one test expression may be executed between the ''start'' and ''stop'' lines.  Alternatively, you may execute the "start" line to begin profiling processes already initiated, or the system in general.  Be sure always to execute a ''stopProfiling'' after a ''startProfiling*''.  Multi-profilers may generate vary large tally trees, with few processes consuming more than a fraction of a percent of the total resource usage, that it may take several minutes to display after you have lowered the cutoff percentage."')	expandMacrosWithArguments: ( Array with: self )</body><body package="AT Profiling UI" selector="openViewWithText:">openViewWithText: aText	"... altered to answer a builder, like other interface opening methods."	| instance |	instance := self new.	instance textModel value: aText.	^[ self openOn: instance ]		on: GetWindowManagerUsagePolicy		do: [ :ex | ex resume: UseParentWindowManagerUsagePolicy new ]</body><body package="AT Profiling UI" selector="templateText">templateText	^self subclassResponsibility</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>accessing</category><body package="AT Profiling UI" selector="showTemplates">showTemplates	^ShowTemplates</body><body package="AT Profiling UI" selector="showTemplates:">showTemplates: aBoolean	"((( self showTemplates: true )))"	"((( self showTemplates: false )))"	ShowTemplates := aBoolean</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>class initialization</category><body package="AT Profiling UI" selector="initialize">initialize	"Profiler initialize"	ShowTemplates := false.</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>private</category><body package="AT Profiling UI" selector="markedAsSystemClass">markedAsSystemClass	"This class is not to be shown when browsing user classes."</body></methods><methods><class-id>Tools.AllocationProfiler</class-id> <category>reporting</category><body package="AT Profiling UI" selector="bytesForClass:basedOn:">bytesForClass: class basedOn: counts	| count vslots |	count := class isVariable ifTrue: [counts at: 1] ifFalse: [counts].	vslots := class isVariable ifTrue: [counts at: 2] ifFalse: [0].	^(( AllocationProfilerCore.ByteOverhead + (class instSize * 4)) * count) +				(class isBits ifTrue: [vslots] ifFalse: [vslots * 4]).</body><body package="AT Profiling UI" selector="labelForReportNamed:">labelForReportNamed: aReportId	( aReportId = #'space usage' )		ifTrue:	[ ^#spaceViewMode &lt;&lt; #tools &gt;&gt; 'Space Usage' ].	^super labelForReportNamed: aReportId</body><body package="AT Profiling UI" selector="profileSummaryFilter:">profileSummaryFilter: limit	"Answer a dictionary which maps a summary title to a	SequenceableCollection of report fields for that summary."	| summary statistics |	summary := super profileSummaryFilter: limit.	statistics := core statistics.	( statistics isNil or: [ statistics isEmpty ] )		ifFalse: [summary at: #'space usage' put: self statisticsProfile].	^summary</body><body package="AT Profiling UI" selector="reportKeys">reportKeys	| sc |	sc := super reportKeys.	( core statistics notNil )		ifTrue: [ sc add: #'space usage' ].	^sc</body><body package="AT Profiling UI" selector="reportOn:cutoffPercent:">reportOn: aStream cutoffPercent: percent	"Write a profile report on the supplied stream."	| statistics |	super reportOn: aStream cutoffPercent: percent.	statistics := core statistics.	( statistics isNil or: [ statistics isEmpty ] )		ifFalse: [ self reportStatisticsOn: aStream ]</body><body package="AT Profiling UI" selector="reportStatisticsOn:">reportStatisticsOn: aStream	"Write a statistics report on the supplied stream."	| statistics sc tbstb1 tbstp2 ptrInsts byInsts ptrSz bySz |	statistics := core statistics.	tbstb1 := 40.	tbstp2 := 20.	aStream cr; cr.	aStream nextPutAll: (#Class &lt;&lt; #advanced &gt;&gt; '    Class') asString.	aStream next: ( tbstb1 - 9 ) put: Character space.	aStream nextPutAll: (#instances &lt;&lt; #advanced &gt;&gt; 'instances') asString.	aStream next: ( tbstp2 - 9 ) rounded put: Character space.	aStream nextPutAll: (#sizeBytes &lt;&lt; #advanced &gt;&gt; 'size (bytes)') asString.	aStream cr.	sc := SortedCollection sortBlock:				[:x :y |				(self bytesForClass: x key basedOn: x value)					&gt;= (self bytesForClass: y key basedOn: y value)].	statistics associationsDo: [:ass | sc add: ass].	ptrInsts := byInsts := ptrSz := bySz := 0.	sc do:		[:elem |		| class count bytes |		class := elem key.		count := class isVariable ifTrue: [elem value at: 1] ifFalse: [elem value].		bytes := self bytesForClass: class basedOn: elem value.		class isBits			ifTrue: [byInsts := byInsts + count. bySz := bySz + bytes]			ifFalse: [ptrInsts := ptrInsts + count. ptrSz := ptrSz + bytes].		aStream nextPutAll: class printString.		aStream next: ( tbstb1 - class printString size max: 1 ) put: Character space.		aStream nextPutAll: count printString.		aStream next: ( tbstp2 - count printString size ) put: Character space.		aStream print: bytes.		aStream cr].	aStream crtab; nextPutAll: (#AllocationSummary &lt;&lt; #advanced &gt;&gt; '  Allocation summary:') asString; cr.	aStream nextPutAll: ((#x1pTotalObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; total objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: byInsts + ptrInsts			with: ((bySz + ptrSz) asFloat / (byInsts + ptrInsts) roundTo: 0.1)); cr.	aStream nextPutAll: ((#x1pByteObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; byte objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: byInsts			with: (bySz asFloat / (byInsts max: 1) roundTo: 0.1)); cr.	aStream nextPutAll: ((#x1pPointerObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; pointer objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: ptrInsts			with: (ptrSz asFloat / (ptrInsts max: 1) roundTo: 0.1)); cr.	aStream cr</body><body package="AT Profiling UI" selector="reportTotalsOn:">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	| samples totalBytes |	samples := core samples.	totalBytes := core totalBytes.	aStream nextPutAll: ((#SamplesAverageBytesPerSampleScavengesIncGCsnBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; samples, &lt;2p&gt; average bytes/sample, &lt;4p&gt; scavenges, &lt;5p&gt; incGCs,&lt;n&gt;&lt;3p&gt; bytes')			expandMacrosWithArguments:				((Array new: 5)					at: 1 put: samples;					at: 2 put: ( samples = 0 ifTrue: [0] ifFalse: [totalBytes // samples] );					at: 3 put: totalBytes;					at: 4 put: core scavenges;					at: 5 put: core incrementalGCs;					yourself))</body><body package="AT Profiling UI" selector="statisticsProfile">statisticsProfile	"Write a statistics report on the supplied stream."	| a sc bySz ptrSz byInsts ptrInsts aStream |	a := OrderedCollection new.	sc := SortedCollection sortBlock:				[:x :y |				(self bytesForClass: x key basedOn: x value)					&gt;= (self bytesForClass: y key basedOn: y value)].	core statistics associationsDo: [:ass | sc add: ass].	ptrInsts := byInsts := ptrSz := bySz := 0.	aStream := String new writeStream.	aStream nextPutAll: (#Class &lt;&lt; #advanced &gt;&gt; '    Class') asString.	aStream next: (31 - aStream position) rounded put: Character space.	aStream nextPutAll: (#Instances &lt;&lt; #advanced &gt;&gt; 'Instances') asString.	aStream next: 47 - aStream position put: Character space.	aStream nextPutAll: (#Bytes &lt;&lt; #advanced &gt;&gt; 'Bytes') asString.	a add: (LabeledObjectHolder string: aStream contents).	sc do:		[:elem |		| class count  bytes |		class := elem key.		count := class isVariable ifTrue: [elem value at: 1] ifFalse: [elem value].		bytes := self bytesForClass: class basedOn: elem value.		class isBits			ifTrue: [byInsts := byInsts + count. bySz := bySz + bytes]			ifFalse: [ptrInsts := ptrInsts + count. ptrSz := ptrSz + bytes].		aStream := String new writeStream.		aStream nextPutAll: class printString.		aStream next: (33 - class printString size max: 1) rounded put: Character space.		aStream nextPutAll: count printString.		aStream next: 13 - count printString size rounded put: Character space.		aStream print: bytes.		a add: (LabeledObjectHolder string: aStream contents).].	a add: (LabeledObjectHolder string: ' ').	a add: (LabeledObjectHolder string: (#AllocationSummary &lt;&lt; #advanced &gt;&gt; '  Allocation summary:') asString).	a add: (LabeledObjectHolder string: ((#x1pTotalObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; total objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: byInsts + ptrInsts			with: ((bySz + ptrSz) asFloat / (byInsts + ptrInsts) roundTo: 0.1))).	a add: (LabeledObjectHolder string: ((#x1pByteObjectsAverageSize2pBytes  &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; byte objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: byInsts			with: (bySz asFloat / (byInsts max: 1) roundTo: 0.1))).	a add: (LabeledObjectHolder string: ((#x1pPointerObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; pointer objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: ptrInsts			with: (ptrSz asFloat / (ptrInsts max: 1) roundTo: 0.1))).	^a</body></methods><methods><class-id>Tools.AllocationProfiler</class-id> <category>public api</category><body package="AT Profiling UI" selector="keepStatistics:">keepStatistics: aBoolean	core keepStatistics: aBoolean</body></methods><methods><class-id>Tools.AllocationProfiler</class-id> <category>accessing</category><body package="AT Profiling UI" selector="sampleUnitName">sampleUnitName	^(#bytes &lt;&lt; #advanced &gt;&gt; 'bytes') asString</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI" selector="coreClass">coreClass	^AllocationProfilerCore</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>public api</category><body package="AT Profiling UI" selector="profile:">profile: theBlock	^self profile: theBlock withStatistics: false</body><body package="AT Profiling UI" selector="profile:withStatistics:">profile: theBlock withStatistics: trueOrFalse	"Set a block up for profiling and open a workspace containing the report."	"((( AllocationProfiler profile: [ScheduledControllers restore] withStatistics: true )))"	self coreClass 		coreStart: ( ( self on: theBlock ) keepStatistics: trueOrFalse )		onExitDo:	[ :spy | ProfileOutlineBrowser 								openOutlineBrowserOn: spy 								label: ((#x1sProfile &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; profile')			expandMacrosWith: spy core description)					].	^theBlock		ensure: [ self stopProfiling ]</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="openView">openView	"... altered to answer a builder, like other interface opening methods."	"((( AllocationProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self basicText, ( self demonstrationText: 1000 ) ].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI" selector="templateText">templateText	^'	"(((	self 			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] )))"	"(((	self 			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ]			reportTo: ((aFilename)) )))"	"(((	self			keepStatistics: ((aBoolean));			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ]  )))"	"(((	( self 			keepStatistics: ((aBoolean));			samplingInterval: ((anIntegerS));			yourself )				profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] 				onExitDo: ((aBlock)) )))"'</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>private</category><body package="AT Profiling UI" selector="markedAsSystemClass">markedAsSystemClass	"This class is not to be shown when browsing user classes."</body></methods><methods><class-id>Tools.MultiAllocationProfiler</class-id> <category>reporting</category><body package="AT Profiling UI" selector="profileSummaryFilter:">profileSummaryFilter: limit	"Answer a dictionary which maps a summary title to a	SequenceableCollection of report fields for that summary."	| summary |	summary := super profileSummaryFilter: limit.	summary at: #'tree grouped by priority' put: ( Array with: ( core priorityTally ) ).	^summary</body><body package="AT Profiling UI" selector="reportKeys">reportKeys	^( super reportKeys )		add: #'tree grouped by priority';		yourself</body></methods><methods><class-id>Tools.MultiAllocationProfiler</class-id> <category>public api</category><body package="AT Profiling UI" selector="profile:">profile: aBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:onExitDo:">profile: aBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:reportTo:">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI" selector="startProfiling">startProfiling	^self startProfilingWithStatistics: false</body><body package="AT Profiling UI" selector="startProfilingReportTo:">startProfilingReportTo: aFilename	^self		startProfilingWithStatistics: true		onExitDo: ( self class defaultFileBlock: aFilename )</body><body package="AT Profiling UI" selector="startProfilingWithStatistics:">startProfilingWithStatistics: trueOrFalse	^self		startProfilingWithStatistics: trueOrFalse 		onExitDo: self class defaultExitBlock</body><body package="AT Profiling UI" selector="startProfilingWithStatistics:onExitDo:">startProfilingWithStatistics: trueOrFalse onExitDo: exitBlock	self reinitializeCore.	^self class coreClass 		coreStart: ( self keepStatistics: trueOrFalse ) 		onExitDo: exitBlock</body></methods><methods><class-id>Tools.MultiAllocationProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI" selector="coreClass">coreClass	^MultiAllocationProfilerCore</body></methods><methods><class-id>Tools.MultiAllocationProfiler class</class-id> <category>public api</category><body package="AT Profiling UI" selector="profile:">profile: theBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:onExitDo:">profile: theBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:reportTo:">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI" selector="startProfiling">startProfiling	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some space."	"((( MultiAllocationProfiler startProfiling )))"	"((( 3 timesRepeat: [ [ ScheduledControllers restore ] fork ] )))"	"((( MultiAllocationProfiler stopProfiling )))"	^self startProfilingWithStatistics: false</body><body package="AT Profiling UI" selector="startProfilingWithStatistics:">startProfilingWithStatistics: trueOrFalse	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some space."	"((( MultiAllocationProfiler startProfilingWithStatistics: true )))"	"((( 3 timesRepeat: [ [ ScheduledControllers restore ] fork ] )))"	"((( MultiAllocationProfiler stopProfiling )))"	^self 		startProfilingWithStatistics: trueOrFalse 		onExitDo: self defaultExitBlock</body><body package="AT Profiling UI" selector="startProfilingWithStatistics:onExitDo:">startProfilingWithStatistics: trueOrFalse onExitDo: exitBlock	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some space."	"((( MultiAllocationProfiler		startProfilingWithStatistics: true 		onExitDo: [:spy |	| fs |							fs := 'ui.report' asFilename writeStream.							[	fs timeStamp; cr.								spy reportOn: fs cutoffPercent: 1							] ensure: [ fs close ] ] )))"	"((( 3 timesRepeat: [ [ ScheduledControllers restore ] fork ] )))"	"((( MultiAllocationProfiler stopProfiling )))"	^self coreClass 		coreStart: ( self new keepStatistics: trueOrFalse ) 		onExitDo: exitBlock</body></methods><methods><class-id>Tools.MultiAllocationProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="openView">openView	"... altered to answer a builder, like other interface opening methods."	"((( MultiAllocationProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self multiText,'	"((( self startProfilingWithStatistics: true )))"	"((( 20 timesRepeat:					[ [	| s r |						s := SortedCollection new: 0.						r := Random new.						256 timesRepeat: [ s add: ( r next * 1000 ) truncated ] ] fork ] )))"	"((( self stopProfiling )))"'].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI" selector="templateText">templateText	^'	"(((	self startProfiling )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self startProfilingReportTo: ((aFilename)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self 			keepStatistics: ((aBoolean));			samplingInterval: ((anIntegerS));			startProfilingOnExitDo: ((aBlock)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"'</body></methods><methods><class-id>Tools.TimeProfiler</class-id> <category>reporting</category><body package="AT Profiling UI" selector="reportTotalsOn:">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	| samples processTime totalTime otherProcessesTime |	totalTime := core totalTime.	processTime := core processTime.	samples := core samples.	otherProcessesTime := core otherProcessesTime.	aStream nextPutAll: ((#TimeProfilerTotals &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; samples, &lt;2p&gt; average ms/sample, &lt;7p&gt; scavenges, &lt;8p&gt; incGCs,&lt;n&gt;&lt;4p&gt;s active, &lt;5p&gt;s other processes,&lt;n&gt;&lt;3p&gt;s real time, &lt;6p&gt;s profiling overhead')			expandMacrosWithArguments:		((Array new: 8)			at: 1 put: samples;			at: 2 put: ( samples = 0 ifTrue: [0] ifFalse: [ ( totalTime // samples / 10 ) rounded / 100.0 ] );			at: 3 put: ( totalTime / 10000 ) rounded / 100.0;			at: 4 put: ( processTime / 10000 ) rounded / 100.0;			at: 5 put: ( otherProcessesTime / 10000 ) rounded / 100.0;			at: 6 put: ( ( totalTime - processTime - otherProcessesTime ) / 10000 ) rounded / 100.0;			at: 7 put: core scavenges;			at: 8 put: core incrementalGCs;			yourself))</body></methods><methods><class-id>Tools.TimeProfiler</class-id> <category>accessing</category><body package="AT Profiling UI" selector="sampleUnitName">sampleUnitName	^(#milliseconds &lt;&lt; #advanced &gt;&gt; 'milliseconds') asString</body></methods><methods><class-id>Tools.TimeProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI" selector="coreClass">coreClass	^TimeProfilerCore</body></methods><methods><class-id>Tools.TimeProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="openView">openView	"... altered to answer a builder, like other interface opening methods."	"((( TimeProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self basicText, ( self demonstrationText: 9000 ) ].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI" selector="templateText">templateText	^'	"(((	self profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] )))"	"(((	self 			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ]			reportTo: ((aFilename)) )))"	"(((	( self 			samplingInterval: ((anIntegerS));			yourself )				profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] 				onExitDo: ((aBlock)) )))"'</body></methods><methods><class-id>Tools.MultiTimeProfiler</class-id> <category>reporting</category><body package="AT Profiling UI" selector="profileSummaryFilter:">profileSummaryFilter: limit	"Answer a dictionary which maps a summary title to a	SequenceableCollection of report fields for that summary."	| summary |	summary := super profileSummaryFilter: limit.	summary at: #'tree grouped by priority' put: ( Array with: ( core priorityTally ) ).	^summary</body><body package="AT Profiling UI" selector="reportKeys">reportKeys	^( super reportKeys )		add: #'tree grouped by priority';		yourself</body><body package="AT Profiling UI" selector="reportTotalsOn:">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	| samples processTime totalTime otherProcessesTime |	totalTime := core totalTime.	processTime := core processTime.	samples := core samples.	otherProcessesTime := core otherProcessesTime.	aStream nextPutAll: ((#MultiTimeProfilerTotals &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; samples, &lt;2p&gt; average ms/sample, &lt;7p&gt; scavenges, &lt;8p&gt; incGCs,&lt;n&gt;&lt;4p&gt;s active, &lt;5p&gt;s semaphore waits,&lt;n&gt;&lt;3p&gt;s real time, &lt;6p&gt;s profiling overhead')			expandMacrosWithArguments:		((Array new: 8)			at: 1 put: samples;			at: 2 put: ( samples = 0 ifTrue: [0] ifFalse: [ ( totalTime // samples / 10 ) rounded / 100.0 ] );			at: 3 put: ( totalTime / 10000 ) rounded / 100.0;			at: 4 put: ( processTime / 10000 ) rounded / 100.0;			at: 5 put: ( otherProcessesTime / 10000 ) rounded / 100.0;			at: 6 put: ( ( totalTime - processTime - otherProcessesTime ) / 10000 ) rounded / 100.0;			at: 7 put: core scavenges;			at: 8 put: core incrementalGCs;			yourself))</body></methods><methods><class-id>Tools.MultiTimeProfiler</class-id> <category>public api</category><body package="AT Profiling UI" selector="profile:">profile: aBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:onExitDo:">profile: aBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:reportTo:">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI" selector="startProfiling">startProfiling	^self startProfilingOnExitDo: self class defaultExitBlock</body><body package="AT Profiling UI" selector="startProfilingOnExitDo:">startProfilingOnExitDo: exitBlock	self reinitializeCore.	^self class coreClass 		coreStart: self 		onExitDo: exitBlock</body><body package="AT Profiling UI" selector="startProfilingReportTo:">startProfilingReportTo: aFilename	^self startProfilingOnExitDo: ( self class defaultFileBlock: aFilename )</body></methods><methods><class-id>Tools.MultiTimeProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI" selector="coreClass">coreClass	^MultiTimeProfilerCore</body></methods><methods><class-id>Tools.MultiTimeProfiler class</class-id> <category>public api</category><body package="AT Profiling UI" selector="profile:">profile: theBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:onExitDo:">profile: theBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI" selector="profile:reportTo:">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI" selector="startProfiling">startProfiling	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some time."	"(((	MultiTimeProfiler startProfiling )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( MultiTimeProfiler stopProfiling )))"	^self startProfilingOnExitDo: self defaultExitBlock</body><body package="AT Profiling UI" selector="startProfilingOnExitDo:">startProfilingOnExitDo: exitBlock	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some time."	"(((	MultiTimeProfiler startProfilingOnExitDo: 			[ :spy |	| fs |					fs := 'factorial.rpt' asFilename writeStream.					[	fs timeStamp; cr.						spy reportOn: fs cutoffPercent: 1					] ensure: [ fs close ]			] )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( MultiTimeProfiler stopProfiling )))"	^self coreClass 		coreStart: self new 		onExitDo: exitBlock</body><body package="AT Profiling UI" selector="startProfilingReportTo:">startProfilingReportTo: aFilename	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some time."	"(((	MultiTimeProfiler startProfilingReportTo: 'factorial.rpt' )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( MultiTimeProfiler stopProfiling )))"	^self startProfilingOnExitDo: ( self defaultFileBlock: aFilename )</body></methods><methods><class-id>Tools.MultiTimeProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI" selector="openView">openView	"... altered to answer a builder, like other interface opening methods."	"((( MultiTimeProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self multiText, '	"((( self startProfiling )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( self stopProfiling )))"'].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI" selector="templateText">templateText	^'	"(((	self startProfiling )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self startProfilingReportTo: ((aFilename)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self 			samplingInterval: ((anIntegerS));			startProfilingOnExitDo: ((aBlock)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"'</body></methods><methods><class-id>UI.MenuItem</class-id> <category>indication (on/off)</category><body package="AT Profiling UI" selector="toggle">toggle	adornment == nil		ifFalse: [adornment indication == true					ifTrue: [adornment indication: false]					ifFalse: [adornment indication: true]]</body></methods><methods><class-id>Tools.ProfileOutlineBrowser class</class-id> <category>resources</category><body package="AT Profiling UI" selector="outlineMenu">outlineMenu	"Tools.MenuEditor new openOnClass: self andSelector: #outlineMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #expand #defaultString: 'expand' #catalogID: #advanced) 				#nameKey: #expand 				#value: #expand ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #expandFully #defaultString: 'expand fully' #catalogID: #advanced) 				#nameKey: #expandFully 				#value: #expandFully ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #contractFully #defaultString: 'contract fully' #catalogID: #advanced) 				#nameKey: #contractFully 				#value: #contractFully ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #senders #defaultString: 'senders' #catalogID: #advanced) 				#nameKey: #browseSenders 				#value: #browseSenders ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #implementors #defaultString: 'implementors' #catalogID: #advanced) 				#nameKey: #browseImplementors 				#value: #browseImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #messages #defaultString: 'messages...' #catalogID: #advanced) 				#nameKey: #browseMessages 				#value: #browseMessages ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #spawn #defaultString: 'spawn' #catalogID: #advanced) 				#nameKey: #spawnCurrent 				#value: #spawnCurrent ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #findNext #defaultString: 'find next' #catalogID: #advanced) 				#nameKey: #findNextMenu 				#value: #findNextMenu ) ) #(3 3 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ProfileOutlineBrowser class</class-id> <category>interface specs</category><body package="AT Profiling UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Profile 				#defaultString: 'Profile' 				#catalogID: #advanced ) 			#min: #(#{Core.Point} 725 450 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 675 525 1400 975 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 5 0 -50 1 30 0 ) 					#name: #spawnTextReport 					#model: #spawnTextReport 					#label: 					#(#{Kernel.UserMessage} 						#key: #spawnText 						#defaultString: 'spawn text' 						#catalogID: #advanced ) 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 140 0 -5 1 -5 1 ) 					#name: #outlineSelectionInList 					#flags: 15 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #outlineSelectionInList 					#menu: #outlineMenu 					#style: #fixed 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 275 110 375 135 ) 					#model: #acceptCutoff 					#label: 					#(#{Kernel.UserMessage} 						#key: #applyCutoff 						#defaultString: 'apply cutoff' 						#catalogID: #advanced ) 					#defaultable: true ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 5 115 215 135 ) 					#name: #cutoff 					#model: #cutoff 					#orientation: #horizontal 					#start: 0 					#stop: 0.1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 215 115 250 135 ) 					#flags: 0 					#model: #cutoff 					#isReadOnly: true 					#type: #number 					#formatString: #($0 $. $0 $% ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 90 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #CutoffPercentage 						#defaultString: 'Cutoff Percentage' 						#catalogID: #advanced ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 5 0 -155 1 90 0 ) 					#name: #totalsReport 					#flags: 4 					#model: #totalsReport 					#isReadOnly: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 40 0 -5 1 135 0 ) 					#name: #viewingModeListSIL 					#model: #viewingModeList 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Tools.ProfileBrowserHelper</class-id> <category>actions</category><body package="AT Profiling UI" selector="browseClass">browseClass	"Spawn a Browser on the selected method's class.."	&lt;menuItem: 'Browse Class'		nameKey: nil		menu: #(#listMenu)		position: 20.1 &gt;	SmalltalkWorkbench browseClass: (self definitionOf: module selection) implementingClass instanceBehavior</body></methods><methods><class-id>Tools.ProfileBrowserHelper class</class-id> <category>resources</category><body package="AT Profiling UI" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#rawLabel: #(#{Kernel.UserMessage} #key: #Spawn #defaultString: 'Spawn' #catalogID: #advanced)				#nameKey: #spawn				#value: #spawnMethod )			#(#MenuItem				#rawLabel: #(#{Kernel.UserMessage} #key: #Senders #defaultString: 'Senders' #catalogID: #advanced)				#nameKey: #allSenders )			#(#MenuItem				#rawLabel: #(#{Kernel.UserMessage} #key: #Implementors #defaultString: 'Implementors' #catalogID: #advanced)				#nameKey: #allImplementors )			#(#MenuItem				#rawLabel: #(#{Kernel.UserMessage} #key: #LocalSenders #defaultString: 'Local Senders' #catalogID: #advanced)				#nameKey: #localSenders )			#(#MenuItem				#rawLabel: #(#{Kernel.UserMessage} #key: #LocalImplementors #defaultString: 'Local Implementors' #catalogID: #advanced)				#nameKey: #localImplementors ) ) #(1 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>interface specs</category><body package="AT Profiling UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProfileSomething 				#defaultString: 'Profile something' 				#catalogID: #advanced ) 			#min: #(#{Core.Point} 650 350 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1350 875 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 43 0 1 0 ) 					#label: #maxSamplingInterval ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 1 0.5 43 0 ) 					#label: #sampleUnitName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 43 ) 					#label: '1' ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 22 0 -8 1 40 0 ) 					#name: #sampleSizeSlider 					#model: #samplingIntervalAdaptor 					#orientation: #horizontal 					#start: 1 					#step: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -58 0.5 42 0 -1 0.5 62 0 ) 					#flags: 0 					#model: #samplingIntervalAdaptor 					#alignment: #right 					#isReadOnly: true 					#type: #number 					#formatString: '##0' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 67 0 -1 1 -1 1 ) 					#name: #textModel 					#model: #textModel 					#tabable: true 					#menu: #textModelMenu 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 7 2 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #SamplingInterval 						#defaultString: 'Sampling Interval:' 						#catalogID: #advanced ) ) ) ) )</body></methods><initialize><class-id>Tools.ProfileBrowserHelper</class-id></initialize><initialize><class-id>Tools.Profiler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MenuItem</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabled label adornment nameKey value position helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>MethodsBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>OutlineBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outlineSelectionInList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Tools</category><attributes><package>AT Tools</package></attributes></class></st-source>