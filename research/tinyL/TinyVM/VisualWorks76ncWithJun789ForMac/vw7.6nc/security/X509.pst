<?xml version="1.0"?><st-source><!-- Name: X509Notice: Copyright © 2008 Cincom Systems, Inc.  All Rights Reserved.Comment: An X509 V3 certificate as defined by the September 23, 1998 draft of the PKIX Working Group of the Internet Engineering Task Force (IETF)X509 is functional barely... The excelent X.509 Style Guide by Peter Gutmann (http://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt) provides the details as to why. If a certificate comes from a program other than the one genrating it, the signatures probably won't match since people interpret the encoding rules differently (see the article). We are making and effort to make this more complete. There are severe problems in different interpretations of the spec and indeed trying to verify a certificate that has been in any way recoded with anything other than the software that generated it, it probably will fail. In some cases with some CA's it fails because the signature in no way resembles what the algorithm puts out. Needless to say while we have minimal functionality working, there remains a lot of work to be done and the CAs are not exactly forth comming with informationWhat this parcel can presently do is:	- read RSA and DSA signed certificates and get the subject public key	- verify RSA-MD5, RSA-SHA1 and DSA signatures most of the time.	- validate certificate chains using a registry of trusted CA certificatesDbIdentifier: bear73DbTrace: 90027DevelopmentPrerequisites: #(#(#any 'ASN1' '') #(#package 'SecurityBase' '') #(#package 'DSA' '') #(#package 'RSA' '') #(#package 'MD5' '') #(#package 'SHA' ''))PackageName: X509Parcel: #('X509')PrerequisiteParcels: #(#('SecurityBase' '') #('ASN1' '') #('DSA' '') #('RSA' '') #('MD5' '') #('SHA' ''))PrintStringCache: (751 3,mkobetic)Version: 7.6Pre-Load Block: 	[:package |	''Flush the ASN1 module if it already exists''	#{Security.X509.ASN1} ifDefinedDo: [ :module |		Security.X509.X509Object resetModule ] ]Date: 12:31:54 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 12:31:54 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>X509</name><environment>Security</environment><private>false</private><imports>			private Smalltalk.*			private ASN1.*			private Security.*			</imports><category>X509</category><attributes><package>X509</package></attributes></name-space><class><name>X509Exception</name><environment>Security.X509</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509Exception</class-id><body>Abstract superclass of all X509 exceptions.</body></comment><class><name>X509Error</name><environment>Security.X509</environment><super>Security.X509.X509Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509Error</class-id><body>Abstract superclass of all X509 errors. Note that X509 notifications are not considered errors.</body></comment><class><name>X509Warning</name><environment>Security.X509</environment><super>Security.X509.X509Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509Warning</class-id><body>X509 warnings all indicate serious security issues, but they still allow to proceed when explicitly resumed. This capability is often expected by the user in situations with significantly relaxed security requirements.</body></comment><class><name>BadCertificate</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.BadCertificate</class-id><body>Indicates that a certificate has structural errors.</body></comment><class><name>RootNotTrusted</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.RootNotTrusted</class-id><body>Indicates that the root certificate of a chain doesn't match any of the trusted certificates in a registry.</body></comment><class><name>X509Object</name><environment>Security.X509</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509Object</class-id><body>Common superclass of all entities identified by the X509 standard.</body></comment><class><name>Validity</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>notBefore notAfter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.Validity</class-id><body>RFC 3280 (section 4.1.2.5  Validity): The certificate validity period is the time interval during which the CA warrants that it will maintain information about the status of the certificate.  The field is represented as a SEQUENCE of two dates: the date on which the certificate validity period begins (notBefore) and the date on which the certificate validity period ends (notAfter).  Both notBefore and notAfter may be encoded as UTCTime or GeneralizedTime.CAs conforming to this profile MUST always encode certificate validity dates through the year 2049 as UTCTime; certificate validity dates in 2050 or later MUST be encoded as GeneralizedTime.The validity period for a certificate is the period of time from notBefore through notAfter, inclusive.4.1.2.5.1  UTCTimeThe universal time type, UTCTime, is a standard ASN.1 type intended for representation of dates and time.  UTCTime specifies the year through the two low order digits and time is specified to the precision of one minute or one second.  UTCTime includes either Z (for Zulu, or Greenwich Mean Time) or a time differential.For the purposes of this profile, UTCTime values MUST be expressed Greenwich Mean Time (Zulu) and MUST include seconds (i.e., times are YYMMDDHHMMSSZ), even where the number of seconds is zero.  Conforming systems MUST interpret the year field (YY) as follows:      Where YY is greater than or equal to 50, the year SHALL be interpreted as 19YY; and      Where YY is less than 50, the year SHALL be interpreted as 20YY.4.1.2.5.2  GeneralizedTimeThe generalized time type, GeneralizedTime, is a standard ASN.1 type for variable precision representation of time.  Optionally, the GeneralizedTime field can include a representation of the time differential between local and Greenwich Mean Time.For the purposes of this profile, GeneralizedTime values MUST be expressed Greenwich Mean Time (Zulu) and MUST include seconds (i.e., times are YYYYMMDDHHMMSSZ), even where the number of seconds is zero. GeneralizedTime values MUST NOT include fractional seconds.Instance Variables:	notBefore	&lt;Asn1Choice&gt; certificate is valid from; timestamp adjusted to reference timezone (TimeZone class&gt;&gt;reference)	notAfter	&lt;Asn1Choice&gt; certfificate is valid until; timestamp adjusted to reference timezone (TimeZone class&gt;&gt;reference)</body></comment><class><name>BrokenChain</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.BrokenChain</class-id><body>Indicates that a chain contains a certificate whose issuer doesn't match the succeeding certificate in the chain.</body></comment><class><name>Extension</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oid critical value </inst-vars><class-inst-vars>oid </class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.Extension</class-id><body>RFC 3280 (section 4.2  Certificate Extensions): The extensions defined for X.509 v3 certificates provide methods for associating additional attributes with users or public keys and for managing a certification hierarchy.  The X.509 v3 certificate format also allows communities to define private extensions to carry information unique to those communities.  Each extension in a certificate is designated as either critical or non-critical.  A certificate using system MUST reject the certificate if it encounters a critical extension it does not recognize; however, a non-critical extension MAY be ignored if it is not recognized.  The following sections present recommended extensions used within Internet certificates and standard locations for information.  Communities may elect to use additional extensions; however, caution ought to be exercised in adopting any critical extensions in certificates which might prevent use in a general context.Each extension includes an OID and an ASN.1 structure.  When an extension appears in a certificate, the OID appears as the field extnID and the corresponding ASN.1 encoded structure is the value of the octet string extnValue.  A certificate MUST NOT include more than one instance of a particular extension.  For example, a certificate may contain only one authority key identifier extension (section 4.2.1.1).  An extension includes the boolean critical, with a default value of FALSE.  The text for each extension specifies the acceptable values for the critical field.Conforming CAs MUST support key identifiers (sections 4.2.1.1 and 4.2.1.2), basic constraints (section 4.2.1.10), key usage (section 4.2.1.3), and certificate policies (section 4.2.1.5) extensions.  If the CA issues certificates with an empty sequence for the subject field, the CA MUST support the subject alternative name extension (section 4.2.1.7).  Support for the remaining extensions is OPTIONAL. Conforming CAs MAY support extensions that are not identified within this specification; certificate issuers are cautioned that marking such extensions as critical may inhibit interoperability.At a minimum, applications conforming to this profile MUST recognize the following extensions: key usage (section 4.2.1.3), certificate policies (section 4.2.1.5), the subject alternative name (section 4.2.1.7), basic constraints (section 4.2.1.10), name constraints (section 4.2.1.11), policy constraints (section 4.2.1.12), extended key usage (section 4.2.1.13), and inhibit any-policy (section 4.2.1.15).In addition, applications conforming to this profile SHOULD recognize the authority and subject key identifier (sections 4.2.1.1 and 4.2.1.2), and policy mapping (section 4.2.1.6) extensions.	Extension  ::=  SEQUENCE  {		extnID      OBJECT IDENTIFIER,		critical    BOOLEAN DEFAULT FALSE,		extnValue   OCTET STRING  }Instance Variables:	oid	&lt;Asn1OID&gt; OID indicating the specific type of extension	critical	&lt;Boolean&gt; indicates extensions that must be processed successfully to validate the containing certificates	value	&lt;ByteArray&gt; DER encoded extension specific contentClass Instance Variables:	oid	&lt;Asn1OID&gt; caches the OID specific to the extension class</body></comment><class><name>SubjectKeyIdentifier</name><environment>Security.X509</environment><super>Security.X509.Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.SubjectKeyIdentifier</class-id><body>RFC 3280 (section 4.2.1.2  Subject Key Identifier): The subject key identifier extension provides a means of identifying certificates that contain a particular public key.To facilitate certification path construction, this extension MUST appear in all conforming CA certificates, that is, all certificates including the basic constraints extension (section 4.2.1.10) where the value of cA is TRUE.  The value of the subject key identifier MUST be the value placed in the key identifier field of the Authority Key Identifier extension (section 4.2.1.1) of certificates issued by the subject of this certificate.For CA certificates, subject key identifiers SHOULD be derived from the public key or a method that generates unique values.  Two common methods for generating key identifiers from the public key are:      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bits).      (2) The keyIdentifier is composed of a four bit type field with the value 0100 followed by the least significant 60 bits of the SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bit string bits).One common method for generating unique values is a monotonically increasing sequence of integers.For end entity certificates, the subject key identifier extension provides a means for identifying certificates containing the particular public key used in an application.  Where an end entity has obtained multiple certificates, especially from multiple CAs, the subject key identifier provides a means to quickly identify the set of certificates containing a particular public key.  To assist applications in identifying the appropriate end entity certificate, this extension SHOULD be included in all end entity certificates.For end entity certificates, subject key identifiers SHOULD be derived from the public key.  Two common methods for generating key identifiers from the public key are identified above.Where a key identifier has not been previously established, this specification RECOMMENDS use of one of these methods for generating keyIdentifiers.  Where a key identifier has been previously established, the CA SHOULD use the previously established identifier.This extension MUST NOT be marked critical.	id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { id-ce 14 }	SubjectKeyIdentifier ::= KeyIdentifierInstance Variables:	identifier	&lt;ByteArray&gt;</body></comment><class><name>Name</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relativeDistinguishedName encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.Name</class-id><body>Names are used to identify subject and issuer of a certificate. They are also used to construct valid certificate chains by matching the issuer name of a certificate to the subject name in a CA certificate (see below).RFC 3280 (section 4.1.2.4  Issuer): Non-empty distinguished name (DN) defined as X.501 type Name. Name is defined by the following ASN.1 structures:	Name ::= CHOICE { RDNSequence }	RDNSequence ::= SEQUENCE OF RelativeDistinguishedName	RelativeDistinguishedName ::= SET OF AttributeTypeAndValueCertificate users MUST be prepared to process the issuer distinguished name and subject distinguished name (section 4.1.2.6) fields to perform name chaining for certification path validation (section 6).  Name chaining is performed by matching the issuer distinguished name in one certificate with the subject name in a CA certificate.This specification requires only a subset of the name comparison functionality specified in the X.500 series of specifications. Conforming implementations are REQUIRED to implement the following name comparison rules:	(a)  attribute values encoded in different types (e.g., PrintableString and BMPString) MAY be assumed to represent different strings;	(b) attribute values in types other than PrintableString are case sensitive (this permits matching of attribute values as binary objects);	(c)  attribute values in PrintableString are not case sensitive (e.g., "Marianne Swanson" is the same as "MARIANNE SWANSON"); and	(d)  attribute values in PrintableString are compared after removing leading and trailing white space and converting internal substrings of one or more consecutive white space characters to a single space.These name comparison rules permit a certificate user to validate certificates issued using languages or encodings unfamiliar to the certificate user.In addition, implementations of this specification MAY use these comparison rules to process unfamiliar attribute types for name chaining.  This allows implementations to process certificates with unfamiliar attributes in the issuer name.Note that the comparison rules defined in the X.500 series of specifications indicate that the character sets used to encode data in distinguished names are irrelevant.  The characters themselves are compared without regard to encoding.  Implementations of this profile are permitted to use the comparison algorithm defined in the X.500 series.  Such an implementation will recognize a superset of name matches recognized by the algorithm specified above.Instance Variables:	relativeDistinguishedName	&lt;OrderedCollection of: X509AttributeValueAssertion&gt; name elements	encoding	&lt;Asn1Encoding&gt; DER encoding of myself</body></comment><class><name>X509Registry</name><environment>Security.X509</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>trustedCertificates revokedCertificates strict </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509Registry</class-id><body>A registry maintains a set of trusted CA (certificate authority) certificates. It is used to validate certificate chains. Any chain with the root certificate from the trusted collection can be validated.There is a default registry instance (X509Registry class&gt;&gt;default) which gets initialized from a trustedCertifcates.pem file in the image directory (or remains empty if the file isn't present). Applications are free to use their own registries instead of the default one.Instance Variables:	trustedCertificates	&lt;Set of: X509Certificate&gt; collection of trusted root certificates	revokedCertificates	&lt;Set of: X509Certificate&gt; collection of certificates that were revoked and should be rejected	strict	&lt;Boolean&gt; adhere strictly to the latest version of the specification (RFC 3280 at the moment)Class Instance Variables:	default	&lt;X509Registry&gt; default instance of the registryShared Class Variables:	DefaultCertificateFile	&lt;String&gt; the default trusted Certificate pem file	ShouldBeStrict	&lt;Boolean&gt; default 'strict' value for X509Registries</body></comment><class><name>DSSParameters</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>p q g </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.DSSParameters</class-id><body>The DSA algorithm may include optional domain parameters. These parameters are commonly referred to as p, q, and g.RFC 3279 (section 2.3.2  DSA Signature Keys):The Digital Signature Algorithm (DSA) is defined in the Digital Signature Standard (DSS) [FIPS 186].  The DSA OID supported by this profile is:	id-dsa OBJECT IDENTIFIER ::= {iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 1 }The id-dsa algorithm syntax includes optional domain parameters. These parameters are commonly referred to as p, q, and g.  When omitted, the parameters component MUST be omitted entirely.  That is, the AlgorithmIdentifier MUST be a SEQUENCE of one component: the OBJECT IDENTIFIER id-dsa.If the DSA domain parameters are present in the subjectPublicKeyInfo AlgorithmIdentifier, the parameters are included using the following ASN.1 structure:	Dss-Parms  ::=  SEQUENCE  {		p             INTEGER,		q             INTEGER,		g             INTEGER  }The AlgorithmIdentifier within subjectPublicKeyInfo is the only place within a certificate where the parameters may be used.  If the DSA algorithm parameters are omitted from the subjectPublicKeyInfo AlgorithmIdentifier and the CA signed the subject certificate using DSA, then the certificate issuer's DSA parameters apply to the subject's DSA key.  If the DSA domain parameters are omitted from the SubjectPublicKeyInfo AlgorithmIdentifier and the CA signed the subject certificate using a signature algorithm other than DSA, then the subject's DSA domain parameters are distributed by other means. If the subjectPublicKeyInfo AlgorithmIdentifier field omits the parameters component, the CA signed the subject with a signature algorithm other than DSA, and the subject's DSA parameters are not available through other means, then clients MUST reject the certificate.Instance Variables:	p	&lt;Integer&gt;	q	&lt;Integer&gt;	g	&lt;Integer&gt;</body></comment><class><name>KeyUsage</name><environment>Security.X509</environment><super>Security.X509.Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.KeyUsage</class-id><body>RFC 3280 (section 4.2.1.3  Key Usage): The key usage extension defines the purpose (e.g., encipherment, signature, certificate signing) of the key contained in the certificate.  The usage restriction might be employed when a key that could be used for more than one operation is to be restricted.  For example, when an RSA key should be used only to verify signatures on objects other than public key certificates and CRLs, the digitalSignature and/or nonRepudiation bits would be asserted. Likewise, when an RSA key should be used only for key management, the keyEncipherment bit would be asserted.This extension MUST appear in certificates that contain public keys that are used to validate digital signatures on other public key certificates or CRLs.  When this extension appears, it SHOULD be marked critical.	id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }	KeyUsage ::= BIT STRING {		digitalSignature	(0),		nonRepudiation	(1),		keyEncipherment	(2),		dataEncipherment	(3),		keyAgreement		(4),		keyCertSign		(5),		cRLSign			(6),		encipherOnly		(7),		decipherOnly		(8) }Bits in the KeyUsage type are used as follows:The digitalSignature bit is asserted when the subject public key is used with a digital signature mechanism to support security services other than certificate signing (bit 5), or CRL signing (bit 6).  Digital signature mechanisms are often used for entity authentication and data origin authentication with integrity.The nonRepudiation bit is asserted when the subject public key is used to verify digital signatures used to provide a non-repudiation service which protects against the signing entity falsely denying some action, excluding certificate or CRL signing. In the case of later conflict, a reliable third party may determine the authenticity of the signed data. Further distinctions between the digitalSignature and nonRepudiation bits may be provided in specific certificate policies.The keyEncipherment bit is asserted when the subject public key is used for key transport.  For example, when an RSA key is to be used for key management, then this bit is set.The dataEncipherment bit is asserted when the subject public key is used for enciphering user data, other than cryptographic keys.The keyAgreement bit is asserted when the subject public key is used for key agreement.  For example, when a Diffie-Hellman key is to be used for key management, then this bit is set.The keyCertSign bit is asserted when the subject public key is used for verifying a signature on public key certificates.  If the keyCertSign bit is asserted, then the cA bit in the basic constraints extension (section 4.2.1.10) MUST also be asserted.The cRLSign bit is asserted when the subject public key is used for verifying a signature on certificate revocation list (e.g., a CRL, delta CRL, or an ARL).  This bit MUST be asserted in certificates that are used to verify signatures on CRLs.The meaning of the encipherOnly bit is undefined in the absence of the keyAgreement bit.  When the encipherOnly bit is asserted and the keyAgreement bit is also set, the subject public key may be used only for enciphering data while performing key agreement.The meaning of the decipherOnly bit is undefined in the absence of the keyAgreement bit.  When the decipherOnly bit is asserted and the keyAgreement bit is also set, the subject public key may be used only for deciphering data while performing key agreement.This profile does not restrict the combinations of bits that may be set in an instantiation of the keyUsage extension.  However, appropriate values for keyUsage extensions for particular algorithms are specified in [RFC 3279].Instance Variables:	bits	&lt;BitString&gt; the key usage bits represented as a bit string</body></comment><class><name>TBSCertificate</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding version serialNumber signature issuer validity subject subjectPublicKeyInfo extensions issuerUniqueID subjectUniqueID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.TBSCertificate</class-id><body>This class represents the "to be signed" (TBS) part of the certificate, which represents most of the information that is contained in the certificate.RFC 3280 (section 4.1.2  TBSCertificate): The sequence TBSCertificate contains information associated with the subject of the certificate and the CA who issued it.  Every TBSCertificate contains the names of the subject and issuer, a public key associated with the subject, a validity period, a version number, and a serial number; some MAY contain optional unique identifier fields.  The remainder of this section describes the syntax and semantics of these fields.  A TBSCertificate usually includes extensions. Extensions for the Internet PKI are described in Section 4.2.	TBSCertificate  ::=  SEQUENCE  {		version         [0]  EXPLICIT Version DEFAULT v1,		serialNumber         CertificateSerialNumber,		signature            AlgorithmIdentifier,		issuer               Name,		validity             Validity,		subject              Name,		subjectPublicKeyInfo SubjectPublicKeyInfo,		issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,			-- If present, version MUST be v2 or v3		subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,			-- If present, version MUST be v2 or v3		extensions      [3]  EXPLICIT Extensions OPTIONAL			-- If present, version MUST be v3	}4.1.2.1  VersionThis field describes the version of the encoded certificate.  When extensions are used, as expected in this profile, version MUST be 3 (value is 2).  If no extensions are present, but a UniqueIdentifier is present, the version SHOULD be 2 (value is 1); however version MAY be 3.  If only basic fields are present, the version SHOULD be 1 (the value is omitted from the certificate as the default value); however the version MAY be 2 or 3.Implementations SHOULD be prepared to accept any version certificate. At a minimum, conforming implementations MUST recognize version 3 certificates.Generation of version 2 certificates is not expected by implementations based on this profile.4.1.2.2  Serial numberThe serial number MUST be a positive integer assigned by the CA to each certificate.  It MUST be unique for each certificate issued by a given CA (i.e., the issuer name and serial number identify a unique certificate).  CAs MUST force the serialNumber to be a non-negative integer.Given the uniqueness requirements above, serial numbers can be expected to contain long integers.  Certificate users MUST be able to handle serialNumber values up to 20 octets.  Conformant CAs MUST NOT use serialNumber values longer than 20 octets.Note: Non-conforming CAs may issue certificates with serial numbers that are negative, or zero.  Certificate users SHOULD be prepared to gracefully handle such certificates.4.1.2.3  SignatureThis field contains the algorithm identifier for the algorithm used by the CA to sign the certificate.This field MUST contain the same algorithm identifier as the signatureAlgorithm field in the sequence Certificate (section 4.1.1.2).  The contents of the optional parameters field will vary according to the algorithm identified.  [RFC 3279] lists the supported signature algorithms, but other signature algorithms MAY also be supported.4.1.2.4  IssuerThe issuer field identifies the entity who has signed and issued the certificate.  The issuer field MUST contain a non-empty distinguished name (DN). The issuer field is defined as the X.501 type Name. 4.1.2.5  ValidityThe certificate validity period is the time interval during which the CA warrants that it will maintain information about the status of the certificate.  The field is represented as a SEQUENCE of two dates: the date on which the certificate validity period begins (notBefore) and the date on which the certificate validity period ends (notAfter).  Both notBefore and notAfter may be encoded as UTCTime or GeneralizedTime.4.1.2.6  SubjectThe subject field identifies the entity associated with the public key stored in the subject public key field.  The subject name MAY be carried in the subject field and/or the subjectAltName extension.  If the subject is a CA (e.g., the basic constraints extension, as discussed in 4.2.1.10, is present and the value of cA is TRUE), then the subject field MUST be populated with a non-empty distinguished name matching the contents of the issuer field (section 4.1.2.4) in all certificates issued by the subject CA.  If the subject is a CRL issuer (e.g., the key usage extension, as discussed in 4.2.1.3, is present and the value of cRLSign is TRUE) then the subject field MUST be populated with a non-empty distinguished name matching the contents of the issuer field (section 4.1.2.4) in all CRLs issued by the subject CRL issuer.  If subject naming information is present only in the subjectAltName extension (e.g., a key bound only to an email address or URI), then the subject name MUST be an empty sequence and the subjectAltName extension MUST be critical.Where it is non-empty, the subject field MUST contain an X.500 distinguished name (DN).  The DN MUST be unique for each subject entity certified by the one CA as defined by the issuer name field. A CA MAY issue more than one certificate with the same DN to the same subject entity.The subject name field is defined as the X.501 type Name. Implementation requirements for this field are those defined for the issuer field (section 4.1.2.4).  When encoding attribute values of type DirectoryString, the encoding rules for the issuer field MUST be implemented.  Implementations of this specification MUST be prepared to receive subject names containing the attribute types required for the issuer field.  Implementations of this specification SHOULD be prepared to receive subject names containing the recommended attribute types for the issuer field.  The syntax and associated object identifiers (OIDs) for these attribute types are provided in the ASN.1 modules in Appendix A.  Implementations of this specification MAY use these comparison rules to process unfamiliar attribute types (i.e., for name chaining).  This allows implementations to process certificates with unfamiliar attributes in the subject name.In addition, legacy implementations exist where an RFC 822 name is embedded in the subject distinguished name as an EmailAddress attribute.  The attribute value for EmailAddress is of type IA5String to permit inclusion of the character '@', which is not part of the PrintableString character set.  EmailAddress attribute values are not case sensitive (e.g., "fanfeedback@redsox.com" is the same as "FANFEEDBACK@REDSOX.COM").Conforming implementations generating new certificates with electronic mail addresses MUST use the rfc822Name in the subject alternative name field (section 4.2.1.7) to describe such identities. Simultaneous inclusion of the EmailAddress attribute in the subject distinguished name to support legacy implementations is deprecated but permitted.4.1.2.7  Subject Public Key InfoThis field is used to carry the public key and identify the algorithm with which the key is used (e.g., RSA, DSA, or Diffie-Hellman).4.1.2.8  Unique IdentifiersThese fields MUST only appear if the version is 2 or 3 (section 4.1.2.1).  These fields MUST NOT appear if the version is 1.  The subject and issuer unique identifiers are present in the certificate to handle the possibility of reuse of subject and/or issuer names over time.  This profile RECOMMENDS that names not be reused for different entities and that Internet certificates not make use of unique identifiers.  CAs conforming to this profile SHOULD NOT generate certificates with unique identifiers.  Applications conforming to this profile SHOULD be capable of parsing unique identifiers.4.1.2.9  ExtensionsThis field MUST only appear if the version is 3 (section 4.1.2.1). If present, this field is a SEQUENCE of one or more certificate extensions.  The format and content of certificate extensions in the Internet PKI is defined in section 4.2.Instance Variables:	encoding	&lt;Asn1Encoding&gt; DER encoding of myself	version	&lt;Integer&gt; certificate format version	serialNumber	&lt;Integer&gt; a unique number assigned to the certificate by the issuer	signature	&lt;X509AlgorithmIdentifier&gt; identifies the algorithm used to sign the certificate	issuer	&lt;X509Name&gt; the name of the certificate issuer, authority issuing the certificate	validity	&lt;X509Validity&gt; indicates the validity period of the certificate	subject	&lt;X509Name&gt; the name of the certificate subject, for whom the certificate was issued	subjectPublicKeyInfo	&lt;X509SubjectPublicKeyInfo&gt; subject's public key	extensions	&lt;OrderedCollection of: X509Extension&gt; certificate extensions, only for version 3 certificates	issuerUniqueID	&lt;Asn1BitString&gt; optional, only version 2 and 3 certificates	subjectUniqueID	&lt;Asn1BitString&gt; optional, only version 2 and 3 certificates</body></comment><class><name>BadCACertificate</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.BadCACertificate</class-id><body>Abstract superclass for all invalid CA certificate errors.</body></comment><class><name>BadCAKeyUsage</name><environment>Security.X509</environment><super>Security.X509.BadCACertificate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.BadCAKeyUsage</class-id><body>Indicates that a supposed CA certificate is missing KeyUsage extension or that the indicated key usage is not appropriate for a CA certificate.</body></comment><class><name>IssuerMismatch</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.IssuerMismatch</class-id><body>Indicates that a supposed issuer certificate doesn't match the issuer field of the subject certificate.</body></comment><class><name>CertificateFileReader</name><environment>Security.X509</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.CertificateFileReader</class-id><body>This class parses a PEM file filled with certificates and private key pairs and return a collection of certificate -&gt; key associations.Instance Variables:	stream	&lt;Object&gt; undocumented</body></comment><class><name>Revoked</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.Revoked</class-id><body>Indicates that a certificate was revoked</body></comment><class><name>X509PrivateKey</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509PrivateKey</class-id><body>Common superclass of all private keys in X509. Provides instance creation utilities for reading private keys from external storage formats.</body></comment><class><name>BadCAConstraints</name><environment>Security.X509</environment><super>Security.X509.BadCACertificate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.BadCAConstraints</class-id><body>Indicates that a supposed CA certificate is missing BasicConstraints extension.</body></comment><class><name>X509PublicKey</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>algorithmOID </class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509PublicKey</class-id><body>Common superclass of all public keys in X509.RFC 3279 (section 2.3  Subject Public Key Algorithms):Certificates conforming to [RFC 3280] may convey a public key for any public key algorithm.  The certificate indicates the algorithm through an algorithm identifier.  This algorithm identifier is an OID and optionally associated parameters.This section identifies preferred OIDs and parameters for the RSA, DSA, Diffie-Hellman, KEA, ECDSA, and ECDH algorithms.  Conforming CAs MUST use the identified OIDs when issuing certificates containing public keys for these algorithms.  Conforming applications supporting any of these algorithms MUST, at a minimum, recognize the OID identified in this section.Class Instance Variables:	algorithmOID	&lt;Asn1OID&gt; caches the algorithm OID as prescribed by RFC#3279</body></comment><class><name>X509DSAPublicKey</name><environment>Security.X509</environment><super>Security.X509.X509PublicKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publicKey dssParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509DSAPublicKey</class-id><body>Public key for the DSS signature standard.RFC 3279 (section 2.3.2  DSA Signature Keys):The Digital Signature Algorithm (DSA) is defined in the Digital Signature Standard (DSS) [FIPS 186].  The DSA OID supported by this profile is:	id-dsa OBJECT IDENTIFIER ::= {iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 1 }The id-dsa algorithm syntax includes optional domain parameters. These parameters are commonly referred to as p, q, and g.  When omitted, the parameters component MUST be omitted entirely.  That is, the AlgorithmIdentifier MUST be a SEQUENCE of one component: the OBJECT IDENTIFIER id-dsa.If the DSA domain parameters are present in the subjectPublicKeyInfo AlgorithmIdentifier, the parameters are included using the following ASN.1 structure:	Dss-Parms  ::=  SEQUENCE  {		p             INTEGER,		q             INTEGER,		g             INTEGER  }The AlgorithmIdentifier within subjectPublicKeyInfo is the only place within a certificate where the parameters may be used.  If the DSA algorithm parameters are omitted from the subjectPublicKeyInfo AlgorithmIdentifier and the CA signed the subject certificate using DSA, then the certificate issuer's DSA parameters apply to the subject's DSA key.  If the DSA domain parameters are omitted from the SubjectPublicKeyInfo AlgorithmIdentifier and the CA signed the subject certificate using a signature algorithm other than DSA, then the subject's DSA domain parameters are distributed by other means. If the subjectPublicKeyInfo AlgorithmIdentifier field omits the parameters component, the CA signed the subject with a signature algorithm other than DSA, and the subject's DSA parameters are not available through other means, then clients MUST reject the certificate.The DSA public key MUST be ASN.1 DER encoded as an INTEGER; this encoding shall be used as the contents (i.e., the value) of the subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo data element.	DSAPublicKey ::= INTEGER -- public key, YIf the keyUsage extension is present in an end entity certificate which conveys a DSA public key, any combination of the following values MAY be present:      digitalSignature;      nonRepudiation;If the keyUsage extension is present in a CA or CRL issuer certificate which conveys a DSA public key, any combination of the following values MAY be present:      digitalSignature;      nonRepudiation;      keyCertSign; and      cRLSign.Instance Variables:	publicKey	&lt;Object&gt; undocumented	dssParameters	&lt;Object&gt; undocumentedClass Instance Variables:</body></comment><class><name>ValidityError</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.ValidityError</class-id><body>Abstract superclass of all validity errors.</body></comment><class><name>NotValidYet</name><environment>Security.X509</environment><super>Security.X509.ValidityError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.NotValidYet</class-id><body>Indicates that a certificate is not valid yet.</body></comment><class><name>DSSSignatureValue</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>r s </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.DSSSignatureValue</class-id><body>RFC 3279 (section 2.2.2  DSA Signature Algorithm): When signing, the DSA algorithm generates two values.  These values are commonly referred to as r and s.To easily transfer these two values as one signature, they SHALL be ASN.1 encoded using the following ASN.1 structure:	Dss-Sig-Value  ::=  SEQUENCE  {		r       INTEGER,		s       INTEGER  }Instance Variables:	r	&lt;Integer&gt;	s	&lt;Integer&gt;</body></comment><class><name>NoExtensionSupport</name><environment>Security.X509</environment><super>Security.X509.X509Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.NoExtensionSupport</class-id><body>This error is signaled when there is an attempt to create extensions in a certificate with version that does not support extensions.</body></comment><class><name>X509Notification</name><environment>Security.X509</environment><super>Security.X509.X509Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509Notification</class-id><body>Abstract superclass of all X509 notifications, usually things that don't satisfy the stated requirements of the X.509 specification but aren't as serious as X509Warnings. </body></comment><class><name>ExtensionShouldBeCritical</name><environment>Security.X509</environment><super>Security.X509.X509Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extension </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.ExtensionShouldBeCritical</class-id><body>Indicates that a certificate has an extension which should have been marked critical, but isn't.Instance Variables:	extension	&lt;Object&gt; undocumented</body></comment><class><name>InvalidSignature</name><environment>Security.X509</environment><super>Security.X509.BadCertificate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.InvalidSignature</class-id><body>Indicates that the signature of a certificate is not valid.</body></comment><class><name>AttributeValueAssertion</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.AttributeValueAssertion</class-id><body>These are components of X509Name, each assertion qualifies a string with a "type". Types are denoted using OIDs.RFC 3280 (section 4.1.2.4 Issuer): As noted above, distinguished names are composed of attributes.  This specification does not restrict the set of attribute types that may appear in names.  However, conforming implementations MUST be prepared to receive certificates with issuer names containing the set of attribute types defined below.  This specification RECOMMENDS support for additional attribute types.Standard sets of attributes have been defined in the X.500 series of specifications [X.520].  Implementations of this specification MUST be prepared to receive the following standard attribute types in issuer and subject (section 4.1.2.6) names:      * country,      * organization,      * organizational-unit,      * distinguished name qualifier,      * state or province name,      * common name (e.g., "Susan Housley"), and      * serial number.In addition, implementations of this specification SHOULD be prepared to receive the following standard attribute types in issuer and subject names:      * locality,      * title,      * surname,      * given name,      * initials,      * pseudonym, and      * generation qualifier (e.g., "Jr.", "3rd", or "IV").The syntax and associated object identifiers (OIDs) for these attribute types are provided in the ASN.1 modules in Appendix A.In addition, implementations of this specification MUST be prepared to receive the domainComponent attribute, as defined in [RFC 2247]. The Domain Name System (DNS) provides a hierarchical resource labeling system.  This attribute provides a convenient mechanism for organizations that wish to use DNs that parallel their DNS names. This is not a replacement for the dNSName component of the alternative name field.  Implementations are not required to convert such names into DNS names.  The syntax and associated OID for this attribute type is provided in the ASN.1 modules in Appendix A.	AttributeTypeAndValue ::= SEQUENCE {		type     AttributeType,		value    AttributeValue }	AttributeType ::= OBJECT IDENTIFIER	AttributeValue ::= ANY DEFINED BY AttributeType	DirectoryString ::= CHOICE {		teletexString           TeletexString (SIZE (1..MAX)),		printableString         PrintableString (SIZE (1..MAX)),		universalString         UniversalString (SIZE (1..MAX)),		utf8String              UTF8String (SIZE (1..MAX)),		bmpString               BMPString (SIZE (1..MAX)) }The type of the component AttributeValue is determined by the AttributeType; in general it will be a DirectoryString. The DirectoryString type is defined as a choice of PrintableString, TeletexString, BMPString, UTF8String, and UniversalString.  The UTF8String encoding [RFC 2279] is the preferred encoding, and all certificates issued after December 31, 2003 MUST use the UTF8String encoding of DirectoryString (except as noted below).  Until that date, conforming CAs MUST choose from the following options when creating a distinguished name, including their own:      (a)  if the character set is sufficient, the string MAY be represented as a PrintableString;      (b)  failing (a), if the BMPString character set is sufficient the string MAY be represented as a BMPString; and      (c)  failing (a) and (b), the string MUST be represented as a UTF8String.  If (a) or (b) is satisfied, the CA MAY still choose to represent the string as a UTF8String.Exceptions to the December 31, 2003 UTF8 encoding requirements are as follows:      (a)  CAs MAY issue "name rollover" certificates to support an orderly migration to UTF8String encoding.  Such certificates would include the CA's UTF8String encoded name as issuer and and the old name encoding as subject, or vice-versa.      (b)  As stated in section 4.1.2.6, the subject field MUST be populated with a non-empty distinguished name matching the contents of the issuer field in all certificates issued by the subject CA regardless of encoding.The TeletexString and UniversalString are included for backward compatibility, and SHOULD NOT be used for certificates for new subjects.  However, these types MAY be used in certificates where the name was previously established.  Certificate users SHOULD be prepared to receive certificates with these types.In addition, many legacy implementations support names encoded in the ISO 8859-1 character set (Latin1String) [ISO 8859-1] but tag them as TeletexString.  TeletexString encodes a larger character set than ISO 8859-1, but it encodes some characters differently.  Implementations SHOULD be prepared to handle both encodings.Instance Variables:	type	&lt;Asn1OID&gt; denotes the type of name component, (OU, O, CN, L, S, ...)	value	&lt;String&gt; value of the name component</body></comment><class><name>X509RSAPublicKey</name><environment>Security.X509</environment><super>Security.X509.X509PublicKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>e n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509RSAPublicKey</class-id><body>Public key for RSA signing/encryption algorithm.RFC 3279 (section 2.3.1  RSA Keys):The OID rsaEncryption identifies RSA public keys.	pkcs-1 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }	rsaEncryption OBJECT IDENTIFIER ::=  { pkcs-1 1}The rsaEncryption OID is intended to be used in the algorithm field of a value of type AlgorithmIdentifier.  The parameters field MUST have ASN.1 type NULL for this algorithm identifier.The RSA public key MUST be encoded using the ASN.1 type RSAPublicKey:      RSAPublicKey ::= SEQUENCE {         modulus            INTEGER,    -- n         publicExponent     INTEGER  }  -- ewhere modulus is the modulus n, and publicExponent is the public exponent e.  The DER encoded RSAPublicKey is the value of the BIT STRING subjectPublicKey.This OID is used in public key certificates for both RSA signature keys and RSA encryption keys.  The intended application for the key MAY be indicated in the key usage field (see [RFC 3280]).  The use of a single key for both signature and encryption purposes is not recommended, but is not forbidden.If the keyUsage extension is present in an end entity certificate which conveys an RSA public key, any combination of the following values MAY be present:      digitalSignature;      nonRepudiation;      keyEncipherment; and      dataEncipherment.If the keyUsage extension is present in a CA or CRL issuer certificate which conveys an RSA public key, any combination of the following values MAY be present:      digitalSignature;      nonRepudiation;      keyEncipherment;      dataEncipherment;      keyCertSign; and      cRLSign.However, this specification RECOMMENDS that if keyCertSign or cRLSign is present, both keyEncipherment and dataEncipherment SHOULD NOT be present.Instance Variables:	e	&lt;Object&gt; undocumented	n	&lt;Object&gt; undocumentedClass Instance Variables:</body></comment><class><name>BasicConstraints</name><environment>Security.X509</environment><super>Security.X509.Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ca depth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.BasicConstraints</class-id><body>RFC 3280 (section 4.2.1.10): The basic constraints extension identifies whether the subject of the certificate is a CA and the maximum depth of valid certification paths that include this certificate.The cA boolean indicates whether the certified public key belongs to a CA.  If the cA boolean is not asserted, then the keyCertSign bit in the key usage extension MUST NOT be asserted.The pathLenConstraint field is meaningful only if the cA boolean is asserted and the key usage extension asserts the keyCertSign bit (section 4.2.1.3).  In this case, it gives the maximum number of non-self-issued intermediate certificates that may follow this certificate in a valid certification path.  A certificate is self-issued if the DNs that appear in the subject and issuer fields are identical and are not empty.  (Note: The last certificate in the certification path is not an intermediate certificate, and is not included in this limit.  Usually, the last certificate is an end entity certificate, but it can be a CA certificate.)  A pathLenConstraint of zero indicates that only one more certificate may follow in a valid certification path.  Where it appears, the pathLenConstraint field MUST be greater than or equal to zero.  Where pathLenConstraint does not appear, no limit is imposed.This extension MUST appear as a critical extension in all CA certificates that contain public keys used to validate digital signatures on certificates.  This extension MAY appear as a critical or non-critical extension in CA certificates that contain public keys used exclusively for purposes other than validating digital signatures on certificates.  Such CA certificates include ones that contain public keys used exclusively for validating digital signatures on CRLs and ones that contain key management public keys used with certificate enrollment protocols.  This extension MAY appear as a critical or non-critical extension in end entity certificates.CAs MUST NOT include the pathLenConstraint field unless the cA boolean is asserted and the key usage extension asserts the keyCertSign bit.   id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }   BasicConstraints ::= SEQUENCE {        cA                      BOOLEAN DEFAULT FALSE,        pathLenConstraint       INTEGER (0..MAX) OPTIONAL }Instance Variables:	ca	&lt;Boolean&gt;	is the subject a certificate issuing authority ?	depth	&lt;Integer&gt; maximum depth of valid certification paths that include this certificate</body></comment><class><name>Expired</name><environment>Security.X509</environment><super>Security.X509.ValidityError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.Expired</class-id><body>Indicates that a certificate has expired.</body></comment><class><name>X509RSAPrivateKey</name><environment>Security.X509</environment><super>Security.X509.X509PrivateKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version d n e p q exponent1 exponent2 coefficient </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509RSAPrivateKey</class-id><body>Private key for RSA signature/encryption algorithm.The ASN.1 representation is described in PKCS#1, section A.1.2, RSA private key syntax:An RSA private key should be represented with the ASN.1 type RSAPrivateKey:	RSAPrivateKey ::= SEQUENCE {		version Version,		modulus INTEGER, -- n		publicExponent INTEGER, -- e		privateExponent INTEGER, -- d		prime1 INTEGER, -- p		prime2 INTEGER, -- q		exponent1 INTEGER, -- d mod (p-1)		exponent2 INTEGER, -- d mod (q-1)		coefficient INTEGER, -- (inverse of q) mod p		otherPrimeInfos OtherPrimeInfos OPTIONAL }The fields of type RSAPrivateKey have the following meanings:* version is the version number, for compatibility with future revisions of this document.It shall be 0 for this version of the document, unless multi-prime is used, in which case it shall be 1.	Version ::= INTEGER { two-prime(0), multi(1) }		(CONSTRAINED BY {-- version must be multi if otherPrimeInfos present --})* modulus is the RSA modulus n.* publicExponent is the RSA public exponent e.* privateExponent is the RSA private exponent d.* prime1 is the prime factor p of n.* prime2 is the prime factor q of n.* exponent1 is d mod (p - 1).* exponent2 is d mod (q - 1).* coefficient is the CRT coefficient q^-1 mod p.* otherPrimeInfos contains the information for the additional primes r3, ... , ru, in order.It shall be omitted if version is 0 and shall contain at least one instance of OtherPrimeInfo if version is 1.	OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo	OtherPrimeInfo ::= SEQUENCE {		prime INTEGER, -- ri		exponent INTEGER, -- di		coefficient INTEGER -- ti	}The fields of type OtherPrimeInfo have the following meanings:* prime is a prime factor ri of n, where i &gt;= 3.* exponent is di = d mod (ri - 1).* coefficient is the CRT coefficient ti = (r1 * r2 * ... * r(i-1))^-1 mod ri.Instance Variables:	version	&lt;Integer&gt; 	d	&lt;Integer&gt; private exponent	n	&lt;Integer&gt; modulus	e	&lt;Integer&gt; public exponent	p	&lt;Integer&gt; prime factor 1	q	&lt;Integer&gt; prime factor 2	exponent1	&lt;Integer&gt; d mod (p - 1).	exponent2	&lt;Integer&gt; d mod (q - 1).	coefficient	&lt;Integer&gt; the CRT coefficient q^-1 mod p.</body></comment><class><name>AlgorithmIdentifier</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oid oidDescription parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.AlgorithmIdentifier</class-id><body>RFC 3280 (section 4.1.1.2 signatureAlgorithm): The signatureAlgorithm field contains the identifier for the cryptographic algorithm used by the CA to sign this certificate. [RFC 3279] lists supported signature algorithms, but other signature algorithms MAY also be supported.An algorithm identifier is defined by the following ASN.1 structure:   AlgorithmIdentifier  ::=  SEQUENCE  {        algorithm               OBJECT IDENTIFIER,        parameters              ANY DEFINED BY algorithm OPTIONAL  }The OBJECT IDENTIFIER component identifies the algorithm (such as DSA with SHA-1). The contents of the optional parameters field will vary according to the algorithm identified.This field MUST contain the same algorithm identifier as the signature field in the sequence tbsCertificate (section 4.1.2.3).Instance Variables:	oid	&lt;Asn1OID&gt; 	oidDescription	&lt;String&gt; 	parameters	&lt;Object&gt; optional signing algorithm parameters</body></comment><class><name>Unsupported</name><environment>Security.X509</environment><super>Security.X509.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.Unsupported</class-id><body>Indicates an unsupported feature, e.g. an unsupported signature algorithm.</body></comment><class><name>SubjectPublicKeyInfo</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>algorithm subjectPublicKey publicKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.SubjectPublicKeyInfo</class-id><body>RFC 3280 (section 4.1.2.7  Subject Public Key Info): This field is used to carry the public key and identify the algorithm with which the key is used (e.g., RSA, DSA, or Diffie-Hellman).  The algorithm is identified using the AlgorithmIdentifier structure specified in section 4.1.1.2.  The object identifiers for the supported algorithms and the methods for encoding the public key materials (public key and parameters) are specified in [RFC 3279].	SubjectPublicKeyInfo  ::=  SEQUENCE  {		algorithm            AlgorithmIdentifier,		subjectPublicKey     BIT STRING  }Instance Variables:	algorithm	&lt;X509AlgorithmIdentifier&gt; 	subjectPublicKey	&lt;BitString&gt; DER encoded key structure (defined by the OID)	publicKey	&lt;X509PublicKey&gt; unmarshaled public key instance</body></comment><class><name>UnhandledCriticalExtension</name><environment>Security.X509</environment><super>Security.X509.Unsupported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extension </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.UnhandledCriticalExtension</class-id><body>Indicates that a certificate has an extension which is marked as critical, but we don't know how to handle it.Instance Variables:	extension	&lt;Object&gt; undocumented</body></comment><class><name>X509DSAPrivateKey</name><environment>Security.X509</environment><super>Security.X509.X509PrivateKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version p q g x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.X509DSAPrivateKey</class-id><body>Private key for DSS signature standard.The ASN.1 representation is derived from the DER format used by OpenSSL. It is described in the man page for the dsa command, DSA(1) as follows: "This specifies the input format. The DER option with a private key uses an ASN1 DER encoded form of an ASN.1 SEQUENCE consisting of the values of version (currently zero), p, q, g, the public and private key components respectively as ASN.1 INTEGERs." Instance Variables:	version	&lt;Integer&gt; 	p	&lt;LargeInteger&gt; 	q	&lt;LargeInteger&gt; 	g	&lt;LargeInteger&gt; 	x	&lt;LargeInteger&gt; 	y	&lt;LargeInterger&gt; </body></comment><class><name>Certificate</name><environment>Security.X509</environment><super>Security.X509.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding tbsCertificate signatureAlgorithm signatureValue signature </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509.Certificate</class-id><body>RFC 3280 (section 3.1  X.509 Version 3 Certificate): Users of a public key require confidence that the associated private key is owned by the correct remote subject (person or system) with which an encryption or digital signature mechanism will be used. This confidence is obtained through the use of public key certificates, which are data structures that bind public key values to subjects.  The binding is asserted by having a trusted CA digitally sign each certificate.  The CA may base this assertion upon technical means (a.k.a., proof of possession through a challenge-response protocol), presentation of the private key, or on an assertion by the subject.  A certificate has a limited valid lifetime which is indicated in its signed contents.  Because a certificate's signature and timeliness can be independently checked by a certificate-using client, certificates can be distributed via untrusted communications and server systems, and can be cached in unsecured storage in certificate-using systems.ITU-T X.509 (formerly CCITT X.509) or ISO/IEC 9594-8, which was first published in 1988 as part of the X.500 Directory recommendations, defines a standard certificate format [X.509].  The certificate format in the 1988 standard is called the version 1 (v1) format. When X.500 was revised in 1993, two more fields were added, resulting in the version 2 (v2) format.The Internet Privacy Enhanced Mail (PEM) RFCs, published in 1993, include specifications for a public key infrastructure based on X.509 v1 certificates [RFC 1422].  The experience gained in attempts to deploy RFC 1422 made it clear that the v1 and v2 certificate formats are deficient in several respects.  Most importantly, more fields were needed to carry information which PEM design and implementation experience had proven necessary.  In response to these new requirements, ISO/IEC, ITU-T and ANSI X9 developed the X.509 version 3 (v3) certificate format.  The v3 format extends the v2 format by adding provision for additional extension fields.  Particular extension field types may be specified in standards or may be defined and registered by any organization or community.  In June 1996, standardization of the basic v3 format was completed [X.509].ISO/IEC, ITU-T, and ANSI X9 have also developed standard extensions for use in the v3 extensions field [X.509][X9.55].  These extensions can convey such data as additional subject identification information, key attribute information, policy information, and certification path constraints.However, the ISO/IEC, ITU-T, and ANSI X9 standard extensions are very broad in their applicability.  In order to develop interoperable implementations of X.509 v3 systems for Internet use, it is necessary to specify a profile for use of the X.509 v3 extensions tailored for the Internet.  It is one goal of this document to specify a profile for Internet WWW, electronic mail, and IPsec applications. Environments with additional requirements may build on this profile or may replace it.4.1  Basic Certificate FieldsThe X.509 v3 certificate basic syntax is as follows.  For signature calculation, the data that is to be signed is encoded using the ASN.1 distinguished encoding rules (DER) [X.690].  ASN.1 DER encoding is a tag, length, value encoding system for each element.   Certificate  ::=  SEQUENCE  {        tbsCertificate       TBSCertificate,        signatureAlgorithm   AlgorithmIdentifier,        signatureValue       BIT STRING  }The signatureAlgorithm field contains the identifier for the cryptographic algorithm used by the CA to sign this certificate.The signatureValue field contains a digital signature computed upon the ASN.1 DER encoded tbsCertificate.  The ASN.1 DER encoded tbsCertificate is used as the input to the signature function.  This signature value is encoded as a BIT STRING and included in the signature field.  The details of this process are specified for each of algorithms listed in [RFC 3279].By generating this signature, a CA certifies the validity of the information in the tbsCertificate field.  In particular, the CA certifies the binding between the public key material and the subject of the certificate.Instance Variables:	encoding	&lt;Asn1Encoding&gt; DER enconding of myself	tbsCertificate	&lt;X509TBSCertificate&gt; "to be signed" certificate, the data part	signatureAlgorithm	&lt;X509AlgorithmIdentifier&gt; identifies the algorithm used to sign the certificate	signatureValue	&lt;BitString&gt; caches marshaler friendly bit string version of the signature	signature	&lt;ByteArray | X509DSSSignatureValue&gt; signature value</body></comment><shared-variable><name>OIDToDescription</name><environment>Security.X509.Name</environment><private>false</private><constant>false</constant><category>ssl</category><initializer>Name buildOIDToDescription</initializer><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>X509Certificate</name><environment>Security</environment><private>true</private><constant>true</constant><category>backward compatibility</category><initializer>Security.X509.Certificate</initializer><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>DefaultCertificateFile</name><environment>Security.X509.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>ShouldBeStrict</name><environment>Security.X509.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><initializer>false</initializer><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>ASN1Module</name><environment>Security.X509.X509Object</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>X509Object createModule</initializer><attributes><package>X509</package></attributes></shared-variable><methods><class-id>Security.X509.X509Warning</class-id> <category>testing</category><body package="X509" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Security.X509.X509Object</class-id> <category>accessing</category><body package="X509" selector="asn1Type">asn1Type	^self class asn1Type</body></methods><methods><class-id>Security.X509.X509Object</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the object in the format used by OpenSSL"	"We need to raise DNU so that Trippy doesn't display the virtual attribute -openssl for objects that don't implement this"	^self doesNotUnderstand: (		Message			selector: #printOpenSSLOn:indent:			arguments: (Array with: aStream with: level))</body><body package="X509" selector="printOpenSSLString">printOpenSSLString"This should print the certificate in the format used by OpenSSL"	| ws |	ws := WriteStream on: (String new: 100).	self printOpenSSLOn: ws indent: 0.	^ws contents</body></methods><methods><class-id>Security.X509.X509Object</class-id> <category>utilities</category><body package="X509" selector="inspectorExtraAttributes">inspectorExtraAttributes	^#{Tools.Trippy.TextAttribute}		ifDefinedDo: [ :class | Array with: (class  label: 'openssl' text: self printOpenSSLString) ]		elseDo: [ Array new ]</body></methods><methods><class-id>Security.X509.X509Object</class-id> <category>writing</category><body package="X509" selector="writeOn:">writeOn: stream"Encode the receiver on the &lt;stream&gt;.	stream &lt;WriteStream&gt; writable binary stream"	(DERStream wrap: stream) marshalObject: self withType: self asn1Type</body></methods><methods><class-id>Security.X509.X509Object class</class-id> <category>accessing</category><body package="X509" selector="asn1Type">asn1Type"The ASN.1 type corresponding to the key class"	^ASN1Module find: self asn1TypeName</body><body package="X509" selector="asn1TypeName">asn1TypeName"The ASN.1 type name corresponding to the key class"	^self subclassResponsibility</body><body package="X509" selector="createModule">createModule	^Module new: #X509</body><body package="X509" selector="module">module	^ASN1Module ifNil: [ ASN1Module := self createModule ]</body><body package="X509" selector="resetModule">resetModule	#{ASN1Module} binding reinitializeValue</body></methods><methods><class-id>Security.X509.X509Object class</class-id> <category>utilities</category><body package="X509" selector="decodeBase64:">decodeBase64: aString	| input stream output char |	input := aString asByteArray readStream.	stream := EncodedStream on: input encodedBy: Protocols.Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	^output contents</body><body package="X509" selector="reinitialize">reinitialize"Reinitialize the X509 infrastructure	self reinitialize"	self	reinitializeAsn1Types;		reinitializeSMINodes</body><body package="X509" selector="reinitializeAsn1Types">reinitializeAsn1Types"Reinitialize the ASN.1 type registry	self reinitializeAsn1Types"	self resetModule.	(self allSubclasses select: [ :c | c class includesSelector: #initializeAsn1Types ])		do: [ :c | c initializeAsn1Types ]</body><body package="X509" selector="reinitializeSMINodes">reinitializeSMINodes"Reinitialize SMI node hierarchy for X509	self reinitializeSMINodes"	(self allSubclasses select: [ :c | c class includesSelector: #initializeSMINodes ])		do: [ :c | c initializeSMINodes ]</body><body package="X509" selector="stripWhitespace:">stripWhitespace: aString	| ws remove |	ws := (String new: aString size) writeStream.	remove := Array			with: Character cr			with: Character lf			with: Character space			with: Character tab.	aString do: [ :c | (remove includes: c) ifFalse: [ ws nextPut: c ] ].	^ws contents</body></methods><methods><class-id>Security.X509.X509Object class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeSMINodes</body><body package="X509" selector="initializeSMINodes">initializeSMINodes"Add OIDs defined by RFC#3280: Appendix A.  Psuedo-ASN.1 Structures and OIDs"	SMINode root"	-- PKIX specific OIDs	id-pkix  OBJECT IDENTIFIER  ::= { iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) }"	atPath: #(1 3 6 1 5 5 7) setSymbol: 'pkix';"	-- PKIX arcs	id-pe OBJECT IDENTIFIER  ::=  { id-pkix 1 }		-- arc for private certificate extensions	id-qt OBJECT IDENTIFIER ::= { id-pkix 2 }        	-- arc for policy qualifier types	id-kp OBJECT IDENTIFIER ::= { id-pkix 3 }        	-- arc for extended key purpose OIDS	id-ad OBJECT IDENTIFIER ::= { id-pkix 48 }		-- arc for access descriptors"	atPath: #(1 3 6 1 5 5 7 1) setSymbol: 'pe';	atPath: #(1 3 6 1 5 5 7 2) setSymbol: 'qt';	atPath: #(1 3 6 1 5 5 7 3) setSymbol: 'kp';	atPath: #(1 3 6 1 5 5 7 48) setSymbol: 'ad';"	-- policyQualifierIds for Internet policy qualifiers	id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }		-- OID for CPS qualifier	id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }		-- OID for user notice qualifier"	atPath: #(1 3 6 1 5 5 7 2 1) setSymbol: 'cps';	atPath: #(1 3 6 1 5 5 7 2 2) setSymbol: 'unotice';"	-- access descriptor definitions	id-ad-ocsp         OBJECT IDENTIFIER ::= { id-ad 1 }	id-ad-caIssuers    OBJECT IDENTIFIER ::= { id-ad 2 }	id-ad-timeStamping OBJECT IDENTIFIER ::= { id-ad 3 }	id-ad-caRepository OBJECT IDENTIFIER ::= { id-ad 5 }"	atPath: #(1 3 6 1 5 5 7 48 1) setSymbol: 'ocsp';	atPath: #(1 3 6 1 5 5 7 48 2) setSymbol: 'caIssuers';	atPath: #(1 3 6 1 5 5 7 48 3) setSymbol: 'timeStamping';	atPath: #(1 3 6 1 5 5 7 48 5) setSymbol: 'caRepository';	yourself</body></methods><methods><class-id>Security.X509.X509Object class</class-id> <category>instance creation</category><body package="X509" selector="readFrom:">readFrom: stream"Decode an instance of the receiver from the &lt;stream&gt;.	stream &lt;ReadStream&gt; readable binary stream"	^(DERStream wrap: stream) unmarshalObjectType: self asn1Type</body></methods><methods><class-id>Security.X509.Validity</class-id> <category>accessing</category><body package="X509" selector="notAfterDate">notAfterDate	"date component of notAfter"	^self notAfterTimestamp asDate</body><body package="X509" selector="notAfterTime">notAfterTime	"time component of notAfter"	^self notAfterTimestamp asTime.</body><body package="X509" selector="notAfterTimestamp">notAfterTimestamp	^notAfter _value</body><body package="X509" selector="notAfterTimestamp:">notAfterTimestamp: aTimestamp	self notAfter: (self choiceFrom: aTimestamp)</body><body package="X509" selector="notBeforeDate">notBeforeDate	"date component of notBefore"	^self notBeforeTimestamp asDate.</body><body package="X509" selector="notBeforeTime">notBeforeTime	"time component of notBefore" 	^self notBeforeTimestamp asTime.</body><body package="X509" selector="notBeforeTimestamp">notBeforeTimestamp	^notBefore _value</body><body package="X509" selector="notBeforeTimestamp:">notBeforeTimestamp: aTimestamp	self notBefore: (self choiceFrom: aTimestamp)</body></methods><methods><class-id>Security.X509.Validity</class-id> <category>marshaling</category><body package="X509" selector="notAfter">notAfter	^notAfter</body><body package="X509" selector="notAfter:">notAfter: anAsn1Choice	notAfter := anAsn1Choice</body><body package="X509" selector="notBefore">notBefore	^notBefore</body><body package="X509" selector="notBefore:">notBefore: anAsn1Choice	notBefore := anAsn1Choice</body></methods><methods><class-id>Security.X509.Validity</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the certificate in the format used by OpenSSL"	| format |	format := 'mmm d hh:mm:ss yyyy'.	aStream tab: level; nextPutAll: (#NotBeforePrefix &lt;&lt; #security &gt;&gt; 'Not Before: ') asString.	TimestampPrintPolicy print: self notBeforeGMT on: aStream using: format.	aStream nextPutAll: (#GMTPrefix &lt;&lt; #security &gt;&gt; ' GMT') asString; cr;		tab: level; nextPutAll: (#NotAfterPrefix &lt;&lt; #security &gt;&gt; 'Not After : ') asString.	TimestampPrintPolicy print: self notAfterGMT on: aStream using: format.	aStream nextPutAll: (#GMTPrefix &lt;&lt; #security &gt;&gt; ' GMT') asString</body></methods><methods><class-id>Security.X509.Validity</class-id> <category>testing</category><body package="X509" selector="isExpired">isExpired	^self isExpiredOn: Timestamp now</body><body package="X509" selector="isExpiredOn:">isExpiredOn: time	^self notAfter asSeconds &lt; time asSeconds</body><body package="X509" selector="isNotValidYet">isNotValidYet	^self isNotValidYetOn: Timestamp now</body><body package="X509" selector="isNotValidYetOn:">isNotValidYetOn: time	^time asSeconds &lt; self notBefore asSeconds</body><body package="X509" selector="isValid">isValid	^self isValidOn: Timestamp now</body><body package="X509" selector="isValidOn:">isValidOn: time	^((self isExpiredOn: time) or: [ self isNotValidYetOn: time ]) not</body></methods><methods><class-id>Security.X509.Validity</class-id> <category>private</category><body package="X509" selector="choiceFrom:">choiceFrom: aTimestamp"RFC: ... CAs conforming to this profile MUST always encode certificate validity dates through the year 2049 as UTCTime; certificate validity dates in 2050 or later MUST be encoded as GeneralizedTime..."	^Choice		type: (ASN1Module find: #Time)		choiceSymbol: (aTimestamp year &lt; 2050 ifTrue: [ #utcTime ] ifFalse: [ #generalTime ])		value: aTimestamp</body><body package="X509" selector="convertToGMT:">convertToGMT: aTimestamp	^TimeZone reference		convertToGMT: aTimestamp asSeconds		do: [ :date :seconds | Timestamp fromDate: date andTime: (Time fromSeconds: seconds) ]</body><body package="X509" selector="notAfterGMT">notAfterGMT	^self convertToGMT: notAfter</body><body package="X509" selector="notBeforeGMT">notBeforeGMT	^self convertToGMT: notBefore</body></methods><methods><class-id>Security.X509.Validity class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	Validity ::= SEQUENCE {		notBefore	Time,		notAfter	Time }"	( ASN1Module SEQUENCE: #Validity )		addElement: #notBefore type: #Time;		addElement: #notAfter type: #Time;		mapping: self."	Time ::= CHOICE {		utcTime        UTCTime,		generalTime    GeneralizedTime }"	( ASN1Module CHOICE: #Time )		addElement: #utcTime type: #UTCTime;		addElement: #generalTime type: #GeneralizedTime.</body></methods><methods><class-id>Security.X509.Validity class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#Validity</body></methods><methods><class-id>Security.X509.Extension</class-id> <category>accessing</category><body package="X509" selector="critical">critical	^critical</body><body package="X509" selector="critical:">critical: aBoolean	critical := aBoolean.	(self shouldBeCritical and: [ aBoolean not ]) ifTrue: [		ExtensionShouldBeCritical  new			messageText: ((#CertExtShouldBeCritical1p&lt;&lt; #security &gt;&gt; 'Certificate extension &lt;1p&gt; should be critical')							expandMacrosWith: self class);			parameter: self;			isResumable: true;			raiseSignal ].</body><body package="X509" selector="oid">oid	^oid</body><body package="X509" selector="oid:">oid: anOID	oid := anOID</body><body package="X509" selector="value">value	"the value"	^value</body><body package="X509" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>Security.X509.Extension</class-id> <category>testing</category><body package="X509" selector="isBasicConstraints">isBasicConstraints	^false</body><body package="X509" selector="isCritical">isCritical	" the value of the instance variable critical"	^self critical</body><body package="X509" selector="isHandled">isHandled	^false</body><body package="X509" selector="isKeyUsage">isKeyUsage	^false</body><body package="X509" selector="isSubjectAltName">isSubjectAltName	^false</body><body package="X509" selector="isSubjectKeyIdentifier">isSubjectKeyIdentifier	^false</body><body package="X509" selector="shouldBeCritical">shouldBeCritical	^false</body></methods><methods><class-id>Security.X509.Extension</class-id> <category>marshaling</category><body package="X509" selector="asn1Value">asn1Value	^self</body><body package="X509" selector="extnID">extnID	^oid</body><body package="X509" selector="extnID:">extnID: anOID	self oid: anOID</body><body package="X509" selector="extnValue">extnValue	^value ifNil: [ | stream |		stream := DERStream on: (ByteArray new: 20).		stream marshalObject: self asn1Value withType: self asn1Type.		value := stream contents ].</body><body package="X509" selector="extnValue:">extnValue: aByteArray	value := aByteArray.	(self class extensionClassFor: oid) ifNotNil: [ :class || extension |		extension := aByteArray.		class asn1Type ifNotNil: [ :type || stream |			stream := DERStream with: aByteArray.			stream reset.			extension := stream unmarshalObjectType: type ].		"Some extensions are simple types that the ASN.1 framework can't map to class automatically,		so we need to work around that here"		extension := class adoptValue: extension.		extension			oid: oid;			critical: critical;			value: value.		self become: extension ]</body></methods><methods><class-id>Security.X509.Extension</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self class oid ifNotNil: [ :id | self oid: id ].	self shouldBeCritical ifTrue: [ self critical: true ]</body></methods><methods><class-id>Security.X509.Extension</class-id> <category>printing</category><body package="X509" selector="id">id	"OID for the extension"	^oid getDottedOID</body><body package="X509" selector="idDescription">idDescription	" the description of the OID for the extension"	^oid	ifNil: ['']		ifNotNil: [ 			[	oid getOIDDescription			] 	on: SMIUnknownPath				do: [ :ex | ex return: '' ] ]</body><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the extension in the format used by OpenSSL"	aStream cr; tab: level;		nextPutAll: (			self class = Extension				ifTrue: [ oid getDottedOID ]				ifFalse: [ self class name ]);		nextPut: $:.	critical ifTrue: [aStream nextPutAll: (#CriticalSuffix &lt;&lt; #security &gt;&gt; ' critical') asString].</body></methods><methods><class-id>Security.X509.Extension</class-id> <category>writing</category><body package="X509" selector="writeOn:">writeOn: stream"Encode the receiver on the &lt;stream&gt;.	stream &lt;WriteStream&gt; writable binary stream"	(DERStream wrap: stream) marshalObject: self asn1Value withType: self asn1Type</body></methods><methods><class-id>Security.X509.Extension class</class-id> <category>accessing</category><body package="X509" selector="asn1Type">asn1Type	^self asn1TypeName ifNotNil: [ :type |		ASN1Module find: type ]</body><body package="X509" selector="asn1TypeName">asn1TypeName	^nil</body><body package="X509" selector="extensionClassFor:">extensionClassFor: anOID	^Extension allSubclasses		detect: [ :c | c oid = anOID ]		ifNone: [ nil ]</body><body package="X509" selector="oid">oid	^oid ifNil: [ self oidString ifNotNil: [ :s | oid := s asAsn1OID ] ]</body></methods><methods><class-id>Security.X509.Extension class</class-id> <category>private</category><body package="X509" selector="adoptValue:">adoptValue: value"Some extensions are simple types that the ASN.1 framework can't map to class automatically, so we need to work around that here."	"by default the extension is mappable so there's nothing that needs to be done; just return the value"	^value</body><body package="X509" selector="oidString">oidString	^nil</body></methods><methods><class-id>Security.X509.Extension class</class-id> <category>instance creation</category><body package="X509" selector="new">new	^super new initialize</body><body package="X509" selector="readFrom:">readFrom: stream"Decode an instance of the receiver from the &lt;stream&gt;.	stream &lt;ReadStream&gt; readable binary stream"	^self adoptValue: (super readFrom: stream)</body></methods><methods><class-id>Security.X509.Extension class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self	initializeAsn1Types;		initializeSMINodes</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	Extension  ::=  SEQUENCE  {		extnID      OBJECT IDENTIFIER,		critical    BOOLEAN DEFAULT FALSE,		extnValue   OCTET STRING  }"	( ASN1Module SEQUENCE: #Extension )		addElement: #extnID type: #'OBJECT IDENTIFIER';		addElement: #critical type: #BOOLEAN default: false;		addElement: #extnValue type: #OCTET_STRING;		mapping: self</body><body package="X509" selector="initializeSMINodes">initializeSMINodes"Add OIDs defined by RFC#3280: Appendix A.  Psuedo-ASN.1 Structures and OIDs"	SMINode root		atPath: #( 2 5 29 )					setSymbol: 'ce';		atPath: #( 2 5 29 3 )					setSymbol: 'certificatePolicies';		atPath: #( 2 5 29 14 )				setSymbol: 'subjectKeyIdentifier';		atPath: #( 2 5 29 15 )				setSymbol: 'keyUsage';		atPath: #( 2 5 29 16 )				setSymbol: 'privateKeyUsagePeriod';		atPath: #( 2 5 29 17 )				setSymbol: 'subjectAltName';		atPath: #( 2 5 29 18 )				setSymbol: 'issuerAltName';		atPath: #( 2 5 29 19 )				setSymbol: 'basicConstraints';		atPath: #( 2 5 29 20 )				setSymbol: 'cRLNumber';		atPath: #( 2 5 29 21 )				setSymbol: 'reasonCode';		atPath: #( 2 5 29 23 )				setSymbol: 'instructionCode';		atPath: #( 2 5 29 24 )				setSymbol: 'invalidityDate';		atPath: #( 2 5 29 27 )				setSymbol: 'deltaCRLIndicator';		atPath: #( 2 5 29 28 )				setSymbol: 'issuingDistributionPoint';		atPath: #( 2 5 29 29 )				setSymbol: 'certificateIssuer';		atPath: #( 2 5 29 30 )				setSymbol: 'nameConstraints';		atPath: #( 2 5 29 31 )				setSymbol: 'cRLDistributionPoints';		atPath: #( 2 5 29 32 )				setSymbol: 'certificatePolicies';		atPath: #( 2 5 29 33 )				setSymbol: 'policyMappings';		atPath: #( 2 5 29 35 )				setSymbol: 'authorityKeyIdentifier';		atPath: #( 2 5 29 36 )				setSymbol: 'policyConstraints';		atPath: #( 2 5 29 37 )				setSymbol: 'extKeyUsage';		yourself</body></methods><methods><class-id>Security.X509.SubjectKeyIdentifier</class-id> <category>accessing</category><body package="X509" selector="identifier">identifier	^identifier</body><body package="X509" selector="identifier:">identifier: aByteArray	identifier := aByteArray</body></methods><methods><class-id>Security.X509.SubjectKeyIdentifier</class-id> <category>testing</category><body package="X509" selector="isSubjectKeyIdentifier">isSubjectKeyIdentifier	^true</body></methods><methods><class-id>Security.X509.SubjectKeyIdentifier</class-id> <category>initialize-release</category><body package="X509" selector="initialize:">initialize: aByteArray	identifier := aByteArray</body></methods><methods><class-id>Security.X509.SubjectKeyIdentifier</class-id> <category>marshaling</category><body package="X509" selector="asn1Value">asn1Value	^self identifier</body></methods><methods><class-id>Security.X509.SubjectKeyIdentifier class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName"Answer the ASN.1 type for the extension value."	^#SubjectKeyIdentifier</body></methods><methods><class-id>Security.X509.SubjectKeyIdentifier class</class-id> <category>private</category><body package="X509" selector="adoptValue:">adoptValue: aByteArray	^self new initialize: aByteArray</body><body package="X509" selector="oidString">oidString	^'2.5.29.14'</body></methods><methods><class-id>Security.X509.SubjectKeyIdentifier class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types" 	SubjectKeyIdentifier ::= KeyIdentifier	KeyIdentifier is defined by AuthorityKeyIdentifier as		KeyIdentifier ::= OCTET STRING	however to avoid ordering issues in registry initialization we'll shortcut the definition as follows."	ASN1Module OCTET_STRING: #SubjectKeyIdentifier</body></methods><methods><class-id>Security.X509.Name</class-id> <category>marshaling</category><body package="X509" selector="asn1ChoiceType">asn1ChoiceType"We need to pretend to be a choice for marshaling purposes"	^ASN1Module find: #RDNSequence</body><body package="X509" selector="asn1ChoiceValue">asn1ChoiceValue"We need to pretend to be a choice for marshaling purposes"	^relativeDistinguishedName collect: [ :ava | OrderedCollection with: ava ]</body><body package="X509" selector="encoding">encoding	^encoding</body><body package="X509" selector="encoding:">encoding: anEncoding	encoding := anEncoding</body><body package="X509" selector="_encoding">_encoding	^encoding</body><body package="X509" selector="_encoding:type:">_encoding: anEncoding type: aType	encoding := anEncoding</body></methods><methods><class-id>Security.X509.Name</class-id> <category>utilities</category><body package="X509" selector="asX509Name">asX509Name	^self</body><body package="X509" selector="descriptionFor:">descriptionFor: oid	^OIDToDescription at: oid ifAbsent: [ oid getDottedOID ]</body><body package="X509" selector="flushEncoding">flushEncoding	encoding := nil</body><body package="X509" selector="oidFor:">oidFor: string	^OIDToDescription at: string ifAbsent: [ string asAsn1OID ]</body></methods><methods><class-id>Security.X509.Name</class-id> <category>accessing</category><body package="X509" selector="add:">add: anAssociation	self at: anAssociation key put: anAssociation value</body><body package="X509" selector="at:">at: key	^self at: key ifAbsent: [nil]</body><body package="X509" selector="at:ifAbsent:">at: key ifAbsent: block	| oid |	oid := key isCharacters			ifTrue: [ self oidFor: key ]			ifFalse: [ key asAsn1OID ].	^(self getRDN detect: [ :ava | ava type = oid ] ifNone: [^block value]) value</body><body package="X509" selector="at:put:">at: key put: value	| oid |	oid := key isCharacters			ifTrue: [ self oidFor: key ]			ifFalse: [ key asAsn1OID ].	self getRDN add: (		AttributeValueAssertion new			type: oid;			value: value;			yourself )</body><body package="X509" selector="getDNBytes">getDNBytes	"return the raw bytes"	^self getEncoding fullEncoding</body><body package="X509" selector="getEncoding">getEncoding	^encoding ifNil: [ | marshaler |		marshaler := DERStream on: (ByteArray new: 100).		marshaler marshalObject: self withType: self asn1Type.		encoding := Encoding with: marshaler contents ]</body><body package="X509" selector="getRDN">getRDN	"OrderedCollection containing the RDN attribute/value pairs"	^relativeDistinguishedName ifNil: [		relativeDistinguishedName := OrderedCollection new ]</body></methods><methods><class-id>Security.X509.Name</class-id> <category>initialize</category><body package="X509" selector="initializeFromChoice:">initializeFromChoice: anAsn1Wrapper"The ASN.1 framework can only map SEQUENCE and SET to Smalltalk class so far, so this method helps to work around the limitation."	encoding := anAsn1Wrapper _encoding.	relativeDistinguishedName :=  OrderedCollection new.	anAsn1Wrapper _value do: [ :rdn |		rdn do: [ :ava | relativeDistinguishedName add: ava ] ]</body></methods><methods><class-id>Security.X509.Name</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the certificate in the format used by OpenSSL"	aStream tab: level.	self getRDN		do: [ :ava |			aStream				nextPutAll: (OIDToDescription at: ava type);				nextPut: $=;				nextPutAll: ava value ]		separatedBy: [ aStream nextPutAll: ', ' ]</body><body package="X509" selector="shortString">shortString	self commonName ifNotNil: [ :cn | ^cn ].	self name ifNotNil: [ :n | ^n ].	self surname ifNotNil: [ :sn |		^self givenName ifNil: [ sn ] ifNotNil: [ :gn | gn, ' ', sn ] ].	self organizationUnit ifNotNil: [ :ou | ^ou ].	self organization ifNotNil: [ :o | ^o ].	self email ifNotNil: [ :e | ^e ].	^self getRDN isEmpty		ifTrue: [ 'empty name' ]		ifFalse: [ self getRDN first value ]</body></methods><methods><class-id>Security.X509.Name</class-id> <category>accessing - name components - short</category><body package="X509" selector="C">C	^self country</body><body package="X509" selector="C:">C: string	self country: string</body><body package="X509" selector="CN">CN	^self commonName</body><body package="X509" selector="CN:">CN: string	self commonName: string</body><body package="X509" selector="E">E	^self email</body><body package="X509" selector="E:">E: string	self email: string</body><body package="X509" selector="L">L	^self locality</body><body package="X509" selector="L:">L: string	self locality: string</body><body package="X509" selector="N">N	^self name</body><body package="X509" selector="N:">N: string	self name: string</body><body package="X509" selector="O">O	^self organization</body><body package="X509" selector="O:">O: string	self organization: string</body><body package="X509" selector="OU">OU	^self organizationUnit</body><body package="X509" selector="OU:">OU: string	self organizationUnit: string</body><body package="X509" selector="S">S	^self state</body><body package="X509" selector="S:">S: string	self state: string</body></methods><methods><class-id>Security.X509.Name</class-id> <category>ssl</category><body package="X509" selector="asAssociations">asAssociations"Return an ordered collection of associations. It compares better than the dictionary an I am still not sure if the order is relevant or not. Dictionary is handy for other cases."	^self getRDN collect: [ :ava || oid |		oid := ava type.		(self descriptionFor: oid) -&gt; ava value ].</body><body package="X509" selector="asDictionary">asDictionary	| dict |	dict := Dictionary new.	self getRDN do: [ :ava || oid |		oid := ava type.		dict	at: (self descriptionFor: oid)			put: ava value ].	^dict</body></methods><methods><class-id>Security.X509.Name</class-id> <category>accessing - name components</category><body package="X509" selector="commonName">commonName	^self at: 'CN'</body><body package="X509" selector="commonName:">commonName: string	self at: 'CN' put: string</body><body package="X509" selector="country">country	^self at: 'C'</body><body package="X509" selector="country:">country: string	self at: 'C' put: string</body><body package="X509" selector="description">description	^self at: 'D'</body><body package="X509" selector="description:">description: string	self at: 'D' put: string</body><body package="X509" selector="email">email	^self at: 'E'</body><body package="X509" selector="email:">email: string	self at: 'E' put: string</body><body package="X509" selector="givenName">givenName	^self at: 'GN'</body><body package="X509" selector="givenName:">givenName: string	self at: 'GN' put: string</body><body package="X509" selector="locality">locality	^self at: 'L'</body><body package="X509" selector="locality:">locality: string	self at: 'L' put: string</body><body package="X509" selector="name">name	^self at: 'N'</body><body package="X509" selector="name:">name: string	self at: 'N' put: string</body><body package="X509" selector="organization">organization	^self at: 'O'</body><body package="X509" selector="organization:">organization: string	self at: 'O' put: string</body><body package="X509" selector="organizationUnit">organizationUnit	^self at: 'OU'</body><body package="X509" selector="organizationUnit:">organizationUnit: string	self at: 'OU' put: string</body><body package="X509" selector="state">state	^self at: 'S'</body><body package="X509" selector="state:">state: string	self at: 'S' put: string</body><body package="X509" selector="streetAddress">streetAddress	^self at: 'A'</body><body package="X509" selector="streetAddress:">streetAddress: string	self at: 'A' put: string</body><body package="X509" selector="surname">surname	^self at: 'SN'</body><body package="X509" selector="surname:">surname: string	self at: 'SN' put: string</body></methods><methods><class-id>Security.X509.Name class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#Name</body></methods><methods><class-id>Security.X509.Name class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self	initializeAsn1Types;		initializeSMINodes</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	RelativeDistinguishedName ::= SET OF AttributeTypeAndValue"	ASN1Module SET: #RelativeDistinguishedName OF: #AttributeTypeAndValue."	RDNSequence ::= SEQUENCE OF RelativeDistinguishedName"	ASN1Module SEQUENCE: #RDNSequence OF: #RelativeDistinguishedName."	Name ::= CHOICE { RDNSequence }"	(ASN1Module CHOICE: self asn1TypeName)		addElement: nil type: #RDNSequence;		"mapping: self; not supported yet"		retainEncoding: true;		"this is the default, but to make it resilient when the default is changed"		useChoice: true</body><body package="X509" selector="initializeSMINodes">initializeSMINodes"Add OIDs defined by RFC#3280: Appendix A.  Psuedo-ASN.1 Structures and OIDs"	SMINode root"	-- suggested naming attributes: Definition of the following	--   information object set may be augmented to meet local	--   requirements.  Note that deleting members of the set may	--   prevent interoperability with conforming implementations.	-- presented in pairs: the AttributeType followed by the	--   type definition for the corresponding AttributeValue	--Arc for standard naming attributes"		atPath: #( 2 5 4 ) setSymbol: 'at';"	-- Naming attributes of type X520name	X520name ::= CHOICE {		teletexString     TeletexString   (SIZE (1..ub-name)),		printableString   PrintableString (SIZE (1..ub-name)),		universalString   UniversalString (SIZE (1..ub-name)),		utf8String		UTF8String	(SIZE (1..ub-name)),		bmpString		BMPString       (SIZE (1..ub-name)) }	ub-name INTEGER ::= 32768	id-at-name              AttributeType ::= { id-at 41 }	id-at-surname           AttributeType ::= { id-at 4 }	id-at-givenName         AttributeType ::= { id-at 42 }	id-at-initials          AttributeType ::= { id-at 43 }	id-at-generationQualifier AttributeType ::= { id-at 44 }"		atPath: #( 2 5 4 4 ) setSymbol: 'surname'; 		atPath: #( 2 5 4 41 ) setSymbol: 'name';		atPath: #( 2 5 4 42 ) setSymbol: 'givenName'; 		atPath: #( 2 5 4 43 ) setSymbol: 'initials';		atPath: #( 2 5 4 44 ) setSymbol: 'generationQualifier';"	-- Naming attributes of type X520CommonName	X520CommonName ::= CHOICE {		teletexString     TeletexString   (SIZE (1..ub-common-name)),		printableString   PrintableString (SIZE (1..ub-common-name)),		universalString   UniversalString (SIZE (1..ub-common-name)),		utf8String		  UTF8String		(SIZE (1..ub-common-name)),		bmpString         BMPString       (SIZE (1..ub-common-name)) }	ub-common-name INTEGER ::= 64	id-at-commonName        AttributeType ::= { id-at 3 }"		atPath: #( 2 5 4 3 ) setSymbol: 'commonName';"	-- Naming attributes of type X520LocalityName	X520LocalityName ::= CHOICE {	      teletexString     TeletexString   (SIZE (1..ub-locality-name)),	      printableString   PrintableString (SIZE (1..ub-locality-name)),	      universalString   UniversalString (SIZE (1..ub-locality-name)),	      utf8String        UTF8String      (SIZE (1..ub-locality-name)),	      bmpString         BMPString       (SIZE (1..ub-locality-name)) }	ub-locality-name INTEGER ::= 128	id-at-localityName      AttributeType ::= { id-at 7 }"		atPath: #( 2 5 4 7 ) setSymbol: 'localityName';"	-- Naming attributes of type X520StateOrProvinceName	X520StateOrProvinceName ::= CHOICE {	      teletexString     TeletexString   (SIZE (1..ub-state-name)),	      printableString   PrintableString (SIZE (1..ub-state-name)),	      universalString   UniversalString (SIZE (1..ub-state-name)),	      utf8String        UTF8String      (SIZE (1..ub-state-name)),	      bmpString         BMPString       (SIZE(1..ub-state-name)) }	ub-state-name INTEGER ::= 128	id-at-stateOrProvinceName AttributeType ::= { id-at 8 }"		atPath: #( 2 5 4 8 ) setSymbol: 'stateOrProvinceName';"	-- Naming attributes of type X520OrganizationName	X520OrganizationName ::= CHOICE {	      teletexString     TeletexString	(SIZE (1..ub-organization-name)),	      printableString   PrintableString	(SIZE (1..ub-organization-name)),	      universalString   UniversalString	(SIZE (1..ub-organization-name)),	      utf8String        UTF8String		(SIZE (1..ub-organization-name)),	      bmpString         BMPString		(SIZE (1..ub-organization-name))  }	ub-organization-name INTEGER ::= 64	id-at-organizationName  AttributeType ::= { id-at 10 }"		atPath: #( 2 5 4 10 )	 setSymbol: 'organizationName';"	-- Naming attributes of type X520OrganizationalUnitName	X520OrganizationalUnitName ::= CHOICE {	      teletexString     TeletexString                          (SIZE (1..ub-organizational-unit-name)),	      printableString   PrintableString                          (SIZE (1..ub-organizational-unit-name)),	      universalString   UniversalString                          (SIZE (1..ub-organizational-unit-name)),	      utf8String        UTF8String                          (SIZE (1..ub-organizational-unit-name)),	      bmpString         BMPString                          (SIZE (1..ub-organizational-unit-name)) }	ub-organizational-unit-name INTEGER ::= 64	id-at-organizationalUnitName AttributeType ::= { id-at 11 }"		atPath: #( 2 5 4 11 )	 setSymbol: 'organizationalUnitName';"	-- Naming attributes of type X520Title	X520Title ::= CHOICE {	      teletexString     TeletexString   (SIZE (1..ub-title)),	      printableString   PrintableString (SIZE (1..ub-title)),	      universalString   UniversalString (SIZE (1..ub-title)),	      utf8String        UTF8String      (SIZE (1..ub-title)),	      bmpString         BMPString       (SIZE (1..ub-title)) }	ub-title INTEGER ::= 64	id-at-title             AttributeType ::= { id-at 12 }"		atPath: #( 2 5 4 12 )	 setSymbol: 'title';"	-- Naming attributes of type X520dnQualifier	X520dnQualifier ::=     PrintableString	id-at-dnQualifier       AttributeType ::= { id-at 46 }"		atPath: #( 2 5 4 46 )	 setSymbol: 'dnQualifier';"	-- Naming attributes of type X520countryName (digraph from IS 3166)	X520countryName ::=     PrintableString (SIZE (2))	id-at-countryName       AttributeType ::= { id-at 6 }"		atPath: #( 2 5 4 6 ) setSymbol: 'countryName';"	-- Naming attributes of type X520SerialNumber	X520SerialNumber ::=    PrintableString (SIZE (1..ub-serial-number))	ub-serial-number INTEGER ::= 64	id-at-serialNumber      AttributeType ::= { id-at 5 }"		atPath: #( 2 5 4 5 ) setSymbol: 'serialNumber';"	-- Naming attributes of type X520Pseudonym	X520Pseudonym ::= CHOICE {	   teletexString     TeletexString   (SIZE (1..ub-pseudonym)),	   printableString   PrintableString (SIZE (1..ub-pseudonym)),	   universalString   UniversalString (SIZE (1..ub-pseudonym)),	   utf8String        UTF8String      (SIZE (1..ub-pseudonym)),	   bmpString         BMPString       (SIZE (1..ub-pseudonym)) }	ub-pseudonym INTEGER ::= 128	id-at-pseudonym         AttributeType ::= { id-at 65 }"		atPath: #( 2 5 4 65 ) setSymbol: 'pseudonym';"	-- Naming attributes of type DomainComponent (from RFC 2247)	DomainComponent ::=     IA5String	id-domainComponent      AttributeType ::= { 0 9 2342 19200300 100 1 25 }"		atPath: #( 0 9 2342 19200300 100 1 25 ) setSymbol: #domainComponent;"	-- Legacy attributes	EmailAddress ::=         IA5String (SIZE (1..ub-emailaddress-length))	ub-emailaddress-length INTEGER ::= 128	pkcs-9 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 9 }	id-emailAddress          AttributeType ::= { pkcs-9 1 }"		atPath: #( 1 2 840 113549 1 9) setSymbol: 'emailAddress';		atPath: #( 2 5 4 9 ) setSymbol: 'streetAddress';		atPath: #( 2 5 4 13 )	 setSymbol: 'description';		yourself</body></methods><methods><class-id>Security.X509.Name class</class-id> <category>ssl</category><body package="X509" selector="buildOIDToDescription">buildOIDToDescription	| map |	map := Dictionary new		at: (ObjectIdentifier value: #(2 5 4 10)) put: 'O';	"organization"		at: (ObjectIdentifier value: #(2 5 4 11)) put: 'OU';	"organization unit"		at: (ObjectIdentifier value: #(2 5 4 3)) put: 'CN';	"common name"		at: (ObjectIdentifier value: #(2 5 4 6)) put: 'C';		"country"		at: (ObjectIdentifier value: #(2 5 4 7)) put: 'L';		"locality"		at: (ObjectIdentifier value: #(2 5 4 8)) put: 'S';		"state or province" 		at: (ObjectIdentifier value: #(2 5 4 9)) put: 'A';		"streetAddress"		at: (ObjectIdentifier value: #(2 5 4 4)) put: 'SN';	"surname" 		at: (ObjectIdentifier value: #(2 5 4 41)) put: 'N';	"name"		at: (ObjectIdentifier value: #(2 5 4 42)) put: 'GN';	"givenName"		at: (ObjectIdentifier value: #(2 5 4 13)) put: 'D';	"description"		at: (ObjectIdentifier value: #(1 2 840 113549 1 9)) put: 'E';	"email"		yourself.	map keys do: [ :oid |	map at: (map at: oid) put: oid ].	^map</body></methods><methods><class-id>Security.X509.Name class</class-id> <category>instance creation</category><body package="X509" selector="fromChoice:">fromChoice: anAsn1Choice"The ASN.1 framework can only map SEQUENCE and SET to Smalltalk class so far, so this method helps to work around the limitation."	^self new initializeFromChoice: anAsn1Choice</body><body package="X509" selector="readFrom:">readFrom: stream"Decode an instance of the receiver from the &lt;stream&gt;.	stream &lt;ReadStream&gt; readable binary stream"	^(self fromChoice: (super readFrom: stream))</body></methods><methods><class-id>Security.X509.X509Registry</class-id> <category>accessing</category><body package="X509" selector="beStrict">beStrict	strict := true</body><body package="X509" selector="dontBeStrict">dontBeStrict	strict := false</body><body package="X509" selector="isStrict">isStrict	^strict</body></methods><methods><class-id>Security.X509.X509Registry</class-id> <category>deprecated</category><body package="X509" selector="addCertificate:">addCertificate: aCertificate"As this is now ambiguous, we're deprecating this method in favor of #addTrusted: and addRevoked:."	self addTrusted: aCertificate</body><body package="X509" selector="addCertificates:">addCertificates: aCollection"As this is now ambiguous, we're deprecating this method in favor of #addTrusted: and addRevoked:."	aCollection do: [ :cert | self addCertificate: cert ]</body><body package="X509" selector="certificateFor:">certificateFor: aDNAssociations"This method is borderline ridiculous. An exact match of DN associations? How useful is that?"	^trustedCertificates		detect: [ :cert | aDNAssociations = cert subject asAssociations ]		ifNone: [ nil ]</body><body package="X509" selector="removeCertificate:">removeCertificate: aCertificate"As this is now ambiguous, we're deprecating this method in favor of #removeTrusted: and #removeRevoked:."	self removeTrusted: aCertificate</body><body package="X509" selector="trustedCertificates:">trustedCertificates: aSet"This is way too intrusive. Will be phased out in subsequent releases. Don't use!"	trustedCertificates := aSet</body></methods><methods><class-id>Security.X509.X509Registry</class-id> <category>private</category><body package="X509" selector="brokenChain:issuer:">brokenChain: subject issuer: issuer	^BrokenChain new		messageText: (#CertificateChainInvalid &lt;&lt; #security &gt;&gt; 'Certificate Chain Invalid !');		parameter: (Array with: subject with: issuer);		isResumable: true;		yourself</body><body package="X509" selector="certificateExpired:">certificateExpired: aCertificate	^Expired new		messageText: (#CertificateExpired &lt;&lt; #security &gt;&gt; 'Certificate expired!');		parameter: aCertificate;		isResumable: true;		raiseSignal</body><body package="X509" selector="certificateNotValidYet:">certificateNotValidYet: aCertificate	^NotValidYet new		messageText: (#CertificateNotValidYet &lt;&lt; #security &gt;&gt; 'Certificate not valid yet!');		parameter: aCertificate;		isResumable: true;		raiseSignal</body><body package="X509" selector="prepareForValidation:">prepareForValidation: chain "Prepare a certificate chain for validation loop.	chain &lt;OrderedCollection of: Certificate&gt;	^&lt;OrderedCollection of: Certificate&gt;"	^(self trustedCertificateMatching: chain last subjectDNInBytes)		ifNil: [ (self trustedCertificateMatching: chain last issuerDNInBytes)				"In this case either the chain is rooted in an unknown CA certificate,				or the chain is simply incomplete. Both cases are equally bad."					ifNil: [ self rootNotTrusted: chain.					"If the exception is explicitly resumed, we'll let validation to continue."					chain ]				"Since the self signed certificate at the end of the chain is practically useless, it is common practice to simply not send it.				In this case just add our trusted CA cert to the end of the chain"				ifNotNil: [ :trusted |					chain copyWith: trusted ] ]		"This is the standard case, only the local copy of the trusted certificate should be used to validate the root of the chain"		ifNotNil: [ :trusted |				chain copy				removeLast;				addLast: trusted;				yourself ].</body><body package="X509" selector="rootNotTrusted:">rootNotTrusted: chain 	^RootNotTrusted new		messageText: (#CANotInTrustRegistry &lt;&lt; #security &gt;&gt; 'CA Not in Trust Registry!');		parameter: chain last;		isResumable: true;		raiseSignal</body><body package="X509" selector="trustedCertificateMatching:">trustedCertificateMatching: dnBytes	^trustedCertificates		detect: [ :cert | dnBytes = cert subjectDNInBytes ]		ifNone: [ nil ]</body></methods><methods><class-id>Security.X509.X509Registry</class-id> <category>accessing - trusted</category><body package="X509" selector="addTrusted:">addTrusted: aCertificate"Add trusted CA certificate to the registry."	self verifyCACertificate: aCertificate.	trustedCertificates add: aCertificate</body><body package="X509" selector="removeTrusted:">removeTrusted: aCertificate	trustedCertificates remove: aCertificate</body><body package="X509" selector="trustedCertificates">trustedCertificates	^trustedCertificates</body><body package="X509" selector="trustedSubject:">trustedSubject: criteria"Return a trusted certificate with subject name matching criteria	criteria &lt;BlockClosure&gt; a one argument selection block that will receive the subject Name as the argument	^&lt;Certificate&gt;"	^self trustedCertificates		detect: [ :cert | criteria value: cert subject ]		ifNone: [ nil ]</body></methods><methods><class-id>Security.X509.X509Registry</class-id> <category>accessing - revoked</category><body package="X509" selector="addRevoked:">addRevoked: aCertificate	revokedCertificates add: aCertificate</body><body package="X509" selector="removeRevoked:">removeRevoked: aCertificate	revokedCertificates remove: aCertificate</body><body package="X509" selector="revokedCertificates">revokedCertificates	^revokedCertificates</body><body package="X509" selector="revokedSubject:">revokedSubject: criteria"Return a revoked certificate with subject name matching criteria.	criteria &lt;BlockClosure&gt; a one argument selection block that will receive the subject Name as the argument	^&lt;Certificate&gt;"	^self revokedCertificates		detect: [ :cert | criteria value: cert subject ]		ifNone: [ nil ]</body></methods><methods><class-id>Security.X509.X509Registry</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	strict := self class shouldBeStrict.	trustedCertificates := Set new.	revokedCertificates := Set new</body></methods><methods><class-id>Security.X509.X509Registry</class-id> <category>chain verification</category><body package="X509" selector="validateCertificateChain:">validateCertificateChain: chain "This is the main entry point for certificate chain validation. The chain is expected to be ordered in the ascending order of the subject issuer relationship, i.e. subject before its issuer. This method performs all the necessary checks and raises an exception if any check fails. The exceptions are resumable so it is possible to collect a list of all problems that the chain has and present them at once. If the chain passes validation the method completes without exceptions.	chain &lt;OrderedCollection of: Certificate&gt;	"	(self prepareForValidation: chain)		inject: nil into: [ :subject :issuer |			self 	verifyRevocationStatus: issuer;				verifyValidityPeriod: issuer;				verifyCriticalExtentions: issuer.			subject ifNotNil: [				self	verifyCACertificate: issuer;					verify: subject isIssuedBy: issuer ].			issuer ]</body><body package="X509" selector="verify:isIssuedBy:">verify: subject isIssuedBy: issuer	[	subject verifyIssuedBy: issuer	] 	on: IssuerMismatch		do: [ :ex | ex resignalAs: (self brokenChain: subject issuer: issuer) ]</body><body package="X509" selector="verifyBasicConstraints:">verifyBasicConstraints: certificate"Verify that a supposedly CA certificate has a properly set up BasicConstraints extension. Signal an error if there's a problem."	| basicConstraints |	basicConstraints := certificate basicConstraints.	basicConstraints isNil ifTrue: [		^BadCAConstraints new			messageText: (#MissingBasicConstraints &lt;&lt; #security &gt;&gt; 'Basic Constraints are required for a CA certificate !');			parameter: certificate;			raiseSignal ].	basicConstraints isCritical ifFalse: [		ExtensionShouldBeCritical  new			messageText: (#ExtShouldBeCritical &lt;&lt; #security &gt;&gt; 'This extension should be critical');			parameter: certificate;			extension: basicConstraints;			raiseSignal ].	basicConstraints ca 	ifFalse: [		BadCAConstraints new			messageText: (#NonCABasicConstraints &lt;&lt; #security &gt;&gt; 'Basic Constraints are invalid for a CA certificate !');			parameter: certificate;			raiseSignal ].</body><body package="X509" selector="verifyCACertificate:">verifyCACertificate: certificate"Verify that certificate is properly marked as a CA certificate. Signal an error if there's a problem."	"Unfortunatelly V1 certificates are still widely deployed (e.g. Verisign), so we'll allow V1 roots when in relaxed mode"	(	self isStrict not		and: [certificate subjectDNInBytes = certificate issuerDNInBytes		and: [certificate isVersionOne]]	) ifTrue: [^self].	self	verifyBasicConstraints: certificate;		verifyKeyUsage: certificate</body><body package="X509" selector="verifyCriticalExtentions:">verifyCriticalExtentions: certificate"Verify that all critical extensions of certificate are properly handled. Signal an error if there's a problem."	(	certificate criticalExtensions			detect:[ :ext | ext isHandled not]			ifNone:[ nil ]	) ifNotNil: [ :extension |		UnhandledCriticalExtension new			messageText: (#UnhandledCriticalExt &lt;&lt; #security &gt;&gt; 'Critical extension is not handled');			parameter: certificate;			extension: extension;			raiseSignal  ].</body><body package="X509" selector="verifyKeyUsage:">verifyKeyUsage: certificate"Verify that a supposedly CA certificate has a properly set up KeyUsage extension. Signal an error if there's a problem."	| keyUsage |	keyUsage := certificate keyUsage.	keyUsage isNil ifTrue: [		^self isStrict ifTrue: [			BadCAKeyUsage new				messageText: (#MissingKeyUsage &lt;&lt; #security &gt;&gt; 'Key Usage is required for a CA certificate !');				parameter: certificate;				raiseSignal ] ].	keyUsage isCritical ifFalse:[		ExtensionShouldBeCritical  new			messageText: (#ExtShouldBeCritical &lt;&lt; #security &gt;&gt; 'This extension should be critical');			parameter: certificate;			extension: keyUsage;			raiseSignal ].	keyUsage keyCertSign ifFalse: [		BadCAKeyUsage new			messageText: (#NotForCertSigning1 &lt;&lt; #security &gt;&gt; 'Key Usage is invalid for a CA certificate !');			parameter: certificate;			raiseSignal ].</body><body package="X509" selector="verifyRevocationStatus:">verifyRevocationStatus: certificate"Verify that a certificate was not revoked. Signal an error if there's a problem."	(revokedCertificates anySatisfy: [ :revoked | certificate isSameAs: revoked ]) ifTrue: [		Revoked new			messageText: (				#CertificateRevoked &lt;&lt; #security &gt;&gt; 'Certificate for &lt;1s&gt; is revoked!'					expandMacrosWith: certificate subject shortString);			parameter: certificate;			raiseSignal ]</body><body package="X509" selector="verifyValidityPeriod:">verifyValidityPeriod: certificate"Verify that certificate is within its validity period. Otherwise signal an error."	certificate isNotValidYet ifTrue: [ self certificateNotValidYet: certificate ].	certificate isExpired ifTrue: [ self certificateExpired: certificate ]</body></methods><methods><class-id>Security.X509.X509Registry class</class-id> <category>instance creation</category><body package="X509" selector="default">default	^default isNil ifTrue:[default := self newDefault ] ifFalse:[default ]</body><body package="X509" selector="new">new	^super new initialize</body><body package="X509" selector="newDefault">newDefault	^self newFromDefaultCertificateFile</body><body package="X509" selector="newFromCertificateFile:">newFromCertificateFile: aFileString	| registry defaultFile |	registry := self new.	defaultFile := aFileString asFilename.	defaultFile exists ifTrue: [		(CertificateFileReader readFromFile: defaultFile) do: [ :certificate |			registry addTrusted: certificate ] ].	^registry</body><body package="X509" selector="newFromDefaultCertificateFile">newFromDefaultCertificateFile		^self newFromCertificateFile: self defaultCertificateFile asFilename</body></methods><methods><class-id>Security.X509.X509Registry class</class-id> <category>accessing</category><body package="X509" selector="addCertificateToTrust:">addCertificateToTrust: aCertificate 	self trustedCertificates add: aCertificate.	self updateDictionaries</body><body package="X509" selector="beStrict">beStrict	ShouldBeStrict := true.</body><body package="X509" selector="defaultCertificateFile">defaultCertificateFile^DefaultCertificateFile isNil ifTrue:[DefaultCertificateFile := 'trustedCertificates.pem'] ifFalse:[ DefaultCertificateFile]</body><body package="X509" selector="defaultCertificateFile:">defaultCertificateFile: aString DefaultCertificateFile := aString</body><body package="X509" selector="dontBeStrict">dontBeStrict	ShouldBeStrict := false.</body><body package="X509" selector="removeCertificate:">removeCertificate: aCertificate"remove a trusted Certificate from the registry and update the indexes"	self trustedCertificates remove: aCertificate ifAbsent: [].	self updateDictionaries</body><body package="X509" selector="shouldBeStrict">shouldBeStrict	^ShouldBeStrict</body><body package="X509" selector="trustedCertificates">trustedCertificates	^self default trustedCertificates</body></methods><methods><class-id>Security.X509.X509Registry class</class-id> <category>testing</category><body package="X509" selector="trustedCertificatesContains:">trustedCertificatesContains: aCertificate"fix this to add the certificate search"	^self trustedCertificates contains: aCertificate</body></methods><methods><class-id>Security.X509.X509Registry class</class-id> <category>deprecated</category><body package="X509" selector="readTrustedCertificatesFromFile:">readTrustedCertificatesFromFile: aFilename"self readTrustedCertificatesFromFile: '..\..\demo.pem'"	| collection |	collection := CertificateFileReader readCertificatesFrom: aFilename.	self trustedCertificates addAll: collection.</body></methods><methods><class-id>Security.X509.X509Registry class</class-id> <category>private</category><body package="X509" selector="updateDictionaries">updateDictionaries" needs to be added. update our indexes. want to index by signature, subjectDN"</body></methods><methods><class-id>Security.X509.DSSParameters</class-id> <category>accessing</category><body package="X509" selector="g">g^g</body><body package="X509" selector="getg">getg^g</body><body package="X509" selector="getp">getp^p</body><body package="X509" selector="getq">getq^q</body><body package="X509" selector="p">p^p</body><body package="X509" selector="q">q^q</body></methods><methods><class-id>Security.X509.DSSParameters</class-id> <category>initialize</category><body package="X509" selector="p:q:g:">p: aP q: aQ g: aG	p := aP.	q := aQ.	g := aG</body></methods><methods><class-id>Security.X509.DSSParameters</class-id> <category>marshaling</category><body package="X509" selector="encodeASN1With:">encodeASN1With: aMarshaler	self asn1Type encodeValue: self with: aMarshaler</body><body package="X509" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00110000	"ASN1.ConstructedSEQUENCE = 48"</body></methods><methods><class-id>Security.X509.DSSParameters class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#'Dss-Parms'</body></methods><methods><class-id>Security.X509.DSSParameters class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"        Dss-Parms  ::=  SEQUENCE  {            p             INTEGER,            q             INTEGER,            g             INTEGER  }"	( ASN1Module SEQUENCE: self asn1TypeName)		addElement: #p type: #INTEGER;		addElement: #q type: #INTEGER;		addElement: #g type: #INTEGER;		mapping: self</body></methods><methods><class-id>Security.X509.DSSParameters class</class-id> <category>instance creation</category><body package="X509" selector="p:q:g:">p: aP q: aQ g: aG	^self new		p: aP		q: aQ		g: aG</body></methods><methods><class-id>Security.X509.KeyUsage</class-id> <category>accessing</category><body package="X509" selector="bits">bits	^bits</body><body package="X509" selector="crlSign">crlSign"Assert/Deny that subject's key can be used for verifying a signature on certificate revocation list (e.g., a CRL, delta CRL, or an ARL)."	^bits bitAt: 7</body><body package="X509" selector="crlSign:">crlSign: aBoolean"Assert/Deny that subject's key can be used for verifying a signature on certificate revocation list (e.g., a CRL, delta CRL, or an ARL)."	bits bitAt: 7 put: aBoolean</body><body package="X509" selector="dataEncipherment">dataEncipherment"Assert/Deny that subject's key is used for enciphering user data, other than cryptographic keys."	^bits bitAt: 4</body><body package="X509" selector="dataEncipherment:">dataEncipherment: aBoolean"Assert/Deny that subject's key is used for enciphering user data, other than cryptographic keys."	bits bitAt: 4 put: aBoolean</body><body package="X509" selector="decipherOnly">decipherOnly"Assert/Deny that subject's key may be used only for deciphering data while performing key agreement (keyAgreement must be true)."	^bits bitAt: 9</body><body package="X509" selector="decipherOnly:">decipherOnly: aBoolean"Assert/Deny that subject's key may be used only for deciphering data while performing key agreement (keyAgreement must be true).RFC#3279 (section 2.3.3  Diffie-Hellman Key Exchange Keys): If the keyUsage extension is present in a certificate which conveys a DH public key, the following values may be present:      keyAgreement;      encipherOnly; and      decipherOnly.If present, the keyUsage extension MUST assert keyAgreement and MAY assert either encipherOnly and decipherOnly.  The keyUsage extension MUST NOT assert both encipherOnly and decipherOnly."	aBoolean ifTrue: [		self setKeyAgreement.		self encipherOnly: false ].	bits bitAt: 9 put: aBoolean</body><body package="X509" selector="denyAll">denyAll	bits clearAllBits</body><body package="X509" selector="digitalSignature">digitalSignature"Assert/Deny that subject's key can be used for signing anything but certificates and CRLs."	^bits bitAt: 1</body><body package="X509" selector="digitalSignature:">digitalSignature: aBoolean"Assert/Deny that subject's key can be used for signing anything but certificates and CRLs."	bits bitAt: 1 put: aBoolean</body><body package="X509" selector="encipherOnly">encipherOnly"Assert/Deny that subject's key may be used only for enciphering data while performing key agreement (keyAgreement must be true)."	^bits bitAt: 8</body><body package="X509" selector="encipherOnly:">encipherOnly: aBoolean"Assert/Deny that subject's key may be used only for enciphering data while performing key agreement (keyAgreement must be true).RFC#3279 (section 2.3.3  Diffie-Hellman Key Exchange Keys): If the keyUsage extension is present in a certificate which conveys a DH public key, the following values may be present:      keyAgreement;      encipherOnly; and      decipherOnly.If present, the keyUsage extension MUST assert keyAgreement and MAY assert either encipherOnly and decipherOnly.  The keyUsage extension MUST NOT assert both encipherOnly and decipherOnly."	aBoolean ifTrue: [		self setKeyAgreement.		self decipherOnly: false ].	bits bitAt: 8 put: aBoolean.</body><body package="X509" selector="keyAgreement">keyAgreement"Assert/Deny that the subject's key can be used for key agreement (e.g. Diffie-Hellman)."	^bits bitAt: 5</body><body package="X509" selector="keyAgreement:">keyAgreement: aBoolean"Assert/Deny that the subject's key can be used for key agreement (e.g. Diffie-Hellman).RFC#3279 (section 2.3.3  Diffie-Hellman Key Exchange Keys): If the keyUsage extension is present in a certificate which conveys a DH public key, the following values may be present:      keyAgreement;      encipherOnly; and      decipherOnly.If present, the keyUsage extension MUST assert keyAgreement and MAY assert either encipherOnly and decipherOnly.  The keyUsage extension MUST NOT assert both encipherOnly and decipherOnly."	bits bitAt: 5 put: aBoolean.	self clearEncipherDecipherOnly</body><body package="X509" selector="keyCertSign">keyCertSign"Assert/Deny that subject's key can be used for verifying a signature on public key certificates."	^bits bitAt: 6</body><body package="X509" selector="keyCertSign:">keyCertSign: aBoolean"Assert/Deny that subject's key can be used for verifying a signature on public key certificates."	bits bitAt: 6 put: aBoolean</body><body package="X509" selector="keyEncipherment">keyEncipherment"Assert/Deny that the subject's key can be used for key transport"	^bits bitAt: 3</body><body package="X509" selector="keyEncipherment:">keyEncipherment: aBoolean"Assert/Deny that the subject's key can be used for key transport"	bits bitAt: 3 put: aBoolean</body><body package="X509" selector="nonRepudiation">nonRepudiation"Assert/Deny that the subject's key can be used for non-repudiation signatures, excluding certificate or CRL signing."	^bits bitAt: 2</body><body package="X509" selector="nonRepudiation:">nonRepudiation: aBoolean"Assert/Deny that the subject's key can be used for non-repudiation signatures, excluding certificate or CRL signing."	bits bitAt: 2 put: aBoolean</body></methods><methods><class-id>Security.X509.KeyUsage</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	super initialize.	self initialize: ( BitString unused: 7 bytes: (ByteArray new: 2) )</body><body package="X509" selector="initialize:">initialize: aBitString	bits := aBitString</body></methods><methods><class-id>Security.X509.KeyUsage</class-id> <category>testing</category><body package="X509" selector="isHandled">isHandled	^true</body><body package="X509" selector="isKeyUsage">isKeyUsage	^true</body><body package="X509" selector="shouldBeCritical">shouldBeCritical	^true</body></methods><methods><class-id>Security.X509.KeyUsage</class-id> <category>private</category><body package="X509" selector="clearEncipherDecipherOnly">clearEncipherDecipherOnly	bits	bitAt: 8 put: false;		bitAt: 9 put: false</body><body package="X509" selector="setKeyAgreement">setKeyAgreement	bits bitAt: 5 put: true</body></methods><methods><class-id>Security.X509.KeyUsage</class-id> <category>marshaling</category><body package="X509" selector="asn1Value">asn1Value	^self bits</body></methods><methods><class-id>Security.X509.KeyUsage</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the extension in the format used by OpenSSL"	| set titles |	aStream cr; tab: level;		nextPutAll: (#KeyUsagePrefix &lt;&lt; #security &gt;&gt; 'X509v3 Key Usage:') asString.	critical ifTrue: [aStream nextPutAll: (#CriticalSuffix &lt;&lt; #security &gt;&gt; ' critical') asString ].	titles := 		#(	'Digital Signature'			'Non Repudiation'			'Key Encipherment'			'Encryption'			'Key Agreement'			'Certificate Sign'			'CRL Sign'			'Encipher Only'			'Decipher Only').	set := (1 to: 9) select: [ :i | bits bitAt: i ].	aStream cr; tab: level + 1.	set	do: [ :i | aStream nextPutAll: (titles at: i) ]		separatedBy: [ aStream nextPutAll: ', ' ]</body></methods><methods><class-id>Security.X509.KeyUsage class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"      KeyUsage ::= BIT STRING {           digitalSignature        (0),           nonRepudiation          (1),           keyEncipherment         (2),           dataEncipherment        (3),           keyAgreement            (4),           keyCertSign             (5),           cRLSign                 (6),           encipherOnly            (7),           decipherOnly            (8) }"	ASN1Module BIT_STRING: #KeyUsage</body></methods><methods><class-id>Security.X509.KeyUsage class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName"Answer the ASN.1 type for the extension value."	^#KeyUsage</body></methods><methods><class-id>Security.X509.KeyUsage class</class-id> <category>private</category><body package="X509" selector="adoptValue:">adoptValue: aBitString	^self new initialize: aBitString</body><body package="X509" selector="oidString">oidString	^'2.5.29.15'</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - key usage</category><body package="X509" selector="forCertificateSigning">forCertificateSigning"Mark the certificate as suitable for signing other certificates."	self forCertificateSigning: nil</body><body package="X509" selector="forCertificateSigning:">forCertificateSigning: depth"Mark the certificate as suitable for signing other certificates.	depth &lt;Integer&gt; what is the maximum length of valid certificate chain with this certificate as root"	self getEmptyKeyUsage keyCertSign: true.	self getBasicConstraints		ca: true;		depth: depth</body><body package="X509" selector="forCRLSigning">forCRLSigning"Mark the certificate as suitable for signing CRLs."	self getEmptyKeyUsage crlSign: true.</body><body package="X509" selector="forEncryption">forEncryption"Mark this certificate as suitable for encryption of data."	self subjectPublicKeyInfo publicKey assertEncryptionIn: self</body><body package="X509" selector="forKeyExchange">forKeyExchange"Mark this certificate as suitable for key exchange or key agreement depending on the key algorithm"	self subjectPublicKeyInfo publicKey assertKeyExchangeIn: self</body><body package="X509" selector="forSigning">forSigning"Mark this certificate as suitable for signing anything except certificates and CRLs"	self subjectPublicKeyInfo publicKey assertSigningIn: self</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - extensions - key usage</category><body package="X509" selector="getEmptyKeyUsage">getEmptyKeyUsage	^(self getExtension: KeyUsage)		denyAll;		yourself</body><body package="X509" selector="hasKeyUsage">hasKeyUsage	^self keyUsage notNil</body><body package="X509" selector="isCrlSign">isCrlSign	^self keyUsage ifNil: [false] ifNotNil: [ :ku | ku crlSign ]</body><body package="X509" selector="isDataEncipherment">isDataEncipherment	^self keyUsage ifNil: [false] ifNotNil: [ :ku | ku dataEncipherment ]</body><body package="X509" selector="isDecipherOnly">isDecipherOnly	^self keyUsage ifNil: [ false ] ifNotNil: [ :ku | ku decipherOnly ]</body><body package="X509" selector="isDigitalSignature">isDigitalSignature	^self keyUsage ifNil: [ false ] ifNotNil: [ :ku | ku digitalSignature ]</body><body package="X509" selector="isEncipherOnly">isEncipherOnly	^self keyUsage ifNil: [ false ] ifNotNil: [ :ku | ku encipherOnly ]</body><body package="X509" selector="isKeyAgreement">isKeyAgreement	^self keyUsage ifNil: [ false ] ifNotNil: [ :ku | ku keyAgreement ]</body><body package="X509" selector="isKeyCertSign">isKeyCertSign	^self keyUsage ifNil: [ false ] ifNotNil: [ :ku | ku keyCertSign ]</body><body package="X509" selector="isKeyEncipherment">isKeyEncipherment	^self keyUsage ifNil: [ false ] ifNotNil: [ :ku | ku keyEncipherment ]</body><body package="X509" selector="isNonRepudiation">isNonRepudiation	^self keyUsage ifNil: [ false ] ifNotNil: [ :ku | ku nonRepudiation ]</body><body package="X509" selector="keyUsage">keyUsage	^self extension: [ :ext | ext isKeyUsage ] ifAbsent: [nil]</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - extensions</category><body package="X509" selector="addExtension:">addExtension: anExtension	self supportsExtensions ifFalse: [ ^NoExtensionSupport raiseWith: self ].	^self extensions add: anExtension</body><body package="X509" selector="criticalExtensions">criticalExtensions	^self extensions select:[:ea | ea isCritical]</body><body package="X509" selector="extension:ifAbsent:">extension: detectionBlock ifAbsent: notFoundBlock	^self extensions detect: detectionBlock ifNone: notFoundBlock</body><body package="X509" selector="extensions">extensions	^extensions ifNil: [		self supportsExtensions			ifTrue: [ extensions := OrderedCollection new ]			ifFalse: [ #() ] ]</body><body package="X509" selector="getExtension:">getExtension: extensionClass"Find or create an extension of specified class."	^self extension: [ :ext | ext class = extensionClass ]		ifAbsent: [ self addExtension: extensionClass new ]</body><body package="X509" selector="hasExtensions">hasExtensions	^self extensions notEmpty</body><body package="X509" selector="supportsExtensions">supportsExtensions	^self versionName &gt; 2</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing</category><body package="X509" selector="serialNumber">serialNumber	"serial number of this certificate"	^serialNumber</body><body package="X509" selector="signatureAlgorithm">signatureAlgorithm	^signature</body><body package="X509" selector="signatureAlgorithm:">signatureAlgorithm: anAlgorithmIdentifier	signature := anAlgorithmIdentifier.	self encoding: nil.</body><body package="X509" selector="signatureAlgorithmOID">signatureAlgorithmOID	"OID of the algorithm used to sign this certificate"	^signature getOID</body><body package="X509" selector="signatureAlgorithmOIDDescription">signatureAlgorithmOIDDescription	"description of the OID of the algorithm used to sign this certificate"	^signature getOIDDescription</body><body package="X509" selector="versionName">versionName	^version ifNil: [ version := 3 ]</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - subject</category><body package="X509" selector="subject">subject	^subject</body><body package="X509" selector="subjectDN">subjectDN	"distinguished name of the subject"	^subject getRDN</body><body package="X509" selector="subjectDNInBytes">subjectDNInBytes	"distinguished name of the subject"	^subject getDNBytes</body><body package="X509" selector="subjectUniqueID">subjectUniqueID	^subjectUniqueID</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - validity</category><body package="X509" selector="isExpired">isExpired	^validity isExpired</body><body package="X509" selector="isNotValidYet">isNotValidYet	^validity isNotValidYet</body><body package="X509" selector="isValid">isValid	^validity isValid</body><body package="X509" selector="isValidOn:">isValidOn: time	^validity isValidOn: time</body><body package="X509" selector="notAfter">notAfter	^validity notAfterTimestamp</body><body package="X509" selector="notAfter:">notAfter: aTimestamp	self validity notAfterTimestamp: aTimestamp asTimestamp.	self encoding: nil</body><body package="X509" selector="notAfterDate">notAfterDate	"instance of Date containing the date component of notAfter"	^validity notAfterDate</body><body package="X509" selector="notAfterTime">notAfterTime	"instance of Time containing the time component of notAfter"	^validity notAfterTime</body><body package="X509" selector="notBefore">notBefore	^validity notBeforeTimestamp</body><body package="X509" selector="notBefore:">notBefore: aTimestamp	self validity notBeforeTimestamp: aTimestamp asTimestamp.	self encoding: nil</body><body package="X509" selector="notBeforeDate">notBeforeDate	"instance of Date containing the date component of notBefore"	^validity notBeforeDate</body><body package="X509" selector="notBeforeTime">notBeforeTime	"instance of Time containing the time component of notBefore"	^validity notBeforeTime</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>marshaling</category><body package="X509" selector="encoding:">encoding: anEncoding	encoding := anEncoding</body><body package="X509" selector="extensions:">extensions: aCollection	extensions := aCollection</body><body package="X509" selector="issuer:">issuer: aName"The ASN.1 framework can only map SEQUENCE and SET to Smalltalk class so far, so this just works around the limitation."	issuer := aName asX509Name</body><body package="X509" selector="issuerUniqueID:">issuerUniqueID: aBitString	issuerUniqueID := aBitString</body><body package="X509" selector="serialNumber:">serialNumber: anInteger	serialNumber := anInteger</body><body package="X509" selector="signature">signature	^signature</body><body package="X509" selector="signature:">signature: anAlgorithmIdentifier	signature := anAlgorithmIdentifier</body><body package="X509" selector="subject:">subject: aName"The ASN.1 framework can only map SEQUENCE and SET to Smalltalk class so far, so this just works around the limitation."	subject := aName asX509Name</body><body package="X509" selector="subjectPublicKeyInfo:">subjectPublicKeyInfo: aKeyInfo	subjectPublicKeyInfo := aKeyInfo</body><body package="X509" selector="subjectUniqueID:">subjectUniqueID: aBitString	subjectUniqueID := aBitString</body><body package="X509" selector="validity">validity	^validity ifNil: [ validity := Validity new ]</body><body package="X509" selector="validity:">validity: aValidity	validity := aValidity</body><body package="X509" selector="version">version	^self versionName - 1</body><body package="X509" selector="version:">version: anInteger	version := anInteger + 1</body><body package="X509" selector="_encoding">_encoding	^encoding</body><body package="X509" selector="_encoding:type:">_encoding: anEncoding type: aType	encoding := anEncoding</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - key</category><body package="X509" selector="publicKey">publicKey	^self subjectPublicKeyInfo getPublicKey</body><body package="X509" selector="publicKey:">publicKey: aPublicKey	self encoding: nil.	self subjectPublicKeyInfo publicKey: aPublicKey.	self supportsExtensions ifTrue: [		self subjectPublicKeyInfo publicKey assertDefaultUsageIn: self ]</body><body package="X509" selector="subjectPublicKeyInfo">subjectPublicKeyInfo	"subject's public key info"	^subjectPublicKeyInfo ifNil: [ subjectPublicKeyInfo := SubjectPublicKeyInfo new ]</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - issuer</category><body package="X509" selector="issuer">issuer	^issuer</body><body package="X509" selector="issuerDN">issuerDN	"distinguished name of the issuer"	^issuer getRDN</body><body package="X509" selector="issuerDNInBytes">issuerDNInBytes	"distinguished name of the issuer"	^issuer getDNBytes</body><body package="X509" selector="issuerUniqueID">issuerUniqueID	^issuerUniqueID</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>utilities</category><body package="X509" selector="flushEncoding">flushEncoding	self encoding: nil.	issuer flushEncoding.	subject flushEncoding.</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - internals</category><body package="X509" selector="derCertificate">derCertificate	^self getEncoding fullEncoding</body><body package="X509" selector="encoding">encoding	^encoding</body><body package="X509" selector="getEncoding">getEncoding	^encoding ifNil: [ | marshaler |		marshaler := DERStream on: (ByteArray new: 100).		marshaler marshalObject: self withType: self asn1Type.		encoding := Encoding with: marshaler contents ]</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>accessing - extensions - basic constraints</category><body package="X509" selector="basicConstraints">basicConstraints 	^self extension: [ :ext | ext isBasicConstraints ] ifAbsent: [nil]</body><body package="X509" selector="getBasicConstraints">getBasicConstraints 	^self getExtension: BasicConstraints</body><body package="X509" selector="hasBasicConstraints">hasBasicConstraints	^self basicConstraints notNil</body><body package="X509" selector="isCACertificate">isCACertificate	^self basicConstraints		ifNil: [ false ]		ifNotNil: [ :bc | bc ca ]</body></methods><methods><class-id>Security.X509.TBSCertificate</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the certificate in the format used by OpenSSL"	aStream		tab: level; nextPutAll: (#VersionPrefix &lt;&lt; #security &gt;&gt; 'Version: ') asString; print: self versionName;			nextPutAll: ' (0x'; print: self version; nextPut: $); cr;		tab: level; nextPutAll: (#SerialNumberPrefix &lt;&lt; #security &gt;&gt; 'Serial Number: ') asString; cr.	serialNumber asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 50.	aStream        	tab: level; nextPutAll: (#SignatureAlgorithmPrefix &lt;&lt; #security &gt;&gt; 'Signature Algorithm: ') asString;		nextPutAll: signature getOIDDescription; cr;		tab: level; nextPutAll: (#IssuerPrefix &lt;&lt; #security &gt;&gt; 'Issuer: ') asString.	issuer printOpenSSLOn: aStream indent: 0.	aStream cr; tab: level; nextPutAll: (#ValidityPrefix &lt;&lt; #security &gt;&gt; 'Validity') asString; cr.	validity printOpenSSLOn: aStream indent: level + 1.	aStream cr; tab: level; nextPutAll: (#SubjectPrefix &lt;&lt; #security &gt;&gt; 'Subject: ') asString.	subject printOpenSSLOn: aStream indent: 0.	aStream cr; tab: level; nextPutAll: (#SubjectKeyInfoPrefix &lt;&lt; #security &gt;&gt; 'Subject Public Key Info:') asString; cr.	subjectPublicKeyInfo printOpenSSLOn: aStream indent: level + 1.		"key"	(extensions isNil or: [extensions isEmpty]) ifFalse: [		aStream tab: level; nextPutAll: (#X509ExtensionsPrefix &lt;&lt; #security &gt;&gt; 'X509v3 extensions:') asString.		extensions do: [ :ext |			ext printOpenSSLOn: aStream indent: level + 1 ] ]</body></methods><methods><class-id>Security.X509.TBSCertificate class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#TBSCertificate</body></methods><methods><class-id>Security.X509.TBSCertificate class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	TBSCertificate  ::=  SEQUENCE  {		version         [0]  EXPLICIT Version DEFAULT v1,		serialNumber         CertificateSerialNumber,		signature            AlgorithmIdentifier,		issuer               Name,		validity             Validity,		subject              Name,		subjectPublicKeyInfo SubjectPublicKeyInfo,		issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,                             -- If present, version MUST be v2 or v3		subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,                             -- If present, version MUST be v2 or v3		extensions      [3]  EXPLICIT Extensions OPTIONAL                             -- If present, version MUST be v3        }"	( ASN1Module SEQUENCE: self asn1TypeName )		addElement: #version type: #Version tag: 0 tagging: #explicit default: 0;		addElement: #serialNumber type: #CertificateSerialNumber;		addElement: #signature type: #AlgorithmIdentifier;		addElement: #issuer type: #Name;		addElement: #validity type: #Validity;		addElement: #subject type: #Name;		addElement: #subjectPublicKeyInfo type: #SubjectPublicKeyInfo;		addOptionalElement: #issuerUniqueID type: #UniqueIdentifier tag: 1 tagging: #implicit;		addOptionalElement: #subjectUniqueID type: #UniqueIdentifier tag: 2 tagging: #implicit;		addOptionalElement: #extensions type: #Extensions tag: 3 tagging: #explicit;		mapping: self;		retainEncoding: true."	Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }"	( ASN1Module INTEGER: #Version )		identifiers: ( Array with: #v1 -&gt; 0 with: #v2 -&gt; 1 with: #v3 -&gt; 2 )."	CertificateSerialNumber  ::=  INTEGER"	ASN1Module INTEGER: #CertificateSerialNumber."	UniqueIdentifier  ::=  BIT STRING"	ASN1Module BIT_STRING: #UniqueIdentifier."	Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension"	( ASN1Module SEQUENCE: #Extensions OF: #Extension )		constraint: ( SizeConstraint lower: 1 upper: SmallInteger maxVal ).</body></methods><methods><class-id>Security.X509.CertificateFileReader</class-id> <category>api</category><body package="X509" selector="readFrom:">readFrom: aStream"Read certificates and private keys from PEM formatted stream. Raises proceedable X509Warnings on read errors.	^&lt;OrderedCollection of: (X509Certificate | X509PrivateKey)&gt;"	| things | 	things := OrderedCollection new.	[ aStream atEnd ] whileFalse: [ | mark chunk |		aStream skipThroughAll: '-----BEGIN '.		aStream atEnd ifTrue: [^things].		mark := aStream throughAll: '-----'.		chunk := aStream upToAll: '-----END ', mark.		aStream throughAll: '-----END ', mark.		(('*private*key*' match: mark)			ifTrue: [ self readKey: mark from: chunk. ]			ifFalse: [ ('*certificate*' match: mark)					ifTrue: [ self readCertificate: mark from: chunk ]					ifFalse: [ X509Warning new							messageText: (								(#UnknownPEMEntity1s &lt;&lt; #security &gt;&gt; 'Unknown PEM entity &lt;1s&gt;')									expandMacrosWith: mark);							parameter: chunk;							raise.						nil ] ]		) ifNotNil: [ :thing |			things add: thing ] ].	^things</body></methods><methods><class-id>Security.X509.CertificateFileReader</class-id> <category>private</category><body package="X509" selector="readCertificate:from:">readCertificate: mark from: chunk	^[	Certificate fromBase64: chunk	] on: Error do: [ :ex |		X509Warning new			messageText: (				(#CertReadError1s &lt;&lt; #security &gt;&gt; 'Error reading certificate &lt;1s&gt;')					expandMacrosWith: mark);			parameter: chunk;			raise.		nil ]</body><body package="X509" selector="readKey:from:">readKey: mark from: chunk	^[	(X509PrivateKey keyClassForPEM: mark)			ifNil: [ X509Warning new					messageText: (						(#UnknownKey1s &lt;&lt; #security &gt;&gt; 'Unknown private key &lt;1s&gt;')							expandMacrosWith: mark);					parameter: chunk;					raise.				nil ]			ifNotNil: [ :class |				class fromBase64: chunk ]	] on: Error do: [ :ex |		X509Warning new			messageText: (				(#KeyReadError1s &lt;&lt; #security &gt;&gt; 'Error reading private key &lt;1s&gt;')					expandMacrosWith: mark);			parameter: chunk;			raise.		nil ]</body></methods><methods><class-id>Security.X509.CertificateFileReader class</class-id> <category>deprecated</category><body package="X509" selector="readCertificatesFrom:">readCertificatesFrom: aFilename"self readCertificatesFrom: 'd:\encryptionCommon\demo.pem'"	^self readFromFile: aFilename</body></methods><methods><class-id>Security.X509.CertificateFileReader class</class-id> <category>utilities</category><body package="X509" selector="readFromFile:">readFromFile: aFilename"Read certificates and private keys from PEM formatted file	self readFromFile: 'ca-bundle.crt'"	| stream |	stream := aFilename asFilename readStream .	^[	self new readFrom: stream	] ensure: [ stream close ]</body></methods><methods><class-id>Security.X509.X509PrivateKey</class-id> <category>accessing</category><body package="X509" selector="getKey">getKey	^self subclassResponsibility</body></methods><methods><class-id>Security.X509.X509PrivateKey</class-id> <category>converting</category><body package="X509" selector="asKey">asKey"Convert the X509 structure into an actual algorithm key"	^self getKey</body></methods><methods><class-id>Security.X509.X509PrivateKey class</class-id> <category>utilities</category><body package="X509" selector="canReadPEM:">canReadPEM: mark	^false</body><body package="X509" selector="keyClassForPEM:">keyClassForPEM: mark	^self subclasses detect: [ :c | c canReadPEM: mark ] ifNone: [ nil ]</body></methods><methods><class-id>Security.X509.X509PrivateKey class</class-id> <category>private</category><body package="X509" selector="getPrivateKeyDataFrom:">getPrivateKeyDataFrom: aPEMString"Answers the Base64 encoded Private Key if aPEMString has the appropriate delimiters required for PEM format; otherwise, answers nil"	| stream mark chunk |	stream := aPEMString readStream.	stream skipThroughAll: '-----BEGIN '.	stream atEnd ifTrue: [^nil].	mark := stream throughAll: '-----'.	(self canReadPEM: mark) ifFalse: [^nil].	chunk := stream upToAll: '-----END ', mark.	^chunk</body></methods><methods><class-id>Security.X509.X509PrivateKey class</class-id> <category>instance creation</category><body package="X509" selector="fromBase64:">fromBase64: aString	^self fromBytes: (self decodeBase64: (self stripWhitespace: aString))</body><body package="X509" selector="fromBytes:">fromBytes: bytes	| stream |	stream := DERStream with: bytes.	stream reset.	^stream unmarshalObjectType: self asn1Type</body><body package="X509" selector="fromString:">fromString: aString	| s |	s := self getPrivateKeyDataFrom: aString.	s isNil ifTrue: [^nil].	^self fromBase64: s</body></methods><methods><class-id>Security.X509.X509PublicKey</class-id> <category>private</category><body package="X509" selector="assertDefaultUsageIn:">assertDefaultUsageIn: aTBSCertificate	aTBSCertificate forSigning</body><body package="X509" selector="assertEncryptionIn:">assertEncryptionIn: aTBSCertificate"Mark this certificate as suitable for encryption of data."	X509Error new		messageText: #X509KeyNotForEncryption &lt;&lt; #security &gt;&gt; 'The key is not suitable for encryption!';		parameter: aTBSCertificate;		raise</body><body package="X509" selector="assertKeyExchangeIn:">assertKeyExchangeIn: aTBSCertificate"Mark this certificate as suitable for key exchange or key agreement depending on the key algorithm"	X509Error new		messageText: #X509KeyNotForKeyExchange &lt;&lt; #security &gt;&gt; 'The key is not suitable for key exchange!';		parameter: aTBSCertificate;		raise</body><body package="X509" selector="assertSigningIn:">assertSigningIn: aTBSCertificate"Mark this certificate as suitable for signing anything except certificates and CRLs"	aTBSCertificate getEmptyKeyUsage digitalSignature: true</body></methods><methods><class-id>Security.X509.X509PublicKey</class-id> <category>accessing</category><body package="X509" selector="algorithmOID">algorithmOID	^self class algorithmOID</body><body package="X509" selector="algorithmParameters">algorithmParameters"AlgorithmIdentifier parameters for this key"	^nil</body><body package="X509" selector="getKey">getKey	^self subclassResponsibility</body></methods><methods><class-id>Security.X509.X509PublicKey</class-id> <category>converting</category><body package="X509" selector="asKey">asKey"Convert the X509 structure into an actual algorithm key"	^self getKey</body></methods><methods><class-id>Security.X509.X509PublicKey class</class-id> <category>accessing</category><body package="X509" selector="algorithmOID">algorithmOID	^algorithmOID ifNil: [ algorithmOID := ObjectIdentifier value: self algorithmOIDArray ]</body><body package="X509" selector="algorithmOIDArray">algorithmOIDArray"Algorithm specific OID value as prescribed by RFC#3279, section 2.3  Subject Public Key Algorithms"	^self subclassResponsibility</body><body package="X509" selector="keyClassFor:">keyClassFor: anAlgorithmIdentifier	^self allSubclasses		detect: [ :class | anAlgorithmIdentifier algorithm = class algorithmOID ]		ifNone: [ nil ]</body></methods><methods><class-id>Security.X509.X509PublicKey class</class-id> <category>marshaling</category><body package="X509" selector="adoptValue:">adoptValue: value"Some keys are simple types that the ASN.1 framework can't map to class automatically, so we need to work around that here."	"by default the key is mappable so there's nothing that needs to be done; just return the value"	^value</body></methods><methods><class-id>Security.X509.X509DSAPublicKey</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key in the format used by OpenSSL"	aStream		tab: level; nextPutAll: (#DSAPubKeyPrefix &lt;&lt; #security &gt;&gt; 'DSA Public Key:') asString; cr;		tab: level + 1; nextPutAll: (#pubPrefix &lt;&lt; #security &gt;&gt; 'pub:') asString; cr.	publicKey asBigEndianByteArray printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream		tab: level + 1; nextPutAll: (#PPrefix &lt;&lt; #security &gt;&gt; 'P:') asString; cr.	dssParameters p asBigEndianByteArray printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream		tab: level + 1; nextPutAll: (#QPrefix &lt;&lt; #security &gt;&gt; 'Q:') asString; cr.	dssParameters q asBigEndianByteArray printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream		tab: level + 1; nextPutAll: (#GPrefix &lt;&lt; #security &gt;&gt; 'G:') asString; cr.	dssParameters g asBigEndianByteArray printOpenSSLOn: aStream indent: level + 2 width: 15.</body></methods><methods><class-id>Security.X509.X509DSAPublicKey</class-id> <category>accessing</category><body package="X509" selector="dssParameters">dssParameters	^dssParameters</body><body package="X509" selector="dssParameters:">dssParameters: anObject	dssParameters := anObject</body><body package="X509" selector="getKey">getKey	^dssParameters notNil		ifTrue:[ DSAPublicKey 				p: dssParameters p				q: dssParameters q				g: dssParameters g				y: publicKey ]		ifFalse:[ DSAPublicKey				p: nil				q: nil				g: nil				y: publicKey  ]</body><body package="X509" selector="publicKey">publicKey	^publicKey</body><body package="X509" selector="publicKey:">publicKey: anInteger	publicKey := anInteger</body></methods><methods><class-id>Security.X509.X509DSAPublicKey</class-id> <category>marshaling</category><body package="X509" selector="algorithmParameters">algorithmParameters"AlgorithmIdentifier parameters for this key"	^self dssParameters ifNotNil: [ :params |		OrderedCollection			with: params p			with: params q			with: params g ]</body><body package="X509" selector="algorithmParameters:">algorithmParameters: anOrderedCollection"AlgorithmIdentifier parameters for this key"	^self dssParameters: (		DSSParameters			p: anOrderedCollection first			q: (anOrderedCollection at: 2)			g: anOrderedCollection last)</body><body package="X509" selector="marshalingValue">marshalingValue	^self publicKey</body></methods><methods><class-id>Security.X509.X509DSAPublicKey</class-id> <category>writing</category><body package="X509" selector="writeOn:">writeOn: stream"Encode the receiver on the &lt;stream&gt;.	stream &lt;WriteStream&gt; writable binary stream"	(DERStream wrap: stream) marshalObject: self marshalingValue withType: self asn1Type</body></methods><methods><class-id>Security.X509.X509DSAPublicKey class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	DSAPublicKey ::= INTEGER -- public key, Y"	ASN1Module INTEGER: self asn1TypeName</body></methods><methods><class-id>Security.X509.X509DSAPublicKey class</class-id> <category>accessing</category><body package="X509" selector="algorithmOIDArray">algorithmOIDArray"RFC#3279 (section 2.3.2  DSA Signature Keys): The Digital Signature Algorithm (DSA) is defined in the Digital Signature Standard (DSS) [FIPS 186].  The DSA OID supported by this profile is:      id-dsa OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 1 }"	^#(1 2 840 10040 4 1)</body><body package="X509" selector="asn1TypeName">asn1TypeName	^#X509DSAPublicKey</body></methods><methods><class-id>Security.X509.X509DSAPublicKey class</class-id> <category>marshaling</category><body package="X509" selector="adoptValue:">adoptValue: value"Some keys are simple types that the ASN.1 framework can't map to class automatically, so we need to work around that here."	^self new		publicKey: value;		yourself</body></methods><methods><class-id>Security.X509.X509DSAPublicKey class</class-id> <category>instance creation</category><body package="X509" selector="readFrom:">readFrom: stream"Decode an instance of the receiver from the &lt;stream&gt;.	stream &lt;ReadStream&gt; readable binary stream"	^self adoptValue: (super readFrom: stream)</body></methods><methods><class-id>Security.X509.DSSSignatureValue</class-id> <category>marshaling</category><body package="X509" selector="r:">r: anInteger	r := anInteger</body><body package="X509" selector="s:">s: anInteger	s := anInteger</body></methods><methods><class-id>Security.X509.DSSSignatureValue</class-id> <category>accessing</category><body package="X509" selector="asX509Signature">asX509Signature	^self</body><body package="X509" selector="getSignature">getSignature	^DSASignature r: r  s: s</body><body package="X509" selector="r">r^r</body><body package="X509" selector="s">s^s</body></methods><methods><class-id>Security.X509.DSSSignatureValue class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	Dss-Sig-Value  ::=  SEQUENCE  {                   r       INTEGER,                   s       INTEGER  }"	( ASN1Module SEQUENCE: #DSSSignature)		addElement: #r type: #INTEGER;		addElement: #s type: #INTEGER;		mapping: self</body></methods><methods><class-id>Security.X509.DSSSignatureValue class</class-id> <category>accessing</category><body package="X509" selector="oidCollection">oidCollection	^#()</body></methods><methods><class-id>Security.X509.NoExtensionSupport class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	notifierString := #NoExtensionSupport &lt;&lt; #security &gt;&gt; 'Extensions are not supported in this version of certificates!'</body></methods><methods><class-id>Security.X509.X509Notification</class-id> <category>private - actions</category><body package="X509" selector="defaultAction">defaultAction	"What to do when the exception is unhandled. By default, Notifications can be ignored."		^self defaultResumeValue</body></methods><methods><class-id>Security.X509.ExtensionShouldBeCritical</class-id> <category>accessing</category><body package="X509" selector="extension">extension	^extension</body><body package="X509" selector="extension:">extension: anObject	extension := anObject</body></methods><methods><class-id>Security.X509.AttributeValueAssertion</class-id> <category>marshaling</category><body package="X509" selector="type:">type: anOID	type := anOID</body><body package="X509" selector="value:">value: aString	value := aString</body></methods><methods><class-id>Security.X509.AttributeValueAssertion</class-id> <category>accessing</category><body package="X509" selector="type">type	"Answers the type component of the type/value pair"	^type</body><body package="X509" selector="value">value	"Answers the value component of the type/value pair"	^value</body></methods><methods><class-id>Security.X509.AttributeValueAssertion class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	AttributeType ::= OBJECT IDENTIFIER"	ASN1Module OBJECT_IDENTIFIER: #AttributeType."	AttributeValue ::= ANY DEFINED BY AttributeType"	ASN1Module ANY: #AttributeValue."	AttributeTypeAndValue ::= SEQUENCE {		type     AttributeType,		value    AttributeValue }"	( ASN1Module SEQUENCE: #AttributeTypeAndValue)		addElement: #type type: #AttributeType;		addElement: #value type: #AttributeValue;		mapping: self</body></methods><methods><class-id>Security.X509.X509RSAPublicKey</class-id> <category>marshaling</category><body package="X509" selector="marshalingValue">marshalingValue	^self</body><body package="X509" selector="modulus">modulus	^n</body><body package="X509" selector="modulus:">modulus: anInteger	n := anInteger</body><body package="X509" selector="publicExponent">publicExponent	^e</body><body package="X509" selector="publicExponent:">publicExponent: anInteger	e := anInteger</body><body package="X509" selector="value">value	^self</body></methods><methods><class-id>Security.X509.X509RSAPublicKey</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key in the format used by OpenSSL"	| keySize nArray |	nArray :=  n asBigEndianByteArray.	keySize :=nArray  size * 8.	aStream		tab: level; nextPutAll: (#RSAPubKeyPrefix &lt;&lt; #security &gt;&gt; 'RSA Public Key: (') asString;		print: keySize; nextPutAll: (#BitsSuffix &lt;&lt; #security &gt;&gt; ' bits)') asString; cr;		tab: level + 1; nextPutAll: (#ModulusPrefix &lt;&lt; #security &gt;&gt; 'Modulus (') asString;		print: nArray size * 8; nextPutAll: (#BitSuffix &lt;&lt; #security &gt;&gt; ' bit)') asString; nextPut: $:; cr.	(#[0], nArray) printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream tab: level + 1; nextPutAll: (#ExponentPrefix &lt;&lt; #security &gt;&gt; 'Exponent: ') asString;		print: e ; nextPutAll: ' (0x'.	e  printOn: aStream base: 16.	aStream nextPut: $); cr</body></methods><methods><class-id>Security.X509.X509RSAPublicKey</class-id> <category>accessing</category><body package="X509" selector="e">e	^e</body><body package="X509" selector="getKey">getKey	^RSAPublicKey e: e n: n</body><body package="X509" selector="n">n	^n</body></methods><methods><class-id>Security.X509.X509RSAPublicKey</class-id> <category>private</category><body package="X509" selector="assertEncryptionIn:">assertEncryptionIn: aTBSCertificate"Mark this certificate as suitable for encryption of data."	aTBSCertificate getEmptyKeyUsage dataEncipherment: true</body><body package="X509" selector="assertKeyExchangeIn:">assertKeyExchangeIn: aTBSCertificate"Mark this certificate as suitable for key exchange or key agreement depending on the key algorithm"	aTBSCertificate getEmptyKeyUsage keyEncipherment: true</body></methods><methods><class-id>Security.X509.X509RSAPublicKey class</class-id> <category>accessing</category><body package="X509" selector="algorithmOIDArray">algorithmOIDArray"RFC#3279 (section 2.3.1  RSA Keys): The OID rsaEncryption identifies RSA public keys.      pkcs-1 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }      rsaEncryption OBJECT IDENTIFIER ::=  { pkcs-1 1}"	^#(1 2 840 113549 1 1 1)</body><body package="X509" selector="asn1TypeName">asn1TypeName	^#X509RSAPublicKey</body><body package="X509" selector="keyClass">keyClass	^RSAPublicKey</body></methods><methods><class-id>Security.X509.X509RSAPublicKey class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	RSAPublicKey ::= SEQUENCE {		modulus           INTEGER,  -- n		publicExponent    INTEGER   -- e }"	( ASN1Module SEQUENCE: self asn1TypeName)		addElement: #modulus type: #INTEGER;		addElement: #publicExponent type: #INTEGER;		mapping: self</body></methods><methods><class-id>Security.X509.BasicConstraints</class-id> <category>accessing</category><body package="X509" selector="ca">ca"	^&lt;Boolean&gt; is the subject a certificate issuing authority ?"	^ca</body><body package="X509" selector="ca:">ca: aBoolean"	aBoolean &lt;Boolean&gt; is the subject a certificate issuing authority ?"	ca := aBoolean</body><body package="X509" selector="depth">depth"	^&lt;Integer&gt; maximum depth of valid certification paths that include this certificate"	^depth</body><body package="X509" selector="depth:">depth: anInteger"	anInteger &lt;Integer&gt; maximum depth of valid certification paths that include this certificate"	depth := anInteger</body></methods><methods><class-id>Security.X509.BasicConstraints</class-id> <category>testing</category><body package="X509" selector="isBasicConstraints">isBasicConstraints	^true</body><body package="X509" selector="isHandled">isHandled	^true</body><body package="X509" selector="shouldBeCritical">shouldBeCritical	^true</body></methods><methods><class-id>Security.X509.BasicConstraints</class-id> <category>marshaling</category><body package="X509" selector="cA">cA	^self ca</body><body package="X509" selector="cA:">cA: aBoolean	self ca: aBoolean</body><body package="X509" selector="pathLenConstraint">pathLenConstraint	^self depth</body><body package="X509" selector="pathLenConstraint:">pathLenConstraint: anObject	self depth: anObject</body></methods><methods><class-id>Security.X509.BasicConstraints</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the extension in the format used by OpenSSL"	aStream cr; tab: level;		nextPutAll: (#BasicConstraintsPrefix &lt;&lt; #security &gt;&gt; 'X509v3 Basic Constraints:') asString.	critical ifTrue: [aStream nextPutAll: (#CriticalSuffix &lt;&lt; #security &gt;&gt; ' critical') asString ].	aStream cr; tab: level + 1; nextPutAll: (#CAPrefix &lt;&lt; #security &gt;&gt; 'CA:') asString.	aStream		nextPutAll: (ca				ifTrue: [(#TRUE &lt;&lt; #security &gt;&gt; 'TRUE') asString]				ifFalse: [(#FALSE &lt;&lt; #security &gt;&gt; 'FALSE') asString]);		cr.	depth ifNotNil: [ :len |		aStream tab: level + 1;		nextPutAll: (#pathLenPrefix &lt;&lt; #security &gt;&gt; 'pathLen: ') asString;		print: len; cr ].</body></methods><methods><class-id>Security.X509.BasicConstraints class</class-id> <category>private</category><body package="X509" selector="oidString">oidString	^'2.5.29.19'</body></methods><methods><class-id>Security.X509.BasicConstraints class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName"Answer the ASN.1 type name for the extension value."	^#BasicConstraints</body></methods><methods><class-id>Security.X509.BasicConstraints class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"   BasicConstraints ::= SEQUENCE {        cA                      BOOLEAN DEFAULT FALSE,        pathLenConstraint       INTEGER (0..MAX) OPTIONAL }"	(ASN1Module SEQUENCE: #BasicConstraints)		addElement: #cA type: #BOOLEAN default: false;		addOptionalElement: #pathLenConstraint type: #INTEGER;		mapping: self</body></methods><methods><class-id>Security.X509.X509RSAPrivateKey</class-id> <category>marshaling</category><body package="X509" selector="coefficient">coefficient	^coefficient</body><body package="X509" selector="coefficient:">coefficient: anInteger	coefficient := anInteger</body><body package="X509" selector="exponent1">exponent1	^exponent1</body><body package="X509" selector="exponent1:">exponent1: anInteger	exponent1 := anInteger</body><body package="X509" selector="exponent2">exponent2	^exponent2</body><body package="X509" selector="exponent2:">exponent2: anInteger	exponent2 := anInteger</body><body package="X509" selector="modulus">modulus	^n</body><body package="X509" selector="modulus:">modulus: anInteger	n := anInteger</body><body package="X509" selector="prime1">prime1	^p</body><body package="X509" selector="prime1:">prime1: anInteger	p := anInteger</body><body package="X509" selector="prime2">prime2	^q</body><body package="X509" selector="prime2:">prime2: anInteger	q := anInteger</body><body package="X509" selector="privateExponent">privateExponent	^d</body><body package="X509" selector="privateExponent:">privateExponent: anInteger	d := anInteger</body><body package="X509" selector="publicExponent">publicExponent	^e</body><body package="X509" selector="publicExponent:">publicExponent: anInteger	e := anInteger</body><body package="X509" selector="version">version	^version ifNil: [ 0 ]</body><body package="X509" selector="version:">version: anInteger	version := anInteger</body></methods><methods><class-id>Security.X509.X509RSAPrivateKey</class-id> <category>accessing</category><body package="X509" selector="d">d	^d</body><body package="X509" selector="e">e	^e</body><body package="X509" selector="getKey">getKey	^RSAPrivateKey new		d: d;		n: n;		e: e;		p: p;		q: q;		dp: exponent1;		dq: exponent2;		qInv: coefficient;		yourself</body><body package="X509" selector="n">n	^n</body><body package="X509" selector="p">p	^p</body><body package="X509" selector="q">q	^q</body></methods><methods><class-id>Security.X509.X509RSAPrivateKey</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key in the format used by OpenSSL"	| keySize nArray |	nArray :=  n asBigEndianByteArray.	keySize :=nArray  size * 8.	aStream		tab: level; nextPutAll: (#RSAPrivateKeyPrefix &lt;&lt; #security &gt;&gt; 'RSA Private Key: (') asString;		print: keySize; nextPutAll: (#BitsSuffix &lt;&lt; #security &gt;&gt; ' bits)') asString; cr.	aStream tab: level; nextPutAll: (#modulus &lt;&lt; #security &gt;&gt; 'modulus:') asString; cr.	nArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#publicExponent &lt;&lt; #security &gt;&gt; 'publicExponent: ') asString;		print: e ; nextPutAll: ' (0x'.	e printOn: aStream base: 16.	aStream nextPut: $); cr.	aStream tab: level; nextPutAll: (#privateExponent &lt;&lt; #security &gt;&gt; 'privateExponent:') asString; cr.	d asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#prime1 &lt;&lt; #security &gt;&gt; 'prime1:') asString; cr.	#[0], p asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#prime2 &lt;&lt; #security &gt;&gt; 'prime2:') asString; cr.	#[0], q asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#exponent1 &lt;&lt; #security &gt;&gt; 'exponent1:') asString; cr.	exponent1 asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#exponent2 &lt;&lt; #security &gt;&gt; 'exponent2:') asString; cr.	exponent2 asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream	tab: level; nextPutAll: (#coefficient &lt;&lt; #security &gt;&gt; 'coefficient:') asString; cr.	coefficient abs asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.</body></methods><methods><class-id>Security.X509.X509RSAPrivateKey class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types" See the man page for the rsa command in the openssl suite, option -inform	RSAPrivateKey ::= SEQUENCE {		version Version,		modulus INTEGER, -- n		publicExponent INTEGER, -- e		privateExponent INTEGER, -- d		prime1 INTEGER, -- p		prime2 INTEGER, -- q		exponent1 INTEGER, -- d mod (p-1)		exponent2 INTEGER, -- d mod (q-1)		coefficient INTEGER -- (inverse of q) mod p }	Version ::= INTEGER"	( ASN1Module SEQUENCE: self asn1TypeName )		addElement: #version type: #INTEGER;		addElement: #modulus type: #INTEGER;		addElement: #publicExponent type: #INTEGER;		addElement: #privateExponent type: #INTEGER;		addElement: #prime1 type: #INTEGER;		addElement: #prime2 type: #INTEGER;		addElement: #exponent1 type: #INTEGER;		addElement: #exponent2 type: #INTEGER;		addElement: #coefficient type: #INTEGER;		mapping: self</body></methods><methods><class-id>Security.X509.X509RSAPrivateKey class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#X509RSAPrivateKey</body><body package="X509" selector="keyClass">keyClass	^RSAPrivateKey</body></methods><methods><class-id>Security.X509.X509RSAPrivateKey class</class-id> <category>utilities</category><body package="X509" selector="canReadPEM:">canReadPEM: mark	^'*rsa*private*key*' match: mark</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier</class-id> <category>accessing</category><body package="X509" selector="getOID">getOID	"Answers the OID for this algorithm"	^oid</body><body package="X509" selector="getOIDDescription">getOIDDescription	"Answers the OID description for this algorithm"	^oidDescription</body><body package="X509" selector="getOIDSymbol">getOIDSymbol	"Answers object identifier asSymbol"	^oid getOIDSymbol</body><body package="X509" selector="getOLDOIDSymbol">getOLDOIDSymbol	"Answers object identifier asSymbol"	| oidString ix |	oidString := oid copy.	oidString := 'x' , self getOID.	ix := 1.	[ix &lt; oidString size]		whileTrue: 			[(oidString at: ix)				= $. ifTrue: [oidString at: ix put: $x].			ix := ix + 1].^oidString asSymbol</body><body package="X509" selector="parameters">parameters	^parameters</body><body package="X509" selector="parameters:">parameters: anOrderedCollection	parameters := anOrderedCollection</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier</class-id> <category>accessing-algorithms</category><body package="X509" selector="dsa_with_sha1">dsa_with_sha1	^self id_dsa_with_sha1</body><body package="X509" selector="getAlgorithm">getAlgorithm	| selector |	selector := oid leafSymbol.	(selector includes: $-) ifTrue: [		selector := (selector asString replaceAll: $- with: $_) asSymbol ].	^(self respondsTo: selector)		ifTrue: [ self perform: selector ]		ifFalse: [ nil ]</body><body package="X509" selector="id_dsa_with_sha1">id_dsa_with_sha1	^DSA new</body><body package="X509" selector="md5WithRSAEncryption">md5WithRSAEncryption	^RSA new		useMD5;		yourself</body><body package="X509" selector="sha1WithRSAEncryption">sha1WithRSAEncryption	^self sha_1WithRSAEncryption</body><body package="X509" selector="sha1_with_rsa_signature">sha1_with_rsa_signature	^self sha_1WithRSAEncryption</body><body package="X509" selector="sha_1WithRSAEncryption">sha_1WithRSAEncryption	^RSA new		useSHA;		yourself</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier</class-id> <category>services</category><body package="X509" selector="verify:isSignedBy:">verify: aSubjectCertificate isSignedBy: anIssuerCertificate	| algorithm |	(algorithm := self getAlgorithm) ifNil: [		Unsupported new			messageText: (#UnsupportedSigAlg &lt;&lt; #security &gt;&gt; 'Signature algorithm is not supported!');			parameter: aSubjectCertificate;			isResumable: true;			raiseSignal.		^false ].	anIssuerCertificate subjectPublicKeyAlgorithmOID = algorithm x509AlgorithmOID ifFalse: [		InvalidSignature new			messageText: (#IssuerSigAlgMismatch &lt;&lt; #security &gt;&gt; 'Public key of the issuer does not match the signature algorithm!');			parameter: (Array with: aSubjectCertificate with: anIssuerCertificate);			isResumable: true;			raiseSignal.		^false ].	^algorithm		publicKey: anIssuerCertificate publicKey;		verify: aSubjectCertificate getSignature		of: aSubjectCertificate tbsDerCertificate</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier</class-id> <category>marshaling</category><body package="X509" selector="algorithm">algorithm	^oid</body><body package="X509" selector="algorithm:">algorithm: anOID	oid := anOID.	oidDescription := oid getShortOIDDescription.</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier</class-id> <category>testing</category><body package="X509" selector="isDSA">isDSA	^oid = self class id_dsa_with_sha1OID</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#AlgorithmIdentifier</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier class</class-id> <category>instance creation</category><body package="X509" selector="id_dsa_with_sha1">id_dsa_with_sha1"RFC 3279 (section 2.2.2  DSA Signature Algorithm): The Digital Signature Algorithm (DSA) is defined in the Digital Signature Standard (DSS).  DSA was developed by the U.S. Government, and DSA is used in conjunction with the SHA-1 one-way hash function. DSA is fully described in [FIPS 186].  The ASN.1 OID used to identify this signature algorithm is:      id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2) us(840) x9-57 (10040) x9cm(4) 3 }When the id-dsa-with-sha1 algorithm identifier appears as the algorithm field in an AlgorithmIdentifier, the encoding SHALL omit the parameters field.  That is, the AlgorithmIdentifier SHALL be a SEQUENCE of one component: the OBJECT IDENTIFIER id-dsa-with-sha1.The DSA parameters in the subjectPublicKeyInfo field of the certificate of the issuer SHALL apply to the verification of the signature.	self id_dsa_with_sha1"	^self new		algorithm: self id_dsa_with_sha1OID;		yourself</body><body package="X509" selector="md5WithRSAEncryption">md5WithRSAEncryption"RFC 3279 (section 2.2.1  RSA Signature Algorithm): The signature algorithm with MD5 and the RSA encryption algorithm is defined in PKCS #1 [RFC 2313].  As defined in PKCS #1 [RFC 2313], the ASN.1 OID used to identify this signature algorithm is:       md5WithRSAEncryption OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) 4  }When any of these three OIDs appears within the ASN.1 type AlgorithmIdentifier, the parameters component of that type SHALL be the ASN.1 type NULL.The RSA signature generation process and the encoding of the result is described in detail in PKCS #1 [RFC 2313].	self md5WithRSAEncryption"	^self new		algorithm: (ObjectIdentifier value: #(1 2 840 113549 1 1 4));		"The following is necessary because parameters are defined as optional ANY and		using simply nil represents absence of the optional element. Using a type wrapper signifies presence of NULL value."		parameters: (TypeWrapper type: ANY new value: nil);		yourself</body><body package="X509" selector="sha_1WithRSAEncryption">sha_1WithRSAEncryption"RFC 3279 (section 2.2.1  RSA Signature Algorithm): The signature algorithm with MD5 and the RSA encryption algorithm is defined in PKCS #1 [RFC 2313].  As defined in PKCS #1 [RFC 2313], the ASN.1 OID used to identify this signature algorithm is:      sha-1WithRSAEncryption OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) 5  }When any of these three OIDs appears within the ASN.1 type AlgorithmIdentifier, the parameters component of that type SHALL be the ASN.1 type NULL.The RSA signature generation process and the encoding of the result is described in detail in PKCS #1 [RFC 2313].	self sha_1WithRSAEncryption"	^self new		algorithm: (ObjectIdentifier value: #(1 2 840 113549 1 1 5));		"The following is necessary because parameters are defined as optional ANY and		using simply nil represents absence of the optional element. Using a type wrapper signifies presence of NULL value."		parameters: (TypeWrapper type: ANY new value: nil);		yourself</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self	initializeAsn1Types;		initializeSMINodes</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	AlgorithmIdentifier  ::=  SEQUENCE  {		algorithm               OBJECT IDENTIFIER,		parameters              ANY DEFINED BY algorithm OPTIONAL  }"	( ASN1Module SEQUENCE: self asn1TypeName )		addElement: #algorithm type: #OBJECT_IDENTIFIER;		addOptionalElement: #parameters type: #ANY;		mapping: self</body><body package="X509" selector="initializeSMINodes">initializeSMINodes"Add Algorithm OIDs from RFC#3279: Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile."	SMINode root"	2.2.1  RSA Signature Algorithm	The RSA signature algorithm, as specified in PKCS #1 [RFC 2313] includes a data encoding step.  In this step, the message digest and the OID for the one-way hash function used to compute the digest are combined.  When performing the data encoding step, the md2, md5, and id-sha1 OIDs MUST be used to specify the MD2, MD5, and SHA-1 one-way hash functions, respectively:		md2  OBJECT IDENTIFIER ::= { iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 2 }		md5  OBJECT IDENTIFIER ::= { iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 5 }		id-sha1  OBJECT IDENTIFIER ::= { iso(1) identified-organization(3) oiw(14) secsig(3) algorithms(2) 26 }"		atPath: #( 1 2 840 113549 ) setSymbol: 'rsadsi';		atPath: #( 1 2 840 113549 2) setSymbol: 'digestAlgorithm';		atPath: #( 1 2 840 113549 2 2) setSymbol: 'md2';		atPath: #( 1 2 840 113549 2 5) setSymbol: 'md5';		atPath: #( 1 3 14 3 ) setSymbol: 'secsig';		atPath: #( 1 3 14 3 2 ) setSymbol: 'algorithms';		atPath: #( 1 3 14 3 2 12 )	 setSymbol: 'dsa';		atPath: #( 1 3 14 3 2 26 ) setSymbol: 'sha1';		atPath: #( 1 3 14 3 2 27 ) setSymbol: 'dsaWithSHA1';"	The signature algorithm with MD2 and the RSA encryption algorithm is defined in PKCS #1 [RFC 2313].  As defined in PKCS #1 [RFC 2313], the ASN.1 OID used to identify this signature algorithm is:		md2WithRSAEncryption OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) 2  }"		atPath: #( 1 2 840 113549 1 ) setSymbol: 'pkcs';		atPath: #( 1 2 840 113549 1 1 ) setSymbol: 'pkcs-1';		atPath: #( 1 2 840 113549 1 1 2 ) setSymbol: 'md2WithRSAEncryption';"	The signature algorithm with MD5 and the RSA encryption algorithm is defined in PKCS #1 [RFC 2313].  As defined in PKCS #1 [RFC 2313], the ASN.1 OID used to identify this signature algorithm is:		md5WithRSAEncryption OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) 4  }"		atPath: #( 1 2 840 113549 1 1 4 ) setSymbol: 'md5WithRSAEncryption';"	The ASN.1 object identifier used to identify this signature algorithm is:		sha-1WithRSAEncryption OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) 5  }"		atPath: #( 1 2 840 113549 1 1 5 ) setSymbol: 'sha-1WithRSAEncryption';"	From PKCS #1 V2.1: RSA CRYPTOGRAPHY STANDARD (June 14, 2002), Appendix C. ASN.1 module		md2WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 2 }		md5WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 4 }		sha1WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 5 }		sha256WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 11 }		sha384WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 12 }		sha512WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 13 }"		atPath: #( 1 2 840 113549 1 1 11 ) setSymbol: 'sha256WithRSAEncryption';		atPath: #( 1 2 840 113549 1 1 12 ) setSymbol: 'sha348WithRSAEncryption';		atPath: #( 1 2 840 113549 1 1 13 ) setSymbol: 'sha512WithRSAEncryption';"	2.2.2  DSA Signature Algorithm	The Digital Signature Algorithm (DSA) is defined in the Digital Signature Standard (DSS).  DSA was developed by the U.S. Government, and DSA is used in conjunction with the SHA-1 one-way hash function. DSA is fully described in [FIPS 186].  The ASN.1 OID used to identify this signature algorithm is:	      id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2) us(840) x9-57 (10040) x9cm(4) 3 }"		atPath: #( 1 2 840 10040 ) setSymbol: 'x9-57';		atPath: #( 1 2 840 10040 4 ) setSymbol: 'x9algorithm';		atPath: #( 1 2 840 10040 4 3 )	 setSymbol: 'dsa-with-sha1';"	2.2.3 ECDSA Signature Algorithm	The Elliptic Curve Digital Signature Algorithm (ECDSA) is defined in [X9.62].  The ASN.1 object identifiers used to identify ECDSA are defined in the following arc:		ansi-X9-62  OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) 10045 }		id-ecSigType OBJECT IDENTIFIER  ::=  { ansi-X9-62 signatures(4) }	ECDSA is used in conjunction with the SHA-1 one-way hash function. The ASN.1 object identifier used to identify ECDSA with SHA-1 is:		ecdsa-with-SHA1  OBJECT IDENTIFIER ::= { id-ecSigType 1 }"		atPath: #( 1 2 840 10045 ) setSymbol: 'x9-62';		atPath: #( 1 2 840 10045 4 ) setSymbol: 'ecSigType';		atPath: #( 1 2 840 10045 4 1) setSymbol: 'ecdsa-with-SHA1';"	2.3  Subject Public Key Algorithms""	2.3.1  RSA Keys	The OID rsaEncryption identifies RSA public keys.		pkcs-1 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }		rsaEncryption OBJECT IDENTIFIER ::=  { pkcs-1 1}"		atPath: #( 1 2 840 113549 1 1 1) setSymbol: 'rsaEncryption';"	2.3.2  DSA Signature Keys	The Digital Signature Algorithm (DSA) is defined in the Digital Signature Standard (DSS) [FIPS 186].  The DSA OID supported by this profile is:		id-dsa OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 1 }"		atPath: #( 1 2 840 10040 4 1 )	 setSymbol: 'dsa';"	2.3.3  Diffie-Hellman Key Exchange Keys	The Diffie-Hellman OID supported by this profile is defined in [X9.42].		dhpublicnumber OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) ansi-x942(10046) number-type(2) 1 }"		atPath: #( 1 2 840 10046 ) setSymbol: 'x9-42';		atPath: #( 1 2 840 10046 2 ) setSymbol: 'number-types';		atPath: #( 1 2 840 10046 2 1 )	 setSymbol: 'dhpublicnumber';"	2.3.4 KEA Public Keys	When the SubjectPublicKeyInfo field contains a KEA key, the algorithm identifier and parameters SHALL be as defined in [SDN.701r]:		id-keyExchangeAlgorithm  OBJECT IDENTIFIER   ::= { 2 16 840 1 101 2 1 1 22 }"		atPath: #( 1 2 840 1 101 2 1 1 22 ) setSymbol: 'keyExchangeAlgorithm';"	2.3.5 ECDSA and ECDH Keys	The ECDSA and ECDH specifications use the same OIDs and parameter encodings.  The ASN.1 object identifiers used to identify these public keys are defined in the following arc:		ansi-X9-62 OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) 10045 }	When certificates contain an ECDSA or ECDH public key, the id-ecPublicKey algorithm identifier MUST be used. The id-ecPublicKey algorithm identifier is defined as follows:		id-public-key-type OBJECT IDENTIFIER  ::= { ansi-X9.62 2 }		id-ecPublicKey OBJECT IDENTIFIER ::= { id-publicKeyType 1 }"		atPath: #( 1 2 840 10045 2) setSymbol: 'public-key-type';		atPath: #( 1 2 840 10045 2 1) setSymbol: 'ecPublicKey';		yourself</body></methods><methods><class-id>Security.X509.AlgorithmIdentifier class</class-id> <category>constants</category><body package="X509" selector="id_dsa_with_sha1OID">id_dsa_with_sha1OID"RFC 3279 (section 2.2.2  DSA Signature Algorithm): The Digital Signature Algorithm (DSA) is defined in the Digital Signature Standard (DSS).  DSA was developed by the U.S. Government, and DSA is used in conjunction with the SHA-1 one-way hash function. DSA is fully described in [FIPS 186].  The ASN.1 OID used to identify this signature algorithm is:      id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2) us(840) x9-57 (10040) x9cm(4) 3 }"	^ObjectIdentifier value: #(1 2 840 10040 4 3)</body></methods><methods><class-id>Security.X509.SubjectPublicKeyInfo</class-id> <category>accessing</category><body package="X509" selector="algorithm">algorithm	^algorithm</body><body package="X509" selector="getPublicKey">getPublicKey	^publicKey getKey</body><body package="X509" selector="publicKey">publicKey	^publicKey</body><body package="X509" selector="publicKey:">publicKey: aPublicKey	publicKey := aPublicKey asX509PublicKey.	algorithm := AlgorithmIdentifier new				algorithm: publicKey algorithmOID;				yourself.	publicKey algorithmParameters ifNotNil: [ :params |		algorithm parameters: params ]</body></methods><methods><class-id>Security.X509.SubjectPublicKeyInfo</class-id> <category>marshaling</category><body package="X509" selector="algorithm:">algorithm: anAlgorithmIdentifier	algorithm := anAlgorithmIdentifier</body><body package="X509" selector="subjectPublicKey">subjectPublicKey	^subjectPublicKey ifNil: [		self publicKey ifNotNil: [ :key || stream |			stream := DERStream on: (ByteArray new: 300).			stream marshalObject: key marshalingValue withType: key asn1Type.			subjectPublicKey := BitString unused: 0 bytes: stream contents ] ]</body><body package="X509" selector="subjectPublicKey:">subjectPublicKey: aBitString	| keyClass marshaler |	subjectPublicKey := aBitString.	keyClass := X509PublicKey keyClassFor: algorithm.	keyClass ifNil: [ publicKey := subjectPublicKey. ^self ].	marshaler := DERStream with: subjectPublicKey value.	marshaler reset.	publicKey := marshaler  unmarshalObjectType: keyClass asn1Type.	publicKey := keyClass adoptValue: publicKey.	algorithm parameters ifNotNil:[ :params |		publicKey algorithmParameters: params ]</body></methods><methods><class-id>Security.X509.SubjectPublicKeyInfo</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key info in the format used by OpenSSL"	aStream		tab: level; nextPutAll: (#PubKeyAlgPrefix &lt;&lt; #security &gt;&gt; 'Public Key Algorithm: ') asString;			nextPutAll: algorithm getOIDDescription; cr.	publicKey printOpenSSLOn: aStream indent: level</body></methods><methods><class-id>Security.X509.SubjectPublicKeyInfo</class-id> <category>private</category><body package="X509" selector="getX509DSAPublicKey">getX509DSAPublicKey	| bytes marshaler key |	bytes := subjectPublicKey value.	marshaler := DERStream with: bytes.	marshaler reset.	key := marshaler  unmarshalObjectType: ( ASN1Module find: #X509DSAPublicKey ).	"The ASN.1 marshaler can't map integers to Smalltalk classes yet, so we need to help here as well"	key := X509DSAPublicKey new			publicKey: key;			yourself.	algorithm parameters ifNotNil:[ :params |		key dssParameters: (			DSSParameters				p: (params at: 1)				q: (params at: 2)				g: (params at: 3) ) ].	^key</body><body package="X509" selector="getX509RSAPublicKey">getX509RSAPublicKey	| bytes marshaler |	bytes := subjectPublicKey value.	marshaler := DERStream with: bytes.	marshaler reset.	^marshaler  unmarshalObjectType: ( ASN1Module find: #X509RSAPublicKey )</body></methods><methods><class-id>Security.X509.SubjectPublicKeyInfo class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	SubjectPublicKeyInfo  ::=  SEQUENCE  {		algorithm            AlgorithmIdentifier,		subjectPublicKey     BIT STRING  }"	( ASN1Module SEQUENCE: self asn1TypeName)		addElement: #algorithm type: #AlgorithmIdentifier;		addElement: #subjectPublicKey type: #BIT_STRING;		mapping: self</body></methods><methods><class-id>Security.X509.SubjectPublicKeyInfo class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#SubjectPublicKeyInfo</body></methods><methods><class-id>Security.X509.UnhandledCriticalExtension</class-id> <category>accessing</category><body package="X509" selector="extension">extension	^extension</body><body package="X509" selector="extension:">extension: anObject	extension := anObject</body></methods><methods><class-id>Security.X509.X509DSAPrivateKey</class-id> <category>marshaling</category><body package="X509" selector="g:">g: anObject	g := anObject</body><body package="X509" selector="p:">p: anObject	p := anObject</body><body package="X509" selector="q:">q: anObject	q := anObject</body><body package="X509" selector="version">version	^version ifNil: [0]</body><body package="X509" selector="version:">version: anInteger	version := anInteger</body><body package="X509" selector="x:">x: anObject	x := anObject</body><body package="X509" selector="y:">y: anObject	y := anObject</body></methods><methods><class-id>Security.X509.X509DSAPrivateKey</class-id> <category>accessing</category><body package="X509" selector="g">g	^g</body><body package="X509" selector="getKey">getKey	^DSAPrivateKey		p: p 		q: q 		g: g 		x: x</body><body package="X509" selector="p">p	^p</body><body package="X509" selector="q">q	^q</body><body package="X509" selector="x">x	^x</body><body package="X509" selector="y">y	^y</body></methods><methods><class-id>Security.X509.X509DSAPrivateKey</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key in the format used by OpenSSL"	| pArray |	pArray := p asBigEndianByteArray.	aStream tab: level; nextPutAll: (#DSAPubKeyPrefix &lt;&lt; #security &gt;&gt; 'DSA Public Key: (') asString;		print: pArray size * 8; nextPutAll: (#BitsSuffix &lt;&lt; #security &gt;&gt; ' bits)') asString; cr.	aStream tab: level; nextPutAll: (#privPrefix &lt;&lt; #security &gt;&gt; 'priv:') asString; cr.	x asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#pubPrefix &lt;&lt; #security &gt;&gt; 'pub:') asString; cr.	y asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#PPrefix &lt;&lt; #security &gt;&gt; 'P:') asString; cr.	#[0], pArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#QPrefix &lt;&lt; #security &gt;&gt; 'Q:') asString; cr.	#[0], q asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.	aStream tab: level; nextPutAll: (#GPrefix &lt;&lt; #security &gt;&gt; 'G:') asString; cr.	g asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 15.</body></methods><methods><class-id>Security.X509.X509DSAPrivateKey class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types" See the man page for the dsa command in the openssl suite, option -inform	DSAPrivateKey  ::=  SEQUENCE  {		version	INTEGER, -- curently zero		p		INTEGER,		q		INTEGER,		g		INTEGER ,		y		INTEGER,		x		INTEGER  }"	( ASN1Module SEQUENCE: self asn1TypeName )		addElement: #version type: #INTEGER;		addElement: #p type: #INTEGER;		addElement: #q type: #INTEGER;		addElement: #g type: #INTEGER;		addElement: #y type: #INTEGER;		addElement: #x type: #INTEGER;		mapping: self</body></methods><methods><class-id>Security.X509.X509DSAPrivateKey class</class-id> <category>utilities</category><body package="X509" selector="canReadPEM:">canReadPEM: mark	^'*dsa*private*key*' match: mark</body></methods><methods><class-id>Security.X509.X509DSAPrivateKey class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#X509DSAPrivateKey</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>marshaling</category><body package="X509" selector="encoding:">encoding: anEncoding	encoding := anEncoding</body><body package="X509" selector="signature:">signature: aSignature	signature := aSignature.	signatureValue := aSignature.	signatureAlgorithm isDSA		ifTrue: [ | marshaler |			marshaler := DERStream on: (ByteArray new: 500).			marshaler  marshalObject: signatureValue withType: ( ASN1Module find: #DSSSignature ).			signatureValue := marshaler contents.			signature := aSignature asX509Signature ].	signatureValue := BitString unused: 0 bytes: signatureValue.</body><body package="X509" selector="signatureAlgorithm:">signatureAlgorithm: anAlgorithmIdentifier	signatureAlgorithm := anAlgorithmIdentifier</body><body package="X509" selector="signatureValue">signatureValue	^signatureValue</body><body package="X509" selector="signatureValue:">signatureValue: aBitString	signatureValue := aBitString.	signature := aBitString value.	signatureAlgorithm isDSA		ifTrue: [ | marshaler |			marshaler := DERStream with: signature.			marshaler reset.			signature := marshaler  unmarshalObjectType: ( ASN1Module find: #DSSSignature ) ]</body><body package="X509" selector="tbsCertificate">tbsCertificate	^tbsCertificate ifNil: [ tbsCertificate := TBSCertificate new ]</body><body package="X509" selector="tbsCertificate:">tbsCertificate: aTBCCertificate	tbsCertificate := aTBCCertificate</body><body package="X509" selector="_encoding">_encoding	^encoding</body><body package="X509" selector="_encoding:type:">_encoding: anEncoding type: aType	encoding := anEncoding</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>testing</category><body package="X509" selector="isForCA">isForCA"Assert/Deny that usage indicates CA purposes, i.e. certificate and CRL signing."	^self isCrlSign or: [ self isKeyCertSign ]</body><body package="X509" selector="isForEncryption">isForEncryption"Assert/Deny that usage indicates data encryption."	^self isDataEncipherment</body><body package="X509" selector="isForKeyEstablishment">isForKeyEstablishment"Assert/Deny that usage indicates key establishment purposes."	^self isKeyEncipherment or: [ self isKeyAgreement ]</body><body package="X509" selector="isForSigning">isForSigning"Assert/Deny that usage indicates data signing."	^self isDigitalSignature</body><body package="X509" selector="isSameAs:">isSameAs: certificate"Test if the receiver is the same as certificate.	^&lt;Boolean&gt;"	^certificate signatureBytes = self signatureBytes</body><body package="X509" selector="isVersionOne">isVersionOne	^self version = 1</body><body package="X509" selector="isVersionThree">isVersionThree	^self version = 3</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - signature</category><body package="X509" selector="getSignature">getSignature	^signature class = ByteArray		ifTrue: [signature]		ifFalse: [signature getSignature]</body><body package="X509" selector="signature">signature	^signature</body><body package="X509" selector="signatureAlgorithm">signatureAlgorithm	^signatureAlgorithm</body><body package="X509" selector="signatureAlgorithmOID">signatureAlgorithmOID	"Answers the OID of the algorithm used to sign this certificate"	^signatureAlgorithm getOID</body><body package="X509" selector="signatureAlgorithmOIDDescription">signatureAlgorithmOIDDescription	"description of the OID of the algorithm used to sign this certificate"	^signatureAlgorithm getOIDDescription</body><body package="X509" selector="signatureBytes">signatureBytes	^signatureValue bytes</body><body package="X509" selector="signUsing:">signUsing: signer"Sign the receiver using the signer.	signer &lt;AsymmetricCipher | PrivateKey&gt; algorithm or signing key to use to sign the receiver"	| algorithm bytes identifier |	algorithm := signer x509AsAlgorithm.	identifier := algorithm x509AlgorithmIdentifier.	self tbsCertificate signatureAlgorithm: identifier.	bytes := self tbsCertificate derCertificate.	self signatureAlgorithm: identifier.	self signature: (algorithm sign: bytes).</body><body package="X509" selector="tbsSignatureAlgorithm">tbsSignatureAlgorithm	^self tbsCertificate signatureAlgorithm</body><body package="X509" selector="tbsSignatureAlgorithmOID">tbsSignatureAlgorithmOID	"Answers the OID of the algorithm used to sign this certificate"	^self tbsCertificate signatureAlgorithmOID</body><body package="X509" selector="tbsSignatureAlgorithmOIDDescription">tbsSignatureAlgorithmOIDDescription	"description of the OID of the algorithm used to sign this certificate"	^self tbsCertificate signatureAlgorithmOIDDescription</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - subject</category><body package="X509" selector="subject">subject	^self tbsCertificate subject</body><body package="X509" selector="subject:">subject: anX509Name	self tbsCertificate subject: anX509Name</body><body package="X509" selector="subjectDN">subjectDN	"Answers the distinguished name of the subject"	^self tbsCertificate subjectDN</body><body package="X509" selector="subjectDNInBytes">subjectDNInBytes	"Answers the distinguished name of the subject"	^self tbsCertificate subjectDNInBytes</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - extensions - key usage</category><body package="X509" selector="hasKeyUsage">hasKeyUsage 	^self tbsCertificate hasKeyUsage</body><body package="X509" selector="isCrlSign">isCrlSign 	^self tbsCertificate isCrlSign</body><body package="X509" selector="isDataEncipherment">isDataEncipherment 	^self tbsCertificate isDataEncipherment</body><body package="X509" selector="isDecipherOnly">isDecipherOnly 	^self tbsCertificate isDecipherOnly</body><body package="X509" selector="isDigitalSignature">isDigitalSignature 	^self tbsCertificate isDigitalSignature</body><body package="X509" selector="isEncipherOnly">isEncipherOnly 	^self tbsCertificate isEncipherOnly</body><body package="X509" selector="isKeyAgreement">isKeyAgreement 	^self tbsCertificate isKeyAgreement</body><body package="X509" selector="isKeyCertSign">isKeyCertSign 	^self tbsCertificate isKeyCertSign</body><body package="X509" selector="isKeyEncipherment">isKeyEncipherment 	^self tbsCertificate isKeyEncipherment</body><body package="X509" selector="isNonRepudiation">isNonRepudiation 	^self tbsCertificate isNonRepudiation</body><body package="X509" selector="keyUsage">keyUsage	^self tbsCertificate keyUsage</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - internals</category><body package="X509" selector="derCertificate">derCertificate	"Answers the DER encoded certificate"	^(encoding ifNil: [ | marshaler |		marshaler := DERStream on: (ByteArray new: 100).		marshaler marshalObject: self withType: self asn1Type.		encoding := Encoding with: marshaler contents ]	) fullEncoding</body><body package="X509" selector="encoding">encoding	^encoding</body><body package="X509" selector="tbsDerCertificate">tbsDerCertificate	"Answers the DER encoded certificate"	^self tbsCertificate derCertificate</body><body package="X509" selector="tbsEncoding">tbsEncoding	^self tbsCertificate encoding</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - validity</category><body package="X509" selector="isExpired">isExpired	^tbsCertificate isExpired</body><body package="X509" selector="isNotValidYet">isNotValidYet	^tbsCertificate isNotValidYet</body><body package="X509" selector="isValid">isValid	^tbsCertificate isValid</body><body package="X509" selector="isValidOn:">isValidOn: time	^tbsCertificate isValidOn: time</body><body package="X509" selector="notAfter">notAfter	"a string containing notAfter as a UTCTIME"	^self tbsCertificate notAfter</body><body package="X509" selector="notAfter:">notAfter: aTimestamp	self tbsCertificate notAfter: aTimestamp</body><body package="X509" selector="notAfterDate">notAfterDate	"an instance of Date containing the date  of notAfter"	^self tbsCertificate notAfterDate</body><body package="X509" selector="notAfterTime">notAfterTime	" instance of Time containing the time  of notAfter"	^self tbsCertificate notAfterTime</body><body package="X509" selector="notBefore">notBefore	"string containing notBefore as a UTCTIME"	^self tbsCertificate notAfter</body><body package="X509" selector="notBefore:">notBefore: aTimestamp	self tbsCertificate notBefore: aTimestamp</body><body package="X509" selector="notBeforeDate">notBeforeDate	"instance of Date containing the date  of notBefore"	^self tbsCertificate notBeforeDate</body><body package="X509" selector="notBeforeTime">notBeforeTime	" instance of Time containing the time  of notBefore"	^self tbsCertificate notBeforeTime</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - key</category><body package="X509" selector="publicKey">publicKey	^self tbsCertificate publicKey</body><body package="X509" selector="publicKey:">publicKey: aPublicKey	self tbsCertificate publicKey: aPublicKey</body><body package="X509" selector="subjectPublicKeyAlgorithmOID">subjectPublicKeyAlgorithmOID	"OID of the algorithm used to generate the subject's public key"	^self tbsCertificate subjectPublicKeyInfo algorithm getOID</body><body package="X509" selector="subjectPublicKeyAlgorithmOIDDescription">subjectPublicKeyAlgorithmOIDDescription	"description of the OID of the algorithm used to generate the subject's public key"	^self tbsCertificate subjectPublicKeyInfo algorithm getOIDDescription</body><body package="X509" selector="subjectPublicKeyInfo">subjectPublicKeyInfo	"Answers the subject's public key"	^self tbsCertificate subjectPublicKeyInfo</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - issuer</category><body package="X509" selector="issuer">issuer	^self tbsCertificate issuer</body><body package="X509" selector="issuer:">issuer: anX509Name	self tbsCertificate issuer: anX509Name</body><body package="X509" selector="issuerDN">issuerDN	"Answers the distinguished name of the issuer"	^self tbsCertificate issuerDN</body><body package="X509" selector="issuerDNInBytes">issuerDNInBytes	"Answers the distinguished name of the issuer in Bytes"	^self tbsCertificate issuerDNInBytes</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - extensions - basic constraints</category><body package="X509" selector="basicConstraints">basicConstraints	^self tbsCertificate basicConstraints</body><body package="X509" selector="getBasicConstraints">getBasicConstraints	^self tbsCertificate getBasicConstraints</body><body package="X509" selector="hasBasicConstraints">hasBasicConstraints	^self tbsCertificate hasBasicConstraints</body><body package="X509" selector="isCACertificate">isCACertificate	^self tbsCertificate isCACertificate</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing</category><body package="X509" selector="serialNumber">serialNumber	"Answers the serial number of  certificate"	^self tbsCertificate serialNumber</body><body package="X509" selector="serialNumber:">serialNumber: anInteger	self tbsCertificate serialNumber: anInteger</body><body package="X509" selector="version">version	"Answers the version number of the certificate"	^self tbsCertificate versionName</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>deprecated</category><body package="X509" selector="getPublicKey">getPublicKey	^self publicKey</body><body package="X509" selector="getRSAPublicKey">getRSAPublicKey	^self tbsCertificate subjectPublicKeyInfo publicKey getKey</body><body package="X509" selector="isBeforeValidityDate">isBeforeValidityDate		^self isNotValidYet</body><body package="X509" selector="verifySignature">verifySignature"This seems like a gratuitous API padding. See below."	self verifySignedBy: self</body><body package="X509" selector="verifyValidityPeriod">verifyValidityPeriod"Responsibility moved to X509Registry."	self isNotValidYet ifTrue: [		NotValidYet new			messageText: (#CertificateNotValidYet &lt;&lt; #security &gt;&gt; 'Certificate not valid yet!');			parameter: self;			isResumable: true;			raiseSignal ].	self isExpired ifTrue: [		Expired new			messageText: (#CertificateExpired &lt;&lt; #security &gt;&gt; 'Certificate expired!');			parameter: self;			isResumable: true;			raiseSignal].</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>utilities</category><body package="X509" selector="flushEncoding">flushEncoding	self encoding: nil.	self tbsCertificate flushEncoding</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - extensions</category><body package="X509" selector="addExtension:">addExtension: anExtension	^self tbsCertificate addExtension: anExtension</body><body package="X509" selector="criticalExtensions">criticalExtensions	^self tbsCertificate criticalExtensions</body><body package="X509" selector="extension:ifAbsent:">extension: detectionBlock ifAbsent: notFoundBlock	^self tbsCertificate extension: detectionBlock ifAbsent: notFoundBlock</body><body package="X509" selector="extensions">extensions	^self tbsCertificate extensions</body><body package="X509" selector="getExtension:">getExtension: extensionClass	^self tbsCertificate getExtension: extensionClass</body><body package="X509" selector="hasExtensions">hasExtensions	^self tbsCertificate hasExtensions</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>accessing - key usage</category><body package="X509" selector="forCertificateSigning">forCertificateSigning"Mark the certificate as suitable for signing other certificates."	self tbsCertificate forCertificateSigning</body><body package="X509" selector="forCertificateSigning:">forCertificateSigning: depth"Mark the certificate as suitable for signing other certificates.	depth &lt;Integer&gt; what is the maximum length of valid certificate chain with this certificate as root"	self tbsCertificate forCertificateSigning: depth</body><body package="X509" selector="forCRLSigning">forCRLSigning"Mark the certificate as suitable for signing CRLs."	self tbsCertificate forCRLSigning</body><body package="X509" selector="forEncryption">forEncryption"Mark this certificate as suitable for encryption of data."	self tbsCertificate forEncryption</body><body package="X509" selector="forKeyExchange">forKeyExchange"Mark this certificate as suitable for key exchange or key agreement depending on the key algorithm"	self tbsCertificate forKeyExchange</body><body package="X509" selector="forSigning">forSigning"Mark this certificate as suitable for signing anything except certificates and CRLs"	self tbsCertificate forSigning</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>printing</category><body package="X509" selector="getFormattedCertificate">getFormattedCertificate	"Answers a String containing the formatted self"	| s idn i pk  |	s := WriteStream on: String new.	s nextPutAll: (#CertificateVersionPrefix &lt;&lt; #security &gt;&gt; 'X509 Certificate Version: ') asString; nextPutAll: self version printString; nextPutAll: ' ', (#SerialNumberPrefix &lt;&lt; #security &gt;&gt; 'Serial Number: ') asString; nextPutAll: self serialNumber printString.	idn := self issuerDN.	s cr; cr; nextPutAll: (#IssuerPrefix &lt;&lt; #security &gt;&gt; 'Issuer: ') asString.	idn := self issuerDN.	i := 1.	idn size		timesRepeat: 			[s nextPutAll: (idn at: i) type getOIDDescription; nextPutAll: '='; nextPutAll: (idn at: i) value .			i = idn size ifFalse: [s nextPutAll: ', '].			i := i + 1].	s cr; cr.	idn := self issuerDN.	s cr; cr; nextPutAll: (#SubjectPrefix &lt;&lt; #security &gt;&gt; 'Subject: ') asString.	idn := self subjectDN.	i := 1.	idn size		timesRepeat: 			[s nextPutAll: (idn at: i) type getOIDDescription; nextPutAll: '='; nextPutAll: (idn at: i) value.			i = idn size ifFalse: [s nextPutAll: ', '].			i := i + 1].	s cr; cr; nextPutAll: (#SubPubKeyAlgPrefix &lt;&lt; #security &gt;&gt; 'Subject Public Key Algorithm: ') asString; nextPutAll: self subjectPublicKeyAlgorithmOID getDottedOID ; nextPutAll: ' ('; nextPutAll: self subjectPublicKeyAlgorithmOIDDescription; nextPutAll: ')'.	s cr; cr; nextPutAll: (#SubPubKeyPrefix &lt;&lt; #security &gt;&gt; 'Public Key:') asString.	pk := self subjectPublicKeyInfo subjectPublicKey getBitStringAsFormattedHexStrings.	s crtab; nextPutAll: pk.	self extensions isNil		ifFalse: 			[s cr; cr; nextPutAll: (#ExtensionsPrefix &lt;&lt; #security &gt;&gt; 'EXTENSIONS:') asString.			self extensions				do: 					[:ext | 					s crtab; nextPutAll: ext id; nextPutAll: ' ('; nextPutAll: ext idDescription; nextPutAll: ')'.					ext isCritical ifTrue: [s tab; nextPutAll: (#CRITICAL &lt;&lt; #security &gt;&gt; 'CRITICAL') asString]]].	s cr; cr; nextPutAll: (#SignatureAlgorithmPrefix &lt;&lt; #security &gt;&gt; 'Signature Algorithm: ') asString; nextPutAll: self signatureAlgorithmOID getDottedOID ; nextPutAll: ' ('; nextPutAll: self signatureAlgorithmOIDDescription; nextPutAll: ')'.	s cr; cr; nextPutAll: (#SignaturePrefix &lt;&lt; #security &gt;&gt; 'Signature:') asString.	pk := self signature asFormattedHexStrings.	s crtab; nextPutAll: pk.	^s contents</body><body package="X509" selector="printOn:">printOn: aStream	aStream		nextPutAll: 'X509v';		print: self version;		nextPutAll: ': ';		nextPutAll: (self subject commonName ifNil: ['No Common Name']);		nextPutAll: ' &lt;';		nextPutAll: (self issuer commonName ifNil:['No Common Name']);		nextPut: $&gt;</body><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the certificate in the format used by OpenSSL"	aStream		tab: level; nextPutAll: (#CertificatePrefix &lt;&lt; #security &gt;&gt; 'Certificate:') asString; cr;		tab: level + 1; nextPutAll: (#DataPrefix &lt;&lt; #security &gt;&gt; 'Data:') asString; cr.	self tbsCertificate printOpenSSLOn: aStream indent: level + 2.	aStream		tab: level + 1;		nextPutAll: (#SignatureAlgorithmPrefix &lt;&lt; #security &gt;&gt; 'Signature Algorithm: ') asString;		nextPutAll: self signatureAlgorithm getOIDDescription; cr.	signatureValue bytes printOpenSSLOn: aStream indent: level + 2 width: 18</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>ssl</category><body package="X509" selector="isRSA">isRSA	^self subjectPublicKeyAlgorithmOIDDescription = 'rsaEncryption'</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>private</category><body package="X509" selector="badCertificate">badCertificate	^BadCertificate new		messageText: (#SubjectSigAlgMismatch &lt;&lt; #security &gt;&gt; 'Inner and outer signature algorithm identification does not match!');		parameter: self;		isResumable: true;		raiseSignal</body><body package="X509" selector="invalidSignature">invalidSignature	^InvalidSignature new		messageText: (#InvalidSignature &lt;&lt; #security &gt;&gt; 'Certificate signature is not valid!');		parameter: self;		isResumable: true;		raiseSignal</body><body package="X509" selector="issuerMismatch:">issuerMismatch: issuer	^IssuerMismatch new		messageText: (#IssuerMismatch &lt;&lt; #security &gt;&gt; 'Issuer does not match!');		parameter: issuer;		isResumable: true;		raiseSignal</body></methods><methods><class-id>Security.X509.Certificate</class-id> <category>verification</category><body package="X509" selector="verifyIssuedBy:">verifyIssuedBy: certificate"Verify that self is issued by certificate. Otherwise signal an error."	self issuerDNInBytes = certificate subjectDNInBytes		ifFalse: [ self issuerMismatch: certificate ].	self verifySignedBy: certificate</body><body package="X509" selector="verifySignedBy:">verifySignedBy: certificate"Verify that the receiver is signed by certificate. Otherwise signal an error."	self signatureAlgorithmOID = self tbsSignatureAlgorithmOID		ifFalse: [			self badCertificate.			^self ].	(self signatureAlgorithm verify: self isSignedBy: certificate)		ifFalse: [			self invalidSignature ]</body></methods><methods><class-id>Security.X509.Certificate class</class-id> <category>chain verification</category><body package="X509" selector="validateCertificateChain:">validateCertificateChain: anOrderedCollection 	^X509Registry default validateCertificateChain: anOrderedCollection</body></methods><methods><class-id>Security.X509.Certificate class</class-id> <category>instance creation</category><body package="X509" selector="fromBase64:">fromBase64: aString"Read a certificate from Base64 encoded bytes"	^self fromBytes: (self decodeBase64: (self stripWhitespace: aString))</body><body package="X509" selector="fromBytes:">fromBytes: aByteArray	| marshaler |	marshaler := DERStream with: aByteArray.	marshaler reset.	^marshaler unmarshalObjectType: ( ASN1Module find: #Certificate )</body><body package="X509" selector="fromFile:">fromFile: aFile"Read a certificate from PEM formatted file"	| file |	file := aFile asFilename readStream.	^[ self fromString: file contents ] ensure: [ file close ]</body><body package="X509" selector="fromString:">fromString: aString"Reads a certificate from a PEM formatted file"	^(self getCertificateDataFrom: aString)		ifNotNil: [ :b64 | self fromBase64: b64 ]</body></methods><methods><class-id>Security.X509.Certificate class</class-id> <category>accessing</category><body package="X509" selector="asn1TypeName">asn1TypeName	^#Certificate</body></methods><methods><class-id>Security.X509.Certificate class</class-id> <category>utilities</category><body package="X509" selector="getCertificateDataFrom:">getCertificateDataFrom: aPEMString"Answers the Base64 encoded certificate it the string has the appropriate delimiters required for PEM format; otherwise answers nil"	| i j k |	i := aPEMString				indexOfSubCollection: '--BEGIN '				startingAt: 1				ifAbsent: [^nil].	i := aPEMString				indexOfSubCollection: 'CERTIFICATE--'				startingAt: i				ifAbsent: [^nil].	j := aPEMString				indexOfSubCollection: '--END '				startingAt: i				ifAbsent: [^nil].	k := aPEMString				indexOfSubCollection: 'CERTIFICATE--'				startingAt: j				ifAbsent: [^nil].	i := (aPEMString findEither: Character cr or: Character lf from: i to: k).	^(aPEMString copyFrom: i to: j) reject: [:c | c = $- or: [c isSeparator]]</body></methods><methods><class-id>Security.X509.Certificate class</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	self	initializeAsn1Types</body><body package="X509" selector="initializeAsn1Types">initializeAsn1Types"	Certificate  ::=  SEQUENCE  {		tbsCertificate       TBSCertificate,		signatureAlgorithm   AlgorithmIdentifier,		signatureValue       BIT STRING  }"	(ASN1Module SEQUENCE: self asn1TypeName)		addElement: #tbsCertificate type: #TBSCertificate;		addElement: #signatureAlgorithm type: #AlgorithmIdentifier;		addElement: #signatureValue type: #BIT_STRING;		mapping: self;		retainEncoding: true</body></methods><methods><class-id>Security.DSAPrivateKey</class-id> <category>x509</category><body package="X509" selector="asX509Key">asX509Key	^Security.X509.X509DSAPrivateKey new		x: x;		y: (g raisedTo: x modulo: p);		p: p;		q: q;		g: g;		yourself</body><body package="X509" selector="x509AsAlgorithm">x509AsAlgorithm	^DSA new		privateKey: self;		yourself</body></methods><methods><class-id>ASN1.ObjectIdentifier</class-id> <category>x509 extensions</category><body package="X509" selector="getDottedOID">getDottedOID	|strm |	strm := (String new:20) readWriteStream.	self value		do: [ :x | strm nextPutAll: x printString ]		separatedBy: [ strm nextPut: $. ].^(strm contents copyFrom: 1 to: strm readPosition)</body><body package="X509" selector="getOIDDescription">getOIDDescription	^self alphabeticSymbol asString</body><body package="X509" selector="getOIDSymbol">getOIDSymbol	^self getOIDSymbolForLookup</body><body package="X509" selector="getOIDSymbolForLookup">getOIDSymbolForLookup	| strm |	strm := (String new: 20) readWriteStream.	strm nextPut: $x.	self value do: [:x | strm nextPutAll: x printString]		separatedBy: [strm nextPut: $x].	^(strm contents copyFrom: 1 to: strm readPosition)  asSymbol</body><body package="X509" selector="getShortOIDDescription">getShortOIDDescription	^(self leafSymbol ifNil: [ self numericSymbol ]) asString</body></methods><methods><class-id>Security.DSA class</class-id> <category>x509</category><body package="X509" selector="dsaOID">dsaOID	^ASN1.ObjectIdentifier value: #(1 2 840 10040 4 1)</body></methods><methods><class-id>Security.DSA</class-id> <category>x509</category><body package="X509" selector="x509AlgorithmIdentifier">x509AlgorithmIdentifier	^Security.X509.AlgorithmIdentifier id_dsa_with_sha1</body><body package="X509" selector="x509AlgorithmOID">x509AlgorithmOID	^self class dsaOID</body><body package="X509" selector="x509AsAlgorithm">x509AsAlgorithm	^self</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>x509</category><body package="X509" selector="asX509Name">asX509Name	^Security.X509.Name fromChoice: self</body></methods><methods><class-id>Core.ByteArray</class-id> <category>security</category><body package="X509" selector="asFormattedHexStrings">asFormattedHexStrings"(((#[160 11 2 16 255 0] asFormattedHexStrings)))"	| lookup s ws |	lookup := '0123456789ABCDEF'.	s := String new: self size * 2.	ws := s readWriteStream.	self do: [ :b |		ws nextPut: (lookup at: (b bitShift: -4) + 1).		ws nextPut: (lookup at: (b bitAnd: 15) + 1).		ws space ].	^(ws contents copyFrom: 1 to: ws readPosition)</body><body package="X509" selector="printOpenSSLOn:indent:width:">printOpenSSLOn: aStream indent: level width: bytes"This should print the value as a hex dump in the format used by OpenSSL"	| digits |	digits := '0123456789abcdef'.	aStream tab: level.	1 to: self size do: [ :idx || byte |		aStream nextPut: (digits at: ((byte := self at: idx) bitShift: -4) + 1).		aStream nextPut: (digits at: (byte bitAnd: 16rF) + 1).		idx =  self size ifFalse: [			aStream nextPut: $:.			idx \\ bytes = 0 ifTrue: [				aStream cr; tab: level ] ] ].	aStream cr</body></methods><methods><class-id>Security.RSAPublicKey</class-id> <category>x509</category><body package="X509" selector="asX509Key">asX509Key	^self asX509PublicKey</body><body package="X509" selector="asX509PublicKey">asX509PublicKey	^Security.X509.X509RSAPublicKey new		modulus: n;		publicExponent: e;		yourself</body></methods><methods><class-id>ASN1.Choice</class-id> <category>x509</category><body package="X509" selector="asX509Name">asX509Name	^Security.X509.Name fromChoice: self</body></methods><methods><class-id>Security.DSAPublicKey</class-id> <category>x509</category><body package="X509" selector="asX509Key">asX509Key	^self asX509PublicKey</body><body package="X509" selector="asX509PublicKey">asX509PublicKey	^Security.X509.X509DSAPublicKey new		publicKey: y;		dssParameters: (Security.X509.DSSParameters p: p q: q g: g);		yourself</body></methods><methods><class-id>Security.RSA class</class-id> <category>x509</category><body package="X509" selector="rsaEncryptionOID">rsaEncryptionOID	^ASN1.ObjectIdentifier value: #(1 2 840 113549 1 1 1)</body></methods><methods><class-id>Security.RSA</class-id> <category>x509</category><body package="X509" selector="x509AlgorithmIdentifier">x509AlgorithmIdentifier	^hash x509RSAAlgorithmIdentifier</body><body package="X509" selector="x509AlgorithmOID">x509AlgorithmOID	^self class rsaEncryptionOID</body><body package="X509" selector="x509AsAlgorithm">x509AsAlgorithm	^self</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>x509</category><body package="X509" selector="asX509Key">asX509Key	^Security.X509.X509RSAPrivateKey new		privateExponent: d;		modulus: n;		publicExponent: e;		prime1: p;		prime2: q;		exponent1: self dp;		exponent2: self dq;		coefficient: self qInv;		yourself</body><body package="X509" selector="x509AsAlgorithm">x509AsAlgorithm	^RSA new		privateKey: self;		yourself</body></methods><methods><class-id>Security.DSASignature</class-id> <category>x509</category><body package="X509" selector="asX509Signature">asX509Signature	^Security.X509.DSSSignatureValue new		r: r;		s: s;		yourself</body></methods><methods><class-id>Security.MD5</class-id> <category>x509</category><body package="X509" selector="x509RSAAlgorithmIdentifier">x509RSAAlgorithmIdentifier	^Security.X509.AlgorithmIdentifier md5WithRSAEncryption</body></methods><methods><class-id>Security.SHA</class-id> <category>x509</category><body package="X509" selector="x509RSAAlgorithmIdentifier">x509RSAAlgorithmIdentifier	^Security.X509.AlgorithmIdentifier sha_1WithRSAEncryption</body></methods><methods><class-id>ASN1.BitString</class-id> <category>x509 extensions</category><body package="X509" selector="clearAllBits">clearAllBits	self bytes: (ByteArray new: self bytes size)</body><body package="X509" selector="getBitStringAsFormattedHexStrings">getBitStringAsFormattedHexStrings	^self value asFormattedHexStrings</body></methods><initialize><class-id>Security.X509.X509Object</class-id></initialize><initialize><class-id>Security.X509.Validity</class-id></initialize><initialize><class-id>Security.X509.Extension</class-id></initialize><initialize><class-id>Security.X509.SubjectKeyIdentifier</class-id></initialize><initialize><class-id>Security.X509.Name</class-id></initialize><initialize><class-id>Security.X509.DSSParameters</class-id></initialize><initialize><class-id>Security.X509.KeyUsage</class-id></initialize><initialize><class-id>Security.X509.TBSCertificate</class-id></initialize><initialize><class-id>Security.X509.X509DSAPublicKey</class-id></initialize><initialize><class-id>Security.X509.DSSSignatureValue</class-id></initialize><initialize><class-id>Security.X509.NoExtensionSupport</class-id></initialize><initialize><class-id>Security.X509.AttributeValueAssertion</class-id></initialize><initialize><class-id>Security.X509.X509RSAPublicKey</class-id></initialize><initialize><class-id>Security.X509.BasicConstraints</class-id></initialize><initialize><class-id>Security.X509.X509RSAPrivateKey</class-id></initialize><initialize><class-id>Security.X509.AlgorithmIdentifier</class-id></initialize><initialize><class-id>Security.X509.SubjectPublicKeyInfo</class-id></initialize><initialize><class-id>Security.X509.X509DSAPrivateKey</class-id></initialize><initialize><class-id>Security.X509.Certificate</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DSA</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sha privateKey publicKey random </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><class><name>TypeWrapper</name><environment>ASN1</environment><super>Protocols.MessageForwarder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Choice</name><environment>ASN1</environment><super>ASN1.TypeWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>choice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>RSA</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>privateKey publicKey hash </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>DSAPublicKey</name><environment>Security</environment><super>Security.DSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>DSAPrivateKey</name><environment>Security</environment><super>Security.DSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><class><name>ObjectIdentifier</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>RSAPublicKey</name><environment>Security</environment><super>Security.RSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>e </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>SHA</name><environment>Security</environment><super>Security.SHAHash</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t k </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>SHA</package></attributes></class><class><name>BitString</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unused </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>MD5</name><environment>Security</environment><super>Security.Hash</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b c d aa bb cc dd f ff m </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>MD5</package></attributes></class><class><name>RSAPrivateKey</name><environment>Security</environment><super>Security.RSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>d e p q dP dQ qInv otherFactors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>DSASignature</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>r s </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class></st-source>