<?xml version="1.0"?><st-source><!-- Name: DHNotice: Copyright © 2008 Cincom Systems, Inc.  All Rights Reserved.Comment: This package implements the Diffie-Hellman algorithm as described in RFC2631 (http://www.ietf.org/rfc/rfc2631.txt). Specifically, generation of the shared secret is implemented, but not the rest of the specification dealing with the key derivation process. This implementation can be used to establish a shared secret between two parties over an insecure communication channel. Note, however, that this algorithm only protects against eaves-dropping attacks; it cannot protect against an active man-in-the-middle attack where the adversary is able to modify messages in transit. An additional authentication mechanism must be employed to prevent such attacks.The algorithm is represented by class DH. Necessary algorithm parameters can be generated using DHParameterGenerator. See the class comments for more details.DbIdentifier: bear73DbTrace: 81606DevelopmentPrerequisites: #(#(#package 'CiphersBase' '') #(#package 'SHA' ''))PackageName: DHParcel: #('DH')PrerequisiteParcels: #(#('CiphersBase' '') #('SHA' ''))PrintStringCache: (751 0,mkobetic)Version: 7.6Date: 12:31:43 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 12:31:43 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DHInvalidGroupParameters</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHInvalidGroupParameters</class-id><body>RFC2631 requires that the group parameters are large primes such that q divides p - 1, i.e. there is such j &gt; 1, that p=q*j + 1. The primary purpose of the validation is to prevent a so called 'small subgroup attack' on the sender's key pair. If this is not the case this exception is signaled.</body></comment><class><name>DHInvalidPublicKey</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHInvalidPublicKey</class-id><body>RFC2631 suggests that received public key y, is validated using following criteria:	1) 1 &lt; y &lt; p-1	2) y^g mod p = 1This error is signaled when the public key doesn't meet this criteria.</body></comment><class><name>DHError</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHError</class-id><body>Generic superclass for DH errors</body></comment><class><name>DH</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>p q g random x y </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DH</class-id><body>This is an implementation of the Diffie-Hellman algorithm as described in RFC2631 (http://www.ietf.org/rfc/rfc2631.txt). Specifically, generation of the shared secret is implemented, but not the rest of the specification dealing with the key derivation process. For consistency, the terminology (parameter names) in RFC2631 is reused here. This implementation can be used to establish a shared secret between two parties over an insecure communication channel. Note, however, that this algorithm only protects against eaves-dropping attacks; it cannot protect against an active man-in-the-middle attack where the adversary is able to modify messages in transit. An additional authentication mechanism must be employed to prevent such attacks.Obtaining a shared secrent using the DH computation consists of several steps.  First, both parties agree on a set of algorithm parameters (p, q and g) each will use for the computations. Next, these parameters are used by each party to generate a private value x and a public value y.  The parties exchange their public y values, and use them to separately compute the shared secret.  The shared secret is not easily broken because neither the private x values nor the shared secret itself are exposed in open communication.  Finally, the shared secret is used by each party to generate the same secret key.  Again, both parties should have a previous agreement on what method will be used to generate the secret key from the shared secret. Usually, the secret has to be at least adjusted to the expected key form or size for the target algorithm.The initial algorithm parameters are p, q and g as follows:    p    modulus, a large prime (&gt;=512 bits)    q     order, another large prime (&gt;= 160 bits) such that p=q*j + 1, where j &gt; 1    g    generator, such that g &gt; 1 and g=h^j mod p, where 1 &lt; h &lt; p-1, g has order q mod pThe parameters are generated using a parameter generator. See the class comment of DHParameterGenerator for more details about this process.Parameters can be precomputed (often contained in the subject key of a certificate), in which case an instance of the algorithm can be created as follows:    DH p: p q: q g: gOr they can be generated on the fly as an automatic part of computing a public value, like so:    DH new publicValueIf one party generates the parameters, they have to be communicated to the other party along with the public value. The parameters do not need to be kept secret, so the same insecure channel can be used for the parameters as well. For example, if alice wants to share a secret with bob, alice may generate the parameters automatically as shown above:    alice := DH new.    alicePublic := alice publicValue.Now alice communicates these parameters to bob in some way, as appropriate for the particular application:    dhParameters := Protocols.Struct new p: alice p; q: alice q; g: alice g; yourself.    &lt;alice send: dhParameters to: bob&gt;and bob uses the parameters generated by alice to compute his own public value:    bob := DH p: dhParameters p q: dhParameters q g: dhParameters g.    bobPublic := bob publicValue.Now each party sends its public value to the other party, again using some appropriate form of communication. Each party can then compute a shared secret using the other party's public value:    aliceSecret := alice sharedSecretUsing: bobPublic.    bobSecret := bob sharedSecretUsing: alicePublic.Neither the private value x nor the shared secret is communicated, which makes the secret difficult to discover, even if p, q, g, and the two public values y are known. But the computational process guaranties that both alice and bob obtain the same secret value:    aliceSecret = bobSecretThe size (number of bits) of the parameters (especially p) affect the level of security.  Here are some important points to remember:    - the size of p must be at least 512 bits    - the size of p should at least 1024 bits to be considered strong    - the size of q must be at least 160 bits    - the size of q should be at least twice the size of the key that will be generated from the shared secretSo for 64-bit keys, the minimum of 160-bits for q is plenty. However, 128-bit keys should use a q of at least 256 bits.Note that the public value y and the shared secret are the same size as p, and the size of the private key x is up to the size of q. So the key lengths can be tuned by providing apropriately sized p and q. If the DH algorithm is instantiated without the q parameter, as is done in SSL key exchanges, it can still perform the shared secret computation. However, it will generate the private value x at roughly the same size as p. That makes the computation much slower. If we take the case of 160-bit long q and 1024-bit p, the algorithm will perform about 6-times faster than using 1024-bit p without q.Ensuring the ability to use even bigger keys is also recommended, even if it would reduce the performance of current systems below desired levels. Since future research breakthroughs could weaken the strength of the algorithm, switching to longer keys at that point can buy some time to adapt to the resulting security threats.Instance Variables:    p    &lt;LargePositiveInteger&gt; large prime (512bits or more)    q    &lt;LargePositiveInteger&gt; large prime (160-bits or more), such that p=q*j + 1, where j &gt;= 2    g    &lt;Integer&gt; the generator, such that g &gt; 1 and g=h^((p-1)/q)) mod p, where 1 &lt; h &lt; p-1,    random    &lt;Random&gt; generator for private values x    x    &lt;LargePositiveInteger&gt; randomly generated private key, should be 1 &lt; x &lt; q - 1    y    &lt;LargePositiveInteger&gt; public key, such that y = g^x mod p.Class Instance Variables:    random    &lt;Random&gt; the default random generator</body></comment><class><name>DHParameterGenerator</name><environment>Security</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>m l random primalityTest sha q p g seed counter </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHParameterGenerator</class-id><body>This is the generator for Diffie-Hellman algorithm parameters p, q and g as described in RFC2631 (http://www.ietf.org/rfc/rfc2631.txt). Parameter q has to be generated first, then parameter p and finally parameter g. An instance of the generator has to be instructed what is the expected bit size of the parameters. The bit-size of q is referred to as m and the bit-size of p is referred to as l. The bit-size of g can be anywhere up to the size of p. Following expression creates a generator for q of size 256 bits and p of size 1024 bits:    generator := DHParameterGenerator m: 256 l: 1024.Parameters are generated automatically when accessed.    p := generator p.    q := generator q.    g := generator g.The parameters are cached, so the accessors will keep returning the same values until the generator is flushed. Flushing resets the generated values, which will be regenerated the next time they are accessed. The generator also answers #seed and #counter which can be used by other parties to verify the quality (cryptographic strength) of the parameters.The generator makes use of an algorithm for testing primality of large numbers and a random number generator. In the default configuration it uses the algorithms described by the RFC, however it is possible to configure the generator with other algorithms if necessary. See methods #m:l:random: and #m:l:random:primalityTest: for details.Since generation can take quite some time, events are triggered to indicate progress. See the class method #eventsTriggered for details.See also the class comment for DH for more details about the algorithm, especially on recommended sizes of parameters.Instance Variables:	m	&lt;SmallInteger&gt; the bit-length of q (minimum 160)	l	&lt;SmallInteger&gt; the bit-length of p (minimum 512)	random	&lt;Random&gt; a random seed generator producing large intergers of at least m-bit size	primalityTest	&lt;PrimalityTest&gt; a probabilistic primality test, with error probability less than 1/(4^50)	sha	&lt;SHA&gt; an instance of the hash function	q	&lt;LargeInteger&gt; order, a large prime of bit-length m	p	&lt;LargeInteger&gt; modulus, a large prime of bit-length l, such that p=jq+1, where j &gt; 1	g	&lt;Integer&gt; generator, such that g &gt; 1 and g=h^j mod p, where 1 &lt; h &lt; p-1; i.e. g has order q mod p	seed	&lt;LargeInteger&gt; the seed used to generate q	counter	&lt;SmallInteger&gt; the counter value that yielded pClass Instance Variables:	random	&lt;Random&gt; the default random generator</body></comment><methods><class-id>Security.DHInvalidGroupParameters class</class-id> <category>testing</category><body package="DH" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Security.DHInvalidPublicKey class</class-id> <category>testing</category><body package="DH" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Security.DH</class-id> <category>accessing</category><body package="DH" selector="g">g	^g</body><body package="DH" selector="p">p	^p</body><body package="DH" selector="privateKey">privateKey	^x ifNil: [ self generateX ]</body><body package="DH" selector="privateKey:">privateKey: aPrivateKey	self shouldNotImplement</body><body package="DH" selector="publicKey">publicKey	^y ifNil: [ self generateY ]</body><body package="DH" selector="publicKey:">publicKey: aPublicKey	self shouldNotImplement</body><body package="DH" selector="q">q	^q</body><body package="DH" selector="random">random	^random ifNil: [random := self defaultRandom]</body><body package="DH" selector="x">x	^x</body><body package="DH" selector="y">y	^y</body></methods><methods><class-id>Security.DH</class-id> <category>initialization</category><body package="DH" selector="p:g:">p: modulus g: generator	p := modulus.	g := generator</body><body package="DH" selector="p:q:g:">p: modulus q: order g: generator	| j |	j := (modulus - 1)/order.	(j isInteger and: [j &gt; 1]) ifFalse: [		DHInvalidGroupParameters			raiseWith: (Array with: p with: q)			errorString: (#BadGroupParameters &lt;&lt; #security &gt;&gt; 'The group parameters do not meet RFC2631 criteria!') ].	q := order.	self p: modulus g: generator</body><body package="DH" selector="random:">random: aRandom	random := aRandom</body><body package="DH" selector="x:y:">x: aPrivateNumber y: aPublicNumber"This is for using predefined keys, e.g. from DH certificates and such.Note that x and y are required to satisfy y=g^x mod p"	x := aPrivateNumber.	y := aPublicNumber</body></methods><methods><class-id>Security.DH</class-id> <category>deprecated</category><body package="DH" selector="computeG">computeG	| j h |	j := (p - 1)/q.	h := 1.	[	h := h + 1.		(g := h raisedTo: j modulo: p) = 1	] whileTrue.	^g</body><body package="DH" selector="computePublicKey">computePublicKey"This is the first phase of the handshake, where the publicly exchanged value is generated"	^self computePublicValue</body><body package="DH" selector="computePublicValue">computePublicValue"This is the first phase of the handshake, where the publicly exchanged value is generated"	^self publicValue</body><body package="DH" selector="computeSharedSecretUsing:">computeSharedSecretUsing: aPublicKey"This is the second phase of the handshake where the shared secret is generatedusing the public value received from the other party"		^self sharedSecretUsing: aPublicKey</body><body package="DH" selector="p:q:">p: modulus q: order"This method was based on the assumption that the generator parameter g is produced deteministically and therefore can be reliably derived from the p and q parameters. However, properly it should be a random choice over a specified interval and thust the assumption is not valid. That's why this API is being deprecated."	self p: modulus q: order g: nil.	g := self computeG</body></methods><methods><class-id>Security.DH</class-id> <category>services</category><body package="DH" selector="decrypt:">decrypt: aByteArray"Decrypt aByteArray using the previously assigned private key."	"This algorithm doesn't support encryption"	^self shouldNotImplement</body><body package="DH" selector="encrypt:">encrypt: aByteArray"Encrypts aByteArray using the previously assigned public key"	"This algorithm doesn't support encryption"	^self shouldNotImplement</body><body package="DH" selector="flush">flush"Flush the keys so that the next call to computePublicKey generates new ones"	x := y := nil</body><body package="DH" selector="publicValue">publicValue"This is the first phase of the handshake, where the publicly exchanged value is generated"	^self publicKey</body><body package="DH" selector="sharedSecretUsing:">sharedSecretUsing: aPublicValue"This is the second phase of the handshake where the shared secret is generated using the public value received from the other party"		(1 &lt; aPublicValue and: [ aPublicValue &lt; p ]) ifFalse: [		DHInvalidPublicKey new			messageText: (#PublicValueOutOfRange &lt;&lt; #security &gt;&gt; 'Public value out of required range &lt;1; p - 1&gt;!');			parameter: aPublicValue;			raiseSignal ].	"This is required check as per RFC2631, section 2.1.5"	(q isNil or: [ (aPublicValue raisedTo: q modulo: p) = 1 ]) ifFalse: [		DHInvalidPublicKey new			messageText: (#PublicValueVulnerable &lt;&lt; #security &gt;&gt; 'Public value possibly vulnerable');			parameter: aPublicValue;			raiseSignal ].	^aPublicValue raisedTo: x modulo: p</body><body package="DH" selector="sign:">sign: aMessageArray"Compute a signature of aMessageArray."	"This algorithm doesn't support signing"	^self shouldNotImplement</body><body package="DH" selector="verify:of:">verify: aSignatureArray of: aMessageArray"Denies or confirms that aSignatureArray is a signature of aMessageArray."	"This algorithm doesn't support signing"	^self shouldNotImplement</body></methods><methods><class-id>Security.DH</class-id> <category>private</category><body package="DH" selector="defaultRandom">defaultRandom	^self class random</body><body package="DH" selector="generateParameters">generateParameters	| generator |	generator := DHParameterGenerator m: 160 l: 512.	self p: generator p q: generator q g: generator g</body><body package="DH" selector="generateX">generateX	| mod |	p ifNil: [ self generateParameters ].	mod := q ifNil: [ p ].	x := self nextRandomSize: mod basicSize.	x := x \\ mod.	" the x from [ 2, q - 2 ] constraint is from section 2.2.  Key and Parameter Requirements"	^( x between: 2 and: mod - 2 )		ifTrue: [ x ]		ifFalse: [ self generateX ]</body><body package="DH" selector="generateY">generateY	x ifNil: [ self generateX ].	^y := g raisedTo: x modulo: p</body><body package="DH" selector="nextRandomSize:">nextRandomSize: size"	size &lt;Integer&gt; size in bytes"	x := self random next.	[ x basicSize &lt; size ] whileTrue: [ | chunk |		chunk := self random next.		x := (x bitShift: (chunk basicSize * 8)) bitOr: chunk ].	^x basicSize &gt; size		ifTrue: [ x bitShift: (size - x basicSize) * 8 ]		ifFalse: [ x ]</body></methods><methods><class-id>Security.DH class</class-id> <category>accessing</category><body package="DH" selector="defaultRandom">defaultRandom	^DSSRandom default</body><body package="DH" selector="random">random	^random ifNil: [ self defaultRandom ]</body><body package="DH" selector="random:">random: aRandom"Set the default random generator for DH algorithms.	aRandom &lt;Random&gt; secure random generator"	random := aRandom</body></methods><methods><class-id>Security.DH class</class-id> <category>instance creation</category><body package="DH" selector="newFrom:">newFrom: generator"This is useful when the parameters are generated on the fly, it makes sense to reuse the random generator that was used to generate the parameters"	^(self		p: generator p		q: generator q		g: generator g	)	random: generator random;		yourself</body><body package="DH" selector="p:g:">p: modulus g: generator"	modulus	&lt;LargePositiveInteger&gt;	must be a large prime (512 bits and more).	generator	&lt;Integer&gt;	must be an integer, such that g &gt; 1 and g=h^((p-1)/q)) mod p,			where 1 &lt; h &lt; p-1 (g has order q mod p, i.e. g^q mod p = 1)"	^self new		p: modulus g: generator;		yourself</body><body package="DH" selector="p:q:g:">p: modulus q: order g: generator"	modulus	&lt;LargePositiveInteger&gt;	must be a large prime (512 bits and more).	order	&lt;LargePositiveInteger&gt;	must be a large prime (160 bits and more) that divides (modulus - 1)	generator	&lt;Integer&gt;	must be an integer, such that g &gt; 1 and g=h^((p-1)/q)) mod p,			where 1 &lt; h &lt; p-1 (g has order q mod p, i.e. g^q mod p = 1)"	^self new		p: modulus q: order g: generator;		yourself</body></methods><methods><class-id>Security.DH class</class-id> <category>deprecated</category><body package="DH" selector="p:q:">p: modulus q: order"This method was based on the assumption that the generator parameter g is produced deteministically and therefore can be reliably derived from the p and q parameters. However, properly it should be a random choice over a specified interval and thust the assumption is not valid. That's why this API is being deprecated.	modulus must be a large prime (512 bits and more).	order must be a large prime (160 bits and more) that divides (modulus - 1)"	^self new		p: modulus q: order;		yourself</body></methods><methods><class-id>Security.DHParameterGenerator</class-id> <category>accessing</category><body package="DH" selector="counter">counter	^counter</body><body package="DH" selector="g">g	g ifNil: [ self generateG ].	^g</body><body package="DH" selector="l">l	^l</body><body package="DH" selector="l:">l: anObject	l := anObject</body><body package="DH" selector="m">m	^m</body><body package="DH" selector="m:">m: anObject	m := anObject</body><body package="DH" selector="p">p	p ifNil: [ self generateP ].	^p</body><body package="DH" selector="primalityTest">primalityTest	^primalityTest</body><body package="DH" selector="primalityTest:">primalityTest: anObject	primalityTest := anObject</body><body package="DH" selector="q">q	q ifNil: [ self generateQ ].	^q</body><body package="DH" selector="random">random	^random</body><body package="DH" selector="random:">random: anObject	random := anObject</body><body package="DH" selector="seed">seed	^seed</body><body package="DH" selector="seed:">seed: anObject	seed := anObject</body><body package="DH" selector="sha">sha	^sha</body><body package="DH" selector="sha:">sha: anObject	sha := anObject</body></methods><methods><class-id>Security.DHParameterGenerator</class-id> <category>initialization</category><body package="DH" selector="m:l:">m: qLength l: pLength"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512"	self m: qLength l: pLength random: self defaultRandom</body><body package="DH" selector="m:l:random:">m: qLength l: pLength random: aRandom"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512	aRandom	&lt;Random&gt; a random seed generator producing large intergers of size &gt;= m bits"	self m: qLength l: pLength random: aRandom primalityTest: (self defaultPrimalityTestUsing: aRandom)</body><body package="DH" selector="m:l:random:primalityTest:">m: qLength l: pLength random: aRandom primalityTest: pTest"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512	aRandom	&lt;Random&gt; a random seed generator producing large intergers of size &gt;= m bits	pTest	&lt;PrimalityTest&gt; a probabilistic primality test, with error probability less than 1/4^50"	m := qLength.	l := pLength.	random := aRandom.	primalityTest := pTest.	sha := SHA new.</body></methods><methods><class-id>Security.DHParameterGenerator</class-id> <category>services</category><body package="DH" selector="flush">flush"Flush all the parameters to make sure next generation creates new ones"	q := p := seed := counter := nil</body><body package="DH" selector="generateG">generateG	| j h |	p ifNil: [self generateP].	j := (p - 1)/q.	[	h := self nextH.		(g := h raisedTo: j modulo: p) = 1	] whileTrue.	^g</body><body package="DH" selector="generateP">generateP"Generates parameter P and a counter value. RFC2631, Section 2.2.1.1"	| mp2 lp n power power2 r v w x q2 |	q ifNil: [ self generateQ ].	mp2 := (m / 160) ceiling * 2.	lp := (l / 160) ceiling.	n := (l / 1024) ceiling * 4096.	power := 2 raisedTo: l - 1.	power2 := power * 2.	counter := 0.	q2 := q * 2.	[ n &gt; counter ] whileTrue: [		r := seed + mp2 + (lp * counter).		v := 0.		0 to: lp - 1 do: [ :i |			v := ((sha hashInteger: r + i) bitShift: 160 * i) + v ].		w := v \\ power2.		x := w bitOr: power.		p := x - (x \\ q2) + 1.		self triggerEvent: #tryingP:counter: with: p with: counter.		(p &gt; power and: [ primalityTest value: p ]) ifTrue: [			self triggerEvent: #foundP:counter: with: p with: counter.			^self ].		counter := counter + 1 ].	^DHError raiseSignal: (#ParameterGenerationFailed &lt;&lt; #security &gt;&gt; 'Failed to generate parameters !')</body><body package="DH" selector="generateQ">generateQ"Generates a seed and parameter Q. RFC2631, Section 2.2.1.1"	| mp u power qAndMask qOrMask |	p := counter := nil.	mp := (m / 160) ceiling.	power := 2 raisedTo: m - 1.	qAndMask := power * 2 - 1.	qOrMask := power bitOr: 1.	[	seed := self newSeed.		u := 0.		0 to: mp - 1 do: [ :i |			u := (	(	(sha hashInteger: seed + i)						bitXor: (sha hashInteger: seed + mp + i)					) bitShift: 160 * i				) bitOr: u ].		q := (u bitAnd: qAndMask) bitOr: qOrMask.		self triggerEvent: #tryingQ:seed: with: q with: seed.		primalityTest value: q	] whileFalse.	self triggerEvent: #foundQ:seed: with: q with: seed</body></methods><methods><class-id>Security.DHParameterGenerator</class-id> <category>private</category><body package="DH" selector="defaultPrimalityTestUsing:">defaultPrimalityTestUsing: aRandom	^PrimeSieve on: (MillerRabin random: aRandom)</body><body package="DH" selector="defaultRandom">defaultRandom	^self class random</body><body package="DH" selector="newSeed">newSeed"RFC2631, Section 2.2.1.1, Step 4. Select an arbitrary bit string SEED such that the length of SEED &gt;= m"	| newSeed |	newSeed := random next.	"Need at least m random bits"	[ newSeed highBit &lt; m ] whileTrue: [ | chunk |		chunk := random next.		newSeed := (newSeed bitShift: chunk highBit) bitOr: chunk ].	^newSeed</body><body package="DH" selector="nextH">nextH"RFC2631, Section 2.2.1.2, step 2. Set h = any integer, where 1 &lt; h &lt; p - 1 and h differs from any value previously tried.Note that we're relying on the quality of the random generator here. Given that secure generators have to have an extremely long period the chances that a value would be repeated are fairly slim."	| h |	h := random next.	"Need l random bits"	[ h basicSize * 8 &lt; l ] whileTrue: [ | chunk |		chunk := random next.		h := (h bitShift: chunk basicSize * 8) bitOr: chunk ].	h := h basicSize * 8 &gt; l			ifTrue: [ h bitShift: l - (h basicSize * 8) ]			ifFalse: [ h ].	^(h between: 2 and: p - 2)		ifFalse: [ self nextH ]		ifTrue: [ h ]</body></methods><methods><class-id>Security.DHParameterGenerator class</class-id> <category>events</category><body package="DH" selector="eventsTriggered">eventsTriggered	^#(	tryingQ:seed:		foundQ:seed:		tryingP:counter:		foundP:counter:)</body></methods><methods><class-id>Security.DHParameterGenerator class</class-id> <category>instance creation</category><body package="DH" selector="m:l:">m: qLength l: pLength"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512"	^self new m: qLength l: pLength</body><body package="DH" selector="m:l:random:">m: qLength l: pLength random: aRandom"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512	aRandom	&lt;Random&gt; a random seed generator producing large intergers of size &gt;= m bits"	^self new m: qLength l: pLength random: aRandom</body></methods><methods><class-id>Security.DHParameterGenerator class</class-id> <category>accessing</category><body package="DH" selector="defaultRandom">defaultRandom	^DSSRandom default</body><body package="DH" selector="random">random	^random ifNil: [ self defaultRandom ]</body><body package="DH" selector="random:">random: aRandom"Set the default random generator for DH parameter generators.	aRandom &lt;Random&gt; secure random generator"	random := aRandom</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>EventManager</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>AsymmetricCipher</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class></st-source>