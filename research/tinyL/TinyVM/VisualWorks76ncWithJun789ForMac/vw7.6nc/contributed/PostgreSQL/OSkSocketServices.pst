<?xml version="1.0"?><st-source><!-- Name: OSkSocketServicesComment: Copyright @2006 Bruce BadgerMade available under the LGPL This package contains socket support classesDbIdentifier: openskills.org-20070415DbTrace: 9428DevelopmentPrerequisites: #(#(#any 'OSkLogger' ''))PackageName: OSkSocketServicesParcel: #('OSkSocketServices')PrerequisiteParcels: #(#('OSkLogger' ''))PrintStringCache: (1 013,bbadger)Date: 11:37:31 pm November 22, 2007 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.5.1 (nov07.2) of November 12, 2007 on November 22, 2007 at 11:37:31 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OSkSocketStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingSocket bufferSize observer timer </inst-vars><class-inst-vars>log </class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketStream</class-id><body>OSkSocketStreams are just helpers for sockets that allow a socket to be though of as a pair of streams, one for reading and one for writing.Sockets only handle bytes.  So all elements read and written must be bytes - no characters.Note that there is something of a tension between the idea of bytes and the idea of octets.  Octets have a clear definition, they are always exactly eight bits long.  The concept of byte is really one associated with CPU architechture.  BSD sockets seem to assume that bytes are always octets, and as were are implementing BSD sockets here we will talk about bytes, and not octets ... even though standards like HTTP call for octets (sigh).Note that socket streams only support a small subset of the things you can do with normal sockets.  You can't position them for example, so no &gt;&gt;reset.  No skipping, but peeking is OK.</body></comment><class><name>OSkSocketTimer</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentMilliseconds incrementInMilliseconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketTimer</class-id><body>OSkSocketTimer is the abscract superclass of times for sockets.  These are used to set and handle timeouts.</body></comment><class><name>OSkSocketUnlimitedTimer</name><environment>Smalltalk</environment><super>OSkSocketTimer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketUnlimitedTimer</class-id><body>OSkSocketUnlimitedTimer is a no-op, really.  It has no limit but it does keep track of the current number of milliseconds we have been waiting for a socket to do something intersting (like accept or deliver bytes).</body></comment><class><name>OSkSocketObserver</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketObserver</class-id><body>OSkSocketMonitor watches the traffic flowing through a socket stream and generates log entries which it submits to an OSkLogSwitch which in turn sends the entries to various media.</body></comment><class><name>OSkActiveSocketObserver</name><environment>Smalltalk</environment><super>OSkSocketObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetLogSwitch isLoggingReads currentLogEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><class><name>OSkSocketReadStream</name><environment>Smalltalk</environment><super>OSkSocketStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferArray lastByteIndex position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketReadStream</class-id><body>c.f. OSkSocketStream comentOSKSocketReadStreams make available bytes from an OSkSocket in a stream like fassion, e.g. &gt;&gt;next returns the next byte.</body></comment><class><name>OSkSocketTimerException</name><environment>Smalltalk</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkSocketServices</category><attributes><package>OSkSocketServices</package></attributes></class><class><name>OSkSocketListenerService</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostName portNumber socketClass socket acceptedConnections acceptInForeground multiThreading stopRequested messagesLog socketObserver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketListenerService</class-id><body>OSkSocketListenerService is an abstract superclass for services that listen on sockets, accept inbound connections and handle requests that come in over those connections.</body></comment><class><name>OSkNilSocketObserver</name><environment>Smalltalk</environment><super>OSkSocketObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><class><name>OSkSocketLimitedTimer</name><environment>Smalltalk</environment><super>OSkSocketTimer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maximumMiliseconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketLimitedTimer</class-id><body>OSkSocketLimitedTimer tracks the number of milliseconds and throws an exception if the current number of milliseconds exceeds the limit.</body></comment><class><name>OSkSocketInboundConnection</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket server </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketInboundConnection</class-id><body>OSkSocketInboundConnection instances represent the connections made by clents to a service.  For example, an HTTPServer listens on a socket and someone uses a web browser to connect to the server.  The server will "accept" the inbound connection as a result of which a new socket is created - this is the socket over which the HTTP (in our example) will flow.  Instances of this class manage the conversation over that client socket. </body></comment><class><name>OSkSocketWriteStream</name><environment>Smalltalk</environment><super>OSkSocketStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferArray bufferWriteStream bufferStartIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>OSkSocketServices</package></attributes></class><comment><class-id>OSkSocketWriteStream</class-id><body>c.f. OSkSocketStream comentOSKSocketWriteStreams write bytes to an OSkSocket in a stream like fassion, e.g. &gt;&gt;nextPut: 42 writes the a byte with value 42 to the socket.</body></comment><methods><class-id>OSkSocketStream</class-id> <category>accessing</category><body package="OSkSocketServices" selector="bufferSize">bufferSize	"^an IntegerI return the target size of my buffer in bytes.  This is the nominal size.  My subclasses may use more space for the buffer if it makes sense."	bufferSize isNil ifTrue: [bufferSize := self class defaultBufferSize].	^bufferSize</body><body package="OSkSocketServices" selector="bufferSize:">bufferSize: anInteger 	"^selfMy subclasses must implement this."	^self subclassResponsibility</body><body package="OSkSocketServices" selector="timer">timer	"^an OSkSocketTimerI return the timer I use to track how long I have been waiting for my underlying socket give a useful respons (either accepting or delivering bytes).  By default this is a limited time, i.e. I will only wait for a limited time before a timeout exception is thrown."	timer isNil ifTrue: [timer := OSkSocketLimitedTimer new].	^timer</body><body package="OSkSocketServices" selector="timer:">timer: aSocketTimer 	"^selfI record my timer.  c.f. &gt;&gt;timer."	timer := aSocketTimer.	^self</body><body package="OSkSocketServices" selector="underlyingSocket">underlyingSocket	"^an OSkSocketI return the OSkSocket that I am a stream for."	^underlyingSocket</body></methods><methods><class-id>OSkSocketStream</class-id> <category>defaults</category><body package="OSkSocketServices" selector="bufferSizeCeiling">bufferSizeCeiling	"^an IntegerBuffers can grow.  I return the size beyond which buffers may be shrunk back to the initial size."	^self bufferSize * self bufferSizeCeilingFactor</body><body package="OSkSocketServices" selector="bufferSizeCeilingFactor">bufferSizeCeilingFactor	"^an IntegerBuffers can grow, and are allowed until they are x times their nominal size.  This factor is the x.  c.f. class&gt;&gt;defaultBufferSizeCeilingFactor"	^self class defaultBufferSizeCeilingFactor</body><body package="OSkSocketServices" selector="defaultBufferSize">defaultBufferSize	^self class defaultBufferSize</body></methods><methods><class-id>OSkSocketStream</class-id> <category>initialize-release</category><body package="OSkSocketServices" selector="on:">on: anOSkSocket 	"^an OSkSocketStreamI initialize myself as a stream on anOSkSocket."	underlyingSocket := anOSkSocket.	^self</body></methods><methods><class-id>OSkSocketStream</class-id> <category>death row</category><body package="OSkSocketServices" selector="log">log	^SpEnvironment madeObsoleteBy: [self observer]</body><body package="OSkSocketServices" selector="startLoggingTo:">startLoggingTo: aLog 	^SpEnvironment madeObsoleteBy: [self observer: aLog]</body><body package="OSkSocketServices" selector="stopLogging">stopLogging	^SpEnvironment madeObsoleteBy: [self removeCurrentObserver]</body></methods><methods><class-id>OSkSocketStream</class-id> <category>observing</category><body package="OSkSocketServices" selector="observer">observer	"^an HTTPSocketObserverI return my socket observer which is a OSkNilSocketObserver by default."	observer isNil ifTrue: [observer := OSkNilSocketObserver new].	^observer</body><body package="OSkSocketServices" selector="observer:">observer: anObserver 	"^selfI note my new observer which will watch the bytes as they flow through.  If there is already an observer watching me, it is closed before anObserver is assigned."	self removeCurrentObserver.	observer := anObserver.	^self</body><body package="OSkSocketServices" selector="removeCurrentObserver">removeCurrentObserver	"^selfI stop and remove the current observer."	observer notNil 		ifTrue: 			[self observer stopLogging.			observer := nil].	^self</body></methods><methods><class-id>OSkSocketStream</class-id> <category>services</category><body package="OSkSocketServices" selector="close">close	"^selfI close my underlying socket and ask any observer to flush any remaining information."	self underlyingSocket close.	self removeCurrentObserver.	^self</body></methods><methods><class-id>OSkSocketStream class</class-id> <category>defaults</category><body package="OSkSocketServices" selector="defaultBufferSize">defaultBufferSize	"^an IntegerThis is the default size for both the read and write buffers.  We use buffers to make the calls to the actual socket at efficient as possible.20480 is the size used by visual works sockets and streams, so we'll go with that 'till we know better."	^20480</body><body package="OSkSocketServices" selector="defaultBufferSizeCeilingFactor">defaultBufferSizeCeilingFactor	"^an IntegerBuffers can grow. I return the factor by which the buffer can grow without being shrunk again.  So, if the buffer size is set to 1024 and the factor here is 10, the buffer can grow to 10240 before being shrunk back to 1024 again.  The default is 5 at the moment for no particular reason."	^5</body></methods><methods><class-id>OSkSocketStream class</class-id> <category>instance creation</category><body package="OSkSocketServices" selector="on:">on: anOSkSocket 	"^an OSkSocketStreamI return a new instance of one of my subclasses."	^self new on: anOSkSocket</body></methods><methods><class-id>OSkSocketStream class</class-id> <category>logging</category><body package="OSkSocketServices" selector="captureAllSocketActivityWhile:">captureAllSocketActivityWhile: aBlock 	"^an ArrayI capture all socket activity to a string in a form that can be replayed.  I return this array."	1 halt: 'start logging here'.	[aBlock value] ensure: [1 halt: 'shut down the logging here'].	^''</body><body package="OSkSocketServices" selector="log">log	"^an OSkSocketLog or nilThis is the log that will capture traffic on *all* sockets.  Use with care.  If you want to log just a single socket then set the log on that."	^log</body><body package="OSkSocketServices" selector="log:">log: anOSkSocketLog	"^selfI record the log which is to be used to log all OSkSocketStream activity."	^log</body></methods><methods><class-id>OSkSocketTimer</class-id> <category>services</category><body package="OSkSocketServices" selector="increment">increment	"^selfThis is a convinience method for incrementing me by my &gt;&gt;incrementInMilliseconds."	^self incrementBy: self incrementInMilliseconds</body><body package="OSkSocketServices" selector="incrementBy:">incrementBy: aNumberOfMilliseconds 	"^selfI increment the current number of milliseconds by aNumberOfMilliseconds  By subclasses may override this if they want to take special action when the currentMilliseconds reaches or exceeds a particular value (e.g. a timeout)."	currentMilliseconds := self currentMilliseconds + aNumberOfMilliseconds.	^self</body><body package="OSkSocketServices" selector="reset">reset	"^selfI reset the current number of milliseconds."	currentMilliseconds := nil.	^self</body></methods><methods><class-id>OSkSocketTimer</class-id> <category>accessing</category><body package="OSkSocketServices" selector="currentMilliseconds">currentMilliseconds	"^an IntegerI return the current number of milliseconds that have elapsed since I was last reset."	currentMilliseconds isNil ifTrue: [currentMilliseconds := 0].	^currentMilliseconds</body><body package="OSkSocketServices" selector="incrementInMilliseconds">incrementInMilliseconds	"^an IntegerI return the number of milliseconds that I increment by.  This is used as the wait-time parameter when socket streams are reading or writing.  I default to 100 milliseconds."	incrementInMilliseconds isNil ifTrue: [incrementInMilliseconds := 100].	^incrementInMilliseconds</body><body package="OSkSocketServices" selector="incrementInMilliseconds:">incrementInMilliseconds: anObject	incrementInMilliseconds := anObject</body></methods><methods><class-id>OSkSocketObserver</class-id> <category>logging</category><body package="OSkSocketServices" selector="logReadByte:">logReadByte: aByte 	^self subclassResponsibility</body><body package="OSkSocketServices" selector="logReadBytes:">logReadBytes: aByteArray 	^self subclassResponsibility</body><body package="OSkSocketServices" selector="logWrittenByte:">logWrittenByte: aByte 	^self subclassResponsibility</body><body package="OSkSocketServices" selector="logWrittenBytes:">logWrittenBytes: aByteArray 	^self subclassResponsibility</body></methods><methods><class-id>OSkSocketObserver</class-id> <category>initialize-release</category><body package="OSkSocketServices" selector="close">close	self targetLogSwitch close.	^self</body></methods><methods><class-id>OSkActiveSocketObserver</class-id> <category>logging</category><body package="OSkSocketServices" selector="logReadByte:">logReadByte: aByte 	^self logReadBytes: (ByteArray with: aByte)</body><body package="OSkSocketServices" selector="logReadBytes:">logReadBytes: subjectBytes 	"^selfSome bytes have been read so I add them to a log entry.  If the last log activity was a read, we just add the bytes to the current log entry, otherwise we create a new log entry.  This ensures that the reads and writes are always in sepparate log entries."	self isLoggingReads 		ifFalse: 			[self flushLogEntry.			self isLoggingReads: true].	self currentLogEntry addBytes: subjectBytes.	^self</body><body package="OSkSocketServices" selector="logWrittenByte:">logWrittenByte: aByte 	^self logWrittenBytes: (ByteArray with: aByte)</body><body package="OSkSocketServices" selector="logWrittenBytes:">logWrittenBytes: subjectBytes 	"^selfSome bytes have been written so I add them to a log entry.  If the last log activity was a write, we just add the bytes to the current log entry, otherwise we create a new log entry.  This ensures that the reads and writes are always in sepparate log entries."	self isLoggingWrites 		ifFalse: 			[self flushLogEntry.			self isLoggingWrites: true].	self currentLogEntry addBytes: subjectBytes.	^self</body></methods><methods><class-id>OSkActiveSocketObserver</class-id> <category>services</category><body package="OSkSocketServices" selector="flushLogEntry">flushLogEntry	"^selfIt is often useful to break byte logs down into meaningful chunks, such as HTTP messages.  If a log entry exists, I tell it to close and then set the instance variable to nil ... which will mean that a new log entry will be lazily initialized if/when I'm asked for the log entry in the future."	currentLogEntry notNil 		ifTrue: 			[currentLogEntry flushTo: self targetLogSwitch.			currentLogEntry := nil].	^self</body><body package="OSkSocketServices" selector="isLoggingReads">isLoggingReads	^isLoggingReads isNil or: [isLoggingReads]</body><body package="OSkSocketServices" selector="isLoggingReads:">isLoggingReads: aBoolean 	isLoggingReads := aBoolean.	^self</body><body package="OSkSocketServices" selector="isLoggingWrites">isLoggingWrites	^self isLoggingReads not</body><body package="OSkSocketServices" selector="isLoggingWrites:">isLoggingWrites: aBoolean 	self isLoggingReads: aBoolean not.	^self</body><body package="OSkSocketServices" selector="stopLogging">stopLogging	"^selfI stop logging.  I close the current logEntry"	self currentLogEntry flushTo: self targetLogSwitch.	currentLogEntry := nil.	^self</body></methods><methods><class-id>OSkActiveSocketObserver</class-id> <category>accessing</category><body package="OSkSocketServices" selector="currentLogEntry">currentLogEntry	"^an OSkByteLogEntryI return the byte log entry I'm currently writing too.  Note that the log entry will go to the default log (i.e. I don't specify a log when I create an entry)."	currentLogEntry isNil ifTrue: [currentLogEntry := OSkByteArrayLogEntry new].	^currentLogEntry</body><body package="OSkSocketServices" selector="targetLogSwitch">targetLogSwitch	"^an OSkLogSwitchI return the log switch to which I send my log entries for distribution."	^targetLogSwitch</body></methods><methods><class-id>OSkActiveSocketObserver</class-id> <category>initialize-release</category><body package="OSkSocketServices" selector="loggingTo:">loggingTo: aLogSwitch 	targetLogSwitch := aLogSwitch.	^self</body></methods><methods><class-id>OSkActiveSocketObserver class</class-id> <category>instance creation</category><body package="OSkSocketServices" selector="loggingTo:">loggingTo: aLogSwitch 	^self new loggingTo: aLogSwitch</body></methods><methods><class-id>OSkSocketReadStream</class-id> <category>private-buffer</category><body package="OSkSocketServices" selector="bufferArray">bufferArray	"^a ByteArrayI return the current buffer array.  The bufferArray is a ByteArray *within which* is the buffer."	bufferArray isNil ifTrue: [bufferArray := ByteArray new: self bufferSize].	^bufferArray</body><body package="OSkSocketServices" selector="ensureBufferContainsNext:">ensureBufferContainsNext: anInteger 	"^selfI make sure that we have at least anInteger octets in the buffer.  If I don't I extend the buffer just enough so we now have that number of octets available."	| additionalOctetsNeeded |	additionalOctetsNeeded := self position + anInteger - self lastByteIndex.	additionalOctetsNeeded &gt; 0 		ifTrue: 			[1 halt.			self fullBufferFromSocketFrom: self position + 1				for: additionalOctetsNeeded].	^self</body><body package="OSkSocketServices" selector="fillBufferFromSocket">fillBufferFromSocket	"^selfI read as much as I can (up to my buffer size) into my &gt;&gt;bufferArray.  I only return when I have managed to read some bytes."	| startingPosition octetsToRead |	startingPosition := 1.	octetsToRead := self bufferSize.	self fullBufferFromSocketFrom: startingPosition for: octetsToRead.	position := startingPosition - 1.	^self</body><body package="OSkSocketServices" selector="fullBufferFromSocketFrom:for:">fullBufferFromSocketFrom: startingPosition for: octetsToRead 	"^an IntegerI populate my &gt;&gt;bufferArray with octets read from my &gt;&gt;underlyingSocket.  I return the number of octets I was actually able to get."	| actuallyRead |	[self underlyingSocket readyForRead] whileFalse: 			[self underlyingSocket 				waitForReadDataUpToMs: self timer incrementInMilliseconds.			self timer increment].	actuallyRead := self underlyingSocket 				readInto: self bufferArray				startingAt: startingPosition				for: octetsToRead.	actuallyRead isNil ifTrue: [actuallyRead := 0].	lastByteIndex := startingPosition + actuallyRead - 1.	actuallyRead &gt; 0 ifTrue: [self timer reset] ifFalse: [self timer increment].	^actuallyRead</body><body package="OSkSocketServices" selector="incrementPosition">incrementPosition	"^selfI increment the current position in the stream.  This means that the byte at the new position has been 'read', so I log it."	position := position + 1.	^self</body><body package="OSkSocketServices" selector="lastByteIndex">lastByteIndex	"^an IntegerI return the index of the last byte of the actual buffer within my bufferArray."	lastByteIndex isNil ifTrue: [lastByteIndex := 0].	^lastByteIndex</body><body package="OSkSocketServices" selector="nextByte">nextByte	"^selfI return the next byte that will be returned in a read.  The position is not advanced.  It's a peek.  Note that the initial position in the stream in zero, so the 'next' byte is always at the current position + 1."	self position &lt; self lastByteIndex ifFalse: [self fillBufferFromSocket].	^bufferArray at: position + 1</body><body package="OSkSocketServices" selector="position">position	"^an IntegerI return the current position in the buffer."	position isNil ifTrue: [position := 0].	^position</body><body package="OSkSocketServices" selector="read:into:">read: targetNumberOfBytes into: targetStream 	"^selfThe net effect will be that targetNumberOfBytes will be written to targetStream.  I may be able to do this directly from my buffer, but I may have to get more bytes from my underlying socket."	| remaining |	remaining := targetNumberOfBytes.		[| thisChunkSize |	thisChunkSize := remaining min: self lastByteIndex - self position.	thisChunkSize &gt; 0 		ifTrue: 			[position + 1 to: position + thisChunkSize				do: [:bufferIndex | targetStream nextPut: (bufferArray at: bufferIndex)].			position := position + thisChunkSize.			remaining := remaining - thisChunkSize].	remaining &gt; 0] 			whileTrue: [self fillBufferFromSocket].	^self</body><body package="OSkSocketServices" selector="readFromBuffer:">readFromBuffer: targetNumberOfBytes 	"^a ByteArrayI return a ByteArray of length targetNumberOfBytes.  If I have enough bytes in my buffer I can immediately respond, but if not I'll have to call out to the socket for more bytes.  I'll try to fill my buffer, but that's not always possible - I'll take what I can get."	| targetStream |	targetStream := WriteStream on: (ByteArray new: targetNumberOfBytes).	self read: targetNumberOfBytes into: targetStream.	^targetStream contents</body><body package="OSkSocketServices" selector="readNextByte">readNextByte	"^selfI return the next byte from the socket and advance the position."	self position &lt; self lastByteIndex ifFalse: [self fillBufferFromSocket].	self incrementPosition.	^bufferArray at: position</body><body package="OSkSocketServices" selector="readUpTo:into:">readUpTo: aByteValue into: targetStream 	"^selfThe net effect will be an arbitrary number of bytes will be written to targetStream.  I may be able to do this directly from my buffer, but I may have to get more bytes from my underlying socket.I think we have a bug here which could result in the observer being given extra bytes.  If the attempt to &gt;&gt;fillBufferFromSocket yields zero bytes, we *still* assign currentByte and log it through the observer.  This is wrong."	| currentByte |	#wip yourself.	currentByte := nil.	[currentByte == aByteValue] whileFalse: 			[self position &lt; self lastByteIndex ifFalse: [self fillBufferFromSocket].			self incrementPosition.			currentByte := bufferArray at: position.			self observer logReadByte: currentByte.			currentByte == aByteValue ifFalse: [targetStream nextPut: currentByte]].	^self</body><body package="OSkSocketServices" selector="skipPosition:">skipPosition: anInteger 	"^selfUsed by &gt;&gt;upToAll to skip back over the octets in the matched pattern."	| newPosition |	newPosition := self position + anInteger.	(newPosition &lt; 0 or: [newPosition &gt; self lastByteIndex]) 		ifTrue: 			[SpError 				raiseSignal: 'Attempt to move OSkSocketReadStream position out of bounds'].	position := newPosition.	^self</body></methods><methods><class-id>OSkSocketReadStream</class-id> <category>accessing</category><body package="OSkSocketServices" selector="bufferSize:">bufferSize: anInteger 	"^selfI record the target size of my read buffer in bytes.  I read everything from the socket in units of this number, so the absolute smallest size that the buffer can be is one - otherwise I'll be reading zero bytes from the socket forever while achieving nothing.  I'll take any smaller number as being 1.  If this is changed on the fly, the next read from the socket will use the new value."	bufferSize := anInteger max: 1.	^self</body></methods><methods><class-id>OSkSocketReadStream</class-id> <category>services</category><body package="OSkSocketServices" selector="next">next	"^a Byte (well, an Integer)I return the next byte from my underlying socket."	| readByte |	readByte := self readNextByte.	self observer logReadByte: readByte.	^readByte</body><body package="OSkSocketServices" selector="next:">next: targetNumberOfBytes 	"^a ByteArrayI return the next integerNumberOfBytes from my underlying socket.  It may be that in the first call to the socket I don't get all the bytes I want, if this is the case I ask the socket again until I get the number of bytes I need."	^targetNumberOfBytes == 0 		ifTrue: [ByteArray new]		ifFalse: 			[| readBytes |			readBytes := self readFromBuffer: targetNumberOfBytes.			self observer logReadBytes: readBytes.			readBytes]</body><body package="OSkSocketServices" selector="peek">peek	"^a Byte (Integer)I return the next byte from the socket without advancing the current position in the stream."	^self nextByte</body><body package="OSkSocketServices" selector="upTo:">upTo: aByteValue 	"^a ByteArrayI return a ByteArray which contains the contents of my underlying socket from the current position up to the first occurance of aByteValue.  I do not include the the detected aByteValue in the returned ByteArray, but I do log it.  The position is left *after* the detected aByteValue"	| targetStream readBytes |	targetStream := WriteStream on: (ByteArray new: 128).	self readUpTo: aByteValue into: targetStream.	readBytes := targetStream contents.	^readBytes</body><body package="OSkSocketServices" selector="upToAll:">upToAll: goal 	"^a ByteArrayI return the octets from my octetStream upto but excluding the octets in soughtByteArray.  Notice that a socket stream has no end so if the goal is not found and the other end of the socket stops sending bytes the search will just hang until the socket conneciton times out.  Also note I need to finishi with my position immediately *before* the goal patter and since  this algorythm reads through the goal pattern when we have confirmed a match we need to wind back both my position in the buffer and the targetStream."	| targetStream readBytes goalIndex |	targetStream := WriteStream on: (ByteArray new: 1024).		[self readUpTo: (goal at: (goalIndex := 1)) into: targetStream.	targetStream nextPut: (goal at: goalIndex).	self ensureBufferContainsNext: goal size - 1.		[goalIndex &lt; goal size and: 			[(targetStream nextPut: self next) 				== (goal at: (goalIndex := goalIndex + 1))]] 			whileTrue: [].	goalIndex &lt; goal size] 			whileTrue: 				["So, we found the first octet match, but not the rest so we need to unwind the rest and try again"				targetStream skip: 1 - goalIndex.				self skipPosition: 1 - goalIndex].	targetStream skip: goal size negated.	self skipPosition: goal size negated.	readBytes := targetStream contents.	self observer logReadBytes: readBytes.	^readBytes</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>accessing</category><body package="OSkSocketServices" selector="acceptInForeground">acceptInForeground	"^a BooleanI answer true if the main accept loop (accepting inbound connections from my socket) happend in the foreground.  If set to true, the Smalltalk process that starts the listener service will block (appear to hang) waiting for an inbound connection.  In some situations this may block the Smalltalk UI, so be careful.  This option exists because it is handy for some Smalltalk dialects (e.g. GemStone) to force the accept into forground for testing.  This defaults to false, i.e. the accept loop is forked off into a new Smalltalk process."	acceptInForeground isNil ifTrue: [acceptInForeground := false].	^acceptInForeground</body><body package="OSkSocketServices" selector="acceptInForeground:">acceptInForeground: aBoolean 	"^selfc.f. acceptInForeground.  I record whether the accept look should run in the current Smalltak process or a forked Smalltalk process."	acceptInForeground := aBoolean.	^self</body><body package="OSkSocketServices" selector="bytesLog">bytesLog	^SpEnvironment madeObsoleteBy: [self socketObserver]</body><body package="OSkSocketServices" selector="hostName">hostName	"^a StringI return the hostname I'm listening on.  Mostly this will be localhost."	hostName isNil ifTrue: [hostName := self class defaultHostName].	^hostName</body><body package="OSkSocketServices" selector="hostName:">hostName: aString 	"^selfI record the hostname I'm listening on."	hostName := aString.	^self</body><body package="OSkSocketServices" selector="multiThreading">multiThreading	"^a BooleanI return true if each inbound connection will be handled in its own thread.  See the senders of this message to see where that is important.  Note that the default mode is single-threaded because this is safest.  Multi threading is tricky for the application programmer because they must ensure that they work in a thread safe way (e.g. avoid the many threads updating the same object).  For those deploying to GemStone, you wil find things much easier if you do *not* run multithreaded, but rather run many gems each with a single-threaded service in each.  Also in GemStone, run the main loop in the foreground, c.f. &gt;&gt;acceptInForeground"	multiThreading isNil ifTrue: [multiThreading := false].	^multiThreading</body><body package="OSkSocketServices" selector="multiThreading:">multiThreading: aBoolean 	"^selfI record whether each inbound connection will be handled in its own thread.  c.f. &gt;&gt;multiThreading."	multiThreading := aBoolean.	^self</body><body package="OSkSocketServices" selector="portNumber">portNumber	"^an IntegerI return the number of the port I'm listening on.  This varies by service."	portNumber isNil ifTrue: [portNumber := self class defaultPortNumber].	^portNumber</body><body package="OSkSocketServices" selector="portNumber:">portNumber: anInteger 	"^selfI record the number of the port upon which I am to listen.  This will fail if I am already started."	self isStarted 		ifTrue: 			[SpError 				raiseSignal: 'Port number can''t be changed when the service is running.'].	portNumber := anInteger.	^self</body><body package="OSkSocketServices" selector="socket">socket	"^a socket of some kind or nilI return the socket from which I will accept inbound connections.  c.f. &gt;&gt;start to see how the socket is created.  If I've not beed started yet or if I've been stopped, I'll return nil."	^socket</body><body package="OSkSocketServices" selector="socket:">socket: aSocket	socket := aSocket</body><body package="OSkSocketServices" selector="socketClass">socketClass	"^a ClassI return the class I'll ask to make a socket when I start."	socketClass isNil ifTrue: [socketClass := self class defaultSocketClass].	^socketClass</body><body package="OSkSocketServices" selector="socketClass:">socketClass: aClass 	"^selfI record the class of the socket I will use when I start.  This will fail if I am already started."	self isStarted 		ifTrue: 			[SpError 				raiseSignal: 'Socket class can''t be changed when the service is running.'].	socketClass := aClass.	^self</body><body package="OSkSocketServices" selector="socketObserver">socketObserver	"^an OSkSocketObserver or nilI return the observer (if any) which monitors all the bytes read and written by this server."	^socketObserver</body><body package="OSkSocketServices" selector="stopRequested">stopRequested	"^a BooleanI return true if this services has been requested to stop."	stopRequested isNil ifTrue: [stopRequested := false].	^stopRequested</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>serving</category><body package="OSkSocketServices" selector="acceptConnection">acceptConnection	"^selfI accept the next inbound TCP/IP connection."	^SpExceptionContext 		for: [self socket accept]		on: SpError		do: 			[:ex | 			OSkLogSwitch log: (OSkExceptionLogEntry for: ex						withComment: 'Socket accept error: ' , ex errorString).			nil]</body><body package="OSkSocketServices" selector="acceptInboundConnections">acceptInboundConnections	"^selfThis is the main accept loop.  The socket is established and then loop accepting inbound connections and handling them until &gt;&gt;isRunning has been set to false, when everything is shut down.  The operating system libraries queue the inbound requests for me, so I can just handle one at a time.  I create an connection object to handle the interaction with the client.  If we are running in single threaded mode I wait until the new client connection closes before grabbing the next inbound request.  In multi-threaded mode I fork the work into a sepparate Smalltalk process and immediately try to accept the next equest (the application programmer must worry about thread safety in this case)."		[socket := self createAndInitializeSocket.	[self stopRequested] whileFalse: 			[self multiThreading 				ifTrue: 					[[self handleInboundConnectionOn: self acceptConnection] 						forkAt: Processor userBackgroundPriority]				ifFalse: [self handleInboundConnectionOn: self acceptConnection]]] 			ensure: [self closeEverything].	^self</body><body package="OSkSocketServices" selector="handleInboundConnectionOn:">handleInboundConnectionOn: aClientSocket 	"^selfI create an inbound connection object to actually handle the interaction with the client - if I am in single threaded mode, the connection will completely handle the request before returning control to me, but in multi-threaded mode the connection forks the work into a sepparate thread in this image and control is immediately returned to me (the application programmer must worry about thread safety in this case."	| inboundConnection |	aClientSocket notNil 		ifTrue: 			[inboundConnection := self inboundConnectionClass socket: aClientSocket.			self addConnection: inboundConnection.			inboundConnection interact].	^self</body><body package="OSkSocketServices" selector="inboundConnectionClass">inboundConnectionClass	"^a ClassI return the class whose instances will represent my inbound connecitons.  Every service needs to have a specific class to handle the specific needs of the client (e.g. HTTP vs LDAP)."	^self subclassResponsibility</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>logging - messages</category><body package="OSkSocketServices" selector="isLoggingMessages">isLoggingMessages	"^a BooleanI return true if my underlying connections are currently required to log the messages they handle, otherwise false."	^self messagesLog notNil</body><body package="OSkSocketServices" selector="messagesLog">messagesLog	"^an OSkLog or nilI retrn the log (if any) to which all the HTTP messages read and written by this server will be logged."	^messagesLog</body><body package="OSkSocketServices" selector="startLoggingMessages">startLoggingMessages	"^selfI start logging the messages I handle.  A message is a request or a response. This log will be a higher level semantic log of events, and some data may not be explicity retained from the bytes that flow over the socket.  c.f. &gt;&gt;startByteLog"	1 halt</body><body package="OSkSocketServices" selector="stopLogging">stopLogging	"^selfI stop all logging."	self stopLoggingBytes.	self stopLoggingMessages.	^self</body><body package="OSkSocketServices" selector="stopLoggingMessages">stopLoggingMessages	"^selfc.f. &gt;&gt;startMessageLog"	1 halt</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>private</category><body package="OSkSocketServices" selector="acceptedConnections">acceptedConnections	acceptedConnections isNil ifTrue: [acceptedConnections := OrderedCollection new].	^acceptedConnections</body><body package="OSkSocketServices" selector="addConnection:">addConnection: aConnection 	self acceptedConnections add: aConnection.	aConnection server: self</body><body package="OSkSocketServices" selector="createAndInitializeSocket">createAndInitializeSocket	"^a Socket like thingI create and initialize the socket I will use to listen for inbound connections."	^(self socketClass newTCPSocket)		setAddressReuse: true;		bindSocketAddress: (SpIPAddress hostName: self hostName					port: self portNumber);		listenBackloggingUpTo: 50;		yourself</body><body package="OSkSocketServices" selector="removeConnection:">removeConnection: aConnection 	self acceptedConnections remove: aConnection ifAbsent: [nil]</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>logging - bytes</category><body package="OSkSocketServices" selector="isLoggingBytes">isLoggingBytes	"^a BooleanI return true if my undrlying socket(s) are currently being observed, otherwise false."	^self socketObserver notNil</body><body package="OSkSocketServices" selector="startLoggingBytes">startLoggingBytes	"^selfI start logging the bytes that pass through my underlying socket to the default log."	^self startLoggingBytesTo: OSkLogSwitch default</body><body package="OSkSocketServices" selector="startLoggingBytesTo:">startLoggingBytesTo: anOSkLogSwitch 	"^selfI start logging the bytes that pass through my underlying socket to anOSkLogSwitch."	socketObserver := OSkActiveSocketObserver loggingTo: anOSkLogSwitch.	self acceptedConnections 		do: [:aConnection | aConnection startLoggingBytes].	^self</body><body package="OSkSocketServices" selector="startLoggingBytesToFileNamed:">startLoggingBytesToFileNamed: aFileNameString 	"^selfCreate a log with a single target of a file named aFileNameString."	| log |	log := OSkLogSwitch new.	OSkFileLogTarget onFileNamed: aFileNameString for: log.	self startLoggingBytesTo: log.	^self</body><body package="OSkSocketServices" selector="stopLoggingBytes">stopLoggingBytes	"^selfc.f. &gt;&gt;startByteLog"	self isLoggingBytes 		ifTrue: 			[self acceptedConnections do: [:aConnection | aConnection stopLoggingBytes].			self socketObserver close.			socketObserver := nil].	^self</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>start/stop</category><body package="OSkSocketServices" selector="closeEverything">closeEverything	self acceptedConnections copy do: [:each | each close].	self socket notNil 		ifTrue: 			[self socket close.			socket := nil].	^self</body><body package="OSkSocketServices" selector="start">start	"^selfI start the main loop of the HTTP server.  The main loop may either be run in this thread, or forked according to the value of &gt;&gt;acceptInForeground.  The default mode is to run the main loop forked."	self isStarted 		ifFalse: 			[self acceptInForeground 				ifTrue: [self acceptInboundConnections]				ifFalse: 					[[self acceptInboundConnections] forkAt: Processor userBackgroundPriority]].	^self</body><body package="OSkSocketServices" selector="stop">stop	"^selfI stop the service right now.  If you want to be kind to in-progress requests, use &gt;&gt;stopGently instead"	stopRequested := true.	self closeEverything.	^self</body><body package="OSkSocketServices" selector="stopGently">stopGently	"^selfI stop the service.  If there are outstanding connections, I let these finish (this method might be executing as part of one!).  If no connectiosn are running, I close everything now."	stopRequested := true.	self acceptedConnections isEmpty ifTrue: [self closeEverything].	^self</body></methods><methods><class-id>OSkSocketListenerService</class-id> <category>testing</category><body package="OSkSocketServices" selector="isStarted">isStarted	"^a BooleanI return true if I have been stated, i.e. if I am actively listening for inbound LDAP connections."	^self isStopping not and: [socket notNil and: [self socket isActive]]</body><body package="OSkSocketServices" selector="isStopping">isStopping	"^a BooleanI return true if I am stopping, otherwise false."	^self stopRequested</body></methods><methods><class-id>OSkSocketListenerService class</class-id> <category>defaults</category><body package="OSkSocketServices" selector="defaultHostName">defaultHostName	^'localhost'</body><body package="OSkSocketServices" selector="defaultPortNumber">defaultPortNumber	^self subclassResponsibility</body><body package="OSkSocketServices" selector="defaultSocketClass">defaultSocketClass	^SpSocket</body></methods><methods><class-id>OSkNilSocketObserver</class-id> <category>services</category><body package="OSkSocketServices" selector="flushLogEntry">flushLogEntry	^self</body><body package="OSkSocketServices" selector="stopLogging">stopLogging	^self</body></methods><methods><class-id>OSkNilSocketObserver</class-id> <category>logging</category><body package="OSkSocketServices" selector="logReadByte:">logReadByte: aByte 	^self</body><body package="OSkSocketServices" selector="logReadBytes:">logReadBytes: aByteArray 	^self</body><body package="OSkSocketServices" selector="logWrittenByte:">logWrittenByte: aByte 	^self</body><body package="OSkSocketServices" selector="logWrittenBytes:">logWrittenBytes: aByteArray 	^self</body></methods><methods><class-id>OSkSocketLimitedTimer</class-id> <category>accessing</category><body package="OSkSocketServices" selector="maximumMilliseconds">maximumMilliseconds	"^an IntegerI return the maximum number of milliseconds that I will record before throwing an exception.  This value defaults to 5 minutes."	maximumMiliseconds isNil ifTrue: [maximumMiliseconds := 5 * 60 * 1000].	^maximumMiliseconds</body><body package="OSkSocketServices" selector="maximumMilliseconds:">maximumMilliseconds: anNumberOfMilliseconds 	"^self I record the number of maximum number milliseconds I will record before I throw a timeout exception."	maximumMiliseconds := anNumberOfMilliseconds.	^self</body></methods><methods><class-id>OSkSocketLimitedTimer</class-id> <category>services</category><body package="OSkSocketServices" selector="incrementBy:">incrementBy: aNumberOfMilliseconds 	"^selfI increment the number of milliseconds as norman but if the new number exceeds my maximum I throw an exception."	super incrementBy: aNumberOfMilliseconds.	self currentMilliseconds &gt; self maximumMilliseconds 		ifTrue: [OSkSocketTimerException raiseSignal: 'Timeout'].	^self</body></methods><methods><class-id>OSkSocketLimitedTimer class</class-id> <category>instance creation</category><body package="OSkSocketServices" selector="maximumMilliseconds:">maximumMilliseconds: anNumberOfMilliseconds 	^(self new)		maximumMilliseconds: anNumberOfMilliseconds;		yourself</body><body package="OSkSocketServices" selector="maximumSeconds:">maximumSeconds: anNumberOfSeconds 	^self maximumMilliseconds: anNumberOfSeconds * 1000</body></methods><methods><class-id>OSkSocketInboundConnection</class-id> <category>accessing</category><body package="OSkSocketServices" selector="socket">socket	"^an SPSocketI return the socket that connects me to my client."	^socket</body></methods><methods><class-id>OSkSocketInboundConnection</class-id> <category>initialize-release</category><body package="OSkSocketServices" selector="socket:">socket: aSocket 	"^selfI initialize myself on aSocket which has an HTTP client at the other end - I assume."	socket := aSocket.	^self</body></methods><methods><class-id>OSkSocketInboundConnection</class-id> <category>services</category><body package="OSkSocketServices" selector="close">close	"^selfNote that we terminate the process first, so that when we close the socket, the process doesn't crash."	self socket close.	self server removeConnection: self</body><body package="OSkSocketServices" selector="interact">interact	"^selfI represent a specifc connection with a client  over which will come requests to which I must respond.  Once the messages have been handled I must ensure that the socket is closed."		[self getAndDispatchMessages.	Processor yield] ensure: [self close].	^self</body></methods><methods><class-id>OSkSocketInboundConnection</class-id> <category>private-accessing</category><body package="OSkSocketServices" selector="server">server	^server</body><body package="OSkSocketServices" selector="server:">server: aServer 	"^selfI am being told my HTTP server.  I take this opportunity to set up the logging as currently required by the server."	server := aServer.	server isLoggingBytes ifTrue: [self startLoggingBytes].	server isLoggingMessages ifTrue: [self startLoggingMessages].	^self</body></methods><methods><class-id>OSkSocketInboundConnection class</class-id> <category>instance creation</category><body package="OSkSocketServices" selector="socket:">socket: aSocket 	^self new socket: aSocket</body></methods><methods><class-id>OSkSocketWriteStream</class-id> <category>private-buffer</category><body package="OSkSocketServices" selector="absolutePosition">absolutePosition	"^an IntegerI return my absolute position in &gt;&gt;bufferArray, i.e. the index of the last byte added to the buffer via the bufferWriteStream."	^self bufferWriteStream position - SpEnvironment streamStartPosition</body><body package="OSkSocketServices" selector="bufferArray">bufferArray	"^a ByteArrayI return the current buffer array.  The bufferArray is a ByteArray *within which* is the buffer.  Nominally, the buffer will start at the first byte of the bufferArry, but if my underlying socket can't accomodate all the data I want to write, the buffer will start at &gt;&gt;bufferStartByte (the first unwritten byte).   It is always true that the buffer starts at the first unwritten byte.  If I have no buffer at the moment, I create one at the &gt;&gt;initialBufferSize.  Note that when we have a new buffer, we must reset the bufferStartIndex too."	bufferArray isNil 		ifTrue: 			[bufferArray := ByteArray new: self bufferSize.			bufferStartIndex := nil].	^bufferArray</body><body package="OSkSocketServices" selector="bufferIsRipe">bufferIsRipe	"^aBooleanI return true if the buffer is 'ripe', that is if it has met or exceeded it's nominal (&gt;&gt;bufferSize) size."	^(self currentBufferPosition &lt; self bufferSize) not</body><body package="OSkSocketServices" selector="bufferStartIndex">bufferStartIndex	"^an IntegerI return the index of the first byte of the buffer within &gt;&gt;bufferArray.  This is nominally 1, but if my underlying socket can't accomodate all the data I want to write, the buffer will start the first unwritten byte.   It is always true that the buffer starts at the first unwritten byte, and that's the value I represent.  My initial value is 1."	bufferStartIndex isNil ifTrue: [bufferStartIndex := 1].	^bufferStartIndex</body><body package="OSkSocketServices" selector="bufferWriteStream">bufferWriteStream	"^a WriteStreamI return the write stream on my &gt;&gt;bufferArray.  All bytes are added to the buffer through this stream."	bufferWriteStream isNil 		ifTrue: [bufferWriteStream := WriteStream on: self bufferArray].	^bufferWriteStream</body><body package="OSkSocketServices" selector="currentBufferPosition">currentBufferPosition	"^an IntegerThe current buffer position is the absolute position of &gt;&gt;bufferWriteStream in &gt;&gt;bufferArray offset by the &gt;&gt;bufferStartIndex."	^self absolutePosition - self bufferStartIndex + 1</body><body package="OSkSocketServices" selector="growBufferToAccomodate:">growBufferToAccomodate: aNumberOfBytes 	"^selfI make sure that there is enough room in &gt;&gt;bufferArray to accomodate aNumberOfBytes.  I grow the buffer if necessary, which involves creating a new ByteArray and copying the contents of the old array to the new array.  I do this via a new &gt;&gt;bufferWriteStream so that the stream is left in the right position."	| requiredSize |	requiredSize := self absolutePosition + aNumberOfBytes.	requiredSize &gt; self bufferArray size 		ifTrue: 			[| oldBufferArray oldPosition oldBufferStartIndex |			oldBufferArray := self bufferArray.			oldPosition := self absolutePosition.			oldBufferStartIndex := self bufferStartIndex.			bufferArray := ByteArray new: requiredSize - self bufferStartIndex + 1.			bufferWriteStream := nil.			bufferStartIndex := nil.			oldPosition - oldBufferStartIndex + 1 &gt; 0 				ifTrue: 					[self bufferWriteStream 						nextPutAll: (oldBufferArray copyFrom: oldBufferStartIndex to: oldPosition)]].	^self</body><body package="OSkSocketServices" selector="shrinkBufferArray">shrinkBufferArray	"^selfThe buffer array may have been stretched to an excessively large size if a huge amount of data was written to me, or if my underlying socket has been unable to accept data for a while.  I'll only shrink the buffer if the bufferWriteStream is nil (which means we are either just starting out, or have just successfully written the entire buffer) and if the buffer is indeed over-sized.  BTW, shrinking just means setting to nil so that it will be lazily initialised to &gt;&gt;initialBufferSize when next needed."	(self absolutePosition == 0 		and: [self bufferArray size &gt; self bufferSizeCeiling]) 			ifTrue: 				[bufferArray := nil.				bufferWriteStream := nil.				bufferStartIndex := nil].	^self</body><body package="OSkSocketServices" selector="tryToFlush">tryToFlush	"^selfI write as much as my buffer as my underlying socket can accept in one &gt;&gt;write call.  The buffer might be emptied, it might not.  If you want to ensure the entire buffer is written to the socket use &gt;&gt;flush instead."	| readyCount writtenCount |	readyCount := self absolutePosition - self bufferStartIndex + 1.	writtenCount := self underlyingSocket 				writeFrom: self bufferArray				startingAt: self bufferStartIndex				for: readyCount.	writtenCount &lt; readyCount 		ifTrue: [bufferStartIndex := self bufferStartIndex + writtenCount]		ifFalse: 			[bufferStartIndex := 1.			bufferWriteStream reset.			self shrinkBufferArray].	^self</body></methods><methods><class-id>OSkSocketWriteStream</class-id> <category>accessing</category><body package="OSkSocketServices" selector="bufferSize:">bufferSize: anInteger 	"^selfI set the new buffer size to anInteger.  This will allow the buffer to grow or shrink to the new size when the next data is written to me, or when the next &gt;&gt;flush happens.c.f. &gt;&gt;bufferSize"	bufferSize := anInteger.	^self</body></methods><methods><class-id>OSkSocketWriteStream</class-id> <category>services</category><body package="OSkSocketServices" selector="flush">flush	"^selfI am being asked to flush the contents of my buffer to my underlying socket.  The socket may not be able to handle the whole buffer in one go, so we have to keep trying to write the buffer contents to the socket until we get it all done.  Should we introdce a delay if the &gt;&gt;tryToFlush did not flush everything?  Might we end up in a tight loop if we don't add something like a delay?"	[self currentBufferPosition == 0] whileFalse: [self tryToFlush].	^self</body><body package="OSkSocketServices" selector="nextPut:">nextPut: aByte 	"^selfI write aByte to my underlying socket."	self growBufferToAccomodate: 1.	self bufferWriteStream nextPut: aByte.	self bufferIsRipe ifTrue: [self tryToFlush].	self observer logWrittenByte: aByte.	^self</body><body package="OSkSocketServices" selector="nextPutAll:">nextPutAll: aByteArray 	"^selfI add aByteArray to by buffer of out-going bytes.  If the buffer is ripe, I try to write it to my underlying socket."	self growBufferToAccomodate: aByteArray size.	self bufferWriteStream nextPutAll: aByteArray.	self bufferIsRipe ifTrue: [self tryToFlush].	self observer logWrittenBytes: aByteArray.	^self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SpError</name><environment>Smalltalk</environment><super>SpAbstractError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpExceptions</category><attributes><package>SpExceptions</package></attributes></class></st-source>