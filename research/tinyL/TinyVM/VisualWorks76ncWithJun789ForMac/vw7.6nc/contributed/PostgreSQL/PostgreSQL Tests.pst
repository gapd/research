<?xml version="1.0"?><st-source><!-- Name: PostgreSQL TestsComment: ©Bruce Badger 2000 - 2006. Licensed under the LGPL.DbIdentifier: openskills.org-20070415DbTrace: 9493DevelopmentPrerequisites: #(#(#any 'PostgreSQLEXDI' '') #(#any 'SUnit' ''))PackageName: PostgreSQL TestsParcel: #('PostgreSQL Tests')PrerequisiteParcels: #(#('PostgreSQLEXDI' '') #('SUnit' ''))PrintStringCache: (1.3 059,bbadger)Version: 1.3 053Date: 11:38:33 pm November 22, 2007 --><time-stamp>From VisualWorks®, Pre-Release 7.5.1 (nov07.2) of November 12, 2007 on November 22, 2007 at 11:38:33 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PostgreSQLEXDITest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identity nameString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQL Tests</package></attributes></class><comment><class-id>PostgreSQLEXDITest</class-id><body>Copyright © 2000-2007  Bruce Badger. All Rights Reserved.These tests replaced the old test class that was included with the PostgreSQL drivers.</body></comment><class><name>PostgreSQLTestVictim</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identity nameString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQL Tests</package></attributes></class><comment><class-id>PostgreSQLTestVictim</class-id><body>Copyright © 2000-2007  Bruce Badger. All Rights Reserved.</body></comment><class><name>PostgreSQLTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>messageLog </class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQL Tests</package></attributes></class><comment><class-id>PostgreSQLTest</class-id><body>Copyright © 2000-2007  Bruce Badger. All Rights Reserved.</body></comment><class><name>PostgreSQLLoggingTesting</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Logging</category><attributes><package>PostgreSQL Tests</package></attributes></class><comment><class-id>PostgreSQLLoggingTesting</class-id><body>Copyright © 2000-2007  Bruce Badger. All Rights Reserved.</body></comment><methods><class-id>PostgreSQLEXDITest</class-id> <category>tests</category><body package="PostgreSQL Tests" selector="test01">test01	"^self 	Using the EXDI, I connect to a PostgreSQL database and then disconnect."	"self test01"	| connection |	connection := PostgreSQLEXDIConnection new.	connection		username: self subjectUsernameString;		password: self subjectPasswordString;		environment: self subjectEnvironmentString.	connection connect.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test02">test02	"^self 	I create a 'logical' environment called e-test and use that to connect. Then, at the end, I remove the 	logical mapping again."	"self test02"	| connection |	PostgreSQLEXDIConnection addLogical: 'e-test'		environment: self subjectEnvironmentString.	connection := PostgreSQLEXDIConnection new.	connection		username: self subjectUsernameString;		password: self subjectPasswordString;		environment: 'e-test'.	connection connect.	connection disconnect.	PostgreSQLEXDIConnection removeLogical: 'e-test'.	^self</body><body package="PostgreSQL Tests" selector="test03">test03	"^self 	I create a 'logical' environment called e-test and then make that the default connection for the 	PostgresEXDI connection. Then I connect without specifying an environment string. At the end, I 	remove the	logical mapping again."	"self test03"	| connection |	PostgreSQLEXDIConnection addLogical: 'e-test'		environment: self subjectEnvironmentString.	PostgreSQLEXDIConnection defaultEnvironment: 'e-test'.	connection := PostgreSQLEXDIConnection new.	connection		username: self subjectUsernameString;		password: self subjectPasswordString.	connection connect.	connection disconnect.	PostgreSQLEXDIConnection defaultEnvironment: nil.	PostgreSQLEXDIConnection removeLogical: 'e-test'.	^self</body><body package="PostgreSQL Tests" selector="test04">test04	"^self 	I create a 'logical' environment called e-test and then make that the default connection for the 	PostgresEXDI connection, I also make PostgreSQLEXDIConnection the default connection. Then I 	connect without specifying an environment string. At the end, I 	remove the	logical mapping again."	"self test04"	| connection |	PostgreSQLEXDIConnection addLogical: 'e-test'		environment: self subjectEnvironmentString.	PostgreSQLEXDIConnection defaultEnvironment: 'e-test'.	ExternalDatabaseConnection defaultConnection: #PostgreSQLEXDIConnection.	connection := PostgreSQLEXDIConnection new.	connection		username: self subjectUsernameString;		password: self subjectPasswordString.	connection connect.	connection disconnect.	ExternalDatabaseConnection defaultConnection: nil.	PostgreSQLEXDIConnection defaultEnvironment: nil.	PostgreSQLEXDIConnection removeLogical: 'e-test'.	^self</body><body package="PostgreSQL Tests" selector="test05">test05	"^self 	I use the default test connection and run a really simple query. I don't process the answer."	"self test05"	| connection session |	connection := self subjectConnection.	session := connection getSession.	session prepare: 'select 3 + 4;'.	session execute.	session answer.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test06">test06	"^self 	I'll test variables in queries."	"self test06"	| connection session |	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest06'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest06 (name varchar(30), phone varchar(20))'.	session execute.	session := connection getSession.	session prepare: 'INSERT INTO exdiTest06 (name, phone) VALUES(?, ?)'.	#(#('Curly' 'x47') #('Moe' 'x29') #('Larry' 'x83')) do: [:entry | session bindInput: entry; execute; answer].	session := connection getSession.	session prepare: 'drop table exdiTest06'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test07">test07	"^self 	I make a table with every possible data type, populate it and then get a row from it. This is all to test 	data type conversion from the PostgreSQL for to the EXDI specified form."	"self test07"	| connection session |	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest07'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest07 (	textField		text,	varcharField		varchar(4),	charField		char(4),	integerField		integer,	int2Field		int2,	int8Field		int8,	oidField			oid,	numericField	numeric(6,2),	floatField		float,	float4Field		float4,	dateField		date,	timeField		time,	timestampField	timestamp without time zone,	intervalField		interval,	boolField		bool,	pointField		point,	lsegField		lseg,	pathField		path,	boxField		box,	circleField		circle,	polygonField	polygon,	inetField		inet,	cidrField		cidr,	macaddrField	macaddr)'.	session execute.	session := connection getSession.	session prepare: 'insert into exdiTest07(	textField,	varcharField,	charField,	integerField,	int2Field,	int8Field,	oidField,	numericField,	floatField,	float4Field,	dateField,	timeField,	timestampField,	intervalField,	boolField,	pointField,	lsegField,	pathField,	boxField,	circleField,	polygonField,	inetField,	cidrField,	macaddrField)values (	''Text value'',	''VC1'',	''C4'',	1234,	2468,	1248,	1357,	123.45,	0.1234,	123456.78,	''07-09-2000'',	''14:53:42'',	''07-09-2000 14:54:55'',	''4 05:00:30'',	''true'',	''(2,7)'',	''[(0,0),(1,3)]'',	''((0,0),(3,0),(4,5),(1,6))'',	''(1,1),(3,3)'',	''&lt;(1,2),60&gt;'',	''((3,1),(3,3),(1,0))'',	''192.168.1.12'',	''172.20.90.0/24'',	''0:50:4:1d:f6:db'')'; execute.	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows |			session prepare: 'select * from exdiTest07'; execute.			rows := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [rows := rows , answer upToEnd].			(rows first collect: [:x | x class name])				= #(#ByteString #ByteString #ByteString #SmallInteger #SmallInteger #SmallInteger #SmallInteger #FixedPoint #Double #Double #Date #Time #Timestamp #SmallInteger #True #Point #LineSegment #Polyline #Rectangle #Circle #Polyline #ByteString #ByteString #ByteString) ifFalse: [Exception raiseSignal: 'Test07 - failed']].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test08">test08	"^self 	I test getting retults back. After populating the database, I make several consecutive queries.	NOTE: this test also uses &gt;&gt;rowCount, but since this is broken, the call has been commented out for now."	"self test08"	| connection session |	connection := self subjectConnection.	session := connection getSession.		[session		prepare: 'drop table exdiTest08';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].	session 		prepare: 'create table exdiTest08 (name varchar(30), phone varchar(20))'.	session execute.	session answer.	session := connection getSession.	session prepare: 'INSERT INTO exdiTest08 (name, phone) VALUES(?, ?)'.	#(#('Curly' 'x47') #('Moe' 'x29') #('Larry' 'x83')) do: 			[:entry | 			session				bindInput: entry;				execute;				answer].	session := connection getSession.	session prepare: 'select * from exdiTest08'.	session execute.	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows totalRows |			rows := OrderedCollection new.			totalRows := 0.			[(answer := session answer) == #noMoreAnswers] whileFalse: 					[totalRows := totalRows + session rowCount.					rows := rows , answer upToEnd].			rows asArray = #(#('Curly' 'x47') #('Moe' 'x29') #('Larry' 'x83')) 				ifFalse: [Exception raiseSignal: 'Test08 - failed'].			self assert: totalRows == 0].	session := connection getSession.	session prepare: 'select * from exdiTest08 where name like ''%r%'' '.	session execute.	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows |			rows := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers] 				whileFalse: [rows := rows , answer upToEnd].			rows asArray = #(#('Curly' 'x47') #('Larry' 'x83')) 				ifFalse: [Exception raiseSignal: 'Test08 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest08'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test09">test09	"^self 	I'll test transactions."	"self test09"	| connection session |	self initializeTestDatabase.	connection := self subjectConnection.	session := connection getSession.	session prepare: 'INSERT INTO task (name) VALUES(''test09a'')'; execute; answer.	connection begin.	session prepare: 'INSERT INTO task (name) VALUES(''test09b'')'; execute; answer.	connection commit.	connection begin.	session prepare: 'INSERT INTO task (name) VALUES(''test09c'')'; execute; answer.	connection rollback.	session prepare: 'INSERT INTO task (name) VALUES(''test09d'')'; execute; answer.	connection begin.	session prepare: 'INSERT INTO task (name) VALUES(''test09e'')'; execute; answer.	session prepare: 'INSERT INTO task (name) VALUES(''test09f'' )'; execute; answer.	connection rollback.	session prepare: 'INSERT INTO task (name) VALUES(''test09g'')'; execute; answer.	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows |			session prepare: 'select * from task where name like ''test09%'' '; execute.			rows := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [rows := rows , answer upToEnd].			rows asArray = #(#('test09a') #('test09b') #('test09d') #('test09g')) ifFalse: [Exception raiseSignal: 'Test09 - failed']].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test10">test10	"^self 	I'll test binding real objects to the query input and output."	"self test10"	| connection session testObjects |	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest10'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest10 (identity integer, nameString text);'; execute.	testObjects := OrderedCollection new.	testObjects add: (PostgreSQLTestVictim withIdentity: 1 andNameString: 'exdiTest10a').	testObjects add: (PostgreSQLTestVictim withIdentity: 2 andNameString: 'exdiTest10b').	testObjects add: (PostgreSQLTestVictim withIdentity: 3 andNameString: 'exdiTest10c').	testObjects add: (PostgreSQLTestVictim withIdentity: 4 andNameString: 'exdiTest10d').	session prepare: 'INSERT INTO exdiTest10 (identity, nameString)VALUES(:identity, :nameString)'.	testObjects do: [:entry | session bindInput: entry; execute; answer].	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest10 order by identity'.			session bindOutput: PostgreSQLTestVictim new; execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [results := results , answer upToEnd].			results = testObjects ifFalse: [Exception raiseSignal: 'Test10 -failed']].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test11">test11	"^self 	I'll test binding real objects to the query input and output and in 	addition, I use a serial column type to assign the identity."	"self test11"	| connection session testObjects |	connection := self subjectConnection.	session := connection getSession.		[session		prepare: 'drop table exdiTest11';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].		[session		prepare: 'drop sequence exditest11_identity_seq';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].	session		prepare: 'create table exdiTest11 (identity serial, nameString text);';		execute.	testObjects := OrderedCollection new.	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest11a').	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest11b').	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest11c').	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest11d').	session 		prepare: 'INSERT INTO exdiTest11 (nameString) VALUES (:nameString)'.	testObjects do: 			[:entry | 			session				bindInput: entry;				execute;				answer].	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest11 order by identity'.			session				bindOutput: PostgreSQLTestVictim new;				execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers] 				whileFalse: [results := results , answer upToEnd].			testObjects := OrderedCollection new.			testObjects 				add: (PostgreSQLTestVictim withIdentity: 1 andNameString: 'exdiTest11a').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 2 andNameString: 'exdiTest11b').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 3 andNameString: 'exdiTest11c').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 4 andNameString: 'exdiTest11d').			results = testObjects ifFalse: [Exception raiseSignal: 'Test09 - failed']].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test12">test12	"^self 	I'll test binding real objects to the query input and output and in 	addition, I use a serial column type to assign the identity."	"self test12"	| connection session testObjects |	connection := self subjectConnection.	session := connection getSession.		[session		prepare: 'drop table exdiTest12';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].		[session		prepare: 'drop sequence exditest12_identity_seq';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].	session		prepare: 'create table exdiTest12 (identity serial, nameStringtext);';		execute.	testObjects := OrderedCollection new.	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest12a').	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest12b').	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest12c').	testObjects 		add: (PostgreSQLTestVictim withIdentity: nil andNameString: 'exdiTest12d').	session prepare: 'INSERT INTO exdiTest12 (nameString) VALUES(:nameString)'.	session bindOutput: self class new.	testObjects do: 			[:entry | 			session				bindInput: entry;				execute;				answer].	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest12 order by identity'.			session				bindOutput: PostgreSQLTestVictim new;				execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers] 				whileFalse: [results := results , answer upToEnd].			testObjects := OrderedCollection new.			testObjects 				add: (PostgreSQLTestVictim withIdentity: 1 andNameString: 'exdiTest12a').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 2 andNameString: 'exdiTest12b').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 3 andNameString: 'exdiTest12c').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 4 andNameString: 'exdiTest12d').			results = testObjects ifFalse: [Exception raiseSignal: 'Test09 -failed']].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test13">test13	"^self 	I test using special characters in strings (e.g. $\)."	"self test13"	| connection session testObjects |	connection := self subjectConnection.	session := connection getSession.		[session		prepare: 'drop table exdiTest13';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].		[session		prepare: 'drop sequence exditest13_identity_seq';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].	session		prepare: 'create table exdiTest13 (identity serial, nameStringtext);';		execute.	testObjects := OrderedCollection new.	testObjects add: (PostgreSQLTestVictim withIdentity: nil				andNameString: '\exdiTest13a\\\').	testObjects add: (PostgreSQLTestVictim withIdentity: nil				andNameString: '\exdiTest13b\\\').	testObjects add: (PostgreSQLTestVictim withIdentity: nil				andNameString: '\exdiTest13c\\\').	testObjects add: (PostgreSQLTestVictim withIdentity: nil				andNameString: '\exdiTest13d\\\').	session prepare: 'INSERT INTO exdiTest13 (nameString) VALUES(:nameString)'.	session bindOutput: self class new.	testObjects do: 			[:entry | 			session				bindInput: entry;				execute;				answer].	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest13 order by identity'.			session				bindOutput: PostgreSQLTestVictim new;				execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers] 				whileFalse: [results := results , answer upToEnd].			testObjects := OrderedCollection new.			testObjects 				add: (PostgreSQLTestVictim withIdentity: 1 andNameString: '\exdiTest13a\\\').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 2 andNameString: '\exdiTest13b\\\').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 3 andNameString: '\exdiTest13c\\\').			testObjects 				add: (PostgreSQLTestVictim withIdentity: 4 andNameString: '\exdiTest13d\\\').			results = testObjects ifFalse: [Exception raiseSignal: 'Test09 -failed']].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test14">test14	"^self 	I test logging. I set logging on, and then run &gt;&gt;test06.."	"self test14"	PostgreSQLEXDIConnection traceCollector: Transcript.	PostgreSQLEXDIConnection traceLevel: 3.	self test06.	PostgreSQLEXDIConnection traceLevel: 0.	^self</body><body package="PostgreSQL Tests" selector="test15">test15	"^self 	Test a senario devised by Chris Lopeman.  In his words (BTW, I hope the BOOM is gone):	Well I am sure that bunch of rambling did not help you understand the problem so	here's a quick way to produce it.  Without the patch of course:		1) open a connection.		2) prepare a query		3) begin a transaction		4) execute the query		5) BOOM!!!!"	"self test15"	| connection session query |	self initializeTestDatabase.	connection := self subjectConnection.	session := connection getSession.	query := session prepare: 'INSERT INTO task (name) VALUES(''test15'')'.	connection begin.	query execute; answer.	connection rollback.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test16">test16	"^self Test a senario devised by Coen De Roover who said:When I try to use named output binding with the PostgreSQLEXDI that is included inVW 7.1, I get (in the following code snippet) a 'Message not understoodexception: #p_login' with zero arguments, while the code was supposed tocall the 'p_login: aLogin' setter method. "	"It seems that the EXDI layer demands that an accessor be there, even if all you want to do is assign the value.  so in the above, you'd need &gt;&gt;p_login *and* &gt;&gt;p_login:.  Also, it seems that case is not preserved between the select statement 'AS' and sending the message - i.e. in this case 'namestring' is the selector used instead of 'nameString'."	"self test16"	| connection session result |	self initializeTestDatabase.	connection := self subjectConnection.	session := connection getSession.	session 		prepare: 'SELECT name AS nameString FROM assignee WHERE name LIKE ?'.	session bindInput: #('Bob').	session bindOutputNamed: PostgreSQLTestVictim new.	session execute.	result := session answer upToEnd.	connection disconnect.	^result</body><body package="PostgreSQL Tests" selector="test17">test17	"^self 	Jay O'Connor found that the following query would not work with the EXDI + PostgreSQL:		insert into exdiTest17 (val1, val2 ) values ('What\'s the problem?', 'val2 String')	Taking out either the escaped quote, or the question mark from the first value stops	the problem happening.	Jay thinks this is a bug in ExternalDatabaseSession&gt;&gt;setupQuery:.  I'd agree."	"self test17"	| connection session |	connection := self subjectConnection.	session := connection getSession.	SpExceptionContext 		for: 			[			[session				prepare: 'drop table exdiTest17';				execute] 					on: connection class externalDatabaseErrorSignal					do: [:e | ].			session 				prepare: 'create table exdiTest17 (	val1		varchar(100),	val2		varchar(100))'.			session execute.			session := connection getSession.			session				prepare: 'insert	into exdiTest17 (val1, val2 )	values (''What\''s the problem?'', ''val2 String'')';				execute.			connection class externalDatabaseErrorSignal 				handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]				do: 					[| answer rows |					session						prepare: 'select * from exdiTest17';						execute.					rows := OrderedCollection new.					[(answer := session answer) == #noMoreAnswers] 						whileFalse: [rows := rows , answer upToEnd].					(rows first collect: [:x | x class name]) = #(#ByteString #ByteString) 						ifFalse: [Exception raiseSignal: 'Test17 - failed']]]		on: InvalidDescriptorCount		do: [:ex | self signalFailure: 'We''ve hit the suspected bug.'].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test20">test20	"^self 	I test handling notice responses. I create two tables, each with a prmary key specified as part of the 	'create table'. This causes PostgreSQL to raise a notice response indicating that the primary key 	clause forced the creation of an index in the database. For the first table, I allow the session to 	suppress the notice response, but for the second call I ask the session to pass on these notice 	response exceptions."	"self test20"	| connection session noticeDetected |	noticeDetected := false.	self initializeTestDatabase.	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest20a'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop table exdiTest20b'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest20a (id int, name varchar(30), phone varchar(20),							PRIMARY KEY(id))'.	session execute.	session passNoticeResponses.	session prepare: 'create table exdiTest20b (id int, name varchar(30), phone varchar(20),							PRIMARY KEY(id))'.	[session execute] on: PostgreSQLNoticeResponse do: [:exception | exception isNoticeResponse			ifTrue: 				[noticeDetected := true.				exception resume]			ifFalse: [exception pass]].	session suppressNoticeResponses.	session prepare: 'INSERT INTO exdiTest20a (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute; answer].	session prepare: 'INSERT INTO exdiTest20b (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute; answer].	session prepare: 'drop table exdiTest20a'.	session execute.	session prepare: 'drop table exdiTest20b'.	session execute.	connection disconnect.	noticeDetected ifFalse: [self halt: 'test20 failed - a notice exception should have been handled.'].	^self</body><body package="PostgreSQL Tests" selector="test21">test21	"^self 	I test the use of database rules. I create two tables. The first is a data table, and the second is a log 	table. I create a rule that makes an entry in the log table every time a row in the data table is 	updated."	"self test21"	| connection session rows answer |	connection := self subjectConnection.	session := connection getSession.	session passNoticeResponses.	[session prepare: 'drop table exdiTest21data'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop table exdiTest21log'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest21data_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest21data (id int, name text, phone varchar(21))'.	session execute.	session prepare: 'create table exdiTest21log (oldName text, newName text)'.	session execute.	session prepare: '			create rule exdiTest21data_update as on update to exdiTest21data			do insert into exdiTest21log (oldName, newName ) values (old.name, new.name);'.	session execute.	session prepare: 'INSERT INTO exdiTest21data (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute].	session prepare: 'update exdiTest21data set name = ''Harry'' where name = ''Larry'';'.	session execute.	session prepare: 'select oldname, newname from exdiTest21log where oldname = ''Larry'';'.	session execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Larry' 'Harry')) ifFalse: [Exception raiseSignal: 'Test21 - failed'].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test22">test22	"^self 	I test the use of database rules calling functions. As with test 21, I create two tables. The first is a 	data table, and the second is a log 	table. I create a rule that makes an entry in the log table every 	time a row in the data table is updated. The extra twist here is that I call a function as well."	"self test22"	| connection session rows answer |	connection := self subjectConnection.	session := connection getSession.	session passNoticeResponses.	[session prepare: 'drop table exdiTest22data'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop table exdiTest22log'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest22data_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest22data (id int, name text, phone varchar(22))'.	session execute.	session prepare: 'create table exdiTest22log (oldName text, newName text, attime timestamp)'.	session execute.	session prepare: '			create rule exdiTest22data_update as on update to exdiTest22data			do insert into exdiTest22log (oldName, newName, attime ) values (old.name, new.name, now());'.	session execute.	session prepare: 'INSERT INTO exdiTest22data (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute].	session prepare: 'update exdiTest22data set name = ''Harry'' where name = ''Larry'';'.	session execute.	session prepare: 'select oldname, newname from exdiTest22log where oldname = ''Larry'';'.	session execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Larry' 'Harry')) ifFalse: [Exception raiseSignal: 'Test22 - failed'].	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test30">test30	"^self 	I test handling blobs. I create a table with an oid column, and then I execute some SQL to add a blob 	into that column. Under the covers, the exdi interface must spot the fact that this is an attempt to 	write a blob, and must first call a function to store the binary data, and put the oid of that blob into 	the oid column in place of the blob itself. 	Without blob-removal rules, this test will add three new blobs to the database every time it's run."	"self test30"	| connection session testBlob values rows answer |	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest30'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest30_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest30 (name varchar(30), blobdata oid )'.	session execute.	session prepare: '			create rule exdiTest30_update as on update to exdiTest30			do select lo_unlink(old.blobdata) from exdiTest30;'.	session execute.	testBlob := PostgreSQLEXDIBLOB on: (ByteArray withAll: (0 to: 200)).	connection begin.	session prepare: 'INSERT INTO exdiTest30 (name, blobdata) VALUES(?, ?)'.	values := OrderedCollection new.	values add: (Array with: 'Curly' with: testBlob).	values add: (Array with: 'Moe' with: testBlob).	values add: (Array with: 'Larry' with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select name from exdiTest30 order by name '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Curly') #('Larry') #('Moe')) ifFalse: [Exception raiseSignal: 'Test30 - failed'].	session prepare: 'select name, blobdata from exdiTest30 order by name '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | (aRow at: 2) isInteger ifFalse: [Exception raiseSignal: 'Test30 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest30'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test31">test31	"^self 	*** Can be changed *** 	I re-create a situation where the answer of a query differs between the first and second time it's 	executed. The problem was caused by a blob handling bug in the StORE mapping. This method can 	be extended to test other things."	"self test31"	| connection session testBlob values rows answer |	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest31'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest31_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest31 (number int4, name varchar(31), blobdata oid )'.	session execute.	session prepare: '			create rule exdiTest31_update as on update to exdiTest31			do select lo_unlink(old.blobdata) from exdiTest31;'.	session execute.	testBlob := PostgreSQLEXDIBLOB on: (ByteArray withAll: (0 to: 200)).	connection begin.	session prepare: 'INSERT INTO exdiTest31 (number, name, blobdata) VALUES(?, ?, ?)'.	values := OrderedCollection new.	values add: (Array			with: 1001			with: 'Curly'			with: testBlob).	values add: (Array			with: 1002			with: 'Moe'			with: testBlob).	values add: (Array			with: 1003			with: 'Larry'			with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select name from exdiTest31 order by number '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Curly') #('Moe') #('Larry')) ifFalse: [Exception raiseSignal: 'Test31 - failed'].	session prepare: 'select name, blobdata from exdiTest31 order by name '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | (aRow at: 2) isInteger ifFalse: [Exception raiseSignal: 'Test31 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest31'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test32">test32	"^self 	I insert three smallish (256 bytes) byte arrays into a table. This just makes sure that the translation 	to/from the database works OK."	"self test32"	| connection session testBlob values rows answer testBlobStream |	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest32'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest32 (number int4,  bytes bytea )'; execute.	testBlobStream := ByteArray new writeStream.	testBlobStream nextPutAll: (0 to: 255).	testBlob := testBlobStream contents.	connection begin.	session prepare: 'INSERT INTO exdiTest32 (number, bytes) VALUES( ?, ?)'.	values := OrderedCollection new.	values add: (Array with: 1001 with: testBlob).	values add: (Array with: 1002 with: testBlob).	values add: (Array with: 1003 with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select bytes from exdiTest32 order by number '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | aRow first = testBlob ifFalse: [Exception raiseSignal: 'Test32 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest32'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test33">test33	"^self 	I insert a single very large (&gt;8k) byte array into a table. This should 	force the creation of multiple byte array framgments.	This test may 	become interesting for future versions of PostgreSQL which can 	handle tuples &gt; 8Kb."	"self test33"	| connection session testBlob values rows answer testBlobStream |	self notYetImplemented.	connection := self subjectConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest33'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest33 (number int4,  bytes bytea )'; execute.	testBlobStream := (ByteArray new: 9000) writeStream.	33 timesRepeat: [testBlobStream nextPutAll: (0 to: 255)].	testBlob := testBlobStream contents.	connection begin.	session prepare: 'INSERT INTO exdiTest33 (number, bytes) VALUES( ?, ?)'.	values := OrderedCollection new.	values add: (Array with: 1001 with: testBlob).	values add: (Array with: 1002 with: testBlob).	values add: (Array with: 1003 with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select bytes from exdiTest33 order by number '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | aRow first = testBlob ifFalse: [Exception raiseSignal: 'Test33 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest33'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="test34">test34	"^self 	This test makes sure that we can read and write timestamps. Note that this test is really just an illustration.  Because timestamp formats can be changed using PostgreSQL database preferences, the translation blocks need to be tweaked to match the db config."	"self test34"	| connection session testTimestamp values rows answer testTimestampString testTimestampZString |	connection := self subjectConnection.	session := connection getSession.	[session		prepare: 'drop table exdiTest34';		execute]		on: connection class externalDatabaseErrorSignal		do: [:e | ].	session		prepare:				'create table exdiTest34 (number int4,  timestamp_1 timestamp, timestamp_z timestamptz )';		execute.	testTimestamp := (Timestamp now)		millisecond: 0;		yourself.	testTimestampString := self timestampStringFor: testTimestamp.	testTimestampZString := self timestampZStringFor: testTimestamp.	connection begin.	session prepare:			'INSERT INTO exdiTest34 (number, timestamp_1, timestamp_z ) VALUES( ?, ?, ?)'.	values := OrderedCollection new.	values		add:			(Array with: 1001 with: testTimestampString with: testTimestampZString).	values		add:			(Array with: 1002 with: testTimestampString with: testTimestampZString).	values		add:			(Array with: 1003 with: testTimestampString with: testTimestampZString).	values		do:			[:entry | 			session				bindInput: entry;				execute;				answer].	connection commit.	session		prepare: 'set datestyle to iso';		execute.	session		prepare:				'select timestamp_1, timestamp_z from exdiTest34 order by number ';		execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows		do:			[:aRow | 			((aRow at: 1) = testTimestamp and: [(aRow at: 2) = testTimestamp])				ifFalse: [Exception raiseSignal: 'Test34 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest34'.	session execute.	connection disconnect.	^self</body></methods><methods><class-id>PostgreSQLEXDITest</class-id> <category>services</category><body package="PostgreSQL Tests" selector="initializeTestDatabase">initializeTestDatabase	^self class initializeTestDatabase</body><body package="PostgreSQL Tests" selector="initializeTestDataUsing:">initializeTestDataUsing: aConnection 	^self class initializeTestDataUsing: aConnection</body><body package="PostgreSQL Tests" selector="subjectConnection">subjectConnection	^self class subjectConnection</body><body package="PostgreSQL Tests" selector="subjectEnvironmentString">subjectEnvironmentString	^self class subjectEnvironmentString</body><body package="PostgreSQL Tests" selector="subjectPasswordString">subjectPasswordString	^self class subjectPasswordString</body><body package="PostgreSQL Tests" selector="subjectUsernameString">subjectUsernameString	^self class subjectUsernameString</body><body package="PostgreSQL Tests" selector="timestampStringFor:">timestampStringFor: aTimestamp	| targetStream |	targetStream := WriteStream on: String new.	self timestampStringFor: aTimestamp on: targetStream.	^targetStream contents</body><body package="PostgreSQL Tests" selector="timestampStringFor:on:">timestampStringFor: aTimestamp on: aStream	"^self"	self		writeInteger: aTimestamp year		digits: 4		to: aStream.	aStream nextPut: $-.	self		writeInteger: aTimestamp month		digits: 2		to: aStream.	aStream nextPut: $-.	self		writeInteger: aTimestamp dayOfMonth		digits: 2		to: aStream.	aStream space.	self		writeInteger: aTimestamp hour		digits: 2		to: aStream.	aStream nextPut: $:.	self		writeInteger: aTimestamp minute		digits: 2		to: aStream.	aStream nextPut: $:.	self		writeInteger: aTimestamp second		digits: 2		to: aStream.	^self</body><body package="PostgreSQL Tests" selector="timestampZStringFor:">timestampZStringFor: aTimestamp	| targetStream |	targetStream := WriteStream on: String new.	self timestampStringFor: aTimestamp on: targetStream.	targetStream		space;		nextPutAll: 'zulu'.	^targetStream contents</body><body package="PostgreSQL Tests" selector="writeInteger:digits:to:">writeInteger: anInteger digits: numberOfDigits to: aStream	"^selfI write the string form of anInteger to aStream with leading zeros to make the string exactly numberOfDigits long."	anInteger printOn: aStream paddedWith: $0 to: numberOfDigits base: 10.	^self</body></methods><methods><class-id>PostgreSQLEXDITest</class-id> <category>license</category><body package="PostgreSQL Tests" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDITest class</class-id> <category>services</category><body package="PostgreSQL Tests" selector="initializeTestDatabase">initializeTestDatabase	"^self 	I initialize the test database using a &gt;&gt;testConnection. I create and populate three tables in the 	database."	"self initializeTestDatabase"	| connection |	connection := self subjectConnection.	self initializeTestSchemaUsing: connection.	self initializeTestDataUsing: connection.	connection disconnect.	^self</body><body package="PostgreSQL Tests" selector="initializeTestDataUsing:">initializeTestDataUsing: aConnection 	"^self 	I populate the test database via aConnection."	| session |	session := aConnection getSession.	session prepare: 'INSERT INTO task (name) VALUES(?)'.	#(#('Admin') #('Vacation') #('Project A') #('Project B') #('Project C') #('Project D')) do: [:entry | session bindInput: entry; execute; answer].	session prepare: 'INSERT INTO assignee (name) VALUES(?)'.	#(#('Development') #('QA') #('Bill') #('Bert') #('Bob') #('Barry')) do: [:entry | session bindInput: entry; execute; answer].^self</body><body package="PostgreSQL Tests" selector="initializeTestSchemaUsing:">initializeTestSchemaUsing: aConnection 	"^self 	I initialize the test schema using aConnection. I do not populate the schema."	|  session |	session := aConnection getSession.	[session prepare: 'drop table task'; execute] on: aConnection class externalDatabaseErrorSignal do: [:e|].	[session prepare: 'drop table assignee'; execute] on: aConnection class externalDatabaseErrorSignal do: [:e|].	[session prepare: 'drop table assignment'; execute] on: aConnection class externalDatabaseErrorSignal do: [:e|].	session prepare: 'create table task (name varchar(30))'; execute.	session prepare: 'create table assignee (name varchar(30))'; execute.	session prepare: 'create table assignment (task oid, assignee oid)'; execute.	^self</body><body package="PostgreSQL Tests" selector="subjectConnection">subjectConnection	| connection |	connection := PostgreSQLEXDIConnection new.	connection		username: self subjectUsernameString;		password: self subjectPasswordString;		environment: self subjectEnvironmentString.	connection connect.	^connection</body><body package="PostgreSQL Tests" selector="subjectEnvironmentString">subjectEnvironmentString	"^a String 	I return the connection environment string to use for all tests. I compose this from &gt;&gt;testHost and 	&gt;&gt;testDatabaseName from the PostgreSQLTest class."	^PostgreSQLTest testHost , '_' , PostgreSQLTest testDatabaseName</body><body package="PostgreSQL Tests" selector="subjectPasswordString">subjectPasswordString	"^a String 	I return the password I'll use for testing.  I delegate this to the PostgreSQLTest class"	^PostgreSQLTest testPassword</body><body package="PostgreSQL Tests" selector="subjectUsernameString">subjectUsernameString	"^a String 	I return the username I'll use for all tests.  I delegate this to the PostgreSQLTest class"	^PostgreSQLTest testUserName</body></methods><methods><class-id>PostgreSQLTestVictim</class-id> <category>comparing</category><body package="PostgreSQL Tests" selector="=">= anOther 	"^a Boolean 	I return true is anOther is the equivalent of me, otherwise I return false.."	^anOther class == self class and: 			[self identity = anOther identity 				and: [self nameString = anOther nameString]]</body><body package="PostgreSQL Tests" selector="hash">hash	^self identity hash + self nameString hash</body></methods><methods><class-id>PostgreSQLTestVictim</class-id> <category>accessing</category><body package="PostgreSQL Tests" selector="identity">identity	"^an Integer 	I return my identity. This value means nothing really, it's just something for me to hold onto for 	testing purposes."	^identity</body><body package="PostgreSQL Tests" selector="identity:">identity: anInteger 	"^self 	I record my identity. c.f self&gt;&gt;identity."	identity := anInteger.	^self</body><body package="PostgreSQL Tests" selector="nameString">nameString	"^a String 	I return my name string. This value means nothing really, it's just something for me to hold onto for 	testing purposes."	^nameString</body><body package="PostgreSQL Tests" selector="namestring">namestring	"^a String 	This is the version of the nameString method that is send by the EXDI when I use 'AS' to specify the column name as 'nameString' - the case is lost.  See self class test16.."	^self nameString</body><body package="PostgreSQL Tests" selector="nameString:">nameString: aString 	"^self 	I record my name string. c.f. self&gt;&gt;nameString."	nameString := aString.	^self</body><body package="PostgreSQL Tests" selector="namestring:">namestring: aString 	"^self 	This is the version of the nameString method that is send by the EXDI when I use 'AS' to specify the column name as 'nameString' - the case is lost.  See self class test16.."	^self nameString: aString</body></methods><methods><class-id>PostgreSQLTestVictim</class-id> <category>initialize-release</category><body package="PostgreSQL Tests" selector="withIdentity:andNameString:">withIdentity: anInteger andNameString: aString 	"^self 	I initialize myself. I'm just a victim for use in tests, and do not represent a test."	self identity: anInteger.	self nameString: aString.	^self</body></methods><methods><class-id>PostgreSQLTestVictim class</class-id> <category>instance creation</category><body package="PostgreSQL Tests" selector="withIdentity:andNameString:">withIdentity: anInteger andNameString: aString 	"^aPostgreSQLEXDITest 	I return an instance of myself. This new instance is just a victim for use in tests, and does not 	represent a test."	^self new withIdentity: anInteger andNameString: aString</body></methods><methods><class-id>PostgreSQLTest</class-id> <category>tests</category><body package="PostgreSQL Tests" selector="test01">test01	"^a Connection 	I just create a connection, and then immediately close it."	"self test01"	| connection |	connection := PostgreSQLConnection using: self subjectParameterSet.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test02">test02	"^self 	I create a connection, run an empty query, and then close the session."	"self test02"	| connection queryMessage |	connection := PostgreSQLConnection using: self subjectParameterSet.	queryMessage := connection newQuery.	queryMessage execute.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test03">test03	"^self 	I create a connection, run a simple query (SELECT 1 + 3;), and then close the 	session."	"self test03"	| connection queryMessage result |	connection := PostgreSQLConnection using: self subjectParameterSet.	queryMessage := connection newQuery.	queryMessage queryString: 'SELECT 1 + 3;'.	result := queryMessage execute.	self showResults: result.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test04">test04	"^self 	I create a table, populate it, query it and then drop it.  NOTE: table 'test04' must not exist prior to this test."	"self test04"	| connection |	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection 				executeQuery: 'create table test04 (a int2, b int2)').	self 		showResults: (connection executeQuery: 'insert into test04 values (1, 1)').	self 		showResults: (connection executeQuery: 'insert into test04 values (2, 1)').	self 		showResults: (connection executeQuery: 'insert into test04 values (3, 1)').	self showResults: (connection executeQuery: 'select a, b from test04').	self showResults: (connection executeQuery: 'drop table test04').	connection close.	^self</body><body package="PostgreSQL Tests" selector="test05">test05	"^self 	I create a table containing a column of each data type. I then insert a row into the table, query it and 	drop it."	"self messageLogReset. self test05"	| connection |	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection 				executeQuery: 'create table test05 (	textField		text,	varcharField		varchar(4),	charField		char(4),	integerField		integer,	int2Field		int2,	int8Field		int8,	oidField			oid,	numericField	numeric(6,2),	floatField		float,	float4Field		float4,	dateField		date,	timeField		time,	timestampField	timestamp,	intervalField		interval,	boolField		bool,	pointField		point,	lsegField		lseg,	pathField		path,	boxField		box,	circleField		circle,	polygonField	polygon,	inetField		inet,	cidrField		cidr,	macaddrField	macaddr,	byteArrayField	bytea)').	self showResults: (connection 				executeQuery: 'insert into test05(	textField,	varcharField,	charField,	integerField,	int2Field,	int8Field,	oidField,	numericField,	floatField,	float4Field,	dateField,	timeField,	timestampField,	intervalField,	boolField,	pointField,	lsegField,	pathField,	boxField,	circleField,	polygonField,	inetField,	cidrField,	macaddrField,	byteArrayField)values (	''Text value'',	''VC1'',	''C4'',	1234,	2468,	1248,	1357,	123.45,	0.1234,	123456.78,	''07-09-2000'',	''14:53:42'',	''07-09-2000 14:54:55'',	''4 05:00:30'',	''true'',	''(2,7)'',	''[(0,0),(1,3)]'',	''((0,0),(3,0),(4,5),(1,6))'',	''(1,1),(3,3)'',	''&lt;(1,2),60&gt;'',	''((3,1),(3,3),(1,0))'',	''192.168.1.12'',	''172.20.90.0/24'',	''0:50:4:1d:f6:db'',	''000'')').	self showResults: (connection executeQuery: 'select * from test05').	self showResults: (connection executeQuery: 'drop table test05').	connection close.	^self messageLog contents</body><body package="PostgreSQL Tests" selector="test06">test06	"^self 	I make a connection and then I get it's data type and function tables. 	This forces the connection to query the database it represents a 	connection to."	"self messageLogReset. self test06. self messageLog contents"	| connection dataTypes functions |	connection := PostgreSQLConnection using: self subjectParameterSet.	dataTypes := connection dataTypeTable.	self messageLog nextPutAll: dataTypes byObjectId printString.	functions := connection functionTable.	self messageLog nextPutAll: functions byObjectId printString.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test07">test07	"^self 	I create a table containing a 'bytea' data type and populate it with 	some byte data which I then read back and make sure that I read 	the same thing that I wrote. I use only alphanumeric 'characters' in	the bytes so that they are writable to the bytea data type - which	 can't hold real bytes despite it's name."	"self messageLogReset. self test07"	| connection insertQuery sourceBytes queryResultList retrievedString sourceString loggingBlock |	loggingBlock := [:aMessage | aMessage printOn: self messageLog].	connection := PostgreSQLConnection using: self subjectParameterSet.	connection readStream loggingBlock: loggingBlock.	connection writeStream loggingBlock: loggingBlock.	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'drop table test07')]		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection 				executeQuery: 'create table test07 (integerField	integer,	byteArrayField bytea)').	sourceBytes := ByteArray 				withAll: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' 						asArray collect: [:ch | ch asInteger]).	sourceString := String 				withAll: (sourceBytes asArray collect: [:aByte | aByte asCharacter]).	insertQuery := 'insert into test07 (	integerField, byteArrayField) values (1234, ''' 				, sourceString , ''')'.	self showResults: (connection executeQuery: insertQuery).	queryResultList := connection executeQuery: 'select * from test07'.	self showResults: queryResultList.	retrievedString := (queryResultList queryResults first rows first fields 				at: 2) bytes 				valueAsString.	self showResults: (connection executeQuery: 'drop table test07').	retrievedString = sourceString 		ifFalse: [PostgreSQLException raiseSignal: 'test07 failed'].	connection close.	^self messageLog contents</body><body package="PostgreSQL Tests" selector="test08">test08	"^a Connection 	I test to make sure that a bad login is handled OK. I call test08b 	which does the login and returns an exception. I check that the 	exception is the one I expect. 	This test is now written in this way to accomodate pre-ANSI 	GemStone exception handling."	"self test08"	| exception |	exception := self test08b.	(exception isNil or: [(exception messageText copyFrom: 1 to: 5)			~= 'FATAL'])		ifTrue: [PostgreSQLException raiseSignal: 'test08 failed'].	^self</body><body package="PostgreSQL Tests" selector="test08b">test08b	"^a Connection 	I try to create a connection to a database that does not exist, I catch 	the exception and return it."	"self test08"	| parameterSet |	parameterSet := self subjectParameterSet.	parameterSet databaseName: 'DoesNotExist'.	SpExceptionContext		for: [PostgreSQLConnection using: parameterSet]		on: PostgreSQLErrorResponse		do: [:exception | ^exception].	^nil</body><body package="PostgreSQL Tests" selector="test09">test09	"^a Connection 	I try to create a connection to a database that does not exist, I catch 	the exception and return it."	"self test09"	| parameterSet |	parameterSet := self subjectParameterSet.	parameterSet databaseName: 'DoesNotExist'.	SpExceptionContext 		for: [PostgreSQLConnection using: parameterSet]		on: PostgreSQLErrorResponse		do: [:exception | ^exception].	^nil</body><body package="PostgreSQL Tests" selector="test10">test10	"^self 	I use more sophisticated SQL to force some notification messages."	"self messageLogReset. self test10"	| connection loggingBlock|	loggingBlock := [:aMessage| aMessage printOn: self messageLog ].	connection := PostgreSQLConnection using: self subjectParameterSet.	connection readStream loggingBlock:  loggingBlock.	connection writeStream loggingBlock:  loggingBlock.	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'drop table test10;')]		on: PostgreSQLErrorResponse		do: [:exception | ].	SpExceptionContext 		for: 			[self showResults: (connection 						executeQuery: 'create table test10 (a int2, b int2, PRIMARY KEY(a))')]		on: PostgreSQLNoticeResponse		do: [:exception | exception resume].	self 		showResults: (connection executeQuery: 'insert into test10 values (1, 1)').	self 		showResults: (connection executeQuery: 'insert into test10 values (2, 1)').	self 		showResults: (connection executeQuery: 'insert into test10 values (3, 1)').	self showResults: (connection executeQuery: 'select a, b from test10').	self showResults: (connection executeQuery: 'drop table test10').	connection close.	^self messageLog contents</body><body package="PostgreSQL Tests" selector="test11">test11	"^self 	I include mutiple queries in a single &gt;&gt;executeQuery."	"self messageLogReset. self test11"	| connection |	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection 				executeQuery: 'select oid, relname from pg_class where relname = ''pg_class'' ;select oid, typname from pg_type where typname = ''bool'';').	connection close.	^self messageLog contents</body><body package="PostgreSQL Tests" selector="test12">test12	"^self 	I test logging in to a database which demands a pasword. I take the 	basic test parameter set and replace the database name to a secured 	database, and add the password. A database and user are created 	(and removed) for this test.	host         authtest     127.0.0.1  255.0.0.0         md5	The idea is to specifically demand that logins to the database authtest must use a password (clear text)."	"self messageLogReset. self test12. self messageLog contents"	| parameterSet connection queryMessage result |	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: 			[queryMessage := connection newQuery.			queryMessage queryString: 'drop user user12;'.			result := queryMessage execute.			self showResults: result]		on: PostgreSQLErrorResponse		do: [:exception | exception].	SpExceptionContext 		for: 			[queryMessage queryString: 'drop database authtest;'.			result := queryMessage execute.			self showResults: result]		on: PostgreSQLErrorResponse		do: [:exception | exception].	connection close.	connection := PostgreSQLConnection using: self subjectParameterSet.	queryMessage := connection newQuery.	queryMessage queryString: 'create database authtest;'.	result := queryMessage execute.	self showResults: result.	queryMessage := connection newQuery.	queryMessage queryString: 'create user user12 with password ''test12'';'.	result := queryMessage execute.	self showResults: result.	connection close.	parameterSet := self subjectParameterSet.	parameterSet databaseName: 'authtest'.	parameterSet userName: 'user12'.	parameterSet password: 'test12'.	connection := PostgreSQLConnection using: parameterSet.	self showResults: (connection 				executeQuery: 'select ''Logon OK using clear text password!'', 1+ 3;').	connection close.	(Delay forMilliseconds: 20) wait.	connection := PostgreSQLConnection using: self subjectParameterSet.	queryMessage := connection newQuery.	queryMessage queryString: 'drop user user12;'.	result := queryMessage execute.	self showResults: result.	queryMessage queryString: 'drop database authtest;'.	result := queryMessage execute.	self showResults: result.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test13">test13	"^self 	I make multiple queries in a single &gt;&gt;executeQuery: where one of 	the queries causes an ErrorResponseMessage to be returned. What 	I'm looking for is to be able handle the exception and still get the 	results from the non-errored portions of the query - but I can't, 	because with this test PostgreSQL throws everything out at the 	compile stage - so nothing executes. I need a better test."	"self test13"	| connection |	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: 			[self showResults: (connection 						executeQuery: 'select oid, relname from pg_class where relname = ''pg_class'' ;select non_field1 from pg_class where relname = ''pg_class'' ;select oid, typname from pg_type where typname = ''bool'';')]		on: PostgreSQLErrorResponse		do: [:exception | exception].	connection close.	^self</body><body package="PostgreSQL Tests" selector="test14">test14	"^self 	I open a connection, do a simple query, and then close it - twice. The 	second closing should not raise an exception."	"self test14"	| connection |	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'select 1+ 1;')]		on: PostgreSQLErrorResponse		do: [:exception | exception].	connection close.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test27">test27	"^self 	I make a simple function call. This is a simple test of function calling."	"self test27"	| connection functionCall result |	connection := PostgreSQLConnection using: self subjectParameterSet.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #timenow).	result := functionCall execute.	self showFunctionCallResult: result.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test28">test28	"^self 	I directly manipulate a 'large object' (BLOB). The large object in question is actually a rather small 	ByteArray, but I perform every one of the provided functions on this object, viz: create (lo_creat), 	import(lo_import), export(lo_export), open (lo_open), write (lo_write), read (lo_read), seek (lo_lseek), 	close (lo_close) and delete/remove(lo_unlink).  Note that the literal ByteSymbol s are quoted to	make Squeak happy (otherwise it thinks the undersores in the function names are 'return' symbols)."	"self test28"	| connection testBlob functionCall result blobOid blobDescriptor retrievedBlob blobSize currentPosition |	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection executeQuery: 'begin').	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_creat').	functionCall 		addArgument: (ByteValue size: 4 value: (ByteArray withAll: #(0 6 0 0)) for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	blobOid := result functionResponse value asIntValue.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_open').	functionCall addArgument: blobOid.	functionCall 		addArgument: (ByteValue size: 4 value: (ByteArray withAll: #(0 6 0 0)) for: functionCall).	result := functionCall execute.	blobDescriptor := result functionResponse value asIntValue.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lowrite').	functionCall addArgument: blobDescriptor.	testBlob := ByteArray withAll: (0 to: 200).	functionCall addArgument: (ByteValue size: testBlob size value: testBlob for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_close').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_open').	functionCall addArgument: blobOid.	functionCall 		addArgument: (ByteValue size: 4 value:  (ByteArray withAll: #(0 6 0 0)) for: functionCall).	result := functionCall execute.	blobDescriptor := result functionResponse value asIntValue.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_tell').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	currentPosition := result functionResponse value asIntValue value.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_lseek').	functionCall addArgument: blobDescriptor.	functionCall addArgument: (IntValue size: 32 value: 0 for: functionCall).	functionCall addArgument: (IntValue size: 32 value: 2 for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_tell').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	blobSize := result functionResponse value asIntValue value.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_lseek').	functionCall addArgument: blobDescriptor.	functionCall addArgument: (IntValue size: 32 value: currentPosition for: functionCall).	functionCall addArgument: (IntValue size: 32 value: 0  for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'loread').	functionCall addArgument: blobDescriptor.	functionCall addArgument: (IntValue size: 32 value: blobSize for: functionCall).	result := functionCall execute.	retrievedBlob := result functionResponse value bytes.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_close').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_unlink').	functionCall addArgument: (IntValue size: 32 value: blobOid value for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	self showResults: (connection executeQuery: 'commit').	connection close.	blobSize = 201 ifFalse: [1 halt: 'The blob size shoule be 201!'].	retrievedBlob = testBlob 		ifFalse: [1 halt: 'These two should *not* be different!'].	^self</body><body package="PostgreSQL Tests" selector="test30">test30	"^self 	I test that I can make a multibyte database."	"self messageLogReset. self test30. self messageLog contents"	| connection result queryMessage |	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: 			[queryMessage := connection newQuery.			queryMessage queryString: 'drop database multibytetest;'.			result := queryMessage execute.			self showResults: result]		on: PostgreSQLErrorResponse		do: [:exception | ].	queryMessage := connection newQuery.	queryMessage 		queryString: 'create database multibytetest with encoding = ''KOI8'';'.	result := queryMessage execute.	self showResults: result.	queryMessage := connection newQuery.	queryMessage queryString: 'drop database multibytetest;'.	result := queryMessage execute.	self showResults: result.	connection close.	^self</body><body package="PostgreSQL Tests" selector="test31">test31	"^self 	I make a KOI8 encoded database, create a test table and then delete it again."	"self messageLogReset. self test31. self messageLog contents"	| connection |	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'drop database koi8test;')]		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection 				executeQuery: 'create database koi8test with encoding = ''KOI8'';').	connection close.	connection := PostgreSQLConnection 				using: (self subjectParameterSet databaseName: 'koi8test').	self showResults: (connection 				executeQuery: 'create table test(string VARCHAR(3));').	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection executeQuery: 'drop database koi8test;').	connection close.	^self</body><body package="PostgreSQL Tests" selector="test32">test32	"^self 	I make a multibyte database, create a test table insert some KOI8 data into it, and read it back out.  Note that the short delay is needed after closing the KOI8 database and removing it (due to the backend session being a little slow to close).  This is a wierd test because I am putting KOI8 characters into a unicode string, and then allowing a #default encoding (probably UTF8) to send the data to the KOI8 encoded database - so the test is broken from a practical standpoint, but I think it's interesting anyway.  So there.  Tests 33 &amp; 34 make more sense."	"self messageLogReset. self test32. self messageLog contents"	| connection koi8Stream |	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'drop database koi8test;')]		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection 				executeQuery: 'create database koi8test with encoding = ''KOI8'';').	connection close.	connection := PostgreSQLConnection 				using: (self subjectParameterSet databaseName: 'koi8test').	self showResults: (connection 				executeQuery: 'create table test(string VARCHAR(3));').	koi8Stream := WriteStream on: String new.	koi8Stream		nextPutAll: 'insert into test (string) values (''';		nextPut: (244 asCharacter);		nextPut: (245 asCharacter);		nextPut: (246 asCharacter);		nextPutAll: ''');'.	self showResults: (connection executeQuery: koi8Stream contents).	self showResults: (connection executeQuery: 'select * from test;').	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection executeQuery: 'drop database koi8test;').	connection close.	^self</body><body package="PostgreSQL Tests" selector="test33">test33	"^self 	I make a multibyte database, create a test table insert some Unicode data 	into it. I try to get the backend to give me the results back in Unicode form."	"self messageLogReset. self test33. self messageLog contents"	| connection queryStream results testString |	SpEnvironment isVisualWorks ifFalse: [^self].	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: 			[self showResults: (connection executeQuery: 'drop database unicodetest;')]		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection 				executeQuery: 'create database unicodetest with encoding = ''UNICODE'';').	connection close.	connection := PostgreSQLConnection 				using: (self subjectParameterSet databaseName: 'unicodetest').	self showResults: (connection 				executeQuery: 'set client_encoding to ''UNICODE'';').	connection stringEncodingName: #'UTF-8'.	self showResults: (connection 				executeQuery: 'create table test(string VARCHAR(3));').	queryStream := WriteStream on: String new.	testString := String 				with: 16r0422 asCharacter				with: 16r0423 asCharacter				with: 16r0416 asCharacter.	queryStream		nextPutAll: 'insert into test (string) values (''';		nextPutAll: testString;		nextPutAll: ''');'.	self showResults: (connection executeQuery: queryStream contents).	results := connection executeQuery: 'select * from test;'.	results first rows first fields first asString = testString 		ifFalse: [1 halt: 'Oops - the strings should match'].	self showResults: results.	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection executeQuery: 'drop database unicodetest;').	connection close.	^self</body><body package="PostgreSQL Tests" selector="test34">test34	"^self 	OK, we make a KOI8 database with a simple table.  We set the driver encoding (this end) to KOI8 and write out some characters.  Then we tell PostgreSQL to use a client encoding of unicode, which maps to UTF8 at this end.  We read in the data from the table, and the characters should match."	"self messageLogReset. self test34. self messageLog contents"	| connection testString koi8Stream results |	SpEnvironment isVisualWorks ifFalse: [^self].	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'drop database koi8test;')]		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection 				executeQuery: 'create database koi8test with encoding = ''KOI8'';').	connection close.	connection := PostgreSQLConnection 				using: (self subjectParameterSet databaseName: 'koi8test').	connection stringEncodingName: #'KOI8-U'.	self showResults: (connection 				executeQuery: 'create table test(string VARCHAR(3));').	testString := String 				with: 16r0422 asCharacter				with: 16r0423 asCharacter				with: 16r0416 asCharacter.	koi8Stream := WriteStream on: String new.	koi8Stream		nextPutAll: 'insert into test (string) values (''';		nextPutAll: testString;		nextPutAll: ''');'.	self showResults: (connection executeQuery: koi8Stream contents).	connection close.	connection := PostgreSQLConnection 				using: (self subjectParameterSet databaseName: 'koi8test').	self showResults: (connection 				executeQuery: 'set client_encoding to ''UNICODE'';').	connection stringEncodingName: #UTF8.	results := connection executeQuery: 'select * from test;'.	results first rows first fields first asString = testString 		ifFalse: [1 halt: 'Oops - the strings should match'].	self showResults: results.	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection executeQuery: 'drop database koi8test;').	connection close.	^self</body><body package="PostgreSQL Tests" selector="test40">test40	"^self 	Testing MD5 authentication.  Make sure that you have something like the following line in your pg_hba.conf file:	host         md5test     127.0.0.1  255.0.0.0         md5	The idea is to specifically demand that logins to the database md5test must use MD5 encoding for the password."	"self messageLogReset. self test40. self messageLog contents"	| connection |	SpEnvironment isGemStone ifTrue: [^self].	connection := PostgreSQLConnection using: self subjectParameterSet.	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'drop database md5test;')]		on: PostgreSQLErrorResponse		do: [:exception | ].	SpExceptionContext 		for: [self showResults: (connection executeQuery: 'drop user md5user;')]		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection executeQuery: 'create database md5test;').	self showResults: (connection 				executeQuery: 'create user md5user with password ''md5password'';').	connection close.	connection := PostgreSQLConnection using: ((self subjectParameterSet)						databaseName: 'md5test';						userName: 'md5user';						password: 'md5password';						yourself).	self showResults: (connection 				executeQuery: 'select ''Logon OK using MD5 password!'', 1+ 3;').	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self subjectParameterSet.	self showResults: (connection executeQuery: 'drop database md5test;').	self showResults: (connection executeQuery: 'drop user md5user;').	connection close.	^self</body></methods><methods><class-id>PostgreSQLTest</class-id> <category>services</category><body package="PostgreSQL Tests" selector="messageLog">messageLog	^self class messageLog</body><body package="PostgreSQL Tests" selector="showFunctionCallResult:">showFunctionCallResult: result 	self class showFunctionCallResult: result</body><body package="PostgreSQL Tests" selector="showResults:">showResults: aResultList 	self class showResults: aResultList</body></methods><methods><class-id>PostgreSQLTest</class-id> <category>license</category><body package="PostgreSQL Tests" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLTest</class-id> <category>resources</category><body package="PostgreSQL Tests" selector="subjectParameterSet">subjectParameterSet	^self class subjectParameterSet</body></methods><methods><class-id>PostgreSQLTest class</class-id> <category>testing - defaults</category><body package="PostgreSQL Tests" selector="subjectParameterSet">subjectParameterSet	"^a ConnectionParameterSet 	I return the connection parameter set to be used for all my tests. Edit this method to suit your 	environment."	| parameterSet |	parameterSet := ConnectionParameterSet new.	parameterSet		host: self testHost;		port: self testPort;		databaseName: self testDatabaseName;		userName: self testUserName;		password: self testPassword.	^parameterSet</body><body package="PostgreSQL Tests" selector="testDatabaseName">testDatabaseName	"^String 	I return the name of the database to be used for testing. Some tests create (and then remove) their own databases, but for the rest, this is the name of the database to use."	^'test2'</body><body package="PostgreSQL Tests" selector="testHost">testHost	"^a String 	I return the name of the host I'll connect to for testing."	^'pgtesthost'</body><body package="PostgreSQL Tests" selector="testPassword">testPassword	"^a String	I return the to use when testing."	^String new</body><body package="PostgreSQL Tests" selector="testPort">testPort	"^an Integer 	I return the port number through which to connect to the PostgreSQL postmaster on &gt;&gt;testHost."	^5432</body><body package="PostgreSQL Tests" selector="testUserName">testUserName	"^a String 	I return the name of the user to be used for testing. This user must be very capable. The user must 	be able to create new databases and new users."	^'bbadger'</body></methods><methods><class-id>PostgreSQLTest class</class-id> <category>testing - support</category><body package="PostgreSQL Tests" selector="messageLog">messageLog	"^a WriteStream 	I return the current message log. This is intended for testing only."	messageLog isNil ifTrue: [messageLog := WriteStream on: String new].	^messageLog</body><body package="PostgreSQL Tests" selector="messageLog:">messageLog: aStreamLikeThing 	"^self 	Set the message log to something more interesting than a stream."	"self messageLog: Transcript"	messageLog := aStreamLikeThing.	^self</body><body package="PostgreSQL Tests" selector="messageLogReset">messageLogReset	"^self 	Reset the message log. It will be initialized again the next time 	someone access it."	"self messageLogReset"	messageLog := nil.	^self</body><body package="PostgreSQL Tests" selector="showFunctionCallResult:">showFunctionCallResult: result 	"^self 	I display the results in a rather crude way."	self messageLog cr; nextPutAll: '================='; cr.	self messageLog nextPutAll: 'Function call ...'; cr.	self messageLog nextPutAll: result request functionCallPacket function name; cr.	self messageLog nextPutAll: 'Result size: ' , result functionResponse value numberOfBytes printString; cr.	self messageLog nextPutAll: 'Result value: ' , result functionResponse value value printString; cr.	self messageLog nextPutAll: '================='; cr.	^self</body><body package="PostgreSQL Tests" selector="showResult:">showResult: result 	"^self 	I display the results in a rather crude way."	(self messageLog)		cr;		nextPutAll: '=================';		cr.	result rowDescription isNil 		ifFalse: 			[result rowDescription fieldDescriptions do: 					[:aFieldDescription | 					(self messageLog)						nextPutAll: aFieldDescription name;						tab].			(self messageLog)				cr;				nextPutAll: '---------------';				cr.			result rows do: 					[:aRow | 					aRow fields do: 							[:aField | 							aField isNil 								ifTrue: 									[(self messageLog)										tab;										tab]								ifFalse: 									[(self messageLog)										nextPutAll: aField asString;										tab]].					self messageLog cr].			(self messageLog)				nextPutAll: '---------------';				cr].	result completedResponses do: 			[:aCompletedResponse | 			(self messageLog)				nextPutAll: aCompletedResponse commandTag;				nextPutAll: ' complete.';				cr].	(self messageLog)		nextPutAll: '=================';		cr.	^self</body><body package="PostgreSQL Tests" selector="showResults:">showResults: aResultList 	"^self 	I display the results in aResultList."	(self messageLog) cr; nextPutAll: '+++++++++++++++++++++++++'; cr.	(self messageLog) nextPutAll: aResultList query queryMessage queryString; cr.	aResultList do: [:aResult | self showResult: aResult].	(self messageLog) cr; nextPutAll: '+++++++++++++++++++++++++'; cr.	^self</body></methods><methods><class-id>PostgreSQLLoggingTesting</class-id> <category>testing</category><body package="PostgreSQL Tests" selector="test10">test10	"^self 	I use the logging facilities to capture the messages exchanged with 	the backend for a particular connection."	"self test10"	| connection logStream |	connection := PostgreSQLConnection using: self subjectParameterSet.	logStream := String new writeStream.	PostgreSQLConnectionLog logEverythingFor: connection to: logStream.	connection executeQuery: 'create table test04 (a int2, b int2)'.	connection executeQuery: 'insert into test04 values (1, 1)'.	connection executeQuery: 'select a, b from test04'.	connection executeQuery: 'drop table test04'.	connection close.	^logStream contents</body><body package="PostgreSQL Tests" selector="test11">test11	"^self 	I use the logging facilities to capture the messages exchanged with the backend for a particular 	connection. I close the logging half way through the queries, just to see if I can."	"self test11"	| connection logStream log |	connection := PostgreSQLConnection using: self subjectParameterSet.	logStream := String new writeStream.	log := PostgreSQLConnectionLog logEverythingFor: connection to: logStream.	connection executeQuery: 'create table test04 (a int2, b int2)'.	connection executeQuery: 'insert into test04 values (1, 1)'.	log close.	connection executeQuery: 'select a, b from test04'.	connection executeQuery: 'drop table test04'.	connection close.	^logStream contents</body><body package="PostgreSQL Tests" selector="test12">test12	"^self 	I use the logging facilities to capture the messages exchanged with the backend for a particular 	connection. I pause the logging for a while and then resume, just to see if I can."	"self test12"	| connection logStream log |	connection := PostgreSQLConnection using: self subjectParameterSet.	logStream := String new writeStream.	log := PostgreSQLConnectionLog logEverythingFor: connection to: logStream.	connection executeQuery: 'create table test04 (a int2, b int2)'.	log pause.	connection executeQuery: 'insert into test04 values (1, 1)'.	log resume.	connection executeQuery: 'select a, b from test04'.	connection executeQuery: 'drop table test04'.	connection close.	^logStream contents</body><body package="PostgreSQL Tests" selector="test20">test20	"^self 	I use the logging facilities to capture the messages exchanged with 	the backend for all connections. 	I set the logging and then run a test from PostgreSQLTest."	"self test20"	| logStream log |	logStream := String new writeStream.	log := PostgreSQLConnectionLog logEverythingTo: logStream.	PostgreSQLTest new test05.	log close.	^logStream contents</body><body package="PostgreSQL Tests" selector="test21">test21	"^self 	I log a PostgreSQLTest which will use an unencrypted password. 	This tests the logging of the UnencryptedPasswordPacket."	"self test21"	| logStream log |	logStream := String new writeStream.	log := PostgreSQLConnectionLog logEverythingTo: logStream.	PostgreSQLTest new test12.	log close.	^logStream contents</body><body package="PostgreSQL Tests" selector="test22">test22	"^self 	I log a PostgreSQLTest which will cause a notification to be raised.  This tests the logging of the NoticeResponseMessage."	"self test22"	| logStream log |	logStream := String new writeStream.	log := PostgreSQLConnectionLog logEverythingTo: logStream.	PostgreSQLTest new test10.	log close.	^logStream contents</body></methods><methods><class-id>PostgreSQLLoggingTesting</class-id> <category>services</category><body package="PostgreSQL Tests" selector="subjectParameterSet">subjectParameterSet	^self class subjectParameterSet</body></methods><methods><class-id>PostgreSQLLoggingTesting</class-id> <category>license</category><body package="PostgreSQL Tests" selector="license">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLLoggingTesting class</class-id> <category>support</category><body package="PostgreSQL Tests" selector="subjectParameterSet">subjectParameterSet	"^a ConnectionParameterSet 	I return the connection parameter set to be used for all my tests. I 	delegate this to PostgreSQLTest."	^PostgreSQLTest subjectParameterSet</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>