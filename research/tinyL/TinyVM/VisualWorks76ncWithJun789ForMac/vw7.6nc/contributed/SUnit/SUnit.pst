<?xml version="1.0"?><st-source><!-- Name: SUnitDbIdentifier: psql_public_cst_2007DbTrace: 36361DevelopmentPrerequisites: #(#(#any 'SUnitPreload' ''))PackageName: SUnitParcel: #('SUnit')PrerequisiteParcels: #(#('SUnitPreload' ''))PrintStringCache: (Camp Smalltalk 3.1 + AR 48889 1 ,aknight)Version: Camp Smalltalk 3.1 + AR 48889 1 Date: 2:51:22 pm January 11, 2008 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.6 (jan08.1) of January 11, 2008 on January 11, 2008 at 2:51:22 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TestResult</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failures errors passed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestResult</class-id><body>This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.</body></comment><class><name>TestSuite</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tests resources name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestSuite</class-id><body>This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol</body></comment><class><name>TestResource</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><comment><class-id>XProgramming.SUnit.TestCase</class-id><body>A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.</body></comment><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Testing</category><body package="SUnit" selector="hasErrors">hasErrors	^self errors size &gt; 0</body><body package="SUnit" selector="hasFailures">hasFailures	^self failures size &gt; 0</body><body package="SUnit" selector="hasPassed">hasPassed	^self hasErrors not and: [self hasFailures not]</body><body package="SUnit" selector="isError:">isError: aTestCase	^self errors includes: aTestCase</body><body package="SUnit" selector="isFailure:">isFailure: aTestCase	^self failures includes: aTestCase</body><body package="SUnit" selector="isPassed:">isPassed: aTestCase	^self passed includes: aTestCase</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Accessing</category><body package="SUnit" selector="correctCount">correctCount	"depreciated - use #passedCount"	^self passedCount</body><body package="SUnit" selector="defects">defects	^OrderedCollection new		addAll: self errors;		addAll: self failures; yourself</body><body package="SUnit" selector="errorCount">errorCount	^self errors size</body><body package="SUnit" selector="errors">errors	errors isNil		ifTrue: [errors := OrderedCollection new].	^errors</body><body package="SUnit" selector="failureCount">failureCount	^self failures size</body><body package="SUnit" selector="failures">failures	failures isNil		ifTrue: [failures := Set new].	^failures</body><body package="SUnit" selector="passed">passed	passed isNil		ifTrue: [passed := OrderedCollection new].	^passed</body><body package="SUnit" selector="passedCount">passedCount	^self passed size</body><body package="SUnit" selector="runCount">runCount	^self passedCount + self failureCount + self errorCount</body><body package="SUnit" selector="tests">tests	^(OrderedCollection new: self runCount)		addAll: self passed;		addAll: self errors;		addAll: self failures;		yourself</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Init / Release</category><body package="SUnit" selector="initialize">initialize</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Printing</category><body package="SUnit" selector="printOn:">printOn: aStream	aStream		nextPutAll: self runCount printString;		nextPutAll: ' run, ';		nextPutAll: self correctCount printString;		nextPutAll: ' passed, ';		nextPutAll: self failureCount printString;		nextPutAll: ' failed, ';		nextPutAll: self errorCount printString;		nextPutAll: ' error'.	self errorCount ~= 1		ifTrue: [aStream nextPut: $s]</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Running</category><body package="SUnit" selector="runCase:">runCase: aTestCase	| testCasePassed |	testCasePassed :=		[			[				aTestCase runCase.				true]					sunitOn: self class failure					do: [:signal |						self failures add: aTestCase.						signal sunitExitWith: false]]							sunitOn: self class error							do: [:signal |								self errors add: aTestCase.								signal sunitExitWith: false].	testCasePassed		ifTrue: [self passed add: aTestCase]</body></methods><methods><class-id>XProgramming.SUnit.TestResult class</class-id> <category>Init / Release</category><body package="SUnit" selector="new">new	^super new initialize</body></methods><methods><class-id>XProgramming.SUnit.TestResult class</class-id> <category>Exceptions</category><body package="SUnit" selector="error">error	^self exError</body><body package="SUnit" selector="exError">exError	^SUnitNameResolver errorObject</body><body package="SUnit" selector="failure">failure	^TestFailure</body><body package="SUnit" selector="resumableFailure">resumableFailure	^ResumableTestFailure</body><body package="SUnit" selector="signalErrorWith:">signalErrorWith: aString 	self error sunitSignalWith: aString</body><body package="SUnit" selector="signalFailureWith:">signalFailureWith: aString 	self failure sunitSignalWith: aString</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>Running</category><body package="SUnit" selector="run">run	| result | 	result := TestResult new.	self resources do: [ :res |		res isAvailable ifFalse: [^res signalInitializationError]].	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].	^result</body><body package="SUnit" selector="run:">run: aResult 	self tests do: [:each | 		self sunitChanged: each.		each run: aResult]</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>Dependencies</category><body package="SUnit" selector="addDependentToHierachy:">addDependentToHierachy: anObject	self sunitAddDependent: anObject.	self tests do: [ :each | each addDependentToHierachy: anObject]</body><body package="SUnit" selector="removeDependentFromHierachy:">removeDependentFromHierachy: anObject	self sunitRemoveDependent: anObject.	self tests do: [ :each | each removeDependentFromHierachy: anObject]</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>Accessing</category><body package="SUnit" selector="addTest:">addTest: aTest	self tests add: aTest</body><body package="SUnit" selector="addTests:">addTests: aCollection 	aCollection do: [:eachTest | self addTest: eachTest]</body><body package="SUnit" selector="defaultResources">defaultResources	^self tests 		inject: Set new		into: [:coll :testCase | 			coll				addAll: testCase resources;				yourself]</body><body package="SUnit" selector="name">name	^name</body><body package="SUnit" selector="name:">name: aString	name := aString</body><body package="SUnit" selector="resources">resources	resources isNil ifTrue: [resources := self defaultResources].	^resources</body><body package="SUnit" selector="resources:">resources: anObject	resources := anObject</body><body package="SUnit" selector="tests">tests	tests isNil ifTrue: [tests := OrderedCollection new].	^tests</body></methods><methods><class-id>XProgramming.SUnit.TestSuite class</class-id> <category>Creation</category><body package="SUnit" selector="named:">named: aString	^self new		name: aString;		yourself</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Printing</category><body package="SUnit" selector="printOn:">printOn: aStream	aStream nextPutAll: self class printString</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Accessing</category><body package="SUnit" selector="description">description	description isNil		ifTrue: [^''].	^description</body><body package="SUnit" selector="description:">description: aString	description := aString</body><body package="SUnit" selector="name">name	name isNil		ifTrue: [^self printString].	^name</body><body package="SUnit" selector="name:">name: aString	name := aString</body><body package="SUnit" selector="resources">resources	^self class resources</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Testing</category><body package="SUnit" selector="isAvailable">isAvailable	"override to provide information on the	readiness of the resource"		^true</body><body package="SUnit" selector="isUnavailable">isUnavailable	"override to provide information on the	readiness of the resource"		^self isAvailable not</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Running</category><body package="SUnit" selector="setUp">setUp	"Does nothing. Subclasses should override this	to initialize their resource"</body><body package="SUnit" selector="signalInitializationError">signalInitializationError	^self class signalInitializationError</body><body package="SUnit" selector="tearDown">tearDown	"Does nothing. Subclasses should override this	to tear down their resource"</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Init / Release</category><body package="SUnit" selector="initialize">initialize	self setUp</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>Accessing</category><body package="SUnit" selector="current">current	current isNil		ifTrue: [current := self new].	^current</body><body package="SUnit" selector="current:">current: aTestResource	current := aTestResource</body><body package="SUnit" selector="resources">resources	^#()</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>Creation</category><body package="SUnit" selector="new">new	^super new initialize</body><body package="SUnit" selector="reset">reset	current notNil ifTrue: [		[current tearDown] ensure: [			current := nil]]</body><body package="SUnit" selector="signalInitializationError">signalInitializationError	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>Testing</category><body package="SUnit" selector="isAbstract">isAbstract	"Override to true if a TestResource subclass is Abstract and should not have	TestCase instances built from it"	^self name = #TestResource</body><body package="SUnit" selector="isAvailable">isAvailable	^self current notNil and: [self current isAvailable]</body><body package="SUnit" selector="isUnavailable">isUnavailable	^self isAvailable not</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Accessing</category><body package="SUnit" selector="assert:">assert: aBoolean	aBoolean ifFalse: [self signalFailure: 'Assertion failed']</body><body package="SUnit" selector="assert:description:">assert: aBoolean description: aString	aBoolean ifFalse: [		self logFailure: aString.		TestResult failure sunitSignalWith: aString]</body><body package="SUnit" selector="assert:description:resumable:">assert: aBoolean description: aString resumable: resumableBoolean 	| exception |	aBoolean		ifFalse: 			[self logFailure: aString.			exception := resumableBoolean						ifTrue: [TestResult resumableFailure]						ifFalse: [TestResult failure].			exception sunitSignalWith: aString]</body><body package="SUnit" selector="deny:">deny: aBoolean	self assert: aBoolean not</body><body package="SUnit" selector="deny:description:">deny: aBoolean description: aString	self assert: aBoolean not description: aString</body><body package="SUnit" selector="deny:description:resumable:">deny: aBoolean description: aString resumable: resumableBoolean 	self		assert: aBoolean not		description: aString		resumable: resumableBoolean</body><body package="SUnit" selector="resources">resources	| allResources resourceQueue |	allResources := Set new.	resourceQueue := OrderedCollection new.	resourceQueue addAll: self class resources.	[resourceQueue isEmpty] whileFalse: [		| next |		next := resourceQueue removeFirst.		allResources add: next.		resourceQueue addAll: next resources].	^allResources</body><body package="SUnit" selector="selector">selector	^testSelector</body><body package="SUnit" selector="should:">should: aBlock	self assert: aBlock value</body><body package="SUnit" selector="should:description:">should: aBlock description: aString	self assert: aBlock value description: aString</body><body package="SUnit" selector="should:raise:">should: aBlock raise: anExceptionalEvent 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)</body><body package="SUnit" selector="should:raise:description:">should: aBlock raise: anExceptionalEvent description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)		description: aString</body><body package="SUnit" selector="shouldnt:">shouldnt: aBlock	self deny: aBlock value</body><body package="SUnit" selector="shouldnt:description:">shouldnt: aBlock description: aString	self deny: aBlock value description: aString</body><body package="SUnit" selector="shouldnt:raise:">shouldnt: aBlock raise: anExceptionalEvent 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not</body><body package="SUnit" selector="shouldnt:raise:description:">shouldnt: aBlock raise: anExceptionalEvent description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString</body><body package="SUnit" selector="signalFailure:">signalFailure: aString	TestResult failure sunitSignalWith: aString</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Private</category><body package="SUnit" selector="executeShould:inScopeOf:">executeShould: aBlock inScopeOf: anExceptionalEvent 	^[aBlock value. 	false] sunitOn: anExceptionalEvent		do: [:ex | ex sunitExitWith: true]</body><body package="SUnit" selector="performTest">performTest	self perform: testSelector sunitAsSymbol</body><body package="SUnit" selector="setTestSelector:">setTestSelector: aSymbol	testSelector := aSymbol</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Dependencies</category><body package="SUnit" selector="addDependentToHierachy:">addDependentToHierachy: anObject 	"an empty method. for Composite compability with TestSuite"</body><body package="SUnit" selector="removeDependentFromHierachy:">removeDependentFromHierachy: anObject 	"an empty method. for Composite compability with TestSuite"</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Running</category><body package="SUnit" selector="debug">debug	self resources do: [:res | 		res isAvailable ifFalse: [^res signalInitializationError]].	[(self class selector: testSelector) runCase] 		sunitEnsure: [self resources do: [:each | each reset]]</body><body package="SUnit" selector="debugAsFailure">debugAsFailure	| semaphore |	semaphore := Semaphore new.	self resources do: [:res | 		res isAvailable ifFalse: [^res signalInitializationError]].	[semaphore wait. self resources do: [:each | each reset]] fork.	(self class selector: testSelector) runCaseAsFailure: semaphore.</body><body package="SUnit" selector="failureLog">failureLog	^SUnitNameResolver defaultLogDevice</body><body package="SUnit" selector="isLogging">isLogging	"By default, we're not logging failures. If you override this in 	a subclass, make sure that you override #failureLog"	^false</body><body package="SUnit" selector="logFailure:">logFailure: aString	self isLogging ifTrue: [		self failureLog 			cr; 			nextPutAll: aString; 			flush]</body><body package="SUnit" selector="openDebuggerOnFailingTestMethod">openDebuggerOnFailingTestMethod	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 	 send into 'self perform: testSelector' to see the failure from the beginning"	self		halt;		performTest</body><body package="SUnit" selector="run">run	| result |	result := TestResult new.	self run: result.	^result</body><body package="SUnit" selector="run:">run: aResult	aResult runCase: self</body><body package="SUnit" selector="runCase">runCase	[self setUp.	self performTest] sunitEnsure: [self tearDown]</body><body package="SUnit" selector="runCaseAsFailure:">runCaseAsFailure: aSemaphore	[self setUp.	self openDebuggerOnFailingTestMethod] sunitEnsure: [		self tearDown.		aSemaphore signal]</body><body package="SUnit" selector="setUp">setUp</body><body package="SUnit" selector="tearDown">tearDown</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Printing</category><body package="SUnit" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class printString;		nextPutAll: '&gt;&gt;#';		nextPutAll: testSelector</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Testing</category><body package="SUnit" selector="isAbstract">isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self sunitName = #TestCase</body><body package="SUnit" selector="shouldInheritSelectors">shouldInheritSelectors	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."	^self superclass isAbstract		or: [self testSelectors isEmpty]"$QA Ignore:Sends system method(superclass)$"</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Building Suites</category><body package="SUnit" selector="buildSuite">buildSuite	| suite |	^self isAbstract		ifTrue: 			[suite := self suiteClass named: self name asString.			self allSubclasses 				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].			suite]		ifFalse: [self buildSuiteFromSelectors]</body><body package="SUnit" selector="buildSuiteFromAllSelectors">buildSuiteFromAllSelectors	^self buildSuiteFromMethods: self allTestSelectors</body><body package="SUnit" selector="buildSuiteFromLocalSelectors">buildSuiteFromLocalSelectors	^self buildSuiteFromMethods: self testSelectors</body><body package="SUnit" selector="buildSuiteFromMethods:">buildSuiteFromMethods: testMethods	^testMethods		inject: (self suiteClass named: self name asString)		into: [:suite :selector |			suite				addTest: (self selector: selector);				yourself]</body><body package="SUnit" selector="buildSuiteFromSelectors">buildSuiteFromSelectors	^self shouldInheritSelectors		ifTrue: [self buildSuiteFromAllSelectors]		ifFalse: [self buildSuiteFromLocalSelectors]</body><body package="SUnit" selector="suiteClass">suiteClass	^TestSuite</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Instance Creation</category><body package="SUnit" selector="debug:">debug: aSymbol	^(self selector: aSymbol) debug</body><body package="SUnit" selector="run:">run: aSymbol	^(self selector: aSymbol) run</body><body package="SUnit" selector="selector:">selector: aSymbol	^self new setTestSelector: aSymbol</body><body package="SUnit" selector="suite">suite	^self buildSuite</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Accessing</category><body package="SUnit" selector="allTestSelectors">allTestSelectors	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]</body><body package="SUnit" selector="resources">resources	^#()</body><body package="SUnit" selector="sunitVersion">sunitVersion	^'3.1'</body><body package="SUnit" selector="testSelectors">testSelectors	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>