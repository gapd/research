<?xml version="1.0"?><st-source><!-- Name: AutoCompleteComment: AutoCompleteApp adds user triggered text completion to ParagraphEditor. You can now hit the tab key half way through a word, and it will complete as much of it as it can. It's based off of the SymbolTable and words found in the current paragraph editor's text. In the event multiple completions exist, it opens a menu which you can use to select the desired completion. These menus' controllers are augmented so that you can type the character that begins the completion (indicated by underline) and it will apply that choice. Or if you type a letter that isn't included, it will drop the menu and insert the character into the paragraph (the exceptions being the up/down arrow keys, the return/esc keys, which are used to navigate the menu).If a completion cannot be performed, because the caret is not positioned at the end of the word, a normal tab will be inserted. It's coded so that if you have *any* keyboard modifiers on the tab, it will also insert the tab. This can be hard on some OSes, because the WindowManager won't let any modified tabs through. There is a boolean (AutoComplete.TabComplete) that can be used to turn off tab completion.Previous versions of this package set the #Insert key to trigger completion as well. Unfortunately, there really is no good way for a bunch of different tools to do this, except through the MagicKeys package. So, if you want to use a different key sequence (CTRL-Space is popular, though the emacs'er in me insists that's for marking), I suggest you load MagicKeys, and bind your sequence to #completeWordKey:There is an AutoCompleteTests package that goes along with this for development. Please make sure tests pass before publishing.DbIdentifier: psql_public_cst_2007DbTrace: 48647PackageName: AutoCompleteParcel: #('AutoComplete')ParcelName: AutoCompletePrintStringCache: (21,aknight)Version: 21Date: 9:34:54 am January 25, 2008 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.6 (jan08.4) of January 25, 2008 on January 25, 2008 at 9:34:54 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>AutoComplete</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></name-space><class><name>Search</name><environment>AutoComplete</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><class><name>CompositeWordSearch</name><environment>AutoComplete</environment><super>AutoComplete.Search</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><class><name>ParagraphSearch</name><environment>AutoComplete</environment><super>AutoComplete.Search</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><class><name>SymbolTableSearch</name><environment>AutoComplete</environment><super>AutoComplete.Search</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><class><name>Match</name><environment>AutoComplete</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prefix </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><comment><class-id>AutoComplete.Match</class-id><body>A Match represents one kind or another of a word completion candidate. Nominally, it is a prefix. Different subclasses represent the different kinds of completions we've found to match that prefix.Subclasses must implement the following messages:	accessing		combineWith:Instance Variables:	prefix	&lt;CharacterArray&gt; the amount of the start of the string that was matched</body></comment><class><name>SingleMatch</name><environment>AutoComplete</environment><super>AutoComplete.Match</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ending </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><class><name>NoMatch</name><environment>AutoComplete</environment><super>AutoComplete.Match</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><class><name>MenuEventDispatcherWithKeyboard</name><environment>AutoComplete</environment><super>UI.MenuEventDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardHook </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>AutoComplete</package></attributes></class><class><name>MultiMatch</name><environment>AutoComplete</environment><super>AutoComplete.Match</super><private>false</private><indexed-type>none</indexed-type><inst-vars>endings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AutoComplete</category><attributes><package>AutoComplete</package></attributes></class><shared-variable><name>TabComplete</name><environment>AutoComplete</environment><private>false</private><constant>false</constant><category>shares</category><initializer>true</initializer><attributes><package>AutoComplete</package></attributes></shared-variable><methods><class-id>AutoComplete.Search</class-id> <category>accessing</category><body package="AutoComplete" selector="searchFor:">searchFor: aString 	^self subclassResponsibility</body></methods><methods><class-id>AutoComplete.CompositeWordSearch</class-id> <category>accessing</category><body package="AutoComplete" selector="addSearch:">addSearch: aWordSearch 	nodes := nodes copyWith: aWordSearch</body><body package="AutoComplete" selector="searchFor:">searchFor: aString 	| match |	match := NoMatch new.	nodes do: [:each | match := match combineWith: (each searchFor: aString)].	^match</body></methods><methods><class-id>AutoComplete.CompositeWordSearch</class-id> <category>private-initialize</category><body package="AutoComplete" selector="initialize">initialize	nodes := Array new</body></methods><methods><class-id>AutoComplete.CompositeWordSearch class</class-id> <category>instance creation</category><body package="AutoComplete" selector="new">new	^super new initialize</body><body package="AutoComplete" selector="with:with:">with: aSearch with: bSearch 	^(self new) addSearch: aSearch; addSearch: bSearch; yourself</body><body package="AutoComplete" selector="withAll:">withAll: aCollection 	| inst |	inst := self new.	aCollection do: [:each | inst addNode: each].	^inst</body></methods><methods><class-id>AutoComplete.ParagraphSearch</class-id> <category>accessing</category><body package="AutoComplete" selector="searchFor:">searchFor: aPrefix 	| candidates candidate |	candidates := OrderedCollection new.	string keywordStartsAndStopsDo: 			[:start :stop | 			(string startingAt: start couldComplete: aPrefix) 				ifTrue: 					[candidate := string copyFrom: start + aPrefix size to: stop.					(candidate isEmpty or: [candidates includes: candidate]) 						ifFalse: [candidates addLast: candidate]]].	candidates isEmpty ifTrue: [^NoMatch prefix: aPrefix].	candidates size = 1 		ifTrue: [^SingleMatch prefix: aPrefix ending: candidates first].	candidates := candidates asArray.	SequenceableCollectionSorter sort: candidates.	^MultiMatch prefix: aPrefix endings: candidates</body><body package="AutoComplete" selector="string:">string: aString 	string := aString</body></methods><methods><class-id>AutoComplete.ParagraphSearch class</class-id> <category>instance creation</category><body package="AutoComplete" selector="for:">for: aString 	^self new string: aString</body></methods><methods><class-id>AutoComplete.SymbolTableSearch</class-id> <category>accessing</category><body package="AutoComplete" selector="newSearchFor:">newSearchFor: aPrefix 	"Used for 7.6+ versions"	| candidates |	candidates := OrderedCollection new: 20.	Symbol allSymbolsDo: [:each | each selectorPartsStartingWith: aPrefix endingsInto: candidates].	candidates isEmpty ifTrue: [^NoMatch prefix: aPrefix].	candidates size = 1 ifTrue: [^SingleMatch prefix: aPrefix ending: candidates first].	candidates := candidates asArray.	SequenceableCollectionSorter sort: candidates.	^MultiMatch prefix: aPrefix endings: candidates</body><body package="AutoComplete" selector="oldSearchFor:">oldSearchFor: aPrefix 	"Used for pre-7.6 versions. this code was made to run fast, I know that it looks ugly, I really can write 	prettier Smalltalk code than this"	| candidates bigTable littleTable contestant |	candidates := OrderedCollection new: 20.	bigTable := Symbol table.	1 to: bigTable size		do: 			[:i | 			littleTable := bigTable at: i.			1 to: littleTable size				do: 					[:j | 					contestant := littleTable at: j.					0 = contestant 						ifFalse: 							[contestant selectorPartsStartingWith: aPrefix endingsInto: candidates]]].	candidates isEmpty ifTrue: [^NoMatch prefix: aPrefix].	candidates size = 1 		ifTrue: [^SingleMatch prefix: aPrefix ending: candidates first].	candidates := candidates asArray.	SequenceableCollectionSorter sort: candidates.	^MultiMatch prefix: aPrefix endings: candidates</body><body package="AutoComplete" selector="searchFor:">searchFor: aPrefix 	^(Symbol respondsTo: #allSymbolsDo:)		ifTrue: [self newSearchFor: aPrefix]		ifFalse: [self oldSearchFor: aPrefix].</body></methods><methods><class-id>AutoComplete.Match</class-id> <category>accessing</category><body package="AutoComplete" selector="combineWith:">combineWith: aMatch 	^self subclassResponsibility</body><body package="AutoComplete" selector="combineWithMulti:">combineWithMulti: aMatch 	^self combineWith: aMatch</body><body package="AutoComplete" selector="combineWithSingle:">combineWithSingle: aMatch 	^self combineWith: aMatch</body><body package="AutoComplete" selector="prefix">prefix	^prefix</body><body package="AutoComplete" selector="prefix:">prefix: anObject	prefix := anObject</body></methods><methods><class-id>AutoComplete.Match</class-id> <category>testing</category><body package="AutoComplete" selector="isEmpty">isEmpty	^false</body><body package="AutoComplete" selector="isSingle">isSingle	^false</body></methods><methods><class-id>AutoComplete.Match class</class-id> <category>instance creation</category><body package="AutoComplete" selector="prefix:">prefix: aString 	^self new prefix: aString</body></methods><methods><class-id>AutoComplete.SingleMatch</class-id> <category>accessing</category><body package="AutoComplete" selector="basicApplyTo:">basicApplyTo: aParagraphEditor 	aParagraphEditor appendToSelection: ending</body><body package="AutoComplete" selector="combineWith:">combineWith: aMatch 	^aMatch combineWithSingle: self</body><body package="AutoComplete" selector="combineWithMulti:">combineWithMulti: aMatch 	(aMatch endings includes: ending) ifTrue: [^aMatch].	^MultiMatch prefix: prefix endings: (aMatch endings copyWith: ending)</body><body package="AutoComplete" selector="combineWithSingle:">combineWithSingle: aMatch 	ending = aMatch ending ifTrue: [^self].	^MultiMatch prefix: prefix		endings: (Array with: aMatch ending with: ending)</body><body package="AutoComplete" selector="ending">ending	^ending</body><body package="AutoComplete" selector="ending:">ending: aString 	ending := aString</body><body package="AutoComplete" selector="interactiveApplyTo:">interactiveApplyTo: aParagraphEditor 	self basicApplyTo: aParagraphEditor</body><body package="AutoComplete" selector="isSingle">isSingle	^true</body><body package="AutoComplete" selector="splitAndApplyTo:">splitAndApplyTo: aParagraphEditor 	self basicApplyTo: aParagraphEditor</body></methods><methods><class-id>AutoComplete.SingleMatch class</class-id> <category>instance creation</category><body package="AutoComplete" selector="prefix:ending:">prefix: bString ending: eString 	^(self prefix: bString) ending: eString</body></methods><methods><class-id>AutoComplete.NoMatch</class-id> <category>accessing</category><body package="AutoComplete" selector="basicApplyTo:">basicApplyTo: aParagraphEditor</body><body package="AutoComplete" selector="combineWith:">combineWith: aMatch 	^aMatch</body><body package="AutoComplete" selector="interactiveApplyTo:">interactiveApplyTo: aParagraphEditor 	Screen default ringBell</body><body package="AutoComplete" selector="splitAndApplyTo:">splitAndApplyTo: aParagraphEditor 	self basicApplyTo: aParagraphEditor</body></methods><methods><class-id>AutoComplete.NoMatch</class-id> <category>testing</category><body package="AutoComplete" selector="isEmpty">isEmpty	^true</body></methods><methods><class-id>AutoComplete.MenuEventDispatcherWithKeyboard</class-id> <category>accessing</category><body package="AutoComplete" selector="keyboardHook">keyboardHook	^keyboardHook</body><body package="AutoComplete" selector="keyboardHook:">keyboardHook: anObject	keyboardHook := anObject</body></methods><methods><class-id>AutoComplete.MenuEventDispatcherWithKeyboard</class-id> <category>initialize-release</category><body package="AutoComplete" selector="initialize">initialize	super initialize.	keyboardHook := [:ev :ctrl | ev]</body></methods><methods><class-id>AutoComplete.MenuEventDispatcherWithKeyboard</class-id> <category>event dispatching</category><body package="AutoComplete" selector="dispatchEvent:">dispatchEvent: anEvent 	(anEvent isKeyboard and: [anEvent isKeyPress]) 		ifTrue: [(keyboardHook value: anEvent value: windowController) ifNil: [^self]].	^super dispatchEvent: anEvent</body></methods><methods><class-id>AutoComplete.MultiMatch</class-id> <category>private</category><body package="AutoComplete" selector="buildMenu">buildMenu	| menu |	menu := Menu new.	endings do: 			[:each | 			| item text |			text := self prefixMenuText , (self endingMenuText: each).			item := MenuItem labeled: text.			item labelText: text.			item value: (SingleMatch prefix: prefix ending: each).			menu addItem: item].	menu selectionMemory: (menu menuItemAt: 1).	^menu</body><body package="AutoComplete" selector="disimiliarEndingsMatch">disimiliarEndingsMatch	| same |	same := self similiarCharacterCount.	^same &gt; 0 		ifTrue: 			[MultiMatch prefix: prefix , (endings first copyFrom: 1 to: same)				endings: ((endings collect: [:each | each copyFrom: same + 1 to: each size]) 						reject: [:each | each isEmpty])]		ifFalse: [self]</body><body package="AutoComplete" selector="endingMenuText:">endingMenuText: each 	^each asText 		emphasizeFrom: 1		to: 1		with: #(#underline)</body><body package="AutoComplete" selector="prefixMenuText">prefixMenuText	^prefix asText emphasizeAllWith: #(#small)</body><body package="AutoComplete" selector="refineMatch:">refineMatch: aCharacter 	| candidates |	candidates := endings select: [:each | each first = aCharacter].	candidates isEmpty 		ifTrue: 			[^aCharacter asUppercase = aCharacter				ifTrue: [NoMatch prefix: prefix]				ifFalse: [self refineMatch: aCharacter asUppercase]].	^candidates size = 1 		ifTrue: [SingleMatch prefix: prefix ending: candidates first]		ifFalse: [MultiMatch prefix: prefix endings: candidates]</body><body package="AutoComplete" selector="similiarBeginningMatch">similiarBeginningMatch	| same |	same := self similiarCharacterCount.	^same &gt; 0 		ifTrue: 			[SingleMatch prefix: prefix ending: (endings first copyFrom: 1 to: same)]		ifFalse: [NoMatch prefix: prefix]</body><body package="AutoComplete" selector="similiarCharacterCount">similiarCharacterCount	| template same |	template := endings first.	same := template size.	2 to: endings size		do: 			[:i | 			same := ((endings at: i) sameCharacters: template) min: same.			same isZero ifTrue: [^0]].	^same</body></methods><methods><class-id>AutoComplete.MultiMatch</class-id> <category>accessing</category><body package="AutoComplete" selector="basicApplyTo:">basicApplyTo: aParagraphEditor 	| menu menuValue |	menu := self buildMenu.	menuValue := (aParagraphEditor view widgetPolicy menuViewForMenu: menu) 				openForWordCompletion: self				from: aParagraphEditor view.	^menuValue 		ifNotNil: [menuValue value interactiveApplyTo: aParagraphEditor]</body><body package="AutoComplete" selector="combineWith:">combineWith: aMatch 	^aMatch combineWithMulti: self</body><body package="AutoComplete" selector="combineWithMulti:">combineWithMulti: aMatch 	| ws |	ws := Array new writeStream.	ws nextPutAll: aMatch endings.	endings 		do: [:each | (aMatch endings includes: each) ifFalse: [ws nextPut: each]].	^MultiMatch prefix: prefix endings: ws contents</body><body package="AutoComplete" selector="combineWithSingle:">combineWithSingle: aMatch 	| ws |	ws := Array new writeStream.	ws nextPut: aMatch ending.	endings do: [:each | each = aMatch ending ifFalse: [ws nextPut: each]].	^MultiMatch prefix: prefix endings: ws contents</body><body package="AutoComplete" selector="endings">endings	^endings</body><body package="AutoComplete" selector="endings:">endings: aCollection 	endings := aCollection</body><body package="AutoComplete" selector="interactiveApplyTo:">interactiveApplyTo: aParagraphEditor 	self splitAndApplyTo: aParagraphEditor</body><body package="AutoComplete" selector="splitAndApplyTo:">splitAndApplyTo: aParagraphEditor 	self similiarBeginningMatch basicApplyTo: aParagraphEditor.	self disimiliarEndingsMatch basicApplyTo: aParagraphEditor</body></methods><methods><class-id>AutoComplete.MultiMatch class</class-id> <category>instance creation</category><body package="AutoComplete" selector="prefix:endings:">prefix: aString endings: aCollection 	^(self prefix: aString) endings: aCollection</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-parent view</category><body package="AutoComplete" selector="openForWordCompletion:from:">openForWordCompletion: aMultiMatch from: aView 	"This is a big copy/merger of the open pop up version, with the differences between subclasses collapsed here"	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow positioningMenuItemView offsetForMenuItem theSelectionMemoryMenuItem |	self setupWordCompletionControllerFor: aMultiMatch.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := aView graphicsDevice.	parentDisplayBox := self displayBoxOfView: aView.	monitorRectangle := theScreen 				preferredRectangleToConstrain: parentDisplayBox.	(self isKindOf: Win95MenuView) 		ifFalse: [monitorRectangle := monitorRectangle insetBy: 4].	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds 		height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0 @ 0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item under cursor."	usedSelectionMemory := true.	theSelectionMemoryMenuItem := self menu selectionMemory.	self menuItemViewsAsCollection do: 			[:eachView | 			eachView menuItem == theSelectionMemoryMenuItem 				ifTrue: 					[positioningMenuItemView := eachView.					selectedValue := theSelectionMemoryMenuItem.					self highlightedMenuItemView: eachView]].	positioningMenuItemView == nil 		ifTrue: [offsetForMenuItem := 0 @ 0]		ifFalse: 			[offsetForMenuItem := positioningMenuItemView 						localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow 		moveTo: (aView 				localPointToGlobal: aView stopBlock left @ aView stopBlock top) 					+ aView topComponent globalOrigin + offsetForMenuItem.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox 				amountToTranslateWithin: monitorRectangle.	menuWindow moveTo: menuWindow globalOrigin + intoMonitor.	self setColorsInMenuWindow: menuWindow from: aView.	self mapAndStartupEventDriven: menuWindow.	aView topComponent becomeActive.	^self selectedValue</body><body package="AutoComplete" selector="setupWordCompletionControllerFor:">setupWordCompletionControllerFor: aMultiMatch 	| newDispatch skip |	self 		controller: (((self isKindOf: Win95MenuView) 				or: [self isKindOf: MacOSXMenuView]) 					ifTrue: [Win95MenuAsPopUpController new]					ifFalse: [MenuAsPopUpController new]).	newDispatch := AutoComplete.MenuEventDispatcherWithKeyboard 				on: self controller.	skip := #(#Up #Down #Right #Left) 				, (Array with: Character cr with: Character esc).	newDispatch keyboardHook: 			[:ev :ctrl | 			(skip includes: ev keyValue) 				ifTrue: [ev]				ifFalse: 					[| refined |					selectionFinal := true.					refined := aMultiMatch refineMatch: ev keyValue.					selectedValue := (refined isEmpty ifTrue: [ev] ifFalse: [refined]) asValue.					nil]].	self controller eventDispatcher become: newDispatch</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>auto complete</category><body package="AutoComplete" selector="couldComplete:">couldComplete: aPrefixString 	"return whether the reciever could complete (add to) the argument aPrefixString"	| hisSize |	hisSize := aPrefixString size.	self size &gt; hisSize ifFalse: [^false].	1 to: hisSize		do: [:i | (self at: i) = (aPrefixString at: i) ifFalse: [^false]].	^true</body><body package="AutoComplete" selector="keywordStartsAndStopsDo:">keywordStartsAndStopsDo: a2ArgBlock 	| isInWord eachCharacter wordStart |	isInWord := false.	1 to: self size		do: 			[:i | 			eachCharacter := self at: i.			isInWord 				ifFalse: 					[eachCharacter canStartKeyword 						ifTrue: 							[isInWord := true.							wordStart := i]]				ifTrue: 					[eachCharacter canBePartOfKeyword 						ifFalse: 							[isInWord := false.							eachCharacter = $: 								ifTrue: [a2ArgBlock value: wordStart value: i]								ifFalse: [a2ArgBlock value: wordStart value: i - 1]]]].	isInWord ifTrue: [a2ArgBlock value: wordStart value: self size]</body><body package="AutoComplete" selector="selectorPartsStartingWith:endingsInto:">selectorPartsStartingWith: aString endingsInto: anOrderedCollection 	"nominally, this method is the bottom branch, BUT most of the cases (about 63% of the symbol table) can be optimized by detecting and taking the upper branch"	"this code is somewhat speed optimized"	| mySize ending |	mySize := self size.	1 to: mySize		do: [:index | (self at: index) canBePartOfSelector ifFalse: [^self]].	(mySize &gt; 1 and: 			[(self at: mySize) ~= $: 				or: [(self 						prevIndexOf: $:						from: mySize - 1						to: 1) == nil]]) 		ifTrue: 			[((self couldComplete: aString) and: [self size &gt; aString size]) 				ifTrue: 					[ending := self copyFrom: aString size + 1 to: self size.					(anOrderedCollection includes: ending) 						ifFalse: [anOrderedCollection addLast: ending]]]		ifFalse: 			[self keywordStartsAndStopsDo: 					[:start :stop | 					(self startingAt: start couldComplete: aString) 						ifTrue: 							[ending := self copyFrom: start + aString size to: stop.							(ending isEmpty or: [anOrderedCollection includes: ending]) 								ifFalse: [anOrderedCollection addLast: ending]]]]</body><body package="AutoComplete" selector="startingAt:couldComplete:">startingAt: anIndex couldComplete: aPrefixString 	| hisSize |	hisSize := aPrefixString size.	self size &gt;= (hisSize + anIndex) ifFalse: [^false].	1 to: hisSize		do: [:i | (self at: anIndex + i - 1) = (aPrefixString at: i) ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="AutoComplete" selector="canBePartOfKeyword">canBePartOfKeyword	^self isAlphaNumeric or: [self = $_]</body><body package="AutoComplete" selector="canBePartOfSelector">canBePartOfSelector	^self canBePartOfKeyword or: [self = $:]</body><body package="AutoComplete" selector="canStartKeyword">canStartKeyword	^self isAlphabetic or: [self = $_]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>auto completion</category><body package="AutoComplete" selector="completeWordFrom:">completeWordFrom: aWordSearch 	| prefix match |	prefix := self computeCurrentCompletionPrefix.	prefix isEmpty ifTrue: [^false].	match := aWordSearch searchFor: prefix.	match interactiveApplyTo: self.	^true</body><body package="AutoComplete" selector="completeWordKey:">completeWordKey: ignored 	(self completeWordFrom: self interactiveWordCompletionSearch) 		ifFalse: [Screen default ringBell]</body><body package="AutoComplete" selector="computeCurrentCompletionPrefix">computeCurrentCompletionPrefix	| stop string start prefix |	stop := self selectionStartIndex.	stop = self selectionStartIndex ifFalse: [^''].	stop &gt; 1 ifFalse: [^''].	string := self text asString.	(stop &lt;= string size 		and: [(string at: stop) canBePartOfKeyword or: [(string at: stop) = $:]]) 			ifTrue: [^''].	start := stop - 1.	[start &gt; 0 and: [(string at: start) canBePartOfKeyword]] 		whileTrue: [start := start - 1].	prefix := string copyFrom: start + 1 to: stop - 1.	prefix detect: [:char | char canStartKeyword] ifNone: [^''].	^prefix</body><body package="AutoComplete" selector="computeWordCompletionSearchOrDo:">computeWordCompletionSearchOrDo: aBlock 	| subscribers tc |	subscribers := Set new.	(performer respondsTo: #wordCompletionSearchFor:)		ifTrue: [subscribers add: performer].	tc := self view topComponent.	(tc notNil and: [tc model respondsTo: #wordCompletionSearchFor:])		ifTrue: [subscribers add: tc model].	(tc notNil and: [tc application respondsTo: #wordCompletionSearchFor:])		ifTrue: [subscribers add: tc application].	^subscribers isEmpty		ifTrue: [aBlock value]		ifFalse: [AutoComplete.CompositeWordSearch withAll: (subscribers collect: [:each | each wordCompletionSearchFor: self])]</body><body package="AutoComplete" selector="interactiveWordCompletionSearch">interactiveWordCompletionSearch	^self computeWordCompletionSearchOrDo: [AutoComplete.CompositeWordSearch with: (AutoComplete.ParagraphSearch for: self text asString)			with: AutoComplete.SymbolTableSearch new]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>editing</category><body package="AutoComplete" selector="normalCharacterKey:">normalCharacterKey: aCharEvent 	"A nonspecial character is to be added to the stream of characters."	"Patched: for autocomplete to pick up completion"	#{AutoComplete.TabComplete} ifDefinedDo: 			[:bool | 			(bool == true 				and: [(aCharEvent hasKeyValue: Character tab) and: [aCharEvent metaState = 0]]) 					ifTrue: 						[(self completeWordFrom: self interactiveWordCompletionSearch) 							ifTrue: [^self]]].	self normalKeyboardEvent: aCharEvent		do: [:ch | self appendToSelection: (String with: ch)]</body></methods><methods><class-id>UI.KeyPressedEvent</class-id> <category>auto complete</category><body package="AutoComplete" selector="interactiveApplyTo:">interactiveApplyTo: aController 	"this happens when an autocomplete returns not a match but a character to continue to put on the stream, so we just spin this character back at the controller"	"if its a tab, it's come out of the menu and we want it to actualy go through, so set its meta state to fake it out"	self keyValue == Character tab ifTrue: [metaState := 1].	aController handleEvent: self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MenuEventDispatcher</name><environment>UI</environment><super>UI.EventDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>MenuView</name><environment>UI</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuItemViews parentMenuItemView selectedValue selectionFinal highlightedMenuItemView usedSelectionMemory parentMenuBarButtonView commonTextIndent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>KeyPressedEvent</name><environment>UI</environment><super>UI.KeyboardEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class><class><name>ParagraphEditor</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>