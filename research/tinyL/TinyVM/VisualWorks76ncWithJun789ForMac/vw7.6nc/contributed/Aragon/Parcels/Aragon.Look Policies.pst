<?xml version="1.0"?><st-source><!-- Name: Aragon.Look PoliciesComment: Contains a two look policies Windows 95 and Nextstep. With VisualWorks 7 using these look policies might not seem meaningful. Anyway, they are still provided for compatibility reasons.DevelopmentPrerequisites: #(#(#parcel 'Aragon.Core' ''))HideSource: falseParcel: #('Aragon.Look Policies')PrerequisiteParcels: #(#('Aragon.Shared' ''))SaveSource: trueVersion: 7.1Date: 4:13:39 am May 28, 2003 --><time-stamp>From VisualWorks®, Release 7.1 of 18. März 2003 on 28. Mai 2003 at 4:13:39</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NSScrollerButton</name><environment>Aragon</environment><super>UI.ScrollerButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>direction </inst-vars><class-inst-vars>arrowImages </class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep</category></class><comment><class-id>Aragon.NSScrollerButton</class-id><body>Instances of this class are the scroller buttons parts of NSScrollBars.  The other part of a NSScrollBar is a NSScrollBarSlider.  An instance of this class can implement any of the four directions of scroller buttons.Instance Variables:	direction			&lt;#left | #right | #up | #down&gt;	The scrolling direction the button controls.Class Variables:	DownArrow		&lt;CachedImage&gt;	The image of the down arrow on the face of the button	LeftArrow		&lt;CachedImage&gt;	The image of the left arrow on the face of the button	RightArrow		&lt;CachedImage&gt;	The image of the right arrow on the face of the button	UpArrow		&lt;CachedImage&gt;	The image of the up arrow on the face of the button	InsetBorder		&lt;BeveledBorder&gt;  The border with the beveled inset appearance	RaisedBorder	&lt;BeveledBorder&gt;  The border with the raised beveled appearance</body></comment><class><name>Win95BorderDecorator</name><environment>Aragon</environment><super>UI.BorderDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hidden </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95</category></class><class><name>NSMenuView</name><environment>Aragon</environment><super>UI.MenuView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shortcutColumnIndent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><comment><class-id>Aragon.NSMenuView</class-id><body>A NSMenuView is a MenuView that implements the Microsoft Windows look-and-feel style for a MenuView.  Other subclasses of MenuView can be used to implement other look-and-feel styles.  This class (and all its subclasses) are private to the implementation of MenuView.  Other users should not interface to this class and should not subclass it.Collaborators:	MenuController:  my default controller	NSMenuItemView: the standard views for my components	MenuItemList:  my model (a list of menu items)	MenuItem:  the models for my componentsMessage protocols declared as being 'protected' are for use only by the class and its subclasses.  Message protocols declared as being 'private' are for use ONLY by this class, NOT by subclasses.  Messages protocols declared as being 'privileged' are for use only by certain other privileged classes that are collaborators with this class.  Behavior inherited from the superclass is also 'protected' or 'privileged' in this class and its subclasses.  All the variables are private to this class.Instance Variables: 	shortcutColumnIndent	&lt;Integer&gt;	the number of pixels the column of shortcut key labels should be indented</body></comment><class><name>NSSliderView</name><environment>Aragon</environment><super>UI.SliderView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><comment><class-id>Aragon.NSSliderView</class-id><body>Instances of this Class are "slider" views in the NSintosh look &amp; feel style.  A "slider" view is used to specify a particular value in a range of values.  Instances are used by NSLookPolicy.Class Variables:	NSMarkerBorder	&lt;SimpleBorder&gt;		border for the marker</body></comment><class><name>NSMenuFromMenuBarController</name><environment>Aragon</environment><super>UI.MenuFromMenuBarController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><class><name>NSScrollBar</name><environment>Aragon</environment><super>UI.EmulationScrollBar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>canScroll isActive windowActive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep</category></class><comment><class-id>Aragon.NSScrollBar</class-id><body>Instances of this class are the scroll bar thumb component of the NSScrollBar, a scroll bar in the NS look/feel style of OS/2.  NSScrollerButtonViews are used for the ends of the NSScrollBar.Class Variables:	InsetThumbBorder  &lt;BeveledBorder&gt;  A BeveledBorder inset appropriate for use when displaying the thumb	RaisedThumbBorder  &lt;BeveledBorder&gt;  The corresponding raised border</body></comment><class><name>NSComboBoxButtonView</name><environment>Aragon</environment><super>UI.ComboBoxButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><comment><class-id>Aragon.NSComboBoxButtonView</class-id><body>NSComboBoxButtonView is the button part of a NSComboBoxView.This class is completely private to the implementation of NSComboBoxView (or to ComboBoxView and NSLookPolicy if NSComboBoxView has not been implemented yet).</body></comment><class><name>NSComboBoxInputFieldView</name><environment>Aragon</environment><super>UI.ComboBoxInputFieldView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><class><name>NSPassiveLabel</name><environment>Aragon</environment><super>UI.PassiveLabel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xController </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><class><name>NSActionButtonView</name><environment>Aragon</environment><super>UI.ActionButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><comment><class-id>Aragon.NSActionButtonView</class-id><body>Instances of this class are action-button Views in the NS style of OS/2.  Instances are used by NSLookWidgetPolicy and NSLookPolicy.</body></comment><class><name>NSVisualDivider</name><environment>Aragon</environment><super>UI.VisualDivider</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><class><name>NSMenuBar</name><environment>Aragon</environment><super>UI.MenuBar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><class><name>Win95ScrollerButton</name><environment>Aragon</environment><super>Aragon.NSScrollerButton</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95</category></class><class><name>NSCheckButtonView</name><environment>Aragon</environment><super>UI.CheckButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><comment><class-id>Aragon.NSCheckButtonView</class-id><body>Instances of this class are check-button Views in the NS look/feel style of OS/2 and are used by NSLookWidgetPolicy and NSLookPolicy.Class Variables:	OffImage		&lt;CachedImage&gt;		The image of the check button in the off state.	OnImage		&lt;CachedImage&gt;		The image of the check button in the on state.	TransitionImage	&lt;CachedImage&gt;		The image of the button in transition between states.</body></comment><class><name>Win95ActionButtonView</name><environment>Aragon</environment><super>Aragon.NSActionButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.Widgets</category></class><class><name>Win95WidgetsExample</name><environment>Aragon</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t sliderValue text selectedClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.Widgets</category></class><class><name>NSFeelPolicy</name><environment>Aragon</environment><super>UI.UIFeelPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private TextConstants.*			</imports><category>Aragon.Look Policies.Nextstep</category></class><class><name>NSMenuItemController</name><environment>Aragon</environment><super>UI.MenuItemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><class><name>Win95ComboBoxInputBoxController</name><environment>Aragon</environment><super>UI.ComboBoxInputBoxController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isMenuButton </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ComboBox</category></class><class><name>NSMenuItemView</name><environment>Aragon</environment><super>UI.MenuItemView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composedLabel composedCharacter accessCharacter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><comment><class-id>Aragon.NSMenuItemView</class-id><body>NSMenuItemViews are Views that display a single MenuItem in the OS/2 NS (Common User Access) UILook of OS/2 Presentation Manager.  Instances will usually be part of a NSMenuView.  The model is a MenuItem.  This class is private to the implementation of MenuItem and MenuItemList.  Users should not interface to this class directly or subclass this class.Collaborators:	MenuItem will be my modelMessage protocols declared as being 'protected' are for use only by the class and its subclasses.  Message protocols declared as being 'private' are for use ONLY by this class, NOT by subclasses.  Messages protocols declared as being 'privileged' are for use only by certain other privileged classes that are collaborators with this class.  Behavior inherited from the superclass is also 'protected' or 'privileged' in this class and its subclasses.  All variables are private to this class.Instance Variables:	accessCharacter  &lt;Integer | nil&gt; the index into the label of the access character (or nil if none)	composedCharacter  &lt;Label | nil&gt;  the Label for the shortcutKeyCharacter (if any)	composedLabel  &lt;Label&gt; the Label for the menu items label TextClass Variables:	IndicationIcon &lt;CachedImage&gt; the check-mark character used to indicate on/off state	SubmenuIcon &lt;CachedImage&gt; the triangle indicator that a submenu exists for the menu item</body></comment><class><name>WindowResizeController</name><environment>Aragon</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ResizeCorner</category></class><class><name>Win95CheckButtonView</name><environment>Aragon</environment><super>Aragon.NSCheckButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.Widgets</category></class><class><name>NSLookPolicy</name><environment>Aragon</environment><super>UI.UILookPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>scrollbarThickness </class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep</category></class><comment><class-id>Aragon.NSLookPolicy</class-id><body>Instances of this class are a UILookPolicy for the NS look/feel style of OS/2.  (UILookPolicy browse) for a description of the purpose of a UILookPolicy.</body></comment><class><name>NSMenuController</name><environment>Aragon</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><class><name>NSMenuAsPopUpController</name><environment>Aragon</environment><super>Aragon.NSMenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><class><name>NSMenuAsSubmenuController</name><environment>Aragon</environment><super>Aragon.NSMenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><class><name>WindowResizeCornerSpec</name><environment>Aragon</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ResizeCorner</category></class><class><name>Win95LookPolicy</name><environment>Aragon</environment><super>Aragon.NSLookPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95</category></class><class><name>NSComboBoxButtonController</name><environment>Aragon</environment><super>UI.ComboBoxButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><class><name>Win95ComboBoxButtonController</name><environment>Aragon</environment><super>Aragon.NSComboBoxButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controlType adjustDropListWidth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ComboBox</category></class><class><name>Win95ComboBoxButtonView</name><environment>Aragon</environment><super>Aragon.NSComboBoxButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ComboBox</category></class><class><name>Win95SliderView</name><environment>Aragon</environment><super>UI.SliderView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pointTo hasTickMarks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.Widgets</category></class><class><name>NSResizingSplitterView</name><environment>Aragon</environment><super>UI.ResizingSplitterView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><class><name>WindowResizeCorner</name><environment>Aragon</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ResizeCorner</category></class><class><name>Win95ComboBoxInputFieldView</name><environment>Aragon</environment><super>Aragon.NSComboBoxInputFieldView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ComboBox</category></class><class><name>NSMenuButtonView</name><environment>Aragon</environment><super>UI.MenuButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><comment><class-id>Aragon.NSMenuButtonView</class-id><body>Instances of this Class are menu button views in the OS/2 NS look and feel style.  Menu button Views will open a menu of mutually exclusive choices to choose from.  Instances are used by NSLookPolicy.Class Variables:	ButtonEdgeBorder  &lt;Border&gt;  The border to use to display the edge of the whole button.	InsetBorder  &lt;BeveledBorder&gt;  The border to use to display menu pop-up button in the pressed state.	MenuButtonImage  &lt;CachedImage&gt;  The image of the icon on the menu pop-up button.	RaisedBorder  &lt;BeveledBorder&gt;  The border to use to display the menu pop-up button in the unpressed state.</body></comment><class><name>NSMenuBarButtonView</name><environment>Aragon</environment><super>UI.MenuBarButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessCharacter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Menus</category></class><comment><class-id>Aragon.NSMenuBarButtonView</class-id><body>Instances of this class are a menu button view on the NS look/feel menu bar.  Instances are used by NSLookPolicyInstance Variables:	accessCharacter  &lt;Integer | nil&gt; the index into the label of the access character (or nil if none)Class variables:	ButtonPressedBorder	&lt;BeveledBorder&gt;  The border to use when displaying the button in the pressed state.</body></comment><class><name>Win95ComboBoxListController</name><environment>Aragon</environment><super>UI.ComboBoxListController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recentMousePoint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ComboBox</category></class><class><name>AcceleratedLabel</name><environment>Aragon</environment><super>UI.Label</super><private>false</private><indexed-type>none</indexed-type><inst-vars>acceleratorKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Enhancements.Button Shortcuts</category></class><class><name>NSWidgetPolicy</name><environment>Aragon</environment><super>UI.WidgetPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep</category></class><comment><class-id>Aragon.NSWidgetPolicy</class-id><body>Instances of this class are a WidgetPolicy for the NS look &amp; feel style of OS/2.  (WidgetPolicy browse) for a description of the purpose of a WidgetPolicy.</body></comment><class><name>Win95WidgetPolicy</name><environment>Aragon</environment><super>Aragon.NSWidgetPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95</category></class><class><name>NSLabelController</name><environment>Aragon</environment><super>UI.SelectController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><class><name>NSGroupBox</name><environment>Aragon</environment><super>UI.GroupBox</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><class><name>Win95ComboBoxListView</name><environment>Aragon</environment><super>UI.ComboBoxListView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.ComboBox</category></class><class><name>NewNotifier</name><environment>Aragon</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.New Notifier</category></class><class><name>NSNotifier</name><environment>Aragon</environment><super>Aragon.NewNotifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.New Notifier</category></class><class><name>Win95Notifier</name><environment>Aragon</environment><super>Aragon.NewNotifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.New Notifier</category></class><class><name>Win95SliderSpec</name><environment>Aragon</environment><super>UI.SliderSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pointTo hasTickMarks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.Widgets</category></class><class><name>NSBorderDecorationPolicy</name><environment>Aragon</environment><super>UI.EmulationBorderDecorationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep</category></class><comment><class-id>Aragon.NSBorderDecorationPolicy</class-id><body>Instances of this class are a BorderDecorationPolicy for the NS user interface style of OS/2 2.0.  (BorderDecorationPolicy browse) to see the description of the purpose of a BorderDecorationPolicy.Instance variables:	scrollBarBorder	&lt;Border&gt;	The Border to go around the perimeter of the scroll bar</body></comment><class><name>Win95BorderDecorationPolicy</name><environment>Aragon</environment><super>Aragon.NSBorderDecorationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95</category></class><class><name>NSToolBar</name><environment>Aragon</environment><super>UI.ToolBar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep</category></class><class><name>Win95ScrollBar</name><environment>Aragon</environment><super>Aragon.NSScrollBar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95</category></class><class><name>NSRadioButtonView</name><environment>Aragon</environment><super>UI.RadioButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Nextstep.Widgets</category></class><comment><class-id>Aragon.NSRadioButtonView</class-id><body>Instances of this Class are radio-button Views in the NS style of OS/2 and are used by NSLookWidgetPolicy and NSLookPolicy.Class Variables:	OffImage				&lt;OpaqueImage&gt;		The image of the radio button in the off state.	OnImage				&lt;OpaqueImage&gt;		The image of the radio button in the on state.	TransitionWhenOnImage	&lt;OpaqueImage&gt;		The image when in transition from on state to still on state.	TransitionToOnImage		&lt;OpaqueImage&gt;		The image when in transition from the off state to the on state.</body></comment><class><name>Win95RadioButtonView</name><environment>Aragon</environment><super>Aragon.NSRadioButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Look Policies.Windows 95.Widgets</category></class><shared-variable><name>ScrollBarHidingEnabled</name><environment>Aragon.Win95BorderDecorator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DropDownKeys</name><environment>Aragon.Win95ComboBoxInputBoxController</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>AdjustDropListWidth</name><environment>Aragon.Win95ComboBoxButtonController</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DefaultPoints</name><environment>Aragon.Win95SliderView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DotIcon</name><environment>Aragon.NSScrollBar</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DefaultShortCutModifier</name><environment>Aragon.NSMenuItemView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>SubmenuIcon</name><environment>Aragon.NSMenuItemView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>ShortCutPrefixes</name><environment>Aragon.NSMenuItemView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>IndicationIcon</name><environment>Aragon.NSMenuItemView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DialogSupplier</name><environment>Aragon.NewNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>TitleStrings</name><environment>Aragon.NewNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>ButtonLabels</name><environment>Aragon.NewNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>Icons</name><environment>Aragon.Win95Notifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>TextBackground</name><environment>Aragon.NSLookPolicy</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>TraversalHilitePattern</name><environment>Aragon.NSLookPolicy</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DefaultIndicatorIcon</name><environment>Aragon.NSActionButtonView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>ResizeCursor</name><environment>Aragon.WindowResizeCorner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><methods><class-id>Aragon.NSScrollerButton</class-id> <category>displaying</category><body>displayOn: gc 	"Display the appropriate scroller button appearance on gc."	| image box imageOrigin |	box := self bounds.	self shouldShow ifFalse: [^gc paint: SymbolicPaint scrollbarBackground; displayRectangle: box].	gc paint: (self isInTransition			ifTrue: [self selectionBackgroundColor]			ifFalse: [self backgroundColor]).	gc displayRectangle: box.	self getBorder displayOn: gc forDisplayBox: box.	image := self image.	imageOrigin := box center - (image bounds extent // 2).	self canScroll		ifFalse: 			[gc paint: self hiliteColor.			image displayOn: gc at: imageOrigin + 1].	gc paint: self buttonPartForegroundColor.	image displayOn: gc at: imageOrigin</body><body>getBorder	^NSBorder raised</body><body>image	^self class arrowImages at: direction</body></methods><methods><class-id>Aragon.NSScrollerButton</class-id> <category>scrolling</category><body>canScroll	^(direction == #up and: [model canScrollUp])		or: [(direction == #down and: [model canScrollDown])				or: [(direction == #left and: [model canScrollLeft])						or: [direction == #right and: [model canScrollRight]]]]</body><body>down	"Scroll down one scroll increment."	self model scrollVertically: self model scrollGrid y negated</body><body>isHorizontal	^direction == #left or: [direction == #right]</body><body>isVertical	^direction == #up or: [direction == #down]</body><body>left	"Scroll to the left one scroll increment."	self model scrollHorizontally: self model scrollGrid x</body><body>right	"Scroll to the right one scroll increment."	self model scrollHorizontally: self model scrollGrid x negated</body><body>scrollPage	"Scroll one page in the receiver's appropriate direction."	direction == #up		ifTrue: 			[controller sensor cursorPoint: controller sensor cursorPoint - (0 @ self bounds height).			^model scrollVertically: (model visibleExtent - model scrollGrid) negated y].	direction == #left		ifTrue: 			[controller sensor cursorPoint: controller sensor cursorPoint - (self bounds width @ 0).			^self model scrollHorizontally: (model visibleExtent - model scrollGrid) negated x].	self flash</body><body>shouldShow	^model canScrollWith: self</body><body>up	"Scroll up one scroll increment."	self model scrollVertically: self model scrollGrid y</body></methods><methods><class-id>Aragon.NSScrollerButton</class-id> <category>updating</category><body>update: aspectSymbol with: parameter from: sender 	"Some aspect of the model has changed."	"If the state of scroll-ability has changed then redraw myself."	sender == model		ifTrue: 			[| value |	value := self canScroll ifTrue: [1] ifFalse: [(model canScrollWith: self) ifTrue: [2] ifFalse: [0]].			value == latestValue ifFalse: [latestValue := value.  self invalidate]]</body></methods><methods><class-id>Aragon.NSScrollerButton</class-id> <category>accessing</category><body>direction: aSymbol	direction := aSymbol</body></methods><methods><class-id>Aragon.NSScrollerButton</class-id> <category>private-visual properties</category><body>buttonPartForegroundColor	(direction == #up and: [model canScrollUp not]) ifTrue: [^self specificInactiveForegroundColor].	(direction == #down and: [model canScrollDown not]) ifTrue: [^self specificInactiveForegroundColor].	(direction == #left and: [model canScrollLeft not]) ifTrue: [^self specificInactiveForegroundColor].	(direction == #right and: [model canScrollRight not]) ifTrue: [^self specificInactiveForegroundColor].	^super buttonPartForegroundColor</body><body>specificBackgroundColor	^SymbolicPaint pushButtonBackground</body><body>specificHiliteColor	^SymbolicPaint pushButtonHilite</body><body>specificSelectionBackgroundColor	^SymbolicPaint pushButtonSelectionBackground</body><body>specificShadowColor	^SymbolicPaint pushButtonShadow</body></methods><methods><class-id>Aragon.NSScrollerButton class</class-id> <category>class initialization</category><body>arrowImages	^arrowImages</body><body>initialize	self setupArrowImages</body><body>setupArrowImages	"NSScrollerButton setupArrowImages."	arrowImages := Dictionary new		at: #up		put: self arrowUpImage;		at: #down	put: self arrowDownImage;		at: #left		put: self arrowLeftImage;		at: #right		put: self arrowRightImage;		at: #smallUp		put: self smallArrowUpImage;		at: #smallDown	put: self smallArrowDownImage;		at: #smallLeft	put: self smallArrowLeftImage;		at: #smallRight	put: self smallArrowRightImage;	yourself.</body></methods><methods><class-id>Aragon.NSScrollerButton class</class-id> <category>instance creation</category><body>new: direction for: aScrollWrapper 	"Answer a new instance of the receiver for scrolling aScrollWrapper in the given direction."	| scrollerButton nextScrollAfter cClass |	scrollerButton := (self model: aScrollWrapper) direction: direction.	cClass := Aragon at: #DelayingWidgetController ifAbsent: [nil].	cClass notNil 		ifTrue: 			[scrollerButton controller: cClass new.			scrollerButton controller startDelay: 250 stepDelay: 60]		ifFalse: [scrollerButton controller: WidgetController new].	scrollerButton controller		controlBlock: 			[:pt :button | 			button == #wentDown				ifTrue: 					[scrollerButton canScroll						ifTrue: [scrollerButton perform: direction; isInTransition: true]						ifFalse: ["scrollerButton scrollPage"].					nextScrollAfter := Time millisecondClockValue + 250].			(button == #down and: [scrollerButton isInTransition])				ifTrue: 					[| timeNow |					timeNow := Time millisecondClockValue.					timeNow &gt; nextScrollAfter						ifTrue: 						[scrollerButton perform: direction; isInTransition: true.							nextScrollAfter := timeNow + 60]].			(button = #up or: [button = #wentUp]) ifTrue: [scrollerButton isInTransition: false]].	^scrollerButton</body></methods><methods><class-id>Aragon.Win95BorderDecorator</class-id> <category>initialize-release</category><body>disableScrollBarHiding	self enableScrollBarHiding: false</body><body>enableScrollBarHiding	self enableScrollBarHiding: true</body><body>enableScrollBarHiding: aBoolean 	aBoolean == hidden notNil ifTrue: [^self].	aBoolean		ifTrue: 			[hidden := Array new: 2.			self isOpen ifTrue: [self checkForScrollers]]		ifFalse: 			[self verticalScrollerIsHidden ifTrue: [self showVerticalScrollerIn: self bounds].			self horizontalScrollerIsHidden ifTrue: [self showHorizontalScrollerIn: self bounds].			hidden := nil]</body><body>initialize	super initialize.	self enableScrollBarHiding: ScrollBarHidingEnabled.</body></methods><methods><class-id>Aragon.Win95BorderDecorator</class-id> <category>bounds accessing</category><body>bounds: newBounds 	"Set the receiver's bounds to newBounds."	super bounds: newBounds.	self scrollBarHidingEnabled ifTrue: [self checkForScrollersIn: newBounds].</body><body>checkForScrollers	self scrollBarHidingEnabled ifTrue: [self checkForScrollersIn: self bounds].</body><body>inset	^self hasBorder ifTrue: [2] ifFalse: [0]</body></methods><methods><class-id>Aragon.Win95BorderDecorator</class-id> <category>displaying</category><body>displayOn: aGraphicsContext 	"Display each of the receiver's components."	self hasBorder ifTrue: [NSBorder inset			displayOn: aGraphicsContext			forDisplayBox: self bounds			using: self].	super displayOn: aGraphicsContext</body></methods><methods><class-id>Aragon.Win95BorderDecorator</class-id> <category>private</category><body>checkForHorizontalScrollerIn: bounds 	component canScrollHorizontally		ifTrue: [self horizontalScrollerIsHidden				ifTrue: 					[self showHorizontalScrollerIn: bounds.					self checkForVerticalScrollerIn: bounds]]		ifFalse: [self horizontalScrollerIsDisplayed				ifTrue: 					[self hideHorizontalScrollerIn: bounds.					self checkForVerticalScrollerIn: bounds.					^true]].	^false</body><body>checkForScrollersIn: bounds 	| invalidate |	invalidate := false.	components isEmpty ifTrue: [^self].	self hasVerticalScrollBar ifTrue: [invalidate := invalidate | (self checkForVerticalScrollerIn: bounds)].	self hasHorizontalScrollBar ifTrue: [invalidate := invalidate | (self checkForHorizontalScrollerIn: bounds)].	invalidate ifTrue: [self invalidate].</body><body>checkForVerticalScrollerIn: bounds 	component canScrollVertically		ifTrue: [self verticalScrollerIsHidden				ifTrue: 					[self showVerticalScrollerIn: bounds.					self checkForHorizontalScrollerIn: bounds]]		ifFalse: [self verticalScrollerIsDisplayed				ifTrue: 					[self hideVerticalScrollerIn: bounds.					self checkForHorizontalScrollerIn: bounds.					^true]].	^false</body><body>computeDisplayBoxFor: aComponent inDisplayBox: aRectangle	"Answer a rectangle for aComponent to use as its display box."	^aComponent rectangleRelativeTo: (aRectangle insetBy: (self hasBorder ifTrue: [2] ifFalse: [0]))</body><body>hideHorizontalScrollerIn: bounds 	hidden at: 2 put: components removeLast.	(hidden last) invalidate; container: nil.	components first layout bottomOffset: 0.	components size &gt; 1		ifTrue: 			[components last layout bottomOffset: 0.			self layoutComponent: components last forBounds: bounds].	self layoutComponent: components first forBounds: bounds</body><body>hideVerticalScrollerIn: bounds 	hidden at: 1 put: (components removeAtIndex: 2).	hidden first container: nil.	components first layout rightOffset: 0.	components size &gt; 1		ifTrue: 			[components last layout rightOffset: 0.			self layoutComponent: components last forBounds: bounds].	self layoutComponent: components first forBounds: bounds</body><body>layoutComponent: comp forBounds: boundsOrNil 	| box |	(box := boundsOrNil) isNil ifTrue: [box := self bounds].	box := 0 @ 0 extent: box extent.	comp bounds: (self computeDisplayBoxFor: comp inDisplayBox: box)</body><body>showHorizontalScrollerIn: bounds 	components addLast: hidden last.	components first layout bottomOffset: hidden last layout topOffset.	components size &gt; 2		ifTrue: 			[| c | (c := components at: 2) invalidate layout bottomOffset: hidden last layout topOffset.			self layoutComponent: c forBounds: bounds].	hidden last layout rightOffset: components first layout rightOffset.	self layoutComponent: hidden last forBounds: bounds.	self layoutComponent: components first forBounds: bounds.	(hidden last) container: self; invalidate</body><body>showVerticalScrollerIn: bounds 	components add: hidden first beforeIndex: 2.	components first layout rightOffset: hidden first layout leftOffset.	components size &gt; 2		ifTrue: 			[| c | (c := components last) invalidate layout rightOffset: hidden first layout leftOffset.			self layoutComponent: c forBounds: bounds].	hidden first layout bottomOffset: components first layout bottomOffset.	self layoutComponent: hidden first forBounds: bounds.	self layoutComponent: components first forBounds: bounds.	(hidden first) container: self; invalidate</body></methods><methods><class-id>Aragon.Win95BorderDecorator</class-id> <category>testing</category><body>horizontalScrollerIsDisplayed	^components first layout bottomOffset ~= 0</body><body>horizontalScrollerIsHidden	^hidden last notNil and: [self horizontalScrollerIsDisplayed not]</body><body>scrollBarHidingEnabled	^hidden ~~ nil</body><body>scrollbarHidingEnabled	^hidden ~~ nil</body><body>verticalScrollerIsDisplayed	^components size &gt; 1 and: [components first layout rightOffset ~~ 0]</body><body>verticalScrollerIsHidden	^hidden first notNil and: [components first layout rightOffset == 0]</body></methods><methods><class-id>Aragon.Win95BorderDecorator class</class-id> <category>class initialization</category><body>enableScrollBarHidingByDefault: aBoolean	ScrollBarHidingEnabled := aBoolean</body><body>initialize	self enableScrollBarHidingByDefault: true</body><body>scrollbarHidingEnabledByDefault	^ScrollBarHidingEnabled</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>adding views-protected</category><body>menuItemViewForMenuItem: aMenuItem 	"Answer the appropriate MenuItemView for the receiver to be the view for aMenuItem."	^NSMenuItemView model: aMenuItem menuView: self</body><body>newHeightWithGroupSeparatorAt: verticalPosition to: aComposite width: width 	"Add a menu item group separator to aComposite at the given position. The width of the separator part 	is given. Rather than using the complex VisualComponent I need to create for a separator, it would be 	more efficient to have the MenuView draw all the separators at the appropriate places."	| componentHeight wrapper vb|	componentHeight := 8.	vb := VisualBlock block: 		[:gc :box | 			gc paint: SymbolicPaint menuShadow; displayLineFrom: 0@3 to: box width@3.			gc paint: SymbolicPaint menuHilite; displayLineFrom: 0@4 to: box width@4].	wrapper := (BoundedWrapper on: vb)		layout: nil;		bounds:  (Rectangle origin: 0@verticalPosition extent: width@componentHeight).	aComposite addWrapper: wrapper.	^verticalPosition + componentHeight</body><body>newHeightWithMenuItemViewGroup: menuItemViewGroup to: aComposite at: verticalPosition width: width 	"Add the given collection of MenuItemViews to the receiver (by putting them inside aComposite). Begin 	placing the views at the given verticalPosition in aComposite. The views occupy the given width (in 	pixels) of aComposite. Answer the new vertical position for placing the next group."	| newVerticalPosition |	verticalPosition = 0		ifTrue: [newVerticalPosition := 0]		ifFalse: [newVerticalPosition := self						newHeightWithGroupSeparatorAt: verticalPosition						to: aComposite						width: width].	^super		newHeightWithMenuItemViewGroup: menuItemViewGroup		to: aComposite		at: newVerticalPosition		width: width</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>menu item views-protected</category><body>addMenuItemViewComposite: aCompositePart height: compositeHeight	"Add the compositePart subView that contains the MenuItemViews.  compositeHeight is the computed height of the composite."	| scrollingMenuItems boundedWrapper layoutFrame edges |	scrollingMenuItems := ScrollWrapper on: aCompositePart.	edges := 3.	layoutFrame := LayoutFrame		leftFraction: 0 offset: 1		rightFraction: 1 offset: -2		topFraction: 0 offset: edges+1		bottomFraction: 1 offset: -2.	boundedWrapper := BoundedWrapper on: scrollingMenuItems in: layoutFrame.	"Give the bounded wrapper a reasonable starting preferredBounds."	boundedWrapper bounds: (aCompositePart preferredBounds expandedBy: 0@(edges+2)).	self addWrapper: boundedWrapper.	self controller setScrollWrapper: scrollingMenuItems</body><body>computeMaxWidth	"Compute the maximum width information of the menu items.  Answer the maximum preferred widths of the bounding boxes of the menuItemViews.  This is the appropriate width of the Composite containing the menuItemViews."	"15 Pixels from the left edge to the beginning of the label, 8 pixels between the label and that start of the short cut keys column (if any), and 15 pixels to the right edge of the menu.  A submenu indicator sits in the shortcut key column."	| maxLabelColumnWidth maxShortcutColumnWidth maxBoundingWidth |	maxLabelColumnWidth := maxShortcutColumnWidth := maxBoundingWidth := 0.	self menuItemViews do: [:eachGroup |		eachGroup do: [:eachItem |			maxLabelColumnWidth := maxLabelColumnWidth max: eachItem preferredLabelExtent x.			maxShortcutColumnWidth := maxShortcutColumnWidth max: eachItem preferredRightSideIndicatorsWidth]].	maxShortcutColumnWidth = 0		ifTrue: [			"No shortcuts to worry about."			maxBoundingWidth := 32 "15 + 6" + maxLabelColumnWidth]		ifFalse: [			shortcutColumnIndent := "15 + 8" 32 + maxLabelColumnWidth.			maxBoundingWidth := shortcutColumnIndent + maxShortcutColumnWidth + 6].	^maxBoundingWidth</body><body>insetWidthOfMenuBorder	"Answer the width in pixels of the menu border (see withBoundedWrapper method)."	^4</body><body>withBoundedWrapper	"Answer the receiver wrapped in an appropriate bounded wrapper."	^BoundedWrapper on: self in: nil</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>displaying</category><body>displayOn: aGraphicsContext 	"Display the receiver on aGraphicsContext."	NSBorder raised displayOn: aGraphicsContext forDisplayBox: self bounds using: self.	super displayOn: aGraphicsContext</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>displaying-privileged</category><body>shortcutColumnIndent	"Answer the number of pixels to indent the shortcut indicator column on the labels. Sent by the menu 	items."	^shortcutColumnIndent</body><body>supportsKeyboard	"On Windows, even popup menus can have accelerators."	^true</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>protected</category><body>borderTopThickness	^0</body><body>cursorOffsetForPopUpStyle	"Answer the offset from the cursor point that a menu view should be positioned	when appearing in the 'pop up' style."	^1@-8</body><body>menuButtonPositionMenuWindow: menuWindow forParentMenuButtonView: parentMenuButtonView displayBox: parentDisplayBox	"Position the menuWindow appropriately in relation to the parent MenuButtonView."	| theMenu theCurrentChoice positioningMenuItemView offsetForMenuItem |	theMenu := self menu.	theCurrentChoice := parentMenuButtonView currentChoice.	self menuItemViewsAsCollection do: [:eachView |		(theMenu valueForMenuItem: eachView menuItem) = theCurrentChoice ifTrue: [			positioningMenuItemView := eachView]].	positioningMenuItemView == nil		ifTrue: [offsetForMenuItem := 0@0]		ifFalse: [offsetForMenuItem := positioningMenuItemView localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow moveTo: parentDisplayBox topLeft + (2@0) - offsetForMenuItem.</body><body>topRightOffsetAsChildMenu	"Answer the offset to position the receiver as a child menu from the topRight corner of the parent 	menu item views bounds."	^ -9@0</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>enhanced - new look policies</category><body>useWin95MenuPolicy	^true</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>privileged-parent view</category><body>mapAndStartup: aMenuWindow in: aParentWindow 	(aParentWindow respondsTo: #isEventDriven)		ifTrue: [(self respondsTo: #mapAndStartupEventDriven:)				ifTrue: [self mapAndStartupEventDriven: aMenuWindow]				ifFalse: [self mapAndStartup: aMenuWindow isEventDriven: aParentWindow isEventDriven]]		ifFalse: [self mapAndStartup: aMenuWindow]</body><body>openFromMenuBarButton: theParentMenuBarButtonView	"Open the menu as a menu appearing from a menu button on a menu bar (the parentMenuBarButtonView).  The user will be given the opportunity to make a selection.  Answer the value object associated with the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow |	parentMenuBarButtonView := theParentMenuBarButtonView.	self controller: NSMenuFromMenuBarController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := theParentMenuBarButtonView graphicsDevice.	parentDisplayBox := self displayBoxOfView: theParentMenuBarButtonView.	monitorRectangle := (theScreen preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds := menuWindowBounds align: menuWindowBounds topLeft with: parentDisplayBox bottomLeft.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindowBounds amountToTranslateWithin: monitorRectangle.	menuWindowBounds := menuWindowBounds translatedBy: intoMonitor.	menuWindowBounds := menuWindowBounds intersect: monitorRectangle.	"Need to eventually adjust if the intersection makes the bounds too small."	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	self setColorsInMenuWindow: menuWindow from: theParentMenuBarButtonView.	wrappedMenu bounds: (0@0 extent: menuWindowBounds extent).	menuWindow component: wrappedMenu.	"adopt the parentMenuBarButton's window event driven trigger"	self mapAndStartup: menuWindow in: theParentMenuBarButtonView topComponent.	^self selectedValue</body><body>openFromParentMenuItemView: theParentMenuItemView	"Open the receiver as a child menu of the given parent MenuItemView.  Allow the user to make a selection.  Answer the menu item that was selected (or nil if none)."	| theValue theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow theSelectionMemoryMenuItem positioningMenuItemView offsetForMenuItem |	parentMenuItemView := theParentMenuItemView.	self controller: NSMenuAsSubmenuController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := theParentMenuItemView graphicsDevice.	parentDisplayBox := self displayBoxOfView: parentMenuItemView.	monitorRectangle := (theScreen preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0@0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item next to parent menu item."	theParentMenuItemView menuView usedSelectionMemory ifTrue: [		usedSelectionMemory := true.		theSelectionMemoryMenuItem := self menu selectionMemory.		self menuItemViewsAsCollection do: [:eachView |			eachView menuItem == theSelectionMemoryMenuItem ifTrue: [				positioningMenuItemView := eachView]]].	positioningMenuItemView == nil		ifTrue: [offsetForMenuItem := 0@0]		ifFalse: [offsetForMenuItem := positioningMenuItemView localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow moveTo: parentDisplayBox topRight + self topRightOffsetAsChildMenu - offsetForMenuItem.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox amountToTranslateWithin: monitorRectangle.	menuWindow moveTo: menuWindow globalOrigin + intoMonitor.	self setColorsInMenuWindow: menuWindow from: theParentMenuItemView.	self mapAndStartup: menuWindow in: theParentMenuItemView topComponent.	theValue := self selectedValue.	selectionFinal == true 		ifTrue: [theParentMenuItemView menuView childSelectionValue: theValue.				(menuWindow respondsTo: #isEventDriven) ifTrue: [(theValue isNil and: [menuWindow isEventDriven not]) 					ifTrue: [theParentMenuItemView menuView setSelectionFinal: false]]]</body><body>openFromView: aView	"Open the menu over aView in the 'pop up' style.  Answer the value object associated with the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow  positioningMenuItemView offsetForMenuItem theSelectionMemoryMenuItem |	self controller: NSMenuAsPopUpController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := aView graphicsDevice.	parentDisplayBox := self displayBoxOfView: aView.	monitorRectangle := (theScreen preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0@0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item under cursor."	usedSelectionMemory := true.	theSelectionMemoryMenuItem := self menu selectionMemory.	self menuItemViewsAsCollection do: [:eachView |		eachView menuItem == theSelectionMemoryMenuItem ifTrue: [			positioningMenuItemView := eachView.			selectedValue := self menu valueForMenuItem: theSelectionMemoryMenuItem]].	positioningMenuItemView == nil		ifTrue: [offsetForMenuItem := 0@0]		ifFalse: [offsetForMenuItem := positioningMenuItemView localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow moveTo: self controller sensor globalCursorPoint + self cursorOffsetForPopUpStyle - offsetForMenuItem.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox amountToTranslateWithin: monitorRectangle.	menuWindow moveTo: menuWindow globalOrigin + intoMonitor.	self setColorsInMenuWindow: menuWindow from: aView.	self mapAndStartup: menuWindow in: aView topComponent.	^self selectedValue</body></methods><methods><class-id>Aragon.NSMenuView</class-id> <category>protected-keyboard</category><body>isMenuItem: aMenuItem matchForShortcutKeyKeyboardEvent: aKeyboardEvent 	"Answer whether aMenuItem corresponds to the given keyboard event as short cut key considering 	the receiver's criteria for matching."	"This needs to be overridden in the appropriate subclasses to determine the appropriate interpretation 	of the keyboardEvent."	| sc |	(sc := aMenuItem shortcutKeyCharacter) == nil ifTrue: [^false].	(aKeyboardEvent metaState &gt; 0 or: [sc isSymbol]) ifFalse: [^false].	aMenuItem hasSubmenu ifTrue: [^false].	(sc isSymbol and: [sc first == $*])		ifTrue: [^(NSMenuItemView shortcutFrom: aKeyboardEvent) == sc].	^super isMenuItem: aMenuItem matchForShortcutKeyKeyboardEvent: aKeyboardEvent</body></methods><methods><class-id>Aragon.NSSliderView</class-id> <category>initialize-release</category><body>initialize	super initialize.	markerLength := 20.</body></methods><methods><class-id>Aragon.NSSliderView</class-id> <category>displaying</category><body>displayOn: aGC	| mark  bd bounds|	mark := self marker.	bounds := self bounds.	self displayBackgroundIfNeededOn: aGC in: self bounds.	axis x = 1		ifTrue: [aGC paint: self color1.				aGC displayRectangle: (bounds origin corner: mark center x@bounds bottom).				aGC paint: self color2.				aGC displayRectangle: (mark center x@bounds top corner: bounds corner)]		ifFalse: [aGC paint: self color1.				aGC displayRectangle: (bounds origin corner: bounds right@mark center y).				aGC paint: self color2.				aGC displayRectangle: (bounds left@mark center y corner: bounds corner)].	markerLength = 0 ifTrue: [^self].	aGC paint: self markerColor.	aGC displayRectangle: mark.	bd := self getMarkerBorder.	bd displayOn: aGC forDisplayBox: mark using: Scrollbar markerColorPreferences.	mark := bd insetDisplayBoxFor: mark.	NSScrollBar dotIcon displayOn: aGC at: mark center-(3@3)</body></methods><methods><class-id>Aragon.NSSliderView</class-id> <category>private</category><body>defaultMarkerBorder	^NSBorder raised</body></methods><methods><class-id>Aragon.NSSliderView</class-id> <category>private-visual properties</category><body>specificInactiveBackgroundColor	^SymbolicPaint inactiveBackground</body></methods><methods><class-id>Aragon.NSMenuFromMenuBarController</class-id> <category>control defaults</category><body>controlActivity	"This controller isControlActive, so handle input from the sensor. This message is sent by 	controlLoop in Controller each time through the main control loop (while isControlActive answers 	true)."	| theSensor |	theSensor := self sensor.	theSensor keyboardPressed ifTrue: [self processKeyboardEvent: theSensor keyboardEvent].	self viewHasCursor ifTrue: [^self controlToNextLevel].	"Outside the view, may want to scroll."	self controlActivityScroll</body><body>isControlActive        "Answer whether the receiver wants to retain control."        | theParentMenuItemView |        self isControlWanted ifFalse: [^false].        theParentMenuItemView := view parentMenuItemView.        theParentMenuItemView == nil ifTrue: [^true].        theParentMenuItemView controller isChildControlActive                ifTrue: [^true].        "If the cursorPoint hasn't moved off the left side I can retain control."        sensor cursorPoint x &gt; view bounds origin x ifTrue: [^true].         ^false</body><body>isControlWanted	"Answer whether the receiver wants control considering the current state of the sensor."	| pressed |	self view selectionFinalized ifTrue: [^false].	pressed := self sensor anyButtonPressed.	state ==  #waitForMousePressed ifTrue: [		pressed			ifTrue: [state := #mousePressed].			^true].	pressed	ifFalse: [		"If the mouse button is released, it is possible that the user was		moving between two menu items.  However, it is likely inappropriate		to select the last item, in particular, because this occurs when a		divider is selected and the button is released."		self view noSelectedMenuItem.		^false].	self viewHasCursor ifTrue: [^true].	self isControlWantedInMenuBar ifTrue: [^false].	^true</body></methods><methods><class-id>Aragon.NSMenuFromMenuBarController</class-id> <category>events</category><body>mouseMovedEvent: event 	super mouseMovedEvent: event.	(self viewHasCursorWithEvent: event)		ifFalse: [(self isControlWantedInMenuBarWithEvent: event)					ifTrue: [state := #finished]]		ifTrue: [state == #waitForReleaseToOpen ifTrue: [state := #waitForReleaseToSelect]].	^event</body></methods><methods><class-id>Aragon.NSScrollBar</class-id> <category>initialize-release</category><body>bounds: newBounds	isActive := nil.	super bounds: newBounds</body><body>initialize	super initialize.	windowActive := true</body></methods><methods><class-id>Aragon.NSScrollBar</class-id> <category>private</category><body>displayInactiveOn: aGraphicsContext	"Display the receiver in its inactive state."	aGraphicsContext paint: self backgroundColor.	aGraphicsContext displayRectangle: self bounds.</body><body>displayMarkerOn: aGraphicsContext 	"Display the marker on aGraphicsContext."	| box |	box := self marker.	(model canScrollWith: self)		ifTrue: 			[aGraphicsContext paint: self markerColor; displayRectangle: box.			NSBorder raised displayOn: aGraphicsContext forDisplayBox: box.			DotIcon displayOn: aGraphicsContext at: box center - (3@3)]</body><body>isHorizontal	^alignment y = 0</body><body>isVertical	^alignment x = 0</body></methods><methods><class-id>Aragon.NSScrollBar</class-id> <category>testing</category><body>isActive	"Answer whether I should display myself as an active scroll bar."	isActive == nil ifTrue: [isActive := self shouldBeActive].	^isActive</body><body>shouldBeActive	"Answer whether I should be an active scroll bar considering the state of the model being scrolled."	| occludedExtent |	occludedExtent := (model scrollableExtent - model visibleExtent) * alignment.	^(occludedExtent x &gt; 0) or: [occludedExtent y &gt; 0]</body><body>shouldDisplayAsActive	"Answer whether I should display myself as an active scroll bar."	^self isActive &amp; windowActive</body></methods><methods><class-id>Aragon.NSScrollBar</class-id> <category>updating</category><body>update: aspectSymbol with: parameter from: sender 	"Some aspect of the model has changed."	"If the state of scroll-ability has changed then redraw myself."	sender == model		ifTrue: 			[| value |	value := model canScrollWith: self.			value == canScroll ifFalse: [canScroll := value]].	^super update: aspectSymbol with: parameter from: sender</body><body>_update: anAspectSymbol with: aParameter from: aSender	"Propagate damage if the receiver's marker has actually changed."	| wasActive oldMarker |	oldMarker :=  marker.	self marker: (self alignMarker: self computeMarkerRegion).	self marker: (self translateMarker:  marker by: self computeMarkerPosition).	wasActive := isActive.	isActive := self shouldBeActive.	wasActive ~~ isActive ifTrue: [		^self simpleRedisplayIn: self bounds].	(marker origin ~= oldMarker origin or: [marker extent ~= oldMarker extent])		ifTrue: [self simpleRedisplayIn: ((oldMarker merge: marker) intersect: self bounds)]</body></methods><methods><class-id>Aragon.NSScrollBar</class-id> <category>displaying</category><body>_displayOn: aGraphicsContext	"Display the receiver's scrolling information on aGraphicsContext." 	self shouldDisplayAsActive		ifTrue: [super displayOn: aGraphicsContext]		ifFalse: [self displayInactiveOn: aGraphicsContext].</body></methods><methods><class-id>Aragon.NSScrollBar class</class-id> <category>class initialization</category><body>initialize	"Initialize the class."	"self initialize"	DotIcon := OpaqueImage figure: self dotIcon shape: self dotMask.</body></methods><methods><class-id>Aragon.NSComboBoxButtonView</class-id> <category>displaying</category><body>displayOn: aGraphicsContext 	| box icon |	self displayBackgroundIfNeededOn: aGraphicsContext.	box := self bounds.	self getBorder		displayOn: aGraphicsContext		forDisplayBox: box		using: self.	icon := self icon.	NSWidgetPolicy		displayVisual: icon		on: aGraphicsContext		at: box extent + 1 - icon bounds extent // 2		for: self</body></methods><methods><class-id>Aragon.NSComboBoxButtonView</class-id> <category>private</category><body>getBorder	^(self isSelected or: [self isInTransition])		ifTrue: [SimpleBorder width: 1 color: self shadowColor]		ifFalse: [state hasBorder				ifTrue: [NSTwoPixelsBorder raised]				ifFalse: [SimpleBorder width: 1 color: self hiliteColor]]</body><body>icon	^NSScrollerButton arrowImages at: (self bounds width &lt; 14			ifTrue: [#smallDown]			ifFalse: [#down])</body><body>lookPolicy	"Answer a UILookPolicy that corresponds to the receiver's look/feel. Sent by the 	ComboBoxButtonController to determine the look/feel for the drop down list."	^NSLookPolicy new</body></methods><methods><class-id>Aragon.NSComboBoxButtonView</class-id> <category>controller accessing</category><body>defaultControllerClass	"Answer the class of the default controller for the receiver."	^NSComboBoxButtonController</body></methods><methods><class-id>Aragon.NSComboBoxInputFieldView</class-id> <category>visual properties</category><body>backgroundColor	^self isEnabled 		ifTrue: [SymbolicPaint background]		ifFalse: [SymbolicPaint inactiveBackground]</body><body>_backgroundColor	^self isEnabled 		ifTrue: [self hasFocus ifTrue: [self selectionBackgroundColor] ifFalse: [SymbolicPaint background]]		ifFalse: [SymbolicPaint inactiveBackground]</body></methods><methods><class-id>Aragon.NSComboBoxInputFieldView</class-id> <category>displaying</category><body>displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle	(state isOpaque or: [state hasBackgroundColor]) ifFalse: [^self].	(self controller readOnly and: [self hasFocus]) ifFalse:		[^super displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle].	aGraphicsContext paint: (self isEnabled 		ifTrue: [SymbolicPaint background] 		ifFalse: [SymbolicPaint inactiveBackground]).	aGraphicsContext displayRectangle: aRectangle.	self hasFocus 		ifTrue: 			[| insetBox | 			insetBox := aRectangle insetBy: (1@1 corner: 2@2).			aGraphicsContext paint: self selectionBackgroundColor; displayRectangle: insetBox.			aGraphicsContext paint: self traversalHiliteColor; displayRectangularBorder: insetBox].	aGraphicsContext paint: self foregroundColor.</body><body>displayOn: aGraphicsContext 	"Display the receiver on aGraphicsContext."	| label |	(self controller readOnly and: [self hasFocus]) ifFalse:		[^super displayOn: aGraphicsContext].	self displayBackgroundIfNeededOn: aGraphicsContext.	label := ((self model value isKindOf: VisualComponent) and: [controller readOnly])				ifTrue: [self model value]				ifFalse: [self displayObject].	NSWidgetPolicy displayVisual: label on: aGraphicsContext copy at: self displayOrigin for: self.</body></methods><methods><class-id>Aragon.NSComboBoxInputFieldView</class-id> <category>private</category><body>displayOrigin	^self inset@(self bounds height - displayContents lineGrid // 2).</body></methods><methods><class-id>Aragon.NSPassiveLabel</class-id> <category>accessing</category><body>labelString: aString	self label: (self makeTextLabelFor: aString asText)</body></methods><methods><class-id>Aragon.NSPassiveLabel</class-id> <category>displaying</category><body>displayLabelOn: aGraphicsContext 	label == nil ifTrue: [^self].	NSWidgetPolicy		displayVisual: label		on: aGraphicsContext		at: margin @ margin		for: self</body></methods><methods><class-id>Aragon.NSPassiveLabel</class-id> <category>visual properties</category><body>hiliteColor	"Answer the receiver's hilite color (for the highlighted border of a raised or etched region)."		^SymbolicPaint pushButtonHilite</body></methods><methods><class-id>Aragon.NSPassiveLabel</class-id> <category>controller accessing</category><body>controller	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	^self getController</body><body>controller: aController 	"Set the receiver's controller to aController.  An instance of NoController can be	specified to indicate that the receiver will not have a controller.  The model of	aController is set to the receiver's model."	self setController: aController</body></methods><methods><class-id>Aragon.NSPassiveLabel</class-id> <category>private</category><body>getController	"Answer the label`s current controller, if any."	^xController</body><body>setController: aController 	"Set the receiver's controller to aController. If aController is not nil, its view is set to the receiver 	and its model is set to aModel."	aController == nil ifFalse: [aController view: self].	xController := aController</body><body>setLabelString: aString	aString == nil ifTrue: [label := nil. ^self].	label := self makeTextLabelFor: aString asText</body></methods><methods><class-id>Aragon.NSActionButtonView</class-id> <category>bounds accessing</category><body>preferredBounds	"Answer the preferred bounding rectangle for the receiver"	"The preferred size of a Workplace action button is 50@20 pixels. The button will be increased in size 	to accomodate the size of the label if necessary. If the button can be shown as the default button 	then I will add 1 pixel on all sides to accomodate the default ring around the button."	| buttonExtent |	label == nil		ifTrue: [buttonExtent := 72 @ 16]		ifFalse: [buttonExtent := (label preferredBounds extent max: 60@12) + (12 @ 4)].	self canDefault		ifTrue: [^(Rectangle origin: 0 @ 0 extent: buttonExtent)				expandedBy: 1]		ifFalse: [^Rectangle origin: 0 @ 0 extent: buttonExtent]</body></methods><methods><class-id>Aragon.NSActionButtonView</class-id> <category>displaying</category><body>displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle		^self hasBorder		ifTrue: [self displayBackgroundOn: aGraphicsContext in: aRectangle]		ifFalse: [super displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle]</body><body>displayButtonIn: aRectangle using: aBlock on: aGraphicsContext	"Display the receiver on aGraphicsContext using aBlock to render 	the button's special decorations like its label and default 	indication."	| box border offset |	self hasBorder ifFalse: [^self displayUndecoratedOn: aGraphicsContext].	border := self getBorder.	box := aRectangle.	border		displayOn: aGraphicsContext		forDisplayBox: box		using: self.	box := border insetDisplayBoxFor: box.	(self isSelected or: [self isInTransition])		ifTrue: 			[aGraphicsContext paint: self selectionBackgroundColor; displayRectangle: box.			offset := self translationFactor]		ifFalse: 			[self displayBackgroundIfNeededOn: aGraphicsContext in: box.			offset := 0 @ 0].		(self hasFocus and: [self hasBorder])		ifTrue:			[aGraphicsContext paint: self traversalHiliteColor.			aGraphicsContext displayRectangularBorder: (box insetBy: (2@2 corner: 3@3))].	label notNil		ifTrue: 			[self setPaintOn: aGraphicsContext.			aBlock value: box center - (label bounds extent // 2) value: offset].</body><body>displayDefaultOn: gc 	"Display the receiver according to the current state of the model."	| box |	self isEnabled ifFalse: [^self displayNormalOn: gc].	box := self bounds.	self		displayButtonIn: box		using: 			[:origin :offset | | pt |			NSWidgetPolicy displayVisual: label on: gc at: origin - (7@ 0) + offset for: self.			pt := box corner x @ (box height // 2) - (20 @ 5) + offset.			gc paint: self shadowColor. self class shadowMask displayOn: gc at: pt.			gc paint: self borderColor. self class borderMask displayOn: gc at: pt.			gc paint: self hiliteColor. self class hiliteMask displayOn: gc at: pt]		on: gc.</body><body>displayNormalOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	self		displayButtonIn: self bounds		using: [:origin :offset | NSWidgetPolicy displayVisual: label on: aGraphicsContext at: origin + offset for: self]		on: aGraphicsContext</body><body>displayOn: aGraphicsContext 	self isDefault		ifTrue: [self displayDefaultOn: aGraphicsContext]		ifFalse: [self displayNormalOn: aGraphicsContext]</body></methods><methods><class-id>Aragon.NSActionButtonView</class-id> <category>private</category><body>insetBorder	^NSBorder inset</body><body>raisedBorder	^NSBorder raised</body></methods><methods><class-id>Aragon.NSActionButtonView class</class-id> <category>class initialization</category><body>initialize		"self initialize"	DefaultIndicatorIcon := OpaqueImage figure: self defaultIndicatorImage shape: self defaultIndicatorShape</body></methods><methods><class-id>Aragon.NSVisualDivider</class-id> <category>visual properties</category><body>hiliteColor	"Answer the receiver's hilite color (for the highlighted border of a raised or etched region)."		^SymbolicPaint pushButtonHilite</body></methods><methods><class-id>Aragon.NSMenuBar</class-id> <category>protected</category><body>newButtonLabeled: label accessCharacter: accessCharacterPosition menu: menuHolder 	"Answer a new MenuBarButtonView for the receiver with the given label, accesssCharacterPosition, 	and menu."	^(NSMenuBarButtonView new)		label: label		menu: menuHolder		menuBar: self; 		accessCharacterPosition: accessCharacterPosition</body></methods><methods><class-id>Aragon.NSMenuBar</class-id> <category>initialize-release</category><body>initializeSpacing	"Initialize the spacing options of the receiver."	super initializeSpacing.	spaceBetweenItems := 2.	leftSpace := 2.</body></methods><methods><class-id>Aragon.NSMenuBar</class-id> <category>privileged-look policy</category><body>inMenuBarWrapper	"Answer the receiver in an appropriate MenuBarWrapper."	| wrapper |	wrapper := MenuBarWrapper on: self.	wrapper layout: (LayoutFrame new bottomOffset: NSLookPolicy systemMenuTextStyle lineGrid+2; rightFraction: 1).	wrapper borderWidth: 0.	^wrapper</body></methods><methods><class-id>Aragon.Win95ScrollerButton</class-id> <category>displaying</category><body>getBorder	^self isInTransition		ifTrue: [SimpleBorder width: 1 color: self shadowColor]		ifFalse: [NSTwoPixelsBorder raised]</body><body>shouldShow	^true</body></methods><methods><class-id>Aragon.Win95ScrollerButton class</class-id> <category>class initialization</category><body>initialize	self setupArrowImages</body></methods><methods><class-id>Aragon.NSCheckButtonView</class-id> <category>display box accessing</category><body>preferredBounds	"Answer the rectangle of the preferredBounds for the receiver"	| labelExtent |	labelExtent := label preferredBounds extent.	^Rectangle		origin: 0@0		corner: (1 + 16 + 4 + labelExtent x)@(16 max: labelExtent y) + (2@2)</body></methods><methods><class-id>Aragon.NSCheckButtonView</class-id> <category>displaying</category><body>displayButtonOn: gc 	"Display the button part of the receiver according to the current state of the model."	"This still needs to be cleaned up a bit and probably should have the BeveledBorder stuff unwound."	| pt |	pt := 2 @ (self bounds height - self class insideMask bounds height) // 2.	gc paint: (self isEnabled 		ifTrue: [self isInTransition ifTrue: [self transitionColor] ifFalse: [self backgroundColor]]		ifFalse: [self disabledColor]).	self class insideMask displayOn: gc at: pt.	gc paint: self shadowColor. self class shadowMask displayOn: gc at: pt.	gc paint: self borderColor. self class borderMask displayOn: gc at: pt.	gc paint: self hiliteColor. self class hiliteMask displayOn: gc at: pt.	self isSelected ifTrue: [gc paint: self selectionForegroundColor. self class markMask displayOn: gc at: pt].</body><body>displayLabelOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	NSWidgetPolicy		displayVisual: label		on: aGraphicsContext		at: 21 @ (self bounds height - label preferredBounds height + 1 // 2)		for: self</body><body>displayOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	self displayButtonOn: aGraphicsContext.	self displayLabelOn: aGraphicsContext.	self hasFocus ifTrue: [self displayTraversalHiliteOn: aGraphicsContext].</body><body>displayTraversalHiliteOn: aGraphicsContext 	"Display indication that the receiver has focus."	| labelBox |	labelBox := Rectangle origin: 21 @ (self bounds height - label preferredBounds height + 1 // 2) extent: label preferredBounds extent.	aGraphicsContext paint: self traversalHiliteColor; displayInteriorRectangularBorder: (labelBox expandedBy: 2 @ 1)</body></methods><methods><class-id>Aragon.NSCheckButtonView</class-id> <category>private</category><body>redisplayButton	"Redisplay the button image part because of a change in it's state."	"Attempts to avoid invalidate if possible."	self invalidateOrRedisplayBy: [:graphContext | self displayButtonOn: graphContext]</body><body>redisplayChangeOfStateFrom: previousState to: currentState	"Redisplay the receiver because the state of the model has changed from previousState to currentState."	| box |	isInTransition := false.	box := self bounds copy right: 16.	self invalidateRectangle: box repairNow: true.	self redisplayButton</body><body>redisplayFocusChange	"Redisplay the receiver because there has been a change in whether its has keyboard focus."	self hasFocus		ifTrue: [self redisplayTraveralHilite]		ifFalse: [super redisplayFocusChange]</body><body>redisplayForTransitionChange	"Redisplay the receiver, there has been a transition between being pressed/unpressed."	self redisplayButton</body><body>redisplayTraveralHilite	"Redisplay the traversal hilite part because it's just turned on."	"Attempts to avoid invalidate if possible."	self invalidateOrRedisplayBy: [:graphContext | self displayTraversalHiliteOn: graphContext]</body></methods><methods><class-id>Aragon.NSCheckButtonView</class-id> <category>private-visual properties</category><body>disabledColor	^SymbolicPaint background</body><body>transitionColor	^ColorValue white</body></methods><methods><class-id>Aragon.Win95ActionButtonView</class-id> <category>private</category><body>insetBorder	^NSBorder inset</body><body>raisedBorder	^NSBorder raised</body></methods><methods><class-id>Aragon.Win95ActionButtonView</class-id> <category>displaying</category><body>displayDefaultOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	| box |	box := self bounds.	aGraphicsContext displayRectangle: box.	self		displayButtonIn: (box insetBy: 1)		using: [:origin :offset | NSWidgetPolicy displayVisual: label on: aGraphicsContext at: origin + offset for: self]		on: aGraphicsContext</body></methods><methods><class-id>Aragon.Win95WidgetsExample</class-id> <category>aspects</category><body>classes	^(Aragon classNames collect: [:each | Aragon at: each]) asValue</body><body>collectionClasses	| mb |	mb := MenuBuilder new.	Collection withAllSubclasses do: [:each | mb add: each name -&gt; each].	^mb menu</body><body>selectedClass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	selectedClass isNil ifTrue: [selectedClass := nil asValue].	^selectedClass</body><body>sliderValue	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	sliderValue isNil ifTrue: [(sliderValue := 0 asValue) compute: [:v | text value: v printString]].	^sliderValue</body><body>text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	text isNil ifTrue: [text := String new asValue].	^text</body></methods><methods><class-id>Aragon.NSFeelPolicy</class-id> <category>keyboard Bindings</category><body>altEditKeys	"Add the default Macintosh/Win95 key maps to the 'AltKeys' dictionary	(for 'command' editing keys on the mac, 'alt' on other platforms)."	super altEditKeys.	self altKeys 		at: BS put: #backspaceKey:;		at: $a put: #againKey:;		at: $&lt; put: #displayColonEqualKey:;	yourself.</body><body>keyboardDispatchTable	"Initialize the keyboard dispatch table."	super keyboardDispatchTable.	self keyboard 			bindValue:	#doItKey:			to: Ctrld;			bindValue:	#printItKey:			to: Ctrlp;			bindValue:	#inspectItKey:		to: Ctrlq;			bindValue:	#acceptKey:			to: Ctrls;			bindValue:	#doItKey:			to: #F5	modifiers: #(shift);			bindValue:	#printItKey:			to: #F6	modifiers: #(shift);			bindValue:	#inspectItKey:		to: #F7	modifiers: #(shift);			bindValue:	#acceptKey:			to: #F12;			bindValue:	#cancelKey:			to: #F11;			bindValue:	#indentKey:			to: Tab;			bindValue:	#nextKey:			to: $n		modifiers: #(control);			bindValue:	#cutKey:				to: Cut		modifiers: #(control);			bindValue:	#copyKey:			to: #Insert	modifiers: #(control);			bindValue:	#pasteKey:			to: #Insert	modifiers: #(shift);			bindValue:	#pasteKey:			to: #Insert;			bindValue:	#selectAllKey:		to: Ctrla;			bindValue:	#findDialogKey:		to: Ctrlf;			bindValue:	#findKey:			to: #F3;			bindValue:	#replaceDialogKey:	to: Ctrlr;			bindValue:	#replaceKey:			to: Ctrlr	modifiers: #(shift control);	yourself.	self supportsCodeEditing 			ifTrue: 			[self keyboard 				bindValue:	#displayIfTrueKey:		to: ESC followedBy: $t;				bindValue:	#displayIfFalseKey:		to: ESC followedBy: $f;				bindValue:	#displayDateKey:			to: ESC followedBy: $d;				bindValue:	#miniFormatKey:			to: ESC followedBy: $m;				bindValue:	#cancelKey:				to: ESC followedBy: ESC;			yourself].</body></methods><methods><class-id>Aragon.NSFeelPolicy class</class-id> <category>installation</category><body>menuName	^'Aragon'</body></methods><methods><class-id>Aragon.NSMenuItemController</class-id> <category>event driven</category><body>isChildControlActiveWithEvent: event 	"Answer whether the child menu of the receiver should retain control. The cursor is typically outside 	the view of the child menu so the receiver (as the parent menu item) can determine if it should retain 	control or give up control (perhaps because the cursor has moved onto a different parent menu 	item)."	"If the cursor is on the receiver, then yes, the child should retain control."	^(view bounds containsPoint: (self sensor cursorPointFor: event))		or: [(view menuView bounds containsPoint: (view menuView controller sensor cursorPointFor: event)) not]</body></methods><methods><class-id>Aragon.NSMenuItemController</class-id> <category>control defaults</category><body>controlActivity	"Wait to change of button state, that is the user releases the pressed mouse button 	or the user now pressed to button."	| theSensor |	theSensor := self sensor.	theSensor keyboardPressed 		ifTrue: [view menuView controller processKeyboardEvent: theSensor keyboardEvent].	state == #waitForMousePressed		ifTrue: [self sensor anyButtonPressed ifTrue: [state := #waitForMouseReleased]]		ifFalse: [super controlActivity]</body><body>controlInitialize	"Remember the current mouse button state to detect state changes."	state := self sensor anyButtonPressed ifTrue: [#mousePressed] ifFalse: [#waitForMousePressed].	super controlInitialize</body><body>isControlWanted	"Answer true if the receiver wants control. (We'll activate even if no button is pressed)"	^self viewHasCursor</body></methods><methods><class-id>Aragon.Win95ComboBoxInputBoxController</class-id> <category>keyboard</category><body>completeTypeIn	| completer |	(completer := Aragon at: #Completer) isNil 		ifFalse: [completer completeTypeInFor: self from: self listItems].</body><body>determineCurrentSelectionIndex	| s items |	(s := view displayContents asString) isEmpty ifTrue: [^0].	items := self listItems.	1 to: items size do: [:i | (items at: i) displayString asString = s ifTrue: [^i]].	^0</body><body>moveSelectionBy: delta 	self selectItemAt: (self determineCurrentSelectionIndex + delta)</body><body>processKeyboardEvent: anEvent 	| kv isalpha |	kv := anEvent keyValue.	((DropDownKeys includes: kv) and: [anEvent metaState == 0])		ifTrue: [^buttonController openDropDownListWithEvent: anEvent].	kv isSymbol		ifTrue: 			[isalpha := false.			self readOnly				ifTrue: 					[kv == #Home ifTrue: [^self selectItemAt: 1].					kv == #End ifTrue: [^self selectItemAt: self listItems size]].			kv == #Down ifTrue: [^self moveSelectionBy: 1].			kv == #Up ifTrue: [^self moveSelectionBy: -1]]		ifFalse: 			[((isalpha := kv isAlphaNumeric) and: [self readOnly]) 				ifTrue: [^self searchChar: kv]].	super superProcessKeyboardEvent: anEvent.	(isalpha &amp; self readOnly not) ifTrue: [self completeTypeIn].</body><body>searchChar: aCharacter 	| c i0 listItems |	c := aCharacter asUppercase.	listItems := self listItems.	i0 := self determineCurrentSelectionIndex.	i0 + 1 to: listItems size do: [:i | (listItems at: i) displayString first asUppercase == c ifTrue: [^self selectItemAt: i]].	1 to: i0 do: [:i | (listItems at: i) displayString first asUppercase == c ifTrue: [^self selectItemAt: i]]</body><body>selectItemAt: index 	index &lt; 1 ifTrue: [^self].	index &gt; (self listItems) size ifTrue: [^self].	self dispatchMenuSelectionAt: index</body></methods><methods><class-id>Aragon.Win95ComboBoxInputBoxController</class-id> <category>private</category><body>buttonController	^buttonController</body><body>listItems	| answer |	((answer := buttonController view dropDownListItems) isKindOf: Menu)		ifTrue: [^answer menuItems collect: [:each | each label]].	^answer</body><body>takeNewValue: aValue	self isMenuButton ifFalse: [super takeNewValue: aValue].</body></methods><methods><class-id>Aragon.Win95ComboBoxInputBoxController</class-id> <category>menu button interface</category><body>dispatchMenuSelection: menuSelection	"A menu pick was made	Dispatch the selection by using the following rule.		1. If the menuSelection is a symbol use it as the argument of perform:			with the menuMessageReceiver as the receiver.		2. If the menuSelection is a BlockClosure send value: and pass self (the Controller)			as argument.		3. Assume the performer is a ValueModel."	self isMenuButton ifFalse: [^super dispatchMenuSelection: menuSelection].	menuSelection = 0 ifTrue: [^self].	self sensor window keyboardProcessor checkForAutoAccept.	menuSelection isSymbol			ifTrue: [^self dispatchMenuSymbol: menuSelection].	menuSelection class == BlockClosure		ifTrue: [^self dispatchBlockClosure: menuSelection].	"Otherwise assume that the performer is a value channel"	model == nil ifFalse: [self requestValueChange ifTrue: [model value: menuSelection. self valueChange]]</body><body>dispatchMenuSelectionAt: anIndex 	| menu |	anIndex &gt; 0 ifFalse: [^self].	self isMenuButton 		ifFalse: [^super takeNewValue: (self listItems at: anIndex)].	menu := buttonController view list.	menu selectionMemory: anIndex.	self dispatchMenuSelection: (menu menuItems at: anIndex) value</body><body>dispatchMenuSymbol: menuSelection 	self isMenuButton ifFalse: [^super dispatchMenuSymbol: menuSelection].	model == nil ifFalse: [(model isKindOf: ValueModel)			ifTrue: [self requestValueChange					ifTrue: 						[model value: menuSelection.						self valueChange]]			ifFalse: [model perform: menuSelection]]</body><body>isMenuButton	^isMenuButton == true</body><body>isMenuButton: aBoolean	isMenuButton := aBoolean</body></methods><methods><class-id>Aragon.Win95ComboBoxInputBoxController</class-id> <category>menu messages</category><body>accept	"Save the current text of the text being edited as the current acceptable	version for purposes of canceling."	self requestValueChange ifFalse: [^model changed].	self privateAccept</body></methods><methods><class-id>Aragon.Win95ComboBoxInputBoxController class</class-id> <category>class initialization</category><body>dropDownKeys	^DropDownKeys</body><body>dropDownKeys: anArrayOfKeyValues	DropDownKeys := anArrayOfKeyValues</body><body>initialize	self dropDownKeys: (Array with: #F4)</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>privileged</category><body>preferredHeight	"Answer the preferred height for the bounding rectangle."	^self preferredLabelExtent y + 2</body><body>preferredLabelExtent	"Answer the preferred extent for the label column entry for this menu item (as opposed to the shortcut key column)."	"8 pixels between labelImage and label (if the labelImage exists)"	| theLabel labelImage labelImageExtent preferredWidth |	theLabel := self composedLabel.	labelImage := model labelImage.	labelImage == nil		ifTrue: [			labelImageExtent := 0@0.			preferredWidth := theLabel width]		ifFalse: [			labelImageExtent := labelImage bounds extent.			preferredWidth := theLabel width + labelImageExtent x + 8].		^preferredWidth@((0 max: labelImageExtent y) max: (theLabel height))</body><body>preferredRightSideIndicatorsWidth	"Answer the preferred width of the right side indicators (the submenu indicator or the shortcut key entry (if any)).  These appear as a separate column."	^model hasSubmenu		ifTrue: [10 "IndicationIcon bounds width"]		ifFalse: [self composedCharacterWidth]</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>displaying-private</category><body>composedCharacter	"Answer the composed text for the shortcut key character of this menu item (or nil if none)."	composedLabel == nil ifTrue: [self computeComposedTexts].	^composedCharacter</body><body>composedCharacterWidth	"Answer the width of the area needed for the short cut key indication.  If there is no shortcut key answer zero."	| theComposedCharacter |	theComposedCharacter := self composedCharacter.	theComposedCharacter == nil ifTrue: [^0].	^theComposedCharacter width</body><body>composedLabel	"Answer the composed text for the label of this menu item."	composedLabel == nil ifTrue: [self computeComposedTexts].	^composedLabel</body><body>computeComposedTexts	"Compute the composed text object appropriate for the label of the receiver and for the 	shortcutKeyCharacter and cache it."	| theMenuItem theText textStyle s |	theMenuItem := self menuItem.	textStyle := NSLookPolicy systemMenuTextStyle.	theText := theMenuItem labelText.	theText == nil ifTrue: [theText := theMenuItem label asText] ifFalse: [theText copy].	s := theText asString.	('*\b' match: s) ifTrue: [theText := (s copyFrom: 1 to: s size-2) asText emphasizeAllWith: #bold].	('*\i' match: s) ifTrue: [theText := (s copyFrom: 1 to: s size-2) asText emphasizeAllWith: #italic].	('*\bi' match: s) ifTrue: [theText := (s copyFrom: 1 to: s size-3) asText emphasizeAllWith: #(bold italic)].	menuView supportsKeyboard		ifTrue: 			[accessCharacter := theMenuItem accessCharacterPosition.			accessCharacter == nil ifFalse: [theText := theText copy							addEmphasis: #(#underline)							removeEmphasis: #()							allowDuplicates: false							from: accessCharacter							to: accessCharacter].			theMenuItem hasSubmenu				ifFalse: 					[self computeShortcutFor: theMenuItem style: textStyle]].	composedLabel := Label with: theText attributes: textStyle</body><body>computeShortcutFor: menuItem style: textStyle 	| s |	s := self class shortcutKeyFrom: menuItem defaultPrefix: (ShortCutPrefixes at: DefaultShortCutModifier).	s == nil ifTrue: [^self].	composedCharacter := Label with: s asText attributes: textStyle</body><body>displayIndicationOn: aGraphicsContext in: theMenuItemBox	"Display the indication state of the menu item on aGraphicsContext inside theMenuItemBox."	IndicationIcon displayOn: aGraphicsContext		at: 5@(theMenuItemBox height - 12 "IndicationIcon extent y") // 2</body><body>displayLabelOn: aGraphicsContext in: theMenuItemBox 	"Display the label of the menu item on aGraphicsContext inside theMenuItemBox. isSelected 	indicates if the menu item is to be displayed in it's selected 'highlighted' state."	| theComposedLabel verticalPosition theLabelImage labelPosition |	theLabelImage := model labelImage.	labelPosition := 15.	theLabelImage ~~ nil		ifTrue: 			[| imageBounds imageVerticalPosition |			imageBounds := theLabelImage bounds.			imageVerticalPosition := theMenuItemBox height - imageBounds height // 2.			theLabelImage displayOn: aGraphicsContext at: labelPosition @ imageVerticalPosition.			labelPosition := labelPosition + imageBounds width + 8].	theComposedLabel := self composedLabel.	verticalPosition := theMenuItemBox height - theComposedLabel height // 2.	self isEnabled		ifFalse: 			[aGraphicsContext paint: self hiliteColor.			theComposedLabel displayOn: aGraphicsContext at: labelPosition @ verticalPosition + 1.			aGraphicsContext paint: self foregroundColor].	theComposedLabel displayOn: aGraphicsContext at: labelPosition @ verticalPosition</body><body>displayRightSideIndicatorsOn: aGraphicsContext in: theDisplayBox 	"Display the indicators (if any) on the right edge (the submenu indicator or the shortcut key indicator)."	model hasSubmenu		ifTrue: [self displaySubMenuIndicatorOn: aGraphicsContext in: theDisplayBox]		ifFalse: [self displayShortCutOn: aGraphicsContext in: theDisplayBox]</body><body>displaySelectionBackgroundOn: aGraphicsContext in: theDisplayBox 	"Display the background on aGraphicsContext (inside theDisplayBox) to indicate that the 	menu item is currently selected (highlighted)."	aGraphicsContext paint: self selectionBackgroundColor; displayRectangle: theDisplayBox</body><body>displayShortCutOn: aGraphicsContext in: theMenuItemBox	"Display the short cut indication (if any) of the menu item on aGraphicsContext inside theMenuItemBox."	| verticalPosition horizontalPosition |	composedCharacter == nil ifTrue: [^self].	verticalPosition := (theMenuItemBox height - composedCharacter height) // 2.	horizontalPosition := menuView shortcutColumnIndent.	composedCharacter displayOn: aGraphicsContext at: horizontalPosition@verticalPosition</body><body>displaySubMenuIndicatorOn: aGraphicsContext in: theDisplayBox	"Display the submenu indicator on the right edge of the menu item."	| verticalPosition horizontalPosition |	verticalPosition := (theDisplayBox height - (7 "SubmenuIcon bounds height")) // 2.	horizontalPosition := theDisplayBox right - 19 "(5 + SubmenuIcon bounds width)".	SubmenuIcon displayOn: aGraphicsContext at: horizontalPosition@verticalPosition</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>displaying</category><body>displayOn: aGraphicsContext 	"Display the receiver on aGraphicsContext. The receiver may alter aGraphicsContext in any way it 	chooses."	| box |	box := self bounds.	self isSelection		ifTrue: 			[self displaySelectionBackgroundOn: aGraphicsContext in: box.			aGraphicsContext paint: self selectionForegroundColor]		ifFalse: [aGraphicsContext paint: self foregroundColor].	model isOn ifTrue: [self displayIndicationOn: aGraphicsContext in: box].	self displayLabelOn: aGraphicsContext in: box.	self displayRightSideIndicatorsOn: aGraphicsContext in: box</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>selection-privileged</category><body>openSubMenu	"One the submenu of this menu item."	(NSMenuView model: model submenu) openFromParentMenuItemView: self</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>visual properties</category><body>selectionForegroundColor	"Answer the receiver's selection foreground color."	self menuItem isEnabled		ifTrue: [			| selectedEnabledColor |			selectedEnabledColor := model color.			selectedEnabledColor ~~ nil ifTrue: [^selectedEnabledColor].			^super selectionForegroundColor]		ifFalse: [^ColorValue gray]</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>display box accessing</category><body>preferredBounds	"Answer a preferred bounding rectangle for the menu item view."	"In general it is not possible for the receiver to calculate the proper answer so answer instead a rectangle with the preferredLabelExtent."	^Rectangle origin: 0@0 extent: self preferredLabelExtent</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>privileged-keyboard</category><body>processKeyboardEvent: aKeyboardEvent	"Process the given keyboard event if possible.  Answer whether the keyboard event was handled."	| matchCharacter |	accessCharacter == nil ifTrue: [^false].	matchCharacter := (self composedLabel text at: accessCharacter) asUppercase.	((aKeyboardEvent hasKeyValue: matchCharacter) or: [aKeyboardEvent hasKeyValue: matchCharacter asLowercase])		ifTrue: [			self assumeSelection.			self menuItem hasSubmenu ifTrue: [self openSubMenu] ifFalse: [self finalizeSelection].			^true]		ifFalse: [^false]</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>controller accessing</category><body>defaultControllerClass	"Answer the class of the default controller for the receiver."	^NSMenuItemController</body></methods><methods><class-id>Aragon.NSMenuItemView</class-id> <category>privileged-selection</category><body>assumeSelection	"The receiver is to become the 'selected' highlighted menu item.  Usually sent from the controller."	self menuView highlightedMenuItemView: self.	(self menuItem hasSubmenu 			and: [self isEnabled 			and: [self controller viewHasCursor]])			"and: [self controller sensor anyButtonPressed]])"		ifTrue: [self openSubMenu]</body></methods><methods><class-id>Aragon.NSMenuItemView class</class-id> <category>initialization</category><body>initialize	"Initialize the class."	"self initialize"	| modifiers n |	IndicationIcon := self indicationIcon.	SubmenuIcon := self submenuIcon.	modifiers := #(Shift Ctrl Alt Meta).	n := modifiers size ** 2.	ShortCutPrefixes := Array new: n.	1 to: n do: 		[:i || s |			s := ''.			(i bitAnd: 2r0001) &gt; 0 ifTrue: [s := s, (modifiers at: 1), '+'].			(i bitAnd: 2r0010) &gt; 0 ifTrue: [s := s, (modifiers at: 2), '+'].			(i bitAnd: 2r0100) &gt; 0 ifTrue: [s := s, (modifiers at: 3), '+'].			(i bitAnd: 2r1000) &gt; 0 ifTrue: [s := s, (modifiers at: 4), '+'].			ShortCutPrefixes at: i put: s.		].	DefaultShortCutModifier := 2r0100.</body><body>modifierIndexFor: aKeyboardEvent 	| answer |	answer := 0.	aKeyboardEvent hasCtrl ifTrue: [answer := answer bitOr: 2].	aKeyboardEvent hasShift ifTrue: [answer := answer bitOr: 1].	aKeyboardEvent hasAlt ifTrue: [answer := answer bitOr: 4].	aKeyboardEvent hasMeta ifTrue: [answer := answer bitOr: 8].	^answer</body><body>shortcutFrom: aKeyboardEvent 	| kv m |	kv := aKeyboardEvent keyValue.	kv == Character tab ifTrue: [^nil].	kv == Character backspace ifTrue: [^nil].	kv == Character del ifTrue: [^nil].	(kv isSymbol or: [kv == Character cr])		ifFalse: 			[kv &lt;= $! ifTrue: [kv := Character value: kv asInteger + 64].			kv isLowercase ifTrue: [kv := kv asUppercase]].	(m := NSMenuItemView modifierIndexFor: aKeyboardEvent) == 0 ifTrue: [^kv].	kv isSymbol ifFalse: [kv := String with: kv].	^('*' , (String with: (Character value: m)) , kv) asSymbol</body><body>shortcutKeyFrom: item defaultPrefix: aPrefix 	| sc |	(sc := item shortcutKeyCharacter) == nil ifTrue: [^nil].	(sc isSymbol and: [sc first == $*])		ifTrue: 			[| s |			sc last == Character cr ifTrue: [sc := (sc copyFrom: 1 to: 2), 'Return'].			s := sc size &gt; 3 ifTrue: [sc copyFrom: 3 to: sc size] ifFalse: [String with: sc last].			^(ShortCutPrefixes at: (sc at: 2) asInteger), s].	sc == Character cr ifTrue: [^#Return].	^item shortcutString</body><body>shortCutPrefixes	^ShortCutPrefixes</body><body>submenuIcon: anImage	SubmenuIcon := anImage</body></methods><methods><class-id>Aragon.WindowResizeController</class-id> <category>basic control sequence</category><body>controlInitialize	view cursor show</body><body>controlTerminate	Cursor normal show</body></methods><methods><class-id>Aragon.WindowResizeController</class-id> <category>control defaults</category><body>controlActivity	self sensor redButtonPressed ifTrue: [self doResize].</body></methods><methods><class-id>Aragon.WindowResizeController</class-id> <category>events</category><body>redButtonPressedEvent: event 	self doResize</body></methods><methods><class-id>Aragon.WindowResizeController</class-id> <category>private</category><body>doResize	| box pt lastPoint window |	window := self view topComponent.	box := window displayBox.	lastPoint := nil.	view cursor showWhile: [[self sensor anyButtonPressed]			whileTrue: 				[(pt := sensor globalCursorPoint) ~= lastPoint					ifTrue: 						[box corner: pt.						window moveTo: box origin resize: box extent].				lastPoint := pt]]</body><body>downcastEvent: aKey with: aParameter from: anInitiator	"This is a message passed down the view structure to all subparts."	super downcastEvent: aKey with: aParameter from: anInitiator.	(aKey == #deactivate and: [Cursor currentCursor == view cursor]) 		ifTrue: [Cursor normal show].</body></methods><methods><class-id>Aragon.Win95CheckButtonView</class-id> <category>private-visual properties</category><body>disabledColor	^SymbolicPaint background</body><body>transitionColor	^SymbolicPaint background</body></methods><methods><class-id>Aragon.NSLookPolicy</class-id> <category>implementation classes</category><body>actionButtonClass	^NSActionButtonView</body><body>borderLayoutPolicy	^NSBorderDecorationPolicy new</body><body>checkBoxClass	^NSCheckButtonView</body><body>comboButtonViewClass	^NSComboBoxButtonView</body><body>compliantMultiSelectControllerClass	^NSEmulatedSequenceController</body><body>defaultDivider			^NSVisualDivider new etched: true</body><body>enhancedActionButtonClass	^Aragon at: #NSEnhancedActionButtonView ifAbsent: [self actionButtonClass]</body><body>enhancedLabelClass	^Aragon at: #NSEnhancedLabel ifAbsent: [PassiveLabel]</body><body>groupBoxClass			^NSGroupBox</body><body>listViewClass	^NSSequenceView</body><body>menuButtonClass	^NSMenuButtonView</body><body>multiSelectionListViewClass	^NSMultiSelectionSequenceView</body><body>radioButtonClass	^NSRadioButtonView</body><body>resizingSplitterClass	"Answer the class that implements the check box view for this policy."	^NSResizingSplitterView</body><body>simpleMultiSelectControllerClass	^NSSequenceController</body><body>sliderClass	^NSSliderView</body><body>toolbarButtonClass	^Aragon at: #NSToolbarButtonView ifAbsent: [self actionButtonClass]</body><body>widgetPolicy	^NSWidgetPolicy new</body></methods><methods><class-id>Aragon.NSLookPolicy</class-id> <category>building</category><body>comboBox: spec into: builder	"Build a ComboBox in the UIBuilder according the the given ComboBoxSpec."	| component model menu performer alignment  boxButton theChoicesList |	model := spec modelInBuilder: builder.	boxButton := self comboButtonViewClass model: model.	boxButton textStyle: spec style.	(theChoicesList := spec getComboListIn: builder) == nil		ifFalse: [boxButton listHolder: theChoicesList].	component := self comboBoxInputBoxClass new.	component inset: 4.	component converter: (spec converterWith: builder).	boxButton editorView: component.	component model: model.	self setStyleOf: component to: spec style.	component controller: self comboBoxInputBoxControllerClass new.	component controller setButtonController: boxButton controller.	self setupFlyByHelpFor: component spec: spec builder: builder.	self setDispatcherOf: component fromSpec: spec builder: builder.	spec isReadOnly ifTrue: [component controller readOnly: true].	(menu := spec getMenuIn: builder) == nil		ifFalse: [component controller menuHolder: menu].	(performer := spec getPerformerIn: builder) == nil		ifFalse: [component controller performer:  performer].	component displaySelection: false.	builder component: (self 			comboBoxCompositeWithEditor: component			andButton: boxButton).	spec tabable		ifTrue: [component widgetState isTabStop: true.				builder sendKeyboardTo: component]		ifFalse: [component widgetState canTakeFocus: true.				component controller keyboardProcessor: builder keyboardProcessor.				builder component controller dispatchOn: Character cr to: #acceptKey:.].	spec numChars == nil ifFalse: [component controller maxChars: spec numChars].	(alignment := spec alignment) == #left		ifFalse: [self setAlignmentOf: component displayContents to: alignment].	spec isDecorated 		ifTrue: 			[builder wrapWith: self borderedWrapperClass new.			builder wrapper inset: 0.			builder wrapper border: self inputFieldBorder] 		ifFalse: [builder wrapWith: self boundedWrapperClass new].	component widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [component widgetState isVisible: spec initiallyVisible].	boxButton widgetState: component widgetState.	boxButton widgetState hasBorder: spec isDecorated.	boxButton container bounds width: boxButton container bounds height.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec state: component widgetState)</body><body>comboBoxListView: spec into: builder		| lv  model  performer  |	model := spec modelInBuilder: builder.	lv := self comboBoxListViewClass new.	lv model: model listHolder.	spec hasHorizontalScrollBar ifTrue: [lv measureWidth: true].	lv selectionChannel: model selectionIndexHolder.	(performer := spec getPerformerIn: builder) == nil		ifFalse: [lv controller performer:  performer].	self setupFlyByHelpFor: lv spec: spec builder: builder.	self setStyleOf: lv to: spec style.	self setDispatcherOf: lv fromSpec: spec builder: builder.	spec tabable		ifTrue: [lv widgetState isTabStop: true.				builder sendKeyboardTo: lv]		ifFalse: [lv widgetState canTakeFocus: true.				lv controller keyboardProcessor: builder keyboardProcessor].	lv widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [lv widgetState isVisible: spec initiallyVisible].	builder component: lv.	self manufactureComboBoxListWrapperFor: spec  into: builder.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body>inputBox: spec into: builder 	super inputBox: spec into: builder.	builder component inset: 4.	builder isEditing ifTrue: [builder component editText: spec name printString]</body><body>label: spec into: builder 	| c lab |	c := NSPassiveLabel new.	self setStyleOf: c to: spec style.	lab := spec labelInBuilder: builder.	spec hasCharacterOrientedLabel		ifTrue: 			[c setLabelString: lab.			(c label class name == #AcceleratedLabel)				ifTrue: 					[c controller: NSLabelController new.					builder sendKeyboardTo: c]]		ifFalse: [c setLabel: lab].	c widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [c widgetState isVisible: spec initiallyVisible].	builder component: c.	builder wrapWith: (self simpleWrapperFor: spec).	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body>simpleWidgetWrapperOn: aBuilder spec: aSpec	^self simpleWidgetWrapperOn: aBuilder spec: aSpec state: aBuilder component widgetState</body><body>simpleWidgetWrapperOn: aBuilder spec: aSpec state: aWidgetState 	| answer restoreColors oldColors |	restoreColors := false.	aSpec hasTextBackground ifTrue: 		[| colors |		(colors := aSpec colors) isNil			ifTrue: 				[aSpec colors: (LookPreferences new setBackgroundColor: SymbolicPaint textBackground).				restoreColors := aBuilder isEditing]			ifFalse: [colors backgroundColor isNil					ifTrue: 						[(restoreColors := aBuilder isEditing) ifTrue: [oldColors := colors copy].						colors setBackgroundColor: SymbolicPaint textBackground]]].	answer := super simpleWidgetWrapperOn: aBuilder spec: aSpec state: aWidgetState.	restoreColors ifTrue: [aSpec colors: oldColors].	^answer</body><body>slider: spec into: builder	| component model |	model := spec modelInBuilder: builder.	component := self sliderClass model: model.	self setupFlyByHelpFor: component spec: spec builder: builder.	component rangeMap: spec rangeMap.	(spec orientation == #horizontal)		ifTrue: [component beHorizontal]		ifFalse: [component beVertical].	component widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [component widgetState isVisible: spec initiallyVisible].	builder component: component.	self setDispatcherOf: component fromSpec: spec builder: builder.	builder wrapWith: self borderedWrapperClass new.	builder wrapper border: NSBorder inset.	builder wrapper inset: 0.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body>textView: spec into: builder 	super textView: spec into: builder.	builder isEditing ifTrue: [builder component editText: spec name printString]</body><body>wrappedMenuBarFor: spec in: builder	"Answer a MenuBarWrapper for this LookPolicy given a Spec and a Builder for that Spec."	| menuBar |	menuBar := NSMenuBar menu: (spec getMenuIn: builder) performer: (spec getPerformerIn: builder).	builder usingMenuBar: menuBar.	^menuBar inMenuBarWrapper</body><body>wrappedToolBarFor: spec in: builder	"Answer a MenuBarWrapper for this LookPolicy given a Spec and a Builder for that Spec." 	| menuBar |	menuBar := NSToolBar menu: (spec getToolBarIn: builder) performer: (spec getPerformerIn: builder).	spec toolBar isSymbol		ifTrue: [builder componentAt: spec toolBar put: menuBar].	^menuBar</body></methods><methods><class-id>Aragon.NSLookPolicy</class-id> <category>constants</category><body>comboBoxInputBoxClass		^NSComboBoxInputFieldView</body><body>inputFieldBorder	^NSBorder inset</body></methods><methods><class-id>Aragon.NSLookPolicy</class-id> <category>private-borders</category><body>insetBorder	^NSBorder inset</body><body>raisedBorder	^NSBorder raised</body></methods><methods><class-id>Aragon.NSLookPolicy</class-id> <category>private</category><body>comboBoxCompositeWithEditor: editor andButton: boxButton	| cp |	cp := ComboBoxView new.	cp editor: editor menuButton: boxButton.	cp components first layout rightOffset: [cp bounds height negated + 2].	cp components last layout leftOffset: [cp bounds height negated+ 2].	^cp</body><body>manufactureComboBoxListWrapperFor: spec into: builder 	| c |	builder wrapper == nil ifFalse: [c := builder wrapper]		ifTrue: [c := builder component].	builder decorator: c inDefaultEdgeDecorator.	builder wrapper: ((BorderedWrapper on: builder decorator) border: SimpleBorder new).	spec hasBorder: false.	builder decorator setWidgetFlags: spec scrollingFlags</body></methods><methods><class-id>Aragon.NSLookPolicy class</class-id> <category>class initialization</category><body>hookUp5i	Aragon.AragonStuff ensureGlobal: self.</body><body>initialize	"self initialize"	TextBackground := SymbolicPaint hilite newChildQualifiedBy: #textBackground.	self scrollbarThickness: 19.	self installSystemTextStyles.	self useDottedTraversalHilite.	self hookUp5i.</body><body>useDottedTraversalHilite	self useDottedTraversalHiliteWithPalette: CoveragePalette monoMaskPalette</body><body>useDottedTraversalHiliteWithPalette: aPalette	TraversalHilitePattern := Pattern from: (CachedImage on: (Image						extent: 8 @ 8						depth: 1						palette: aPalette						bits: #[							2r10101010						 	2r01010101							2r10101010						 	2r01010101							2r10101010						 	2r01010101							2r10101010						 	2r01010101] 						pad: 8)).</body><body>useSolidTraversalHilite	TraversalHilitePattern := ColorValue lightGray.</body></methods><methods><class-id>Aragon.NSLookPolicy class</class-id> <category>installing</category><body>installLookPreferences	super installLookPreferences.	LookPreferences widgetPolicy class initializeDefaultWidgetColors.	Screen default flushPaintPreferencesCache.	"Ensure that the correct paint preferences are installed at the new widget policy's lookCode in Screen."	Screen default defaultPaintPreferencesFor: LookPreferences widgetPolicy.	NSNotifier beDefaultNotifier.</body><body>installSystemTextStyles	Fonts install: #(Arial regular 16) as: #'Notifier.Message'.	systemAttributes := self textAttributesFor: self systemTextStyle characterAttributes.	systemWidgetAttributes := self textAttributesFor: self systemWidgetTextStyle characterAttributes.	useSystemFontOnWidgets := true.</body><body>useAsCurrentLook	(UISettings preferenceModelFor: #defaultLookSelector)		value: self name</body></methods><methods><class-id>Aragon.NSLookPolicy class</class-id> <category>constants</category><body>defaultBorder	^NSBorder inset</body><body>scrollbarThickness	^scrollbarThickness</body><body>scrollbarThickness: anInteger	scrollbarThickness := anInteger</body><body>textBackground	^TextBackground</body><body>traversalHilitePattern	"Answer the Pattern to use to display the traversal hilite around widgets."	^TraversalHilitePattern</body><body>traversalHilitePattern: aPaint	TraversalHilitePattern := aPaint</body></methods><methods><class-id>Aragon.NSLookPolicy class</class-id> <category>utilities</category><body>textAttributesFor: characterAttributes	^(TextAttributes new) setCharacterAttributes: characterAttributes;		gridForFont: nil		withTopLead: 0		bottomLead: 1.</body></methods><methods><class-id>Aragon.NSLookPolicy class</class-id> <category>private</category><body>defaultFeelPolicy	^NSFeelPolicy</body><body>menuName	^'Aragon /Nextstep' copy</body></methods><methods><class-id>Aragon.NSMenuController</class-id> <category>initialize-release</category><body>initialize	"Initialize the receiver to assume the mouse is pressed." 	super initialize.	state := #waitForMousePressed</body></methods><methods><class-id>Aragon.NSMenuController</class-id> <category>control defaults</category><body>controlActivity	"This controller isControlActive, so handle input from the sensor. This message is sent by 	controlLoop in Controller each time through the main control loop (while isControlActive answers 	true)."	| theSensor |	theSensor := self sensor.	theSensor keyboardPressed ifTrue: [self processKeyboardEvent: theSensor keyboardEvent].	self viewHasCursor ifTrue: [^self controlToNextLevel].	"Outside the view, may want to scroll."	self controlActivityScroll</body><body>isControlActive        "Answer whether the receiver wants to retain control."        | theParentMenuItemView |        self isControlWanted ifFalse: [^false].        theParentMenuItemView := view parentMenuItemView.        theParentMenuItemView == nil ifTrue: [^true].        theParentMenuItemView controller isChildControlActive                ifTrue: [^true].        "If the cursorPoint hasn't moved off the left side I can retain control."        sensor cursorPoint x&gt; view bounds origin x ifTrue: [^true].         ^false</body><body>isControlWanted	"Answer whether the receiver wants control considering the current state of the sensor."	| pressed |	((self respondsTo: #hasCloseEventOccured) and: [self hasCloseEventOccured]) ifTrue: [^false].	self view selectionFinalized ifTrue: [^false].	pressed := self sensor anyButtonPressed.	state == #waitForMouseReleased ifTrue: [pressed ifFalse: [state := #waitForMousePressed]. ^true].	state == #waitForMousePressed		ifTrue: 			[pressed ifTrue: [state := #mousePressed].			^true].	pressed ifFalse: [		"If the mouse button is released, it is possible that the user was		moving between two menu items.  However, it is likely inappropriate		to select the last item, in particular, because this occurs when a		divider is selected and the button is released."		self view noSelectedMenuItem.		^false].	self viewHasCursor ifTrue: [^true].	self isControlWantedInMenuBar ifTrue: [^false].	^true</body><body>startUp	state := #waitForMouseReleased.	^super startUp</body></methods><methods><class-id>Aragon.NSMenuAsPopUpController</class-id> <category>events</category><body>buttonPressedEvent: event 	"This has been copied without modification from MenuAsPopUpController"	(self viewHasCursorWithEvent: event) ifFalse: [state := #finished. ^nil].	state == #waitForMousePressed ifTrue: [state := #waitForReleaseToSelect].	^event</body><body>buttonReleasedEvent: event 	"This has been copied without modification from MenuAsPopUpController"	state == #waitForReleaseToSelect ifTrue: [state := #finished].	^event</body><body>exposeEvent: event 	"pop up menus don't stay up after a release"	super exposeEvent: event.	(event anyButtonPressed and: [event point x &gt; 4])		ifTrue: [state := #waitForReleaseToSelect]		ifFalse: [state := #waitForMousePressed].	^nil</body><body>windowEnterEvent: event 	event anyButtonPressed		ifTrue: [state := #waitForReleaseToSelect]		ifFalse: [state := #waitForMousePressed].	^nil</body></methods><methods><class-id>Aragon.NSMenuAsSubmenuController</class-id> <category>events</category><body>buttonPressedEvent: event 	"This has been copied without modification from MenuAsSubmenuController"	"if button down is not in my area, I need to give it 	to my parent menu because the press event might 	be intended to select an item in my pareent menu"	"ignore bogus button pressed events caused by 	opening up the TransientWindow"	state == #waitForReleaseToSelect ifTrue: [^nil].	(self viewHasCursorWithEvent: event)		ifFalse: 			[state := #finished.			self view parentMenuItemView topComponent sensor queueEvent: event.			^nil].	state == #waitForMousePressed		ifTrue: 			[state := #waitForReleaseToSelect.			^event].	^nil</body><body>buttonReleasedEvent: event	"This has been copied without modification from MenuAsSubmenuController"	state == #waitForReleaseToSelect		ifTrue: 			[state := #finished. 			view noSelectedMenuItem.			^event].	^nil</body><body>exposeEvent: event 	super exposeEvent: event.	state := #justOpened.	^nil</body><body>mouseMovedEvent: event 	"Ask the parentMenuItem whether it has cursor or not if the mouse 	exits from the left of the submenu window. If the 	parentMenuItem view does not have mouse focus, close the 	submenu."	| theParentMenuItemView |	state == #justOpened		ifTrue: [state := event anyButtonPressed ifTrue: [#waitForReleaseToSelect] ifFalse: [#waitForMousePressed]]		ifFalse: [(sensor cursorPointFor: event) x &gt; view bounds origin x				ifFalse: 					[theParentMenuItemView := view parentMenuItemView.					theParentMenuItemView == nil ifTrue: [^nil].					(theParentMenuItemView controller isChildControlActiveWithEvent: event)						ifFalse: [state := #finished]]].	^super mouseMovedEvent: event</body><body>windowEnterEvent: event 	"This has been copied without modification from MenuAsSubmenuController"	event anyButtonPressed		ifTrue: [state := #waitForReleaseToSelect]		ifFalse: 			[state := #waitForMousePressed.			self view highlightedMenuItemView == nil ifTrue: [self view highlightSelectionMemoryMenuItem]].	^nil</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec</class-id> <category>dispatching</category><body>dispatchTo: policy with: builder	| c |	c := WindowResizeCorner new.	c widgetState isEnabled: self initiallyEnabled.	builder isEditing ifFalse: [c widgetState isVisible: self initiallyVisible].	builder component: c.	builder wrapWith: BoundingWrapper new.	builder applyLayout: self layout.	builder wrapWith: (policy simpleWidgetWrapperOn: builder spec: self).</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec</class-id> <category>accessing</category><body>hasInherentSize	^true</body><body>setLayout: aLayout	layout := aLayout</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec class</class-id> <category>class initialization</category><body>initialize	self installOnPalette</body><body>shouldBeOnPalette	^true</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec class</class-id> <category>instance-creation</category><body>defaultLayout	^(AlignmentOrigin new) 		leftFraction: 1; 		topFraction: 1; 		leftAlignmentFraction: 1; 		topAlignmentFraction: 1</body><body>new	^super new layout: self defaultLayout</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec class</class-id> <category>resources</category><body>paletteIconImage	"Answer an image to reperesent spec on the palette"	paletteIcon isNil ifTrue: [paletteIcon := Array with: (OpaqueImage figure: (CachedImage on: self paletteIcon)						shape: (CachedImage on: self paletteMonoIcon))					with: (CachedImage on: self paletteMonoIcon)].	^paletteIcon at: (Screen default colorDepth == 1			ifTrue: [2]			ifFalse: [1])</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec class</class-id> <category>private-interface building</category><body>componentName	"Identification of component"	^'Window Sizer'</body><body>slices	^#(	(Basics basicsEditSpec)		(Position propSpec PositionToolModel) 	)</body><body>specGenerationBlock	^[:ctrlr :point | self new]</body></methods><methods><class-id>Aragon.Win95LookPolicy</class-id> <category>implementation classes</category><body>actionButtonClass	^Win95ActionButtonView</body><body>borderLayoutPolicy	^Win95BorderDecorationPolicy new</body><body>checkBoxClass	^Win95CheckButtonView</body><body>comboBoxInputBoxClass		^Win95ComboBoxInputFieldView</body><body>comboBoxInputBoxControllerClass		^Win95ComboBoxInputBoxController</body><body>comboBoxListViewClass	^Win95ComboBoxListView</body><body>comboButtonViewClass	^Win95ComboBoxButtonView</body><body>radioButtonClass	^Win95RadioButtonView</body><body>sliderClass	^Win95SliderView</body><body>widgetPolicy	^Win95WidgetPolicy new</body></methods><methods><class-id>Aragon.Win95LookPolicy</class-id> <category>building</category><body>menuButton: spec into: builder 	| colors restoreColors oldColors editor model menu menuHolder |	menuHolder := spec getMenuIn: builder.	(menu := menuHolder value) notNil 		ifTrue: [(menu isKindOf: Menu)			ifTrue: [menu menuItems 				do: [:each | each submenu notNil 					ifTrue: [^super menuButton: spec into: builder ]].			]		].	(colors := spec colors) isNil		ifTrue: 			[spec colors: (LookPreferences new setBackgroundColor: SymbolicPaint textBackground).			restoreColors := builder isEditing]		ifFalse: [colors backgroundColor isNil				ifTrue: 					[(restoreColors := builder isEditing) ifTrue: [oldColors := colors copy].					colors setBackgroundColor: SymbolicPaint textBackground]				ifFalse: [restoreColors := false]].	self comboBox: spec into: builder.	spec isPopUp ifTrue: [builder component menuButton controller bePopUp].	editor := builder component editor.	editor controller isMenuButton: true.	spec label notNil ifTrue: [editor editText: (SimpleView new makeTextLabelFor: spec label) text].	(model := spec modelInBuilder: builder) value notNil ifTrue: [editor model: model].	restoreColors ifTrue: [spec colors: oldColors].</body><body>slider: spec into: builder	| component model |	model := spec modelInBuilder: builder.	component := self sliderClass model: model.	self setupFlyByHelpFor: component spec: spec builder: builder.	component rangeMap: spec rangeMap.	(spec orientation == #horizontal)		ifTrue: [component beHorizontal]		ifFalse: [component beVertical].	component widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [component widgetState isVisible: spec initiallyVisible].	builder component: component.	self setDispatcherOf: component fromSpec: spec builder: builder.	builder wrapWith: self boundedWrapperClass new.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body></methods><methods><class-id>Aragon.Win95LookPolicy</class-id> <category>private</category><body>manufactureGeneralWrapperFor: spec decorationType: decorationType into: builder	super manufactureGeneralWrapperFor: spec decorationType: decorationType into: builder.	(decorationType ~~ #none and: [builder isEditing and: [builder decorator notNil]]) 		ifTrue: [builder decorator disableScrollBarHiding]</body></methods><methods><class-id>Aragon.Win95LookPolicy class</class-id> <category>class initialization</category><body>initialize	"self initialize"	self installSystemTextStyles.	self scrollbarThickness: 16.	self hookUp5i.</body></methods><methods><class-id>Aragon.Win95LookPolicy class</class-id> <category>installing</category><body>askAndInstall	| dialog dialogBuilder |	dialog := SimpleDialog new.	dialogBuilder := dialog builder policy: self new.	dialogBuilder aspectAt: #look put: #Win95LookPolicy asValue.	(dialog openFrom: (UISpecification from: self setupSpec))		ifTrue: [(dialogBuilder aspectAt: #look) value useAsCurrentLook]</body><body>installLookPreferences	super installLookPreferences.	Win95Notifier beDefaultNotifier.</body><body>showWarning(Win95Notifier new title: 'Win95 Look Policy') notify:'&lt;b&gt;&lt;c:red&gt;PLEASE NOTE:&lt;/c&gt;&lt;/b&gt; &lt;i&gt;Win95 Look Policy&lt;/i&gt; comes with an own enhanced &lt;i&gt;BorderDecorator&lt;/i&gt; class. In order to install the appropriate border decorators you should &lt;c:blue&gt;close and re-open all your windows&lt;/c&gt; whenever you change the look policy to or from Windows 95.'asRichText.</body><body>useAsCurrentLook	| launcher contentsOfTranscript displayBox |	super useAsCurrentLook.	self showWarning.	launcher := ScheduledControllers scheduledControllers 				detect: [:ctrlr | ctrlr model isKindOf: VisualLauncher]				ifNone: [^self].	contentsOfTranscript := Transcript value.	displayBox := launcher view displayBox.	launcher closeAndUnschedule.	launcher := VisualLauncher new.	launcher allButOpenInterface: #windowSpec.	launcher finallyOpenIn: displayBox withType: #normal.	Transcript show: contentsOfTranscript</body></methods><methods><class-id>Aragon.Win95LookPolicy class</class-id> <category>constants</category><body>systemMenuTextStyle	"Answer the text style appropriate for text labels on menus."	^NSLookPolicy systemMenuTextStyle</body><body>systemMenuTextStyle: aTextStyle	NSLookPolicy systemMenuTextStyle: aTextStyle</body></methods><methods><class-id>Aragon.Win95LookPolicy class</class-id> <category>private</category><body>menuName	^'Aragon /Windows' copy</body></methods><methods><class-id>Aragon.NSComboBoxButtonController</class-id> <category>drop down creation</category><body>dropDownWindowBoundsFor: aDropListView 	^(super dropDownWindowBoundsFor: aDropListView) insetBy: -1@0 + (0@1)</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonController</class-id> <category>initialize-release</category><body>initialize	super initialize.	self adjustDropListWidth: self class adjustDropListWidth</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonController</class-id> <category>accessing</category><body>adjustDropListWidth	^adjustDropListWidth</body><body>adjustDropListWidth: aBoolean	adjustDropListWidth := aBoolean</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonController</class-id> <category>menu button interface</category><body>bePopUp	controlType := #popUp</body><body>bePullDown	controlType := #pullDown</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonController</class-id> <category>drop down creation</category><body>dropDownWindowBoundsFor: aDropListView 	| box |	box := super dropDownWindowBoundsFor: aDropListView.	self adjustDropListWidth		ifTrue: 			[| w | w := aDropListView computeWidth + 7.			aDropListView sequence size &gt; 10 ifTrue: [w := w + Win95LookPolicy scrollbarThickness].			box width: (box width max: w)].	^box insetBy: 1</body><body>openDropDownListWithEvent: anEvent 	controlType == #popUp		ifTrue: 			[view editorView controller processMenuAt: anEvent globalPoint centered: true.			view isInTransition: false]		ifFalse: [super openDropDownListWithEvent: anEvent]</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonController class</class-id> <category>class initialization</category><body>adjustDropListWidth	^AdjustDropListWidth</body><body>adjustDropListWidth: aBoolean	AdjustDropListWidth := aBoolean</body><body>initialize	self adjustDropListWidth: true</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonView</class-id> <category>accessing</category><body>dropDownListHeightFor: aDropListView 	"Answer the height in pixels of the drop down list that appears when the button is pressed."	| grd minSize |	(aDropListView textStyle isKindOf: TextAttributes)		ifFalse: [grd := (TextAttributes styleNamed: self textStyle ifAbsent: [TextAttributes default]) lineGrid]		ifTrue: [grd := aDropListView textStyle lineGrid].	(minSize := aDropListView numberOfElements) = 0 ifTrue: [minSize := self maxLines].	^grd * (self maxLines min: minSize) + 7</body><body>listHolder: aListCollectionHolder	"Set the list collection to use for the drop down list of the combo box."	list == nil ifFalse: [list removeDependent: self].	list := aListCollectionHolder.	list == nil ifFalse: [list addDependent: self].</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonView</class-id> <category>private</category><body>dropDownListItems	"Answer the items to be displayed in the drop down list."	| answer |	(answer := self list) == nil ifTrue: [^Array new].	"Win95 Combo box lists allow menus as drop down list items."	(answer isKindOf: Menu)		ifTrue: [^answer menuItems collect: [:mi || t | (t := mi labelText) isNil ifTrue: [mi label] ifFalse: [t]]].	^answer</body><body>icon	^Win95ScrollerButton arrowImages at: (self bounds width &lt; 14			ifTrue: [#smallDown]			ifFalse: [#down])</body><body>lookPolicy	"Answer a UILookPolicy that corresponds to the receiver's look/feel. Sent by the 	ComboBoxButtonController to determine the look/feel for the drop down list."	^Win95LookPolicy new</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonView</class-id> <category>controller accessing</category><body>defaultControllerClass	"Answer the class of the default controller for the receiver."	^Win95ComboBoxButtonController</body></methods><methods><class-id>Aragon.Win95ComboBoxButtonView</class-id> <category>updating</category><body>update: anAspect with: aParameter from: anObject 	anObject == list ifTrue: [lastSelectionIndex := 0].	^super update: anAspect with: aParameter from: anObject</body></methods><methods><class-id>Aragon.Win95SliderView</class-id> <category>initialize-release</category><body>axis: aPoint	super axis: aPoint.	pointTo := DefaultPoints at: (axis x == 1 ifTrue: [1] ifFalse: [2])</body><body>initialize	super initialize.	markerLength := nil.	self hasTickMarks: false.</body><body>rangeMap: aRangeMap	super rangeMap: aRangeMap.	self hasTickMarks: (rangeMap ~~ nil and: [rangeMap grid  ~~ nil and: [(rangeMap rangeStop - rangeMap rangeStart // rangeMap grid) &lt; 20]]).</body></methods><methods><class-id>Aragon.Win95SliderView</class-id> <category>accessing</category><body>hasTickMarks	^hasTickMarks &amp; rangeMap notNil</body><body>hasTickMarks: aBoolean	hasTickMarks := aBoolean</body><body>pointTo	^pointTo</body><body>pointTo: nilTopLeftOrBottomRight	pointTo := nilTopLeftOrBottomRight</body></methods><methods><class-id>Aragon.Win95SliderView</class-id> <category>displaying</category><body>displayHorizontalBottomMarkerOn: gc	| r x0 y0 x1 y1 oldPaint s |	r := self marker.	s := markerLength // 2.	x0 := r origin x.  y0 := r origin y.   x1 := r corner x-1.  y1 := r corner y-1.	oldPaint := gc paint.	gc paint: SymbolicPaint pushButtonHilite;	displayPolyline: (Array with: (x0+s@y1)  with: (x0@(y1-s)) with: (x0@y0) with: (x1@y0)).	gc paint: SymbolicPaint pushButtonShadow;	displayPolyline: (Array with: (x0+s@(y1-1)) with: (x1-1@(y1-s)) with: (x1-1@y0)).	gc paint: SymbolicPaint pushButtonBorder; 	displayPolyline: (Array with: (x0+s@y1) with: (x1@(y1-s)) with: (x1@(y0-1))).	gc paint: oldPaint.</body><body>displayHorizontalMarkerOn: gc	pointTo == #topLeft ifTrue: [^self displayHorizontalTopMarkerOn: gc].	pointTo == #bottomRight ifTrue: [^self displayHorizontalBottomMarkerOn: gc].	NSBorder raised displayOn: gc forDisplayBox: self marker using: self.</body><body>displayHorizontalTopMarkerOn: gc	| r x0 y0 x1 y1 oldPaint s |	r := self marker.	s := markerLength // 2.	x0 := r origin x.  y0 := r origin y.   x1 := r corner x-1.  y1 := r corner y-1.	oldPaint := gc paint.	gc paint: SymbolicPaint pushButtonHilite;	displayPolyline: (Array with: (x0@y1) with: (x0@(y0+s)) with: (x0+s@y0)).	gc paint: SymbolicPaint pushButtonBorder;	displayPolyline: (Array with: (x0@y1) with: (x1@y1) with: (x1@(y0+s)) with: (x0+s-1@(y0-1))).	gc paint: SymbolicPaint pushButtonShadow; 	displayPolyline: (Array with: (x0+1@(y1 :=y1-1)) with: ((x1 := x1-1)@y1) with: (x1@(y0+s)) with: (x0+s-1@y0)).	gc paint: oldPaint.</body><body>displayMarkerOn: gc	| r x0 y0 x1 y1 oldPaint |	r := self marker.	x0 := r origin x.  y0 := r origin y.   x1 := r corner x-1.  y1 := r corner y-1.	oldPaint := gc paint.	gc paint: SymbolicPaint pushButtonHilite;	displayPolyline: (Array with: (x0@y1) with: (x0@(y0+5)) with: (x0+5@y0)).	gc paint: SymbolicPaint pushButtonBorder;	displayPolyline: (Array with: (x0@y1) with: (x1@y1) with: (x1@(y0+5)) with: (x0+4@(y0-1))).	gc paint: SymbolicPaint pushButtonShadow; 	displayPolyline: (Array with: (x0+1@(y1 :=y1-1)) with: ((x1 := x1-1)@y1) with: (x1@(y0+5)) with: (x0+4@y0)).	gc paint: oldPaint.</body><body>displayOn: gc	| mark  bounds lineBox |	mark := self marker.	bounds := self bounds.	axis x == 1 		ifTrue: 			[| cy | cy := (bounds height min: 22) // 2.			lineBox := bounds copy top: bounds top + cy-2; bottom: bounds top + cy+2.			self hasTickMarks				ifTrue: 					[| dx y |					pointTo == #bottomRight 						ifTrue: [y := mark bottom + 1]						ifFalse:							[y := bounds top.							lineBox moveBy: 0@5].					dx := (bounds width - markerLength) / (rangeMap rangeStop - rangeMap rangeStart / rangeMap grid). 					bounds left + (markerLength//2) to: bounds right - (markerLength//2) by: dx						do: [:x | gc displayLineFrom: x@y to: x@(y+3)]].			NSBorder inset displayOn: gc forDisplayBox: lineBox using: self]		ifFalse:			[| cx | cx := (bounds width min: 22) // 2.			lineBox := bounds copy left: bounds left + cx-2; right: bounds left + cx+2.			self hasTickMarks				ifTrue: 					[| dy x |					pointTo == #bottomRight 						ifTrue: [x := mark right + 1]						ifFalse:							[x := bounds left.							lineBox moveBy: 5@0].					dy := (bounds height - markerLength) / (rangeMap rangeStop - rangeMap rangeStart / rangeMap grid). 					bounds top + (markerLength//2) to: bounds bottom - (markerLength//2) by: dy						do: [:y | gc displayLineFrom: x@y to: x+3@y]].			NSBorder inset displayOn: gc forDisplayBox: lineBox using: self].	markerLength = 0 ifTrue: [^self].	gc paint: self markerColor.	gc displayRectangle: mark.	axis x == 1 ifTrue: [self displayHorizontalMarkerOn: gc] ifFalse: [self displayVerticalMarkerOn: gc].</body><body>displayVerticalLeftMarkerOn: gc	| r x0 y0 x1 y1 oldPaint s |	r := self marker.	s := markerLength // 2.	x0 := r origin x.  y0 := r origin y.   x1 := r corner x-1.  y1 := r corner y-1.	oldPaint := gc paint.	gc paint: SymbolicPaint pushButtonHilite;	displayPolyline: (Array with: (x0@(y0+s)) with: (x0+s@y0) with: (x1@y0)).	gc paint: SymbolicPaint pushButtonBorder;	displayPolyline: (Array with: (x0@(y0+s)) with: (x0+s@y1) with: (x1@y1) with: (x1@(y0-1))).	gc paint: SymbolicPaint pushButtonShadow; 	displayPolyline: (Array with: (x0+1@(y0+s)) with: (x0+s@(y1-1)) with: ((x1-1)@(y1-1)) with: (x1-1@y0)).	gc paint: oldPaint.</body><body>displayVerticalMarkerOn: gc	pointTo == #topLeft ifTrue: [^self displayVerticalLeftMarkerOn: gc].	pointTo == #bottomRight ifTrue: [^self displayVerticalRightMarkerOn: gc].	NSBorder raised displayOn: gc forDisplayBox: self marker using: self.</body><body>displayVerticalRightMarkerOn: gc	| r x0 y0 x1 y1 oldPaint s |	r := self marker.	s := markerLength // 2.	x0 := r origin x.  y0 := r origin y.   x1 := r corner x-1.  y1 := r corner y-1.	oldPaint := gc paint.	gc paint: SymbolicPaint pushButtonHilite;	displayPolyline: (Array with: (x0@y1) with: (x0@y0) with: (x1-s@y0) with: (x1@(y1-s))).	gc paint: SymbolicPaint pushButtonBorder;	displayPolyline: (Array with: (x0@y1) with: (x1-s@y1) with: (x1+1@(y0+s-1))).	gc paint: SymbolicPaint pushButtonShadow; 	displayPolyline: (Array with: (x0+1@(y1-1)) with: (x1-s@(y1-1)) with: (x1@(y0+s-1))).	gc paint: oldPaint.</body></methods><methods><class-id>Aragon.Win95SliderView</class-id> <category>private</category><body>bounds: newBounds	super bounds: newBounds.	markerLength := nil</body><body>computeMarker	markerLength == nil 		ifTrue: [self setMarkerLength: ((axis x == 1 ifTrue: [self bounds height] ifFalse: [self bounds width]) // 2)].	super computeMarker.	axis x == 1		ifTrue: [marker bottom &gt; 21 ifTrue: [marker bottom: 21]]		ifFalse: [marker right &gt; 21 ifTrue: [marker right: 21]].	(self hasTickMarks and: [pointTo ~~ #bottomRight]) ifTrue: [marker moveBy: 5@5 * axis transpose].	^marker</body><body>defaultMarkerBorder	^NSBorder raised</body><body>setMarkerLength: aNumber	markerLength := aNumber min: 11.	markerLength even ifTrue: [markerLength := markerLength + 1].</body></methods><methods><class-id>Aragon.Win95SliderView</class-id> <category>private-visual properties</category><body>specificBackgroundColor	^SymbolicPaint background</body></methods><methods><class-id>Aragon.Win95SliderView class</class-id> <category>class initialization</category><body>defaultHorizontalPointTo	^DefaultPoints first</body><body>defaultHorizontalPointTo: nilTopLeftOrBottomRight	DefaultPoints at: 1 put: nilTopLeftOrBottomRight</body><body>defaultPoints	^DefaultPoints</body><body>defaultVerticalPointTo	^DefaultPoints last</body><body>defaultVerticalPointTo: nilTopLeftOrBottomRight	DefaultPoints at: 2 put: nilTopLeftOrBottomRight</body><body>initialize	DefaultPoints := Array new: 2.	self defaultHorizontalPointTo: #topLeft.</body></methods><methods><class-id>Aragon.NSResizingSplitterView</class-id> <category>displaying</category><body>displayOn: aGraphicsContext</body></methods><methods><class-id>Aragon.WindowResizeCorner</class-id> <category>controller accessing</category><body>cursor	^ResizeCursor</body><body>defaultControllerClass	^WindowResizeController</body></methods><methods><class-id>Aragon.WindowResizeCorner</class-id> <category>bounds accessing</category><body>preferredBounds	^self class backgroundShape bounds</body></methods><methods><class-id>Aragon.WindowResizeCorner</class-id> <category>displaying</category><body>displayOn: aGraphicsContext"	aGraphicsContext paint: self backgroundColor.	self class backgroundShape displayOn: aGraphicsContext."	aGraphicsContext paint: self hiliteColor.	self class hiliteShape displayOn: aGraphicsContext.	aGraphicsContext paint: self shadowColor.	self class shadowShape displayOn: aGraphicsContext.</body></methods><methods><class-id>Aragon.WindowResizeCorner</class-id> <category>private-visual properties</category><body>specificBackgroundColor	^SymbolicPaint pushButtonBackground</body><body>specificHiliteColor	^SymbolicPaint pushButtonHilite</body><body>specificShadowColor	^SymbolicPaint pushButtonShadow</body></methods><methods><class-id>Aragon.WindowResizeCorner class</class-id> <category>class initialization</category><body>initialize	ResizeCursor := Cursor				image: self cursorImage				mask: self cursorShape				hotSpot: 7 @ 7				name: 'WindowResizeCursor'</body></methods><methods><class-id>Aragon.Win95ComboBoxInputFieldView</class-id> <category>private</category><body>getContents	| answer menu |	answer := super getContents.	(controller isNil or: [controller isKindOf: SpinButtonInputBoxController])		ifFalse:			[((menu := controller buttonController view list) isKindOf: Menu) ifFalse: [^answer].			menu menuItems do: [:each | each value = answer 				ifTrue: [^(answer := each labelText) notNil ifTrue: [answer] ifFalse: [each label]]]].	(answer respondsTo: #asText) ifFalse: [answer := answer displayString].	^answer</body></methods><methods><class-id>Aragon.NSMenuButtonView</class-id> <category>initialize-release</category><body>initializeForFixedLabel: aString	vcBlock := [:obj :aMenu | self makeTextLabelFor: aString asString asText].	self setLabel: aString</body><body>initializeForLabelList	vcBlock := [:obj :aMenu | self makeTextLabelFor: (aMenu menuItemAt: obj) label asString  asText]</body><body>initializeForLookUp	vcBlock :=		[:obj :aMenu |		| key |		obj == defaultChoice			ifTrue: [key := defaultChoice]			ifFalse: [key := aMenu someMenuItemWithValue: obj ifNone: [nil]].		key == nil			ifTrue: [key := String new]			ifFalse: [key := key label].		self makeTextLabelFor: key asString asText]</body><body>initializeForStringValues	vcBlock := [:obj :aMenu | self makeTextLabelFor: obj  asString asText]</body></methods><methods><class-id>Aragon.NSMenuButtonView</class-id> <category>displaying</category><body>displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle		^self hasBorder		ifTrue: [self displayBackgroundOn: aGraphicsContext in: aRectangle]		ifFalse: [super displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle]</body><body>displayLabelOn: aGraphicsContext in: bounds 	| labelOrigin gc box |	box := bounds copy right: bounds right - 16.	labelOrigin := box leftCenter - (-6 @ (2 + label bounds extent y // 2)).	gc := aGraphicsContext copy intersectClip: box.	NSWidgetPolicy		displayVisual: label		on: gc		at: labelOrigin		for: self</body><body>displayNormalOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	|  box border |	self hasBorder ifFalse: [^super displayNormalOn: aGraphicsContext].	box := self bounds.	(self isSelected or: [self isInTransition])		ifTrue:			[aGraphicsContext paint: self selectionBackgroundColor.			aGraphicsContext displayRectangle: box.			border := NSBorder inset]		ifFalse:			[self displayBackgroundIfNeededOn: aGraphicsContext in: box.			border := NSBorder raised].	border displayOn: aGraphicsContext forDisplayBox: box using: self.	(self hasFocus and: [self hasBorder])		ifTrue:			[aGraphicsContext				paint: self traversalHiliteColor;				displayInteriorRectangularBorder: ((border insetDisplayBoxFor: box) insetBy: 2);				paint: self foregroundColor].	NSBorder raised 		displayOn: aGraphicsContext 		forDisplayBox: ((box rightCenter - (20@3)) extent: 10@5) 		using: self.	label == nil ifFalse: [self displayLabelOn: aGraphicsContext in: box].</body></methods><methods><class-id>Aragon.NSMenuButtonView</class-id> <category>privileged-menu</category><body>menuViewForMenu: aMenuItemList	^NSMenuView model: aMenuItemList</body></methods><methods><class-id>Aragon.NSMenuBarButtonView</class-id> <category>bounds accessing</category><body>preferredBounds	"Answer the preferred bounding rectangle for the receiver"	| buttonExtent |	label == nil		ifTrue: [buttonExtent := 0@16]		ifFalse: [buttonExtent := (label preferredBounds extent max: 0@16) + (12@2)].	^Rectangle origin: 0@0 extent: buttonExtent</body></methods><methods><class-id>Aragon.NSMenuBarButtonView</class-id> <category>displaying</category><body>displayOn: aGraphicsContext 	"Display the button on aGraphicsContext."	| box offset newGraphicsContext |	box := self bounds.	self isInTransition		ifTrue: [aGraphicsContext paint: self selectionBackgroundColor; displayRectangle: box; paint: self selectionForegroundColor]		ifFalse: [aGraphicsContext paint: self foregroundColor].	box := box insetBy: 1.	label == nil ifTrue: [^self].	offset := box center - (label bounds extent // 2).	newGraphicsContext := aGraphicsContext copy intersectClip: box.	self isEnabled		ifFalse: 			[newGraphicsContext paint: self hiliteColor.			label displayOn: newGraphicsContext at: offset + 1.			newGraphicsContext paint: self foregroundColor].	label displayOn: newGraphicsContext at: offset</body></methods><methods><class-id>Aragon.NSMenuBarButtonView</class-id> <category>initialize-release</category><body>accessCharacterPosition: theAccessCharacterPosition	"Initialize the position in the label of the access character (which may be nil)."	accessCharacter := theAccessCharacterPosition.	accessCharacter == nil ifFalse: [		self label text emphasizeFrom: accessCharacter to: accessCharacter with: #(underline)]</body><body>initialize	super initialize.	self textStyle: NSLookPolicy systemMenuTextStyle</body></methods><methods><class-id>Aragon.NSMenuBarButtonView</class-id> <category>protected</category><body>menuViewForMenu: aMenuItemList	"Answer an appropriate MenuView for displaying the given MenuItemList."	^NSMenuView model: aMenuItemList</body></methods><methods><class-id>Aragon.NSMenuBarButtonView</class-id> <category>privileged</category><body>processShortcutKeyEventAsMenuBarAccessor: aKeyboardEvent 	"Attempt to process aKeyboardEvent as an accessor key to pull down the menu. Answer whether it 	could be processed that way."	| matchCharacter |	accessCharacter == nil ifTrue: [^false].	matchCharacter := (self label text at: accessCharacter) asUppercase.	((aKeyboardEvent hasKeyValue: matchCharacter)		or: [aKeyboardEvent hasKeyValue: matchCharacter asLowercase])		ifTrue: 			[self controller startUpWithMenuBarAction.			^true]		ifFalse: [^false]</body></methods><methods><class-id>Aragon.Win95ComboBoxListController</class-id> <category>control defaults</category><body>controlActivity	| pt |	outside := false.	(sensor noButtonPressed and: [self viewHasCursor 	and: [(pt := self sensor cursorPoint) ~= recentMousePoint]])		ifTrue: [self mouseMovedTo: (recentMousePoint := pt)].	sensor keyboardPressed		ifTrue: 			[self processKeyboard.			^recentMousePoint := self sensor cursorPoint].	sensor anyButtonPressed ifTrue: [^super controlActivity]</body><body>isControlActive	^closeChannel value not and: [sensor noButtonPressed or: [self viewHasCursor]]</body><body>isControlWanted	^self viewHasCursor</body></methods><methods><class-id>Aragon.Win95ComboBoxListController</class-id> <category>keyboard</category><body>processKeyboardEvent: anEvent 	| ev ch |	ev := anEvent.	keyboardHook == nil ifFalse: [(ev := keyboardHook value: ev value: self) isNil ifTrue: [^self]].	ch := ev keyValue.	ch isSymbol		ifTrue: 			[			searchString := nil.			ch == #Down ifTrue: [^self moveSelectionBy: 1].			ch == #Up ifTrue: [^self moveSelectionBy: -1].			ch == #PageUp ifTrue: [^self scrollPageUp].			ch == #PageDown ifTrue: [^self scrollPageDown].			ch == #Home ifTrue: [^self moveSelectionBy: view lastIndex negated].			ch == #End ifTrue: [^self moveSelectionBy: view lastIndex]].	ch == #F4 ifTrue: [^self selectAndClose].	ch == Character cr ifTrue: [^self selectAndClose].	ch == Character esc ifTrue: [^self cancelAndClose].	^super processKeyboardEvent: anEvent</body><body>searchChar: aCharacter 	self multiCharSearch		ifTrue: [super searchChar: aCharacter]		ifFalse: [self simpleSearchChar: aCharacter]</body><body>simpleSearchChar: aCharacter	| c i0 |	c := aCharacter asUppercase.	i0 := view selectionIndex.	i0+1 to: view numberOfElements do: [:i | (view displayStringAt: i) asString first asUppercase == c ifTrue: [^self matchedIndex: i]].	1 to: i0 do: [:i | (view displayStringAt: i) asString first asUppercase == c ifTrue: [^self matchedIndex: i]].</body></methods><methods><class-id>Aragon.Win95ComboBoxListController</class-id> <category>private</category><body>cancelAndClose	view selectionChannel value: 0.	self close</body><body>mouseExitedAt: aPoint 	sensor redButtonPressed		ifTrue: 			[view selectionIndex: view zeroIndex.			view targetIndex: view zeroIndex.]</body><body>mouseMovedTo: aPoint	"Selection continues at relative point aPoint."	| index |	(outside and: [sensor redButtonPressed not]) ifTrue: [^self].	index := self findElementFor: aPoint.	(outside not and: [view selectionIndex ~= index]) ifTrue: [view selectionIndex: index].	view targetIndex: index.</body><body>moveSelectionBy: delta	| i1 i2 |	searchString := nil.	i1 := view selectionIndex.	super moveSelectionBy: delta.	i2 := view selectionIndex.	i2 ~~ i1 ifTrue: [self selectItemAt: view selectionIndex]</body><body>selectAndClose	view editorController isMenuButton		ifTrue: [view editorController dispatchMenuSelectionAt: view selectionIndex].	view selectionChannel value: view selectionIndex.	self close</body><body>selectItemAt: anIndex 	view selectionIndex: anIndex.	view editorController dispatchMenuSelectionAt: anIndex.</body><body>selectUpAt: aPoint 	outside		ifTrue: [self cancelAndClose]		ifFalse: [self selectAndClose]</body></methods><methods><class-id>Aragon.Win95ComboBoxListController</class-id> <category>event driven</category><body>mouseMovedEvent: anEvent 	outside := false.	anEvent redButtonPressed		ifTrue: [self selectionTracker redButtonPressedEvent: anEvent]		ifFalse: [self mouseMovedTo: (self sensor mousePointFor: anEvent)]</body></methods><methods><class-id>Aragon.Win95ComboBoxListController</class-id> <category>menu button interface</category><body>matchedIndex: index	super matchedIndex: index.	view editorController dispatchMenuSelectionAt: index.</body></methods><methods><class-id>Aragon.AcceleratedLabel</class-id> <category>accessing</category><body>acceleratorKey	^acceleratorKey</body><body>acceleratorKey: aValue	acceleratorKey := aValue</body></methods><methods><class-id>Aragon.AcceleratedLabel class</class-id> <category>instance creation</category><body>with: aTextOrString 	^self with: aTextOrString attributes: nil</body><body>with: aTextOrString attributes: aTextAttributes 	^self with: aTextOrString attributes: aTextAttributes offset: nil</body><body>with: aTextOrString attributes: aTextAttributes offset: aPoint	| s i t |	s := aTextOrString.	((i := s indexOf: $&amp;) &lt;= 0 or: [i = s size]) ifTrue: [^Label with: aTextOrString attributes: aTextAttributes offset: aPoint].	t := (s copyFrom: 1 to: i-1), (s copyFrom: i+1 to: s size).	s := (s isKindOf: Text)		ifTrue: [Text string: t asString runs: (s runs copyFrom: 1 to: i - 1), (s runs copyFrom: i + 1 to: s size)]		ifFalse: [t asText].	(t at: i) == $&amp; ifTrue: [^Label with: s attributes: aTextAttributes offset: aPoint].	s		addEmphasis: #(#underline)		removeEmphasis: #()		allowDuplicates: false		from: i		to: i.	^(self new) 		text: s;		attributes: aTextAttributes;		offset: aPoint;		acceleratorKey: (s at: i) asUppercase;	yourself</body><body>with: aTextOrString offset: aPoint	^self with: aTextOrString attributes: nil offset: aPoint</body></methods><methods><class-id>Aragon.NSWidgetPolicy</class-id> <category>button creation</category><body>switchFor: button 	"Answer an appropriate Check button view for a generic button."	^(NSCheckButtonView model: button model)		labelString: button label</body><body>toggleFor: button	"Answer an appropriate Radio button view for a generic button."	^(NSRadioButtonView model: button model) labelString: button label</body><body>triggerFor: button	"Answer an appropriate Action button view class for a generic button."	| view |	view := (NSActionButtonView model: button model) labelString: button label.	view canDefault: true.	button isDefault		ifTrue: [view beDefault].	^view</body></methods><methods><class-id>Aragon.NSWidgetPolicy</class-id> <category>menus</category><body>menuViewForMenu: aMenuItemList	"Answer an appropriate MenuView for displaying the given MenuItemList."	^NSMenuView model: aMenuItemList</body></methods><methods><class-id>Aragon.NSWidgetPolicy</class-id> <category>accessing</category><body>lookPolicyClass	^NSLookPolicy</body></methods><methods><class-id>Aragon.NSWidgetPolicy class</class-id> <category>class initialization</category><body>initialize	"This is necessary to initialize the class's instance variable defaultWidgetColors!!!"	"self initialize."	self initializeDefaultWidgetColors</body></methods><methods><class-id>Aragon.NSWidgetPolicy class</class-id> <category>displaying widgets</category><body>displayVisual: aVisual on: aGraphicsContext at: aPoint for: aWidget	| v |	v := aVisual.	aWidget isEnabled		ifFalse: 			[(v isKindOf: OpaqueImage) ifTrue: [v := v shape].			aGraphicsContext paint: aWidget hiliteColor.			v displayOn: aGraphicsContext at: aPoint + 1].	aGraphicsContext paint: aWidget foregroundColor.	v displayOn: aGraphicsContext at: aPoint</body></methods><methods><class-id>Aragon.NSWidgetPolicy class</class-id> <category>accessing</category><body>lookCode	^4</body></methods><methods><class-id>Aragon.NSWidgetPolicy class</class-id> <category>private-initializing</category><body>initializeDefaultButtonColors	self allPreferencesDo:		[:preferences |		preferences			matchAt: SymbolicPaint checkBoxSelectionForeground		put: ColorValue darkRed;			matchAt: SymbolicPaint buttonForeground					put: ColorValue black;			matchAt: SymbolicPaint buttonBackground					put: (ColorValue brightness: 12/15);			matchAt: SymbolicPaint buttonShadow						put: (ColorValue brightness: 7/15);			matchAt: SymbolicPaint buttonSelectionForeground			put: (SymbolicPaint foreground);			matchAt: SymbolicPaint buttonSelectionBackground			put: (ColorValue white);			matchAt: SymbolicPaint buttonInactiveBackground			put: (ColorValue brightness: 12/15);			matchAt: SymbolicPaint buttonInactiveForeground			put: ColorValue gray;			matchAt: SymbolicPaint menuButtonSelectionBackground	put: ColorValue white;			matchAt: SymbolicPaint scrollerButtonForeground			put: ColorValue black;			matchAt: SymbolicPaint scrollerButtonBackground			put: (ColorValue brightness: 4/5);			matchAt: SymbolicPaint scrollerButtonSelectionBackground	put: ColorValue white;			matchAt: SymbolicPaint scrollerButtonInactiveForeground	put: ColorValue gray]</body><body>initializeDefaultGenericColors	self allPreferencesDo:		[:preferences |		preferences			matchAt: SymbolicPaint border put: ColorValue black;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: (ColorValue brightness: 4/5);			matchAt: SymbolicPaint selectionForeground put: ColorValue white;			matchAt: SymbolicPaint selectionBackground put: ColorValue navy;			matchAt: SymbolicPaint hilite put: ColorValue white;			matchAt: SymbolicPaint shadow put: (ColorValue brightness: 7/15);			matchAt: SymbolicPaint separator put: (ColorValue brightness: 7/15);			matchAt: SymbolicPaint inactiveBackground put: (ColorValue brightness: 4/5);			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: NSLookPolicy traversalHilitePattern].	self defaultColorWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue navy</body><body>initializeDefaultMenuColors	self allPreferencesDo:		[:preferences |		preferences			matchAt: SymbolicPaint menuSelectionForeground put: ColorValue white;			matchAt: SymbolicPaint menuSelectionBackground put: ColorValue navy;			matchAt: SymbolicPaint menuForeground put: (ColorValue black);			matchAt: SymbolicPaint menuBackground put: (ColorValue brightness: 4/5);			matchAt: SymbolicPaint menuHilite put: (ColorValue white);			matchAt: SymbolicPaint menuShadow put: (ColorValue gray)]</body><body>initializeDefaultScrollbarColors	self allPreferencesDo:		[:preferences |		preferences			matchAt: SymbolicPaint scrollbarForeground put: (ColorValue brightness: 4/5);			matchAt: SymbolicPaint scrollbarBackground put: (ColorValue brightness: 3/4);			matchAt: SymbolicPaint markerBackground put: (ColorValue brightness: 4/5)]</body><body>installCalculatedPaintPreferencesFrom: aGraphicsDevice on: aColorPreferencesDictionary 	| windowColor threeDObjectColor cp |	windowColor := aColorPreferencesDictionary matchAt: SymbolicPaint inactiveBackground ifAbsent: [].	windowColor notNil ifTrue: [aColorPreferencesDictionary matchAt: SymbolicPaint textBackground put: windowColor].	threeDObjectColor := aColorPreferencesDictionary matchAt: SymbolicPaint pushButtonBackground ifAbsent: [].	threeDObjectColor notNil		ifTrue: 			[aColorPreferencesDictionary matchAt: SymbolicPaint background put: threeDObjectColor.			aColorPreferencesDictionary matchAt: SymbolicPaint inactiveBackground put: threeDObjectColor].	(cp := aColorPreferencesDictionary)		matchAt: SymbolicPaint pushButtonSelectionBackground		put: ColorValue white;		matchAt: SymbolicPaint menuButtonSelectionBackground	put: ColorValue white;		matchAt: SymbolicPaint pushButtonSelectionForeground		put: (cp matchAt: SymbolicPaint foreground);		matchAt: SymbolicPaint checkBoxBackground				put: (cp matchAt: SymbolicPaint background);		matchAt: SymbolicPaint checkBoxSelectionForeground		put: ColorValue darkRed;	yourself.	(cp matchAt: SymbolicPaint scrollbarBackground) = (cp matchAt: SymbolicPaint markerBackground) 		ifTrue: [cp matchAt: SymbolicPaint scrollbarBackground put: (cp matchAt: SymbolicPaint hilite)].</body></methods><methods><class-id>Aragon.Win95WidgetPolicy</class-id> <category>accessing</category><body>lookPolicyClass	^Win95LookPolicy</body></methods><methods><class-id>Aragon.Win95WidgetPolicy</class-id> <category>button creation</category><body>switchFor: button 	"Answer an appropriate Check button view for a generic button."	^(Win95CheckButtonView model: button model)		labelString: button label</body><body>toggleFor: button	^(Win95RadioButtonView model: button model) labelString: button label</body><body>triggerFor: button	"Answer an appropriate Action button view class for a generic button."	| view |	view := (Win95ActionButtonView model: button model) labelString: button label.	view canDefault: true.	button isDefault		ifTrue: [view beDefault].	^view</body></methods><methods><class-id>Aragon.Win95WidgetPolicy</class-id> <category>enhanced - Aragon Look Policies</category><body>borderDecoratorClass	^Win95BorderDecorator</body></methods><methods><class-id>Aragon.Win95WidgetPolicy class</class-id> <category>class initialization</category><body>initialize	"This is necessary to initialize the class's instance variable defaultWidgetColors!!!"	"self initialize."	self initializeDefaultWidgetColors</body></methods><methods><class-id>Aragon.Win95WidgetPolicy class</class-id> <category>private-initializing</category><body>initializeDefaultButtonColors	self allPreferencesDo:		[:preferences |		preferences			matchAt: SymbolicPaint checkBoxSelectionForeground		put: ColorValue black;			matchAt: SymbolicPaint buttonForeground					put: ColorValue black;			matchAt: SymbolicPaint buttonBackground					put: (ColorValue brightness: 12/15);			matchAt: SymbolicPaint buttonSelectionForeground			put: (SymbolicPaint foreground);			matchAt: SymbolicPaint buttonSelectionBackground			put: (ColorValue white);			matchAt: SymbolicPaint buttonInactiveBackground			put: (ColorValue brightness: 12/15);			matchAt: SymbolicPaint buttonInactiveForeground			put: ColorValue gray;			matchAt: SymbolicPaint scrollerButtonForeground			put: ColorValue black;			matchAt: SymbolicPaint scrollerButtonBackground			put: (ColorValue brightness: 4/5);			matchAt: SymbolicPaint scrollerButtonSelectionBackground	put: ColorValue white;			matchAt: SymbolicPaint scrollerButtonInactiveForeground	put: ColorValue gray]</body><body>initializeDefaultScrollbarColors	self allPreferencesDo:		[:preferences |		preferences matchAt: SymbolicPaint scrollbarBackground put: (ColorValue brightness: 8/9)]</body><body>installCalculatedPaintPreferencesFrom: aGraphicsDevice on: aColorPreferencesDictionary 	| cp |	cp := aColorPreferencesDictionary.	(cp matchAt: SymbolicPaint scrollbarBackground) = (cp matchAt: SymbolicPaint markerBackground) 		ifTrue: [cp matchAt: SymbolicPaint scrollbarBackground put: (cp matchAt: SymbolicPaint hilite)].	super installCalculatedPaintPreferencesFrom: aGraphicsDevice on: aColorPreferencesDictionary.	cp := aColorPreferencesDictionary		matchAt: SymbolicPaint pushButtonSelectionBackground	 	put: (cp matchAt: SymbolicPaint background);		matchAt: SymbolicPaint checkBoxBackground				put: (cp matchAt: SymbolicPaint textBackground);		matchAt: SymbolicPaint checkBoxSelectionForeground		put: ColorValue black;		matchAt: SymbolicPaint radioButtonSelectionForeground		put: ColorValue black;	yourself.</body></methods><methods><class-id>Aragon.NSLabelController</class-id> <category>keyboard</category><body>processShortcutKeyEvent: anEvent 	| al |	al := Aragon at: #AcceleratedLabel ifAbsent: [^false].	((view label isKindOf: al)		and: [view label acceleratorKey == anEvent keyValue asUppercase])		ifTrue: 			[keyboardProcessor setActive: self; nextField.			^true].	^false</body></methods><methods><class-id>Aragon.NSGroupBox</class-id> <category>visual properties</category><body>hiliteColor	"Answer the receiver's hilite color (for the highlighted border of a raised or etched region)."		^SymbolicPaint pushButtonHilite</body></methods><methods><class-id>Aragon.NSGroupBox</class-id> <category>accessing</category><body>labelString: aString	self label: (self makeTextLabelFor: aString asText)</body></methods><methods><class-id>Aragon.NSGroupBox</class-id> <category>private</category><body>border	^border == nil		ifTrue: [EtchedBorder new]		ifFalse: [border]</body><body>displayLabelOn: aGraphicsContext 	| box |	label == nil		ifFalse: 			[box := 6 @ 1 extent: label preferredBounds extent + (4 @ 0).			aGraphicsContext paint: self backgroundColor.			aGraphicsContext displayRectangle: box.			NSWidgetPolicy				displayVisual: label				on: aGraphicsContext				at: 8 @ 1				for: self]</body><body>setLabelString: aString	label :=  self makeTextLabelFor: aString asText</body></methods><methods><class-id>Aragon.Win95ComboBoxListView</class-id> <category>controller accessing</category><body>defaultControllerClass	"Answer a default controller class for the receiver."	^Win95ComboBoxListController</body></methods><methods><class-id>Aragon.Win95ComboBoxListView</class-id> <category>private</category><body>toggleOnMove	^NSSequenceView toggleOnMove</body><body>useSelectionIndex: anIndex	"Prevent the selection channel from being updated."	self makeVisible: anIndex.	self selectionIndex: anIndex.	self fixScrollingOffset.	self controller sensor window checkForEvents.</body></methods><methods><class-id>Aragon.NewNotifier</class-id> <category>binding</category><body>icon	^builder visualAt: #icon</body><body>icon: aSymbolOrVisual	builder visualAt: #icon put: (self visualFor: aSymbolOrVisual)</body><body>labelFor: aKey 	| label |	(label := super labelFor: aKey) notNil ifTrue: [^label].	^TitleStrings at: aKey ifAbsent: ['']</body><body>message	^builder visualAt: #message</body><body>message: aText 	| composedText |	(aText isKindOf: ComposedText)		ifTrue: [composedText := aText]		ifFalse: 			[| style |			(Aragon includesKey: #TextStyle)				ifTrue: [style := (Aragon at: #TextStyle) named: #'Notifier.Message'].			style isNil ifTrue: [style := TextAttributes styleNamed: #'Notifier.Message' ifAbsent: [TextAttributes default]].			composedText := ComposedText withText: aText asText style: style].	builder visualAt: #message put: composedText</body><body>subtitle	^builder labelAt: #subtitle</body><body>subtitle: aString	builder labelAt: #subtitle put: aString</body><body>title	^builder labelAt: #title</body><body>title: aString	builder labelAt: #title put: aString</body><body>visualFor: aKey 	| visual |	(visual := super visualFor: aKey) notNil ifTrue: [^visual].	(parentView notNil and: [(visual := parentView topComponent model visualFor: aKey) notNil]) ifTrue: [^visual].	^ComposedText new</body></methods><methods><class-id>Aragon.NewNotifier</class-id> <category>private</category><body>addMinWidthFor: aComponent 	aComponent == nil ifTrue: [^self].	self minWidth: builder window displayBox width + (self minWidthFor: aComponent)</body><body>getSpec	| answer |	answer := #panel0Spec.	(builder labelAt: #title) notNil ifTrue: [answer := #panel1Spec].	(builder visualAt: #icon) notNil 		ifTrue: [(builder labelAt: #subtitle) notNil				ifTrue: [answer := #panel4Spec]				ifFalse: [answer := #panel2Spec]]		ifFalse: [(builder labelAt: #subtitle) notNil ifTrue: [answer := #panel3Spec]].	^self class interfaceSpecFor: answer</body><body>minWidthFor: aComponent 	^aComponent ~~ nil ifTrue: [aComponent bounds width + aComponent bounds asLayout leftOffset + 24]</body><body>prepareBindingsFor: aVisualOrNil mode: mode 	self parentView: (aVisualOrNil isNil			ifTrue: [Dialog defaultParentWindow]			ifFalse: [aVisualOrNil]).	parentView notNil		ifTrue: 			[(builder visuals includesKey: #icon) ifFalse: [self prepareIconWithMode: mode].			(builder labels includesKey: #title) ifFalse: [self prepareTitleWithMode: mode]]</body><body>prepareIconWithMode: mode 	| t |	t := parentView topComponent model class.	((t respondsTo: #defaultIcon) and: [(t := t defaultIcon) notNil])		ifTrue: [self builder visualAt: #icon put: t]</body><body>prepareSubTitleWithMode: mode 	(mode notNil and: [(builder labels includesKey: #subtitle) not])		ifTrue: [self subtitle: (TitleStrings at: mode)]</body><body>prepareTitleWithMode: mode 	| t |	t := parentView topComponent model class.	((t respondsTo: #applicationName) and: [(t := t applicationName) notNil])		ifTrue: 			[self title: t.			self prepareSubTitleWithMode: mode]		ifFalse: [mode notNil ifTrue: [self title: (TitleStrings at: mode)]]</body><body>setMinWidthFor: aComponent 	aComponent == nil ifTrue: [^self].	self minWidth: (self minWidthFor: aComponent)</body></methods><methods><class-id>Aragon.NewNotifier</class-id> <category>utility</category><body>choose: messageString labels: labels values: values default: defaultValue equalize: eqBoolean for: aVisualOrNil 	^self		choose: messageString		labels: labels		values: values		default: defaultValue		equalize: eqBoolean		for: aVisualOrNil		mode: #notify</body><body>confirm: aString	^self confirm: aString for: nil</body><body>confirm: aString default: theDefault 	^self confirm: aString default: theDefault for: nil</body><body>confirm: aString default: theDefault for: aParentView 	^self 		choose: aString		labels: (ButtonLabels at: #confirm)		values: #(true false)		default: theDefault		equalize: true		for: aParentView		mode: #confirm</body><body>confirm: aString for: aParentView	^self confirm: aString default: true for: aParentView</body><body>confirmOrCancel: aString	^self confirmOrCancel: aString for: nil</body><body>confirmOrCancel: aString default: theDefault 	^self confirmOrCancel: aString default: theDefault for: nil</body><body>confirmOrCancel: aString default: theDefault for: aParentView 	^self 		choose: aString		labels: (ButtonLabels at: #confirm), (ButtonLabels at: #cancel)		values: #(true false nil)		default: theDefault		equalize: true		for: aParentView		mode: #confirm</body><body>confirmOrCancel: aString for: aParentView	^self confirmOrCancel: aString default: true for: aParentView</body><body>notify: aString 	^self notify: aString for: nil</body><body>notify: aString default: theDefault	^self notify: aString default: theDefault for: nil</body><body>notify: aString default: theDefault for: aParentView 	^self		choose: aString		labels: (ButtonLabels at: #notify)		values: #(#ok nil)		default: theDefault 		equalize: true		for: aParentView		mode: #notify</body><body>notify: aString for: aParentView 	^self notify: aString default: #ok for: aParentView</body><body>warn: aString 	^self warn: aString for: nil</body><body>warn: aString for: aParentView 	^self		choose: aString		labels: (ButtonLabels at: #warn)		values: #(#ok)		default: #ok		equalize: true		for: aParentView		mode: #warn</body></methods><methods><class-id>Aragon.NewNotifier class</class-id> <category>class initialization</category><body>beDefaultNotifier	DialogSupplier := self</body><body>default 	^DialogSupplier new</body><body>hookUp	self beDefaultNotifier</body><body>initialize	"self initialize"	DialogSupplier := SimpleDialog.	self initializeTitleStrings: (IdentityDictionary new		at: #confirm		put: 'Please confirm';		at: #warn		put: 'Warning';		at: #notify		put: 'Please note';		at: #title			put: 'Please note';		at: #subtitle		put: 'Unknown context';	yourself).	self initializeButtonLabels: (IdentityDictionary new		at: #confirm		put: #('&amp;Yes' '&amp;No');		at: #warn		put: #('&amp;OK');		at: #notify		put: #('&amp;OK');		at: #cancel		put: #('&amp;Cancel');	yourself).	TextAttributes styleNamed: #Title put: (TextAttributes styleNamed: #large).</body><body>initializeButtonLabels: aDictionary	ButtonLabels := aDictionary</body><body>initializeTitleStrings: aDictionary		TitleStrings := aDictionary</body><body>isHookedUp	^DialogSupplier == self</body><body>obsolete 	self uninstall</body><body>restoreStandardNotifier	DialogSupplier := SimpleDialog</body><body>unhook	self restoreStandardNotifier</body><body>uninstall	self restoreStandardNotifier</body></methods><methods><class-id>Aragon.NewNotifier class</class-id> <category>tunneling</category><body>doesNotUnderstand: aMessage 	^(self includesSelector: aMessage selector)		ifTrue: [self notifierClass new perform: aMessage selector withArguments: aMessage arguments]		ifFalse: [super doesNotUnderstand: aMessage]</body><body>notifierClass	^DialogSupplier</body></methods><methods><class-id>Aragon.NSNotifier</class-id> <category>interface construction</category><body>addLabels: labels values: values default: defaultValue storeInto: result takeKeyboard: takeKeyboard equalize: eqBoolean columns: nColumns 	| num wmax hmax separation wrappers actualColumns buttonSpec layout |	buttonSpec := (self class interfaceSpecFor: #buttonSpec) component collection first.	layout := buttonSpec layout.	wmax := layout rightOffset - layout leftOffset.	num := labels size.	hmax := 0.	separation := 7.	wrappers := OrderedCollection new.	actualColumns := nColumns min: labels size.	"We have to create and place the buttons before we can ask them their 	preferred bounds and refine their spacing."		1 to: num		do: 			[:index | 			| val wrapper bExt |			val := values at: index.			builder add: (buttonSpec					model: (result == nil ifTrue: [val] ifFalse: [[result value: val. self close]]);					label: (labels at: index);					isDefault: val == defaultValue).			wrapper := builder wrapper.			(takeKeyboard and: [val == defaultValue])				ifTrue: [builder keyboardProcessor setActive: wrapper widget controller].			wmax := wmax max: (bExt := wrapper preferredBounds extent) x.			hmax := hmax max: bExt y.			wrappers add: wrapper -&gt; bExt].	wrappers		reverseDo:			[:each | 			| width |			width := eqBoolean ifTrue: [wmax] ifFalse: [each value x].			layout leftOffset: layout rightOffset - width.			each key layout: layout copy.			layout rightOffset: layout rightOffset - width - separation].	self addGap: hmax * ("Actual rows:" num + actualColumns - 1 // actualColumns).	self minWidth: 20 + (eqBoolean				ifTrue: [actualColumns * wmax + (actualColumns - 1 * separation)]				ifFalse: [wrappers inject: separation negated into: [:x :assoc | x + assoc value x + separation]]).	^builder wrapper</body><body>addMessage: messageString centered: center 	| label text |	label := builder componentAt: #message.	label isNil ifTrue: [^super addMessage: messageString centered: center].	label := label widget.	text := ComposedText		withText: messageString		style: (label textStyle alignment: (center ifTrue: [2] ifFalse: [0])).	label label: text.	self addGap: text bounds height - 36.	self minWidth: text bounds width + 60.	^builder wrapper</body><body>choose: messageString labels: labels values: values default: defaultValue equalize: eqBoolean for: aVisualOrNil mode: mode	"Ask the user a question.  Let the user pick from a row of buttons made up	to match the labels collection.  Return the response from the corresponding	item from the values collection."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow.  It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	| result spec box |	self prepareBindingsFor: aVisualOrNil mode: mode.	self escapeIsCancel: ((values includes: nil) or: [values includes: #cancel]).	result := ValueHolder new.	spec := self getSpec.	self initializeBuilderFor: parentView."	(builder policy class == NSLookPolicy) ifFalse: [builder policy: NSLookPolicy new]."	builder source: self.	builder add: spec window.	builder add: spec component.	self initializeWindowFor: parentView.	box := builder window displayBox.	box width: 0.	builder window displayBox: box.	self addMessage: messageString centered: false.	self addLabels: labels		values: values		default: defaultValue		storeInto: result		takeKeyboard: true		equalize: eqBoolean.	self setMinWidthFor: (builder componentAt: #title).	self setMinWidthFor: (builder componentAt: #icon).	self setMinWidthFor: (builder componentAt: #subtitle).	self preOpen.	builder window maximumSize: builder window displayBox extent.	builder window minimumSize: builder window displayBox extent.	builder openDialogWithExtent: builder window displayBox extent.	^result value</body></methods><methods><class-id>Aragon.NSNotifier class</class-id> <category>examples</category><body>open 	self new notify: 'This is an example for a &lt;c:blue&gt;&lt;b&gt;Nextstep&lt;/b&gt;&lt;/c&gt; notifier' asRichText</body></methods><methods><class-id>Aragon.Win95Notifier</class-id> <category>interface construction</category><body>addLabels: labels values: values default: defaultValue storeInto: result takeKeyboard: takeKeyboard equalize: eqBoolean columns: nColumns	| num maxButtonWidth maxButtonHeight separation buttonWAs buttonWidth window box layout left top actualColumns actualRows |	self addGap: 4.	num := labels size.	maxButtonWidth := 0.	maxButtonHeight := 0.	separation := 7.	buttonWAs := OrderedCollection new.	window := builder window.	box := window displayBox.	actualColumns := nColumns min: labels size.	actualRows := num + actualColumns - 1 // actualColumns.	"We have to create and place the buttons before we can ask them their	preferred bounds and refine their spacing."	layout := LayoutFrame new.	layout leftFraction: 0.5; rightFraction: 0.5.	builder newComposite.	1 to: num do:		[:index |		| lbl val buttonSpec buttonW bExt |		lbl := labels at: index.		val := values at: index.		(buttonSpec :=			ActionButtonSpec				model: (result == nil						ifTrue: [val]						ifFalse: [[result value: val. self close]])				label: lbl				layout: (0@0 extent: 1@1))			defaultable: (values includes: defaultValue);			isDefault: val == defaultValue.		builder add: buttonSpec.		buttonW := builder wrapper.		(takeKeyboard and: [val == defaultValue])			ifTrue: [builder keyboardProcessor setActive: buttonW widget controller].		maxButtonWidth := maxButtonWidth max: (bExt := buttonW preferredBounds extent) x.		maxButtonHeight := maxButtonHeight max: bExt y.		buttonWAs add: buttonW -&gt; bExt]. 	buttonWidth := eqBoolean		ifTrue: [actualColumns * maxButtonWidth + ((actualColumns - 1) * separation)]		ifFalse: [buttonWAs				inject: separation negated				into: [:x :assoc | x + assoc value x + separation]].	layout topOffset: box height; bottomOffset: box height+(actualRows * maxButtonHeight).	layout		leftOffset: 0 - ((buttonWidth + 1) // 2);		rightOffset: (buttonWidth + 1) // 2.	builder endCompositeLayout: layout.	left := 0.	top := 0.	1 to: num do:		[:index |		| bttnWA width |		bttnWA := buttonWAs at: index.		width := eqBoolean				ifTrue: [maxButtonWidth]				ifFalse: [bttnWA value x].		bttnWA key newLayout:			(Rectangle				left: left				right: left + width				top: top				bottom: top + maxButtonHeight).		index \\ actualColumns = 0			ifTrue:				[left := 0.				top := top + maxButtonHeight]			ifFalse: [left := left + width + separation]].	self addGap: maxButtonHeight * actualRows + 4.	self minWidth: buttonWidth + 24.	^builder wrapper</body><body>addTitle: aString		builder window label: aString</body><body>choose: messageString labels: labels values: values default: defaultValue equalize: eqBoolean for: aVisualOrNil mode: mode	"Ask the user a question.  Let the user pick from a row of buttons made up	to match the labels collection.  Return the response from the corresponding	item from the values collection."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow.  It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	| result inset offset extent title icon message |	inset := 12@12 corner: 24@12.	offset := inset origin copy.	extent := 0@0.	self prepareBindingsFor: aVisualOrNil mode: mode.	self escapeIsCancel: ((values includes: nil) or: [values includes: #cancel]).	self message: messageString.	self initializeBuilderFor: parentView."	(builder policy class == Win95LookPolicy) ifFalse: [builder policy: Win95LookPolicy new]."	builder source: self.	builder add: WindowSpec new.	self initializeWindowFor: parentView.	(title := self title) notNil ifTrue: [builder window label: title].	(icon := self icon) notNil		ifTrue:			[builder add: (LabelSpec new				label: #icon;				layout: offset copy;				hasCharacterOrientedLabel: false).			offset x: offset x + icon bounds width + 20.			extent := icon bounds extent + (20@0)].	(message := self message) notNil		ifTrue:			[message bounds height &lt; icon bounds height 				ifTrue: [offset y: offset y + (icon bounds height - message bounds height // 2)].			builder add: (LabelSpec new				label: #message;				layout: offset copy;				style: #'Notifier.Message';				hasCharacterOrientedLabel: false).			extent x: extent x + message bounds width.			extent y: (extent y max: message bounds height)]."	self addMessage: messageString centered: false."	result := ValueHolder new.	extent := extent + inset origin + inset corner.	builder window displayBox: (0@0 extent: extent).	self addLabels: labels		values: values		default: defaultValue		storeInto: result		takeKeyboard: true		equalize: eqBoolean.	self preOpen.	builder openDialog.	^result value</body></methods><methods><class-id>Aragon.Win95Notifier</class-id> <category>private</category><body>prepareIconWithMode: mode 	mode == #notify ifTrue: [^self icon: #information].	mode == #warn ifTrue: [^self icon: #warning].	mode == #confirm ifTrue: [^self icon: #question].	super prepareIconWithMode: mode.</body><body>visualFor: aSymbolOrNil	^Icons at: aSymbolOrNil ifAbsent: [super visualFor: aSymbolOrNil]</body></methods><methods><class-id>Aragon.Win95Notifier class</class-id> <category>class initialization</category><body>initialize	"self initialize"	Icons := IdentityDictionary new		add: #information -&gt; (OpaqueImage figure: self informationImage shape: self informationShape);		add: #question -&gt; (OpaqueImage figure: self questionImage shape: self questionShape);		add: #stop -&gt; (OpaqueImage figure: self stopImage shape: self stopShape);		add: #warning -&gt; (OpaqueImage figure: self warningImage shape: self warningShape);	yourself.	Icons		add: #hand -&gt; (Icons at: #stop);		add: #error -&gt; (Icons at: #stop);		add: #exclamation -&gt; (Icons at: #warning);		add: #asterisk -&gt; (Icons at: #information);	yourself.</body></methods><methods><class-id>Aragon.Win95Notifier class</class-id> <category>examples</category><body>open 	self new notify: 'This is an example for a &lt;c:red&gt;&lt;b&gt;Win95&lt;/b&gt;&lt;/c&gt; notifier' asRichText</body></methods><methods><class-id>Aragon.Win95SliderSpec</class-id> <category>accessing</category><body>hasTickMarks	^hasTickMarks == true</body><body>hasTickMarks: aBoolean	hasTickMarks := aBoolean == true ifTrue: [aBoolean].</body><body>pointTo	^pointTo == nil		ifTrue: [Win95SliderView defaultPoints at: (orientation == #vertical ifTrue: [2] ifFalse: [1])]		ifFalse: [pointTo]</body><body>pointTo: aValue 	pointTo := aValue == (Win95SliderView defaultPoints at: (orientation == #vertical						ifTrue: [2]						ifFalse: [1])) ifFalse: [aValue].</body></methods><methods><class-id>Aragon.Win95SliderSpec</class-id> <category>building</category><body>dispatchTo: policy with: builder 	super dispatchTo: policy with: builder.	(policy isKindOf: Win95LookPolicy) ifFalse: [^self].	builder component hasTickMarks: self hasTickMarks.	builder component pointTo: self pointTo.</body></methods><methods><class-id>Aragon.Win95SliderSpec class</class-id> <category>class initialization</category><body>initialize	self installOnPalette</body><body>shouldBeOnPalette	^true</body></methods><methods><class-id>Aragon.Win95SliderSpec class</class-id> <category>private-interface building</category><body>addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #hasTickMarks put: (self adapt: inst forAspect: #hasTickMarks channel: aChannel).	env at: #pointTo put: (self adapt: inst forAspect: #pointTo channel: aChannel).</body><body>componentName	"Identification of component"	^'Win95 Slider'</body><body>specGenerationBlock	^[:ctrlr :point | 		Win95SliderSpec			model: nil			layout: ((ctrlr gridPoint: point)				extent: (ctrlr currentMode value class placementExtentFor: SliderSpec inBuilder: ctrlr builder))			properties: (Array with: #horizontal )]</body></methods><methods><class-id>Aragon.Win95SliderSpec class</class-id> <category>resources</category><body>paletteIconImage	"Answer an image to reperesent spec on the palette"	paletteIcon isNil ifTrue: [paletteIcon := Array with: (OpaqueImage figure: (CachedImage on: self paletteImage)						shape: (CachedImage on: self paletteMonoIcon))					with: (CachedImage on: self paletteMonoIcon)].	^paletteIcon at: (Screen default colorDepth == 1			ifTrue: [2]			ifFalse: [1])</body></methods><methods><class-id>Aragon.NSBorderDecorationPolicy</class-id> <category>initialize-release</category><body>initialize	"Initialize the receiver with the default values."	super initialize.	border := NSBorder inset.	scrollbarThickness :=  self lookPolicy scrollbarThickness.	markerThickness := (NSBorder inset insetDisplayBoxFor: (0@0 extent: scrollbarThickness@0)) width.	scrollButtonThickness := markerThickness.	minMarkerExtent := markerThickness // 2 * 3.	menuBarHeight := 0</body><body>lookPolicy	^NSLookPolicy</body></methods><methods><class-id>Aragon.NSBorderDecorationPolicy</class-id> <category>private - layout</category><body>horizontalScrollBarFor: aScrollWrapper 	| composite offset |	composite := CompositePart new.	offset := scrollbarThickness negated.	composite add: (NSScrollBar model: aScrollWrapper) beHorizontal		in: ((LayoutFrame new) 			bottomFraction: 1;			rightFraction: 1 offset: 2*offset).	composite add: (NSScrollerButton new: #left for: aScrollWrapper)		in: ((LayoutFrame new)			bottomFraction: 1;			leftFraction: 1 offset: 2*offset;			rightFraction: 1 offset: offset).	composite add: (NSScrollerButton new: #right for: aScrollWrapper)		in: ((LayoutFrame new)		bottomFraction: 1;		leftFraction: 1 offset: offset;		rightFraction: 1).	^(BorderedWrapper on: composite) inset: 0; border: self border</body><body>verticalScrollBarFor: aScrollWrapper 	| composite offset |	composite := CompositePart new.	offset := scrollbarThickness negated.	composite add: (NSScrollBar model: aScrollWrapper) beVertical		in: ((LayoutFrame new) 			rightFraction: 1;			bottomFraction: 1 offset: 2*offset).	composite add: (NSScrollerButton new: #up for: aScrollWrapper)		in: ((LayoutFrame new)			rightFraction: 1;			topFraction: 1 offset: 2*offset;			bottomFraction: 1 offset: offset).	composite add: (NSScrollerButton new: #down for: aScrollWrapper)		in: ((LayoutFrame new)		rightFraction: 1;		topFraction: 1 offset: offset;		bottomFraction: 1).	^(BorderedWrapper on: composite) inset: 0; border: self border</body></methods><methods><class-id>Aragon.NSBorderDecorationPolicy</class-id> <category>private - regions</category><body>dataRegionFor: aDecorator 	"Answer a layout frame for aDecorator's data area"	"Since there isn't a double border between the edge of the data area and the scroll bars, outside the 	data area corner by 2@2 pixels in order to have that border of the data area appear under the 	corresponding border of the scroll bar."	| vdelta hdelta |	vdelta := hdelta := 0.	aDecorator hasBorder		ifTrue: 			[aDecorator hasHorizontalScrollBar ifTrue: [hdelta := 2].			aDecorator hasVerticalScrollBar ifTrue: [vdelta := 2]].	^(LayoutFrame new) 		leftOffset: (self leftOffsetFor: aDecorator);		rightFraction: 1 offset: (self rightOffsetFor: aDecorator) + vdelta;		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator) + hdelta;		topOffset: (self topOffsetFor: aDecorator)</body><body>horizontalScrollRegionFor: aDecorator	"Answer a layout frame for aDecorator's horizontal scrollbar"	"Outside the right edge by two pixels if there is a vertical scroll bar to correspond to the two pixels outset in dataRegionFor:"	| verticalDelta x |	x := aDecorator hasBorder ifTrue: [0] ifFalse: [2].	verticalDelta := aDecorator hasVerticalScrollBar ifTrue: [scrollbarThickness] ifFalse: [0].	^LayoutFrame new		leftOffset: (self leftOffsetFor: aDecorator) - x;		topFraction: 1 offset: (self bottomOffsetFor: aDecorator);		rightFraction: 1 offset: (self rightOffsetFor: aDecorator) + verticalDelta + x;		bottomFraction: 1</body><body>verticalScrollRegionFor: aDecorator 	"Answer a layout frame for aDecorator's vertical scrollbar"	"Outset the right edge by 2 pixels if there is a horizontal scroll bar to counteract the offsets in 	dataRegionFor:"	| layout horizontalDelta x |	x := aDecorator hasBorder ifTrue: [0] ifFalse: [2].	horizontalDelta := aDecorator hasHorizontalScrollBar ifTrue: [2] ifFalse: [0].	layout := (LayoutFrame new) 		topFraction: 0 offset: (self topOffsetFor: aDecorator) - x; 		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator) + horizontalDelta + x.	verticalScrollBarOnRight		ifTrue: [layout leftFraction: 1 offset: (self rightOffsetFor: aDecorator); rightFraction: 1 offset: 0]		ifFalse: [layout leftFraction: 0 offset: 0; rightFraction: 0 offset: (self leftOffsetFor: aDecorator)].	^layout</body></methods><methods><class-id>Aragon.Win95BorderDecorationPolicy</class-id> <category>initialize-release</category><body>initialize	"Initialize the receiver with the default values."	super initialize.	markerThickness := scrollbarThickness."	markerThickness := (Win95VerticalScrollbarBorder default insetDisplayBoxFor: (0@0 extent: scrollbarThickness@0)) width."</body><body>lookPolicy	^Win95LookPolicy</body></methods><methods><class-id>Aragon.Win95BorderDecorationPolicy</class-id> <category>private - layout</category><body>horizontalScrollBarFor: aScrollWrapper 	| composite |	composite := CompositePart new.	composite add: (Win95ScrollBar model: aScrollWrapper) beHorizontal		in: ((LayoutFrame new) 			bottomFraction: 1;			leftFraction: 0 offset: scrollbarThickness;			rightFraction: 1 offset: scrollbarThickness negated).	composite add: (Win95ScrollerButton new: #left for: aScrollWrapper)		in: ((LayoutFrame new)			bottomFraction: 1;			leftFraction: 0;			rightFraction: 0 offset: scrollbarThickness).	composite add: (Win95ScrollerButton new: #right for: aScrollWrapper)		in: ((LayoutFrame new)		bottomFraction: 1;		leftFraction: 1 offset: scrollbarThickness negated;		rightFraction: 1).	^BoundedWrapper on: composite</body><body>layout: aBorderDecorator 	"This is the public layout protocol, to create a fully populated composite 	from a base component"	(aBorderDecorator isKindOf: TableDecorator) ifTrue: [^super layout: aBorderDecorator].	inset := aBorderDecorator hasBorder ifTrue: [2] ifFalse: [0].	self		add: (BoundedWrapper on: aBorderDecorator scrollerComponent)		to: aBorderDecorator		in: (self dataRegionFor: aBorderDecorator).	aBorderDecorator hasVerticalScrollBar		ifTrue: [self			add: (self verticalScrollBarFor: aBorderDecorator scrollerComponent)			to: aBorderDecorator			in: (self verticalScrollRegionFor: aBorderDecorator)].	aBorderDecorator hasHorizontalScrollBar		ifTrue: [self			add: (self horizontalScrollBarFor: aBorderDecorator scrollerComponent)			to: aBorderDecorator			in: (self horizontalScrollRegionFor: aBorderDecorator)]</body><body>verticalScrollBarFor: aScrollWrapper 	| composite |	composite := CompositePart new.	composite add: (Win95ScrollBar model: aScrollWrapper) beVertical		in: ((LayoutFrame new) 			rightFraction: 1;			topFraction: 0 offset: scrollbarThickness;			bottomFraction: 1 offset: scrollbarThickness negated).	composite add: (Win95ScrollerButton new: #up for: aScrollWrapper)		in: ((LayoutFrame new)			rightFraction: 1;			topFraction: 0;			bottomFraction: 0 offset: scrollbarThickness).	composite add: (Win95ScrollerButton new: #down for: aScrollWrapper)		in: ((LayoutFrame new)			rightFraction: 1;			topFraction: 1 offset: scrollbarThickness negated;			bottomFraction: 1).	^BoundedWrapper on: composite</body></methods><methods><class-id>Aragon.Win95BorderDecorationPolicy</class-id> <category>private - regions</category><body>dataRegionFor: aDecorator	"Answer a layout frame for aDecorator's data area"	^LayoutFrame new		leftOffset: (self leftOffsetFor: aDecorator);		rightFraction: 1 offset: (self rightOffsetFor: aDecorator);		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator);		topOffset: (self topOffsetFor: aDecorator)</body><body>horizontalScrollRegionFor: aDecorator	"Answer a layout frame for aDecorator's horizontal scrollbar"	^LayoutFrame new		leftOffset: (self leftOffsetFor: aDecorator);		topFraction: 1 offset: (self bottomOffsetFor: aDecorator);		rightFraction: 1 offset: (self rightOffsetFor: aDecorator);		bottomFraction: 1</body><body>verticalScrollRegionFor: aDecorator 	"Answer a layout frame for aDecorator's vertical scrollbar"	"Outset the right edge by 2 pixels if there is a horizontal scroll bar to counteract the offsets in 	dataRegionFor:"	| layout |	layout := (LayoutFrame new) 		topFraction: 0 offset: (self topOffsetFor: aDecorator); bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator).	verticalScrollBarOnRight		ifTrue: [layout leftFraction: 1 offset: (self rightOffsetFor: aDecorator); rightFraction: 1 offset: 0]		ifFalse: [layout leftFraction: 0 offset: 0; rightFraction: 0 offset: (self leftOffsetFor: aDecorator)].	^layout</body></methods><methods><class-id>Aragon.NSToolBar</class-id> <category>initialize-release</category><body>initializeSpacing	"Initialize the spacing parameters between sub components."	super initializeSpacing.	extraSpaceTop := 3.</body></methods><methods><class-id>Aragon.NSToolBar</class-id> <category>displaying</category><body>displayOn: aGraphicsContext	| box |	super displayOn: aGraphicsContext.	box := self bounds.	aGraphicsContext paint: self shadowColor; displayLineFrom: box left@0 to: box right@0.	aGraphicsContext paint: self hiliteColor; displayLineFrom: box left@1 to: box right@1.</body></methods><methods><class-id>Aragon.NSToolBar</class-id> <category>private</category><body>newButtonFor: item	"Answer a new MenuBarButtonView for the receiver."	"Subclasses must define the appropriate MenuBarButtonViews for their look/feel."	| button model buttonType |	buttonType := self widgetPolicy lookPolicyClass new toolbarButtonClass.	model := (PluggableAdaptor on: ValueHolder new)					getBlock: [:b | false]					putBlock: [:b :v | (self performer actionFor: item value) value]					updateBlock: [:b :a :p | false].	button := buttonType model: model.	button setLabel: item labelImage.	^button</body></methods><methods><class-id>Aragon.Win95ScrollBar</class-id> <category>private</category><body>displayMarkerOn: aGraphicsContext 	"Display the marker on aGraphicsContext."	| box |	box := self marker.	(model canScrollWith: self)		ifTrue: 			[aGraphicsContext paint: self markerColor; displayRectangle: box.			NSTwoPixelsBorder raised displayOn: aGraphicsContext forDisplayBox: box using: self]</body></methods><methods><class-id>Aragon.NSRadioButtonView</class-id> <category>private</category><body>redisplayButton	"Redisplay the button image part because of a change in it's state."	"Attempts to avoid invalidate if possible."	self invalidateOrRedisplayBy: [:graphContext | self displayButtonOn: graphContext]</body><body>redisplayChangeOfStateFrom: previousState to: currentState 	"Redisplay the receiver because the state of the model has changed from previousState to 	currentState."	isInTransition := false.	self redisplayButton</body><body>redisplayFocusChange	"Redisplay the receiver because there has been a change in whether its has keyboard focus."	self hasFocus		ifTrue: [self redisplayTraveralHilite]		ifFalse: [super redisplayFocusChange]</body><body>redisplayForTransitionChange	"Redisplay the receiver, there has been a transition between being pressed/unpressed."	self redisplayButton</body><body>redisplayTraveralHilite	"Redisplay the traversal hilite part because it's just turned on."	"Attempts to avoid invalidate if possible."	self invalidateOrRedisplayBy: [:graphContext | self displayTraversalHiliteOn: graphContext]</body></methods><methods><class-id>Aragon.NSRadioButtonView</class-id> <category>display box accessing</category><body>preferredBounds	"Answer the rectangle of preferred bounds for the receiver"	| labelExtent |	labelExtent := self label preferredBounds extent.	^Rectangle origin: 0 @ 0		corner: (1 + 16 + 4 + labelExtent x)@ (16 max: labelExtent y) + (2@2)</body></methods><methods><class-id>Aragon.NSRadioButtonView</class-id> <category>displaying</category><body>displayButtonOn: gc 	"Display the button part of the receiver according to the current state of the model."	"This still needs to be cleaned up a bit and probably should have the BeveledBorder stuff unwound."	| pt |	pt := 2 @ (self bounds height - self class dotMask bounds height) // 2.	gc paint: self shadowColor. self class shadowMask displayOn: gc at: pt.	gc paint: self borderColor. self class borderMask displayOn: gc at: pt.	gc paint: self hiliteColor. self class hiliteMask displayOn: gc at: pt.	gc paint: (self isSelected ifTrue: [ColorValue white] ifFalse: [SymbolicPaint background]). 	self class dotMask displayOn: gc at: pt.</body><body>displayLabelOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	NSWidgetPolicy		displayVisual: label		on: aGraphicsContext		at: 21 @ (self bounds height - label preferredBounds height + 1 // 2)		for: self</body><body>displayOn: aGraphicsContext 	"Display the receiver according to the current state of the model."	self displayButtonOn: aGraphicsContext.	self displayLabelOn: aGraphicsContext.	self hasFocus ifTrue: [self displayTraversalHiliteOn: aGraphicsContext].</body><body>displayTraversalHiliteOn: aGraphicsContext	"Display indication that the receiver has keyboard focus."	| labelBox |	labelBox := Rectangle origin: 21@(self bounds height - label preferredBounds height + 1 // 2) extent: label preferredBounds extent.	aGraphicsContext		paint: self traversalHiliteColor;		displayInteriorRectangularBorder: (labelBox expandedBy: 2@1)</body></methods><methods><class-id>Aragon.NSRadioButtonView</class-id> <category>private-visual properties</category><body>disabledColor	^SymbolicPaint background</body><body>transitionColor	^ColorValue white</body></methods><methods><class-id>Aragon.Win95RadioButtonView</class-id> <category>displaying</category><body>displayButtonOn: gc 	"Display the button part of the receiver according to the current state of the model."	"This still needs to be cleaned up a bit and probably should have the BeveledBorder stuff unwound."	| pt |	pt := 2 @ (self bounds height - self class insideMask bounds height) // 2.	gc paint: (self isEnabled 		ifTrue: [self isInTransition ifTrue: [self transitionColor] ifFalse: [self backgroundColor]]		ifFalse: [self disabledColor]).	self class insideMask displayOn: gc at: pt.	gc paint: self shadowColor. self class shadowMask displayOn: gc at: pt.	gc paint: self borderColor. self class borderMask displayOn: gc at: pt.	gc paint: self hiliteColor. self class hiliteMask displayOn: gc at: pt.	self isSelected ifTrue: [gc paint: self selectionForegroundColor. self class dotMask displayOn: gc at: pt].</body></methods><methods><class-id>Aragon.Win95RadioButtonView</class-id> <category>private-visual properties</category><body>transitionColor	^SymbolicPaint background</body></methods><methods><class-id>UI.UILookPolicy class</class-id> <category>private</category><body>feelPolicy	^(UISettings preferenceFor: #feelSelection) == #AutoSelect		ifTrue: [UIBuilder defaultPolicyClass defaultFeelPolicy]		ifFalse: 			[| symbol |			symbol := UISettings preferenceFor: #feelSelection.			(symbol respondsTo: #asQualifiedReference)				ifTrue: [symbol asQualifiedReference value]				ifFalse: [Smalltalk at: symbol]]</body></methods><methods><class-id>Graphics.SymbolicPaint class</class-id> <category>enhanced - Nextstep Look</category><body>textBackground	^Aragon.NSLookPolicy textBackground</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText 	"Answer a visual component for displaying aStringOrText in the appropriate text style. 	DJH: Modified to add support for keyboard shortcuts in action buttons"	^(Aragon at: #AcceleratedLabel ifAbsent: [Label])		with: aStringOrText attributes: self getTextStyle</body></methods><methods><class-id>UI.SimpleComponent</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText 	^super makeTextLabelFor: aStringOrText</body></methods><methods><class-id>UI.UILookPolicy class</class-id> <category>private</category><body>_feelPolicy	^(UISettings preferenceFor: #feelSelection) == #AutoSelect 		ifTrue:[UIFeelPolicy getFeelPolicyForPlatform ]		ifFalse:[Smalltalk at:(UISettings preferenceFor: #feelSelection) ]</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>changedPreferredBounds: oldPreferredBoundsOrNil forComponent: aComponent	self checkForScrollers.	^self formerChangedPreferredBounds: oldPreferredBoundsOrNil forComponent: aComponent.</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>enhanced - text editing</category><body>inspectItKey: aCharEvent	" Inspect the current selection. "	(aCharEvent keyValue isSymbol or: [aCharEvent hasCtrl])		ifFalse: [  " sigh, Tab key gets munched through here also "			self appendToSelection: ( String with: aCharEvent keyCharacter ).			view isOpen ifTrue: [view displaySelection ifTrue: [view selectAndScroll]].			^self ].	self inspectIt.</body></methods><methods><class-id>UI.MotifCheckButtonView</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText	"Answer a visual component for displaying aStringOrText in the appropriate text style."	^super makeTextLabelFor: aStringOrText asText allBold.</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - New Notifier</category><body>warn: messageString	"Present the message string to the user.  Continue processing	when the user hits the 'ok' box or types cr."	"Dialog warn: 'Beware, this is a warning'."	^self warn: messageString for: nil</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>canScrollUp	"Answer if there is still information above the current viewable range."	^self translation y &lt; 0</body></methods><methods><class-id>UI.BasicButtonController</class-id> <category>enhanced - button shortcuts</category><body>processKeyboardEvent: anEvent onCarriageReturn: aBlock	| ev ch |	ev := anEvent.	keyboardHook == nil		ifFalse: [ev := keyboardHook value: ev value: self].	ev == nil ifTrue: [^self].	(keyboardProcessor isBackTab: anEvent)		ifTrue: [^keyboardProcessor prevFieldFrom: self].	ch := ev keyValue.	ch isSymbol ifTrue: [^self].	ch == Character tab  		ifTrue: [keyboardProcessor nextFieldFrom: self].	ch == Character space ifTrue: [^self pressAction].	ch == Character cr  ifTrue: aBlock.	ch == Character esc ifTrue: [^keyboardProcessor doCancelAction].</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>enhanced - Win95 Look Policy</category><body>alignment	^#left</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>enhanced - text editing</category><body>performPasteAction: aString	"Here we perform the default paste action for paragraphs.  Any subclass of us	can choose to override this default in favor of some other paste-like action."	self deselect.	"Pasting has happened so there is a valid selection interval.	This means the beginTypeInIndex should be reset."	self resetTypein.	self replaceSelectionWith: aString.	"Un-comment the following for Windows-faithful paste behaviour."	self selectionStartIndex: self selectionStopIndex.	self selectAndScroll</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>canScrollVertically	^self scrollableExtent y &gt; self visibleExtent y</body></methods><methods><class-id>UI.ApplicationModel class</class-id> <category>enhanced - New Notifier</category><body>applicationName	^self name</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>enhanced - Win95 Look Policy</category><body>getComboListIn: aBuilder	^self getMenuIn: aBuilder</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - New Notifier</category><body>confirm: messageString initialAnswer: aBoolean for: aVisualOrNil 	"Ask the user a question, with a true/false answer. Return the response."	"aVisualOrNil, if not nil, may be either a VisualPart or a 	ScheduledWindow. It controls the look and feel and color choices 	used by the dialog, and supplies the dialog's master window, which 	is used by some window systems to create a visual connection between 	the dialog and the window that created it."	"Dialog confirm: 'Are you tired yet?' initialAnswer: false 	for: ScheduledControllers activeController view. 	Dialog confirm: 'Are you completely sure?' initialAnswer: true 	for: Dialog defaultParentWindow"	^((Aragon includesKey: #NewNotifier) and: [self dialogSupplier isKindOf: (Aragon at: #NewNotifier)])		ifTrue: 			[| answer |			answer := self dialogSupplier confirm: messageString default: aBoolean for: aVisualOrNil.			answer notNil and: [answer]]		ifFalse: [self				choose: messageString				labels: #('yes' 'no')				values: #(true false)				default: aBoolean				for: aVisualOrNil]</body></methods><methods><class-id>UI.LookPreferences class</class-id> <category>enhanced - Win95 Look Policy</category><body>edgeDecorator	"Answer the class of the object that allows Scroll bars and Menu bars."	^WidgetTypePolicy borderDecoratorClass</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - New Notifier</category><body>notify: messageString	"Present the message string to the user.  Continue processing	when the user hits the 'ok' box or types cr."	"Dialog notify: 'Beware, this is a notifying'."	^self notify: messageString for: nil</body></methods><methods><class-id>UI.MotifMenuBarButtonView</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText	"Answer a visual component for displaying aStringOrText in the appropriate text style."	^super makeTextLabelFor: aStringOrText asText allBold.</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>canScrollDown	"Answer if there is still information below the current viewable range."	^self scrollableExtent y + self translation y &gt; self visibleExtent y</body><body>canScrollWith: aScrollBarOrAScrollerButton 	^aScrollBarOrAScrollerButton isVertical		ifTrue: [self canScrollVertically]		ifFalse: [self canScrollHorizontally]</body></methods><methods><class-id>UI.UISpecification</class-id> <category>enhanced - Nextstep Look</category><body>hasTextBackground	^false</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>formerChangedPreferredBounds: oldPreferredBoundsOrNil forComponent: aComponent	"The receiver is notifying any dependents that its preferredBounds has changed."	super changedPreferredBounds: oldPreferredBoundsOrNil forComponent: aComponent.	self updateControls</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>enhanced - Win95 Look Policy</category><body>converterWith: aBuilder	^nil</body></methods><methods><class-id>UI.MotifActionButtonView</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText	"Answer a visual component for displaying aStringOrText in the appropriate text style."	^super makeTextLabelFor: aStringOrText asText allBold.</body></methods><methods><class-id>UI.KeyboardProcessor</class-id> <category>enhanced - button shortcuts</category><body>offerToShortcutsAgain: aKeyboardEvent 	1 to: keyboardConsumers size		do: 			[:i | 			| ctrl |			ctrl := (keyboardConsumers at: i) controller.			(ctrl processShortcutKeyEvent: aKeyboardEvent)				ifTrue: [^self]]</body></methods><methods><class-id>UI.ComboBoxView</class-id> <category>enhanced - Win95 Look Policy</category><body>model	^self menuButton model</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>canScroll	| r1 r2 |	r1 := self scrollableExtent.	r2 := self visibleExtent.	^r1 y &gt; r2 y or: [r1 x &gt; r2 x]</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>enhanced - Win95 Look Policy</category><body>numChars	^nil</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - New Notifier</category><body>confirm: messageString initialAnswer: aBoolean	"Ask the user a question, with a true/false answer. Return the response."	"Dialog confirm: 'Are you tired yet?' initialAnswer: false.	Dialog confirm: 'Are you completely sure?' initialAnswer: true"	^self confirm: messageString initialAnswer: aBoolean for: nil</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>enhanced - text editing</category><body>indentKey: aCharEvent 	"The Tab key was pressed. If the current selection spans at least one whole line the selected lines are 	indented or unindented resp. by one tab."	| start stop index |	(self selection occurrencesOf: CR) &lt; 1 ifTrue: [^self normalCharacterKey: aCharEvent].	start := self selectionStartIndex.	stop := self selectionStopIndex.	start &gt; stop ifTrue: [| t | t := start. start := stop. stop := t].	[start &gt; 1 and: [(self text at: start) ~~ CR]] whileTrue: [start := start - 1].	index := start.	aCharEvent hasShift		ifTrue:			[[index notNil]				whileTrue: 					[(self text at: index+1) == Tab ifTrue: [self replaceFrom: index+1 to: index+1 with: ''. stop := stop-1].					index := self text nextIndexOf: CR from: index+1 to: stop-2]]		ifFalse:			[[index notNil]				whileTrue: 					[self replaceFrom: index+1 to: index with: '	'.					index := self text nextIndexOf: CR from: index+1 to: stop-1.					stop := stop + 1]].	self selectFrom: start+1 to: stop - 1.</body></methods><methods><class-id>UI.ComboBoxSpec</class-id> <category>enhanced - Nextstep Look</category><body>hasTextBackground	^self isOpaque or: [self hasBorder]</body></methods><methods><class-id>UI.MotifRadioButtonView</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText	"Answer a visual component for displaying aStringOrText in the appropriate text style."	^super makeTextLabelFor: aStringOrText asText allBold.</body></methods><methods><class-id>UI.ComboBoxView</class-id> <category>enhanced - Win95 Look Policy</category><body>initializeForLookUp</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>canScrollLeft	"Answer if there is still information to the left of the current viewable range."	^self translation x &lt; 0</body></methods><methods><class-id>UI.UILookPolicy class</class-id> <category>private</category><body>defaultFeelPolicy	^UIFeelPolicy getFeelPolicyForPlatform</body></methods><methods><class-id>UI.TriggerButtonController</class-id> <category>enhanced - button shortcuts</category><body>processKeyboardEvent: anEvent	self 		processKeyboardEvent: anEvent 		onCarriageReturn: [^self pressAction].	"-------------------------------------------------------------------"	"Added for Button Shortcuts support:"	keyboardProcessor offerToShortcutsAgain: anEvent.	"-------------------------------------------------------------------"</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - New Notifier</category><body>notify: messageString for: aVisualOrNil	"Present the message string to the user.  Continue processing	when the user hits the 'ok' box or types cr."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow.  It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	"Dialog notify: 'Beware, this is a notifying'		for: Dialog defaultParentWindow."	^self warn: messageString for: aVisualOrNil</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>enhanced - Win95 Look Policy</category><body>checkForScrollers	"This message is being send to the receiver in 	ScrollWrapper&gt;&gt;changedPreferredBounds:forComponent:. It travels up the view hierarchy up to a 	BorderDecorator. If this is a Win95BorderDecorator it will enable or disable scrollbars appropriately."	container == nil ifFalse: [container checkForScrollers]</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>enhanced - Nextstep Look</category><body>primarySymbolicBackground	"Answer the symbolic paint that represents the primary background color for the 	receiver.  If none, answer nil."	"Subclasses may override this."	^super backgroundColor</body></methods><methods><class-id>UI.BasicButtonController</class-id> <category>enhanced - button shortcuts</category><body>processShortcutKeyEvent: anEvent 	"Attempt to process anEvent as a possible short cut key activation of the receiver. Answer 	whether it was possible to process the event. Subclasses may override this message if they can 	possibly handle such a keyboardEvent as a shortcut key. This message is a privileged message 	sent by a KeyboardProcessor."	| al |	al := Aragon at: #AcceleratedLabel ifAbsent: [^false].	((view label isKindOf: al)		and: [view label acceleratorKey == anEvent keyValue asUppercase])		ifTrue: 			[self simulateMousePress.			^true].	^false</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>enhanced - Nextstep Look</category><body>scrollOffsetHolder: aValueHolder 	scrollOffset := aValueHolder.	scrollOffset grid: [1 @ self displayObject lineGrid].	(LookPreferences widgetPolicy isKindOf: (Aragon at: #NSWidgetPolicy ifAbsent: [nil]))		ifTrue: [^self].		"Set extra space 2 lines shorter than vertical bounds to accomodate a trailing &lt;cr&gt;."	scrollOffset extraSpace: [0 @ 0 corner: 0 @ 		(0 max: (self bounds height - (self lineGrid * 2) truncateTo: self lineGrid))].</body></methods><methods><class-id>UI.ComboBoxView</class-id> <category>enhanced - Win95 Look Policy</category><body>menu: aValueHolder	self menuButton listHolder: aValueHolder.</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - New Notifier</category><body>warn: messageString for: aVisualOrNil	"Present the message string to the user.  Continue processing	when the user hits the 'ok' box or types cr."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow.  It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	"Dialog warn: 'Beware, this is a warning'		for: Dialog defaultParentWindow."	^self choose: messageString labels: #('OK') values: #(nil) default: nil</body></methods><methods><class-id>UI.BasicButtonController</class-id> <category>enhanced - button shortcuts</category><body>processKeyboardEvent: anEvent	self 		processKeyboardEvent: anEvent 		onCarriageReturn: [keyboardProcessor doDefaultAction].	"-------------------------------------------------------------------"	"Added for Button Shortcuts support:"	keyboardProcessor offerToShortcutsAgain: anEvent.	"-------------------------------------------------------------------"</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>enhanced - Win95 Look Policy</category><body>isReadOnly	^true</body></methods><methods><class-id>Graphics.Window</class-id> <category>enhanced - Win95 Look Policy</category><body>checkForScrollers</body></methods><methods><class-id>UI.ApplicationModel class</class-id> <category>enhanced - New Notifier</category><body>defaultIcon	^self visualAt: self defaultIconName ifAbsent: [nil]</body></methods><methods><class-id>UI.TextEditorSpec</class-id> <category>enhanced - Nextstep Look</category><body>hasTextBackground	^ self isOpaque or: [self hasBorder and: [self isReadOnly not]]</body></methods><methods><class-id>UI.WidgetPolicy</class-id> <category>enhanced - Aragon Look Policies</category><body>borderDecoratorClass	^BorderDecorator</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>enhanced - text editing</category><body>processTabKey: aCharEvent 	"The user has typed a &lt;tab&gt;. If the control key was pressed along with	the &lt;tab&gt; and if this view supports tabbing between fields, shift focus	in the appropriate direction. Otherwise, insert a &lt;tab&gt; character into the text."	(tabMeansNextField and: [aCharEvent hasCtrl])		ifTrue: [(keyboardProcessor isBackTab: aCharEvent)				ifTrue: [self moveToPrevField]				ifFalse: [self moveToNextField]]		ifFalse: [self indentKey: aCharEvent]"		ifFalse: [(keyboardProcessor isBackTab: aCharEvent)				ifFalse: [self normalCharacterKey: aCharEvent]]"</body></methods><methods><class-id>UI.ComboBoxView</class-id> <category>enhanced - Win95 Look Policy</category><body>setLabel: anEntry 	| menu |	((menu := menuButton list) isKindOf: Menu)		ifTrue: [menu menuItems do: [:each | each value = anEntry ifTrue: [^editor editText: each label]]]</body></methods><methods><class-id>UI.ComboBoxInputBoxController</class-id> <category>enhanced - Win95 Look Policy</category><body>superProcessKeyboardEvent: anEvent 	^super processKeyboardEvent: anEvent</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - New Notifier</category><body>dialogSupplier	^(Aragon includesKey: #NewNotifier)		ifTrue: [(Aragon at: #NewNotifier) notifierClass new]		ifFalse: [SimpleDialog new]</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>canScrollRight	"Answer if there is still information to the right the current viewable range."	^self scrollableExtent x + self translation x &gt; self visibleExtent x</body></methods><methods><class-id>UI.UndecoratedActionButtonView</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText	"Answer a visual component for displaying aStringOrText in the appropriate text style."	^super makeTextLabelFor: aStringOrText asText allBold.</body></methods><methods><class-id>UI.ScrollWrapper</class-id> <category>enhanced - Aragon Look Policies</category><body>canScrollHorizontally	^self scrollableExtent x &gt; self visibleExtent x</body></methods><methods><class-id>UI.ApplicationModel class</class-id> <category>enhanced - New Notifier</category><body>defaultIconName	^nil</body></methods><methods><class-id>UI.SimpleView</class-id> <category>enhanced - button shortcuts</category><body>makeTextLabelFor: aStringOrText 	^super makeTextLabelFor: aStringOrText</body></methods><methods><class-id>UI.SequenceViewSpec</class-id> <category>enhanced - Nextstep Look</category><body>hasTextBackground	^self isOpaque</body></methods><methods><class-id>Aragon.NSScrollerButton class</class-id> <category>resources</category><body>arrowDownImage	"UIMaskEditor new openOnClass: self andSelector: #arrowDownImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 254 0 0 0 124 0 0 0 124 0 0 0 56 0 0 0 56 0 0 0 16 0 0 0 16 0 0 0])</body><body>arrowLeftImage	"UIMaskEditor new openOnClass: self andSelector: #arrowLeftImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 14 0 0 0 62 0 0 0 254 0 0 0 62 0 0 0 14 0 0 0 2 0 0 0])</body><body>arrowRightImage	"UIMaskEditor new openOnClass: self andSelector: #arrowRightImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[64 0 0 0 112 0 0 0 124 0 0 0 127 0 0 0 124 0 0 0 112 0 0 0 64 0 0 0])</body><body>arrowUpImage	"UIMaskEditor new openOnClass: self andSelector: #arrowUpImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[16 0 0 0 16 0 0 0 56 0 0 0 56 0 0 0 124 0 0 0 124 0 0 0 254 0 0 0 0 0 0 0])</body><body>smallArrowDownImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowDownImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 7@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 124 0 0 0 56 0 0 0 56 0 0 0 16 0 0 0 16 0 0 0 0 0 0 0])</body><body>smallArrowLeftImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowLeftImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 7@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 4 0 0 0 28 0 0 0 124 0 0 0 28 0 0 0 4 0 0 0 0 0 0 0])</body><body>smallArrowRightImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowRightImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 7@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 64 0 0 0 112 0 0 0 124 0 0 0 112 0 0 0 64 0 0 0 0 0 0 0])</body><body>smallArrowUpImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowUpImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 7@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 16 0 0 0 16 0 0 0 56 0 0 0 56 0 0 0 124 0 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.NSScrollBar class</class-id> <category>resources</category><body>dotIcon	"UIMaskEditor new openOnClass: self andSelector: #dotIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 6@6 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 6 put: (ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: #[69 0 4 0 80 37 21 0 2 84 68 0 5 68 51 0 1 67 51 0 66 67 52 0])</body><body>dotMask	"UIMaskEditor new openOnClass: self andSelector: #dotMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 6@6 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[120 0 0 0 252 0 0 0 224 0 0 0 204 0 0 0 220 0 0 0 88 0 0 0])</body></methods><methods><class-id>Aragon.NSActionButtonView class</class-id> <category>resources</category><body>borderMask	"UIMaskEditor new openOnClass: self andSelector: #borderMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@10 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 60 0 0 12 32 0 0 16 32 0 0 35 224 0 0 64 0 0 0 128 0 0 0 64 0 0 0 32 0 0 0 16 0 0 0 8 0 0 0])</body><body>defaultIndicatorImage	"UIMaskEditor new openOnClass: self andSelector: #defaultIndicatorImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@10 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); at: 4 put: (ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); yourself)) usingBits: #[255 255 240 8 255 15 243 244 252 175 243 212 242 224 3 244 203 255 255 212 47 255 255 244 207 221 221 212 243 85 85 84 252 223 255 252 255 31 255 252])</body><body>defaultIndicatorShape	"UIMaskEditor new openOnClass: self andSelector: #defaultIndicatorShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@10 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 62 0 0 12 34 0 0 28 38 0 0 55 226 0 0 96 6 0 0 192 2 0 0 69 86 0 0 47 254 0 0 20 0 0 0 12 0 0 0])</body><body>hiliteMask	"UIMaskEditor new openOnClass: self andSelector: #hiliteMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@10 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 2 0 0 0 6 0 0 0 2 0 0 0 6 0 0 0 2 0 0 5 86 0 0 15 254 0 0 4 0 0 0 4 0 0 0])</body><body>shadowMask	"UIMaskEditor new openOnClass: self andSelector: #shadowMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@10 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 2 0 0 0 0 0 0 12 0 0 0 20 0 0 0 32 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.Win95ScrollerButton class</class-id> <category>resources</category><body>arrowDownImage	"UIMaskEditor new openOnClass: self andSelector: #arrowDownImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@6 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 254 0 0 0 124 0 0 0 56 0 0 0 16 0 0 0 0 0 0 0])</body><body>arrowLeftImage	"UIMaskEditor new openOnClass: self andSelector: #arrowLeftImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 6@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[16 0 0 0 48 0 0 0 112 0 0 0 240 0 0 0 112 0 0 0 48 0 0 0 16 0 0 0])</body><body>arrowRightImage	"UIMaskEditor new openOnClass: self andSelector: #arrowRightImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 6@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[64 0 0 0 96 0 0 0 112 0 0 0 120 0 0 0 112 0 0 0 96 0 0 0 64 0 0 0])</body><body>arrowUpImage	"UIMaskEditor new openOnClass: self andSelector: #arrowUpImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@5 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[16 0 0 0 56 0 0 0 124 0 0 0 254 0 0 0 0 0 0 0])</body><body>smallArrowDownImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowDownImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 7@5 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 124 0 0 0 56 0 0 0 16 0 0 0 0 0 0 0])</body><body>smallArrowLeftImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowLeftImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 5@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 16 0 0 0 48 0 0 0 112 0 0 0 48 0 0 0 16 0 0 0 0 0 0 0])</body><body>smallArrowRightImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowRightImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 5@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 64 0 0 0 96 0 0 0 112 0 0 0 96 0 0 0 64 0 0 0 0 0 0 0])</body><body>smallArrowUpImage	"UIMaskEditor new openOnClass: self andSelector: #smallArrowUpImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 7@5 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 16 0 0 0 56 0 0 0 124 0 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.NSCheckButtonView class</class-id> <category>resources</category><body>borderMask	"UIMaskEditor new openOnClass: self andSelector: #borderMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 127 240 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>hiliteMask	"UIMaskEditor new openOnClass: self andSelector: #hiliteMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 0 4 0 0 255 252 0 0 0 0 0 0 0 0 0 0])</body><body>insideMask	"UIMaskEditor new openOnClass: self andSelector: #insideMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>markMask	"UIMaskEditor new openOnClass: self andSelector: #markMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 4 0 0 0 8 0 0 0 16 0 0 0 32 0 0 0 32 0 0 8 64 0 0 28 192 0 0 62 128 0 0 31 128 0 0 15 128 0 0 7 0 0 0 7 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>shadowMask	"UIMaskEditor new openOnClass: self andSelector: #shadowMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@18 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 255 248 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.Win95WidgetsExample class</class-id> <category>interface specs</category><body>pollingSpec	"UIPainter new openOnClass: self andSelector: #pollingSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Win95 Widgets Example' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 362 364 918 660 ) 			#isEventDriven: false ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CheckBoxSpec 					#layout: #(#Point 32 118 ) 					#label: '&amp;Check Box' ) 				#(#RadioButtonSpec 					#layout: #(#Point 32 139 ) 					#label: '&amp;Radio Button' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 150 40 250 61 ) 					#model: #text ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 31 74 139 96 ) 					#model: #selectedClass 					#label: '&amp;Menu Button' 					#menu: #collectionClasses 					#isPopUp: false ) 				#(#WindowResizeCornerSpec 					#layout: #(#AlignmentOrigin 0 1 0 1 1 1 ) ) 				#(#GroupBoxSpec 					#layout: #(#Rectangle 12 9 271 209 ) 					#label: 'Enabled Widgets' ) 				#(#LabelSpec 					#layout: #(#Point 71 212 ) 					#name: #canvasLabel 					#colors: 					#(#LookPreferences 						#setForegroundColor: #(#ColorValue #red ) ) 					#label: 'Win95 Widgets' 					#style: #('Times New Roman' #italic 72 ) ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 150 110 250 192 ) 					#flags: 15 ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 150 63 250 85 ) 					#isReadOnly: false 					#comboList: #classes ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 31 41 140 69 ) 					#label: 'Action &amp;Button' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#Point 147 92 ) 					#label: 'TextField' ) 				#(#CheckBoxSpec 					#layout: #(#Point 303 118 ) 					#flags: 32 					#label: '&amp;Check Box' ) 				#(#RadioButtonSpec 					#layout: #(#Point 303 139 ) 					#flags: 32 					#label: '&amp;Radio Button' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 421 40 521 61 ) 					#flags: 40 ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 302 74 411 97 ) 					#flags: 40 					#model: #selectedClass 					#label: '&amp;Menu Button' 					#menu: #collectionClasses ) 				#(#GroupBoxSpec 					#layout: #(#Rectangle 283 9 542 209 ) 					#flags: 32 					#label: 'Disabled Widgets' ) 				#(#SliderSpec 					#layout: #(#Rectangle 301 169 409 197 ) 					#flags: 40 					#orientation: #horizontal ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 421 110 521 192 ) 					#flags: 47 ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 421 64 521 86 ) 					#flags: 40 ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 302 41 411 69 ) 					#flags: 40 					#label: 'Action &amp;Button' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#Point 418 92 ) 					#flags: 32 					#label: 'TextField' ) 				#(#Win95SliderSpec 					#layout: #(#Rectangle 28 169 138 198 ) 					#model: #sliderValue 					#orientation: #horizontal 					#start: -300 					#stop: 300 					#step: 100 					#hasTickMarks: true ) 				#(#Win95SliderSpec 					#layout: #(#Rectangle 233 -46 313 -22 ) 					#orientation: #horizontal ) ) ) )</body><body>w2	"UIPainter new openOnClass: self andSelector: #w2"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Win95 Widgets Example' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 522 492 1078 788 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CheckBoxSpec 					#layout: #(#Point 32 118 ) 					#label: '&amp;Check Box' ) 				#(#RadioButtonSpec 					#layout: #(#Point 32 139 ) 					#label: '&amp;Radio Button' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 150 40 250 61 ) 					#model: #text ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 31 74 139 96 ) 					#model: #selectedClass 					#label: '&amp;Menu Button' 					#menu: #collectionClasses 					#isPopUp: false ) 				#(#WindowResizeCornerSpec 					#layout: #(#AlignmentOrigin 0 1 0 1 1 1 ) ) 				#(#GroupBoxSpec 					#layout: #(#Rectangle 12 9 271 209 ) 					#label: 'Enabled Widgets' ) 				#(#LabelSpec 					#layout: #(#Point 71 212 ) 					#name: #canvasLabel 					#colors: 					#(#LookPreferences 						#setForegroundColor: #(#ColorValue #red ) ) 					#label: 'Win95 Widgets' 					#style: #('Times New Roman' #italic 72 ) ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 150 110 250 192 ) 					#flags: 15 ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 150 63 250 85 ) 					#isOpaque: true 					#type: #object 					#comboList: #classes ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 31 41 140 69 ) 					#label: 'Action &amp;Button' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#Point 147 92 ) 					#label: 'TextField' ) 				#(#CheckBoxSpec 					#layout: #(#Point 303 118 ) 					#flags: 32 					#label: '&amp;Check Box' ) 				#(#RadioButtonSpec 					#layout: #(#Point 303 139 ) 					#flags: 32 					#label: '&amp;Radio Button' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 421 40 521 61 ) 					#flags: 40 					#isReadOnly: false ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 302 74 411 97 ) 					#flags: 40 					#isOpaque: true 					#model: #selectedClass 					#label: '&amp;Menu Button' 					#menu: #collectionClasses ) 				#(#GroupBoxSpec 					#layout: #(#Rectangle 283 9 542 209 ) 					#flags: 32 					#label: 'Disabled Widgets' ) 				#(#SliderSpec 					#layout: #(#Rectangle 301 169 409 197 ) 					#flags: 40 					#orientation: #horizontal ) 				#(#TextEditorSpec 					#layout: #(#Rectangle 421 110 521 192 ) 					#flags: 47 					#isReadOnly: false ) 				#(#ComboBoxSpec 					#layout: #(#Rectangle 421 64 521 86 ) 					#flags: 40 					#isReadOnly: false ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 302 41 411 69 ) 					#flags: 40 					#label: 'Action &amp;Button' 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#Point 418 92 ) 					#flags: 32 					#label: 'TextField' ) 				#(#Win95SliderSpec 					#layout: #(#Rectangle 28 169 138 198 ) 					#model: #sliderValue 					#orientation: #horizontal 					#start: -300 					#stop: 300 					#step: 100 					#hasTickMarks: true ) 				#(#Win95SliderSpec 					#layout: #(#Rectangle 233 -46 313 -22 ) 					#orientation: #horizontal ) ) ) )</body><body>windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Win95 Widgets Example' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1196 808 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 32 118 ) 					#label: '&amp;Check Box' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 32 139 ) 					#label: '&amp;Radio Button' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 150 40 250 61 ) 					#model: #text ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 31 74 139 96 ) 					#model: #selectedClass 					#label: '&amp;Menu Button' 					#menu: #collectionClasses 					#isPopUp: false ) 				#(#{Aragon.WindowResizeCornerSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 1 0 1 1 1 ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 12 9 271 209 ) 					#label: 'Enabled Widgets' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 71 212 ) 					#name: #canvasLabel 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: 'Win95 Widgets' 					#style: #('Times New Roman' #italic 72 ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.Rectangle} 150 110 250 192 ) 					#flags: 15 					#tabRequiresControl: true ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 150 63 250 85 ) 					#isReadOnly: false 					#type: #object 					#comboList: #classes ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 31 41 140 69 ) 					#label: 'Action &amp;Button' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 147 92 ) 					#label: 'TextField' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 303 118 ) 					#flags: 32 					#label: '&amp;Check Box' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 303 139 ) 					#flags: 32 					#label: '&amp;Radio Button' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 421 40 521 61 ) 					#flags: 40 					#isReadOnly: false ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 302 74 411 97 ) 					#flags: 40 					#isOpaque: true 					#model: #selectedClass 					#label: '&amp;Menu Button' 					#menu: #collectionClasses ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 283 9 542 209 ) 					#flags: 32 					#label: 'Disabled Widgets' ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 301 169 409 197 ) 					#flags: 40 					#orientation: #horizontal 					#start: -300 					#stop: 300 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.Rectangle} 421 110 521 192 ) 					#flags: 47 					#isReadOnly: false 					#tabRequiresControl: true ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 421 64 521 86 ) 					#flags: 40 					#isReadOnly: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 302 41 411 69 ) 					#flags: 40 					#label: 'Action &amp;Button' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 418 92 ) 					#flags: 32 					#label: 'TextField' ) 				#(#{Aragon.Win95SliderSpec} 					#layout: #(#{Graphics.Rectangle} 28 169 138 198 ) 					#model: #sliderValue 					#orientation: #horizontal 					#start: -300 					#stop: 300 					#step: 100 					#hasTickMarks: true ) 				#(#{Aragon.Win95SliderSpec} 					#layout: #(#{Graphics.Rectangle} 233 -46 313 -22 ) 					#orientation: #horizontal ) ) ) )</body></methods><methods><class-id>Aragon.NSMenuItemView class</class-id> <category>resources</category><body>indicationIcon	"UIMaskEditor new openOnClass: self andSelector: #indicationIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 11@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 32 0 0 0 64 0 0 0 128 0 0 0 128 0 0 33 0 0 0 115 0 0 0 250 0 0 0 126 0 0 0 62 0 0 0 28 0 0 0 28 0 0 0 12 0 0 0])</body><body>submenuIcon	"UIMaskEditor new openOnClass: self andSelector: #submenuIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 6@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[64 0 0 0 96 0 0 0 112 0 0 0 120 0 0 0 112 0 0 0 96 0 0 0 64 0 0 0])</body><body>submenuMask	"UIMaskEditor new openOnClass: self andSelector: #submenuMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 11@10 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 112 0 0 0 124 0 0 0 127 0 0 0 127 192 0 0 127 192 0 0 127 0 0 0 124 0 0 0 112 0 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.Win95CheckButtonView class</class-id> <category>resources</category><body>borderMask	"UIMaskEditor new openOnClass: self andSelector: #borderMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 224 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0])</body><body>hiliteMask	"UIMaskEditor new openOnClass: self andSelector: #hiliteMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 0 8 0 0 255 248 0 0])</body><body>indicationIcon	"UIMaskEditor new openOnClass: self andSelector: #indicationIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 3 0 0 0 71 0 0 0 110 0 0 0 124 0 0 0 56 0 0 0 16 0 0 0 0 0 0 0])</body><body>insideMask	"UIMaskEditor new openOnClass: self andSelector: #insideMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 224 0 0 63 224 0 0 63 224 0 0 63 224 0 0 63 224 0 0 63 224 0 0 63 224 0 0 63 224 0 0 63 224 0 0 0 0 0 0 0 0 0 0])</body><body>markMask	"UIMaskEditor new openOnClass: self andSelector: #markMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 64 0 0 0 192 0 0 17 192 0 0 27 128 0 0 31 0 0 0 14 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>shadowMask	"UIMaskEditor new openOnClass: self andSelector: #shadowMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 240 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.NSLookPolicy class</class-id> <category>interface specs</category><body>setupSpec	"UIPainter new openOnClass: self andSelector: #setupSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'New UI Looks' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 656 509 954 685 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#RadioButtonSpec 					#layout: #(#Point 77 95 ) 					#model: #look 					#label: 'Windows 95' 					#style: #'Notifier.Message' 					#select: #Win95LookPolicy ) 				#(#RadioButtonSpec 					#layout: #(#Point 77 76 ) 					#model: #look 					#label: 'Nextstep Look' 					#style: #'Notifier.Message' 					#select: #NSLookPolicy ) 				#(#LabelSpec 					#layout: #(#Point 17 34 ) 					#label: 'as your default Look Policy right now.' 					#style: #'Notifier.Message' ) 				#(#LabelSpec 					#layout: #(#Point 17 16 ) 					#label: 'You can install one of the new UI Looks' 					#style: #'Notifier.Message' ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 90 143 182 169 ) 					#model: #accept 					#label: 'Install' 					#style: #'Notifier.Message' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 185 143 277 169 ) 					#model: #cancel 					#label: 'Cancel' 					#style: #'Notifier.Message' 					#isDefault: false 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec class</class-id> <category>resources</category><body>paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: (MappedPalette withColors: ((Array new: 2) at: 1 put: ColorValue white; at: 2 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 100 0 0 0 204 0 0 1 152 0 0 3 48 0 0 6 100 0 0 12 204 0 0 25 152 0 0 0 0 0 0])</body><body>paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 4 0 0 0 12 0 0 0 28 0 0 0 56 0 0 0 116 0 0 0 236 0 0 1 220 0 0 3 184 0 0 7 116 0 0 14 236 0 0 29 220 0 0 59 184 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.WindowResizeCornerSpec class</class-id> <category>interface specs</category><body>basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 171 ) 			#max: #(#Point 300 171 ) 			#bounds: #(#Rectangle 490 427 790 598 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame 60 0 39 0 -10 1 64 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 63 0 0 1 ) 					#label: 'ID:' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#CheckBoxSpec 					#layout: #(#Point 59 90 ) 					#model: #initiallyDisabled 					#label: 'Initially Disabled' ) 				#(#CheckBoxSpec 					#layout: #(#Point 59 111 ) 					#model: #initiallyInvisible 					#label: 'Initially Invisible' ) ) ) )</body></methods><methods><class-id>Aragon.WindowResizeCorner class</class-id> <category>resources</category><body>backgroundShape	"UIMaskEditor new openOnClass: self andSelector: #backgroundShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 254 0 0 255 254 0 0 255 250 0 0 255 242 0 0 255 226 0 0 255 198 0 0 255 138 0 0 255 18 0 0 254 34 0 0 252 70 0 0 248 138 0 0 241 18 0 0 226 34 0 0 196 70 0 0 255 254 0 0])</body><body>cursorImage	"UIMaskEditor new openOnClass: self andSelector: #cursorImage"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[0 0 0 0 124 0 0 0 120 0 0 0 112 0 0 0 104 0 0 0 68 0 0 0 2 0 0 0 1 0 0 0 0 128 0 0 0 68 0 0 0 44 0 0 0 28 0 0 0 60 0 0 0 124 0 0 0 0 0 0 0 0 0 0])</body><body>cursorShape	"UIMaskEditor new openOnClass: self andSelector: #cursorShape"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[254 0 0 0 254 0 0 0 252 0 0 0 248 0 0 0 252 0 0 0 238 0 0 0 199 0 0 0 3 128 0 0 1 198 0 0 0 238 0 0 0 126 0 0 0 62 0 0 0 126 0 0 0 254 0 0 0 254 0 0 0 0 0 0])</body><body>hiliteShape	"UIMaskEditor new openOnClass: self andSelector: #hiliteShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 4 0 0 0 8 0 0 0 16 0 0 0 32 0 0 0 68 0 0 0 136 0 0 1 16 0 0 2 32 0 0 4 68 0 0 8 136 0 0 17 16 0 0 34 32 0 0 0 0 0 0])</body><body>image	"UIMaskEditor new openOnClass: self andSelector: #image"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: (ColorValue scaledRed: 7098 scaledGreen: 6167 scaledBlue: 5814); at: 2 put: (ColorValue scaledRed: 7644 scaledGreen: 7195 scaledBlue: 7034); at: 3 put: (ColorValue scaledRed: 5749 scaledGreen: 3629 scaledBlue: 2794); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 16 0 0 0 96 0 0 1 160 0 0 6 128 0 0 26 16 0 0 104 96 0 1 161 160 0 6 134 128 0 26 26 16 0 104 104 96 1 161 161 160 6 134 134 128 0 0 0 0])</body><body>shadowShape	"UIMaskEditor new openOnClass: self andSelector: #shadowShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 100 0 0 0 204 0 0 1 152 0 0 3 48 0 0 6 100 0 0 12 204 0 0 25 152 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.NewNotifier class</class-id> <category>interface specs</category><body>buttonSpec	"UIPainter new openOnClass: self andSelector: #buttonSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Button' 			#bounds: #(#Rectangle 562 490 719 535 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -127 1 -30 1 -7 1 -7 1 ) 					#tabable: true 					#label: 'Button' 					#isDefault: false 					#defaultable: true ) ) ) )</body><body>panel0Spec	"UIPainter new openOnClass: self andSelector: #panel0Spec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 314 89 ) 			#max: #(#Point 365 152 ) 			#bounds: #(#Rectangle 483 468 797 557 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 22 0 0.5 0 ) 					#name: #message 					#label: 'Message Text' 					#style: #'Notifier.Message' ) ) ) )</body><body>panel1Spec	"UIPainter new openOnClass: self andSelector: #panel1Spec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 314 132 ) 			#max: #(#Point 365 152 ) 			#bounds: #(#Rectangle 483 446 797 578 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 28 7 ) 					#name: #title 					#label: #title 					#style: #Title ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0 44 0 0 1.0 46 0 ) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 68 0 0.5 0 ) 					#name: #message 					#label: 'Message Text' 					#style: #'Notifier.Message' ) ) ) )</body><body>panel2Spec	"UIPainter new openOnClass: self andSelector: #panel2Spec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 314 152 ) 			#max: #(#Point 365 152 ) 			#bounds: #(#Rectangle 483 436 797 588 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 84 15 ) 					#name: #title 					#label: #title 					#style: #Title ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0 60 0 0 1.0 62 0 ) ) 				#(#LabelSpec 					#layout: #(#Rectangle 12 3 80 57 ) 					#name: #icon 					#label: #icon 					#hasCharacterOrientedLabel: false ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 82 0 0.5 0 ) 					#name: #message 					#label: 'Message Text'					#style: #'Notifier.Message' ) ) ) )</body><body>panel3Spec	"UIPainter new openOnClass: self andSelector: #panel3Spec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 314 152 ) 			#max: #(#Point 365 152 ) 			#bounds: #(#Rectangle 258 321 572 473 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 26 8 ) 					#name: #title 					#label: #title 					#style: #Title)				#(#LabelSpec 					#layout: #(#Point 27 31 ) 					#name: #subtitle 					#label: #subtitle 					#style: #'Notifier.Subtitle' ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0 60 0 0 1.0 62 0 ) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 82 0 0.5 0 ) 					#name: #message 					#label: 'Message Text' 					#style: #'Notifier.Message' ) ) ) )</body><body>panel4Spec	"UIPainter new openOnClass: self andSelector: #panel4Spec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 314 152 ) 			#max: #(#Point 365 152 ) 			#bounds: #(#Rectangle 483 436 797 588 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 84 8 ) 					#name: #title 					#label: #title 					#style: #Title)				#(#LabelSpec 					#layout: #(#Point 85 31 ) 					#name: #subtitle 					#label: #subtitle 					#style: #'Notifier.Subtitle' ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0 60 0 0 1.0 62 0 ) ) 				#(#LabelSpec 					#layout: #(#Rectangle 12 3 80 57 ) 					#name: #icon 					#label: #icon 					#hasCharacterOrientedLabel: false ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 82 0 0.5 0 ) 					#name: #message 					#label: 'Message Text' 					#style: #'Notifier.Message' ) ) ) )</body></methods><methods><class-id>Aragon.Win95Notifier class</class-id> <category>resources</category><body>informationImage	"UIMaskEditor new openOnClass: self andSelector: #informationImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 2 put: ColorValue blue; at: 3 put: ColorValue black; at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@DQDQDP@@@@@@@@@@@@@ADPCL3L0QD@@@@@@@@@@AD@3L3L3L3LDP@@@@@@@@D@3L3L3L3L3L0P@@@@@@@P3L3L0DQDCL3L3H@@@@@ACL3L3LQDQD3L3L3H@@@@DL3L3L3DQDQL3L3L3H@@@PCL3L3L0DQDCL3L3L0H@@DL3L3L3L3L3L3L3L3L2P@PCL3L3L3L3L3L3L3L3LBPDL3L3L3LQDQDSL3L3L3L$ACL3L3L3L1DQD3L3L3L3IDP3L3L3L3LQDQL3L3L3L2QDL3L3L3L3DQDSL3L3L3L$QCL3L3L3L1DQD3L3L3L3IDPCL3L3L3LQDQL3L3L3LBQ@P3L3L3L3DQDSL3L3L3IDPD@3L3L3L1DQD3L3L3LBQD@DL3L3L1DQDQDSL3L3IDP@@BL3L3L3L3L3L3L3L$QD@@@BL3L3L3L3L3L3L2QDP@@@@B@3L3L3L3L3L0IDQ@@@@@@BHCL3L3L3L0H$QD@@@@@@@DH"@3L3LBH$QDP@@@@@@@@DQBH L3IDQDQ@@@@@@@@@@@QDP#L2QDQ@@@@@@@@@@@@@@DH3L$P@@@@@@@@@@@@@@@@@H3ID@@@@@@@@@@@@@@@@@@H2Q@@@@@@@@@@@@@@@@@@@H$P@@@@@@@@@@@@@@@@@@@QD@@@@@@@@@@@@@@@@@@@@Q@@@@@@@@b'))</body><body>informationShape	"UIMaskEditor new openOnClass: self andSelector: #informationShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 31 224 0 0 239 220 0 3 127 251 0 5 255 254 128 15 247 191 192 31 255 255 224 63 255 255 240 95 247 191 232 127 255 255 252 191 255 255 246 255 255 255 254 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 191 255 255 247 127 255 255 255 95 255 255 239 63 255 255 254 31 255 255 254 15 255 255 252 5 255 254 248 3 127 251 240 1 239 223 224 0 253 255 192 0 63 255 0 0 7 248 0 0 1 248 0 0 0 248 0 0 0 120 0 0 0 56 0 0 0 24 0])</body><body>questionImage	"UIMaskEditor new openOnClass: self andSelector: #questionImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 2 put: ColorValue black; at: 3 put: ColorValue blue; at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@DQDQDP@@@@@@@@@@@@@ADPCL3L0QD@@@@@@@@@@AD@3L3L3L3LDP@@@@@@@@D@3L3L3L3L3L0P@@@@@@@P3L3L3L3L3L3L3D@@@@@ACL3L3@"H"HCL3L3D@@@@DL3L3LB@3H"HCL3L3D@@@PCL3L3H#L3H"H3L3L0D@@DL3L3L2H"L2H"L3L3L1P@PCL3L3L"H#@"H#L3L3LAPDL3L3L3@"@2H"L3L3L3LTACL3L3L3L3@"H3L3L3L3EDP3L3L3L3L2H#L3L3L3L1QDL3L3L3L3L"@3L3L3L3LTQCL3L3L3L3H#L3L3L3L3EDPCL3L3L3L3L3L3L3L3LAQ@P3L3L3L3@"@3L3L3L3EDPD@3L3L3L2H"L3L3L3LAQD@DL3L3L3L"H#L3L3L3EDP@@AL3L3L3@"@3L3L3LTQD@@@AL3L3L3L3L3L3L1QDP@@@@A@3L3L3L3L3L0EDQ@@@@@@ADCL3L3L3L0DTQD@@@@@@@DDQ@3L3LADTQDP@@@@@@@@DQADPL3EDQDQ@@@@@@@@@@@QDPSL1QDQ@@@@@@@@@@@@@@DD3LTP@@@@@@@@@@@@@@@@@D3ED@@@@@@@@@@@@@@@@@@D1Q@@@@@@@@@@@@@@@@@@@DTP@@@@@@@@@@@@@@@@@@@QD@@@@@@@@@@@@@@@@@@@@Q@@@@@@@@b'))</body><body>questionShape	"UIMaskEditor new openOnClass: self andSelector: #questionShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 31 224 0 0 239 220 0 3 127 251 0 5 255 254 128 15 255 255 192 31 239 223 224 63 215 239 240 95 255 255 232 127 255 255 252 191 254 255 246 255 219 255 254 255 253 255 255 255 255 255 255 255 255 127 255 255 255 255 255 191 255 255 247 127 251 127 255 95 255 255 239 63 255 255 254 31 251 127 254 15 255 255 252 5 255 254 248 3 127 251 240 1 239 223 224 0 253 255 192 0 63 255 0 0 7 248 0 0 1 248 0 0 0 248 0 0 0 120 0 0 0 56 0 0 0 24 0])</body><body>stopImage	"UIMaskEditor new openOnClass: self andSelector: #stopImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 2 put: ColorValue red; at: 3 put: (ColorValue scaledRed: 4111 scaledGreen: 0 scaledBlue: 0); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@BH"H"H@@@@@@@@@@@@@@"HQDQDQH"@@@@@@@@@@@BDQDQDQDQDR@@@@@@@@@BHQDQDQDQDQDRH@@@@@@@HQDQDQDQDQDQDQH@@@@@@!DQDQDQDQDQDQDQH@@@@@HQDQDQDQDQDQDQDRP@@@@!DQDSDQDQDQD1DQDRP@@BDQDQL3DQDQDSL1DQDR@@@!DQD3L3DQDQL3L1DQD$@@HQDQD3L3DQD3L3DQDQID@!DQDQD3L3DSL3LQDQDQI@HQDQDQD3L3L3L1DQDQDRPBDQDQDQD3L3L3DQDQDQD$P!DQDQDQD3L3LQDQDQDQIDHQDQDQDQL3L3DQDQDQDRQBDQDQDQD3L3L3DQDQDQD$P!DQDQDSL3L3L3DQDQDQIDHQDQDQL3L1D3L3DQDQDRQ@HQDQD3L3DQD3L3DQDQIDPBDQDSL3LQDQD3L3DQDRQD@!DQDSL1DQDQD3LQDQD$P@@!DQDSDQDQDQD1DQDRQD@@@!DQDQDQDQDQDQDQIDQ@@@HQDQDQDQDQDQDQDRQD@@@@HQDQDQDQDQDQDQIDP@@@@@H!DQDQDQDQDQH$QD@@@@@@P!DQDQDQDQD$QDP@@@@@@@P"HQDQDQH"QDQ@@@@@@@@@ADH"H"H$QDQ@@@@@@@@@@@ADQDQDQDQD@@@@@@@@@@@@@@QDQDQ@@@@@@@@b'))</body><body>stopShape	"UIMaskEditor new openOnClass: self andSelector: #stopShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 31 224 0 0 255 252 0 1 255 254 0 7 255 255 128 15 255 255 192 31 255 255 224 31 255 255 240 63 255 255 248 127 255 255 248 127 255 255 252 127 255 255 254 255 255 255 254 255 255 255 254 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 127 255 255 255 127 255 255 255 127 255 255 254 63 255 255 254 31 255 255 254 31 255 255 252 15 255 255 248 7 255 255 248 3 255 255 240 1 255 255 224 0 127 255 128 0 63 255 0 0 7 248 0])</body><body>warningImage	"UIMaskEditor new openOnClass: self andSelector: #warningImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 2 put: ColorValue black; at: 3 put: ColorValue yellow; at: 4 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 0); at: 5 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@3L@@@@@@@@@@@@@@@@@@CH D@@@@@@@@@@@@@@@@@L"H E@@@@@@@@@@@@@@@@CH"H!Q@@@@@@@@@@@@@@@L"H"HAQ@@@@@@@@@@@@@@CH"H"HTP@@@@@@@@@@@@@L"H"H"@TP@@@@@@@@@@@@CH"H"H"ED@@@@@@@@@@@@L"H"H"H ED@@@@@@@@@@@CH"@QDBH!Q@@@@@@@@@@@L"H!DQD"HAQ@@@@@@@@@@CH"HQDQH"HTP@@@@@@@@@L"H"DQDRH"@TP@@@@@@@@CH"H!DQD"H"ED@@@@@@@@L"H"HQDQH"H ED@@@@@@@CH"H"LQD2H"H!Q@@@@@@@L"H"H DQ@"H"HAQ@@@@@@CH"H"H!DRH"H"HTP@@@@@L"H"H"H1L"H"H"@TP@@@@CH"H"H"@PH"H"H"ED@@@@L"H"H"H"D"H"H"H ED@@@CH"H"H"H"H"H"H"H!Q@@@L"H"H"H"@Q@"H"H"HAQ@@CH"H"H"H!DQH"H"H"HTP@L"H"H"H"HQDRH"H"H"@TPCH"H"H"H"@Q@"H"H"H"ED@2H"H"H"H"H"H"H"H"H!QDL"H"H"H"H"H"H"H"H"@TQ@L"H"H"H"H"H"H"H"HAQDP@LQDQDQDQDQDQDQDQEDQD@@ADQDQDQDQDQDQDQDQDP@@@ADQDQDQDQDQDQDQDQ@@b'))</body><body>warningShape	"UIMaskEditor new openOnClass: self andSelector: #warningShape"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 7 0 0 0 14 128 0 0 31 96 0 0 31 240 0 0 63 184 0 0 63 248 0 0 127 220 0 0 127 252 0 0 255 238 0 0 247 126 0 1 255 247 0 1 255 255 0 3 255 251 128 3 255 255 128 7 255 253 192 7 255 255 192 15 247 126 224 15 255 255 224 31 255 255 112 31 250 255 240 63 255 255 184 63 255 255 248 127 251 127 220 127 255 255 252 255 255 255 238 255 251 127 254 255 255 255 255 255 255 255 239 127 255 255 223 63 255 255 255 15 255 255 254 7 255 255 252])</body></methods><methods><class-id>Aragon.Win95SliderSpec class</class-id> <category>interface specs</category><body>detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 245 233 ) 			#max: #(#Point 300 243 ) 			#bounds: #(#Rectangle 490 391 790 634 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 46 0 -4 0.5 129 0 ) 					#label: 'Orientation' ) 				#(#RadioButtonSpec 					#layout: #(#Point 25 74 ) 					#model: #orientation 					#label: '&amp;Vertical' 					#select: #vertical ) 				#(#RadioButtonSpec 					#layout: #(#Point 25 95 ) 					#model: #orientation 					#label: '&amp;Horizontal' 					#select: #horizontal ) 				#(#CheckBoxSpec 					#layout: #(#Point 19 175 ) 					#model: #initiallyDisabled 					#label: 'Initially &amp;Disabled' ) 				#(#CheckBoxSpec 					#layout: #(#Point 19 196 ) 					#model: #initiallyInvisible 					#label: 'Initially &amp;Invisible' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.501818 8 0 0.5 0 ) 					#label: #componentName 					#style: #large ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 4 0.5 46 0 -10 1 146 0 ) 					#label: 'Point To' ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 20 0.5 70 0 ) 					#model: #pointTo 					#label: '&amp;None' ) 				#(#CheckBoxSpec 					#layout: #(#Point 19 154 ) 					#model: #hasTickMarks 					#label: 'Show Tick &amp;Marks' ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 20 0.5 90 0 ) 					#model: #pointTo 					#label: '&amp;Top/Left' 					#select: #topLeft ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 20 0.5 111 0 ) 					#model: #pointTo 					#label: '&amp;Bottom/Right' 					#select: #bottomRight ) ) ) )</body></methods><methods><class-id>Aragon.Win95SliderSpec class</class-id> <category>resources</category><body>paletteImage	"UIMaskEditor new openOnClass: self andSelector: #paletteImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'UUUUUUUUT@AUUUUUUUUP@EUUUUUUUU@@UUUUUUUUT@ATUTUTUTUP@EQUQUQUQU@@UEUEUEUET@AUUUUUUUUP@EUUUEUUUU@@UUUUEUUUT@AUUUUEUUUP@EUUUTUUUU@@T@@UP@@@T@AR*)UJ**%P@EIUUTUUUU@@TUUUQUUUT@AUUUUEUUUP@EUUUTUUUU@@UUU@AUUUT@AUUUUUUUUP@EUUUUUUUU@@UUUUUUUUT@AUUUUUUUUP@EUUUUUUUU@@UUUUUUUUT@AUUUUUUUUP@@@a'))</body><body>paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 65 4 0 16 65 4 0 16 65 4 0 0 0 0 0 0 16 0 0 0 40 0 0 0 68 0 0 0 68 0 0 63 199 255 0 63 199 255 0 48 68 1 0 63 199 255 0 0 68 0 0 0 68 0 0 0 124 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.NSRadioButtonView class</class-id> <category>resources</category><body>borderMask	"UIMaskEditor new openOnClass: self andSelector: #borderMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 24 0 0 0 32 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>dotMask	"UIMaskEditor new openOnClass: self andSelector: #dotMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 15 240 0 0 15 240 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 15 240 0 0 15 240 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>hiliteMask	"UIMaskEditor new openOnClass: self andSelector: #hiliteMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0 8 0 0 8 48 0 0 7 192 0 0 0 0 0 0])</body><body>shadowMask	"UIMaskEditor new openOnClass: self andSelector: #shadowMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[7 192 0 0 24 48 0 0 36 8 0 0 80 0 0 0 64 0 0 0 160 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 192 0 0 0 64 0 0 0 64 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>shapeImage	"UIMaskEditor new openOnClass: self andSelector: #shapeImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[7 192 0 0 31 240 0 0 63 248 0 0 127 252 0 0 127 252 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 127 252 0 0 127 252 0 0 63 248 0 0 31 240 0 0 7 192 0 0 0 0 0 0])</body></methods><methods><class-id>Aragon.Win95RadioButtonView class</class-id> <category>resources</category><body>borderMask	"UIMaskEditor new openOnClass: self andSelector: #borderMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 12@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 15 0 0 0 48 192 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>dotMask	"UIMaskEditor new openOnClass: self andSelector: #dotMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 12@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 15 0 0 0 15 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body>hiliteMask	"UIMaskEditor new openOnClass: self andSelector: #hiliteMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 12@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 32 0 0 0 32 0 0 0 16 0 0 0 16 0 0 0 16 0 0 0 16 0 0 0 32 0 0 0 32 0 0 48 192 0 0 15 0 0 0])</body><body>imageMask	"UIMaskEditor new openOnClass: self andSelector: #imageMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 12@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 0 0 0 63 192 0 0 127 224 0 0 127 224 0 0 255 240 0 0 255 240 0 0 255 240 0 0 255 240 0 0 127 224 0 0 127 224 0 0 63 192 0 0 15 0 0 0])</body><body>insideMask	"UIMaskEditor new openOnClass: self andSelector: #insideMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 12@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 15 0 0 0 31 128 0 0 63 192 0 0 63 192 0 0 63 192 0 0 63 192 0 0 31 128 0 0 15 0 0 0 0 0 0 0 0 0 0 0])</body><body>shadowMask	"UIMaskEditor new openOnClass: self andSelector: #shadowMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 12@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 0 0 0 48 192 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0])</body></methods><initialize><class-id>Aragon.NSScrollerButton</class-id></initialize><initialize><class-id>Aragon.Win95BorderDecorator</class-id></initialize><initialize><class-id>Aragon.NSScrollBar</class-id></initialize><initialize><class-id>Aragon.NSActionButtonView</class-id></initialize><initialize><class-id>Aragon.Win95ScrollerButton</class-id></initialize><initialize><class-id>Aragon.Win95ComboBoxInputBoxController</class-id></initialize><initialize><class-id>Aragon.NSMenuItemView</class-id></initialize><initialize><class-id>Aragon.NSLookPolicy</class-id></initialize><initialize><class-id>Aragon.WindowResizeCornerSpec</class-id></initialize><initialize><class-id>Aragon.Win95LookPolicy</class-id></initialize><initialize><class-id>Aragon.Win95ComboBoxButtonController</class-id></initialize><initialize><class-id>Aragon.Win95SliderView</class-id></initialize><initialize><class-id>Aragon.WindowResizeCorner</class-id></initialize><initialize><class-id>Aragon.NSWidgetPolicy</class-id></initialize><initialize><class-id>Aragon.Win95WidgetPolicy</class-id></initialize><initialize><class-id>Aragon.NewNotifier</class-id></initialize><initialize><class-id>Aragon.Win95Notifier</class-id></initialize><initialize><class-id>Aragon.Win95SliderSpec</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category></class><class><name>EmulationScrollBar</name><environment>UI</environment><super>UI.Scrollbar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dragging </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Support</category></class><class><name>ComboBoxView</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editor menuButton dropDownWindowModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>KeyboardProcessor</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardConsumers currentConsumer default cancel keyboardHook focusIsShifting currentConsumerChannel acceptOnControlChange menuBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category></class><class><name>WidgetPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>defaultWidgetColors </class-inst-vars><imports></imports><category>UIBuilder-Support</category></class><class><name>ResizingSplitterView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>horizontal aboveWidgets belowWidgets builder minAboveSize minBelowSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>Label</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text attributes width offset needsScan fontPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category></class><class><name>SimpleComponent</name><environment>UI</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category></class><class><name>BorderDecorator</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component widgetFlags policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category></class><class><name>PassiveLabel</name><environment>UI</environment><super>UI.SimpleComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label textStyle margin mnemonic controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>MenuView</name><environment>UI</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuItemViews parentMenuItemView selectedValue selectionFinal highlightedMenuItemView usedSelectionMemory parentMenuBarButtonView commonTextIndent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>UIFeelPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>altKeys keyboard metaKeys supportsCodeEditing </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBuilder-Support</category></class><class><name>ToolBar</name><environment>UI</environment><super>UI.ComposingComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuChannel performer spaceIndices namedComponents releaseAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>EmulationBorderDecorationPolicy</name><environment>UI</environment><super>UI.BorderDecorationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Support</category></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view sensor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category></class><class><name>ComboBoxButtonController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dropDownIsOpen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>SimpleView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category></class><class><name>MenuButtonView</name><environment>UI</environment><super>UI.PushButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentChoice defaultChoice menu vcBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>SelectController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor keyboardHook dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>CheckButtonView</name><environment>UI</environment><super>UI.LabeledButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>ScrollerButtonView</name><environment>UI</environment><super>UI.BasicButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orientation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>BasicButtonController</name><environment>UI</environment><super>UI.SelectController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>RadioButtonView</name><environment>UI</environment><super>UI.LabeledButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>TriggerButtonController</name><environment>UI</environment><super>UI.BasicButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>ComboBoxListController</name><environment>UI</environment><super>UI.SequenceController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>continuousAccept closeChannel multiCharSearch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>MenuItemView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category></class><class><name>MotifCheckButtonView</name><environment>UI</environment><super>UI.CheckButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category></class><class><name>ParagraphEditor</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Support</category></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category></class><class><name>MotifRadioButtonView</name><environment>UI</environment><super>UI.RadioButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ParagraphEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category></class><class><name>ComboBoxButtonView</name><environment>UI</environment><super>UI.BasicButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editorView list forceScrollBar maxLines textStyle lastSelectionIndex multiCharSearch continuousAccept </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>UISpecification</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category></class><class><name>NamedSpec</name><environment>UI</environment><super>UI.ComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name flags isOpaque colors </inst-vars><class-inst-vars>paletteIcon </class-inst-vars><imports></imports><category>UIBuilder-Specifications</category></class><class><name>TextEditorSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alignment style isReadOnly tabRequiresControl isWrapped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category></class><class><name>SliderSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orientation start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category></class><class><name>MenuButtonSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu isList isPopUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category></class><class><name>ComboBoxSpec</name><environment>UI</environment><super>UI.InputFieldSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comboList readSelector printSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category></class><class><name>SequenceViewSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multipleSelections style useModifierKeys selectionType autoSelect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category></class><class><name>ScrollWrapper</name><environment>UI</environment><super>Graphics.TranslatingWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents preferredBoundsBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category></class><class><name>ComboBoxListView</name><environment>UI</environment><super>UI.SequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttonController editorController </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>ComposedTextView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayContents startBlock stopBlock selectionShowing displaySelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>TextEditorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>ComboBoxInputFieldView</name><environment>UI</environment><super>UI.InputFieldView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>MenuItemController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>MenuBar</name><environment>UI</environment><super>UI.ComposingComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuChannel performer menuButtons nextMenuButton </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>MenuController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scrollWrapper state isEventDriven eventDispatcher scrollProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>MenuFromMenuBarController</name><environment>UI</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>GroupBox</name><environment>UI</environment><super>UI.SimpleComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label border textStyle mnemonic controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>SliderView</name><environment>UI</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>axis markerBlock markerLength marker color1 color2 markerBorder rangeMap helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>ComboBoxInputBoxController</name><environment>UI</environment><super>UI.InputBoxController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttonController </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category></class><class><name>ActionButtonView</name><environment>UI</environment><super>UI.PushButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>MotifActionButtonView</name><environment>UI</environment><super>UI.ActionButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category></class><class><name>UndecoratedActionButtonView</name><environment>UI</environment><super>UI.ActionButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hiliteSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>MenuBarButtonView</name><environment>UI</environment><super>UI.PushButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder menuBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class><class><name>MotifMenuBarButtonView</name><environment>UI</environment><super>UI.MenuBarButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessCharacter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category></class><class><name>VisualDivider</name><environment>UI</environment><super>UI.SimpleComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orientation lineWidth etched </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category></class></st-source>