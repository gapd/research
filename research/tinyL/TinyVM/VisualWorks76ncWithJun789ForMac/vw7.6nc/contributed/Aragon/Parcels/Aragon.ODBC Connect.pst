<?xml version="1.0"?><st-source><!-- Name: Aragon.ODBC ConnectComment: Aragon ODBC Connect is an implementation of VisualWorks' External Database Interface (EXDI) as well as the Object Lens layer for use with ODBC data sources. After having loaded this parcel you might want to load VisualWorks' Lens-Dev parcel in order to use the Database Modeler tool. HideSource: falseParcel: #('Aragon.ODBC Connect')PrerequisiteParcels: #(#('Database' '') #('Lens-Runtime' '') #('Aragon.Basics' ''))SaveSource: trueVersion: 7.1Date: 6:23:06 am May 28, 2003 --><time-stamp>From VisualWorks®, Release 7.1 of 18. März 2003 on 28. Mai 2003 at 6:23:06</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ODBCParameterBuffer</name><environment>Aragon</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rgbValue pcbValue mapping size </inst-vars><class-inst-vars></class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.EXDI Support</category></class><class><name>ODBCLensTable</name><environment>Aragon</environment><super>Lens.LensDatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name owner tableType columns qualifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.ODBC.ObjectLens</category></class><class><name>ODBCTransaction</name><environment>Aragon</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.ODBC.EXDI Support</category></class><comment><class-id>Aragon.ODBCTransaction</class-id><body>Class ODBCTransaction is a private abstract class used by the external database interface to manage transaction services on behalf of one or more connections. ODBCTransaction reduces the differences between independent and coordinated (sometimes called distributed) database transaction styles.  Independent transactions limit the unit of work to a single connection with a database.  Coordinated transactions allow multiple concurrent connections to comprise the unit of work.  For either independent or coordinated transactions, commiting or aborting all changes made during the unit of work should be atomic.ODBCTransaction unifies these two transaction styles by allowing multiple connections (of the same driver) to be coordinated whether or not there is direct support from the underlying database system.  A *two-phase commit* protocol is required to assure atomicity for the unit of work. When a two-phase commit protocol is not available, a less rigorous serial broadcast strategy is used.  In this approach, each connection is asked to commit or rollback in turn.  If there is a system or network failure before all have completed the work, it is possible that not all will perform the same action to complete the transaction.  The application is responsible for recovery in the event that not all commits are completed.Implementation Considerations:Participation relationships:	An instance of the connection subclasses will participate in an instance of the	transaction subclass.Inherited instance variables:	stateHolder			&lt;ValueHolder on: (#xactNo | #xactYes | #committing | #aborting | #paused)&gt;		The state variable is used to track the legal operations on transactions.	traceStream		&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants		&lt;WeakArray of: ExternalDatabaseConnection&gt;		The connection instances that are coordinated via the transaction instance.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection on uses of the participants array. Instance variables:	memberCountHolder	&lt;ValueHolder on: SmallInteger&gt;		A count of the number of connections that are members of the current transaction.	remainingCountHolder	&lt;ValueHolder on: SmallInteger&gt;		A count of the number of connections that remain members of the current transaction.		If this number is less than the number held in memberCount, we are in the		#committed or #aborting states.  This will persist until the last executor is heard from.Subclasses must implement the following messages	instance protocol		private-library calls			beginExternal			commitExternal			rollbackExternal </body></comment><class><name>ODBCInterface</name><environment>Aragon</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.DLL Interface</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>odbc32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel></attributes></class><class><name>ODBCSession</name><environment>Aragon</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmt affectedRows parameterBuffers </inst-vars><class-inst-vars>registry </class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.EXDI Support</category></class><comment><class-id>Aragon.ODBCSession</class-id><body>ODBCSession is the abstract class defining the application interface to executing prepared SQL statements or stored procedures, describing the results of the execution, and acquiring streams of results.Inherited instance variables:	stateHolder &lt;ValueHolder on: (#new | #connected | #prepared | #executing | #ready | #validResults | #fetchingData | #paused)&gt;			The state variable is used to track the legal operations on sessions.	traceStream &lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants &lt;WeakArray of: ExternalDatabaseAnswerStream&gt;		The answer stream instance that participates in this session.  There will never be		more than one.	participantsSemaphore &lt;RecursionLock&gt;		Used for mutual exclusion protection of uses of the participants array.Instance variables:	connection &lt;ExternalDatabaseConnection&gt;		The connection context in which this session executes		SQL statements or stored procedures.	query &lt;String&gt;		The SQL query provided by the client.	queryFragments &lt;Collection of: (String | SmallInteger | Symbol)&gt;		The query, canonized for parameter binding.	bindInput &lt;Object | nil&gt;		The object to obtain bind values from, if any are required.	bindOutput &lt;Object | nil&gt;		The bind object to use for output rows.  If nil, output rows are instances of Array.	bindValues &lt;IdentityDictionary&gt;		A private dictionary, keyed by bind position, of values bound to parameters.		Used to avoid unneccessary rebinds.	useNamedOutputBinding &lt;Boolean&gt;		Determines if the output bind object should be populated by sending it mutators		fashined from the column names.  The default is populate the bind object		by directly indexing its instance variables.	allocateForEachRow	&lt;Boolean&gt;		When true (the default), the answer stream will create a copy of the output bind		object for each row.  When false, the answer stream will use the same bind object		repeatedly.	blockFactor	&lt;SmallInteger&gt;		The number of rows to fetch in a block from the dbms server.	currentRow &lt;Object | nil&gt;		A copy of the session's bindOutput object.  The adaptors used to insert values		into the appropriate repository for each column are given this.	numColumns &lt;SmallInteger&gt;		The number of columns in the answer set.	columnDescriptions &lt;(Array of: ExternalDatabaseColumnDescription) | nil&gt;		Array containing a description of each column in the answer set.	rowAdaptors &lt;Array of: BlockClosure&gt;		A block for each column of the output.  Each block takes two arguments		(subject and value) and is responsible for inserting the value into the instance		or indexed variable of the subject.	rowBuffersHolder &lt;ValueHolder on: (Array of: (ExternalDatabaseBuffer | Array))&gt;		Each driver will need space to store the data as it is returned from the		dbms api.  For systems which do not fetch rows directly into predeclared		buffer, it is still important to allocate these buffers once to avoid the overhead		of constantly allocating and deallocating space.	answerStream &lt;ExternalDatabaseAnswerStream | nil&gt;		A reference to the active answer stream.	bindTemplate &lt;Object&gt;		Private variable for Object Lens use.	resultTemplate &lt;Object&gt;		Private variable for Object Lens use.	bufferIndex &lt;SmallInteger&gt;		Private variable for Object Lens use.Subclasses must implement the following messages	instance protocol		data processing			rowCount		private-answer set			advanceExternal			allocateRowBufferExternal:			getColumnDescriptionExternal:			hasAnswerSetExternal			getFieldExternal:			cancelAnswerSetExternal		private-execution			executeExternal			readyExternal			resultsExternal			moreResultsExternal			cancelExternal		private-binding			prepareExternal			bindValue:at:		schema access			listTablesLike:			describeColumns:		private-ObjectLens			bindInput:template:to:			flattenResultTemplate:onto:			nextViaTemplate:</body></comment><class><name>ODBCLensTableColumn</name><environment>Aragon</environment><super>Lens.LensDatabaseTableColumn</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table notNil type name maxColumnConstraint isKey nativeType </inst-vars><class-inst-vars></class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.ObjectLens</category></class><class><name>ODBCMainApplication</name><environment>Aragon</environment><super>Lens.LensMainApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.ODBC.ObjectLens</category></class><class><name>ODBCDatabaseBuffer</name><environment>Aragon</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cType lengthPointer getBlock isLarge </inst-vars><class-inst-vars></class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.EXDI Support</category></class><class><name>ODBCLensTransporter</name><environment>Aragon</environment><super>Lens.LensSQLTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.ODBC.ObjectLens</category></class><class><name>ODBCLensContext</name><environment>Aragon</environment><super>Lens.LensDatabaseContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nativeTypeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.ODBC.ObjectLens</category></class><class><name>ODBCTypeMapping</name><environment>Aragon</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cName sqlName class cTypeDef cTypeCode sqlTypeCode maxSize bufferBlock putBlock getBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.EXDI Support</category></class><class><name>ODBCColumnDescription</name><environment>Aragon</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlTypeCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.EXDI Support</category></class><comment><class-id>Aragon.ODBCColumnDescription</class-id><body>same as superclass, additionally storing the SQL type code for 'SQLBindColumn'</body></comment><class><name>ODBCConnection</name><environment>Aragon</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hdbc henv serialNumberQuery </inst-vars><class-inst-vars>registry </class-inst-vars><imports>			private Aragon.ODBCInterfaceDictionary.*			</imports><category>Aragon.ODBC.EXDI Support</category></class><comment><class-id>Aragon.ODBCConnection</class-id><body>ODBCConnection is the abstract class defining database connection services.The maximum number of active connections is controlled by the driver.All drivers are required to support coordinated transactions.  If full atomic behavior is not available, it is simulated with a serial broadcast commit on each participating connection.  A two-phase commit protocol would ensure true coordination for commits and rollbacks.Implementation Details:Participation relationships:	An instance of the connection subclasses will participate in an instance of the	transaction subclass.  An instance of the session subclass will participate	in an instance of the connection subclass.Inherited instance variables:	stateHolder			&lt;ValueHolder on: (#new | #xactNo | #xactYes | #paused)&gt;		The state variable is used to track the legal operations on connections.	traceStream		&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants			&lt;WeakArray of: ExternalDatabaseSession&gt;		The session instances that participate in the connection.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection of uses of the participants array.Instance variables:	transaction			&lt;ExternalDatabaseTransaction | nil&gt;		Transaction that this connection is a part of.	username			&lt;String | nil&gt;			Name of current user; driver will signal if required and == nil.	password			&lt;String | nil&gt;		Password of current user; driver will signal if required and == nil.	environment			&lt;String | nil&gt;			Logical or physical name for environment; driver will signal if required and == nil.	transactionCoordinator &lt;ValueHolder on: Boolean&gt;		Holds true if this connection is a transaction coordinator for other connections.	cachedSession &lt;nil | ExternalDatabaseSession&gt;		Holds onto a session for reuse by getSession.	isolationLevel &lt; Symbol | nil&gt;		Holds the isolationLevel for this connection.Class variables:	DefaultConnection			&lt;Symbol | nil&gt;		Contains name of subclass to use when creating a new connection.	DefaultEnvironment	&lt;String | nil&gt;		Contains logical environment to use as a default for connecting.	StandardSignals		&lt;IdentityDictionary of: Signal&gt;		Maps signal names to signals.	PlatformType &lt;nil | Symbol&gt;		Platform/OS type that we're running on.  Used to select an platform-specific		ExternalInterface subclass.Class instance variables:	environmentMap		&lt;Dictionary | nil&gt;		Each driver maintains a map of logical to physical environments.Subclasses must implement the following messages:	instance protocol		private-library calls			acquireExternal:	class protocol		accessing			sessionClass			transactionClass			kind		activation			pause			resume		private-accessing			call		private-activation			install</body></comment><shared-variable><name>ExternalBuffers</name><environment>Aragon.ODBCInterface</environment><private>false</private><constant>false</constant><category>Globals</category></shared-variable><shared-variable><name>GenericErrorSignal</name><environment>Aragon.ODBCInterface</environment><private>false</private><constant>false</constant><category>Globals</category></shared-variable><shared-variable><name>DriverInfoString</name><environment>Aragon.ODBCInterface</environment><private>false</private><constant>false</constant><category>Globals</category></shared-variable><shared-variable><name>ErrorSignals</name><environment>Aragon.ODBCInterface</environment><private>false</private><constant>false</constant><category>Globals</category></shared-variable><shared-variable><name>CTypes</name><environment>Aragon.ODBCTypeMapping</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>Mappings</name><environment>Aragon.ODBCTypeMapping</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>St2Odbc</name><environment>Aragon.ODBCTypeMapping</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>Odbc2St</name><environment>Aragon.ODBCTypeMapping</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>ColumnDescriptionBuffer</name><environment>Aragon.ODBCSession</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>MaxLengths</name><environment>Aragon.ODBCColumnDescription</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DatasourceNameSeparator</name><environment>Aragon.ODBCConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><methods><class-id>Aragon.ODBCParameterBuffer</class-id> <category>initialize-release</category><body>initialize	pcbValue := SDWORD malloc.</body><body>release	rgbValue isNil ifFalse: [rgbValue free. rgbValue := nil].	pcbValue isNil ifFalse: [pcbValue free. pcbValue := nil].</body></methods><methods><class-id>Aragon.ODBCParameterBuffer</class-id> <category>accessing</category><body>mapping	^mapping</body><body>pcbValue	^pcbValue</body><body>rgbValue	^rgbValue</body><body>size	^size</body><body>value: aValue 	| newMapping oldSize answer value isNts |	oldSize := self size.	value := aValue class == Text ifTrue: [aValue asString] ifFalse: [aValue].	value := aValue class == GapString ifTrue: [aValue asByteString] ifFalse: [aValue].	size := value class isVariableSize				ifTrue: 					[(isNts := value isKindOf: String)						ifTrue: [pcbValue contents: SQL_NTS value]						ifFalse: [pcbValue contents: value size].					value size]				ifFalse: 					[value isNil 						ifTrue: [pcbValue contents: SQL_NULL_DATA value]						ifFalse: [pcbValue contents: 0 "ignored"].					value basicSize].	newMapping := ODBCTypeMapping for: value.	(newMapping ~~ mapping or: [size &gt; oldSize])		ifTrue: 			[mapping := newMapping.			rgbValue isNil ifFalse: [rgbValue free].			rgbValue := mapping bufferBlock value: size+1.			answer := #rebind]		ifFalse: [answer := #reuse].	"value has exactly the same data type and mapping as the recent parameter value. Furthermore	if it is a collection (String, or raw binary data), its size doesn't exceed the size of the recent value.	So we can certainly reuse the previously allocated buffer by simply writing the new contents to it."	mapping putBlock value: rgbValue value: value.	isNts == true ifTrue: [size := 0].	^answer</body></methods><methods><class-id>Aragon.ODBCLensTable</class-id> <category>initialize-release</category><body>initializeFrom: aDictionary 	name := aDictionary at: #name.	owner := aDictionary at: #owner.	tableType := aDictionary at: #tableType.	qualifier := aDictionary at: #qualifier.</body></methods><methods><class-id>Aragon.ODBCLensTable</class-id> <category>accessing</category><body>columns	"Answer the receiver's columns."	^columns</body><body>columns: aValue	columns := aValue</body><body>name	^name</body><body>name: aValue	name := aValue</body><body>owner	^owner</body><body>owner: aValue	owner := aValue</body><body>qualifier"generated"	^qualifier</body><body>qualifier: aValue	qualifier:= aValue.</body><body>qualify: aLensDataModel</body><body>tableType	^tableType</body><body>tableType: ttype	tableType := ttype</body><body>unqualify</body></methods><methods><class-id>Aragon.ODBCLensTable</class-id> <category>key detection</category><body>getPrimaryKeyIn: aLensSession	"Answer the primary key for this table by looking it up in the database catalogs.  Answer an instance of LensTableKey or nil."	| keys |	keys := (aLensSession connection getSession getPrimaryKeysFor: self name) 		collect: [:s | self columns detect: [:c | c name = s]].		^keys isEmpty ifFalse: [LensTableKey table: self columns: keys keyType: #primary]</body><body>inferReferencesIn: aLensSession 	"We use tables also as non-persistent objects, therefore, aLensSession is passed 	to this method and the table's own lens is not used (if it even had one). This method	returns a collection with arrays representing references from the table to other tables"	Dialog warn: 'Infering foreign key references is not supported by ODBC Connect.'.	LensSession doNotProceedSignal raise.</body></methods><methods><class-id>Aragon.ODBCLensTable</class-id> <category>DDL generation</category><body>alterColumnCommand: column operation: operation 	"Answer a command to add or modify a column in a table. If the modification is to the type then do not emit the nullness part"	| stream |	stream := WriteStream on: String new.	stream nextPutAll: 'ALTER TABLE ' , self qualifiedName.	operation == #add		ifTrue: 			[stream nextPutAll: ' ADD COLUMN '.			column putDefinitionOn: stream]		ifFalse:	[operation == #drop ifTrue: [stream nextPutAll: ' DROP COLUMN ', column name]].	^stream contents</body></methods><methods><class-id>Aragon.ODBCLensTable</class-id> <category>As yet unclassified</category><body>printNameOn: aStream	self qualifier == nil ifFalse:		[ aStream			nextPutAll: self qualifier;			nextPut: $. ].	super printNameOn: aStream</body></methods><methods><class-id>Aragon.ODBCLensTable class</class-id> <category>accessing</category><body>contextClass	^ODBCLensContext</body></methods><methods><class-id>Aragon.ODBCTransaction</class-id> <category>private-accessing</category><body>xif	^self class connectionClass xif</body></methods><methods><class-id>Aragon.ODBCTransaction</class-id> <category>private-library calls</category><body>acquireExternal	"Acquire the external resources. If the external resources	cannot be acquired, an exception is raised."</body><body>beginExternal	"Perform driver-specific work at the beginning of a transaction."</body><body>commitExternal	"Perform driver-specific work at the completion of a transaction."	self participantsDo: [:each | each commitExternal].</body><body>dismissExternal	"Release the external resources."	"All activity within this method must function with only the instance	variables defined in the executor object."</body><body>rollbackExternal	"Perform driver-specific work at the rollback of a transaction."	self participantsDo: [:each | each rollbackExternal].</body></methods><methods><class-id>Aragon.ODBCTransaction class</class-id> <category>private-accessing</category><body>connectionClass	"Answer the class to use for connection objects associated with receiver."	^ODBCConnection</body></methods><methods><class-id>Aragon.ODBCInterface</class-id> <category>public-inquiry</category><body>bufferFor: aCType	^ExternalBuffers at: aCType ifAbsent: [ExternalBuffers at: aCType put: aCType malloc]</body><body>errorMsgFor: aStatement env: henv dbc: hdbc stmt: hstmt	| errorInfo |	errorInfo := self getErrorInfo: henv dbc: hdbc stmt: hstmt.^errorInfo last, 'ODBC call was:	', aStatement, 'SQL state:		', errorInfo first.</body><body>getDriverInfoAbout: aTopic dbc: hdbc type: aType 	| topic buffer typeOfBuffer |	topic := aTopic value.	(typeOfBuffer := aType) == String ifTrue: [typeOfBuffer := DriverInfoString].	buffer := self bufferFor: typeOfBuffer.	self		SQLGetInfo: hdbc		with: topic		with: buffer		with: typeOfBuffer sizeof		with: nil.	^typeOfBuffer isArray		ifTrue: [buffer copyCStringFromHeap]		ifFalse: [buffer contents]</body><body>getErrorInfo: henv dbc: hdbc stmt: hstmt	| message sqlState d2 d3 |	message := self bufferFor: self ERROR_MSG.	sqlState := self bufferFor: self SQL_STATE.	d2 := self bufferFor: self SDWORD.	d3 := self bufferFor: self SWORD.	(self SQLError: henv with: hdbc with: hstmt with: sqlState with: d2 with: message with: 400 with: d3)		~= self SQL_SUCCESS ifTrue: [^ExternalDatabaseError new dbmsErrorString: 'Couldn''t get an error message from the ODBC driver'].	^ExternalDatabaseError new		dbmsErrorCode: sqlState copyCStringFromHeap; 		dbmsErrorString: message copyCStringFromHeap</body><body>handleError: sqlError in: aStatement env: henv dbc: hdbc stmt: hstmt 	| dbError message |	dbError := self getErrorInfo: henv dbc: hdbc stmt: hstmt.	dbError dbmsErrorCode = '01004' 		ifTrue: [^Transcript show: 'WARNING: ', dbError errorString; cr].	dbError osErrorCode: sqlError.	message := '==================================' , dbError dbmsErrorString , 'ODBC call was:	' , thisContext sender sender selector.	dbError dbmsErrorCode notNil ifTrue: [message := message , 'SQL state:		' , dbError dbmsErrorCode].	(ODBCInterface errorSignalsDictionary at: sqlError)		raiseRequestWith: (Array with: dbError) errorString: message</body></methods><methods><class-id>Aragon.ODBCInterface</class-id> <category>types</category><body>BOOKMARK	&lt;C: typedef unsigned long BOOKMARK&gt;</body><body>ERROR_MSG	&lt;C: typedef char ERROR_MSG[401]&gt;</body><body>HANDLE	&lt;C: typedef void * HANDLE&gt;</body><body>HDBC	&lt;C: typedef void * HDBC&gt;</body><body>HENV	&lt;C: typedef void * HENV&gt;</body><body>HSTMT	&lt;C: typedef void * HSTMT&gt;</body><body>HWND	&lt;C: typedef void * HWND&gt;</body><body>LDOUBLE	&lt;C: typedef double LDOUBLE&gt;</body><body>PTR	&lt;C: typedef void * PTR&gt;</body><body>RETCODE	&lt;C: typedef short RETCODE&gt;</body><body>SCHAR	&lt;C: typedef char SCHAR&gt;</body><body>SDOUBLE	&lt;C: typedef double SDOUBLE&gt;</body><body>SDWORD	&lt;C: typedef long SDWORD&gt;</body><body>SFLOAT	&lt;C: typedef float SFLOAT&gt;</body><body>SLONG	&lt;C: typedef long SLONG&gt;</body><body>SQL_STATE	&lt;C: typedef char SQL_STATE[25]&gt;</body><body>SSHORT	&lt;C: typedef short SSHORT&gt;</body><body>SWORD	&lt;C: typedef short SWORD&gt;</body><body>UCHAR	&lt;C: typedef unsigned char UCHAR&gt;</body><body>UDWORD	&lt;C: typedef unsigned long UDWORD&gt;</body><body>ULONG	&lt;C: typedef unsigned long ULONG&gt;</body><body>USHORT	&lt;C: typedef unsigned short USHORT&gt;</body><body>UWORD	&lt;C: typedef unsigned short UWORD&gt;</body></methods><methods><class-id>Aragon.ODBCInterface</class-id> <category>structs</category><body>tagDATE_STRUCT	&lt;C: struct tagDATE_STRUCT {			SWORD year;			UWORD month, day;		}&gt;</body><body>tagTIMESTAMP_STRUCT	&lt;C: struct tagTIMESTAMP_STRUCT {			SWORD year;			UWORD month, day, hour, minute, second;			UDWORD fraction;		}&gt;</body><body>tagTIME_STRUCT	&lt;C: struct tagTIME_STRUCT {			UWORD hour, minute, second;		}&gt;</body></methods><methods><class-id>Aragon.ODBCInterface</class-id> <category>defines</category><body>ODBCVER	&lt;C: #define ODBCVER 513	&gt;</body><body>SQL_ACCESSIBLE_PROCEDURES	&lt;C: #define SQL_ACCESSIBLE_PROCEDURES 20	&gt;</body><body>SQL_ACCESSIBLE_TABLES	&lt;C: #define SQL_ACCESSIBLE_TABLES 19	&gt;</body><body>SQL_ACCESS_MODE	&lt;C: #define SQL_ACCESS_MODE 101	&gt;</body><body>SQL_ACTIVE_CONNECTIONS	&lt;C: #define SQL_ACTIVE_CONNECTIONS 0	&gt;</body><body>SQL_ACTIVE_STATEMENTS	&lt;C: #define SQL_ACTIVE_STATEMENTS 1	&gt;</body><body>SQL_ADD	&lt;C: #define SQL_ADD 4	&gt;</body><body>SQL_ALL_EXCEPT_LIKE	&lt;C: #define SQL_ALL_EXCEPT_LIKE 2	&gt;</body><body>SQL_ALL_TYPES	&lt;C: #define SQL_ALL_TYPES 0	&gt;</body><body>SQL_ALTER_TABLE	&lt;C: #define SQL_ALTER_TABLE 86	&gt;</body><body>SQL_API_ALL_FUNCTIONS	&lt;C: #define SQL_API_ALL_FUNCTIONS 0	&gt;</body><body>SQL_API_LOADBYORDINAL	&lt;C: #define SQL_API_LOADBYORDINAL 199	&gt;</body><body>SQL_API_SQLALLOCCONNECT	&lt;C: #define SQL_API_SQLALLOCCONNECT 1	&gt;</body><body>SQL_API_SQLALLOCENV	&lt;C: #define SQL_API_SQLALLOCENV 2	&gt;</body><body>SQL_API_SQLALLOCSTMT	&lt;C: #define SQL_API_SQLALLOCSTMT 3	&gt;</body><body>SQL_API_SQLBINDCOL	&lt;C: #define SQL_API_SQLBINDCOL 4	&gt;</body><body>SQL_API_SQLBINDPARAMETER	&lt;C: #define SQL_API_SQLBINDPARAMETER 72	&gt;</body><body>SQL_API_SQLBROWSECONNECT	&lt;C: #define SQL_API_SQLBROWSECONNECT 55	&gt;</body><body>SQL_API_SQLCANCEL	&lt;C: #define SQL_API_SQLCANCEL 5	&gt;</body><body>SQL_API_SQLCOLATTRIBUTES	&lt;C: #define SQL_API_SQLCOLATTRIBUTES 6	&gt;</body><body>SQL_API_SQLCOLUMNPRIVILEGES	&lt;C: #define SQL_API_SQLCOLUMNPRIVILEGES 56	&gt;</body><body>SQL_API_SQLCOLUMNS	&lt;C: #define SQL_API_SQLCOLUMNS 40	&gt;</body><body>SQL_API_SQLCONNECT	&lt;C: #define SQL_API_SQLCONNECT 7	&gt;</body><body>SQL_API_SQLDATASOURCES	&lt;C: #define SQL_API_SQLDATASOURCES 57	&gt;</body><body>SQL_API_SQLDESCRIBECOL	&lt;C: #define SQL_API_SQLDESCRIBECOL 8	&gt;</body><body>SQL_API_SQLDESCRIBEPARAM	&lt;C: #define SQL_API_SQLDESCRIBEPARAM 58	&gt;</body><body>SQL_API_SQLDISCONNECT	&lt;C: #define SQL_API_SQLDISCONNECT 9	&gt;</body><body>SQL_API_SQLDRIVERCONNECT	&lt;C: #define SQL_API_SQLDRIVERCONNECT 41	&gt;</body><body>SQL_API_SQLDRIVERS	&lt;C: #define SQL_API_SQLDRIVERS 71	&gt;</body><body>SQL_API_SQLERROR	&lt;C: #define SQL_API_SQLERROR 10	&gt;</body><body>SQL_API_SQLEXECDIRECT	&lt;C: #define SQL_API_SQLEXECDIRECT 11	&gt;</body><body>SQL_API_SQLEXECUTE	&lt;C: #define SQL_API_SQLEXECUTE 12	&gt;</body><body>SQL_API_SQLEXTENDEDFETCH	&lt;C: #define SQL_API_SQLEXTENDEDFETCH 59	&gt;</body><body>SQL_API_SQLFETCH	&lt;C: #define SQL_API_SQLFETCH 13	&gt;</body><body>SQL_API_SQLFOREIGNKEYS	&lt;C: #define SQL_API_SQLFOREIGNKEYS 60	&gt;</body><body>SQL_API_SQLFREECONNECT	&lt;C: #define SQL_API_SQLFREECONNECT 14	&gt;</body><body>SQL_API_SQLFREEENV	&lt;C: #define SQL_API_SQLFREEENV 15	&gt;</body><body>SQL_API_SQLFREESTMT	&lt;C: #define SQL_API_SQLFREESTMT 16	&gt;</body><body>SQL_API_SQLGETCONNECTOPTION	&lt;C: #define SQL_API_SQLGETCONNECTOPTION 42	&gt;</body><body>SQL_API_SQLGETCURSORNAME	&lt;C: #define SQL_API_SQLGETCURSORNAME 17	&gt;</body><body>SQL_API_SQLGETDATA	&lt;C: #define SQL_API_SQLGETDATA 43	&gt;</body><body>SQL_API_SQLGETFUNCTIONS	&lt;C: #define SQL_API_SQLGETFUNCTIONS 44	&gt;</body><body>SQL_API_SQLGETINFO	&lt;C: #define SQL_API_SQLGETINFO 45	&gt;</body><body>SQL_API_SQLGETSTMTOPTION	&lt;C: #define SQL_API_SQLGETSTMTOPTION 46	&gt;</body><body>SQL_API_SQLGETTYPEINFO	&lt;C: #define SQL_API_SQLGETTYPEINFO 47	&gt;</body><body>SQL_API_SQLMORERESULTS	&lt;C: #define SQL_API_SQLMORERESULTS 61	&gt;</body><body>SQL_API_SQLNATIVESQL	&lt;C: #define SQL_API_SQLNATIVESQL 62	&gt;</body><body>SQL_API_SQLNUMPARAMS	&lt;C: #define SQL_API_SQLNUMPARAMS 63	&gt;</body><body>SQL_API_SQLNUMRESULTCOLS	&lt;C: #define SQL_API_SQLNUMRESULTCOLS 18	&gt;</body><body>SQL_API_SQLPARAMDATA	&lt;C: #define SQL_API_SQLPARAMDATA 48	&gt;</body><body>SQL_API_SQLPARAMOPTIONS	&lt;C: #define SQL_API_SQLPARAMOPTIONS 64	&gt;</body><body>SQL_API_SQLPREPARE	&lt;C: #define SQL_API_SQLPREPARE 19	&gt;</body><body>SQL_API_SQLPRIMARYKEYS	&lt;C: #define SQL_API_SQLPRIMARYKEYS 65	&gt;</body><body>SQL_API_SQLPROCEDURECOLUMNS	&lt;C: #define SQL_API_SQLPROCEDURECOLUMNS 66	&gt;</body><body>SQL_API_SQLPROCEDURES	&lt;C: #define SQL_API_SQLPROCEDURES 67	&gt;</body><body>SQL_API_SQLPUTDATA	&lt;C: #define SQL_API_SQLPUTDATA 49	&gt;</body><body>SQL_API_SQLROWCOUNT	&lt;C: #define SQL_API_SQLROWCOUNT 20	&gt;</body><body>SQL_API_SQLSETCONNECTOPTION	&lt;C: #define SQL_API_SQLSETCONNECTOPTION 50	&gt;</body><body>SQL_API_SQLSETCURSORNAME	&lt;C: #define SQL_API_SQLSETCURSORNAME 21	&gt;</body><body>SQL_API_SQLSETPARAM	&lt;C: #define SQL_API_SQLSETPARAM 22	&gt;</body><body>SQL_API_SQLSETPOS	&lt;C: #define SQL_API_SQLSETPOS 68	&gt;</body><body>SQL_API_SQLSETSCROLLOPTIONS	&lt;C: #define SQL_API_SQLSETSCROLLOPTIONS 69	&gt;</body><body>SQL_API_SQLSETSTMTOPTION	&lt;C: #define SQL_API_SQLSETSTMTOPTION 51	&gt;</body><body>SQL_API_SQLSPECIALCOLUMNS	&lt;C: #define SQL_API_SQLSPECIALCOLUMNS 52	&gt;</body><body>SQL_API_SQLSTATISTICS	&lt;C: #define SQL_API_SQLSTATISTICS 53	&gt;</body><body>SQL_API_SQLTABLEPRIVILEGES	&lt;C: #define SQL_API_SQLTABLEPRIVILEGES 70	&gt;</body><body>SQL_API_SQLTABLES	&lt;C: #define SQL_API_SQLTABLES 54	&gt;</body><body>SQL_API_SQLTRANSACT	&lt;C: #define SQL_API_SQLTRANSACT 23	&gt;</body><body>SQL_ASYNC_ENABLE	&lt;C: #define SQL_ASYNC_ENABLE 4	&gt;</body><body>SQL_ASYNC_ENABLE_DEFAULT	&lt;C: #define SQL_ASYNC_ENABLE_DEFAULT SQL_ASYNC_ENABLE_OFF	&gt;</body><body>SQL_ASYNC_ENABLE_OFF	&lt;C: #define SQL_ASYNC_ENABLE_OFF 0L	&gt;</body><body>SQL_ASYNC_ENABLE_ON	&lt;C: #define SQL_ASYNC_ENABLE_ON 1L	&gt;</body><body>SQL_ATTR_READONLY	&lt;C: #define SQL_ATTR_READONLY 0	&gt;</body><body>SQL_ATTR_READWRITE_UNKNOWN	&lt;C: #define SQL_ATTR_READWRITE_UNKNOWN 2	&gt;</body><body>SQL_ATTR_WRITE	&lt;C: #define SQL_ATTR_WRITE 1	&gt;</body><body>SQL_AT_ADD_COLUMN	&lt;C: #define SQL_AT_ADD_COLUMN 0x00000001	&gt;</body><body>SQL_AT_DROP_COLUMN	&lt;C: #define SQL_AT_DROP_COLUMN 0x00000002	&gt;</body><body>SQL_AUTOCOMMIT	&lt;C: #define SQL_AUTOCOMMIT 102	&gt;</body><body>SQL_AUTOCOMMIT_DEFAULT	&lt;C: #define SQL_AUTOCOMMIT_DEFAULT SQL_AUTOCOMMIT_ON	&gt;</body><body>SQL_AUTOCOMMIT_OFF	&lt;C: #define SQL_AUTOCOMMIT_OFF 0L	&gt;</body><body>SQL_AUTOCOMMIT_ON	&lt;C: #define SQL_AUTOCOMMIT_ON 1L	&gt;</body><body>SQL_BEST_ROWID	&lt;C: #define SQL_BEST_ROWID 1	&gt;</body><body>SQL_BIGINT	&lt;C: #define SQL_BIGINT (-5)	&gt;</body><body>SQL_BINARY	&lt;C: #define SQL_BINARY (-2)	&gt;</body><body>SQL_BIND_BY_COLUMN	&lt;C: #define SQL_BIND_BY_COLUMN 0 L	&gt;</body><body>SQL_BIND_TYPE	&lt;C: #define SQL_BIND_TYPE 5	&gt;</body><body>SQL_BIT	&lt;C: #define SQL_BIT (-7)	&gt;</body><body>SQL_BOOKMARK_PERSISTENCE	&lt;C: #define SQL_BOOKMARK_PERSISTENCE 82	&gt;</body><body>SQL_BP_CLOSE	&lt;C: #define SQL_BP_CLOSE 0x00000001	&gt;</body><body>SQL_BP_DELETE	&lt;C: #define SQL_BP_DELETE 0x00000002	&gt;</body><body>SQL_BP_DROP	&lt;C: #define SQL_BP_DROP 0x00000004	&gt;</body><body>SQL_BP_OTHER_HSTMT	&lt;C: #define SQL_BP_OTHER_HSTMT 0x00000020	&gt;</body><body>SQL_BP_SCROLL	&lt;C: #define SQL_BP_SCROLL 0x00000040	&gt;</body><body>SQL_BP_TRANSACTION	&lt;C: #define SQL_BP_TRANSACTION 0x00000008	&gt;</body><body>SQL_BP_UPDATE	&lt;C: #define SQL_BP_UPDATE 0x00000010	&gt;</body><body>SQL_CASCADE	&lt;C: #define SQL_CASCADE 0	&gt;</body><body>SQL_CB_CLOSE	&lt;C: #define SQL_CB_CLOSE 0x0001	&gt;</body><body>SQL_CB_DELETE	&lt;C: #define SQL_CB_DELETE 0x0000	&gt;</body><body>SQL_CB_NON_NULL	&lt;C: #define SQL_CB_NON_NULL 0x0001	&gt;</body><body>SQL_CB_NULL	&lt;C: #define SQL_CB_NULL 0x0000	&gt;</body><body>SQL_CB_PRESERVE	&lt;C: #define SQL_CB_PRESERVE 0x0002	&gt;</body><body>SQL_CC_CLOSE	&lt;C: #define SQL_CC_CLOSE SQL_CB_CLOSE	&gt;</body><body>SQL_CC_DELETE	&lt;C: #define SQL_CC_DELETE SQL_CB_DELETE	&gt;</body><body>SQL_CC_PRESERVE	&lt;C: #define SQL_CC_PRESERVE SQL_CB_PRESERVE	&gt;</body><body>SQL_CHAR	&lt;C: #define SQL_CHAR 1	&gt;</body><body>SQL_CLOSE	&lt;C: #define SQL_CLOSE 0	&gt;</body><body>SQL_CN_ANY	&lt;C: #define SQL_CN_ANY 0x0002	&gt;</body><body>SQL_CN_DIFFERENT	&lt;C: #define SQL_CN_DIFFERENT 0x0001	&gt;</body><body>SQL_CN_NONE	&lt;C: #define SQL_CN_NONE 0x0000	&gt;</body><body>SQL_COLATT_OPT_MAX	&lt;C: #define SQL_COLATT_OPT_MAX SQL_COLUMN_LABEL	&gt;</body><body>SQL_COLATT_OPT_MIN	&lt;C: #define SQL_COLATT_OPT_MIN SQL_COLUMN_COUNT	&gt;</body><body>SQL_COLUMN_ALIAS	&lt;C: #define SQL_COLUMN_ALIAS 87	&gt;</body><body>SQL_COLUMN_AUTO_INCREMENT	&lt;C: #define SQL_COLUMN_AUTO_INCREMENT 11	&gt;</body><body>SQL_COLUMN_CASE_SENSITIVE	&lt;C: #define SQL_COLUMN_CASE_SENSITIVE 12	&gt;</body><body>SQL_COLUMN_COUNT	&lt;C: #define SQL_COLUMN_COUNT 0	&gt;</body><body>SQL_COLUMN_DISPLAY_SIZE	&lt;C: #define SQL_COLUMN_DISPLAY_SIZE 6	&gt;</body><body>SQL_COLUMN_DRIVER_START	&lt;C: #define SQL_COLUMN_DRIVER_START 1000	&gt;</body><body>SQL_COLUMN_LABEL	&lt;C: #define SQL_COLUMN_LABEL 18	&gt;</body><body>SQL_COLUMN_LENGTH	&lt;C: #define SQL_COLUMN_LENGTH 3	&gt;</body><body>SQL_COLUMN_MONEY	&lt;C: #define SQL_COLUMN_MONEY 9	&gt;</body><body>SQL_COLUMN_NAME	&lt;C: #define SQL_COLUMN_NAME 1	&gt;</body><body>SQL_COLUMN_NULLABLE	&lt;C: #define SQL_COLUMN_NULLABLE 7	&gt;</body><body>SQL_COLUMN_OWNER_NAME	&lt;C: #define SQL_COLUMN_OWNER_NAME 16	&gt;</body><body>SQL_COLUMN_PRECISION	&lt;C: #define SQL_COLUMN_PRECISION 4	&gt;</body><body>SQL_COLUMN_QUALIFIER_NAME	&lt;C: #define SQL_COLUMN_QUALIFIER_NAME 17	&gt;</body><body>SQL_COLUMN_SCALE	&lt;C: #define SQL_COLUMN_SCALE 5	&gt;</body><body>SQL_COLUMN_SEARCHABLE	&lt;C: #define SQL_COLUMN_SEARCHABLE 13	&gt;</body><body>SQL_COLUMN_TABLE_NAME	&lt;C: #define SQL_COLUMN_TABLE_NAME 15	&gt;</body><body>SQL_COLUMN_TYPE	&lt;C: #define SQL_COLUMN_TYPE 2	&gt;</body><body>SQL_COLUMN_TYPE_NAME	&lt;C: #define SQL_COLUMN_TYPE_NAME 14	&gt;</body><body>SQL_COLUMN_UNSIGNED	&lt;C: #define SQL_COLUMN_UNSIGNED 8	&gt;</body><body>SQL_COLUMN_UPDATABLE	&lt;C: #define SQL_COLUMN_UPDATABLE 10	&gt;</body><body>SQL_COMMIT	&lt;C: #define SQL_COMMIT 0	&gt;</body><body>SQL_CONCAT_NULL_BEHAVIOR	&lt;C: #define SQL_CONCAT_NULL_BEHAVIOR 22	&gt;</body><body>SQL_CONCURRENCY	&lt;C: #define SQL_CONCURRENCY 7	&gt;</body><body>SQL_CONCUR_LOCK	&lt;C: #define SQL_CONCUR_LOCK 2	&gt;</body><body>SQL_CONCUR_READ_ONLY	&lt;C: #define SQL_CONCUR_READ_ONLY 1	&gt;</body><body>SQL_CONCUR_ROWVER	&lt;C: #define SQL_CONCUR_ROWVER 3	&gt;</body><body>SQL_CONCUR_TIMESTAMP	&lt;C: #define SQL_CONCUR_TIMESTAMP SQL_CONCUR_ROWVER	&gt;</body><body>SQL_CONCUR_VALUES	&lt;C: #define SQL_CONCUR_VALUES 4	&gt;</body><body>SQL_CONNECT_OPT_DRVR_START	&lt;C: #define SQL_CONNECT_OPT_DRVR_START 1000	&gt;</body><body>SQL_CONN_OPT_MAX	&lt;C: #define SQL_CONN_OPT_MAX SQL_PACKET_SIZE	&gt;</body><body>SQL_CONN_OPT_MIN	&lt;C: #define SQL_CONN_OPT_MIN SQL_ACCESS_MODE	&gt;</body><body>SQL_CONVERT_BIGINT	&lt;C: #define SQL_CONVERT_BIGINT 53	&gt;</body><body>SQL_CONVERT_BINARY	&lt;C: #define SQL_CONVERT_BINARY 54	&gt;</body><body>SQL_CONVERT_BIT	&lt;C: #define SQL_CONVERT_BIT 55	&gt;</body><body>SQL_CONVERT_CHAR	&lt;C: #define SQL_CONVERT_CHAR 56	&gt;</body><body>SQL_CONVERT_DATE	&lt;C: #define SQL_CONVERT_DATE 57	&gt;</body><body>SQL_CONVERT_DECIMAL	&lt;C: #define SQL_CONVERT_DECIMAL 58	&gt;</body><body>SQL_CONVERT_DOUBLE	&lt;C: #define SQL_CONVERT_DOUBLE 59	&gt;</body><body>SQL_CONVERT_FLOAT	&lt;C: #define SQL_CONVERT_FLOAT 60	&gt;</body><body>SQL_CONVERT_FUNCTIONS	&lt;C: #define SQL_CONVERT_FUNCTIONS 48	&gt;</body><body>SQL_CONVERT_INTEGER	&lt;C: #define SQL_CONVERT_INTEGER 61	&gt;</body><body>SQL_CONVERT_LONGVARBINARY	&lt;C: #define SQL_CONVERT_LONGVARBINARY 71	&gt;</body><body>SQL_CONVERT_LONGVARCHAR	&lt;C: #define SQL_CONVERT_LONGVARCHAR 62	&gt;</body><body>SQL_CONVERT_NUMERIC	&lt;C: #define SQL_CONVERT_NUMERIC 63	&gt;</body><body>SQL_CONVERT_REAL	&lt;C: #define SQL_CONVERT_REAL 64	&gt;</body><body>SQL_CONVERT_SMALLINT	&lt;C: #define SQL_CONVERT_SMALLINT 65	&gt;</body><body>SQL_CONVERT_TIME	&lt;C: #define SQL_CONVERT_TIME 66	&gt;</body><body>SQL_CONVERT_TIMESTAMP	&lt;C: #define SQL_CONVERT_TIMESTAMP 67	&gt;</body><body>SQL_CONVERT_TINYINT	&lt;C: #define SQL_CONVERT_TINYINT 68	&gt;</body><body>SQL_CONVERT_VARBINARY	&lt;C: #define SQL_CONVERT_VARBINARY 69	&gt;</body><body>SQL_CONVERT_VARCHAR	&lt;C: #define SQL_CONVERT_VARCHAR 70	&gt;</body><body>SQL_CORRELATION_NAME	&lt;C: #define SQL_CORRELATION_NAME 74	&gt;</body><body>SQL_CR_CLOSE	&lt;C: #define SQL_CR_CLOSE SQL_CB_CLOSE	&gt;</body><body>SQL_CR_DELETE	&lt;C: #define SQL_CR_DELETE SQL_CB_DELETE	&gt;</body><body>SQL_CR_PRESERVE	&lt;C: #define SQL_CR_PRESERVE SQL_CB_PRESERVE	&gt;</body><body>SQL_CURRENT_QUALIFIER	&lt;C: #define SQL_CURRENT_QUALIFIER 109	&gt;</body><body>SQL_CURSOR_COMMIT_BEHAVIOR	&lt;C: #define SQL_CURSOR_COMMIT_BEHAVIOR 23	&gt;</body><body>SQL_CURSOR_DYNAMIC	&lt;C: #define SQL_CURSOR_DYNAMIC 2L	&gt;</body><body>SQL_CURSOR_FORWARD_ONLY	&lt;C: #define SQL_CURSOR_FORWARD_ONLY 0L	&gt;</body><body>SQL_CURSOR_KEYSET_DRIVEN	&lt;C: #define SQL_CURSOR_KEYSET_DRIVEN 1L	&gt;</body><body>SQL_CURSOR_ROLLBACK_BEHAVIOR	&lt;C: #define SQL_CURSOR_ROLLBACK_BEHAVIOR 24	&gt;</body><body>SQL_CURSOR_STATIC	&lt;C: #define SQL_CURSOR_STATIC 3L	&gt;</body><body>SQL_CURSOR_TYPE	&lt;C: #define SQL_CURSOR_TYPE 6	&gt;</body><body>SQL_CUR_DEFAULT	&lt;C: #define SQL_CUR_DEFAULT SQL_CUR_USE_DRIVER	&gt;</body><body>SQL_CUR_USE_DRIVER	&lt;C: #define SQL_CUR_USE_DRIVER 2L	&gt;</body><body>SQL_CUR_USE_IF_NEEDED	&lt;C: #define SQL_CUR_USE_IF_NEEDED 0L	&gt;</body><body>SQL_CUR_USE_ODBC	&lt;C: #define SQL_CUR_USE_ODBC 1L	&gt;</body><body>SQL_CVT_BIGINT	&lt;C: #define SQL_CVT_BIGINT 0x00004000	&gt;</body><body>SQL_CVT_BINARY	&lt;C: #define SQL_CVT_BINARY 0x00000400	&gt;</body><body>SQL_CVT_BIT	&lt;C: #define SQL_CVT_BIT 0x00001000	&gt;</body><body>SQL_CVT_CHAR	&lt;C: #define SQL_CVT_CHAR 0x00000001	&gt;</body><body>SQL_CVT_DATE	&lt;C: #define SQL_CVT_DATE 0x00008000	&gt;</body><body>SQL_CVT_DECIMAL	&lt;C: #define SQL_CVT_DECIMAL 0x00000004	&gt;</body><body>SQL_CVT_DOUBLE	&lt;C: #define SQL_CVT_DOUBLE 0x00000080	&gt;</body><body>SQL_CVT_FLOAT	&lt;C: #define SQL_CVT_FLOAT 0x00000020	&gt;</body><body>SQL_CVT_INTEGER	&lt;C: #define SQL_CVT_INTEGER 0x00000008	&gt;</body><body>SQL_CVT_LONGVARBINARY	&lt;C: #define SQL_CVT_LONGVARBINARY 0x00040000	&gt;</body><body>SQL_CVT_LONGVARCHAR	&lt;C: #define SQL_CVT_LONGVARCHAR 0x00000200	&gt;</body><body>SQL_CVT_NUMERIC	&lt;C: #define SQL_CVT_NUMERIC 0x00000002	&gt;</body><body>SQL_CVT_REAL	&lt;C: #define SQL_CVT_REAL 0x00000040	&gt;</body><body>SQL_CVT_SMALLINT	&lt;C: #define SQL_CVT_SMALLINT 0x00000010	&gt;</body><body>SQL_CVT_TIME	&lt;C: #define SQL_CVT_TIME 0x00010000	&gt;</body><body>SQL_CVT_TIMESTAMP	&lt;C: #define SQL_CVT_TIMESTAMP 0x00020000	&gt;</body><body>SQL_CVT_TINYINT	&lt;C: #define SQL_CVT_TINYINT 0x00002000	&gt;</body><body>SQL_CVT_VARBINARY	&lt;C: #define SQL_CVT_VARBINARY 0x00000800	&gt;</body><body>SQL_CVT_VARCHAR	&lt;C: #define SQL_CVT_VARCHAR 0x00000100	&gt;</body><body>SQL_C_BINARY	&lt;C: #define SQL_C_BINARY SQL_BINARY	&gt;</body><body>SQL_C_BIT	&lt;C: #define SQL_C_BIT SQL_BIT	&gt;</body><body>SQL_C_BOOKMARK	&lt;C: #define SQL_C_BOOKMARK SQL_C_ULONG	&gt;</body><body>SQL_C_CHAR	&lt;C: #define SQL_C_CHAR SQL_CHAR	&gt;</body><body>SQL_C_DATE	&lt;C: #define SQL_C_DATE SQL_DATE	&gt;</body><body>SQL_C_DEFAULT	&lt;C: #define SQL_C_DEFAULT 99	&gt;</body><body>SQL_C_DOUBLE	&lt;C: #define SQL_C_DOUBLE SQL_DOUBLE	&gt;</body><body>SQL_C_FLOAT	&lt;C: #define SQL_C_FLOAT SQL_REAL	&gt;</body><body>SQL_C_GUID	&lt;C: #define SQL_C_GUID SQL_GUID	&gt;</body><body>SQL_C_LONG	&lt;C: #define SQL_C_LONG SQL_INTEGER	&gt;</body><body>SQL_C_SHORT	&lt;C: #define SQL_C_SHORT SQL_SMALLINT	&gt;</body><body>SQL_C_SLONG	&lt;C: #define SQL_C_SLONG 4-20	&gt;</body><body>SQL_C_SSHORT	&lt;C: #define SQL_C_SSHORT 5-20	&gt;</body><body>SQL_C_STINYINT	&lt;C: #define SQL_C_STINYINT -6-20	&gt;</body><body>SQL_C_TIME	&lt;C: #define SQL_C_TIME SQL_TIME	&gt;</body><body>SQL_C_TIMESTAMP	&lt;C: #define SQL_C_TIMESTAMP SQL_TIMESTAMP	&gt;</body><body>SQL_C_TINYINT	&lt;C: #define SQL_C_TINYINT SQL_TINYINT	&gt;</body><body>SQL_C_TYPE_DATE	&lt;C: #define SQL_C_TYPE_DATE SQL_TYPE_DATE	&gt;</body><body>SQL_C_TYPE_TIME	&lt;C: #define SQL_C_TYPE_TIME SQL_TYPE_TIME	&gt;</body><body>SQL_C_TYPE_TIMESTAMP	&lt;C: #define SQL_C_TYPE_TIMESTAMP SQL_TYPE_TIMESTAMP	&gt;</body><body>SQL_C_ULONG	&lt;C: #define SQL_C_ULONG 4-22	&gt;</body><body>SQL_C_USHORT	&lt;C: #define SQL_C_USHORT 5-22	&gt;</body><body>SQL_C_UTINYINT	&lt;C: #define SQL_C_UTINYINT -6-22	&gt;</body><body>SQL_C_WCHAR	&lt;C: #define SQL_C_WCHAR SQL_WCHAR	&gt;</body><body>SQL_DATABASE_NAME	&lt;C: #define SQL_DATABASE_NAME 16	&gt;</body><body>SQL_DATA_AT_EXEC	&lt;C: #define SQL_DATA_AT_EXEC (-2)	&gt;</body><body>SQL_DATA_SOURCE_NAME	&lt;C: #define SQL_DATA_SOURCE_NAME 2	&gt;</body><body>SQL_DATA_SOURCE_READ_ONLY	&lt;C: #define SQL_DATA_SOURCE_READ_ONLY 25	&gt;</body><body>SQL_DATE	&lt;C: #define SQL_DATE 9	&gt;</body><body>SQL_DBMS_NAME	&lt;C: #define SQL_DBMS_NAME 17	&gt;</body><body>SQL_DBMS_VER	&lt;C: #define SQL_DBMS_VER 18	&gt;</body><body>SQL_DECIMAL	&lt;C: #define SQL_DECIMAL 3	&gt;</body><body>SQL_DEFAULT_PARAM	&lt;C: #define SQL_DEFAULT_PARAM (-5)	&gt;</body><body>SQL_DEFAULT_TXN_ISOLATION	&lt;C: #define SQL_DEFAULT_TXN_ISOLATION 26	&gt;</body><body>SQL_DELETE	&lt;C: #define SQL_DELETE 3	&gt;</body><body>SQL_DOUBLE	&lt;C: #define SQL_DOUBLE 8	&gt;</body><body>SQL_DRIVER_COMPLETE	&lt;C: #define SQL_DRIVER_COMPLETE 1	&gt;</body><body>SQL_DRIVER_COMPLETE_REQUIRED	&lt;C: #define SQL_DRIVER_COMPLETE_REQUIRED 3	&gt;</body><body>SQL_DRIVER_HDBC	&lt;C: #define SQL_DRIVER_HDBC 3	&gt;</body><body>SQL_DRIVER_HENV	&lt;C: #define SQL_DRIVER_HENV 4	&gt;</body><body>SQL_DRIVER_HLIB	&lt;C: #define SQL_DRIVER_HLIB 76	&gt;</body><body>SQL_DRIVER_HSTMT	&lt;C: #define SQL_DRIVER_HSTMT 5	&gt;</body><body>SQL_DRIVER_NAME	&lt;C: #define SQL_DRIVER_NAME 6	&gt;</body><body>SQL_DRIVER_NOPROMPT	&lt;C: #define SQL_DRIVER_NOPROMPT 0	&gt;</body><body>SQL_DRIVER_ODBC_VER	&lt;C: #define SQL_DRIVER_ODBC_VER 77	&gt;</body><body>SQL_DRIVER_PROMPT	&lt;C: #define SQL_DRIVER_PROMPT 2	&gt;</body><body>SQL_DRIVER_VER	&lt;C: #define SQL_DRIVER_VER 7	&gt;</body><body>SQL_DROP	&lt;C: #define SQL_DROP 1	&gt;</body><body>SQL_ENSURE	&lt;C: #define SQL_ENSURE 1	&gt;</body><body>SQL_ENTIRE_ROWSET	&lt;C: #define SQL_ENTIRE_ROWSET 0	&gt;</body><body>SQL_ERROR	&lt;C: #define SQL_ERROR (-1)	&gt;</body><body>SQL_EXPRESSIONS_IN_ORDERBY	&lt;C: #define SQL_EXPRESSIONS_IN_ORDERBY 27	&gt;</body><body>SQL_EXT_API_LAST	&lt;C: #define SQL_EXT_API_LAST SQL_API_SQLBINDPARAMETER	&gt;</body><body>SQL_EXT_API_START	&lt;C: #define SQL_EXT_API_START 40	&gt;</body><body>SQL_FD_FETCH_ABSOLUTE	&lt;C: #define SQL_FD_FETCH_ABSOLUTE 0x00000010	&gt;</body><body>SQL_FD_FETCH_BOOKMARK	&lt;C: #define SQL_FD_FETCH_BOOKMARK 0x00000080	&gt;</body><body>SQL_FD_FETCH_FIRST	&lt;C: #define SQL_FD_FETCH_FIRST 0x00000002	&gt;</body><body>SQL_FD_FETCH_LAST	&lt;C: #define SQL_FD_FETCH_LAST 0x00000004	&gt;</body><body>SQL_FD_FETCH_NEXT	&lt;C: #define SQL_FD_FETCH_NEXT 0x00000001	&gt;</body><body>SQL_FD_FETCH_PREV	&lt;C: #define SQL_FD_FETCH_PREV SQL_FD_FETCH_PRIOR	&gt;</body><body>SQL_FD_FETCH_PRIOR	&lt;C: #define SQL_FD_FETCH_PRIOR 0x00000008	&gt;</body><body>SQL_FD_FETCH_RELATIVE	&lt;C: #define SQL_FD_FETCH_RELATIVE 0x00000020	&gt;</body><body>SQL_FD_FETCH_RESUME	&lt;C: #define SQL_FD_FETCH_RESUME 0x00000040	&gt;</body><body>SQL_FETCH_ABSOLUTE	&lt;C: #define SQL_FETCH_ABSOLUTE 5	&gt;</body><body>SQL_FETCH_BOOKMARK	&lt;C: #define SQL_FETCH_BOOKMARK 8	&gt;</body><body>SQL_FETCH_DIRECTION	&lt;C: #define SQL_FETCH_DIRECTION 8	&gt;</body><body>SQL_FETCH_FIRST	&lt;C: #define SQL_FETCH_FIRST 2	&gt;</body><body>SQL_FETCH_LAST	&lt;C: #define SQL_FETCH_LAST 3	&gt;</body><body>SQL_FETCH_NEXT	&lt;C: #define SQL_FETCH_NEXT 1	&gt;</body><body>SQL_FETCH_PREV	&lt;C: #define SQL_FETCH_PREV SQL_FETCH_PRIOR	&gt;</body><body>SQL_FETCH_PRIOR	&lt;C: #define SQL_FETCH_PRIOR 4	&gt;</body><body>SQL_FETCH_RELATIVE	&lt;C: #define SQL_FETCH_RELATIVE 6	&gt;</body><body>SQL_FETCH_RESUME	&lt;C: #define SQL_FETCH_RESUME 7	&gt;</body><body>SQL_FILE_NOT_SUPPORTED	&lt;C: #define SQL_FILE_NOT_SUPPORTED 0x0000	&gt;</body><body>SQL_FILE_QUALIFIER	&lt;C: #define SQL_FILE_QUALIFIER 0x0002	&gt;</body><body>SQL_FILE_TABLE	&lt;C: #define SQL_FILE_TABLE 0x0001	&gt;</body><body>SQL_FILE_USAGE	&lt;C: #define SQL_FILE_USAGE 84	&gt;</body><body>SQL_FLOAT	&lt;C: #define SQL_FLOAT 6	&gt;</body><body>SQL_FN_CVT_CONVERT	&lt;C: #define SQL_FN_CVT_CONVERT 0x00000001	&gt;</body><body>SQL_FN_NUM_ABS	&lt;C: #define SQL_FN_NUM_ABS 0x00000001	&gt;</body><body>SQL_FN_NUM_ACOS	&lt;C: #define SQL_FN_NUM_ACOS 0x00000002	&gt;</body><body>SQL_FN_NUM_ASIN	&lt;C: #define SQL_FN_NUM_ASIN 0x00000004	&gt;</body><body>SQL_FN_NUM_ATAN	&lt;C: #define SQL_FN_NUM_ATAN 0x00000008	&gt;</body><body>SQL_FN_NUM_ATAN2	&lt;C: #define SQL_FN_NUM_ATAN2 0x00000010	&gt;</body><body>SQL_FN_NUM_CEILING	&lt;C: #define SQL_FN_NUM_CEILING 0x00000020	&gt;</body><body>SQL_FN_NUM_COS	&lt;C: #define SQL_FN_NUM_COS 0x00000040	&gt;</body><body>SQL_FN_NUM_COT	&lt;C: #define SQL_FN_NUM_COT 0x00000080	&gt;</body><body>SQL_FN_NUM_DEGREES	&lt;C: #define SQL_FN_NUM_DEGREES 0x00040000	&gt;</body><body>SQL_FN_NUM_EXP	&lt;C: #define SQL_FN_NUM_EXP 0x00000100	&gt;</body><body>SQL_FN_NUM_FLOOR	&lt;C: #define SQL_FN_NUM_FLOOR 0x00000200	&gt;</body><body>SQL_FN_NUM_LOG	&lt;C: #define SQL_FN_NUM_LOG 0x00000400	&gt;</body><body>SQL_FN_NUM_LOG10	&lt;C: #define SQL_FN_NUM_LOG10 0x00080000	&gt;</body><body>SQL_FN_NUM_MOD	&lt;C: #define SQL_FN_NUM_MOD 0x00000800	&gt;</body><body>SQL_FN_NUM_PI	&lt;C: #define SQL_FN_NUM_PI 0x00010000	&gt;</body><body>SQL_FN_NUM_POWER	&lt;C: #define SQL_FN_NUM_POWER 0x00100000	&gt;</body><body>SQL_FN_NUM_RADIANS	&lt;C: #define SQL_FN_NUM_RADIANS 0x00200000	&gt;</body><body>SQL_FN_NUM_RAND	&lt;C: #define SQL_FN_NUM_RAND 0x00020000	&gt;</body><body>SQL_FN_NUM_ROUND	&lt;C: #define SQL_FN_NUM_ROUND 0x00400000	&gt;</body><body>SQL_FN_NUM_SIGN	&lt;C: #define SQL_FN_NUM_SIGN 0x00001000	&gt;</body><body>SQL_FN_NUM_SIN	&lt;C: #define SQL_FN_NUM_SIN 0x00002000	&gt;</body><body>SQL_FN_NUM_SQRT	&lt;C: #define SQL_FN_NUM_SQRT 0x00004000	&gt;</body><body>SQL_FN_NUM_TAN	&lt;C: #define SQL_FN_NUM_TAN 0x00008000	&gt;</body><body>SQL_FN_NUM_TRUNCATE	&lt;C: #define SQL_FN_NUM_TRUNCATE 0x00800000	&gt;</body><body>SQL_FN_STR_ASCII	&lt;C: #define SQL_FN_STR_ASCII 0x00002000	&gt;</body><body>SQL_FN_STR_CHAR	&lt;C: #define SQL_FN_STR_CHAR 0x00004000	&gt;</body><body>SQL_FN_STR_CONCAT	&lt;C: #define SQL_FN_STR_CONCAT 0x00000001	&gt;</body><body>SQL_FN_STR_DIFFERENCE	&lt;C: #define SQL_FN_STR_DIFFERENCE 0x00008000	&gt;</body><body>SQL_FN_STR_INSERT	&lt;C: #define SQL_FN_STR_INSERT 0x00000002	&gt;</body><body>SQL_FN_STR_LCASE	&lt;C: #define SQL_FN_STR_LCASE 0x00000040	&gt;</body><body>SQL_FN_STR_LEFT	&lt;C: #define SQL_FN_STR_LEFT 0x00000004	&gt;</body><body>SQL_FN_STR_LENGTH	&lt;C: #define SQL_FN_STR_LENGTH 0x00000010	&gt;</body><body>SQL_FN_STR_LOCATE	&lt;C: #define SQL_FN_STR_LOCATE 0x00000020	&gt;</body><body>SQL_FN_STR_LOCATE_2	&lt;C: #define SQL_FN_STR_LOCATE_2 0x00010000	&gt;</body><body>SQL_FN_STR_LTRIM	&lt;C: #define SQL_FN_STR_LTRIM 0x00000008	&gt;</body><body>SQL_FN_STR_REPEAT	&lt;C: #define SQL_FN_STR_REPEAT 0x00000080	&gt;</body><body>SQL_FN_STR_REPLACE	&lt;C: #define SQL_FN_STR_REPLACE 0x00000100	&gt;</body><body>SQL_FN_STR_RIGHT	&lt;C: #define SQL_FN_STR_RIGHT 0x00000200	&gt;</body><body>SQL_FN_STR_RTRIM	&lt;C: #define SQL_FN_STR_RTRIM 0x00000400	&gt;</body><body>SQL_FN_STR_SOUNDEX	&lt;C: #define SQL_FN_STR_SOUNDEX 0x00020000	&gt;</body><body>SQL_FN_STR_SPACE	&lt;C: #define SQL_FN_STR_SPACE 0x00040000	&gt;</body><body>SQL_FN_STR_SUBSTRING	&lt;C: #define SQL_FN_STR_SUBSTRING 0x00000800	&gt;</body><body>SQL_FN_STR_UCASE	&lt;C: #define SQL_FN_STR_UCASE 0x00001000	&gt;</body><body>SQL_FN_SYS_DBNAME	&lt;C: #define SQL_FN_SYS_DBNAME 0x00000002	&gt;</body><body>SQL_FN_SYS_IFNULL	&lt;C: #define SQL_FN_SYS_IFNULL 0x00000004	&gt;</body><body>SQL_FN_SYS_USERNAME	&lt;C: #define SQL_FN_SYS_USERNAME 0x00000001	&gt;</body><body>SQL_FN_TD_CURDATE	&lt;C: #define SQL_FN_TD_CURDATE 0x00000002	&gt;</body><body>SQL_FN_TD_CURTIME	&lt;C: #define SQL_FN_TD_CURTIME 0x00000200	&gt;</body><body>SQL_FN_TD_DAYNAME	&lt;C: #define SQL_FN_TD_DAYNAME 0x00008000	&gt;</body><body>SQL_FN_TD_DAYOFMONTH	&lt;C: #define SQL_FN_TD_DAYOFMONTH 0x00000004	&gt;</body><body>SQL_FN_TD_DAYOFWEEK	&lt;C: #define SQL_FN_TD_DAYOFWEEK 0x00000008	&gt;</body><body>SQL_FN_TD_DAYOFYEAR	&lt;C: #define SQL_FN_TD_DAYOFYEAR 0x00000010	&gt;</body><body>SQL_FN_TD_HOUR	&lt;C: #define SQL_FN_TD_HOUR 0x00000400	&gt;</body><body>SQL_FN_TD_MINUTE	&lt;C: #define SQL_FN_TD_MINUTE 0x00000800	&gt;</body><body>SQL_FN_TD_MONTH	&lt;C: #define SQL_FN_TD_MONTH 0x00000020	&gt;</body><body>SQL_FN_TD_MONTHNAME	&lt;C: #define SQL_FN_TD_MONTHNAME 0x00010000	&gt;</body><body>SQL_FN_TD_NOW	&lt;C: #define SQL_FN_TD_NOW 0x00000001	&gt;</body><body>SQL_FN_TD_QUARTER	&lt;C: #define SQL_FN_TD_QUARTER 0x00000040	&gt;</body><body>SQL_FN_TD_SECOND	&lt;C: #define SQL_FN_TD_SECOND 0x00001000	&gt;</body><body>SQL_FN_TD_TIMESTAMPADD	&lt;C: #define SQL_FN_TD_TIMESTAMPADD 0x00002000	&gt;</body><body>SQL_FN_TD_TIMESTAMPDIFF	&lt;C: #define SQL_FN_TD_TIMESTAMPDIFF 0x00004000	&gt;</body><body>SQL_FN_TD_WEEK	&lt;C: #define SQL_FN_TD_WEEK 0x00000080	&gt;</body><body>SQL_FN_TD_YEAR	&lt;C: #define SQL_FN_TD_YEAR 0x00000100	&gt;</body><body>SQL_FN_TSI_DAY	&lt;C: #define SQL_FN_TSI_DAY 0x00000010	&gt;</body><body>SQL_FN_TSI_FRAC_SECOND	&lt;C: #define SQL_FN_TSI_FRAC_SECOND 0x00000001	&gt;</body><body>SQL_FN_TSI_HOUR	&lt;C: #define SQL_FN_TSI_HOUR 0x00000008	&gt;</body><body>SQL_FN_TSI_MINUTE	&lt;C: #define SQL_FN_TSI_MINUTE 0x00000004	&gt;</body><body>SQL_FN_TSI_MONTH	&lt;C: #define SQL_FN_TSI_MONTH 0x00000040	&gt;</body><body>SQL_FN_TSI_QUARTER	&lt;C: #define SQL_FN_TSI_QUARTER 0x00000080	&gt;</body><body>SQL_FN_TSI_SECOND	&lt;C: #define SQL_FN_TSI_SECOND 0x00000002	&gt;</body><body>SQL_FN_TSI_WEEK	&lt;C: #define SQL_FN_TSI_WEEK 0x00000020	&gt;</body><body>SQL_FN_TSI_YEAR	&lt;C: #define SQL_FN_TSI_YEAR 0x00000100	&gt;</body><body>SQL_GB_GROUP_BY_CONTAINS_SELECT	&lt;C: #define SQL_GB_GROUP_BY_CONTAINS_SELECT 0x0002	&gt;</body><body>SQL_GB_GROUP_BY_EQUALS_SELECT	&lt;C: #define SQL_GB_GROUP_BY_EQUALS_SELECT 0x0001	&gt;</body><body>SQL_GB_NOT_SUPPORTED	&lt;C: #define SQL_GB_NOT_SUPPORTED 0x0000	&gt;</body><body>SQL_GB_NO_RELATION	&lt;C: #define SQL_GB_NO_RELATION 0x0003	&gt;</body><body>SQL_GD_ANY_COLUMN	&lt;C: #define SQL_GD_ANY_COLUMN 0x00000001	&gt;</body><body>SQL_GD_ANY_ORDER	&lt;C: #define SQL_GD_ANY_ORDER 0x00000002	&gt;</body><body>SQL_GD_BLOCK	&lt;C: #define SQL_GD_BLOCK 0x00000004	&gt;</body><body>SQL_GD_BOUND	&lt;C: #define SQL_GD_BOUND 0x00000008	&gt;</body><body>SQL_GETDATA_EXTENSIONS	&lt;C: #define SQL_GETDATA_EXTENSIONS 81	&gt;</body><body>SQL_GET_BOOKMARK	&lt;C: #define SQL_GET_BOOKMARK 13	&gt;</body><body>SQL_GROUP_BY	&lt;C: #define SQL_GROUP_BY 88	&gt;</body><body>SQL_GUID	&lt;C: #define SQL_GUID (-11)	&gt;</body><body>SQL_IC_LOWER	&lt;C: #define SQL_IC_LOWER 0x0002	&gt;</body><body>SQL_IC_MIXED	&lt;C: #define SQL_IC_MIXED 0x0004	&gt;</body><body>SQL_IC_SENSITIVE	&lt;C: #define SQL_IC_SENSITIVE 0x0003	&gt;</body><body>SQL_IC_UPPER	&lt;C: #define SQL_IC_UPPER 0x0001	&gt;</body><body>SQL_IDENTIFIER_CASE	&lt;C: #define SQL_IDENTIFIER_CASE 28	&gt;</body><body>SQL_IDENTIFIER_QUOTE_CHAR	&lt;C: #define SQL_IDENTIFIER_QUOTE_CHAR 29	&gt;</body><body>SQL_IGNORE	&lt;C: #define SQL_IGNORE (-6)	&gt;</body><body>SQL_INDEX_ALL	&lt;C: #define SQL_INDEX_ALL 1	&gt;</body><body>SQL_INDEX_CLUSTERED	&lt;C: #define SQL_INDEX_CLUSTERED 1	&gt;</body><body>SQL_INDEX_HASHED	&lt;C: #define SQL_INDEX_HASHED 2	&gt;</body><body>SQL_INDEX_OTHER	&lt;C: #define SQL_INDEX_OTHER 3	&gt;</body><body>SQL_INDEX_UNIQUE	&lt;C: #define SQL_INDEX_UNIQUE 0	&gt;</body><body>SQL_INFO_DRIVER_START	&lt;C: #define SQL_INFO_DRIVER_START 1000	&gt;</body><body>SQL_INFO_FIRST	&lt;C: #define SQL_INFO_FIRST 0	&gt;</body><body>SQL_INFO_LAST	&lt;C: #define SQL_INFO_LAST SQL_QUALIFIER_LOCATION	&gt;</body><body>SQL_INTEGER	&lt;C: #define SQL_INTEGER 4	&gt;</body><body>SQL_INVALID_HANDLE	&lt;C: #define SQL_INVALID_HANDLE (-2)	&gt;</body><body>SQL_KEYSET_SIZE	&lt;C: #define SQL_KEYSET_SIZE 8	&gt;</body><body>SQL_KEYSET_SIZE_DEFAULT	&lt;C: #define SQL_KEYSET_SIZE_DEFAULT 0L	&gt;</body><body>SQL_KEYWORDS	&lt;C: #define SQL_KEYWORDS 89	&gt;</body><body>SQL_LCK_EXCLUSIVE	&lt;C: #define SQL_LCK_EXCLUSIVE 0x00000002	&gt;</body><body>SQL_LCK_NO_CHANGE	&lt;C: #define SQL_LCK_NO_CHANGE 0x00000001	&gt;</body><body>SQL_LCK_UNLOCK	&lt;C: #define SQL_LCK_UNLOCK 0x00000004	&gt;</body><body>SQL_LEN_DATA_AT_EXEC_OFFSET	&lt;C: #define SQL_LEN_DATA_AT_EXEC_OFFSET (-100)	&gt;</body><body>SQL_LIKE_ESCAPE_CLAUSE	&lt;C: #define SQL_LIKE_ESCAPE_CLAUSE 113	&gt;</body><body>SQL_LIKE_ONLY	&lt;C: #define SQL_LIKE_ONLY 1	&gt;</body><body>SQL_LOCK_EXCLUSIVE	&lt;C: #define SQL_LOCK_EXCLUSIVE 1	&gt;</body><body>SQL_LOCK_NO_CHANGE	&lt;C: #define SQL_LOCK_NO_CHANGE 0	&gt;</body><body>SQL_LOCK_TYPES	&lt;C: #define SQL_LOCK_TYPES 78	&gt;</body><body>SQL_LOCK_UNLOCK	&lt;C: #define SQL_LOCK_UNLOCK 2	&gt;</body><body>SQL_LOGIN_TIMEOUT	&lt;C: #define SQL_LOGIN_TIMEOUT 103	&gt;</body><body>SQL_LOGIN_TIMEOUT_DEFAULT	&lt;C: #define SQL_LOGIN_TIMEOUT_DEFAULT 15L	&gt;</body><body>SQL_LONGVARBINARY	&lt;C: #define SQL_LONGVARBINARY (-4)	&gt;</body><body>SQL_LONGVARCHAR	&lt;C: #define SQL_LONGVARCHAR (-1)	&gt;</body><body>SQL_MAX_BINARY_LITERAL_LEN	&lt;C: #define SQL_MAX_BINARY_LITERAL_LEN 112	&gt;</body><body>SQL_MAX_CHAR_LITERAL_LEN	&lt;C: #define SQL_MAX_CHAR_LITERAL_LEN 108	&gt;</body><body>SQL_MAX_COLUMNS_IN_GROUP_BY	&lt;C: #define SQL_MAX_COLUMNS_IN_GROUP_BY 97	&gt;</body><body>SQL_MAX_COLUMNS_IN_INDEX	&lt;C: #define SQL_MAX_COLUMNS_IN_INDEX 98	&gt;</body><body>SQL_MAX_COLUMNS_IN_ORDER_BY	&lt;C: #define SQL_MAX_COLUMNS_IN_ORDER_BY 99	&gt;</body><body>SQL_MAX_COLUMNS_IN_SELECT	&lt;C: #define SQL_MAX_COLUMNS_IN_SELECT 100	&gt;</body><body>SQL_MAX_COLUMNS_IN_TABLE	&lt;C: #define SQL_MAX_COLUMNS_IN_TABLE 101	&gt;</body><body>SQL_MAX_COLUMN_NAME_LEN	&lt;C: #define SQL_MAX_COLUMN_NAME_LEN 30	&gt;</body><body>SQL_MAX_CURSOR_NAME_LEN	&lt;C: #define SQL_MAX_CURSOR_NAME_LEN 31	&gt;</body><body>SQL_MAX_DSN_LENGTH	&lt;C: #define SQL_MAX_DSN_LENGTH 32	&gt;</body><body>SQL_MAX_INDEX_SIZE	&lt;C: #define SQL_MAX_INDEX_SIZE 102	&gt;</body><body>SQL_MAX_LENGTH	&lt;C: #define SQL_MAX_LENGTH 3	&gt;</body><body>SQL_MAX_LENGTH_DEFAULT	&lt;C: #define SQL_MAX_LENGTH_DEFAULT 0L	&gt;</body><body>SQL_MAX_MESSAGE_LENGTH	&lt;C: #define SQL_MAX_MESSAGE_LENGTH 512	&gt;</body><body>SQL_MAX_OPTION_STRING_LENGTH	&lt;C: #define SQL_MAX_OPTION_STRING_LENGTH 256	&gt;</body><body>SQL_MAX_OWNER_NAME_LEN	&lt;C: #define SQL_MAX_OWNER_NAME_LEN 32	&gt;</body><body>SQL_MAX_PROCEDURE_NAME_LEN	&lt;C: #define SQL_MAX_PROCEDURE_NAME_LEN 33	&gt;</body><body>SQL_MAX_QUALIFIER_NAME_LEN	&lt;C: #define SQL_MAX_QUALIFIER_NAME_LEN 34	&gt;</body><body>SQL_MAX_ROWS	&lt;C: #define SQL_MAX_ROWS 1	&gt;</body><body>SQL_MAX_ROWS_DEFAULT	&lt;C: #define SQL_MAX_ROWS_DEFAULT 0L	&gt;</body><body>SQL_MAX_ROW_SIZE	&lt;C: #define SQL_MAX_ROW_SIZE 104	&gt;</body><body>SQL_MAX_ROW_SIZE_INCLUDES_LONG	&lt;C: #define SQL_MAX_ROW_SIZE_INCLUDES_LONG 103	&gt;</body><body>SQL_MAX_STATEMENT_LEN	&lt;C: #define SQL_MAX_STATEMENT_LEN 105	&gt;</body><body>SQL_MAX_TABLES_IN_SELECT	&lt;C: #define SQL_MAX_TABLES_IN_SELECT 106	&gt;</body><body>SQL_MAX_TABLE_NAME_LEN	&lt;C: #define SQL_MAX_TABLE_NAME_LEN 35	&gt;</body><body>SQL_MAX_USER_NAME_LEN	&lt;C: #define SQL_MAX_USER_NAME_LEN 107	&gt;</body><body>SQL_MODE_DEFAULT	&lt;C: #define SQL_MODE_DEFAULT SQL_MODE_READ_WRITE	&gt;</body><body>SQL_MODE_READ_ONLY	&lt;C: #define SQL_MODE_READ_ONLY 1L	&gt;</body><body>SQL_MODE_READ_WRITE	&lt;C: #define SQL_MODE_READ_WRITE 0L	&gt;</body><body>SQL_MULTIPLE_ACTIVE_TXN	&lt;C: #define SQL_MULTIPLE_ACTIVE_TXN 37	&gt;</body><body>SQL_MULT_RESULT_SETS	&lt;C: #define SQL_MULT_RESULT_SETS 36	&gt;</body><body>SQL_NC_END	&lt;C: #define SQL_NC_END 0x0004	&gt;</body><body>SQL_NC_HIGH	&lt;C: #define SQL_NC_HIGH 0x0000	&gt;</body><body>SQL_NC_LOW	&lt;C: #define SQL_NC_LOW 0x0001	&gt;</body><body>SQL_NC_START	&lt;C: #define SQL_NC_START 0x0002	&gt;</body><body>SQL_NEED_DATA	&lt;C: #define SQL_NEED_DATA 99	&gt;</body><body>SQL_NEED_LONG_DATA_LEN	&lt;C: #define SQL_NEED_LONG_DATA_LEN 111	&gt;</body><body>SQL_NNC_NON_NULL	&lt;C: #define SQL_NNC_NON_NULL 0x0001	&gt;</body><body>SQL_NNC_NULL	&lt;C: #define SQL_NNC_NULL 0x0000	&gt;</body><body>SQL_NON_NULLABLE_COLUMNS	&lt;C: #define SQL_NON_NULLABLE_COLUMNS 75	&gt;</body><body>SQL_NOSCAN	&lt;C: #define SQL_NOSCAN 2	&gt;</body><body>SQL_NOSCAN_DEFAULT	&lt;C: #define SQL_NOSCAN_DEFAULT SQL_NOSCAN_OFF	&gt;</body><body>SQL_NOSCAN_OFF	&lt;C: #define SQL_NOSCAN_OFF 0L	&gt;</body><body>SQL_NOSCAN_ON	&lt;C: #define SQL_NOSCAN_ON 1L	&gt;</body><body>SQL_NO_DATA_FOUND	&lt;C: #define SQL_NO_DATA_FOUND 100	&gt;</body><body>SQL_NO_NULLS	&lt;C: #define SQL_NO_NULLS 0	&gt;</body><body>SQL_NO_TOTAL	&lt;C: #define SQL_NO_TOTAL (-4)	&gt;</body><body>SQL_NTS	&lt;C: #define SQL_NTS (-3)	&gt;</body><body>SQL_NULLABLE	&lt;C: #define SQL_NULLABLE 1	&gt;</body><body>SQL_NULLABLE_UNKNOWN	&lt;C: #define SQL_NULLABLE_UNKNOWN 2	&gt;</body><body>SQL_NULL_COLLATION	&lt;C: #define SQL_NULL_COLLATION 85	&gt;</body><body>SQL_NULL_DATA	&lt;C: #define SQL_NULL_DATA (-1)	&gt;</body><body>SQL_NULL_HDBC	&lt;C: #define SQL_NULL_HDBC 0	&gt;</body><body>SQL_NULL_HENV	&lt;C: #define SQL_NULL_HENV 0	&gt;</body><body>SQL_NULL_HSTMT	&lt;C: #define SQL_NULL_HSTMT 0	&gt;</body><body>SQL_NUMERIC	&lt;C: #define SQL_NUMERIC 2	&gt;</body><body>SQL_NUMERIC_FUNCTIONS	&lt;C: #define SQL_NUMERIC_FUNCTIONS 49	&gt;</body><body>SQL_NUM_EXTENSIONS	&lt;C: #define SQL_NUM_EXTENSIONS (SQL_EXT_API_LAST-SQL_EXT_API_START+1)	&gt;</body><body>SQL_NUM_FUNCTIONS	&lt;C: #define SQL_NUM_FUNCTIONS 23	&gt;</body><body>SQL_OAC_LEVEL1	&lt;C: #define SQL_OAC_LEVEL1 0x0001	&gt;</body><body>SQL_OAC_LEVEL2	&lt;C: #define SQL_OAC_LEVEL2 0x0002	&gt;</body><body>SQL_OAC_NONE	&lt;C: #define SQL_OAC_NONE 0x0000	&gt;</body><body>SQL_ODBC_API_CONFORMANCE	&lt;C: #define SQL_ODBC_API_CONFORMANCE 9	&gt;</body><body>SQL_ODBC_CURSORS	&lt;C: #define SQL_ODBC_CURSORS 110	&gt;</body><body>SQL_ODBC_KEYWORDS	&lt;C: #define SQL_ODBC_KEYWORDS 	&gt;</body><body>SQL_ODBC_SAG_CLI_CONFORMANCE	&lt;C: #define SQL_ODBC_SAG_CLI_CONFORMANCE 12	&gt;</body><body>SQL_ODBC_SQL_CONFORMANCE	&lt;C: #define SQL_ODBC_SQL_CONFORMANCE 15	&gt;</body><body>SQL_ODBC_SQL_OPT_IEF	&lt;C: #define SQL_ODBC_SQL_OPT_IEF 73	&gt;</body><body>SQL_ODBC_VER	&lt;C: #define SQL_ODBC_VER 10	&gt;</body><body>SQL_OJ_ALL_COMPARISON_OPS	&lt;C: #define SQL_OJ_ALL_COMPARISON_OPS 0x00000040	&gt;</body><body>SQL_OJ_CAPABILITIES	&lt;C: #define SQL_OJ_CAPABILITIES 65002	&gt;</body><body>SQL_OJ_FULL	&lt;C: #define SQL_OJ_FULL 0x00000004	&gt;</body><body>SQL_OJ_INNER	&lt;C: #define SQL_OJ_INNER 0x00000020	&gt;</body><body>SQL_OJ_LEFT	&lt;C: #define SQL_OJ_LEFT 0x00000001	&gt;</body><body>SQL_OJ_NESTED	&lt;C: #define SQL_OJ_NESTED 0x00000008	&gt;</body><body>SQL_OJ_NOT_ORDERED	&lt;C: #define SQL_OJ_NOT_ORDERED 0x00000010	&gt;</body><body>SQL_OJ_RIGHT	&lt;C: #define SQL_OJ_RIGHT 0x00000002	&gt;</body><body>SQL_OPT_TRACE	&lt;C: #define SQL_OPT_TRACE 104	&gt;</body><body>SQL_OPT_TRACEFILE	&lt;C: #define SQL_OPT_TRACEFILE 105	&gt;</body><body>SQL_OPT_TRACE_DEFAULT	&lt;C: #define SQL_OPT_TRACE_DEFAULT SQL_OPT_TRACE_OFF	&gt;</body><body>SQL_OPT_TRACE_FILE_DEFAULT	&lt;C: #define SQL_OPT_TRACE_FILE_DEFAULT "\SQL.LOG"	&gt;</body><body>SQL_OPT_TRACE_OFF	&lt;C: #define SQL_OPT_TRACE_OFF 0L	&gt;</body><body>SQL_OPT_TRACE_ON	&lt;C: #define SQL_OPT_TRACE_ON 1L	&gt;</body><body>SQL_ORDER_BY_COLUMNS_IN_SELECT	&lt;C: #define SQL_ORDER_BY_COLUMNS_IN_SELECT 90	&gt;</body><body>SQL_OSCC_COMPLIANT	&lt;C: #define SQL_OSCC_COMPLIANT 0x0001	&gt;</body><body>SQL_OSCC_NOT_COMPLIANT	&lt;C: #define SQL_OSCC_NOT_COMPLIANT 0x0000	&gt;</body><body>SQL_OSC_CORE	&lt;C: #define SQL_OSC_CORE 0x0001	&gt;</body><body>SQL_OSC_EXTENDED	&lt;C: #define SQL_OSC_EXTENDED 0x0002	&gt;</body><body>SQL_OSC_MINIMUM	&lt;C: #define SQL_OSC_MINIMUM 0x0000	&gt;</body><body>SQL_OUTER_JOINS	&lt;C: #define SQL_OUTER_JOINS 38	&gt;</body><body>SQL_OU_DML_STATEMENTS	&lt;C: #define SQL_OU_DML_STATEMENTS 0x00000001	&gt;</body><body>SQL_OU_INDEX_DEFINITION	&lt;C: #define SQL_OU_INDEX_DEFINITION 0x00000008	&gt;</body><body>SQL_OU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_OU_PRIVILEGE_DEFINITION 0x00000010	&gt;</body><body>SQL_OU_PROCEDURE_INVOCATION	&lt;C: #define SQL_OU_PROCEDURE_INVOCATION 0x00000002	&gt;</body><body>SQL_OU_TABLE_DEFINITION	&lt;C: #define SQL_OU_TABLE_DEFINITION 0x00000004	&gt;</body><body>SQL_OWNER_TERM	&lt;C: #define SQL_OWNER_TERM 39	&gt;</body><body>SQL_OWNER_USAGE	&lt;C: #define SQL_OWNER_USAGE 91	&gt;</body><body>SQL_PACKET_SIZE	&lt;C: #define SQL_PACKET_SIZE 112	&gt;</body><body>SQL_PARAM_INPUT	&lt;C: #define SQL_PARAM_INPUT 1	&gt;</body><body>SQL_PARAM_INPUT_OUTPUT	&lt;C: #define SQL_PARAM_INPUT_OUTPUT 2	&gt;</body><body>SQL_PARAM_OUTPUT	&lt;C: #define SQL_PARAM_OUTPUT 4	&gt;</body><body>SQL_PARAM_TYPE_DEFAULT	&lt;C: #define SQL_PARAM_TYPE_DEFAULT SQL_PARAM_INPUT_OUTPUT	&gt;</body><body>SQL_PARAM_TYPE_UNKNOWN	&lt;C: #define SQL_PARAM_TYPE_UNKNOWN 0	&gt;</body><body>SQL_PC_NON_PSEUDO	&lt;C: #define SQL_PC_NON_PSEUDO SQL_PC_NOT_PSEUDO	&gt;</body><body>SQL_PC_NOT_PSEUDO	&lt;C: #define SQL_PC_NOT_PSEUDO 1	&gt;</body><body>SQL_PC_PSEUDO	&lt;C: #define SQL_PC_PSEUDO 2	&gt;</body><body>SQL_PC_UNKNOWN	&lt;C: #define SQL_PC_UNKNOWN 0	&gt;</body><body>SQL_POSITION	&lt;C: #define SQL_POSITION 0	&gt;</body><body>SQL_POSITIONED_STATEMENTS	&lt;C: #define SQL_POSITIONED_STATEMENTS 80	&gt;</body><body>SQL_POS_ADD	&lt;C: #define SQL_POS_ADD 0x00000010	&gt;</body><body>SQL_POS_DELETE	&lt;C: #define SQL_POS_DELETE 0x00000008	&gt;</body><body>SQL_POS_OPERATIONS	&lt;C: #define SQL_POS_OPERATIONS 79	&gt;</body><body>SQL_POS_POSITION	&lt;C: #define SQL_POS_POSITION 0x00000001	&gt;</body><body>SQL_POS_REFRESH	&lt;C: #define SQL_POS_REFRESH 0x00000002	&gt;</body><body>SQL_POS_UPDATE	&lt;C: #define SQL_POS_UPDATE 0x00000004	&gt;</body><body>SQL_PROCEDURES	&lt;C: #define SQL_PROCEDURES 21	&gt;</body><body>SQL_PROCEDURE_TERM	&lt;C: #define SQL_PROCEDURE_TERM 40	&gt;</body><body>SQL_PS_POSITIONED_DELETE	&lt;C: #define SQL_PS_POSITIONED_DELETE 0x00000001	&gt;</body><body>SQL_PS_POSITIONED_UPDATE	&lt;C: #define SQL_PS_POSITIONED_UPDATE 0x00000002	&gt;</body><body>SQL_PS_SELECT_FOR_UPDATE	&lt;C: #define SQL_PS_SELECT_FOR_UPDATE 0x00000004	&gt;</body><body>SQL_PT_FUNCTION	&lt;C: #define SQL_PT_FUNCTION 2	&gt;</body><body>SQL_PT_PROCEDURE	&lt;C: #define SQL_PT_PROCEDURE 1	&gt;</body><body>SQL_PT_UNKNOWN	&lt;C: #define SQL_PT_UNKNOWN 0	&gt;</body><body>SQL_QL_END	&lt;C: #define SQL_QL_END 0x0002	&gt;</body><body>SQL_QL_START	&lt;C: #define SQL_QL_START 0x0001	&gt;</body><body>SQL_QUALIFIER_LOCATION	&lt;C: #define SQL_QUALIFIER_LOCATION 114	&gt;</body><body>SQL_QUALIFIER_NAME_SEPARATOR	&lt;C: #define SQL_QUALIFIER_NAME_SEPARATOR 41	&gt;</body><body>SQL_QUALIFIER_TERM	&lt;C: #define SQL_QUALIFIER_TERM 42	&gt;</body><body>SQL_QUALIFIER_USAGE	&lt;C: #define SQL_QUALIFIER_USAGE 92	&gt;</body><body>SQL_QUERY_TIMEOUT	&lt;C: #define SQL_QUERY_TIMEOUT 0	&gt;</body><body>SQL_QUERY_TIMEOUT_DEFAULT	&lt;C: #define SQL_QUERY_TIMEOUT_DEFAULT 0L	&gt;</body><body>SQL_QUICK	&lt;C: #define SQL_QUICK 0	&gt;</body><body>SQL_QUIET_MODE	&lt;C: #define SQL_QUIET_MODE 111	&gt;</body><body>SQL_QUOTED_IDENTIFIER_CASE	&lt;C: #define SQL_QUOTED_IDENTIFIER_CASE 93	&gt;</body><body>SQL_QU_DML_STATEMENTS	&lt;C: #define SQL_QU_DML_STATEMENTS 0x00000001	&gt;</body><body>SQL_QU_INDEX_DEFINITION	&lt;C: #define SQL_QU_INDEX_DEFINITION 0x00000008	&gt;</body><body>SQL_QU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_QU_PRIVILEGE_DEFINITION 0x00000010	&gt;</body><body>SQL_QU_PROCEDURE_INVOCATION	&lt;C: #define SQL_QU_PROCEDURE_INVOCATION 0x00000002	&gt;</body><body>SQL_QU_TABLE_DEFINITION	&lt;C: #define SQL_QU_TABLE_DEFINITION 0x00000004	&gt;</body><body>SQL_RD_DEFAULT	&lt;C: #define SQL_RD_DEFAULT SQL_RD_ON	&gt;</body><body>SQL_RD_OFF	&lt;C: #define SQL_RD_OFF 0L	&gt;</body><body>SQL_RD_ON	&lt;C: #define SQL_RD_ON 1L	&gt;</body><body>SQL_REAL	&lt;C: #define SQL_REAL 7	&gt;</body><body>SQL_REFRESH	&lt;C: #define SQL_REFRESH 1	&gt;</body><body>SQL_RESET_PARAMS	&lt;C: #define SQL_RESET_PARAMS 3	&gt;</body><body>SQL_RESTRICT	&lt;C: #define SQL_RESTRICT 1	&gt;</body><body>SQL_RESULT_COL	&lt;C: #define SQL_RESULT_COL 3	&gt;</body><body>SQL_RETRIEVE_DATA	&lt;C: #define SQL_RETRIEVE_DATA 11	&gt;</body><body>SQL_RETURN_VALUE	&lt;C: #define SQL_RETURN_VALUE 5	&gt;</body><body>SQL_ROLLBACK	&lt;C: #define SQL_ROLLBACK 1	&gt;</body><body>SQL_ROWSET_SIZE	&lt;C: #define SQL_ROWSET_SIZE 9	&gt;</body><body>SQL_ROWSET_SIZE_DEFAULT	&lt;C: #define SQL_ROWSET_SIZE_DEFAULT 1L	&gt;</body><body>SQL_ROWVER	&lt;C: #define SQL_ROWVER 2	&gt;</body><body>SQL_ROW_ADDED	&lt;C: #define SQL_ROW_ADDED 4	&gt;</body><body>SQL_ROW_DELETED	&lt;C: #define SQL_ROW_DELETED 1	&gt;</body><body>SQL_ROW_ERROR	&lt;C: #define SQL_ROW_ERROR 5	&gt;</body><body>SQL_ROW_NOROW	&lt;C: #define SQL_ROW_NOROW 3	&gt;</body><body>SQL_ROW_NUMBER	&lt;C: #define SQL_ROW_NUMBER 14	&gt;</body><body>SQL_ROW_SUCCESS	&lt;C: #define SQL_ROW_SUCCESS 0	&gt;</body><body>SQL_ROW_UPDATED	&lt;C: #define SQL_ROW_UPDATED 2	&gt;</body><body>SQL_ROW_UPDATES	&lt;C: #define SQL_ROW_UPDATES 11	&gt;</body><body>SQL_SCCO_LOCK	&lt;C: #define SQL_SCCO_LOCK 0x00000002	&gt;</body><body>SQL_SCCO_OPT_ROWVER	&lt;C: #define SQL_SCCO_OPT_ROWVER 0x00000004	&gt;</body><body>SQL_SCCO_OPT_TIMESTAMP	&lt;C: #define SQL_SCCO_OPT_TIMESTAMP SQL_SCCO_OPT_ROWVER	&gt;</body><body>SQL_SCCO_OPT_VALUES	&lt;C: #define SQL_SCCO_OPT_VALUES 0x00000008	&gt;</body><body>SQL_SCCO_READ_ONLY	&lt;C: #define SQL_SCCO_READ_ONLY 0x00000001	&gt;</body><body>SQL_SCOPE_CURROW	&lt;C: #define SQL_SCOPE_CURROW 0	&gt;</body><body>SQL_SCOPE_SESSION	&lt;C: #define SQL_SCOPE_SESSION 2	&gt;</body><body>SQL_SCOPE_TRANSACTION	&lt;C: #define SQL_SCOPE_TRANSACTION 1	&gt;</body><body>SQL_SCROLL_CONCURRENCY	&lt;C: #define SQL_SCROLL_CONCURRENCY 43	&gt;</body><body>SQL_SCROLL_DYNAMIC	&lt;C: #define SQL_SCROLL_DYNAMIC (-2)	&gt;</body><body>SQL_SCROLL_FORWARD_ONLY	&lt;C: #define SQL_SCROLL_FORWARD_ONLY 0	&gt;</body><body>SQL_SCROLL_KEYSET_DRIVEN	&lt;C: #define SQL_SCROLL_KEYSET_DRIVEN (-1)	&gt;</body><body>SQL_SCROLL_OPTIONS	&lt;C: #define SQL_SCROLL_OPTIONS 44	&gt;</body><body>SQL_SCROLL_STATIC	&lt;C: #define SQL_SCROLL_STATIC (-3)	&gt;</body><body>SQL_SC_NON_UNIQUE	&lt;C: #define SQL_SC_NON_UNIQUE 0L	&gt;</body><body>SQL_SC_TRY_UNIQUE	&lt;C: #define SQL_SC_TRY_UNIQUE 1L	&gt;</body><body>SQL_SC_UNIQUE	&lt;C: #define SQL_SC_UNIQUE 2L	&gt;</body><body>SQL_SEARCHABLE	&lt;C: #define SQL_SEARCHABLE 3	&gt;</body><body>SQL_SEARCH_PATTERN_ESCAPE	&lt;C: #define SQL_SEARCH_PATTERN_ESCAPE 14	&gt;</body><body>SQL_SERVER_NAME	&lt;C: #define SQL_SERVER_NAME 13	&gt;</body><body>SQL_SETPARAM_VALUE_MAX	&lt;C: #define SQL_SETPARAM_VALUE_MAX (-1)	&gt;</body><body>SQL_SET_NULL	&lt;C: #define SQL_SET_NULL 2	&gt;</body><body>SQL_SIGNED_OFFSET	&lt;C: #define SQL_SIGNED_OFFSET (-20)	&gt;</body><body>SQL_SIMULATE_CURSOR	&lt;C: #define SQL_SIMULATE_CURSOR 10	&gt;</body><body>SQL_SMALLINT	&lt;C: #define SQL_SMALLINT 5	&gt;</body><body>SQL_SO_DYNAMIC	&lt;C: #define SQL_SO_DYNAMIC 0x00000004	&gt;</body><body>SQL_SO_FORWARD_ONLY	&lt;C: #define SQL_SO_FORWARD_ONLY 0x00000001	&gt;</body><body>SQL_SO_KEYSET_DRIVEN	&lt;C: #define SQL_SO_KEYSET_DRIVEN 0x00000002	&gt;</body><body>SQL_SO_MIXED	&lt;C: #define SQL_SO_MIXED 0x00000008	&gt;</body><body>SQL_SO_STATIC	&lt;C: #define SQL_SO_STATIC 0x00000010	&gt;</body><body>SQL_SPECIAL_CHARACTERS	&lt;C: #define SQL_SPECIAL_CHARACTERS 94	&gt;</body><body>SQL_SPEC_MAJOR	&lt;C: #define SQL_SPEC_MAJOR 2	&gt;</body><body>SQL_SPEC_MINOR	&lt;C: #define SQL_SPEC_MINOR 1	&gt;</body><body>SQL_SPEC_STRING	&lt;C: #define SQL_SPEC_STRING "02.01"	&gt;</body><body>SQL_SQLSTATE_SIZE	&lt;C: #define SQL_SQLSTATE_SIZE 5	&gt;</body><body>SQL_SQ_COMPARISON	&lt;C: #define SQL_SQ_COMPARISON 0x00000001	&gt;</body><body>SQL_SQ_CORRELATED_SUBQUERIES	&lt;C: #define SQL_SQ_CORRELATED_SUBQUERIES 0x00000010	&gt;</body><body>SQL_SQ_EXISTS	&lt;C: #define SQL_SQ_EXISTS 0x00000002	&gt;</body><body>SQL_SQ_IN	&lt;C: #define SQL_SQ_IN 0x00000004	&gt;</body><body>SQL_SQ_QUANTIFIED	&lt;C: #define SQL_SQ_QUANTIFIED 0x00000008	&gt;</body><body>SQL_SS_ADDITIONS	&lt;C: #define SQL_SS_ADDITIONS 0x00000001	&gt;</body><body>SQL_SS_DELETIONS	&lt;C: #define SQL_SS_DELETIONS 0x00000002	&gt;</body><body>SQL_SS_UPDATES	&lt;C: #define SQL_SS_UPDATES 0x00000004	&gt;</body><body>SQL_STATIC_SENSITIVITY	&lt;C: #define SQL_STATIC_SENSITIVITY 83	&gt;</body><body>SQL_STILL_EXECUTING	&lt;C: #define SQL_STILL_EXECUTING 2	&gt;</body><body>SQL_STMT_OPT_MAX	&lt;C: #define SQL_STMT_OPT_MAX SQL_ROW_NUMBER	&gt;</body><body>SQL_STMT_OPT_MIN	&lt;C: #define SQL_STMT_OPT_MIN SQL_QUERY_TIMEOUT	&gt;</body><body>SQL_STRING_FUNCTIONS	&lt;C: #define SQL_STRING_FUNCTIONS 50	&gt;</body><body>SQL_SUBQUERIES	&lt;C: #define SQL_SUBQUERIES 95	&gt;</body><body>SQL_SUCCESS	&lt;C: #define SQL_SUCCESS 0	&gt;</body><body>SQL_SUCCESS_WITH_INFO	&lt;C: #define SQL_SUCCESS_WITH_INFO 1	&gt;</body><body>SQL_SYSTEM_FUNCTIONS	&lt;C: #define SQL_SYSTEM_FUNCTIONS 51	&gt;</body><body>SQL_TABLE_STAT	&lt;C: #define SQL_TABLE_STAT 0	&gt;</body><body>SQL_TABLE_TERM	&lt;C: #define SQL_TABLE_TERM 45	&gt;</body><body>SQL_TC_ALL	&lt;C: #define SQL_TC_ALL 0x0002	&gt;</body><body>SQL_TC_DDL_COMMIT	&lt;C: #define SQL_TC_DDL_COMMIT 0x0003	&gt;</body><body>SQL_TC_DDL_IGNORE	&lt;C: #define SQL_TC_DDL_IGNORE 0x0004	&gt;</body><body>SQL_TC_DML	&lt;C: #define SQL_TC_DML 0x0001	&gt;</body><body>SQL_TC_NONE	&lt;C: #define SQL_TC_NONE 0x0000	&gt;</body><body>SQL_TIME	&lt;C: #define SQL_TIME 10	&gt;</body><body>SQL_TIMEDATE_ADD_INTERVALS	&lt;C: #define SQL_TIMEDATE_ADD_INTERVALS 109	&gt;</body><body>SQL_TIMEDATE_DIFF_INTERVALS	&lt;C: #define SQL_TIMEDATE_DIFF_INTERVALS 110	&gt;</body><body>SQL_TIMEDATE_FUNCTIONS	&lt;C: #define SQL_TIMEDATE_FUNCTIONS 52	&gt;</body><body>SQL_TIMESTAMP	&lt;C: #define SQL_TIMESTAMP 11	&gt;</body><body>SQL_TINYINT	&lt;C: #define SQL_TINYINT (-6)	&gt;</body><body>SQL_TRANSLATE_DLL	&lt;C: #define SQL_TRANSLATE_DLL 106	&gt;</body><body>SQL_TRANSLATE_OPTION	&lt;C: #define SQL_TRANSLATE_OPTION 107	&gt;</body><body>SQL_TXN_CAPABLE	&lt;C: #define SQL_TXN_CAPABLE 46	&gt;</body><body>SQL_TXN_ISOLATION	&lt;C: #define SQL_TXN_ISOLATION 108	&gt;</body><body>SQL_TXN_ISOLATION_OPTION	&lt;C: #define SQL_TXN_ISOLATION_OPTION 72	&gt;</body><body>SQL_TXN_READ_COMMITTED	&lt;C: #define SQL_TXN_READ_COMMITTED 0x00000002	&gt;</body><body>SQL_TXN_READ_UNCOMMITTED	&lt;C: #define SQL_TXN_READ_UNCOMMITTED 0x00000001	&gt;</body><body>SQL_TXN_REPEATABLE_READ	&lt;C: #define SQL_TXN_REPEATABLE_READ 0x00000004	&gt;</body><body>SQL_TXN_SERIALIZABLE	&lt;C: #define SQL_TXN_SERIALIZABLE 0x00000008	&gt;</body><body>SQL_TXN_VERSIONING	&lt;C: #define SQL_TXN_VERSIONING 0x00000010	&gt;</body><body>SQL_TYPE_DATE	&lt;C: #define SQL_TYPE_DATE      91	&gt;</body><body>SQL_TYPE_DRIVER_START	&lt;C: #define SQL_TYPE_DRIVER_START (-80)	&gt;</body><body>SQL_TYPE_MAX	&lt;C: #define SQL_TYPE_MAX SQL_VARCHAR	&gt;</body><body>SQL_TYPE_MIN	&lt;C: #define SQL_TYPE_MIN SQL_BIT	&gt;</body><body>SQL_TYPE_NULL	&lt;C: #define SQL_TYPE_NULL 0	&gt;</body><body>SQL_TYPE_TIME	&lt;C: #define SQL_TYPE_TIME      92	&gt;</body><body>SQL_TYPE_TIMESTAMP	&lt;C: #define SQL_TYPE_TIMESTAMP 93	&gt;</body><body>SQL_UB_DEFAULT	&lt;C: #define SQL_UB_DEFAULT SQL_UB_OFF	&gt;</body><body>SQL_UB_OFF	&lt;C: #define SQL_UB_OFF 0L	&gt;</body><body>SQL_UB_ON	&lt;C: #define SQL_UB_ON 1L	&gt;</body><body>SQL_UNBIND	&lt;C: #define SQL_UNBIND 2	&gt;</body><body>SQL_UNION	&lt;C: #define SQL_UNION 96	&gt;</body><body>SQL_UNSEARCHABLE	&lt;C: #define SQL_UNSEARCHABLE 0	&gt;</body><body>SQL_UNSIGNED_OFFSET	&lt;C: #define SQL_UNSIGNED_OFFSET (-22)	&gt;</body><body>SQL_UPDATE	&lt;C: #define SQL_UPDATE 2	&gt;</body><body>SQL_USER_NAME	&lt;C: #define SQL_USER_NAME 47	&gt;</body><body>SQL_USE_BOOKMARKS	&lt;C: #define SQL_USE_BOOKMARKS 12	&gt;</body><body>SQL_U_UNION	&lt;C: #define SQL_U_UNION 0x00000001	&gt;</body><body>SQL_U_UNION_ALL	&lt;C: #define SQL_U_UNION_ALL 0x00000002	&gt;</body><body>SQL_VARBINARY	&lt;C: #define SQL_VARBINARY (-3)	&gt;</body><body>SQL_VARCHAR	&lt;C: #define SQL_VARCHAR 12	&gt;</body><body>SQL_WCHAR	&lt;C: #define SQL_WCHAR (-8)		&gt;</body><body>SQL_WLONGVARCHAR	&lt;C: #define SQL_WLONGVARCHAR (-10)	&gt;</body><body>SQL_WVARCHAR	&lt;C: #define SQL_WVARCHAR	 (-9)	&gt;</body><body>__DATE__	&lt;C: #define __DATE__ "May 29, 1996"	&gt;</body><body>__FILE__	&lt;C: #define __FILE__ 	&gt;</body><body>__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body>__SQL	&lt;C: #define __SQL 	&gt;</body><body>__SQLEXT	&lt;C: #define __SQLEXT 	&gt;</body><body>__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body>__TIME__	&lt;C: #define __TIME__ "9:29:08 am"	&gt;</body></methods><methods><class-id>Aragon.ODBCInterface class</class-id> <category>class initialization</category><body>eliminateMacros	"self eliminateMacros"	self fillDefineCachesWithValues</body><body>flushAllCaches	ExternalBuffers notNil ifTrue: [ExternalBuffers do: [:each | each isNull ifFalse: [each free]]].	ExternalBuffers := IdentityDictionary new.	^super flushAllCaches</body><body>initialize	"ODBCInterface initialize"	self flushAllCaches.	self fillDefineCaches.	DriverInfoString := CArrayType new referentType: CIntegerType char; numElements: 72.</body><body>initializeErrorSignals	"ODBCInterface initializeErrorSignals"	GenericErrorSignal := ExternalDatabaseConnection externalDatabaseErrorSignal newSignalMayProceed: true.	ErrorSignals := IdentityDictionary new		at: SQL_ERROR value				put: (GenericErrorSignal				notifierString: 'ODBC Error: SQL_ERROR');		at: SQL_SUCCESS_WITH_INFO value	put: (GenericErrorSignal newSignal	notifierString: 'ODBC Error: SQL_SUCCESS_WITH_INFO');		at: SQL_NO_DATA_FOUND value		put: (GenericErrorSignal newSignal	notifierString: 'ODBC Error: SQL_NO_DATA_FOUND');		at: SQL_INVALID_HANDLE value		put: (GenericErrorSignal newSignal	notifierString: 'ODBC Error: SQL_INVALID_HANDLE');		at: SQL_STILL_EXECUTING value		put: (GenericErrorSignal newSignal	notifierString: 'ODBC Error: SQL_STILL_EXECUTING');		at: SQL_NEED_DATA value			put: (GenericErrorSignal newSignal	notifierString: 'ODBC Error: SQL_NEED_DATA');	yourself.</body></methods><methods><class-id>Aragon.ODBCInterface class</class-id> <category>Signal constants</category><body>errorSignal	^GenericErrorSignal</body><body>errorSignalsDictionary	^ErrorSignals</body><body>invalidHandleSignal	^ErrorSignals at: SQL_INVALID_HANDLE value</body><body>needDataSignal	^ErrorSignals at: SQL_NEED_DATA value</body><body>noDataFoundSignal	^ErrorSignals at: SQL_NO_DATA_FOUND value</body><body>stillExecutingSignal	^ErrorSignals at: SQL_STILL_EXECUTING value</body><body>successWithInfoSignal	^ErrorSignals at: SQL_SUCCESS_WITH_INFO value</body></methods><methods><class-id>Aragon.ODBCInterface class</class-id> <category>constants</category><body>reservedWords"The following words are reserved for use in ODBC function calls. These words do not constrain the minimum SQL grammar; however, to ensure compatibility with drivers that support the core SQL grammar, applications should avoid using any of these keywords. The #define value SQL_ODBC_KEYWORDS contains a comma-separated list of these keywords."^#('ABSOLUTE''ACTION''ADA''ADD''ALL''ALLOCATE''ALTER''AND''ANY''ARE''AS''ASC''ASSERTION''AT''AUTHORIZATION''AVG''BEGIN''BETWEEN''BIT''BIT_LENGTH''BOTH''BY''CASCADE''CASCADED''CASE''CAST''CATALOG''CHAR''CHAR_LENGTH''CHARACTER''CHARACTER_LENGTH''CHECK''CLOSE''COALESCE''COBOL''COLLATE''COLLATION''COLUMN''COMMIT''CONNECT''CONNECTION''CONSTRAINT''CONSTRAINTS''CONTINUE''CONVERT''CORRESPONDING''COUNT''CREATE''CROSS''CURRENT''CURRENT_DATE''CURRENT_TIME''CURRENT_TIMESTAMP''CURRENT_USER''CURSOR''DATE''DAY''DEALLOCATE''DEC''DECIMAL''DECLARE''DEFAULT''DEFERRABLE''DEFERRED''DELETE''DESC''DESCRIBE''DESCRIPTOR''DIAGNOSTICS''DISCONNECT''DISTINCT''DOMAIN''DOUBLE''DROP''ELSE''END''END-EXEC''ESCAPE''EXCEPT''EXCEPTION''EXEC''EXECUTE''EXISTS''EXTERNAL''EXTRACT''FALSE''FETCH''FIRST''FLOAT''FOR''FOREIGN''FORTRAN''FOUND''FROM''FULL''GET''GLOBAL''GO''GOTO''GRANT''GROUP''HAVING''HOUR''IDENTITY''IMMEDIATE''IN''INCLUDE''INDEX''INDICATOR''INITIALLY''INNER''INPUT''INSENSITIVE''INSERT''INTEGER''INTERSECT''INTERVAL''INTO''IS''ISOLATION''JOIN''KEY''LANGUAGE''LAST''LEADING''LEFT''LEVEL''LIKE''LOCAL''LOWER''MATCH''MAX''MIN''MINUTE''MODULE''MONTH''MUMPS''NAMES''NATIONAL''NATURAL''NCHAR''NEXT''NO''NONE''NOT''NULL''NULLIF''NUMERIC''OCTET_LENGTH''OF''ON''ONLY''OPEN''OPTION''OR''ORDER''OUTER''OUTPUT''OVERLAPS''PAD''PARTIAL''PASCAL''PLI''POSITION''PRECISION''PREPARE''PRESERVE''PRIMARY''PRIOR''PRIVILEGES''PROCEDURE''PUBLIC''REFERENCES''RELATIVE''RESTRICT''REVOKE''RIGHT''ROLLBACK''ROWS''SCHEMA''SCROLL''SECOND''SECTION''SELECT''SEQUENCE''SESSION''SESSION_USER''SET''SIZE''SMALLINT''SOME''SPACE''SQL''SQLCA''SQLCODE''SQLERROR''SQLSTATE''SQLWARNING''SUBSTRING''SUM''SYSTEM_USER''TABLE''TEMPORARY''THEN''TIME''TIMESTAMP''TIMEZONE_HOUR''TIMEZONE_MINUTE''TO''TRAILING''TRANSACTION''TRANSLATE''TRANSLATION''TRIM''TRUE''UNION''UNIQUE''UNKNOWN''UPDATE''UPPER''USAGE''USER''USING''VALUE''VALUES''VARCHAR''VARYING''VIEW''WHEN''WHENEVER''WHERE''WITH''WORK''YEAR').</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>data processing</category><body>prepare: aString 	"Prepare aString for processing."	(hstmt ~~ nil and: [aString = query])		ifTrue: 			["If we are about to prepare a query which is exactly the same as the query processed 			before, we do not need to do the full job of preparing as would be done in the 			superclass's implementation of prepare:. Rather we are able to reuse both the prepared 			statement in the odbc driver, as well as the parameter and column bindings."			| stateTemp |			self isExecuting ifTrue: ["Should we clean up after any previous work?"				self cancel].			self state == #new ifTrue: ["If not already held, acquire the right to execute SQL statements."				self connect].			((stateTemp := self state) == #connected or: ["Enforce: we're in a legal state to prepare new SQL text."				stateTemp == #prepared])				ifFalse: [self class connectionClass invalidSessionStateSignal raise]]		ifFalse: [super prepare: aString]</body><body>rowCount	"Answer an Integer representing the number of rows affected by the previous query. 	Valid only after the query has been answered."	^affectedRows</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>schema access</category><body>describeColumns: aTableName 	^self		getColumnsOfTable: aTableName		qualifier: nil		owner: nil</body><body>getColumnsOfTable: aTableName qualifier: aQualifier owner: anOwner 	| answer |	self class traceLevel &gt;= 1 ifTrue: [self class trace: 'Looking up columns for table "', aTableName, '" ...'].	hstmt == nil ifFalse: [self dismiss].	affectedRows := 0.	self acquire state: #ready.	self handle: (self xif SQLColumns: hstmt			with: aQualifier			with: SQL_NTS value			with: anOwner			with: SQL_NTS value			with: aTableName		with: SQL_NTS value			with: nil "columnPattern"	with: SQL_NTS value).	answer := OrderedCollection new.	self answer do: [:t | (answer add: Dictionary new) 			add: #catalog -&gt; (t at: 1);			add: #schema -&gt; (t at: 2);			add: #table -&gt; (t at: 3);			add: #name -&gt; (t at: 4);			add: #type -&gt; (t at: 5);			add: #nativeType -&gt; (t at: 6);			add: #columnSize -&gt; (t at: 7);			add: #maxLength -&gt; (t at: 8);			add: #nullable -&gt; (t at: 11)].	self disconnect.	^answer</body><body>getPrimaryKeysFor: aTableName	| answer |	self class traceLevel &gt;= 1 ifTrue: [self class trace: 'Looking up columns for table "', aTableName, '" ...'].	hstmt == nil ifFalse: [self dismiss].	self acquire state: #ready.	affectedRows := 0.	answer := OrderedCollection new.	ODBCInterface errorSignal		handle: [:ex | ex return]		do:			[self xif SQLPrimaryKeys: hstmt				with: nil "aLensTable	qualifier"	with: SQL_NTS value				with: nil	"anOwner"			with: SQL_NTS value				with: aTableName		with: SQL_NTS value.			self answer do: [:x | answer add: (x at: 4)]].	self disconnect.	^answer</body><body>listTables	"Answer a collection of tables available in the receiver's database."		^self listTablesLike: '%'.</body><body>listTablesLike: aString 	"Answer a collection of tables available in the receiver's database."	| pattern i owner tableType answer qualifier tokens |	hstmt == nil ifFalse: [self dismiss].	affectedRows := 0.	owner := ''.	((pattern := aString) isNil or: [aString isEmpty])		ifTrue: [pattern := '%'].	tokens := (pattern tokensBasedOn: $.) reverse.	pattern	:= tokens at: (i := 1).	owner	:= tokens size &gt; i ifTrue: [tokens at: (i := i+1)].	qualifier	:= tokens size &gt; i ifTrue: [tokens at: (i := i+1)].	(qualifier notNil and: [qualifier isEmpty]) ifTrue: [qualifier := nil].	(owner notNil and: [owner isEmpty]) ifTrue: [owner := nil].	tableType := aString first == $+ ifTrue: ['SYSTEM TABLE'] ifFalse: ['TABLE'].	self acquire state: #ready.	self handle: (self xif SQLTables: hstmt			with: qualifier		with: SQL_NTS value			with: owner			with: SQL_NTS value			with: pattern			with: SQL_NTS value			with: tableType		with: SQL_NTS value).	answer := OrderedCollection new.	self answer do: [:t | (answer add: IdentityDictionary new) 			add: #name -&gt; (t at: 3);			add: #owner -&gt; (t at: 2);			add: #tableType -&gt; (t at: 4);			add: #qualifier -&gt; (t at: 1)].	self dismiss.	^answer</body><body>typeInfoFor: anSqlType	| sqlTypeCode answer |	sqlTypeCode := anSqlType isSymbol 			ifTrue: [(ODBCInterfaceDictionary at: ('SQL_', anSqlType) asSymbol) value] 			ifFalse: [anSqlType].	hstmt == nil ifFalse: [self dismiss].	self acquire state: #ready.	affectedRows := 0.	[self handle: (self xif SQLGetTypeInfo: hstmt with: sqlTypeCode).	answer := IdentityDictionary new.	self answer do: [:t | answer add: (ODBCTypeMapping typeNameFor: (t at: 2)) -&gt; t].	] valueNowOrOnUnwindDo: [self disconnect].	^answer</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>printing</category><body>printOn: aStream	super printOn: aStream.	aStream space; nextPut: $(.	(hstmt notNil ifTrue: [hstmt referentAddress]) printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private-answer set</category><body>advanceExternal	"Advance the current row. If blockFactor is supported, this may entail fetching 	many rows but doing it infrequently. If there are no more rows, answer nil. 	Otherwise, answering self is sufficient."	| retcode |	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	(retcode := self xif SQLFetch: hstmt) = SQL_NO_DATA_FOUND value ifTrue: [^nil].	self handle: retcode.	affectedRows := affectedRows + 1</body><body>allocateRowBufferExternal: anIndex 	"Answer an object describing space allocated for holding one column's 	worth of information as returned by the dbms api. The driver is responsible 	for defining the structure of the object returned."	| cd buffer |	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	cd := columnDescriptions at: anIndex.	buffer := ODBCDatabaseBuffer new "		elementSize: (cd maxColumnConstraint isNil ifTrue: [0] ifFalse: [cd maxColumnConstraint])"		elementSize: cd maxColumnConstraint		count: 0 "We only have single values"		databaseType: cd sqlTypeCode.	buffer isLarge 		ifFalse: [self handle: (self xif			SQLBindCol: hstmt			with: anIndex			with: buffer cType			with: buffer pointer			with: buffer size			with: buffer indicator)].	^buffer</body><body>answerStreamDismissed	"Note that the answer stream has dismissed itself."	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	self handle: (self xif SQLFreeStmt: hstmt with: SQL_CLOSE value).	^super answerStreamDismissed.</body><body>cancelAnswerSetExternal	"Cancel any resources associated with the current answer set"	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	self handle: (self xif SQLCancel: hstmt)</body><body>coalesce: bufferValue	"Attempt to coalesce segments of data into a single large segment. 	Assumes very last segment of data is the smallest."	| firstSegSize lastSegSize allocationSize copyIndex nSlots largeSegment |	((nSlots := bufferValue size ) &gt; 1 ) 		ifFalse: [^bufferValue at: 1].	firstSegSize := (bufferValue at: 1) size.		lastSegSize := (bufferValue at: nSlots) size.		allocationSize := (nSlots - 1) * firstSegSize + lastSegSize.	"Choose an appropriate object to hold chunks."	largeSegment := (bufferValue at: 1) species new: allocationSize.	copyIndex := 0.	bufferValue do: [:segment | 		largeSegment  replaceFrom: copyIndex + 1					    to: copyIndex + segment size					    with: segment					    startingAt: 1.					    copyIndex := copyIndex + segment size].	"Explicitly discard previously held segments of data and replace with a single large segment."	^largeSegment.</body><body>getColumnDescriptionExternal: anIndex 	| buffer |	anIndex &gt; self numColumns ifTrue: [^nil].	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	buffer := self class columnDescriptionBuffer.	self handle: (self xif			SQLDescribeCol: hstmt			with: anIndex			with: buffer name			with: self class maxColumnName			with: buffer scale			with: buffer sqlTypeCode			with: buffer maxColumnConstraint			with: buffer precision			with: buffer nullable).	^(self connection class columnDescriptionClass new)		name:					buffer name copyCStringFromHeap;		sqlTypeCode:			buffer sqlTypeCode contents;		index:					anIndex;		precision:				buffer precision contents;		scale:					0;		nullable:					buffer nullable contents;		maxColumnConstraint:	buffer maxColumnConstraint contents;	yourself.</body><body>getFieldExternal: columnIndex 	| buffer value |	buffer := self rowBuffers at: columnIndex.	buffer isLarge ifTrue: [^self getLargeObjectExternal: columnIndex].	(value := buffer value) isNil		ifFalse: 			[| t | t := (self columnDescriptions at: columnIndex) type.			(t ~~ nil and: [t includesBehavior: Symbol])				ifTrue: [^value asSymbol]].	^value</body><body>getLargeObjectExternal: columnIndex 	| buffer xif bytes maxBytesToCopy chunkSize rc answer nextChunkSize |	buffer := self rowBuffers at: columnIndex.	xif := self xif.	bytes := 0.	answer := OrderedCollection new: 0.	chunkSize := (ODBCColumnDescription maxLengths at: buffer databaseType) last.	maxBytesToCopy := (ODBCColumnDescription maxLengths at: buffer databaseType) first.	[bytes &gt;= maxBytesToCopy ]		whileFalse: 			[nextChunkSize := ((maxBytesToCopy - bytes) min: chunkSize).			rc := self handle: (xif SQLGetData: hstmt					with: columnIndex					with: buffer cType					with: buffer pointer					with: nextChunkSize					with: buffer indicator).			(rc == xif SQL_SUCCESS_WITH_INFO 			and: [(xif getErrorInfo: connection henv dbc: connection handle stmt: hstmt) 					dbmsErrorCode = '01004']) 				ifTrue: 					["Data has been truncated"					buffer indicator contents: (maxBytesToCopy min: chunkSize).					bytes := bytes + nextChunkSize]				ifFalse: 					["All the data for the receiver has been received"					buffer indicator contents: (maxBytesToCopy min: buffer indicator contents).					bytes := maxBytesToCopy + 1].			"Convert the data chunk to an appropriate object and add it."			answer add: buffer value].		^self coalesce: answer</body><body>hasAnswerSetExternal	"Answer true if the SQL-statement (batch) being processed returns an answer set."	| buffer odbc |	odbc := self xif.	buffer := odbc bufferFor: SWORD.	self handle: (odbc SQLNumResultCols: hstmt with: buffer).	self numColumns: buffer contents.	^self numColumns &gt; 0</body><body>releaseBuffers	"Release buffers and their associated resources."	"Subclasses may release subclass-specific resources before invoking this method."	| buffers |	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	(buffers := self rowBuffers) notNil ifTrue: [buffers do: [:each | each free]].	parameterBuffers notNil		ifTrue: 			[parameterBuffers do: [:each | each release].			parameterBuffers := nil].	hstmt notNil		ifTrue: 			[self handle: (self xif SQLFreeStmt: hstmt with: SQL_RESET_PARAMS value).			self handle: (self xif SQLFreeStmt: hstmt with: SQL_UNBIND value)].	^super releaseBuffers</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private-library calls</category><body>acquireExternal	| odbc buffer |	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	odbc := self xif.	buffer := odbc bufferFor: HANDLE.	self handle: (odbc SQLAllocStmt: self connection handle with: buffer).	hstmt := buffer contents</body><body>dismissExternal	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	hstmt notNil ifTrue: [self handle: (self xif SQLFreeStmt: hstmt with: SQL_DROP value).  hstmt := nil].</body><body>installExternal	"Perform return from snapshot processing."	"Subclasses that override should invoke super installExternal."	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	hstmt := nil.	super installExternal.	"Assure: no dangling CPointers remain."</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private-finalization</category><body>key	"Key value to use when inserting receiver into a handle registry. This value 	needs to be unique within the registry."	^hstmt</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private-execution</category><body>cancelExternal	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	hstmt == nil ifTrue: [^self].	ODBCInterface successWithInfoSignal 		handle: [:ex | "ignore it"]		do: [self handle: (self xif SQLCancel: hstmt)].</body><body>executeExternal	"Execute the prepared query."	"Subclasses that don't support query preparation will need to assemble the 	query in the overriding method."	| odbc |	self class traceLevel &gt;= 1 ifTrue: [self class trace: (bindValues isNil				ifTrue: [query]				ifFalse: [query , '\	' withCRs , self bindInputString])].	odbc := self xif.	self handle: (odbc SQLExecute: hstmt).	affectedRows := ('SELECT*' match: query)				ifTrue: [0]				ifFalse: 					[| buffer |					buffer := odbc bufferFor: SDWORD.					self handle: (odbc SQLRowCount: hstmt with: buffer).					buffer contents]</body><body>moreResultsExternal	"Answer true if there are more results available, otherwise answer false. 	Raise an exception if there are errors."	| retcode |	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	(retcode := self xif SQLMoreResults: hstmt) = SQL_NO_DATA_FOUND value ifTrue: [^false].	self handle: retcode.	^true</body><body>readyExternal	"Answer whether or not the dbms has processed the SQL statement (batch)."	^true</body><body>resultsExternal	"Examine the outcome of executing an SQL statement and raise exceptions	for any errors.  Answer a boolean indicating the presense of an answer."	^true</body><body>update: anObject at: columns put: values 	| n |	n := columns size min: values size.	1 to: n do: [:i | anObject instVarAt: (anObject class instVarIndexFor: (columns at: i) value asString)			put: (values at: i)].	^anObject</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private-binding</category><body>bindValue: aValue at: aPosition 	"Bind aValue at aPosition."	| index buffer |	index := (aPosition isKindOf: Symbol)				ifTrue: [(queryFragments indexOf: aPosition) // 2]				ifFalse: [aPosition].	parameterBuffers isNil ifTrue: [parameterBuffers := OrderedCollection new].	[parameterBuffers size &lt; index]		whileTrue: [parameterBuffers add: ODBCParameterBuffer new initialize].	buffer := parameterBuffers at: index.	(buffer value: aValue) == #rebind		ifTrue: 			[self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].			self handle: (self xif					SQLBindParameter: hstmt					with: index					with: SQL_PARAM_INPUT value					with: buffer mapping cTypeCode					with: buffer mapping sqlTypeCode					with: buffer size	"precision"					with: 0	"scale"					with: buffer rgbValue					with: 0					with: buffer pcbValue)]</body><body>prepareExternal	"Send the query text to the external DBMS to be prepared."	| theQuery i size |	query isEmpty ifTrue: [^self].	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	(theQuery := ReadWriteStream on: String new) nextPutAll: queryFragments first.	i := 2.	size := queryFragments size.	[i &lt;= size]		whileTrue: 			[theQuery nextPut: $?.			theQuery nextPutAll: (queryFragments at: i + 1).			i := i + 2].	self handle: (self xif			SQLPrepare: hstmt			with: theQuery contents			with: SQL_NTS value)</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private-accessing</category><body>handle	^hstmt</body><body>xif	^self class xif</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private-ObjectLens</category><body>addInput: object template: template to: aStream 	((((object isNil or: [	object isKindOf: String]) or: [	object isKindOf: Boolean]) or: [	object isKindOf: Magnitude]) or: [	object isKindOf: Timestamp])		ifTrue: 			[aStream nextPut: object.			^self].	(object isKindOf: Collection)		ifTrue: 			[1 to: object size 				do: [:i | self addInput: (object at: i) template: (template at: i) to: aStream].			^self].	1 to: template class instSize do: [:i || t |  		(t := template instVarAt: i) class ~~ Object 			ifTrue: [self addInput: (object instVarAt: i) template: t to: aStream]].</body><body>bindInput: object template: template to: stream 	('UPDATE*' match: query)		ifTrue: 			[2 to: object size do: [:i | stream nextPut: (object at: i)].			self addInput: object first template: template first to: stream]		ifFalse: [self addInput: object template: template to: stream]</body><body>flattenResultTemplate: template onto: descStream 	"Flatten an ObjectLens template onto the stream descStream."	| names descr templates |	(template class == ByteFieldDescriptor or: [template isKindOf: Magnitude])		ifTrue: [^descStream nextPut: (self getColumnDescriptionExternal: 1)].	template class isVariableSize		ifTrue: 			[templates := template.			names := Array new: templates size]		ifFalse: 			[names := template class allInstVarNames.			templates := (1 to: names size) collect: [:i | template instVarAt: i]].	(1 to: templates size)		do: 			[:i | 			| each |			(each := templates at: i) class == Object ifFalse: [(each class == ByteFieldDescriptor or: [each class == ByteString or: [(each isKindOf: Magnitude) or: [ODBCTypeMapping defaultMappings keys includes: each class]]])					ifTrue: 						[descr := (connection class columnDescriptionClass new) name: (names at: i); index: i; type: each effectiveClass; 							sqlTypeCode: (ODBCTypeMapping forClass: each effectiveClass) sqlTypeCode.						each class == ByteFieldDescriptor ifTrue: [descr maxColumnConstraint: each MaxColumnConstraint].						descStream nextPut: descr]					ifFalse: [self flattenResultTemplate: each onto: descStream]]].</body><body>nextViaTemplate: template	"Answer the object formed by reifying the template using a fetched row"	| clazz |	(clazz := template class) == Object ifTrue: [^nil].	(		(#(ByteFieldDescriptor Timestamp True False) includes: clazz name) or: [		(template isKindOf: Magnitude) or: [		(template isString and: [template isSymbol not])  	]]) 	ifTrue: [| v | v := self getFieldExternal: bufferIndex. bufferIndex := bufferIndex + 1. ^v].	(template isKindOf: Collection) 		ifTrue: [^(template isKindOf: Array)			ifTrue: [self nextViaArrayTemplate: template]			ifFalse: [self nextViaCollectionTemplate: template]].	^self nextViaEntityTemplate: template</body><body>_addInput: object template: template to: aStream 	(((object isKindOf: String) or: [object isKindOf: Magnitude]) or: [object isKindOf: Timestamp])		ifTrue: [aStream nextPut: object]		ifFalse: [(object isKindOf: Collection)				ifTrue: [1 to: object size do: [:i | self addInput: (object at: i) template: (template at: i) to: aStream]]				ifFalse: 					[1 to: template class instSize						do: [:i | (template instVarAt: i) class ~~ Object ifTrue: [aStream nextPut: (object instVarAt: i)]]]]</body><body>_nextViaTemplate: template	"Answer an object constructed via the template"	"Any template entry that digests a rowBuffer is responsible for incrementing	bufferIndex."	| values instVars columns |	values := (1 to: numColumns) collect: [:i | self getFieldExternal: i].	(template class isVariableSize)		ifTrue:			[| answer i | answer := OrderedCollection new. i := 1.			template do:				[:each | (each class == ByteFieldDescriptor or: [each isKindOf: Magnitude])					ifTrue: [answer add: (values at: i). i := i+1]					ifFalse: 						[instVars := each class allInstVarNames.						columns := OrderedCollection new.						1 to: instVars size do: [:j | (each instVarAt: j) class == Object ifFalse: [columns add: (instVars at: j) asSymbol]].						answer add: (self update: each effectiveClass new at: columns put: (values copyFrom: i to: i+columns size-1)).						i := i + columns size]].			^answer].	(template class == ByteFieldDescriptor or: [template isKindOf: Magnitude]) ifTrue: [^values first].	instVars := template class allInstVarNames.	columns := OrderedCollection new.	1 to: instVars size do: [:i | (template instVarAt: i) class == Object ifFalse: [columns add: (instVars at: i) asSymbol]].	^self update: template effectiveClass new at: columns put: values.</body></methods><methods><class-id>Aragon.ODBCSession</class-id> <category>private</category><body>bindInputString	| stream |	stream := String new writeStream.	stream nextPut: $(.	bindValues values		do: 			[:each | 			each printOn: stream.			stream nextPutAll: ' | '].	stream nextPut: $).	^stream contents</body><body>handle: aRetcode 	(aRetcode ~~ SQL_SUCCESS value and: [		aRetcode ~~  SQL_SUCCESS_WITH_INFO value]) 			ifTrue: [self xif				handleError: aRetcode				in: thisContext sender sender selector				env: (self connection ~~ nil ifTrue: [self connection henv])				dbc: (self connection ~~ nil ifTrue: [self connection handle])				stmt: self handle].	^aRetcode</body></methods><methods><class-id>Aragon.ODBCSession class</class-id> <category>accessing</category><body>columnDescriptionBuffer	ColumnDescriptionBuffer isNil 		ifTrue: [ColumnDescriptionBuffer := (self connectionClass columnDescriptionClass new)				name:						(CIntegerType unsignedChar malloc: (self maxColumnName + 1));				setMaxColumnConstraint:		UDWORD malloc;				sqlTypeCode:				SWORD malloc;				precision:					SWORD malloc;				scale:						SWORD malloc;				nullable:						SWORD	malloc;			yourself].	^ColumnDescriptionBuffer</body><body>connectionClass	"Answer the class to use for connection objects associated with receiver."	^ODBCConnection</body><body>maxColumnName	^255</body><body>releaseGlobalBuffers	ColumnDescriptionBuffer isNil ifTrue: [^self].	ColumnDescriptionBuffer name free.	ColumnDescriptionBuffer maxColumnConstraint free.	ColumnDescriptionBuffer sqlTypeCode free.	ColumnDescriptionBuffer precision free.	ColumnDescriptionBuffer scale free.	ColumnDescriptionBuffer nullable free.	ColumnDescriptionBuffer := nil</body></methods><methods><class-id>Aragon.ODBCSession class</class-id> <category>tracing</category><body>trace: aStringOrNil	"Emit the standard trace header followed by aString (if not nil) into the trace log."	| header when sender depth handle |	TraceCollector == nil ifTrue: [ ^self ].	header := WriteStream on: (String new: 64).	when := Time dateAndTimeNow.	sender := thisContext sender.	handle := sender receiver handle.	depth := TraceLevel &gt; 4 ifTrue: [ TraceLevel - 4 ] ifFalse: [ 1 ].	"Emit a timestamp"	header		nextPutAll: '{';		"print: (when at: 1);"  nextPutAll: ((when at: 1) printFormat: #(1 2 3 $ 2 2));		nextPutAll: ' ';		print: (when at: 2);		nextPutAll: '} 	'.		"curly-brace, space and a tab"	"Emit a stack trace"	[ depth &gt; 0 ] whileTrue:		[ header			nextPutAll: sender mclass name asString.		handle ~~ nil			ifTrue: [header nextPut: $(; nextPutAll: (handle datum printStringRadix: 16); nextPut: $)].		header			nextPutAll: '&gt;&gt;';			nextPutAll: sender selector asString.		sender := sender sender.		(depth := depth - 1) &gt; 0 ifTrue:			[ header cr; tab: 6 ] ].	TraceSequencer critical:		[ TraceCollector nextPutAll: header contents; cr.		( aStringOrNil size &gt; 0 ) ifTrue:			[ TraceCollector tab; nextPutAll: aStringOrNil; cr ].		TraceCollector flush ]</body></methods><methods><class-id>Aragon.ODBCSession class</class-id> <category>class initialization</category><body>initialize	self initRegistry</body></methods><methods><class-id>Aragon.ODBCSession class</class-id> <category>private-registry</category><body>registry	^registry</body><body>registry: aCollection 	"Record aCollection as the registry."	registry := aCollection</body></methods><methods><class-id>Aragon.ODBCLensTableColumn</class-id> <category>initialize-release</category><body>initializeFrom: aDictionary	| sqlTypeCode |	name := aDictionary at: #name. 	type := ODBCTypeMapping typeNameFor: (sqlTypeCode := aDictionary at: #type).	nativeType := aDictionary at: #nativeType.	notNil := ((aDictionary at: #nullable) == SQL_NULLABLE value) not.	maxColumnConstraint := 		((ODBCTypeMapping variableLengthTypes includes: type) and: 		[(ODBCTypeMapping isLarge: sqlTypeCode) not])			ifTrue: [aDictionary at: #columnSize].	table := aDictionary at: #table.</body></methods><methods><class-id>Aragon.ODBCLensTableColumn</class-id> <category>accessing</category><body>dataType	"Answer the receiver's dataType."	^type</body><body>dataType: newDataType	"Set the receiver's dataType to newDataType."	type := newDataType.</body><body>isNotNil	"Answer whether the column described by the receiver cannot store nulls."	^notNil</body><body>isNotNil: newIsNotNil	"Set the receiver's isNotNil to newIsNotNil."	notNil := newIsNotNil</body><body>maxColumnConstraint	"Answer the receiver's maxColumnConstraint."	^maxColumnConstraint</body><body>maxColumnConstraint: newWidth	"Set the receiver's maxColumnConstraint to newWidth."	maxColumnConstraint := newWidth</body><body>name	^name</body><body>name: newName	"Set the receiver's name to newName."	name := newName</body><body>nativeType	^nativeType isNil ifTrue: [type] ifFalse: [nativeType]</body><body>nativeType: aValue	nativeType := aValue</body><body>table	"Answer the receiver's table."	^table</body><body>table: newTable	"Set the receiver's table to newTable."	table := newTable</body></methods><methods><class-id>Aragon.ODBCLensTableColumn</class-id> <category>DDL generation</category><body>putBasicDefinitionOn: stream 	"Emit a column definition expression for receiver on stream, minus nullness 	spec."	stream nextPutAll: self name; space; nextPutAll: self nativeType.	(self maxColumnConstraint == nil or: [self maxColumnConstraint isZero]) ifFalse:		[| mapping |		mapping := self class contextClass dataTypeMappings						detect: [:m | self dataType = m columnType]						ifNone: nil.		(mapping isNil or: [mapping isLongType not]) ifTrue:			[stream nextPut: $(; nextPutAll: self printedWidth; nextPut: $)]]</body></methods><methods><class-id>Aragon.ODBCLensTableColumn class</class-id> <category>accessing</category><body>contextClass	^ODBCLensContext</body></methods><methods><class-id>Aragon.ODBCLensTableColumn class</class-id> <category>private</category><body>encodedAspects	^#(table isNotNil dataType name maxColumnConstraint )</body><body>putNullnessDefinitionOn: stream 	"Put nullness definition on stream."	"comment this out, if nullness definitions are not supported by your particular ODBC driver."	super putNullnessDefinitionOn: stream</body></methods><methods><class-id>Aragon.ODBCMainApplication</class-id> <category>events</category><body>confirmationOfLogin	"The user has just logged in to the database; provide the new session with a serial number generator."	self session 		serialNumberGeneratorBlock: 			[:arguments | session connection 				nextSerialNumberFor: (arguments at: 3) column: (arguments at: 4)].	</body></methods><methods><class-id>Aragon.ODBCDatabaseBuffer</class-id> <category>initialize-release</category><body>elementSize: eSize count: aCount databaseType: aDatabaseType 	| mapping n |	mapping := ODBCTypeMapping forSqlType: aDatabaseType.	isLarge := (eSize isNil and: [mapping isVariable]) or: [ODBCTypeMapping isLarge: aDatabaseType].	n := 	isLarge		ifTrue: [(ODBCColumnDescription maxLengths at: aDatabaseType) last] 		ifFalse: [eSize isNil ifTrue: [0] ifFalse: [eSize]].	bufferPointer := mapping bufferBlock value: (n == nil ifTrue: [1] ifFalse: [n+1]).	getBlock := mapping getBlock.	cType := mapping cTypeCode.	super		elementSize: (n isNil ifTrue: [mapping maxSize] ifFalse: [n * mapping cTypeDef sizeof +1])		count: aCount		databaseType: aDatabaseType."	super		elementSize: (n == nil ifTrue: [mapping maxSize] ifFalse: [n +1])		count: aCount		databaseType: aDatabaseType."</body><body>initialize	"Initialize an instance of the receiver."	super initialize.	lengthPointer := SDWORD malloc</body><body>_elementSize_jet: n count: aCount databaseType: aDatabaseType	| mapping |	super		elementSize: (n == nil ifTrue: [0] ifFalse: [n+1])		count: aCount		databaseType: aDatabaseType.	mapping := ODBCTypeMapping forSqlType: aDatabaseType.	bufferPointer := mapping bufferBlock value: (elementSize max: 1).	getBlock := mapping getBlock.	cType := mapping cTypeCode</body><body>_elementSize_orcale: n count: aCount databaseType: aDatabaseType 	| mapping |	mapping := ODBCTypeMapping forSqlType: aDatabaseType.	bufferPointer := mapping bufferBlock value: (n == nil ifTrue: [1] ifFalse: [n+1]).	getBlock := mapping getBlock.	cType := mapping cTypeCode.	super		elementSize: (n == nil ifTrue: [mapping maxSize] ifFalse: [n+1])		count: aCount		databaseType: aDatabaseType.</body></methods><methods><class-id>Aragon.ODBCDatabaseBuffer</class-id> <category>accessing</category><body>at: anIndex	"Answer the object in the buffer at anIndex."	^self isNull ifFalse: [getBlock value: self pointer value: self elementSize]</body><body>cType	^cType</body><body>cType: anInteger	cType := anInteger</body><body>indicator	^lengthPointer</body><body>isNull		^lengthPointer contents == SQL_NULL_DATA value</body><body>length		^lengthPointer contents &gt; 0 ifTrue: [lengthPointer contents] ifFalse: [0]</body></methods><methods><class-id>Aragon.ODBCDatabaseBuffer</class-id> <category>allocation</category><body>free	"Free the receiver."	super free.	lengthPointer notNil		ifTrue: 			[lengthPointer freePointer.			lengthPointer := nil]</body></methods><methods><class-id>Aragon.ODBCDatabaseBuffer</class-id> <category>large objects</category><body>isLarge	^isLarge</body></methods><methods><class-id>Aragon.ODBCLensTransporter</class-id> <category>variable naming</category><body>nextVariableName	^'?'</body></methods><methods><class-id>Aragon.ODBCLensTransporter class</class-id> <category>class initialization</category><body>initialize	super initialize</body></methods><methods><class-id>Aragon.ODBCLensContext</class-id> <category>data dictionary manipulation</category><body>checkDataModelColumn: dataModelCol withDatabaseColumn: dbCol of: type in: session	"Check consistency of existing data model column with database column. 	Engage user in dialog to fix any discrepancies."	| dataModelColType dbColType choice dataModel connection colName dataModelColWidth dbColWidth table variable message |	dataModel := session dataModel.	connection := session connection.	table := type table.	colName := table name , '.' , dataModelCol name.	self nativeTypeInfoIn: session.	"check for datatype agreement"	dataModelColType := dataModelCol dataType.	dbColType := dbCol dataType.	(self isColumnType: dataModelColType compatibleWith: dbColType) ifFalse:		[message := 'Column &lt;1s&gt; has datatype &lt;2p&gt; in the data model, and datatype &lt;3p&gt; in the database.(Changing table definition will drop the current column!)'					expandMacrosWith: colName					with: dataModelColType					with: dbColType.		choice := self getChoiceFor: message.		choice == #alterDataModel ifTrue: [			type dataModel saved: false.			dataModelCol dataType: dbColType].		choice == #alterDb			ifTrue:				[connection doCommandString: (table alterColumnCommand: dataModelCol operation: #drop).				connection doCommandString: (table alterColumnCommand: dataModelCol operation: #add)]].	"check for width agreement"	dataModelColWidth := dataModelCol maxColumnConstraint.	dbColWidth := dbCol maxColumnConstraint.	variable := type variableMappedTo: dataModelCol.	"Do the checking only if the column is mapped to a variable"	variable notNil		ifTrue: [			(variable hasLongType or: [dataModelColWidth = dbColWidth]) ifFalse: [				message := 'Column &lt;1s&gt; has width &lt;2p&gt; in the data model, and width &lt;3p&gt; in the database.(Changing table definition will drop the current column!)'							expandMacrosWith: colName							with: dataModelColWidth							with: dbColWidth.				choice := self getChoiceFor: message.				choice == #alterDataModel ifTrue: [					type dataModel saved: false.					dataModelCol maxColumnConstraint: dbColWidth.					variable valueType: (dataModel fieldTypeForColumn: dataModelCol)].		choice == #alterDb			ifTrue:				[connection doCommandString: (table alterColumnCommand: dataModelCol operation: #drop).				connection doCommandString: (table alterColumnCommand: dataModelCol operation: #add)]]].	"check for nullability agreement"	dataModelCol isNotNil = dbCol isNotNil ifFalse: [		message := 'Column &lt;1s&gt; is &lt;2?not :&gt;nullable in the data model and &lt;2?:not &gt;nullable in the database.(Changing table definition will drop the current column!)'					expandMacrosWith: colName					with: dataModelCol isNotNil.		choice := self getChoiceFor: message.		choice == #alterDataModel ifTrue: [			type dataModel saved: false.			dataModelCol isNotNil: dbCol isNotNil].		choice == #alterDb			ifTrue:				[connection doCommandString: (table alterColumnCommand: dataModelCol operation: #drop).				connection doCommandString: (table alterColumnCommand: dataModelCol operation: #add)]].</body><body>createTableFor: type in: aLensSession	"Add the table for type in aLensSession.  It's OK if it already exists."		| definition |	definition := WriteStream on: String new.	definition nextPutAll: 'CREATE TABLE ', type table qualifiedName , ' ('.	type table columns do: [:column |"		column nativeType: (self nativeTypeFor: column dataType in: aLensSession)."		column nativeType: column dataType.		aLensSession connection supportsNonNullableColumns 			ifTrue: [column putDefinitionOn: definition]			ifFalse: [column putBasicDefinitionOn: definition].		definition nextPut: $,].	definition skip: -1.	definition nextPut: $).	aLensSession connection doCommandString: definition contents.</body><body>definePrimaryKeyFor: type in: aLensSession	"Define the primary key for type in aLensSession.  It's OK if it already exists."	| definition idv |	aLensSession connection supportsAlterTable ifFalse: [^self].	definition := WriteStream on: String new.	definition nextPutAll: 'ALTER TABLE ', type table qualifiedName , ' ADD CONSTRAINT ', type table qualifiedName, '_Key PRIMARY KEY ('.	idv := type idVariable.	idv forLeavesDo: 		[:v | 		definition nextPutAll: v column name.		definition nextPutAll: ', '].	definition skip: -2.	definition nextPutAll: ')'.	aLensSession connection doCommandString: definition contents.</body><body>getTableNamed: tableName in: session 	| t |	^(t := self listTablesLike: tableName in: session) isEmpty ifFalse: [t first]</body><body>listTablesLike: aPattern in: aLens 	"Answer a collection of tables which are accessible using aLens. 	If aPattern is not nil, limit the search to only those tables with names matching."	| exdiSession tables |	exdiSession := aLens connection getSession.	tables := (exdiSession listTablesLike: aPattern)				collect: [:each | self class tableClass new initializeFrom: each].	tables do: [:each | each columns: ((exdiSession getColumnsOfTable: each name qualifier: each qualifier owner: each owner)				collect: [:c | self class tableColumnClass new initializeFrom: c])].	^tables</body></methods><methods><class-id>Aragon.ODBCLensContext</class-id> <category>accessing</category><body>nativeTypeFor: aDataType in: aLensSession	| nti |	nti := (self nativeTypeInfoIn: aLensSession) at: aDataType ifAbsent: [nil].	nti notNil ifTrue: [^nti first].	aDataType == #DATE ifTrue: [^self nativeTypeFor: #TIMESTAMP in: aLensSession].	aDataType == #TIME ifTrue: [^self nativeTypeFor: #TIMESTAMP in: aLensSession].	nti := (self nativeTypeInfoIn: aLensSession) at: #VARCHAR ifAbsent: [nil].	nti notNil ifTrue: [^nti first].	nti := (self nativeTypeInfoIn: aLensSession) at: #CHAR ifAbsent: [nil].	nti notNil ifTrue: [^nti first].	^#INVALID</body><body>nativeTypeInfoIn: aLensSession	nativeTypeInfo isNil ifTrue: [nativeTypeInfo := aLensSession connection getSession typeInfoFor: #ALL_TYPES].	^nativeTypeInfo</body></methods><methods><class-id>Aragon.ODBCLensContext</class-id> <category>private</category><body>isColumnType: dataModelColType compatibleWith: databaseColType 	"Answer whether the data model and database column types are compatible."	^(dataModelColType sameAs: databaseColType)		or: [(self nativeTypeFor: dataModelColType in: nil)				sameAs: (self nativeTypeFor: databaseColType in: nil)]</body></methods><methods><class-id>Aragon.ODBCLensContext class</class-id> <category>class initialization</category><body>addMappingFor: fieldClassName to: columnType from: anODBCTypeMapping 	basicTypes detect: [:each | each name == fieldClassName] ifNone: [^self].	dataTypeMappings detect: [:m | m fieldType name == fieldClassName and: [m columnType == columnType]]		ifNone: 			[| newMapping |			newMapping := self mapFieldOf: fieldClassName to: columnType.			anODBCTypeMapping isLong				ifTrue: [newMapping makeLong]				ifFalse: [newMapping maxSize: anODBCTypeMapping maxSize]]</body><body>initialize	"self initialize"	maxColumnSize := ODBCColumnDescription initialize maxLengths 		inject: 0 into: [:max :lengths | max max: lengths first].	self initializeBasicTypes.	LensCompiler isNil ifFalse: [self initializeCatalogDataModel].	self initializeDataTypeMappings.	maxNameSize := 72.	reservedWords := #().	shortSize := 2 ** 32.	transactionPolicies := IdentitySet new</body><body>initializeBasicTypes	"self initializeBasicTypes"	basicTypes := IdentityDictionary new.	#(Object SmallInteger Integer Character Float Double ByteArray String Date Time Timestamp Symbol Boolean FixedPoint) do:		[ :className | self addBasicType: (self environment at: className) type].	self addBasicType: (Integer type name: #SerialNumber)</body><body>initializeDataTypeMappings	"self initializeDataTypeMappings"	dataTypeMappings := OrderedCollection new.	ODBCTypeMapping initialize.	ODBCTypeMapping standardMappings associationsDo: [:each | self addMappingFor: each value smalltalkType name to: each key from: each value].	self mapFieldOf: #FixedPoint to: #DOUBLE.	self mapFieldOf: #Symbol to: #CHAR.	ODBCTypeMapping mappingsDo: [:each | self addMappingFor: each value smalltalkType name to: each key from: each value].	self addMappingFor: #SerialNumber to: #INTEGER from: (ODBCTypeMapping forClass: Integer).	(ODBCTypeMapping longSqlTypes collect: [:each | ODBCTypeMapping typeNameFor: each])		do: [:each | (self mappingFor: each) makeLong].</body><body>mappingFor: typeName	^dataTypeMappings detect: [:m | typeName = m columnType]		ifNone: [nil]</body></methods><methods><class-id>Aragon.ODBCLensContext class</class-id> <category>accessing</category><body>connectionClass	"Answer the class of connections opened by instances of self."	^ODBCConnection</body><body>kind	"symbol representing the type of the d'ase  "	^#ODBC</body><body>tableClass	"Answer the class of tables for the receiver."	^ODBCLensTable</body><body>tableColumnClass	"Answer the class of table columns in receiver's data dictionary."	^ODBCLensTableColumn</body><body>transporterClass	"Answer the class of transporters via which to dynamically access the 	receiver's associated database."	^ODBCLensTransporter</body><body>verifyConstraintsOnType: type	"Verify entity for runtime operation.  Check size constraints."	| columnSize fieldType | 	"check column size constraints"	type allRecordVariables do:		[ :var |		((var isReference not and: [var hasLongType not])		and: [(fieldType := var fieldType) isVariableSize]) ifTrue:			[ "Check to make sure that variable length entries are within legal bounds."			columnSize := fieldType maxColumnConstraint.			(columnSize isNil)				ifTrue: [ type dataModel							dataDefinitionWarningWith:								(Array									with: type dataModel displayString									with: var name asString									with: type name asString									with: var column defaultBLOBSize)							errorPattern:								'&lt;1p&gt; &lt;n&gt;Data definition error:&lt;n&gt;Variable &lt;2p&gt; of Entity &lt;3p&gt;&lt;n&gt;should have a maximum length defined.&lt;n&gt;Press OK to accept the default value (&lt;4p&gt;).'.						var column maxColumnLength: var column defaultBLOBSize.						var resetFieldTypeMax.						var isId ifTrue: [var objectType idVariable resetFieldType] ]				ifFalse: [ (columnSize asInteger &gt; maxColumnSize)						ifTrue: [ type dataModel									dataDefinitionWarningWith:										(Array											with: type dataModel displayString											with: var name asString											with: type name asString											with: maxColumnSize)									errorPattern: '&lt;1p&gt; &lt;n&gt;Data definition error:&lt;n&gt;Variable &lt;2p&gt; of Entity &lt;3p&gt;&lt;n&gt;is too long.&lt;n&gt;Press OK to accept the maximum size (&lt;4p&gt;).'.								var column maxColumnLength: maxColumnSize.								var resetFieldTypeMax.								var isId ifTrue: [var objectType idVariable resetFieldType ] ] ] ] ]</body></methods><methods><class-id>Aragon.ODBCTypeMapping</class-id> <category>accessing</category><body>bufferBlock	^bufferBlock</body><body>cName: aName	cName := aName</body><body>cTypeCode	^cTypeCode</body><body>cTypeDef	^cTypeDef</body><body>cTypeName	^cName</body><body>getBlock	^getBlock</body><body>maxSize	^maxSize</body><body>putBlock	^putBlock</body><body>smalltalkType	^class</body><body>sqlName: aName	sqlName := aName</body><body>sqlTypeCode	^sqlTypeCode</body><body>sqlTypeName	^sqlName</body></methods><methods><class-id>Aragon.ODBCTypeMapping</class-id> <category>printing</category><body>printOn: aStream	super printOn: aStream.	aStream space; nextPut: $(.	aStream nextPutAll: 'C:', cName, ' &lt;-&gt; SQL:', sqlName.	aStream nextPut: $)</body></methods><methods><class-id>Aragon.ODBCTypeMapping</class-id> <category>private-accessing</category><body>bufferBlock: aValue	bufferBlock := aValue</body><body>cType: aTypedefOrASymbol allocationType: aSymbol maxSize: anInteger	cTypeDef := aTypedefOrASymbol isSymbol				ifTrue: [ODBCInterfaceDictionary at: aTypedefOrASymbol]				ifFalse: [aTypedefOrASymbol]."	maxSize := (aSymbol ~= #s and: [aSymbol ~= #c]) ifTrue: [anInteger]."	maxSize := anInteger.	bufferBlock := self class bufferBlockFor: cTypeDef allocationType: aSymbol maxSize: anInteger.	putBlock := self class putBlockFor: cTypeDef allocationType: aSymbol maxSize: anInteger.	getBlock := self class getBlockFor: cTypeDef allocationType: aSymbol maxSize: anInteger.</body><body>cTypeCode: anIntegerOrASymbol 	cTypeCode := anIntegerOrASymbol isSymbol				ifTrue: [(ODBCInterfaceDictionary at: anIntegerOrASymbol) value]				ifFalse: [anIntegerOrASymbol].</body><body>getBlock: aValue	getBlock := aValue</body><body>isLarge	^self class isLarge: sqlTypeCode</body><body>isLong	^maxSize isNil or: [self isLarge]</body><body>isVariable	^self class variableLengthTypes includes: sqlName</body><body>maxSize: aValue	maxSize := aValue</body><body>putBlock: aValue	putBlock := aValue</body><body>smalltalkType: aClassOrASymbol 	class := aClassOrASymbol isSymbol				ifTrue: [Smalltalk at: aClassOrASymbol]				ifFalse: [aClassOrASymbol]</body><body>sqlCType: aType	cName := aType.	cTypeCode := (ODBCInterfaceDictionary at: ('SQL_C_', aType) asSymbol) value</body><body>sqlType: aType	sqlName := aType.	sqlTypeCode := (ODBCInterfaceDictionary at: ('SQL_', aType) asSymbol) value</body><body>sqlTypeCode: aValue	sqlTypeCode := aValue</body></methods><methods><class-id>Aragon.ODBCTypeMapping class</class-id> <category>class initialization</category><body>initialize	"ODBCTypeMapping initialize"	CTypes := self readCTypesFrom:	#(		"SQL_C_..."			"SQL_..."		"C Typedef"				   "type"	"max size"	"Smalltalk Class"		GUID				GUID			UCHAR						v	36			String		WCHAR				WVARCHAR		UWORD						u	255			String			"Unicode C Data Types"		CHAR				VARCHAR		UCHAR 						v	255			String			"Core C Data Types"		LONG				INTEGER		SDWORD					s	10			SmallInteger		SHORT				SMALLINT		SWORD						s	5			SmallInteger		FLOAT				REAL			SFLOAT						s	15			Float		DOUBLE			DOUBLE		SDOUBLE					s	15			Double		BIT					BIT				UCHAR						1	1			Boolean			"Extended C Data Types"		TINYINT				TINYINT			SCHAR						s	3			SmallInteger		BINARY				BINARY			UCHAR						b	nil			ByteArray		DATE				DATE			tagDATE_STRUCT			c	10			Date		TIME				TIME			tagTIME_STRUCT			c	8			Time		TIMESTAMP			TIMESTAMP		tagTIMESTAMP_STRUCT		c	23			Timestamp		"BOOKMARK			INTEGER		BOOKMARK					s	10			LookupKey"		"Bookmark C Data Types"	).	St2Odbc := IdentityDictionary new.	CTypes do: [:each | St2Odbc add: each smalltalkType -&gt; each].	St2Odbc at: String put: (CTypes at: #CHAR).	St2Odbc at: SmallInteger put: (CTypes at: #LONG).	St2Odbc at: Number put: (CTypes at: #DOUBLE).	St2Odbc at: Symbol put: (CTypes at: #CHAR).	St2Odbc at: True put: (St2Odbc at: Boolean).	St2Odbc at: False put: (St2Odbc at: Boolean).	St2Odbc at: FixedPoint put: ((CTypes at: #DOUBLE) copy putBlock: [:p :v | p contents: v asDouble]).	St2Odbc at: UndefinedObject put: ((CTypes at: #BIT) copy cName: #NULL; sqlName: #NULL; bufferBlock: [:n | nil]; putBlock: [:p :v |]).	Mappings := self readMappingsFrom:	#(		"SQL_..."			"SQL_C_..."		GUID				#(GUID			CHAR BINARY  DATE  TIME  TIMESTAMP)			"Minimum SQL Data Types"				CHAR				#(CHAR			BIT  TINYINT  SHORT  LONG  FLOAT  DOUBLE  BINARY  DATE  TIME  TIMESTAMP)		VARCHAR			#(CHAR			BIT  TINYINT  SHORT  LONG  FLOAT  DOUBLE  BINARY  DATE  TIME  TIMESTAMP)		LONGVARCHAR		#(CHAR			BIT  TINYINT  SHORT  LONG  FLOAT  DOUBLE  BINARY  DATE  TIME  TIMESTAMP)			"Unicode SQL Data Types"				WCHAR				#(WCHAR		BIT  TINYINT  SHORT  LONG  FLOAT  DOUBLE  BINARY  DATE  TIME  TIMESTAMP)		WVARCHAR			#(WCHAR		BIT  TINYINT  SHORT  LONG  FLOAT  DOUBLE  BINARY  DATE  TIME  TIMESTAMP)		WLONGVARCHAR	#(WCHAR		BIT  TINYINT  SHORT  LONG  FLOAT  DOUBLE  BINARY  DATE  TIME  TIMESTAMP)			"Core SQL Data Types"		DECIMAL			#(DOUBLE		CHAR BIT  TINYINT  SHORT  LONG  FLOAT  BINARY)		NUMERIC			#(DOUBLE		CHAR BIT  TINYINT  SHORT  LONG  FLOAT  BINARY)		SMALLINT			#(SHORT		CHAR BIT  TINYINT  LONG  FLOAT  DOUBLE  BINARY)		INTEGER			#(LONG			CHAR BIT  TINYINT  SHORT  FLOAT  DOUBLE  BINARY)		REAL				#(FLOAT		CHAR BIT  TINYINT  SHORT  LONG  DOUBLE  BINARY)		FLOAT				#(DOUBLE		CHAR BIT  TINYINT  SHORT  LONG  FLOAT  BINARY)		DOUBLE			#(DOUBLE		CHAR BIT  TINYINT  SHORT  LONG  FLOAT  BINARY)			"Extended SQL Data Types"		BIT					#(BIT			CHAR TINYINT  SHORT  LONG  FLOAT  DOUBLE  BINARY)		TINYINT				#(TINYINT		CHAR BIT SHORT  LONG  FLOAT  DOUBLE  BINARY)		BIGINT				#(DOUBLE		CHAR BIT TINYINT  SHORT  LONG  FLOAT  BINARY)		BINARY				#(BINARY		CHAR)		VARBINARY			#(BINARY		CHAR)		LONGVARBINARY	#(BINARY		CHAR)		DATE				#(DATE			CHAR  BINARY  TIMESTAMP)		TIME				#(TIME			CHAR  BINARY  TIMESTAMP)		TIMESTAMP			#(TIMESTAMP	CHAR  BINARY  DATE  TIME)	).	Odbc2St := IdentityDictionary new.	Mappings associationsDo: [:each | Odbc2St add: 		(self sqlTypeNamed: each key)		-&gt; ((CTypes at: each value first) copy sqlTypeCode: (self sqlTypeNamed: each key))].</body><body>readCTypesFrom: anArray 	| stream answer |	answer := IdentityDictionary new.	stream := anArray readStream.	[stream atEnd]		whileFalse:			[answer add: stream peek -&gt; (self new 				sqlCType: stream next; 				sqlType: stream next; 				cType: stream next				allocationType: stream next				maxSize: stream next;				smalltalkType: stream next)].	^answer</body><body>readMappingsFrom: anArray	| stream answer |	answer := IdentityDictionary new.	stream := anArray readStream.	[stream atEnd]		whileFalse: 			[answer add: stream next -&gt; stream next].	^answer</body></methods><methods><class-id>Aragon.ODBCTypeMapping class</class-id> <category>accessing</category><body>allMappings	^Mappings</body><body>defaultMappings	^St2Odbc</body><body>for: anObject	^self forClass: anObject class</body><body>forClass: aClass 	| class |	((class := aClass) == Text) ifTrue: [class := String].	[St2Odbc includesKey: class]		whileFalse: [(class := class superclass) isNil ifTrue: [^self error: 'Couldn''t find ODBC type mapping for class ' , aClass name]].	^St2Odbc at: class</body><body>forSqlType: anSqlTypeCode	^Odbc2St at: anSqlTypeCode</body><body>isLarge: aDatabaseType	^	aDatabaseType == SQL_LONGVARCHAR value or: [	aDatabaseType == SQL_WLONGVARCHAR value or: [	aDatabaseType == SQL_LONGVARBINARY value or: [	false]]]</body><body>longSqlTypes	^ODBCColumnDescription maxLengths keys	</body><body>mappingsDo: aBlock	Mappings associationsDo: [:each | each value do: [:cType | aBlock value: each key -&gt; (CTypes at: cType)]]</body><body>standardMappings	^CTypes</body><body>typeNameFor: anSqlTypeCode 	^Mappings keys detect: [:aKey | (ODBCInterfaceDictionary at: ('SQL_' , aKey) asSymbol) value == anSqlTypeCode]		ifNone: [#INVALID_TYPE]</body><body>variableLengthTypes	 ^#(WCHAR WVARCHAR WLONGVARCHAR CHAR VARCHAR BINARY VARBINARY LONGVARBINARY LONGVARCHAR NUMERIC " BIGINT DECIMAL " )</body></methods><methods><class-id>Aragon.ODBCTypeMapping class</class-id> <category>private</category><body>bufferBlockFor: aCType allocationType: aSymbol maxSize: anInteger	aSymbol == #s	ifTrue: [^[:n | aCType malloc]].	aSymbol == #c	ifTrue: [^[:n | aCType malloc]].	aSymbol == 1	ifTrue: [^[:n | aCType malloc]].	aSymbol == #v	ifTrue: [^[:n | aCType malloc: n]].	aSymbol == #u	ifTrue: [^[:n | aCType malloc: n]].	aSymbol == #b	ifTrue: [^[:n | aCType malloc: (n notNil ifTrue: [n] ifFalse: [anInteger])]].</body><body>cTypeNamed: aSymbol	^(ODBCInterfaceDictionary at: ('SQL_C_', aSymbol) asSymbol) value</body><body>getBlockFor: aCType allocationType: aSymbol maxSize: anInteger 	aSymbol == #s	ifTrue: [^[:p :n | p contents]].	aSymbol == #v	ifTrue: [^[:p :n | p isNull ifFalse: [p copyCStringFromHeap]]].	aSymbol == #u	ifTrue: [^[:p :n | p isNull ifFalse: [p copyUnicodeStringFromHeap]]].	aSymbol == #b	ifTrue: [^[:p :n || b | b := ByteArray new: n. p copyAt: 0 to: b size: n startingAt: 1. b]].	aSymbol == 1	ifTrue: [^[:p :n | p contents ~~ 0]].	aSymbol ~~ #c	ifTrue: [^self error: 'Unknown allocation type: ' , aSymbol printString].	aCType = tagDATE_STRUCT ifTrue: [^[:p :n |				Date					newDay: (p memberAt: #day)					monthNumber: (p memberAt: #month)					year: (p memberAt: #year)]].	aCType = tagTIME_STRUCT ifTrue: [^[:p :n | 				Time new					hours: (p memberAt: #hour)					minutes: (p memberAt: #minute)					seconds: (p memberAt: #second)]].	aCType = tagTIMESTAMP_STRUCT ifTrue: [^[:p :n | 				Timestamp new					day: (p memberAt: #day);					month: (p memberAt: #month);					year: (p memberAt: #year);					hour: (p memberAt: #hour);					minute: (p memberAt: #minute);					second: (p memberAt: #second);				yourself]].	^self error: 'Don''t know how to get objects of C type: ' , aCType printString</body><body>putBlockFor: aCType allocationType: aSymbol maxSize: anInteger 	aSymbol == #s	ifTrue: [^[:p :v | p contents: v]].	(aSymbol == #v or: [aSymbol == #u])		ifTrue: [^[:p :v || size |						p copyAt: 0 from: v size: (size := v size) startingAt: 1.						p at: size put: 0 "(Character value: 0)"]].	aSymbol == #b	ifTrue: [^[:p :v | p copyAt: 0 from: v size: v size startingAt: 1]].	aSymbol == 1	ifTrue: [^[:p :v | p contents: (v ifTrue: [1] ifFalse: [0])]].	aSymbol ~~ #c 	ifTrue: [^self error: 'Unknown allocation type: ' , aSymbol printString].	aCType = tagDATE_STRUCT ifTrue: [^[:p :v | p				memberAt: #day		put: v dayOfMonth;				memberAt: #month	put: v monthIndex;				memberAt: #year		put: v year;			yourself]].	aCType = tagTIME_STRUCT ifTrue: [^[:p :v | p				memberAt: #hour		put: v hours;				memberAt: #minute	put: v minutes;				memberAt: #second	put: v seconds;			yourself]].	aCType = tagTIMESTAMP_STRUCT ifTrue: [^[:p :v | p				memberAt: #day		put: v day;				memberAt: #month	put: v month;				memberAt: #year		put: v year;				memberAt: #hour		put: v hour;				memberAt: #minute	put: v minute;				memberAt: #second	put: v second;				memberAt: #fraction	put: v millisecond;			yourself]].	^self error: 'Don''t know how to push objects fo C type: ' , aCType printString</body><body>sqlTypeNamed: aSymbol	^(ODBCInterfaceDictionary at: ('SQL_', aSymbol) asSymbol) value</body></methods><methods><class-id>Aragon.ODBCColumnDescription</class-id> <category>accessing</category><body>sqlTypeCode	^sqlTypeCode</body></methods><methods><class-id>Aragon.ODBCColumnDescription</class-id> <category>private-accessing</category><body>maxColumnConstraint: anInteger 	length := anInteger.	(MaxLengths includesKey: sqlTypeCode)		ifTrue: [length := length min: (MaxLengths at: sqlTypeCode) first]</body><body>setMaxColumnConstraint: anInteger	length := anInteger</body><body>sqlTypeCode: aValue 	sqlTypeCode := aValue.</body></methods><methods><class-id>Aragon.ODBCColumnDescription class</class-id> <category>class initialization</category><body>initialize	MaxLengths := IdentityDictionary new		at: SQL_LONGVARCHAR value put: #(16r1000000 16r1000);		at: SQL_WLONGVARCHAR value put: #(16r1000000 16r1000);		at: SQL_LONGVARBINARY value put: #(16r10000000 16r4000);		at: SQL_VARCHAR value put: #(16r1000000 16r1000);		at: SQL_WVARCHAR value put: #(16r1000000 16r1000);		at: SQL_VARBINARY value put: #(16r10000000 16r4000);		at: SQL_BINARY value put: #(16r10000000 16r4000);	yourself</body></methods><methods><class-id>Aragon.ODBCColumnDescription class</class-id> <category>constants</category><body>maxLengthForLongVarbinary	^(MaxLengths at: SQL_LONGVARBINARY value) first</body><body>maxLengthForLongVarbinary: anInteger	(MaxLengths at: SQL_LONGVARBINARY value) at: 1 put: anInteger</body><body>maxLengthForLongVarchar	^(MaxLengths at: SQL_LONGVARCHAR value) first</body><body>maxLengthForLongVarchar: anInteger	(MaxLengths at: SQL_LONGVARCHAR value) at: 1 put: anInteger</body><body>maxLengths	^MaxLengths</body></methods><methods><class-id>Aragon.ODBCConnection</class-id> <category>private-finalization</category><body>finalizeExternal	self dismissExternal.	^super finalizeExternal</body><body>key	"Key value to use when inserting receiver into a handle registry. This value 	needs to be unique within the registry."	^hdbc</body></methods><methods><class-id>Aragon.ODBCConnection</class-id> <category>private-library calls</category><body>acquireExternal: aPassword 	"Acquire the external resources involved with a connection to the SQL-environment."	"The username, password, and environment variables may be nil to indicate that the proper value is 	unknown or an empty string to indicate that the DBMS is expected to take the default. If the value for 	one of these variables is required, raise the proceedable signal requiredUsernameSignal, 	requiredPasswordSignal, or requiredEnvironmentSignal and use the proceed value. Do not record this 	value in the instance variable."	"Note: implementations of this method are expected to use self class mapLogical: self environment in 	order to determine the proper environment string to use."	| odbc buffer |	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	odbc := self xif.	buffer := odbc bufferFor: HANDLE.	["Begin of unwind protection"	ODBCInterface errorSignal		handle: 			[:ex | 			hdbc notNil ifTrue: [odbc SQLFreeConnect: hdbc].			henv notNil ifTrue: [odbc SQLFreeEnv: henv].			hdbc := henv := nil.			self class connectionExceptionSignal raise]		do: [| datasource tokens qualifier |			datasource := self class mapLogical: self environment.			tokens := datasource tokensBasedOn: self class datasourceNameSeparator.			datasource := tokens first.			qualifier := tokens size &gt; 1 ifTrue: [tokens last].			self handle: (odbc SQLAllocEnv: buffer). 				henv := buffer contents.			self handle: (odbc SQLAllocConnect: henv with: buffer).	hdbc := buffer contents.			self handle: (odbc SQLConnect: hdbc					with: datasource	with: datasource size					with: username	with: username size					with: aPassword	with: aPassword size).			qualifier notNil 				ifTrue: [self handle: (odbc SQLSetConnectOption: hdbc 					with: SQL_CURRENT_QUALIFIER value 					with: qualifier gcCopyToHeap referentAddress)].			self handle: (odbc SQLSetConnectOption: hdbc 					with: SQL_AUTOCOMMIT value 					with: SQL_AUTOCOMMIT_OFF value)		]	"End of unwind protection"]		valueOnUnwindDo:			[hdbc notNil ifTrue: [odbc SQLFreeConnect: hdbc].			henv notNil ifTrue: [odbc SQLFreeEnv: henv].			hdbc := henv := nil].</body><body>beginExternal	"Mark the beginning of receiver's portion of a transaction. Most 	dbms define this as a side-effect of using a transaction-initiating 	statement. This is provided as a convenience for drivers that 	require knowledge of the event to control their state machines."	super beginExternal</body><body>commitExternal	"Commit all changes made by receiver's connection."	self handle: (self xif			SQLTransact: henv			with: hdbc			with: SQL_COMMIT value).	^super commitExternal</body><body>dismissExternal	| odbc delay |	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	odbc := self xif.	"I've encountered severe problems with ODBC drivers for MS Access, Excel, etc. coming with	MS Office 95 (update a) on NT 4.0 (final, german):	Frequently the complete system crashes after executing the ODBC calls below.	Curiosly, the only way to fix the problem was to incorporate a small delay (very small in fact) 	between each ODBC call."	delay := Delay forMilliseconds: 1.	self commitExternal.	delay wait.	hdbc notNil ifTrue: [self handle: (odbc SQLDisconnect: hdbc)].		delay wait.	hdbc notNil ifTrue: [self handle: (odbc SQLFreeConnect: hdbc).		hdbc := nil].	delay wait.	henv notNil ifTrue: [self handle: (odbc SQLFreeEnv: henv).			henv := nil].	serialNumberQuery := nil.</body><body>installExternal	"Perform return from snapshot processing."	"Subclasses that override should invoke super installExternal."	self class traceLevel &gt;= 3 ifTrue: [self class trace: nil].	hdbc := nil.	henv := nil.	^super installExternal.	"Assure: no dangling CPointers remain."</body><body>rollbackExternal	"Rollback all changes made by receiver's connection."	self handle: (self xif			SQLTransact: henv			with: hdbc			with: SQL_ROLLBACK value).	^super rollbackExternal</body></methods><methods><class-id>Aragon.ODBCConnection</class-id> <category>private-ObjectLens</category><body>isolationLevel: anIsolationLevel 	"Set the current isolation level."	self class traceLevel &gt;= 1 ifTrue: [self class trace: anIsolationLevel printString]</body></methods><methods><class-id>Aragon.ODBCConnection</class-id> <category>private-accessing</category><body>handle	^hdbc</body><body>henv	^henv</body><body>nextSerialNumberFor: aTable column: aColumn	| answer infiniteLoopProtecion |	infiniteLoopProtecion := false.	serialNumberQuery isNil 		ifTrue: 			[serialNumberQuery := Array 				with: (self prepare: 'UPDATE SerialNumbers set  lastNumber = lastNumber+1 where tableName=? and columnName=?')				with: (self prepare: 'SELECT lastNumber from SerialNumbers where tableName=? and columnName=?').			infiniteLoopProtecion := true].	serialNumberQuery do: [:each | each bindInput: (Array with: aTable with: aColumn)].	serialNumberQuery first execute.	^(answer := serialNumberQuery last execute answer upToEnd) isEmpty 		ifTrue: 			[infiniteLoopProtecion ifTrue: [^self error: 'Failed to get next SerialNumber for: ', aTable, '.', aColumn, '']. 			serialNumberQuery := nil. self nextSerialNumberFor: aTable column: aColumn]		ifFalse: [answer first first].</body><body>xif	^self class xif</body></methods><methods><class-id>Aragon.ODBCConnection</class-id> <category>private</category><body>handle: aRetcode 	(aRetcode ~~ SQL_SUCCESS value and: [		aRetcode ~~  SQL_SUCCESS_WITH_INFO value]) 			ifTrue: [self xif				handleError: aRetcode				in: thisContext sender sender selector				env: henv				dbc: hdbc				stmt: nil].	^aRetcode</body></methods><methods><class-id>Aragon.ODBCConnection</class-id> <category>printing</category><body>printOn: aStream	super printOn: aStream.	aStream space; nextPut: $(.	self environment printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Aragon.ODBCConnection</class-id> <category>driver info</category><body>apiConformanceLevel	^self getDriverInfoAbout: SQL_ODBC_API_CONFORMANCE type: SWORD.</body><body>databaseName	^self getDriverInfoAbout: SQL_DATABASE_NAME type: String.</body><body>dataSourceName	^self getDriverInfoAbout: SQL_DATA_SOURCE_NAME type: String.</body><body>dbmsName	^self getDriverInfoAbout: SQL_DBMS_NAME type: String.</body><body>dbmsVer	^self getDriverInfoAbout: SQL_DBMS_VER type: String.</body><body>driverOdbcVersion	^self getDriverInfoAbout: SQL_DRIVER_ODBC_VER type: String.</body><body>driverVersion	^self getDriverInfoAbout: SQL_DRIVER_VER type: String.</body><body>getDriverInfoAbout: aTopic type: aType	^self xif getDriverInfoAbout: aTopic dbc: hdbc type: aType</body><body>isReadOnly	^(self getDriverInfoAbout: SQL_DATA_SOURCE_READ_ONLY type: String) = 'Y'</body><body>odbcVersion	^self getDriverInfoAbout: SQL_ODBC_VER type: String.</body><body>reservedWords	^ODBCInterface reservedWords, 	((self getDriverInfoAbout: SQL_KEYWORDS type: ERROR_MSG) tokensBasedOn: $,)</body><body>reservedWordsInDataSource	^(self getDriverInfoAbout: SQL_KEYWORDS type: ERROR_MSG) tokensBasedOn: $,</body><body>sqlConformanceLevel	^#(minimum core extended) at: (self getDriverInfoAbout: SQL_ODBC_SQL_CONFORMANCE type: SWORD)+1.</body><body>supportsAddColumnInAlterTable	^((self getDriverInfoAbout: SQL_ALTER_TABLE type: UDWORD) bitAnd: SQL_AT_ADD_COLUMN value) &gt; 0.</body><body>supportsAlterTable	^(self getDriverInfoAbout: SQL_ALTER_TABLE type: UDWORD) &gt; 0.</body><body>supportsDropColumnInAlterTable	^((self getDriverInfoAbout: SQL_ALTER_TABLE type: UDWORD) bitAnd: SQL_AT_DROP_COLUMN value) &gt; 0.</body><body>supportsNonNullableColumns	^(self getDriverInfoAbout: SQL_NON_NULLABLE_COLUMNS type: SWORD) == SQL_NNC_NON_NULL value.</body></methods><methods><class-id>Aragon.ODBCConnection class</class-id> <category>class initialization</category><body>ensureGlobal: aClass category: aCategory	((CodeWriter fileFormat &gt; 11) or: [Smalltalk includesKey: aClass name]) 		ifFalse: 			[Smalltalk 				defineStatic: aClass name 				private: false				constant: false				category: aCategory				initializer: ''.			Smalltalk at: aClass name put: aClass].</body><body>initialize	self ensureGlobal: self category: 'Aragon.ODBC Connect'.	ODBCInterface initializeErrorSignals.	self initRegistry.</body><body>obsolete	(Smalltalk includesKey: self name) ifTrue: [Smalltalk removeKey: self name].	super obsolete</body><body>uninstall	self pause.</body></methods><methods><class-id>Aragon.ODBCConnection class</class-id> <category>accessing</category><body>datasourceNameSeparator	^$#</body><body>kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^ #ODBC</body></methods><methods><class-id>Aragon.ODBCConnection class</class-id> <category>activation</category><body>pause	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	indefinitely suspend operations."	"Subclasses must override to provide driver-specific behavior."	self quiesce.	self releaseXif.	self sessionClass releaseGlobalBuffers.</body><body>resume	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	resume suspended operations."	"Subclasses must override to provide driver-specific behavior."	self activate.</body></methods><methods><class-id>Aragon.ODBCConnection class</class-id> <category>private-accessing</category><body>columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^ODBCColumnDescription</body><body>releaseXif	xif := nil</body><body>sessionClass	"Answer the class to use for session objects associated with receiver."	^ODBCSession</body><body>transactionClass	"Answer the class to use for transaction objects associated with receiver."	^ODBCTransaction</body><body>xif	"Answer the ExternalInterface subclass instance to use."	"r.m: currently not freed, if the session is closed"	xif isNil ifTrue: [xif := ODBCInterface new].	^xif</body></methods><methods><class-id>Aragon.ODBCConnection class</class-id> <category>private-activation</category><body>install	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	take the necessary steps for returning from a snapshot.  Notify dependents	when fully installed so that appropriate action may be taken."	"ExternalDatabaseConnection install"	self releaseXif.	self sessionClass releaseGlobalBuffers.	self returnFromSnapshot.</body></methods><methods><class-id>Aragon.ODBCConnection class</class-id> <category>private-registry</category><body>registry	^registry</body><body>registry: aCollection 	"Record aCollection as the registry."	registry := aCollection</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body>zero	^self newDay: 1 year: 0</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body>zero	^self fromSeconds: 0</body></methods><methods><class-id>Aragon.ODBCLensContext class</class-id> <category>lens data model specs</category><body>catalogDataModelSpec	"LensEditor new openOnClass: self andSelector: #catalogDataModelSpec"		&lt;resource: #dataModel&gt;	^#(#LensDataModel 		#setDatabaseContext: 		#(#{Aragon.ODBCLensContext} 			#username: '' 			#environment: '') 		#structureTypes: #() 		#lensPolicyName: #Mixed 		#lensTransactionPolicyName: #PessimisticRR 		#validity: #installed )</body></methods><methods><class-id>Aragon.ODBCInterface</class-id> <category>procedures</category><body>SQLAllocConnect: henv with: phdbc	&lt;C: RETCODE SQLAllocConnect(HENV henv, HDBC * phdbc)&gt;	^self externalAccessFailed</body><body>SQLAllocEnv: phenv	&lt;C: RETCODE SQLAllocEnv(HENV * phenv)&gt;	^self externalAccessFailed</body><body>SQLAllocStmt: hdbc with: phstmt	&lt;C: RETCODE SQLAllocStmt(HDBC hdbc, HSTMT * phstmt)&gt;	^self externalAccessFailed</body><body>SQLBindCol: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLBindCol(HSTMT hstmt, UWORD icol, SWORD fCType, PTR rgbValue, SDWORD cbValueMax, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body>SQLBindParameter: hstmt with: ipar with: fParamType with: fCType with: fSqlType with: cbColDef with: ibScale with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLBindParameter(HSTMT hstmt, UWORD ipar, SWORD fParamType, SWORD fCType, SWORD fSqlType, UDWORD cbColDef, SWORD ibScale, PTR rgbValue, SDWORD cbValueMax, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body>SQLBrowseConnect: hdbc with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut	&lt;C: RETCODE SQLBrowseConnect(HDBC hdbc, UCHAR * szConnStrIn, SWORD cbConnStrIn, UCHAR * szConnStrOut, SWORD cbConnStrOutMax, SWORD * pcbConnStrOut)&gt;	^self externalAccessFailed</body><body>SQLCancel: hstmt	&lt;C: RETCODE SQLCancel(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body>SQLColAttributes: hstmt with: icol with: fDescType with: rgbDesc with: cbDescMax with: pcbDesc with: pfDesc	&lt;C: RETCODE SQLColAttributes(HSTMT hstmt, UWORD icol, UWORD fDescType, PTR rgbDesc, SWORD cbDescMax, SWORD * pcbDesc, SDWORD * pfDesc)&gt;	^self externalAccessFailed</body><body>SQLColumnPrivileges: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLColumnPrivileges(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body>SQLColumns: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLColumns(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body>SQLConnect: hdbc with: szDSN with: cbDSN with: szUID with: cbUID with: szAuthStr with: cbAuthStr	&lt;C: RETCODE SQLConnect(HDBC hdbc, UCHAR * szDSN, SWORD cbDSN, UCHAR * szUID, SWORD cbUID, UCHAR * szAuthStr, SWORD cbAuthStr)&gt;	^self externalAccessFailed</body><body>SQLDataSources: henv with: fDirection with: szDSN with: cbDSNMax with: pcbDSN with: szDescription with: cbDescriptionMax with: pcbDescription	&lt;C: RETCODE SQLDataSources(HENV henv, UWORD fDirection, UCHAR * szDSN, SWORD cbDSNMax, SWORD * pcbDSN, UCHAR * szDescription, SWORD cbDescriptionMax, SWORD * pcbDescription)&gt;	^self externalAccessFailed</body><body>SQLDescribeCol: hstmt with: icol with: szColName with: cbColNameMax with: pcbColName with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: RETCODE SQLDescribeCol(HSTMT hstmt, UWORD icol, UCHAR * szColName, SWORD cbColNameMax, SWORD * pcbColName, SWORD * pfSqlType, UDWORD * pcbColDef, SWORD * pibScale, SWORD * pfNullable)&gt;	^self externalAccessFailed</body><body>SQLDescribeParam: hstmt with: ipar with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: RETCODE SQLDescribeParam(HSTMT hstmt, UWORD ipar, SWORD * pfSqlType, UDWORD * pcbColDef, SWORD * pibScale, SWORD * pfNullable)&gt;	^self externalAccessFailed</body><body>SQLDisconnect: hdbc	&lt;C: RETCODE SQLDisconnect(HDBC hdbc)&gt;	^self externalAccessFailed</body><body>SQLDriverConnect: hdbc with: hwnd with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut with: fDriverCompletion	&lt;C: RETCODE SQLDriverConnect(HDBC hdbc, HWND hwnd, UCHAR * szConnStrIn, SWORD cbConnStrIn, UCHAR * szConnStrOut, SWORD cbConnStrOutMax, SWORD * pcbConnStrOut, UWORD fDriverCompletion)&gt;	^self externalAccessFailed</body><body>SQLDrivers: henv with: fDirection with: szDriverDesc with: cbDriverDescMax with: pcbDriverDesc with: szDriverAttributes with: cbDrvrAttrMax with: pcbDrvrAttr	&lt;C: RETCODE SQLDrivers(HENV henv, UWORD fDirection, UCHAR * szDriverDesc, SWORD cbDriverDescMax, SWORD * pcbDriverDesc, UCHAR * szDriverAttributes, SWORD cbDrvrAttrMax, SWORD * pcbDrvrAttr)&gt;	^self externalAccessFailed</body><body>SQLError: henv with: hdbc with: hstmt with: szSqlState with: pfNativeError with: szErrorMsg with: cbErrorMsgMax with: pcbErrorMsg	&lt;C: RETCODE SQLError(HENV henv, HDBC hdbc, HSTMT hstmt, UCHAR * szSqlState, SDWORD * pfNativeError, UCHAR * szErrorMsg, SWORD cbErrorMsgMax, SWORD * pcbErrorMsg)&gt;	^self externalAccessFailed</body><body>SQLExecDirect: hstmt with: szSqlStr with: cbSqlStr	&lt;C: RETCODE SQLExecDirect(HSTMT hstmt, UCHAR * szSqlStr, SDWORD cbSqlStr)&gt;	^self externalAccessFailed</body><body>SQLExecute: hstmt	&lt;C: RETCODE SQLExecute(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body>SQLExtendedFetch: hstmt with: fFetchType with: irow with: pcrow with: rgfRowStatus	&lt;C: RETCODE SQLExtendedFetch(HSTMT hstmt, UWORD fFetchType, SDWORD irow, UDWORD * pcrow, UWORD * rgfRowStatus)&gt;	^self externalAccessFailed</body><body>SQLFetch: hstmt	&lt;C: RETCODE SQLFetch(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body>SQLForeignKeys: hstmt with: szPkTableQualifier with: cbPkTableQualifier with: szPkTableOwner with: cbPkTableOwner with: szPkTableName with: cbPkTableName with: szFkTableQualifier with: cbFkTableQualifier with: szFkTableOwner with: cbFkTableOwner with: szFkTableName with: cbFkTableName	&lt;C: RETCODE SQLForeignKeys(HSTMT hstmt, UCHAR * szPkTableQualifier, SWORD cbPkTableQualifier, UCHAR * szPkTableOwner, SWORD cbPkTableOwner, UCHAR * szPkTableName, SWORD cbPkTableName, UCHAR * szFkTableQualifier, SWORD cbFkTableQualifier, UCHAR * szFkTableOwner, SWORD cbFkTableOwner, UCHAR * szFkTableName, SWORD cbFkTableName)&gt;	^self externalAccessFailed</body><body>SQLFreeConnect: hdbc	&lt;C: RETCODE SQLFreeConnect(HDBC hdbc)&gt;	^self externalAccessFailed</body><body>SQLFreeEnv: henv	&lt;C: RETCODE SQLFreeEnv(HENV henv)&gt;	^self externalAccessFailed</body><body>SQLFreeStmt: hstmt with: fOption	&lt;C: RETCODE SQLFreeStmt(HSTMT hstmt, UWORD fOption)&gt;	^self externalAccessFailed</body><body>SQLGetConnectOption: hdbc with: fOption with: pvParam	&lt;C: RETCODE SQLGetConnectOption(HDBC hdbc, UWORD fOption, PTR pvParam)&gt;	^self externalAccessFailed</body><body>SQLGetCursorName: hstmt with: szCursor with: cbCursorMax with: pcbCursor	&lt;C: RETCODE SQLGetCursorName(HSTMT hstmt, UCHAR * szCursor, SWORD cbCursorMax, SWORD * pcbCursor)&gt;	^self externalAccessFailed</body><body>SQLGetData: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLGetData(HSTMT hstmt, UWORD icol, SWORD fCType, PTR rgbValue, SDWORD cbValueMax, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body>SQLGetFunctions: hdbc with: fFunction with: pfExists	&lt;C: RETCODE SQLGetFunctions(HDBC hdbc, UWORD fFunction, UWORD * pfExists)&gt;	^self externalAccessFailed</body><body>SQLGetInfo: hdbc with: fInfoType with: rgbInfoValue with: cbInfoValueMax with: pcbInfoValue	&lt;C: RETCODE SQLGetInfo(HDBC hdbc, UWORD fInfoType, PTR rgbInfoValue, SWORD cbInfoValueMax, SWORD * pcbInfoValue)&gt;	^self externalAccessFailed</body><body>SQLGetStmtOption: hstmt with: fOption with: pvParam	&lt;C: RETCODE SQLGetStmtOption(HSTMT hstmt, UWORD fOption, PTR pvParam)&gt;	^self externalAccessFailed</body><body>SQLGetTypeInfo: hstmt with: fSqlType	&lt;C: RETCODE SQLGetTypeInfo(HSTMT hstmt, SWORD fSqlType)&gt;	^self externalAccessFailed</body><body>SQLMoreResults: hstmt	&lt;C: RETCODE SQLMoreResults(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body>SQLNativeSql: hdbc with: szSqlStrIn with: cbSqlStrIn with: szSqlStr with: cbSqlStrMax with: pcbSqlStr	&lt;C: RETCODE SQLNativeSql(HDBC hdbc, UCHAR * szSqlStrIn, SDWORD cbSqlStrIn, UCHAR * szSqlStr, SDWORD cbSqlStrMax, SDWORD * pcbSqlStr)&gt;	^self externalAccessFailed</body><body>SQLNumParams: hstmt with: pcpar	&lt;C: RETCODE SQLNumParams(HSTMT hstmt, SWORD * pcpar)&gt;	^self externalAccessFailed</body><body>SQLNumResultCols: hstmt with: pccol	&lt;C: RETCODE SQLNumResultCols(HSTMT hstmt, SWORD * pccol)&gt;	^self externalAccessFailed</body><body>SQLParamData: hstmt with: prgbValue	&lt;C: RETCODE SQLParamData(HSTMT hstmt, PTR * prgbValue)&gt;	^self externalAccessFailed</body><body>SQLParamOptions: hstmt with: crow with: pirow	&lt;C: RETCODE SQLParamOptions(HSTMT hstmt, UDWORD crow, UDWORD * pirow)&gt;	^self externalAccessFailed</body><body>SQLPrepare: hstmt with: szSqlStr with: cbSqlStr	&lt;C: RETCODE SQLPrepare(HSTMT hstmt, UCHAR * szSqlStr, SDWORD cbSqlStr)&gt;	^self externalAccessFailed</body><body>SQLPrimaryKeys: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName	&lt;C: RETCODE SQLPrimaryKeys(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName)&gt;	^self externalAccessFailed</body><body>SQLProcedureColumns: hstmt with: szProcQualifier with: cbProcQualifier with: szProcOwner with: cbProcOwner with: szProcName with: cbProcName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLProcedureColumns(HSTMT hstmt, UCHAR * szProcQualifier, SWORD cbProcQualifier, UCHAR * szProcOwner, SWORD cbProcOwner, UCHAR * szProcName, SWORD cbProcName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body>SQLProcedures: hstmt with: szProcQualifier with: cbProcQualifier with: szProcOwner with: cbProcOwner with: szProcName with: cbProcName	&lt;C: RETCODE SQLProcedures(HSTMT hstmt, UCHAR * szProcQualifier, SWORD cbProcQualifier, UCHAR * szProcOwner, SWORD cbProcOwner, UCHAR * szProcName, SWORD cbProcName)&gt;	^self externalAccessFailed</body><body>SQLPutData: hstmt with: rgbValue with: cbValue	&lt;C: RETCODE SQLPutData(HSTMT hstmt, PTR rgbValue, SDWORD cbValue)&gt;	^self externalAccessFailed</body><body>SQLRowCount: hstmt with: pcrow	&lt;C: RETCODE SQLRowCount(HSTMT hstmt, SDWORD * pcrow)&gt;	^self externalAccessFailed</body><body>SQLSetConnectOption: hdbc with: fOption with: vParam	&lt;C: RETCODE SQLSetConnectOption(HDBC hdbc, UWORD fOption, UDWORD vParam)&gt;	^self externalAccessFailed</body><body>SQLSetCursorName: hstmt with: szCursor with: cbCursor	&lt;C: RETCODE SQLSetCursorName(HSTMT hstmt, UCHAR * szCursor, SWORD cbCursor)&gt;	^self externalAccessFailed</body><body>SQLSetParam: hstmt with: ipar with: fCType with: fSqlType with: cbColDef with: ibScale with: rgbValue with: pcbValue	&lt;C: RETCODE SQLSetParam(HSTMT hstmt, UWORD ipar, SWORD fCType, SWORD fSqlType, UDWORD cbColDef, SWORD ibScale, PTR rgbValue, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body>SQLSetPos: hstmt with: irow with: fOption with: fLock	&lt;C: RETCODE SQLSetPos(HSTMT hstmt, UWORD irow, UWORD fOption, UWORD fLock)&gt;	^self externalAccessFailed</body><body>SQLSetScrollOptions: hstmt with: fConcurrency with: crowKeyset with: crowRowset	&lt;C: RETCODE SQLSetScrollOptions(HSTMT hstmt, UWORD fConcurrency, SDWORD crowKeyset, UWORD crowRowset)&gt;	^self externalAccessFailed</body><body>SQLSetStmtOption: hstmt with: fOption with: vParam	&lt;C: RETCODE SQLSetStmtOption(HSTMT hstmt, UWORD fOption, UDWORD vParam)&gt;	^self externalAccessFailed</body><body>SQLSpecialColumns: hstmt with: fColType with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: fScope with: fNullable	&lt;C: RETCODE SQLSpecialColumns(HSTMT hstmt, UWORD fColType, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UWORD fScope, UWORD fNullable)&gt;	^self externalAccessFailed</body><body>SQLStatistics: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: fUnique with: fAccuracy	&lt;C: RETCODE SQLStatistics(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UWORD fUnique, UWORD fAccuracy)&gt;	^self externalAccessFailed</body><body>SQLTablePrivileges: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName	&lt;C: RETCODE SQLTablePrivileges(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName)&gt;	^self externalAccessFailed</body><body>SQLTables: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szTableType with: cbTableType	&lt;C: RETCODE SQLTables(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szTableType, SWORD cbTableType)&gt;	^self externalAccessFailed</body><body>SQLTransact: henv with: hdbc with: fType	&lt;C: RETCODE SQLTransact(HENV henv, HDBC hdbc, UWORD fType)&gt;	^self externalAccessFailed</body></methods><initialize><class-id>Aragon.ODBCInterface</class-id></initialize><initialize><class-id>Aragon.ODBCSession</class-id></initialize><initialize><class-id>Aragon.ODBCLensTransporter</class-id></initialize><initialize><class-id>Aragon.ODBCLensContext</class-id></initialize><initialize><class-id>Aragon.ODBCTypeMapping</class-id></initialize><initialize><class-id>Aragon.ODBCColumnDescription</class-id></initialize><initialize><class-id>Aragon.ODBCConnection</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category></class><class><name>LensDatabaseContext</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username environment </inst-vars><class-inst-vars>catalogDataModel dataTypeMappings maxColumnSize maxNameSize reservedWords basicTypes shortSize transactionPolicies </class-inst-vars><imports></imports><category>Lens-Private-Database Context</category></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category></class><class><name>LensDatabaseTable</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category></class><class><name>LensDatabaseTableColumn</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category></class><class><name>LensSQLTransporter</name><environment>Lens</environment><super>Lens.LensBasicTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectFieldList whereCondition commandStream command objectSurrogateIndices joinLinks variableIndex numberOfIdVariables itemSurrogate variableBindings </inst-vars><class-inst-vars>functions </class-inst-vars><imports></imports><category>Lens-Private-Transporter</category></class><class><name>LensMainApplication</name><environment>Lens</environment><super>Lens.LensApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Applications-Framework</category></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel </inst-vars><class-inst-vars>environmentMap xif xifMap </class-inst-vars><imports></imports><category>Database-Interface</category></class></st-source>