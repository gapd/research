<?xml version="1.0"?><st-source><!-- Name: Aragon.Win32Comment: This parcel adds some convenient support for Win32 common dialogs, calls to the Windows explorer, a DDE server that allows to open VisualWorks files (.cha, .st, .pcl) in VisualWorks from the Windows explorer and much more. Have a look at the methods of Win32 to get an overview. DevelopmentPrerequisites: #(#(#parcel 'Aragon.Core' '') #(#parcel 'DDEML' ''))HideSource: falseParcel: #('Aragon.Win32')PrerequisiteParcels: #(#('Aragon.Basics' '') #('DDEML' ''))SaveSource: trueVersion: 7.1Date: 4:01:05 am May 28, 2003 --><time-stamp>From VisualWorks®, Release 7.1 of 18. März 2003 on 28. Mai 2003 at 4:01:05</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Win32</name><environment>Aragon</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>instance </class-inst-vars><imports>			private Aragon.Win32Dictionary.*			</imports><category>Aragon.Win32</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>user32.dll</item> <item>shell32.dll</item> <item>comdlg32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel></attributes></class><class><name>DDEServer4WindowsExplorer</name><environment>Aragon</environment><super>OS.DdemlServer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>soleInstance </class-inst-vars><imports>			private Aragon.DDEServer4WindowsExplorerDictionary.*			</imports><category>Aragon.Win32</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel></attributes></class><class><name>WinHelp</name><environment>Aragon</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle helpFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Win32</category></class><class><name>Win32Process</name><environment>Aragon</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Win32</category></class><class><name>Win32Filename</name><environment>Aragon</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name fileSize created modified accessed attributes attributesString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Aragon.Win32</category></class><shared-variable><name>Registry</name><environment>Aragon.Win32Process</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DefaultTitles</name><environment>Aragon.Win32</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>DefaultFlags</name><environment>Aragon.Win32</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>CustomColors</name><environment>Aragon.Win32</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><shared-variable><name>Constants</name><environment>Aragon.Win32</environment><private>false</private><constant>false</constant><category>As yet unclassified</category></shared-variable><methods><class-id>Aragon.Win32</class-id> <category>convenient - file requester</category><body>openFilename	^self openFilename: ''</body><body>openFilename: default 	^self openFilename: default title: nil</body><body>openFilename: default filters: filters	^self openFilename: default title: nil filters: filters for: Window currentWindow</body><body>openFilename: default for: aWindow 	^self		openFilename: default		title: nil		filters: #()		for: aWindow</body><body>openFilename: default title: aTitle 	^self		openFilename: default		title: aTitle		for: Window currentWindow</body><body>openFilename: default title: aTitle filters: filters for: aWindow     "SPL Modified - Don't change current directory."     ^self          openFilename: default          title: aTitle          filters: filters          for: aWindow          flags: nil</body><body>openFilename: default title: aTitle filters: filters for: aWindow flags: flags 	^self		requestFilenameWith: #GetOpenFileName:		default: default		title: aTitle		filters: filters		for: aWindow		flags: flags</body><body>openFilename: default title: aTitle for: aWindow 	^self		openFilename: default		title: aTitle		filters: #()		for: aWindow</body><body>saveFilename	^self saveFilename: ''</body><body>saveFilename: default 	^self saveFilename: default title: nil</body><body>saveFilename: default filters: filters	^self saveFilename: default title: nil filters: filters for: Window currentWindow</body><body>saveFilename: default title: aTitle	^self		saveFilename: default		title: aTitle		filters: #()		for: Window currentWindow</body><body>saveFilename: default title: aTitle filters: filters for: aWindow 	^self 		saveFilename: default		title: aTitle		filters: filters		for: aWindow		flags: nil</body><body>saveFilename: default title: aTitle filters: filters for: aWindow flags: flags 	^self		requestFilenameWith: #GetSaveFileName:		default: default		title: aTitle		filters: filters		for: aWindow		flags: flags</body><body>saveFilename: default title: aTitle for: aWindow 	^self		saveFilename: default		title: aTitle		filters: #()		for: aWindow</body></methods><methods><class-id>Aragon.Win32</class-id> <category>convenient - font chooser</category><body>chooseFont	^self chooseFont: nil</body><body>chooseFont: aFont	^self chooseFont: aFont for: nil</body><body>chooseFont: aFont color: aColorValue for: aWindow 	^self chooseFont: aFont color: aColorValue for: aWindow flags: #(SCREENFONTS EFFECTS INITTOLOGFONTSTRUCT)</body><body>chooseFont: aFontDescription color: aColorValue for: aWindow flags: flags	| cfs answer logFont scaleFactor lfHeight fd null |	scaleFactor :=   1.43.	logFont := self LOGFONT gcMalloc.	cfs := (self prepareCommonDialog: self CHOOSEFONT for: aWindow flags: flags)		memberAt: #lpLogFont	put: logFont;	yourself.	aColorValue notNil ifTrue: [cfs memberAt: #rgbColors put: (self colorRefFrom: aColorValue)].	null := self nullString.	fd := aFontDescription notNil ifTrue: [aFontDescription] ifFalse: [self class defaultFontDescription].	scaleFactor := scaleFactor + (fd pixelSize / 400).	(logFont memberAt: #lfFaceName) copyAt: 0 from: fd family size: fd family size startingAt: 1.	(logFont memberAt: #lfFaceName) copyAt: fd family size from: null size: null size startingAt: 1.	logFont memberAt: #lfWeight put: (fd boldness * 1000) asInteger.	logFont memberAt: #lfItalic put: (fd italic ifTrue: [255] ifFalse: [0]).	logFont memberAt: #lfHeight put: (lfHeight := (fd pixelSize * 96 / 72 / scaleFactor) rounded negated).	(self ChooseFont: cfs) ~~ 0		ifTrue:			[answer := FontDescription new family: (logFont memberAt: #lfFaceName) copyCStringFromHeap.			answer boldness: ((logFont memberAt: #lfWeight) / 1000) asFloat.			answer italic: (logFont memberAt: #lfItalic) ~~ 0.			answer pixelSize: ((logFont memberAt: #lfHeight) == lfHeight 				ifTrue: [fd pixelSize] 				ifFalse: [((cfs memberAt: #iPointSize) * scaleFactor / 10) rounded]).			answer := answer -&gt; (self colorValueFrom: (cfs memberAt: #rgbColors))].	cfs free.	^answer</body><body>chooseFont: aFont for: aWindow 	^self chooseFont: aFont color: nil for: aWindow flags: #(SCREENFONTS INITTOLOGFONTSTRUCT)</body></methods><methods><class-id>Aragon.Win32</class-id> <category>convenient - color chooser</category><body>chooseColor	^self chooseColor: nil</body><body>chooseColor: aColorValue	^self chooseColor: aColorValue customColors: nil</body><body>chooseColor: aColorValue customColors: anArray	^self chooseColor: aColorValue customColors: anArray  for: Window currentWindow</body><body>chooseColor: aColorValue customColors: anArray  for: aWindow	^self chooseColor: aColorValue customColors: anArray  for: aWindow flags: #(RGBINIT)</body><body>chooseColor: aColorValue customColors: anArray  for: aWindow flags: flags	| ccs answer customColors |	customColors := self class customColors.	anArray notNil ifTrue: [1 to:  (6 min: anArray size) do: [:i | customColors at: i-1 put: (self colorRefFrom: (anArray at: i))]].	ccs := (self prepareCommonDialog: self CHOOSECOLOR for: aWindow flags: flags)		memberAt: #lpCustColors		put: customColors;	yourself.	aColorValue notNil ifTrue: [ccs memberAt: #rgbResult put: (self colorRefFrom: aColorValue)].	(self ChooseColor: ccs) ~~ 0		ifTrue: [answer := self colorValueFrom: (ccs memberAt: #rgbResult)].	anArray notNil ifTrue: [1 to:  (6 min: anArray size) do: [:i  | anArray at: i put: (self colorValueFrom: (customColors at: i-1))]].	ccs free.	^answer</body><body>chooseColor: aColorValue for: aWindow	^self chooseColor: aColorValue customColors: nil  for: aWindow</body></methods><methods><class-id>Aragon.Win32</class-id> <category>convenient - processes</category><body>createProcess: commandLine 	^self		createProcess: commandLine		flags: #(createDefaultErrorMode createNewProcessGroup)		environment: nil		workDirectory: nil		windowTitle: nil		windowBounds: nil		windowMode: #showNormal</body><body>createProcess: commandLine flags: flags 	^self		createProcess: commandLine		flags: flags		environment: nil		workDirectory: nil		windowTitle: nil		windowBounds: nil		windowMode: #showNormal</body><body>createProcess: commandLine flags: flags environment: env workDirectory: workDir windowTitle: title windowBounds: aRectangle windowMode:  windowMode	| startupInfo windowFlags processInfo returnValue answer |	windowFlags := 0.	startupInfo := STARTUPINFO malloc.	startupInfo memberAt: #cb put: STARTUPINFO sizeof.	startupInfo memberAt: #lpReserved put: nil.	startupInfo memberAt: #lpDesktop put: nil.	startupInfo memberAt: #lpTitle put: title.	aRectangle notNil		ifTrue:			[windowFlags := windowFlags bitOr: 2+4.			startupInfo memberAt: #dwX put: aRectangle origin x.			startupInfo memberAt: #dwY put: aRectangle origin y.			startupInfo memberAt: #dwXSize put: aRectangle extent x.			startupInfo memberAt: #dwYSize put: aRectangle extent y].	startupInfo memberAt: #dwFillAttribute put: 0.	windowMode notNil		ifTrue:			[windowFlags := windowFlags bitOr: 1.			startupInfo memberAt: #wShowWindow put: (self resolveFlag: windowMode withKey: #ShowWindow)].	startupInfo memberAt: #cbReserved2 put: 0.	startupInfo memberAt: #lpReserved2 put: nil.	startupInfo memberAt: #dwFlags put: windowFlags.	processInfo := PROCESS_INFORMATION malloc.	returnValue := self CreateProcess: nil 		with: commandLine		with: nil		with: nil		with: 0		with: (self resolveFlags: flags withKey: #CreateProcess)		with: env		with: workDir		with: startupInfo		with: processInfo.	returnValue ~~ 0 		ifTrue: [self CloseHandle: (processInfo memberAt: #hThread)]		ifFalse: [^nil].	answer := Win32Process new		id: (processInfo memberAt: #dwProcessId); 		handle: (processInfo memberAt: #hProcess).	processInfo free.	startupInfo free.	^answer</body><body>createProcess: commandLine in: aRectangle	^self		createProcess: commandLine		flags: #(createDefaultErrorMode createNewProcessGroup)		environment: nil		workDirectory: nil		windowTitle: nil		windowBounds: aRectangle		windowMode: #showNormal</body><body>createProcess: commandLine windowMode: aSymbol	^self		createProcess: commandLine		flags: #(createDefaultErrorMode createNewProcessGroup)		environment: nil		workDirectory: nil		windowTitle: nil		windowBounds: nil		windowMode: aSymbol</body><body>execute: aCommand	^self execute: aCommand showWindow: #showNormal</body><body>execute: aCommand showWindow: aSymbol	^self WinExec: aCommand with: (self resolveFlag: aSymbol withKey: #ShowWindow)</body></methods><methods><class-id>Aragon.Win32</class-id> <category>convenient - message box</category><body>messageBox: message	^self messageBox: message caption: '' type: #mbOk</body><body>messageBox: message caption: caption flags: anArray	^self messageBox: message caption: caption flags: anArray for: nil</body><body>messageBox: message caption: caption flags: flags for: aWindow 	| hWnd returnValue |	hWnd := (aWindow isNil ifTrue: [Window currentWindow] ifFalse: [aWindow]) windowHandle.	returnValue := self				MessageBox: hWnd				with: message				with: caption				with: (self resolveFlags: flags withKey: #MessageBoxFlags).	^returnValue &gt; 0 ifTrue: [(Constants at: #MessageBoxAnswers) at: returnValue]</body><body>messageBox: message caption: caption type: type 	^self messageBox: message caption: caption flags: (Array with: type) for: nil</body><body>messageBox: message caption: caption type: type icon: icon	^self messageBox: message caption: caption flags: (Array with: type with: icon) for: nil</body><body>messageBox: message icon: icon	^self messageBox: message caption: '' type: #mbOk icon: icon</body><body>messageBox: message type: type 	^self messageBox: message caption: nil type: type</body></methods><methods><class-id>Aragon.Win32</class-id> <category>convenient - miscellaneous</category><body>currentDirectory	| length buffer answer |	length := 255.	buffer := CIntegerType char malloc: length+1.	self GetCurrentDirectory: length with: buffer.	answer := buffer copyCStringFromHeap.	buffer free.	^answer</body><body>currentDirectory: aFilenameOrString	self SetCurrentDirectory: aFilenameOrString asString</body><body>diskFreeSpaceExOn: aDirectory	| lpFreeBytesAvailableToCaller lpTotalNumberOfBytes lpTotalNumberOfFreeBytes answer |	lpFreeBytesAvailableToCaller := ULARGE_INTEGER malloc.	lpTotalNumberOfBytes := ULARGE_INTEGER malloc.	lpTotalNumberOfFreeBytes := ULARGE_INTEGER malloc.	self GetDiskFreeSpaceEx: aDirectory asString with: lpFreeBytesAvailableToCaller with: lpTotalNumberOfBytes with: lpTotalNumberOfFreeBytes.	answer := IdentityDictionary new 		add: #directoryName -&gt; aDirectory asString;		add: #freeBytesAvailableToCaller -&gt; (((lpFreeBytesAvailableToCaller memberAt: #HighPart) bitShift: 32) bitOr:  (lpFreeBytesAvailableToCaller memberAt: #LowPart));		add: #totalNumberOfBytes -&gt; (((lpTotalNumberOfBytes memberAt: #HighPart) bitShift: 32) bitOr:  (lpTotalNumberOfBytes memberAt: #LowPart));		add: #totalNumberOfFreeBytes -&gt; (((lpTotalNumberOfFreeBytes memberAt: #HighPart) bitShift: 32) bitOr:  (lpTotalNumberOfFreeBytes memberAt: #LowPart));	yourself.	lpFreeBytesAvailableToCaller free.	lpTotalNumberOfBytes free.	lpTotalNumberOfFreeBytes free.		^answer</body><body>diskFreeSpaceOn: aDirectory	| sectorsPerCluster bytesPerSector numberOfFreeClusters totalNumberOfClusters answer |	sectorsPerCluster := DWORD malloc.	bytesPerSector := DWORD malloc.	numberOfFreeClusters := DWORD malloc.	totalNumberOfClusters := DWORD malloc.	self GetDiskFreeSpace: aDirectory asString with: sectorsPerCluster with: bytesPerSector with: numberOfFreeClusters with: totalNumberOfClusters.	answer := IdentityDictionary new 		add: #rootPathName -&gt; aDirectory asString;		add: #sectorsPerCluster -&gt; sectorsPerCluster contents;		add: #bytesPerSector -&gt; bytesPerSector contents;		add: #numberOfFreeClusters -&gt; numberOfFreeClusters contents;		add: #totalNumberOfClusters -&gt; totalNumberOfClusters contents;	yourself.	sectorsPerCluster free.	bytesPerSector free.	numberOfFreeClusters free.	totalNumberOfClusters free.		^answer</body><body>findContentsOf: aFilename 	^self findFilesLike: (aFilename asFilename construct: '*') asString</body><body>findFilesLike: aPattern	| answer fileInfo handle getFileTime |	answer := OrderedCollection new.	fileInfo := self WIN32_FIND_DATA malloc.	[handle := self FindFirstFile: aPattern asString with: fileInfo.	handle &lt; 0 ifTrue: [^#()].	getFileTime := [:ft || ts | ts := Timestamp		fromSeconds: (((ft memberAt: #dwHighDateTime) bitShift: 32) 				+ (ft memberAt: #dwLowDateTime)) 			// 10000000 + (26*3600). ts year: ts year - 300].		[answer add: (Win32Filename new		name:		(fileInfo memberAt: #cFileName) copyCStringFromHeap;		fileSize:		((fileInfo memberAt: #nFileSizeHigh) bitShift: 32) + (fileInfo memberAt: #nFileSizeLow);		created:		(getFileTime value: (fileInfo memberAt: #ftCreationTime));		accessed:	(getFileTime value: (fileInfo memberAt: #ftLastAccessTime));		modified:	(getFileTime value: (fileInfo memberAt: #ftLastWriteTime));		attributes:	(fileInfo memberAt: #dwFileAttributes);	yourself).	(self FindNextFile: handle with: fileInfo) ~~ 0] whileTrue.	self FindClose: handle]		valueNowOrOnUnwindDo: [fileInfo free].	^answer</body><body>findText: default for: aWindow flags: flags	| frs answer findText |		findText := CIntegerType char malloc: 214.	default notNil ifTrue: [findText copyAt: 0 from: default size: default size startingAt: 1].	frs := (self prepareCommonDialog: self FINDREPLACE for: aWindow flags: flags)		memberAt: #lpstrFindWhat	put: default;		memberAt: #wFindWhatLen	put: 214;	yourself.	(self FindText: frs) ~~ 0		ifTrue: [answer := (frs memberAt: #lpstrFindWhat) copyCStringFromHeap].	findText free.	frs free.	^answer</body><body>getenv	| pointer result string p0 |	p0 := pointer := self GetEnvironmentStrings.	result := Dictionary new.		[string := pointer copyCStringFromHeap.	string isEmpty]		whileFalse: 			[| entry | entry := string tokensBasedOn: $=.			result add: entry first -&gt; entry last.			pointer += (string size + 1)].	self FreeEnvironmentStrings: p0.	^result</body><body>getenv: aVariableName	| buffer answer |	buffer := CIntegerType char malloc: 400+1.	self GetEnvironmentVariable: aVariableName asString with: buffer with: 400.	answer := buffer copyCStringFromHeap.	buffer free.	^answer</body><body>replaceText: default with: replacement for: aWindow flags: flags	| frs answer findText replaceText |		findText := CIntegerType char malloc: 214.	replaceText := CIntegerType char malloc: 214.	default notNil ifTrue: [findText copyAt: 0 from: default size: default size startingAt: 1].	replacement notNil ifTrue: [replaceText copyAt: 0 from: replacement size: replacement size startingAt: 1].	frs := (self prepareCommonDialog: self FINDREPLACE for: aWindow flags: flags)		memberAt: #lpstrFindWhat		put: findText;		memberAt: #lpstrReplaceWith		put: replaceText;		memberAt: #wFindWhatLen		put: 214;		memberAt: #wReplaceWithLen	put: 214;	yourself.	(self ReplaceText: frs) ~~ 0		ifTrue: [answer := (frs memberAt: #lpstrFindWhat) copyCStringFromHeap].	findText free.	replaceText free.	frs free.	^answer</body><body>setenv: aVariableName value: aString	self SetEnvironmentVariable: aVariableName asString with: aString</body><body>shellExecute: aCommand on: aFilename	^self shellExecute: aCommand on: aFilename asString with: nil in: nil</body><body>shellExecute: aCommand on: aFilename in: aDirectory	^self shellExecute: aCommand on: aFilename asString with: nil in: aDirectory asString</body><body>shellExecute: aCommand on: aPath with: parameters in: startDirectory 	^self shellExecute: aCommand on: aPath asString with: parameters in: startDirectory for: Window currentWindow</body><body>shellExecute: aCommand on: aPath with: parameters in: startDirectory for: aWindow 	^self 		ShellExecute: (aWindow notNil				ifTrue: [aWindow windowHandle]				ifFalse: [0])		with: aCommand asString 		with: aPath asString		with: parameters		with: startDirectory		with: 1</body><body>unsetenv: aVariableName	self setenv: aVariableName value: nil</body></methods><methods><class-id>Aragon.Win32</class-id> <category>typedefs</category><body>BOOL	&lt;C: typedef long  BOOL&gt;</body><body>BYTE	&lt;C: typedef unsigned char  BYTE&gt;</body><body>CHOOSECOLOR	&lt;C: typedef struct {   // cc  		    DWORD				lStructSize; 		    HWND				hwndOwner; 		    HWND				hInstance; 		    COLORREF			rgbResult; 		    COLORREF*			lpCustColors; 		    DWORD				Flags; 		    LPARAM				lCustData; 		    LPCCHOOKPROC		lpfnHook; 		    LPCTSTR				lpTemplateName; 	} CHOOSECOLOR&gt;</body><body>CHOOSEFONT	&lt;C: typedef struct {// cf 			DWORD				lStructSize; 			HWND				hwndOwner; 			HDC				hDC; 			LOGFONT *			lpLogFont; 			INT					iPointSize; 			DWORD				Flags; 			DWORD				rgbColors; 			LPARAM				lCustData; 			void *				lpfnHook; 			LPCTSTR			lpTemplateName; 			HINSTANCE			hInstance; 			LPTSTR				lpszStyle; 			WORD				nFontType; 			WORD				___MISSING_ALIGNMENT__; 			INT					nSizeMin; 			INT					nSizeMax; 	} CHOOSEFONT&gt;</body><body>COLORREF	&lt;C: typedef unsigned long  COLORREF&gt;</body><body>DWORD	&lt;C: typedef unsigned long  DWORD&gt;</body><body>FILETIME	&lt;C: typedef struct _FILETIME { // ft 		    DWORD dwLowDateTime; 		    DWORD dwHighDateTime; 	} FILETIME&gt;</body><body>FINDREPLACE	&lt;C: typedef struct {    // fr 		    DWORD		lStructSize; 		    HWND		hwndOwner; 		    HINSTANCE	hInstance; 		    DWORD		Flags; 		    LPCSTR		lpstrFindWhat; 		    LPCSTR		lpstrReplaceWith; 		    WORD		wFindWhatLen; 		    WORD		wReplaceWithLen; 		    LPARAM		lCustData; 		    LPVOID		lpfnHook; 		    LPCSTR		lpTemplateName; 	} FINDREPLACE&gt;</body><body>HANDLE	&lt;C: typedef unsigned long HANDLE&gt;</body><body>HDC	&lt;C: typedef unsigned long HDC&gt;</body><body>HINSTANCE	&lt;C: typedef unsigned long HINSTANCE&gt;</body><body>HWND	&lt;C: typedef unsigned long  HWND&gt;</body><body>INT	&lt;C: typedef int  INT&gt;</body><body>LOGFONT	&lt;C: typedef struct tagLOGFONT { // lf 		   LONG lfHeight; 		   LONG lfWidth; 		   LONG lfEscapement; 		   LONG lfOrientation; 		   LONG lfWeight; 		   BYTE lfItalic; 		   BYTE lfUnderline; 		   BYTE lfStrikeOut; 		   BYTE lfCharSet; 		   BYTE lfOutPrecision; 		   BYTE lfClipPrecision; 		   BYTE lfQuality; 		   BYTE lfPitchAndFamily; 		   TCHAR lfFaceName[32]; 	} LOGFONT&gt;</body><body>LONG	&lt;C: typedef long  LONG&gt;</body><body>LPARAM	&lt;C: typedef LONG  LPARAM&gt;</body><body>LPCSTR	&lt;C: typedef unsigned char*  LPCSTR&gt;</body><body>LPCTSTR	&lt;C: typedef const unsigned short*  LPCTSTR&gt;</body><body>LPTSTR	&lt;C: typedef unsigned short*  LPTSTR&gt;</body><body>LPVOID	&lt;C: typedef void*  LPVOID&gt;</body><body>OPENFILENAME	&lt;C: typedef struct tagOFN { // ofn 		    DWORD		lStructSize; 		    HWND		hwndOwner; 		    HINSTANCE	hInstance; 		    LPCSTR		lpstrFilter; 		    LPCSTR		lpstrCustomFilter; 		    DWORD		nMaxCustFilter; 		    DWORD		nFilterIndex; 		    LPCSTR		lpstrFile; 		    DWORD		nMaxFile; 		    LPCSTR		lpstrFileTitle; 		    DWORD		nMaxFileTitle; 		    LPCSTR		lpstrInitialDir; 		    LPCSTR		lpstrTitle; 		    DWORD		Flags; 		    WORD		nFileOffset; 		    WORD		nFileExtension; 		    LPCSTR		lpstrDefExt; 		    DWORD		lCustData; 		    LPVOID		lpfnHook; 		    LPCSTR		lpTemplateName; 	} OPENFILENAME&gt;</body><body>PROCESS_INFORMATION	&lt;C: typedef struct _PROCESS_INFORMATION { // pi  	    HANDLE hProcess; 	    HANDLE hThread; 	    DWORD dwProcessId; 	    DWORD dwThreadId; 	} PROCESS_INFORMATION&gt;</body><body>SECURITY_ATTRIBUTES	&lt;C: typedef struct _SECURITY_ATTRIBUTES { // sa  		    DWORD  nLength; 		    LPVOID lpSecurityDescriptor; 		    BOOL   bInheritHandle; 	} SECURITY_ATTRIBUTES&gt;</body><body>STARTUPINFO	&lt;C: typedef struct _STARTUPINFO { // si  	    DWORD   cb; 	    LPTSTR  lpReserved; 	    LPTSTR  lpDesktop; 	    LPTSTR  lpTitle; 	    DWORD   dwX; 	    DWORD   dwY; 	    DWORD   dwXSize; 	    DWORD   dwYSize; 	    DWORD   dwXCountChars; 	    DWORD   dwYCountChars; 	    DWORD   dwFillAttribute; 	    DWORD   dwFlags; 	    WORD    wShowWindow; 	    WORD    cbReserved2; 	    LPBYTE  lpReserved2; 	    HANDLE  hStdInput; 	    HANDLE  hStdOutput; 	    HANDLE  hStdError; 	} STARTUPINFO&gt;</body><body>TCHAR	&lt;C: typedef WCHAR TCHAR&gt;</body><body>UINT	&lt;C: typedef unsigned int  UINT&gt;</body><body>ULARGE_INTEGER	&lt;C: typedef struct _ULARGE_INTEGER {  	        DWORD LowPart; 	        DWORD HighPart; 	} ULARGE_INTEGER&gt;</body><body>WCHAR	&lt;C: typedef wchar_t  WCHAR&gt;</body><body>wchar_t	"As declared in 'rpcndr.h'"	&lt;C: typedef unsigned short  wchar_t&gt;</body><body>WIN32_FIND_DATA	&lt;C: typedef struct _WIN32_FIND_DATA { // wfd 		    DWORD dwFileAttributes; 		    FILETIME ftCreationTime; 		    FILETIME ftLastAccessTime; 		    FILETIME ftLastWriteTime; 		    DWORD    nFileSizeHigh; 		    DWORD    nFileSizeLow; 		    DWORD    dwReserved0; 		    DWORD    dwReserved1; 		    char    cFileName [ 260 ]; 		    char    cAlternateFileName [ 14 ]; 	} WIN32_FIND_DATA&gt;</body><body>WORD	&lt;C: typedef unsigned short  WORD&gt;</body></methods><methods><class-id>Aragon.Win32</class-id> <category>types</category><body>LPBYTE	&lt;C: typedef void * LPBYTE&gt;</body><body>LPCCHOOKPROC	&lt;C: typedef void * LPCCHOOKPROC&gt;</body><body>LPCFHOOKPROC	&lt;C: typedef void * LPCFHOOKPROC&gt;</body></methods><methods><class-id>Aragon.Win32</class-id> <category>structs</category><body>tagLOGFONT	&lt;C: struct tagLOGFONT {			LONG lfHeight, lfWidth, lfEscapement, lfOrientation, lfWeight;			BYTE lfItalic, lfUnderline, lfStrikeOut, lfCharSet, lfOutPrecision, lfClipPrecision, lfQuality, lfPitchAndFamily;			TCHAR lfFaceName[32];		}&gt;</body><body>tagOFN	&lt;C: struct tagOFN {			DWORD lStructSize;			HWND hwndOwner;			HINSTANCE hInstance;			LPCSTR lpstrFilter, lpstrCustomFilter;			DWORD nMaxCustFilter, nFilterIndex;			LPCSTR lpstrFile;			DWORD nMaxFile;			LPCSTR lpstrFileTitle;			DWORD nMaxFileTitle;			LPCSTR lpstrInitialDir, lpstrTitle;			DWORD Flags;			WORD nFileOffset, nFileExtension;			LPCSTR lpstrDefExt;			DWORD lCustData;			LPVOID lpfnHook;			LPCSTR lpTemplateName;		}&gt;</body><body>_FILETIME	&lt;C: struct _FILETIME {			DWORD dwLowDateTime, dwHighDateTime;		}&gt;</body><body>_PROCESS_INFORMATION	&lt;C: struct _PROCESS_INFORMATION {			HANDLE hProcess, hThread;			DWORD dwProcessId, dwThreadId;		}&gt;</body><body>_SECURITY_ATTRIBUTES	&lt;C: struct _SECURITY_ATTRIBUTES {			DWORD nLength;			LPVOID lpSecurityDescriptor;			BOOL bInheritHandle;		}&gt;</body><body>_STARTUPINFO	&lt;C: struct _STARTUPINFO {			DWORD cb;			LPTSTR lpReserved, lpDesktop, lpTitle;			DWORD dwX, dwY, dwXSize, dwYSize, dwXCountChars, dwYCountChars, dwFillAttribute, dwFlags;			WORD wShowWindow, cbReserved2;			LPBYTE lpReserved2;			HANDLE hStdInput, hStdOutput, hStdError;		}&gt;</body><body>_ULARGE_INTEGER	&lt;C: struct _ULARGE_INTEGER {			DWORD LowPart, HighPart;		}&gt;</body><body>_WIN32_FIND_DATA	&lt;C: struct _WIN32_FIND_DATA {			DWORD dwFileAttributes;			FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;			DWORD nFileSizeHigh, nFileSizeLow, dwReserved0, dwReserved1;			char cFileName[260];			char cAlternateFileName[14];		}&gt;</body></methods><methods><class-id>Aragon.Win32</class-id> <category>private</category><body>colorRefFrom: aColorValue	^((aColorValue red * 255) rounded	bitOr: ((aColorValue green * 255) rounded bitShift: 8))	bitOr: ((aColorValue blue * 255) rounded bitShift: 16)</body><body>colorValueFrom: aColorRef	^ColorValue		red:		(aColorRef bitAnd: 16rff) / 255		green:	((aColorRef bitShift: -8) bitAnd: 16rff) / 255		blue:	((aColorRef bitShift: -16) bitAnd: 16rff) / 255</body><body>getFilenamesFrom: aCPointer flags: flags 	| files |	(flags includes: #ALLOWMULTISELECT) ifFalse: [^aCPointer copyCStringFromHeap].	(flags includes: #EXPLORER)		ifTrue: 			[| bytes  i0 n |			bytes := ByteArray new: (n := self class fileBufferSize+1).			aCPointer copyAt: 0 to: bytes size: n startingAt: 1.			files := OrderedCollection new.			i0 := 1.						[| i |			i := bytes nextIndexOf: 0 from: i0 to: n.			files add: (bytes copyFrom: i0 to: i - 1) asByteString.			(bytes at: (i0 := i + 1)) ~= 0] whileTrue]				ifFalse: [files := aCPointer copyCStringFromHeap tokensBasedOn: Character space].	^files size &gt; 1 		ifTrue: [(2 to: files size) collect: [:i | (files first asFilename construct: (files at: i)) asString]]		ifFalse: [files]</body><body>nullString	^String with: (Character value: 0).</body><body>prepareCommonDialog: aCommonDialogStructureType for: aWindow flags: flags 	^(aCommonDialogStructureType malloc) 				memberAt: #lStructSize put: aCommonDialogStructureType sizeof; 		memberAt: #hwndOwner put: (aWindow notNil			ifTrue: [aWindow windowHandle]			ifFalse: [0]); 		memberAt: #Flags put: (self resolveFlags: flags withKey: aCommonDialogStructureType); 	yourself</body><body>prepareFilenameDialog: default title: aTitle filters: filters for: aWindow flags: flags	| filename null size initial filterString |	initial := default asString.	size := self class fileBufferSize.	(initial size &gt; size or: [initial includes: Character cr]) ifTrue: [initial := ''].	null := self nullString.	filename := CIntegerType char malloc: size+null size.	filename copyAt: 0 from: initial size: initial size startingAt: 1.	filename copyAt: initial size from: null size: null size startingAt: 1.	filterString := filters isEmpty ifFalse: [(filters inject: '' into: [:s :f | s, f, null]) copyToHeap].	^(self prepareCommonDialog: self OPENFILENAME for: aWindow flags: flags)		memberAt: #lpstrFilter put: filterString;		memberAt: #lpstrCustomFilter put: nil;		memberAt: #nFilterIndex put: 1;		memberAt: #lpstrFile put: filename;		memberAt: #lpstrTitle put: aTitle;		memberAt: #nMaxFile put: size;		memberAt: #lpstrFileTitle put: nil;		memberAt: #lpstrInitialDir put: nil;		memberAt: #lpstrDefExt put: nil;	yourself.</body><body>requestFilenameWith: aSelector default: default title: aTitle filters: filters for: aWindow flags: flagsOrNil	| params answer flags p |	(flags := flagsOrNil) isNil ifTrue: [flags := self class defaultFlags at: aSelector ifAbsent: []].	params := self				prepareFilenameDialog: default				title: aTitle				filters: filters				for: aWindow				flags: flags.	Object errorSignal 		handle: 			[:ex |				Transcript show:  '-------------------------------------------'; cr.				Transcript show: 'Win32: Failed to call ', aSelector; cr.				Transcript show: 'Exception was: ', ex errorString; cr.				Transcript show: 'CommDlgExtendedError reports: ', self CommDlgExtendedError printString; cr.				Transcript show: 'using standard filename requestor instead ...'; cr.				Transcript show:  '-------------------------------------------'; cr.				answer := Dialog request: (aTitle isNil					ifTrue: [DefaultTitles at: aSelector]					ifFalse: [aTitle])				initialAnswer: default.			 answer isEmpty ifTrue: [answer := nil]]		do: [(self perform: aSelector with: params) ~~ 0 			ifTrue: [answer := self getFilenamesFrom: (params memberAt: #lpstrFile) flags: flags]			ifFalse: [self CommDlgExtendedError ~~ 0 				ifTrue: 					["Most often this happens because some strange default filename pattern was 					passed from the current text selection "					^self requestFilenameWith: aSelector default: '' title: aTitle filters: filters for: aWindow flags: flags]]].	(p := params memberAt: #lpstrFilter) isNull ifFalse: [p free].	(p := params memberAt: #lpstrFile) isNull ifFalse: [p free].	params free.	(answer notNil and: [default notNil and: [default asString isEmpty not and: [default asFilename isRelative]]])		ifTrue: 			[| s | s := Filename defaultDirectoryName.			(flags includes: #ALLOWMULTISELECT)				ifTrue: 					[1 to: answer size do: 						[:i || a | a := (answer at: i) asFilename.						a directory = s ifTrue: [answer at: i put: a tail]]]			ifFalse:  [answer asFilename directory = s ifTrue: [answer := answer asFilename tail]]].	^answer</body><body>resolveFlag: aSymbol withKey: aKey 	^(Constants at: aKey) at: aSymbol</body><body>resolveFlags: anArrayOfSymbols withKey: aKey 	| flags |	flags := Constants at: aKey.	^anArrayOfSymbols inject: 0 into: [:f :each | f bitOr: (flags at: each)]</body></methods><methods><class-id>Aragon.Win32 class</class-id> <category>class initialization</category><body>defaultFlags	^DefaultFlags</body><body>flushAllCaches	self releaseCustomColors.	instance := nil.	^super flushAllCaches</body><body>initialize	"Win32 initialize"	Constants := IdentityDictionary new.	self initializeCreateProcessFlags.	self initializeShowWindowFlags.	self initializeMessageBoxFlags.	self initializeHelpCommands.	self initializeColorDialogFlags.	self initializeFileDialogFlags.	self initializeFindDialogFlags.	self initializeFontDialogFlags.	DefaultTitles := IdentityDictionary new			at: #GetOpenFileName: put: 'Open';			at: #GetSaveFileName: put: 'Save As';		yourself.	DefaultFlags := IdentityDictionary new			at: #GetOpenFileName: put:  #(CREATEPROMPT PATHMUSTEXIST HIDEREADONLY NOCHANGEDIR);			at: #GetSaveFileName: put: #(CREATEPROMPT PATHMUSTEXIST FILEMUSTEXIST HIDEREADONLY NOCHANGEDIR);		yourself.</body><body>initializeColorDialogFlags	Constants at: self CHOOSECOLOR put: (IdentityDictionary new			at: #RGBINIT						put: 16r00000001;			at: #FULLOPEN					put: 16r00000002;			at: #PREVENTFULLOPEN			put: 16r00000004;			at: #SHOWHELP					put: 16r00000008;			at: #ENABLEHOOK				put: 16r00000010;			at: #ENABLETEMPLATE			put: 16r00000020;			at: #ENABLETEMPLATEHANDLE	put: 16r00000040;			at: #SOLIDCOLOR				put: 16r00000080;			at: #ANYCOLOR					put: 16r00000100;	yourself).</body><body>initializeCreateProcessFlags	Constants at: #CreateProcess put: (IdentityDictionary new			at: #debugProcess				put: 16r00000001;			at: #debugOnlyThisProcess		put: 16r00000002;			at: #createSuspended			put: 16r00000004;			at: #detachedProcess			put: 16r00000008;			at: #createNewConsole			put: 16r00000010;			at: #normalPriorityClass			put: 16r00000020;			at: #idlePriorityClass				put: 16r00000040;			at: #highPriorityClass				put: 16r00000080;			at: #realtimePriorityClass			put: 16r00000100;			at: #createNewProcessGroup		put: 16r00000200;			at: #createUnicodeEnvironment	put: 16r00000400;			at: #createSeparateWowVdm		put: 16r00000800;			at: #createSharedWowVdm		put: 16r00001000;			at: #createDefaultErrorMode		put: 16r04000000;			at: #createNoWindow				put: 16r08000000;		yourself).</body><body>initializeFileDialogFlags	Constants at: self OPENFILENAME put: (IdentityDictionary new			at: #READONLY					put: 16r00000001;			at: #OVERWRITEPROMPT		put: 16r00000002;			at: #HIDEREADONLY				put: 16r00000004;			at: #NOCHANGEDIR				put: 16r00000008;			at: #SHOWHELP					put: 16r00000010;			at: #ENABLEHOOK				put: 16r00000020;			at: #ENABLETEMPLATE			put: 16r00000040;			at: #ENABLETEMPLATEHANDLE	put: 16r00000080;			at: #NOVALIDATE				put: 16r00000100;			at: #ALLOWMULTISELECT		put: 16r00000200;			at: #EXTENSIONDIFFERENT		put: 16r00000400;			at: #PATHMUSTEXIST			put: 16r00000800;			at: #FILEMUSTEXIST				put: 16r00001000;			at: #CREATEPROMPT			put: 16r00002000;			at: #SHAREAWARE				put: 16r00004000;			at: #NOREADONLYRETURN		put: 16r00008000;			at: #NOTESTFILECREATE		put: 16r00010000;			at: #NONETWORKBUTTON		put: 16r00020000;			at: #NOLONGNAMES				put: 16r00040000;			at: #EXPLORER					put: 16r00080000;			at: #NODEREFERENCELINKS	put: 16r00100000;			at: #LONGNAMES				put: 16r00200000;	yourself).</body><body>initializeFindDialogFlags	Constants at: self FINDREPLACE put: (IdentityDictionary new			at: #DOWN						put: 16r00000001;			at: #WHOLEWORD				put: 16r00000002;			at: #MATCHCASE				put: 16r00000004;			at: #FINDNEXT					put: 16r00000008;			at: #REPLACE					put: 16r00000010;			at: #REPLACEALL               		put: 16r00000020;			at: #DIALOGTERM				put: 16r00000040;			at: #SHOWHELP					put: 16r00000080;			at: #ENABLEHOOK				put: 16r00000100;			at: #ENABLETEMPLATE			put: 16r00000200;			at: #NOUPDOWN			 	put: 16r00000400;			at: #NOMATCHCASE				put: 16r00000800;			at: #NOWHOLEWORD			put: 16r00001000;			at: #ENABLETEMPLATEHANDLE	put: 16r00002000;			at: #HIDEUPDOWN				put: 16r00004000;			at: #HIDEMATCHCASE			put: 16r00008000;			at: #HIDEWHOLEWORD			put: 16r00010000;	yourself).</body><body>initializeFontDialogFlags	Constants at: self CHOOSEFONT put: (IdentityDictionary new			at: #SCREENFONTS				put: 16r00000001;			at: #PRINTERFONTS				put: 16r00000002;			at: #BOTH						put: 16r00000003;	"(CF_SCREENFONTS | CF_PRINTERFONTS);"			at: #SHOWHELP					put: 16r00000004;			at: #ENABLEHOOK				put: 16r00000008;			at: #ENABLETEMPLATE			put: 16r00000010;			at: #ENABLETEMPLATEHANDLE	put: 16r00000020;			at: #INITTOLOGFONTSTRUCT		put: 16r00000040;			at: #USESTYLE					put: 16r00000080;			at: #EFFECTS					put: 16r00000100;			at: #APPLY						put: 16r00000200;			at: #ANSIONLY					put: 16r00000400;			at: #SCRIPTSONLY				put: 16r00000400;	"CF_ANSIONLY"			at: #NOVECTORFONTS			put: 16r00000800;			at: #NOOEMFONTS				put: 16r00000800;	"CF_NOVECTORFONTS"			at: #NOSIMULATIONS			put: 16r00001000;			at: #LIMITSIZE					put: 16r00002000;			at: #FIXEDPITCHONLY			put: 16r00004000;			at: #WYSIWYG					put: 16r00008000;	"must also have CF_SCREENFONTS &amp; CF_PRINTERFONTS"			at: #FORCEFONTEXIST			put: 16r00010000;			at: #SCALABLEONLY				put: 16r00020000;			at: #TTONLY						put: 16r00040000;			at: #NOFACESEL					put: 16r00080000;			at: #NOSTYLESEL				put: 16r00100000;			at: #NOSIZESEL					put: 16r00200000;			at: #SELECTSCRIPT				put: 16r00400000;			at: #NOSCRIPTSEL				put: 16r00800000;			at: #NOVERTFONTS				put: 16r01000000;	yourself).</body><body>initializeHelpCommands		Constants at: #HelpCommandCodes put: (IdentityDictionary new		add: #HELP_CONTEXT			-&gt; 16r0001  "Display topic in ulTopic";		add: #HELP_QUIT				-&gt; 16r0002  "Terminate help";		add: #HELP_INDEX				-&gt; 16r0003  "Display index";		add: #HELP_CONTENTS			-&gt; 16r0003;		add: #HELP_HELPONHELP		-&gt; 16r0004  "Display help on using help";		add: #HELP_SETINDEX			-&gt; 16r0005  "Set current Index for multi index help";		add: #HELP_SETCONTENTS		-&gt; 16r0005;		add: #HELP_CONTEXTPOPUP	-&gt; 16r0008;		add: #HELP_FORCEFILE			-&gt; 16r0009;		add: #HELP_KEY				-&gt; 16r0101  "Display topic for keyword in offabData";		add: #HELP_COMMAND			-&gt; 16r0102;		add: #HELP_PARTIALKEY		-&gt; 16r0105;		add: #HELP_MULTIKEY			-&gt; 16r0201;		add: #HELP_SETWINPOS		-&gt; 16r0203;		add: #HELP_CONTEXTMENU		-&gt; 16r000a;		add: #HELP_FINDER				-&gt; 16r000b;		add: #HELP_WM_HELP			-&gt; 16r000c;		add: #HELP_SETPOPUP_POS	-&gt; 16r000d;		add: #HELP_TCARD				-&gt; 16r8000;		add: #HELP_TCARD_DATA		-&gt; 16r0010;		add: #HELP_TCARD_OTHER_CALLER -&gt; 16r0011;	yourself).</body><body>initializeMessageBoxFlags		Constants at: #MessageBoxFlags put: (IdentityDictionary new		at: #mbOk						put: 16r00000000;		at: #mbOkCancel					put: 16r00000001;		at: #mbAbortRetryIgnore			put: 16r00000002;		at: #mbYesNoCancel				put: 16r00000003;		at: #mbYesNo					put: 16r00000004;		at: #mbRetryCancel				put: 16r00000005;		at: #mbIconHand					put: 16r00000010;		at: #mbIconQuestion				put: 16r00000020;		at: #mbIconExclamation			put: 16r00000030;		at: #mbIconAsterisk				put: 16r00000040;		at: #mbUserIcon					put: 16r00000080;		at: #mbIconStop					put: 16r00000010;		at: #mbIconError					put: 16r00000010;		at: #mbIconWarning				put: 16r00000030;		at: #mbIconInformation			put: 16r00000040;		at: #mbDefButton1				put: 16r00000000;		at: #mbDefButton2				put: 16r00000100;		at: #mbDefButton3				put: 16r00000200;		at: #mbDefButton4				put: 16r00000300;		at: #mbApplModal				put: 16r00000000;		at: #mbSystemModal				put: 16r00001000;		at: #mbTaskModal				put: 16r00002000;	yourself).	Constants at: #MessageBoxAnswers put: #(ok cancel abort retry ignore yes no close help).</body><body>initializeShowWindowFlags	Constants at: #ShowWindow put: (IdentityDictionary new			at: #hide					put: 0;			at: #showNormal			put: 1;			at: #normal				put: 1;			at: #showMinimized		put: 2;			at: #showMaximized		put: 3;			at: #maximize			put: 3;			at: #showNoActive		put: 4;			at: #show				put: 5;			at: #minimize			put: 6;			at: #showMinNoActive		put: 7;			at: #showNa				put: 8;			at: #restore				put: 9;			at: #showDefault			put: 10;			at: #max					put: 10;		yourself)</body><body>installOn: platformArray	self OPENFILENAME typeDo: CStructureLayout dosLayout.	^super installOn: platformArray</body><body>obsolete	"This class is being removed from the system."	(ObjectMemory dependents includes: self) ifTrue: [ObjectMemory removeDependent: self ].	super obsolete</body><body>uninstall	self flushAllCaches</body></methods><methods><class-id>Aragon.Win32 class</class-id> <category>instance creation</category><body>instance	instance == nil ifTrue: [instance := self  new].	^instance</body></methods><methods><class-id>Aragon.Win32 class</class-id> <category>constants</category><body>fileBufferSize	^400</body><body>helpCommands	^Constants at: #HelpCommandCodes</body></methods><methods><class-id>Aragon.Win32 class</class-id> <category>uitilities</category><body>changeListGetIn	"Find out the file name of a file to write to using the Filename utility that	prompts for existing files."	| answer |	answer := self			openFilename: 'Changes.cha'			title: 'Name of file/directory to scan?'			filters: #(				'Changes File' '*.cha'				'Smalltalk File Out' '*.st' 				'All Files' '*.*'			)			for: Window currentWindow			flags: #(HIDEREADONLY NOCHANGEDIR FILEMUSTEXIST NOREADONLYRETURN).	^answer isNil ifTrue: [^''] ifFalse: [answer]</body><body>changeListGetOut: prompt	"Find out the file name of a file to write to using the Filename utility that	prompts for existing files."	| answer |	answer := self			saveFilename: 'Changes.cha'			title: prompt			filters: #(				'Changes File' '*.cha'				'Smalltalk File Out' '*.st' 				'All Files' '*.*'			)			for: Window currentWindow			flags: #(HIDEREADONLY NOREADONLYRETURN).	^answer isNil ifTrue: [^''] ifFalse: [answer]</body><body>chooseFontForCanvas	| selectionHolder controller widgets font controllerClass |	controllerClass := Smalltalk at: #UIPainterController ifAbsent: [^self].	selectionHolder := controllerClass lastControllerWithSelectionChannel.	((controller := selectionHolder value) isNil or: [(widgets := controller selections) isNil or: [widgets isEmpty]])		ifTrue: [^self].	(widgets size == 1 and: [widgets first spec respondsTo: #style]) ifTrue: [font := FontDescription new: widgets first spec style].	font := self chooseFont: font for: Window currentWindow.	font isNil ifTrue: [^self].	font := font key asFont encoded.	controller selectionList: (widgets			collect: 				[:each | 				(each spec respondsTo: #style:) ifTrue: [each spec style: font].				controller replaceElement: each basedOnSpec: each spec])</body><body>getImagePrefix: default 	"Prompt the user for a snapshot file name. Persist until a legal name is supplied."	| answer |	answer := self				saveFilename: ((default notNil and: [default isEmpty not and: [default asFilename isRelative]])						ifTrue: [Filename defaultDirectory construct: default] 						ifFalse: [default])				title: 'Save Image As'				filters: #('Smalltalk Images' '*.im')				for: Window currentWindow				flags: #(#HIDEREADONLY #NOREADONLYRETURN).	answer isNil ifTrue: [^''].	answer isEmpty ifTrue: [^''].	('*.im' match: answer)		ifTrue: [answer := answer copyFrom: 1 to: answer size - 3].	(default notNil and: [default isEmpty not and: [default asFilename isRelative]])		ifTrue: 			[| s | s := Filename defaultDirectoryName, '*'.			(s match: answer) ifTrue: [answer := answer copyFrom: s size + 1 to: answer size]].	^answer</body></methods><methods><class-id>Aragon.Win32 class</class-id> <category>private</category><body>customColors	CustomColors isNil		ifTrue: 			[CustomColors := self COLORREF malloc: 16.			0 to: 15 do: [:i | CustomColors at: i put: 0]].	^CustomColors</body><body>defaultFontDescription	^FontDescription new family: ''; pixelSize: 20</body><body>doesNotUnderstand: aMessage 	^self instance perform: aMessage selector withArguments: aMessage arguments</body><body>releaseCustomColors	CustomColors notNil ifTrue: [CustomColors free. CustomColors := nil].</body></methods><methods><class-id>Aragon.DDEServer4WindowsExplorer</class-id> <category>transactions</category><body>accessDataFrom: hCommand	^(self DdeAccessData: hCommand with: nil) copyCStringFromHeap</body><body>ddeConnect: hszTopic service: hszService context: dwContext serverAppInstance: dwServerAppInstance	^1</body><body>ddeExecute: hConversation topic: hszTopic command: hCommand 	| command |	(command := self accessDataFrom: hCommand) == nil		ifFalse: 			[| index |			Transcript show: 'DDE Execute: ['; show: command; show: ']'; cr.			index := command indexOf: Character space.			self perform: (command copyFrom: 1 to: index - 1) asSymbol with: (command copyFrom: index + 1 to: command size).			^self DDE_FACK].	^self DDE_FNOTPROCESSED</body></methods><methods><class-id>Aragon.DDEServer4WindowsExplorer</class-id> <category>commands</category><body>fileIn: aString	aString asFilename fileIn.</body><body>openInChangeList: aString	ChangeList openOnFileNamed: aString.</body><body>openInWorkspace: aString	(Aragon at: #TextEditor ifAbsent: [FileBrowser]) openOnFileNamed: aString.</body><body>parcelIn: aString	Parcel loadParcelFrom: aString.</body></methods><methods><class-id>Aragon.DDEServer4WindowsExplorer class</class-id> <category>class initialization</category><body>flushAllCaches	soleInstance := nil.	^super flushAllCaches</body><body>initialize	(ObjectMemory dependents includes: self) ifFalse: [ObjectMemory addDependent: self].	soleInstance := self new.</body><body>obsolete	ObjectMemory removeDependent: self.	super obsolete</body><body>uninstall	ObjectMemory removeDependent: self.	self flushAllCaches</body><body>update: anAspect with: arguments from: anObject 	"Check for return from snapshot to install."	(anObject == ObjectMemory and: [anAspect == #returnFromSnapshot])		ifTrue: 			[Transcript crtab; show: 'Starting DDE Server...'; cr; cr.			soleInstance := self new]</body></methods><methods><class-id>Aragon.DDEServer4WindowsExplorer class</class-id> <category>class accessing</category><body>instance	^soleInstance</body><body>serviceName	^'VisualWorks'</body></methods><methods><class-id>Aragon.WinHelp</class-id> <category>initialize-release</category><body>handle: aValue	handle := aValue</body><body>helpFile: aValue	helpFile := aValue asString</body><body>window: aWindow	handle := aWindow windowHandle</body></methods><methods><class-id>Aragon.WinHelp</class-id> <category>accessing</category><body>handle	^handle</body><body>helpFile	^helpFile</body></methods><methods><class-id>Aragon.WinHelp</class-id> <category>api</category><body>close		^self invoke: #HELP_QUIT</body><body>contents		^self invoke: #HELP_CONTENTS</body><body>context: anInteger		^self invoke: #HELP_CONTEXT withId: anInteger</body><body>contextPopup: anInteger		^self invoke: #HELP_CONTEXTPOPUP withId: anInteger</body><body>helpOnHelp		^self invoke: #HELP_HELPONHELP</body><body>index		^self invoke: #HELP_INDEX</body><body>key: aString		^self invoke: #HELP_KEY with: aString</body><body>search		^self invoke: #HELP_FINDER</body><body>setContents: anInteger		^self invoke: #HELP_SETCONTENTS withId: anInteger</body><body>setIndex: anInteger		^self invoke: #HELP_SETINDEX withId: anInteger</body><body>startUp	^self invoke: #HELP_CONTENTS</body></methods><methods><class-id>Aragon.WinHelp</class-id> <category>private</category><body>invoke: aSymbol 	^self invoke: aSymbol withId: 0</body><body>invoke: aSymbol with: aParameter	| buffer answer |	buffer := aParameter copyToHeap.	answer := Win32 instance		WinHelp: handle		with: helpFile		with: (Win32 helpCommands at: aSymbol)		with: buffer referentAddress.	buffer free.	^answer</body><body>invoke: aSymbol withId: anInteger	^Win32 instance		WinHelp: handle		with: helpFile		with: (Win32 helpCommands at: aSymbol)		with: anInteger.</body></methods><methods><class-id>Aragon.WinHelp class</class-id> <category>instance creation</category><body>for: aFilename	^self for: aFilename window: Window currentWindow</body><body>for: aFilename window: aWindow	^self new window: aWindow; helpFile: aFilename</body></methods><methods><class-id>Aragon.Win32Process</class-id> <category>initialize-release</category><body>finalize	self releaseHandle</body><body>releaseHandle	(handle isNil or: [handle == 0])		ifFalse: 			[Win32 CloseHandle: handle.			handle := nil]</body></methods><methods><class-id>Aragon.Win32Process</class-id> <category>accessing</category><body>handle	^handle</body><body>handle: aValue	(handle := aValue) notNil ifTrue: [self register]</body><body>id	^id</body><body>id: aValue	id := aValue</body></methods><methods><class-id>Aragon.Win32Process</class-id> <category>api</category><body>exitCode	| buffer answer |	handle isNil ifTrue: [^nil].	buffer := CIntegerType unsignedLong malloc.	(Win32 GetExitCodeProcess: handle with: buffer) == 0		ifTrue: [answer := nil]		ifFalse: [answer := buffer contents].	buffer free.	^answer</body><body>hasFinished	^handle isNil or: 		[| exitCode |		(exitCode := self exitCode) notNil and: [exitCode ~= 259]]</body><body>terminate	self terminateWith: 0</body><body>terminateWith: exitCode	Win32 TerminateProcess: handle with: exitCode.	self releaseHandle.</body><body>wait	^self waitWithTimeout: 16rffffffff.</body><body>waitWithTimeout: milliSeconds 	handle isNil		ifFalse: 			[| returnValue |			returnValue := Win32 WaitForSingleObject: handle withTimeout: milliSeconds.			returnValue == 4294967295 | returnValue == -1 ifTrue: [^#failed].			returnValue == 258 ifTrue: [^#timedOut].			returnValue == 0 ifTrue: [^#terminated].			returnValue == 128 ifTrue: [^#abandoned]].	^nil</body></methods><methods><class-id>Aragon.Win32Process</class-id> <category>private</category><body>key	^handle</body><body>register	Registry add: self key -&gt; self</body><body>unregister	Registry removeKey: self key ifAbsent: []</body></methods><methods><class-id>Aragon.Win32Process class</class-id> <category>class initialization</category><body>initialize	Registry := WeakDictionary new.</body></methods><methods><class-id>Aragon.Win32Filename</class-id> <category>accessing</category><body>accessed	^accessed</body><body>accessed: aValue	accessed := aValue</body><body>attributes	^attributes</body><body>attributes: aValue	attributes := aValue</body><body>created	^created</body><body>created: aValue	created := aValue</body><body>extension	| s i |	s := self name.	i := s lastIndexOf: $..	^i &gt; 0 ifTrue: [(s copyFrom: i+1 to: s size) asUppercase] ifFalse: ['']</body><body>fileSize	^fileSize</body><body>fileSize: aValue	fileSize := aValue</body><body>modified	^modified</body><body>modified: aValue	modified := aValue</body><body>name	^name</body><body>name: aValue	name := aValue</body></methods><methods><class-id>Aragon.Win32Filename</class-id> <category>testing</category><body>= anotherFilename 	^((anotherFilename isKindOf: self species)		or: [anotherFilename isKindOf: Filename])		and: [self asString = anotherFilename asString]</body><body>isDirectory	^(attributes bitAnd: 16r10) &gt; 0</body><body>isHidden	^(attributes bitAnd: 16r2) &gt; 0</body><body>isReadable	^true</body><body>isReadOnly	^(attributes bitAnd: 16r1) &gt; 0</body><body>isSystem	^(attributes bitAnd: 16r4) &gt; 0</body><body>isTemporary	^(attributes bitAnd: 2r100000000) &gt; 0</body><body>isWritable	^self isReadOnly not</body></methods><methods><class-id>Aragon.Win32Filename</class-id> <category>printing</category><body>displayString	^self name</body><body>printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self name printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Aragon.Win32Filename</class-id> <category>utility</category><body>attributesString	attributesString == nil		ifTrue: 			[attributesString := String new: 7.			attributesString at: 1 put: ((attributes bitAnd: 2r000000001) &gt; 0 ifTrue: [$r] ifFalse: [$-]).			attributesString at: 2 put: ((attributes bitAnd: 2r000000010) &gt; 0 ifTrue: [$h] ifFalse: [$-]).			attributesString at: 3 put: ((attributes bitAnd: 2r000000100) &gt; 0 ifTrue: [$s] ifFalse: [$-]).			attributesString at: 4 put: ((attributes bitAnd: 2r000010000) &gt; 0 ifTrue: [$d] ifFalse: [$-]).			attributesString at: 5 put: ((attributes bitAnd: 2r000100000) &gt; 0 ifTrue: [$a] ifFalse: [$-]).			attributesString at: 6 put: ((attributes bitAnd: 2r010000000) &gt; 0 ifTrue: [$n] ifFalse: [$-]).			attributesString at: 7 put: ((attributes bitAnd: 2r100000000) &gt; 0 ifTrue: [$t] ifFalse: [$-])].	^attributesString</body><body>construct: aString	^self asFilename construct: aString</body><body>directoryContents	^self directoryEntries collect: [:each | each asString]</body><body>directoryEntries	^Win32 findContentsOf: self</body><body>type	| answer |	answer := self isDirectory ifTrue: ['   /'] ifFalse: [self extension].	answer isEmpty ifTrue: [answer := '  ?'].	^answer</body></methods><methods><class-id>Aragon.Win32Filename</class-id> <category>converting</category><body>asFilename	^self name asFilename</body><body>asString	^self name</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>private</category><body>getWriteFileWithPrompt: promptString do: actionBlock 	"Find out the file name of a file to write to using the Filename utility that	prompts for existing files."	| fileName |	[fileName := (Dialog useWin32)					ifTrue: [(Aragon at: #Win32) changeListGetOut: promptString]					ifFalse: [Dialog						requestNewFileName: promptString						default: ParagraphEditor currentSelection].	fileName isEmpty or:		[(self includesFileName: fileName)			ifTrue:				[Dialog warn: fileName, ' cannot be used becauseit holds the source of some or all entries.Please try again.'.				false]			ifFalse: [true]]] whileFalse.	fileName isEmpty		ifFalse:			[Cursor wait showWhile:				[actionBlock value: ((fileName asFilename withEncoding: #Source) writeStream)]]</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>enhanced - Win32</category><body>getImagePrefix	"Prompt the user for a snapshot file name. Persist until a legal name is supplied."	| default prompt index |	prompt := 'Enter name for image file:'.	SourceFileManager default targetFile == nil		ifTrue: [default := ImagePrefix]		ifFalse: 			[default := SourceFileManager default targetFile name.			index := default findLast: [:ch | ch = $.].			default := index = 0						ifTrue: [default]						ifFalse: [default copyFrom: 1 to: index - 1]].	ImagePrefix := default.	^Dialog useWin32		ifTrue: [(Aragon at: #Win32) getImagePrefix: default]		ifFalse: [Dialog request: prompt initialAnswer: default].</body></methods><methods><class-id>UI.Dialog class</class-id> <category>enhanced - Win32</category><body>useWin32	^(Aragon includesKey: #Win32)		and: [OSHandle currentOS == #win32 		and: [InputState default shiftDown not]]</body><body>requestWithWin32: someMessage initialAnswer: aString for: aVisualOrNil	| messageString |	messageString := someMessage asString.	^(self useWin32 and: ['requestFilename*' match: thisContext sender selector])		ifTrue: 			[| win32 answer |			win32 := (Aragon at: #Win32) instance.			answer := (('*save*' match: messageString) or: ['*writ*' match: messageString])				ifTrue:	[win32 saveFilename: aString title: messageString for: aVisualOrNil]				ifFalse:	[win32 openFilename: aString title: messageString for: aVisualOrNil].			answer isNil ifTrue: [''] ifFalse: [answer]].</body><body>request: messageString initialAnswer: aString for: aVisualOrNil	"Create an instance of the receiver whose question is messageString. 	Display it centered around the cursor. Supply aString as an initial 	answer. Simply return whatever the user accepts."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow.  It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	"Dialog		request: 'What is your name?'		initialAnswer: 'Mr. T'		for: Dialog defaultParentWindow"	| answer |	(answer := self requestWithWin32: messageString initialAnswer: aString for: aVisualOrNil) notNil 		ifTrue: [^answer].	^self		request: messageString		initialAnswer: aString		onCancel: nil		windowLabel: nil		for: aVisualOrNil</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>fileIn/Out</category><body>scanFilename	"Prompt for the name of an existing file (or directory) to scan. If a 	directory name is supplied, scan all files inside the directory."	| fileName |	fileName := Dialog useWin32					ifTrue: [(Aragon at: #Win32) changeListGetIn]					ifFalse: [Dialog						requestFileName: 'Name of file/directory to scan?'						default: ParagraphEditor currentSelection						version: #mustBeOld].	fileName isEmpty ifTrue: [^self].	Cursor execute showWhile:		[self scanFilename: fileName asFilename]</body></methods><methods><class-id>Aragon.Win32</class-id> <category>procedures</category><body>ChooseColor: lpcc	&lt;C: short ChooseColorA (		CHOOSECOLOR*  lpcc 	// pointer to structure with initialization data	)&gt;	^self externalAccessFailed</body><body>ChooseFont: lpcf	&lt;C: short ChooseFontA (		CHOOSECOLOR*  lpcf 	// pointer to structure with initialization data	)&gt;	^self externalAccessFailed</body><body>CloseHandle: hObject	&lt;C: BOOL CloseHandle (		HANDLE hObject 	// handle to object to close  	)&gt;	^self externalAccessFailed</body><body>CommDlgExtendedError	&lt;C: DWORD CommDlgExtendedError (void)&gt;</body><body>CreateProcess: lpApplicationName with: lpCommandLine with: lpProcessAttributes with: lpThreadAttributes with: bInheritHandles with: dwCreationFlags with: lpEnvironment with: lpCurrentDirectory with: lpStartupInfo with: lpProcessInformation	&lt;C: BOOL CreateProcessA (		    LPCTSTR lpApplicationName,	// pointer to name of executable module 		    LPTSTR lpCommandLine,	// pointer to command line string		    SECURITY_ATTRIBUTES* lpProcessAttributes,	// pointer to process security attributes 		    SECURITY_ATTRIBUTES* lpThreadAttributes,	// pointer to thread security attributes 		    BOOL bInheritHandles,	// handle inheritance flag 		    DWORD dwCreationFlags,	// creation flags 		    LPVOID lpEnvironment,	// pointer to new environment block 		    LPCTSTR lpCurrentDirectory,	// pointer to current directory name 		    STARTUPINFO* lpStartupInfo,	// pointer to STARTUPINFO 		    PROCESS_INFORMATION* lpProcessInformation 	// pointer to PROCESS_INFORMATION  	)&gt;	^self externalAccessFailed</body><body>FindClose: hFindFile	&lt;C: BOOL FindClose (		    HANDLE  hFindFile 	// file search handle 	 )&gt;	^self externalAccessFailed</body><body>FindFirstFile: lpFileName with: lpFindFileData	&lt;C: long FindFirstFileA (	    LPCTSTR 				lpFileName,		// address of name of file to search for  	    WIN32_FIND_DATA* 	lpFindFileData 	// address of returned information 	)&gt;	^self externalAccessFailed</body><body>FindNextFile: hFindFile with: lpFindFileData	&lt;C: BOOL FindNextFileA (	    HANDLE 				hFindFile,		// handle of search  	    WIN32_FIND_DATA *	lpFindFileData 	// address of structure for data on found file	)&gt;</body><body>FindText: lpfr	&lt;C: HWND  FindTextA (		FINDREPLACE*  lpfr		// pointer to structure with initialization data	)&gt;	^self externalAccessFailed</body><body>FreeEnvironmentStrings: lpszEnvironmentBlock	&lt;C: BOOL FreeEnvironmentStringsA (char*  lpszEnvironmentBlock)&gt;	^self externalAccessFailed</body><body>GetCurrentDirectory: nBufferLength with: lpBuffer	&lt;C: DWORD GetCurrentDirectoryA (		DWORD		nBufferLength,	// size, in characters, of directory buffer 		LPTSTR		lpBuffer 	// address of buffer for current directory 	)&gt;</body><body>GetDiskFreeSpace: lpRootPathName with: lpSectorsPerCluster with: lpBytesPerSector with: lpNumberOfFreeClusters with: lpTotalNumberOfClusters	&lt;C: BOOL GetDiskFreeSpaceA(		    LPCTSTR lpRootPathName,	// address of root path 		    DWORD* lpSectorsPerCluster,	// address of sectors per cluster 		    DWORD* lpBytesPerSector,	// address of bytes per sector 		    DWORD* lpNumberOfFreeClusters,	// address of number of free clusters  		    DWORD* lpTotalNumberOfClusters 	// address of total number of clusters  	   )&gt;	^self externalAccessFailed</body><body>GetDiskFreeSpaceEx: lpDirectoryName with: lpFreeBytesAvailableToCaller with: lpTotalNumberOfBytes with: lpTotalNumberOfFreeBytes	&lt;C: BOOL GetDiskFreeSpaceExA (			LPCTSTR lpDirectoryName,	// address of root path 			ULARGE_INTEGER* lpFreeBytesAvailableToCaller,	// pointer to variable to receive free bytes on disk available to the caller			ULARGE_INTEGER* lpTotalNumberOfBytes,	// pointer to variable to receive number of bytes on disk			ULARGE_INTEGER* lpTotalNumberOfFreeBytes	// pointer to variable to receive free bytes on disk	   )&gt;	^self externalAccessFailed</body><body>GetEnvironmentStrings	&lt;C: unsigned char*  GetEnvironmentStrings (void)&gt;	^self externalAccessFailed</body><body>GetEnvironmentVariable: lpName with: lpBuffer with: nSize	&lt;C: unsigned long  GetEnvironmentVariableA (		    const char*	lpName,		// address of environment variable name 		    char*			lpBuffer,		// address of buffer for variable value 		    unsigned long  nSize 		// size of buffer, in characters 	 )&gt;</body><body>GetExitCodeProcess: hProcess with: lpExitCode	&lt;C: BOOL GetExitCodeProcess(		    HANDLE hProcess,	// handle to the process 		    DWORD* lpExitCode 	// address to receive termination status 	 )&gt;	^self externalAccessFailed</body><body>GetOpenFileName: lpofn	&lt;C: short GetOpenFileNameA (		OPENFILENAME*  lpofn 	// pointer to structure with initialization data	)&gt;	^self externalAccessFailed</body><body>GetSaveFileName: lpofn	&lt;C: short GetSaveFileNameA (		OPENFILENAME*  lpofn 	// pointer to structure with initialization data	)&gt;	^self externalAccessFailed</body><body>MessageBox: hWnd with: lpText with: lpCaption with: uType	&lt;C: int MessageBoxA	(		    unsigned long	hWnd,		// handle of owner window		    const char*	lpText,		// address of text in message box		    const char*	lpCaption,	// address of title of message box  		    unsigned 		uType 		// style of message box	)&gt;</body><body>ReplaceText: lpfr	&lt;C: HWND  ReplaceTextA (		FINDREPLACE*  lpfr		// pointer to structure with initialization data	)&gt;	^self externalAccessFailed</body><body>SetCurrentDirectory: lpPathName	&lt;C: BOOL SetCurrentDirectoryA (		LPCTSTR lpPathName 	// address of name of new current directory 	)&gt;</body><body>SetEnvironmentVariable: lpName with: lpValue	&lt;C: BOOL  SetEnvironmentVariableA (		    LPCTSTR	lpName,		// address of environment variable name 		    LPCTSTR  lpValue		//  address of new value for variable	 )&gt;</body><body>ShellExecute: hwnd with: lpOperation with: lpFile with: lpParameters with: lpDirectory with: nShowCmd	&lt;C: unsigned long  ShellExecuteA	(		unsigned long 	hwnd,			// handle to parent window		const char*		lpOperation,		// pointer to string that specifies operation to perform		const char*		lpFile,			// pointer to filename or folder name string		const char*		lpParameters,	// pointer to string that specifies executable-file parameters 		const char*		lpDirectory,		// pointer to string that specifies default directory		int				nShowCmd 		// whether file is shown when opened 	)&gt;</body><body>TerminateProcess: hProcess with: uExitCode	&lt;C: BOOL TerminateProcess (		    HANDLE hProcess,	// handle to the process 		    UINT uExitCode 	// exit code for the process  	 )&gt;	^self externalAccessFailed</body><body>WaitForSingleObject: hHandle withTimeout: dwMilliseconds	&lt;C: DWORD WaitForSingleObject(		HANDLE hHandle,	// handle of object to wait for 		DWORD dwMilliseconds 	// time-out interval in milliseconds  	)&gt;	^self externalAccessFailed</body><body>WinExec: lpModuleName with: lpCmdShow	&lt;C: int WinExec	(		    char*		lpModuleName,		    unsigned 	lpCmdShow	)&gt;</body><body>WinHelp: hWndMain with: lpszHelp with: uCommand with: dwData	&lt;C: BOOL WinHelpA(		    HWND		hWndMain,		// handle of window requesting Help 		    LPCTSTR		lpszHelp,		// address of directory-path string 		    UINT			uCommand,		// type of Help 		    DWORD		dwData			// additional data 	 )&gt;	^self externalAccessFailed</body></methods><initialize><class-id>Aragon.Win32</class-id></initialize><initialize><class-id>Aragon.DDEServer4WindowsExplorer</class-id></initialize><initialize><class-id>Aragon.Win32Process</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category></class><class><name>ChangeList</name><environment>Tools</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category></class><class><name>DdemlServer</name><environment>OS</environment><super>OS.DdemlPort</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceName </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.DdemlServerDictionary.*			</imports><category>OS-DDEML</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel></attributes></class></st-source>