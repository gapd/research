<?xml version="1.0"?><st-source><!-- Name: NetConfigToolNotice: Copyright © 1999, 2000, 2002, 2002, 2001 Cincom Systems, Inc.  All Rights Reserved.Comment: Contains pages for the Network Settings to store a few default values that are useful while working with NetClients.DbIdentifier: bear73DbTrace: 113659DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'Blowfish' '') #(#any 'Tools-Settings' ''))PackageName: NetConfigToolParcel: #('NetConfigTool')ParcelName: NetConfigToolPrerequisiteParcels: #(#('NetClientBase' '') #('Blowfish' '') #('Tools-Settings' ''))PrintStringCache: (751 20,tkogan)Version: 7.6Vesion: 7.0Date: 12:33:41 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 12:33:41 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NetRef</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.NetRef</class-id><body>NetRef is used to save/restore objects from the Net Settings</body></comment><class><name>DeliveryMonitor</name><environment>Net</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progress letter deliveryClient resultsQueue deliveryProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Mail</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.DeliveryMonitor</class-id><body>DeliveryMonitor creates separate process for the mail delivery and while sending messages shows the progressInstance Variables:	progress	&lt;ValueHolder&gt;	number of messages to deliver	letter	&lt;Letter&gt;	letter for delivery	deliveryClient	&lt;NetClient&gt;	 SMTP client	resultsQueue	&lt;SharedQueue&gt;	 delivery queue	deliveryProcess	&lt;Process&gt;	delivery processShared Variables:	CollapseOnDelivery	&lt;Boolean&gt;	indicates if the window should be collapsed on delivery	DeliveryPriority	&lt;Number&gt;	priority</body></comment><class><name>HttpProxyExceptions</name><environment>Net</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>httpProxyExceptions parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.HttpProxyExceptions</class-id><body>A HttpProxyException  provides an user-interface for editing a http proxy exceptions. Instance Variables:	httpProxyExceptions	&lt;String&gt;	proxy exceptions</body></comment><class><name>NetSettingsPage</name><environment>Net</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userPreferences userListOwner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.NetSettingsPage</class-id><body>A NetSettingsPage provides an user-interface for editing a Settings properties. Instance Variables:	identityListAspect	&lt;SelectionInList&gt;	identities list	serverListAspect	&lt;SelectionInList&gt;	mail server list	netUser	&lt;NetUser&gt;	selected instance of NetClient	hostSpec	&lt;HostSpec&gt;	selected instance of HostSpecShared Variables:	UserPreferences	&lt;Dictionary&gt;	The user preference profile is a Dictionary with of value models against subject keys</body></comment><class><name>AddNetUser</name><environment>Net</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.AddNetUser</class-id><body>A AddNetUser is an application model designed to add new user for UISettings. The only reason to have this class that TabbedDialog as supperclass for UISettings doesn't support two models.Instance Variables:	parent	&lt;UISettings&gt;	an instance of UISettings</body></comment><class><name>NetSettings</name><environment>Net</environment><super>Tools.GenericSettingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>passwordKey passwordEncoding </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.NetSettings</class-id><body>Settings is a central repository for various preference items related to Internet Connectivity clients. The Setting class is the model for application model UISettings.Instance Variables:Shared Variables:	Registry	&lt;IdentityDictionary&gt;	holds all settings</body></comment><class><name>HttpProxyPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>redirectRequest proxyExceptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.HttpProxyPage</class-id><body>HttpPage creates Http UI Settings pageInstance Variables:	proxyExceptions	&lt;Collection of Strings&gt;	do not use proxy servers for domains in the proxyExceptions list	redirectRequest	&lt;ValueModel of Boolean&gt;	describe wether or not redirect the request </body></comment><class><name>MailServerPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverListAspect hostSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.MailServerPage</class-id><body>MailPage creates the UI page for the mail server settingsInstance Variables:	hostSpec	&lt;HostSpec&gt;	name of the selected mail server	serverListAspect	&lt;SelectionInList&gt;	mail server list</body></comment><class><name>UserPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identityListAspect netUser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.UserPage</class-id><body>A UserPage provides an user-interface for editing a Settings properties. Instance Variables:	identityListAspect	&lt;SelectionInList&gt;	identities list	serverListAspect	&lt;SelectionInList&gt;	mail server list	netUser	&lt;NetUser&gt;	selected instance of NetClient	hostSpec	&lt;HostSpec&gt;	selected instance of HostSpecShared Variables:	UserPreferences	&lt;Dictionary&gt;	The user preference profile is a Dictionary with of value models against subject keys</body></comment><shared-variable><name>Registry</name><environment>Net.NetSettings</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>NetConfigTool</package></attributes></shared-variable><shared-variable><name>DeliveryPriority</name><environment>Net.DeliveryMonitor</environment><private>false</private><constant>false</constant><category>constants</category><initializer>30</initializer><attributes><package>NetConfigTool</package></attributes></shared-variable><shared-variable><name>CollapseOnDelivery</name><environment>Net.DeliveryMonitor</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>NetConfigTool</package></attributes></shared-variable><methods><class-id>Net.NetRef class</class-id> <category>persistence</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^NetSettings restoreRefFrom: anXMLElement</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>initialize-release</category><body package="NetConfigTool" selector="letterForDelivery:deliveryClient:">letterForDelivery: let deliveryClient: mailClient 	self		letterForDelivery: let		deliveryClient: mailClient		resultsTo: nil</body><body package="NetConfigTool" selector="letterForDelivery:deliveryClient:resultsTo:">letterForDelivery: let deliveryClient: mailClient resultsTo: sharedQueueOrNil	letter := let.	deliveryClient := mailClient.	resultsQueue := sharedQueueOrNil</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>actions</category><body package="NetConfigTool" selector="deliver">deliver	| estimatedSize increment window | 	estimatedSize := 1 max: letter size.	increment := 1.0 / estimatedSize.	self allButOpenInterface: #windowSpec.	window := self builder window.	window		openAroundCursorWithExtent: builder window minimumSize		andType: #normal.	self setWindowLabel.	CollapseOnDelivery ifTrue: [window collapse].	deliveryProcess := 		[[deliveryClient sendLetter: letter.		  [self closeRequest] uiEventFor: window.		  self noteSuccess]			on: MailIncrementNotification			do: 				[:not | 				[ [self progress value: progress value + (not ticks * increment)] uiEventFor: window] fork.				not resume]] forkAt: DeliveryPriority</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>private</category><body package="NetConfigTool" selector="noteFailure">noteFailure	resultsQueue isNil ifTrue: [^self].	resultsQueue nextPut: false</body><body package="NetConfigTool" selector="noteSuccess">noteSuccess	resultsQueue isNil ifTrue: [^self].	resultsQueue nextPut: true</body><body package="NetConfigTool" selector="sendLetter">sendLetter	[deliveryClient sendLetter: letter]		on: OsInaccessibleError		do: [:ex | 			#{LetterWriter}				ifDefinedDo: [:letterWriter| letterWriter delayDeliveryOf: letter]				elseDo: [ex pass]]</body><body package="NetConfigTool" selector="setWindowLabel">setWindowLabel	self builder window label: ((#DeliveringMailFor1s &lt;&lt; #net &gt;&gt; 'Delivering mail for &lt;1s&gt;') expandMacrosWith: (letter subject ))</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>aspects</category><body package="NetConfigTool" selector="progress">progress	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^progress isNil		ifTrue:			[progress := 0.0 asValue]		ifFalse:			[progress]</body></methods><methods><class-id>Net.DeliveryMonitor class</class-id> <category>instance creation</category><body package="NetConfigTool" selector="deliver:using:">deliver: letterForDelivery using: deliveryClient 	| app |	app := self new.	app letterForDelivery: letterForDelivery deliveryClient: deliveryClient.	^app</body><body package="NetConfigTool" selector="deliver:using:resultsTo:">deliver: letterForDelivery using: deliveryClient resultsTo: sharedQueueOrNil	| app |	app := self new.	app letterForDelivery: letterForDelivery deliveryClient: deliveryClient resultsTo: sharedQueueOrNil.	^app</body></methods><methods><class-id>Net.HttpProxyExceptions</class-id> <category>aspects</category><body package="NetConfigTool" selector="domainCollectionAsString">domainCollectionAsString	| aStream col |	col :=  parent proxyExceptions.	^col isEmpty		ifTrue: [String new]		ifFalse: 			[aStream := (String new: 64) writeStream.			col				do: [:element | aStream nextPutAll: element]				separatedBy: [aStream nextPut: $;].			aStream contents]</body><body package="NetConfigTool" selector="httpProxyExceptions">httpProxyExceptions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^httpProxyExceptions isNil		ifTrue:			[httpProxyExceptions := self domainCollectionAsString asValue]		ifFalse:			[httpProxyExceptions]</body><body package="NetConfigTool" selector="parent:">parent: aHttpPage	parent := aHttpPage</body></methods><methods><class-id>Net.HttpProxyExceptions</class-id> <category>actions</category><body package="NetConfigTool" selector="acceptHttpExceptions">acceptHttpExceptions	| proxyExceptions sc token |	proxyExceptions := OrderedCollection new: 10. 	sc := self httpProxyExceptions value string readStream.	[ sc atEnd ]		whileFalse: 			[token := sc upTo: $;. 			token notEmpty ifTrue: [ proxyExceptions add: token trimBlanks]].	parent acceptProxyExceptions: proxyExceptions.	self cancelHttpException.</body><body package="NetConfigTool" selector="cancelHttpException">cancelHttpException	^self closeRequest</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>accessing settings</category><body package="NetConfigTool" selector="registry">registry	^self class registry</body><body package="NetConfigTool" selector="resetUserPreferences">resetUserPreferences	userPreferences := Dictionary new.	^userPreferences</body><body package="NetConfigTool" selector="userPreferences">userPreferences	^userPreferences isNil 		ifTrue: [ self resetUserPreferences]		ifFalse: [ userPreferences ]</body><body package="NetConfigTool" selector="userPreferencesAt:">userPreferencesAt: aSymbol	^self  userPreferences at: aSymbol</body><body package="NetConfigTool" selector="userPreferencesAt:ifAbsentPut:">userPreferencesAt: aSymbol ifAbsentPut: aBlock	^self userPreferences at: aSymbol ifAbsentPut: aBlock</body><body package="NetConfigTool" selector="userPreferencesAt:put:">userPreferencesAt: aSymbol put: anObject	self userPreferences at: aSymbol put: anObject</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>accessing</category><body package="NetConfigTool" selector="settings">settings	^Array with: Net.NetSettings new</body><body package="NetConfigTool" selector="userListOwner">userListOwner	^userListOwner</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>notifications</category><body package="NetConfigTool" selector="triggered">triggered	manager triggerChannel value 		ifTrue: [self accept]		ifFalse: [ self reset ]</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>actions</category><body package="NetConfigTool" selector="accept">accept</body><body package="NetConfigTool" selector="importSnapshots:">importSnapshots: aCollection	NetSettings importSnapshots: aCollection first stateNodes.	self reset</body><body package="NetConfigTool" selector="reset">reset</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>initialize-release</category><body package="NetConfigTool" selector="manager:">manager: aSettingsManager	super manager: aSettingsManager.	userListOwner := manager pageWithId: #(net userIdentities).	manager triggerChannel onChangeSend: #triggered to: self</body></methods><methods><class-id>Net.NetSettingsPage class</class-id> <category>accessing settings</category><body package="NetConfigTool" selector="registry">registry	^Settings</body></methods><methods><class-id>Net.NetSettingsPage class</class-id> <category>class initialization</category><body package="NetConfigTool" selector="initialize">initialize	"UISettings initialize "	( NetSettings dependents includes: self )		ifFalse:	[ NetSettings addDependent: self ].</body><body package="NetConfigTool" selector="obsolete">obsolete	"Break dependencies"	[NetSettings dependents includes: self] whileTrue:		[NetSettings removeDependent: self].	^super obsolete</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>accessing</category><body package="NetConfigTool" selector="parent">parent	^parent isNil 		ifTrue: [ parent := UserPage new ]		ifFalse: [ parent ]</body><body package="NetConfigTool" selector="parent:">parent: aUISettings	parent := aUISettings</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>accessing settings</category><body package="NetConfigTool" selector="userNet">userNet	^self parent userNet</body><body package="NetConfigTool" selector="userPreferencesAt:">userPreferencesAt: aSymbol	^self  parent userPreferencesAt: aSymbol</body><body package="NetConfigTool" selector="userPreferencesAt:ifAbsentPut:">userPreferencesAt: aSymbol ifAbsentPut: aBlock	^self parent userPreferencesAt: aSymbol ifAbsentPut: aBlock</body><body package="NetConfigTool" selector="userPreferencesAt:put:">userPreferencesAt: aSymbol put: anObject	self parent userPreferencesAt: aSymbol put: anObject</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>aspects</category><body package="NetConfigTool" selector="accountIdentity">accountIdentity 	^self userPreferencesAt: #accountIdentity  		ifAbsentPut: 			[ (self parent netUser isNil				ifTrue: [ '' ]				ifFalse: [ self parent netUser account  ]) asValue ]</body><body package="NetConfigTool" selector="emailAddressIdentity">emailAddressIdentity  	^self userPreferencesAt: #emailAddressIdentity  		ifAbsentPut: 			[ (self parent netUser isNil				ifTrue: [ '' ]				ifFalse: [ self parent netUser mailAddress ] ) asValue]</body><body package="NetConfigTool" selector="fullNameIdentity">fullNameIdentity  	^self userPreferencesAt: #fullNameIdentity  			ifAbsentPut: 				[ (self parent netUser isNil					ifTrue: [ '' ]					ifFalse: [ self parent netUser fullName ]) asValue]</body><body package="NetConfigTool" selector="passwordIdentity">passwordIdentity  	^self userPreferencesAt: #passwordIdentity  			ifAbsentPut: 				[ (self parent netUser isNil					ifTrue: [ '' ]					ifFalse: [ self parent netUser password ]) asValue]</body><body package="NetConfigTool" selector="rememberPassword">rememberPassword	^self userPreferencesAt: #rememberPassword  			ifAbsentPut: 				[ | pass | 					pass := self parent netUser notNil							ifTrue: [ self parent netUser savePassword].					(pass isNil 						ifTrue: [false]						ifFalse: [ pass ]) asValue]</body><body package="NetConfigTool" selector="userNameIdentity">userNameIdentity 	^self userPreferencesAt: #userNameIdentity 			ifAbsentPut: 				[ (self parent netUser isNil					ifTrue: [ '']					ifFalse: [ self parent netUser username ]) asValue]</body><body package="NetConfigTool" selector="verifyPasswordIdentity">verifyPasswordIdentity	^self userPreferencesAt: #verifyPasswordIdentity  ifAbsentPut: [ nil asValue ].</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>actions</category><body package="NetConfigTool" selector="okToAddIdentity">okToAddIdentity	self rememberPassword value		ifTrue: 			[ (self passwordIdentity value = self verifyPasswordIdentity value)				ifFalse: 					[ self passwordIdentity value: ''.					self verifyPasswordIdentity value: ''. 					^Dialog warn: (#NewPasswordWasNotCorrectlyConfirmed &lt;&lt; #net &gt;&gt; 'The new password was not correctly confirmed')]].	((self fullNameIdentity value isNil or: [self fullNameIdentity value isEmpty])		or: [ self userNameIdentity value isNil or: [self userNameIdentity value isEmpty]])			ifTrue: [ ^Dialog warn: (#UserNameIsEmpty &lt;&lt; #net &gt;&gt; 'User name is empty') ].	self parent updateNetUser.	self accept value: true</body></methods><methods><class-id>Net.AddNetUser class</class-id> <category>instance creation</category><body package="NetConfigTool" selector="openWithSpec:parent:">openWithSpec: aSpec parent: uiSettings	^self openOn: (self new parent: uiSettings)		 withSpec: aSpec.</body></methods><methods><class-id>Net.NetSettings</class-id> <category>persistence</category><body package="NetConfigTool" selector="addStateXmlElementsTo:">addStateXmlElementsTo: rootElement	self class addStateXmlElementsTo: rootElement</body><body package="NetConfigTool" selector="restoreFrom:">restoreFrom: aSettingSnapshot	self class importSnapshots: aSettingSnapshot stateNodes</body></methods><methods><class-id>Net.NetSettings</class-id> <category>initialize-release</category><body package="NetConfigTool" selector="initialize">initialize	super initialize.	id := #( net )</body></methods><methods><class-id>Net.NetSettings class</class-id> <category>accessing settings</category><body package="NetConfigTool" selector="passwordEncodingForPersistence">passwordEncodingForPersistence	^passwordEncoding  ifNil: [ Locale current defaultEncoding ]</body><body package="NetConfigTool" selector="passwordEncodingForPersistence:">passwordEncodingForPersistence: aSymbol	passwordEncoding := aSymbol</body><body package="NetConfigTool" selector="registry">registry	^Settings registry</body></methods><methods><class-id>Net.NetSettings class</class-id> <category>private</category><body package="NetConfigTool" selector="collection:asXmlNode:">collection: aCollection asXmlNode: aString	| node |	node := self nodeForClass: 'OrderedCollection' tag: aString.	aCollection do: [ :each | node addNode: (each asXmlNode: 'item' ) ].	^node</body><body package="NetConfigTool" selector="createNetRefFor:tag:">createNetRefFor: aNetClient tag: aString	| node attr |	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	attr 	add: ( XML.Attribute name: 'fullName' value: aNetClient fullName ).	^node</body><body package="NetConfigTool" selector="createNetRefServerFor:tag:">createNetRefServerFor: aHostSpec tag: aString	| node attr |	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	attr 	add: ( XML.Attribute name: 'name' value: aHostSpec name ).	^node</body><body package="NetConfigTool" selector="createPasswordNode:tag:">createPasswordNode: passString tag: aString	| pass node attr cipher bf output stream |	cipher := Security.Blowfish key: self passwordKey.	bf := Security.BlockPadding on: cipher.	pass := bf encrypt: 				(ByteArray 					fromString: passString 					encoding: self passwordEncodingForPersistence).	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: Base64StreamEncoder asEncoder.	stream nextPutAll: (pass asStringEncoding: #'iso-8859-1').	stream close.	attr 	add: ( XML.Attribute name: 'password' value: stream encodedContents asString  ).	^node</body><body package="NetConfigTool" selector="dictionary:asXmlNode:">dictionary: aDict asXmlNode: aString	| node entry |	node := self nodeForClass: 'Dictionary' tag: aString.	aDict 		keysAndValuesDo: 			[ :key :value | 			entry := XML.Element tag: 'entry'.			node addNode: entry.			entry addNode: ( key asXmlNode: 'key' ).			entry addNode: ( value asXmlNode: 'value' ) ].		^node</body><body package="NetConfigTool" selector="netObject:asXmlNode:">netObject: aClass asXmlNode: aString 	| value root node |	aString = #defaultIdentity		ifTrue: [  ^self createNetRefFor: aClass  tag: aString ].	(aString = #defaultIncomingServer or: [ aString = #defaultOutgoingServer ])		ifTrue: [  ^self createNetRefServerFor: aClass  tag: aString ].	root := self nodeForClass: aClass class fullName tag: aString.	aClass class instVarNames do: 			[:ins | 			(value := aClass instVarAt: (aClass class instVarIndexFor: ins)) notNil 				ifTrue: 					[ node := value class name = #NetUser 						ifTrue: [ self createNetRefFor: value tag: ins ]						ifFalse: 							[ ins = 'password'								ifTrue: [ self createPasswordNode: value tag: ins ]								ifFalse: [ value asXmlNode: ins]].					root addNode: node]].	^root</body><body package="NetConfigTool" selector="nodeForClass:tag:">nodeForClass: aClassName tag: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: aClassName )).	^node</body><body package="NetConfigTool" selector="object:asXmlNode:">object: anObject asXmlNode: aString	| node |	node := self nodeForClass: anObject class fullName tag: aString.	node addNode: (XML.Text text: anObject printString ).	^node</body><body package="NetConfigTool" selector="restoreClassFrom:">restoreClassFrom: anXMLElement	^(anXMLElement valueOfAttribute: 'smalltalkClass' ifAbsent: [^nil])		asSymbol asQualifiedReference value.</body><body package="NetConfigTool" selector="restoreNetObject:from:">restoreNetObject: anObject from:  anXMLElement	| val xmlColl |	xmlColl := anXMLElement realElements.	xmlColl do: 			[ :el |  			val := el restoreValue.			anObject perform: (el tag type, ':') asSymbol  with: val].	^anObject</body><body package="NetConfigTool" selector="restorePassword:">restorePassword: decString 	| cipher bf stream output char input bArr |	input := decString asByteArray readStream.	stream := EncodedStream on: input encodedBy: Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	bArr := ByteArray fromString: output contents asString encoding: #'iso-8859-1'.	cipher := Security.Blowfish key: self passwordKey.	bf := Security.BlockPadding on: cipher.	^( bf decrypt: bArr) asStringEncoding: self passwordEncodingForPersistence.</body><body package="NetConfigTool" selector="restoreRefFrom:">restoreRefFrom:  anXMLElement	| tag val |	tag := anXMLElement tag type asSymbol.	tag = #password		ifTrue: 			[val := anXMLElement valueOfAttribute: 'password' ifAbsent: [ nil].			 ^(self restorePassword: val) asString ].	(tag = #defaultIdentity or: [ tag = #netUser ])		ifTrue: 			[  val := anXMLElement valueOfAttribute: 'fullName' ifAbsent: [ nil].			^Settings detectIdentityByName: val ].	(tag = #defaultIncomingServer or: [ tag = #defaultOutgoingServer ])		ifTrue: 			[ val := anXMLElement valueOfAttribute: 'name' ifAbsent: [ nil].			^Settings detectMailHostByName: val ].</body><body package="NetConfigTool" selector="string:asXmlNode:">string: valString asXmlNode: aString	| node |	node := self nodeForClass: 'String' tag: aString.	node addNode: (XML.Text text: valString ).	^node</body></methods><methods><class-id>Net.NetSettings class</class-id> <category>password key</category><body package="NetConfigTool" selector="defaultKey">defaultKey	^#[16r2b 16r7e 16r15 16r16 16r28 16rae 16rd2 16ra6 16rab 16rf7 16r15 16r88 16r09 16rcf 16r4f 16r3c].</body><body package="NetConfigTool" selector="passwordKey">passwordKey	^passwordKey isNil		ifTrue: [ self defaultKey ]		ifFalse: [ passwordKey ]</body><body package="NetConfigTool" selector="passwordKey:">passwordKey: aByteArray	passwordKey := aByteArray</body></methods><methods><class-id>Net.NetSettings class</class-id> <category>persistence</category><body package="NetConfigTool" selector="addStateXmlElementsTo:">addStateXmlElementsTo: rootElement	| coll  | 	(coll := self registry at: #identities ifAbsent: [ nil]) notNil		ifTrue:  [ rootElement addNode: ( coll asXmlNode: #identities)].	(coll := self registry at: #mailServers ifAbsent: [ nil]) notNil		ifTrue:  [ rootElement addNode: ( coll asXmlNode: #mailServers)].	self registry keysAndValuesDo:		[ :key :value | 		(key ~= #identities and: [ key ~= #mailServers])			ifTrue: [	rootElement addNode: ( value asXmlNode: key) ]].</body><body package="NetConfigTool" selector="importSnapshots:">importSnapshots: aCollectionElements	aCollectionElements do:		[ :el | self restoreSettingFrom: el ]</body><body package="NetConfigTool" selector="restoreSettingFrom:">restoreSettingFrom: anXMLElement	| key coll |	key := anXMLElement tag type  asSymbol.	key = #identities		ifTrue: 			[coll := self restoreValueFrom: anXMLElement. 			^coll do: [ :each | Settings addIdentity:  each] ].	key = #mailServers		ifTrue: 			[coll := self restoreValueFrom: anXMLElement.			 ^coll do: [ :each | Settings updateMailHost:  each] ].	self registry 		at: key		put: (self restoreValueFrom: anXMLElement)</body><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^(self restoreClassFrom:  anXMLElement ) 			restoreValueFrom: anXMLElement</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>actions</category><body package="NetConfigTool" selector="accept">accept	(self httpUseProxy value		and: [self httpHost value isEmpty])			 ifTrue: [ ^Dialog warn: (#ProxyHostIsEmpty &lt;&lt; #net &gt;&gt; 'Proxy host is empty!')].	self registry httpUseProxy: self httpUseProxy value.	(self httpUseProxy value 		and: [self httpHost value notNil and: [ self httpHost value notEmpty ]])		ifTrue: 			[ self registry httpProxyHost: 					(HostSpec new							name: self httpHost value;							port:  self httpPort value;							type: 'http';							netUser: self proxyUserMenuAspect value;							yourself) ].	self registry httpProxyExceptions:  self proxyExceptions.</body><body package="NetConfigTool" selector="acceptProxyExceptions:">acceptProxyExceptions: aCollection	proxyExceptions := aCollection.	manager tickle</body><body package="NetConfigTool" selector="addIdentity">addIdentity	self userListOwner addIdentity</body><body package="NetConfigTool" selector="httpAdvanced">httpAdvanced	( HttpProxyExceptions new parent: self; yourself ) open</body><body package="NetConfigTool" selector="importSnapshots:">importSnapshots: aCollection	super importSnapshots: aCollection.	self userListOwner reset</body><body package="NetConfigTool" selector="reset">reset	self httpUseProxy value: self registry httpUseProxy.	self resetProxyAspects.</body><body package="NetConfigTool" selector="resetProxyAspects">resetProxyAspects	self httpHost value: self defaultProxyHost.	self proxyUserMenuAspect value: self defaultProxyUserMenuAspect.	self httpPort value: self defaultPort.</body><body package="NetConfigTool" selector="resetUIStateToDefault">resetUIStateToDefault	self httpUseProxy value: self registry httpUseProxyDefault.	self resetProxyAspects.</body><body package="NetConfigTool" selector="useProxyChanged">useProxyChanged	| aBoolean | 	aBoolean := self httpUseProxy value. 	#(proxyAddress proxyPort addIdentityButton advancedButton proxyUserMenuAspect addressLabel portLabel  proxyUserLabel )		do: [ :each | (self widgetAt: each ) isEnabled: aBoolean ].</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>accessing</category><body package="NetConfigTool" selector="helpText">helpText	^(#HttpProxySettingsHelp &lt;&lt; #net &gt;&gt; 'HTTP Settings allow specifying proxy server settings on a per-user basis.  Proxies are used in some situations to access the web through a firewall, or for improved web access. - Use proxy must be checked to use the proxy information - Address: is the host IP or name of the proxy server - Port: is the port number for the proxy server - Proxy User: is an user ID authorized to access the proxyProxy user must be defined as a user (see User Identities ) and then selected from the drop-down list. To define a new user, click Add User... .  Complete the form as described in help for the User Identities page.') asString</body><body package="NetConfigTool" selector="httpHost">httpHost	^self 		userPreferencesAt: #httpHost		ifAbsentPut: [ self defaultProxyHost asValue]</body><body package="NetConfigTool" selector="httpPort">httpPort	^self 		userPreferencesAt: #httpPort		ifAbsentPut: 			[ self defaultPort asValue]</body><body package="NetConfigTool" selector="httpUseProxy">httpUseProxy 	^self 		userPreferencesAt: #httpUseProxy  		ifAbsentPut: [ self registry httpUseProxy  asValue ]</body><body package="NetConfigTool" selector="netUserMenu">netUserMenu 	^self userListOwner netUserMenu</body><body package="NetConfigTool" selector="proxyExceptions">proxyExceptions	proxyExceptions isNil		ifTrue: [ proxyExceptions := self registry httpProxyExceptions].	 ^proxyExceptions</body><body package="NetConfigTool" selector="proxyUserMenuAspect">proxyUserMenuAspect	^self 		userPreferences at: #proxyUserMenuAspect		ifAbsentPut: [ self defaultProxyUserMenuAspect asValue]</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>defaults</category><body package="NetConfigTool" selector="defaultHttpUserMenuAspect">defaultHttpUserMenuAspect	| ids | 	^(ids := self netUserMenu value menuItems) notEmpty		ifTrue: [ ids first value asValue]		ifFalse: [ nil asValue ]</body><body package="NetConfigTool" selector="defaultPort">defaultPort	^self registry httpProxyHost notNil				ifTrue: [ self registry httpProxyHost port]				ifFalse: [80]</body><body package="NetConfigTool" selector="defaultProxyHost">defaultProxyHost	^self registry httpProxyHost notNil			ifTrue: [ self registry httpProxyHost name]			ifFalse: ['' ]</body><body package="NetConfigTool" selector="defaultProxyUserMenuAspect">defaultProxyUserMenuAspect	| uh usr |	uh := self registry httpProxyHost notNil		ifTrue: 			[( usr := self registry httpProxyHost netUser) notNil				ifTrue: [ usr ]].	^uh isNil 		ifTrue: [ self defaultHttpUserMenuAspect value]		ifFalse: [ uh]</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>interface opening</category><body package="NetConfigTool" selector="postBuildWith:">postBuildWith: aBuilder	self httpHost onChangeSend: #tickle to: self.	self httpPort onChangeSend: #tickle to: self.	self httpUseProxy onChangeSend: #tickle to: self.	self proxyUserMenuAspect onChangeSend: #tickle to: self.	self httpUseProxy onChangeSend: #useProxyChanged to: self.	self useProxyChanged.</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>accessing</category><body package="NetConfigTool" selector="defaultIncomingServer">defaultIncomingServer	^self userPreferencesAt: #defaultIncomingServer ifAbsentPut: [ nil ]</body><body package="NetConfigTool" selector="defaultIncomingServer:">defaultIncomingServer: aHostSpec	^self userPreferencesAt: #defaultIncomingServer put: aHostSpec</body><body package="NetConfigTool" selector="defaultMailServerName">defaultMailServerName	| serv | 	^((serv := self serverList) notEmpty 				ifTrue: [ serv first ]				ifFalse: [ '' ])</body><body package="NetConfigTool" selector="defaultMailServerTypeMenuAspect">defaultMailServerTypeMenuAspect	^self mailServerMenu value menuItems notEmpty 		ifTrue: [ self mailServerMenu value menuItems first value type]		ifFalse: 			[self registry supportedMailClients notEmpty				ifTrue: [self registry supportedMailClients first serverType ]				ifFalse: [(String new) ] ]</body><body package="NetConfigTool" selector="defaultMailUserMenuAspect">defaultMailUserMenuAspect	^self mailServerMenu value menuItems notEmpty 			ifTrue: [ self mailServerMenu value menuItems first value netUser ]			ifFalse: [ nil  ]</body><body package="NetConfigTool" selector="defaultOutgoingServer">defaultOutgoingServer	^self userPreferencesAt: #defaultOutgoingServer ifAbsentPut: [ nil ]</body><body package="NetConfigTool" selector="defaultOutgoingServer:">defaultOutgoingServer: aHostSpec	^self userPreferencesAt: #defaultOutgoingServer put: aHostSpec</body><body package="NetConfigTool" selector="helpText">helpText	^(#ServerHelp &lt;&lt; #net &gt;&gt; 'You can specify several mail servers.  Typically you will have only a single outgoing mail server, but may have several incoming mail servers, if you receive mail from multiple mail services.To add a server, complete these fields and click Accept: - Name is the server''s fully qualified internet host name or IP address - Type is the server type, either POP3 (incoming), IMAP (incoming), or SMTP (outgoing) - User is a user ID already defined on the Identities page. To define a new user, click Add User... .  Complete the form as described in help for the Identities page.') asString</body><body package="NetConfigTool" selector="hostSpec">hostSpec	^hostSpec</body><body package="NetConfigTool" selector="hostSpec:">hostSpec: aHostSpec	hostSpec := aHostSpec.	self updateHostValuesFrom: aHostSpec</body><body package="NetConfigTool" selector="mailServerMenu">mailServerMenu	^self 		userPreferencesAt: #mailServerMenu  		ifAbsentPut: [self initializeFromRegistry asValue]</body><body package="NetConfigTool" selector="mailServerName">mailServerName	^self userPreferencesAt: #mailServerName		ifAbsentPut: [ self defaultMailServerName asValue ]</body><body package="NetConfigTool" selector="mailServerTypeMenu">mailServerTypeMenu	| menu | 	menu := Menu new.	self registry supportedMailClients 		do: 	[ :each | 			menu			addItemLabel: ( each serverType, ' ', each description asString)			value: each serverType ].	^menu</body><body package="NetConfigTool" selector="mailServerTypeMenuAspect">mailServerTypeMenuAspect	^self userPreferencesAt: #mailServerTypeMenuAspect		ifAbsentPut: [ self defaultMailServerTypeMenuAspect asValue ]</body><body package="NetConfigTool" selector="mailUserMenuAspect">mailUserMenuAspect	^self 		userPreferencesAt: #mailUserMenuAspect		ifAbsentPut: [ self defaultMailUserMenuAspect asValue ]</body><body package="NetConfigTool" selector="netUserMenu">netUserMenu 	^self userListOwner netUserMenu</body><body package="NetConfigTool" selector="selectedServer">selectedServer	^self hostSpec</body><body package="NetConfigTool" selector="selectedServer:">selectedServer: aHostSpecString	self enableButtons: aHostSpecString notNil.	aHostSpecString notNil 		ifTrue: [ self hostSpec: (self detectServer: aHostSpecString) ]</body><body package="NetConfigTool" selector="serverList">serverList 	^self mailServerMenu value menuItems collect: [ :it | it label ]</body><body package="NetConfigTool" selector="serverListAspect">serverListAspect 	serverListAspect isNil		ifTrue: 			[serverListAspect := SelectionInList					adapt: self 					aspect: #selectedServer					list: #serverList					selection: #selectedServer:].	^serverListAspect</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>interface opening</category><body package="NetConfigTool" selector="enableButtons">enableButtons	(self builder componentAt: #acceptButton) widget isEnabled: true.</body><body package="NetConfigTool" selector="enableButtons:">enableButtons: aBoolean	self builder isNil ifTrue: [^nil].	#( acceptButton removeButton setAsDefaultButton )		do: [ :each | (self widgetAt: each) isEnabled: aBoolean ].</body><body package="NetConfigTool" selector="postBuildWith:">postBuildWith: aBuilder	self serverList notEmpty ifTrue: [self serverListAspect 	selectionIndex: 1 ].	self mailServerName onChangeSend: #enableButtons to: self.	self mailServerTypeMenuAspect onChangeSend: #enableButtons to: self.	self mailUserMenuAspect onChangeSend: #enableButtons to: self.</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>actions</category><body package="NetConfigTool" selector="accept">accept	self registry resetServers.	self mailServerMenu value menuItems 		do: [ :itemx | self registry updateMailHost: itemx value].	self defaultIncomingServer notNil		ifTrue: [ self registry defaultIncomingHost: self defaultIncomingServer].	self defaultOutgoingServer notNil		ifTrue: [ self registry defaultOutgoingHost: self defaultOutgoingServer].</body><body package="NetConfigTool" selector="addIdentity">addIdentity	self  userListOwner addIdentity</body><body package="NetConfigTool" selector="disturb">disturb</body><body package="NetConfigTool" selector="importSnapshots:">importSnapshots: aCollection	super importSnapshots: aCollection.	self userListOwner reset</body><body package="NetConfigTool" selector="mailServerTypeMenuString:">mailServerTypeMenuString: aType	^aType first, ' (', (aType at:2), ')'</body><body package="NetConfigTool" selector="okToAddServer">okToAddServer	( self mailServerName value isNil or: [self mailServerName value isEmpty])		ifTrue: [ ^Dialog warn: (#HostNameIsEmpty &lt;&lt; #net &gt;&gt; 'Host name is empty') ].	( self mailServerTypeMenuAspect value isNil or: [ self mailServerTypeMenuAspect value isEmpty])		ifTrue: [ ^Dialog warn: (#HostTypeIsEmpty &lt;&lt; #net &gt;&gt; 'Host type is empty') ].	self removeMenuItemFor: self mailServerName value.	hostSpec := HostSpec new						name: self mailServerName value;						type: self mailServerTypeMenuAspect value;						netUser: self mailUserMenuAspect value;						yourself.	(hostSpec isIncomingTypeMail and: [self defaultIncomingServer isNil])		ifTrue: [self defaultIncomingServer: hostSpec].	(hostSpec isOutgoingTypeMail and: [self defaultOutgoingServer isNil])		ifTrue: [self defaultOutgoingServer: hostSpec].	self mailServerMenu value		addItemLabel: ( self serverAsString: hostSpec ) 		value: hostSpec.		self updateMenuAspects.	manager tickle.</body><body package="NetConfigTool" selector="removeServer">removeServer	| it |	self removeMenuItemFor:  self hostSpec name. 	self hostSpec  = self defaultIncomingServer 		ifTrue: 			[ (it := self mailServerMenu value menuItems 					detect: [ :itx | itx value isIncomingTypeMail ] 					ifNone: [nil]) notNil				ifTrue: 					[self defaultIncomingServer: it value.					it label: (self serverAsString: it value)]				ifFalse: [self defaultIncomingServer: nil]].	self hostSpec  = self defaultOutgoingServer 		ifTrue: 			[ (it := self mailServerMenu value menuItems 						detect: [ :itx | itx value isOutgoingTypeMail ] 						ifNone: [nil]) notNil				ifTrue: 					[self defaultOutgoingServer: it value.					it label: (self serverAsString: it value)]				ifFalse: [ self defaultOutgoingServer: nil ]].	self hostSpec: HostSpec new.	self serverListAspect listHolder changed:#value.</body><body package="NetConfigTool" selector="reset">reset	self resetUIStateToDefault</body><body package="NetConfigTool" selector="resetUIStateToDefault">resetUIStateToDefault	self mailServerMenu value: self initializeFromRegistry.	self serverListAspect listHolder changed:#value.	self mailServerName value: self defaultMailServerName.	self mailServerTypeMenuAspect value: self defaultMailServerTypeMenuAspect.	self mailUserMenuAspect value: self defaultMailUserMenuAspect.</body><body package="NetConfigTool" selector="setServerAsDefault">setServerAsDefault	self setAsDefaultServer: self hostSpec.</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>private</category><body package="NetConfigTool" selector="detectServer:">detectServer: aString	| item |	^(item := self 			mailServerMenu value menuItems detect: [ :it | (self serverAsString: it value ) = aString ] 			ifNone: [ nil]) isNil		ifTrue: [ HostSpec new ]		ifFalse: [ item value]</body><body package="NetConfigTool" selector="initializeFromRegistry">initializeFromRegistry	| menu | 	menu := Menu new.	self defaultIncomingServer: self registry defaultIncomingHost.	self defaultOutgoingServer: self registry defaultOutgoingHost.	self registry mailServers copy		do: 	[ :each |			menu			addItemLabel: (self serverAsString: each)			value: each  ].	^menu</body><body package="NetConfigTool" selector="removeMenuItemFor:">removeMenuItemFor: aSpecHostName	|  item |	(item := self mailServerMenu value menuItems 				detect: [ :itemx | itemx value name = aSpecHostName ] 				ifNone: [ nil ] ) notNil		ifTrue: 			[self mailServerMenu value removeItem: item.			self serverListAspect listHolder changed:#value.			manager tickle].</body><body package="NetConfigTool" selector="serverAsString:">serverAsString: aHostSpec	| stream |	stream := String new writeStream.	stream nextPutAll: aHostSpec name.	((self defaultIncomingServer notNil 		and: [ aHostSpec name = self defaultIncomingServer name ])	or: [self defaultOutgoingServer notNil		and: [aHostSpec name = self defaultOutgoingServer name]])		ifTrue: [ aHostSpec printDefaultDescriptionOn: stream ]		ifFalse: [ aHostSpec printDescriptionOn: stream ].	^stream contents</body><body package="NetConfigTool" selector="setAsDefaultServer:">setAsDefaultServer: aHostSpec	| host |	host :=  (aHostSpec isNil		ifTrue: 			[ self mailServerMenu value menuItems notEmpty 				ifTrue: [self mailServerMenu menuItems first value]				ifFalse: [nil]]		ifFalse: [ aHostSpec ]).	host isNil ifTrue: [ ^nil ].	host isIncomingTypeMail		ifTrue: [ self defaultIncomingServer: host]		ifFalse: [ self defaultOutgoingServer: host].	self mailServerMenu value menuItems do: 		[ :itemx |  itemx label: ( self serverAsString: itemx value )  ].	self updateMenuAspects.	manager tickle.</body><body package="NetConfigTool" selector="updateHostValuesFrom:">updateHostValuesFrom: aHostSpec	self mailServerName value: aHostSpec name.	self mailUserMenuAspect value:  aHostSpec netUser.	self mailServerTypeMenuAspect value:  aHostSpec type.</body><body package="NetConfigTool" selector="updateMenuAspects">updateMenuAspects	| selectIndex |	selectIndex := self serverListAspect selectionIndex.	self serverListAspect listHolder changed:#value. 	selectIndex notNil		ifTrue: [ self serverListAspect selectionIndex: selectIndex ]</body></methods><methods><class-id>Net.UserPage</class-id> <category>accessing</category><body package="NetConfigTool" selector="accountIdentity">accountIdentity 	^self 		userPreferencesAt: #accountIdentity  		ifAbsentPut: [ self defaultAccountIdentity asValue]</body><body package="NetConfigTool" selector="defaultAccountIdentity">defaultAccountIdentity 	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser account ]</body><body package="NetConfigTool" selector="defaultFullNameIdentity">defaultFullNameIdentity  	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser fullName ]</body><body package="NetConfigTool" selector="defaultMailAddressIdentity">defaultMailAddressIdentity  	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser mailAddress ]</body><body package="NetConfigTool" selector="defaultNetUserMenu">defaultNetUserMenu	| menu |	menu := Menu new.	self defaultUser: self registry defaultIdentity.	self registry identities copy		do: 	[ :each |			menu				addItemLabel: (self userAsString: each)				value: each  ].	^menu</body><body package="NetConfigTool" selector="defaultPasswordIdentity">defaultPasswordIdentity  	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser password ]</body><body package="NetConfigTool" selector="defaultRememberPassword">defaultRememberPassword	| pass |	pass := self netUser notNil		ifTrue: [ self netUser savePassword].	^pass isNil 		ifTrue: [false]		ifFalse: [ pass ]</body><body package="NetConfigTool" selector="defaultUser">defaultUser	^self userPreferencesAt: #defaultUser ifAbsentPut: [ nil ]</body><body package="NetConfigTool" selector="defaultUser:">defaultUser: aNetUser	^self userPreferencesAt: #defaultUser put: aNetUser</body><body package="NetConfigTool" selector="defaultUserNameIdentity">defaultUserNameIdentity 	^self netUser isNil		ifTrue: [ '']		ifFalse: [ self netUser username ]</body><body package="NetConfigTool" selector="emailAddressIdentity">emailAddressIdentity  	^self userPreferencesAt: #emailAddressIdentity  		ifAbsentPut: [self defaultMailAddressIdentity  asValue ]</body><body package="NetConfigTool" selector="fullNameIdentity">fullNameIdentity  	^self userPreferencesAt: #fullNameIdentity  			ifAbsentPut: [ self defaultFullNameIdentity asValue]</body><body package="NetConfigTool" selector="helpText">helpText	^(#IdentityHelp &lt;&lt; #net &gt;&gt; 'Network Identities lists user identifications for this client. You may have only one, or several user identities.  To add an ID, click Add and complete the Add Identity dialog. In the Add Identity dialog: - Full name: is your name as it will be displayed - User Name: is your account user ID - Email address: is your email address for this account - Account is the account ID used if an FTP host requires an account (does not accept anonymous FTP)To provide a password for this account: - check Remember password to store this information - enter your password identically twice (Enter: and Confirm:). The password is masked while you type.') asString</body><body package="NetConfigTool" selector="identityListAspect">identityListAspect	identityListAspect isNil		ifTrue: 			[identityListAspect := SelectionInList							adapt: self 							aspect: #selectedIdentity							list: #userIdentities							selection: #selectedIdentity:].	^identityListAspect</body><body package="NetConfigTool" selector="netUser">netUser	^netUser</body><body package="NetConfigTool" selector="netUser:">netUser: aNetUser	netUser := aNetUser.	self updateIdentityValuesFrom: netUser</body><body package="NetConfigTool" selector="netUserMenu">netUserMenu	^self 		userPreferencesAt: #netUserMenu  		ifAbsentPut: [ self defaultNetUserMenu asValue ]</body><body package="NetConfigTool" selector="passwordIdentity">passwordIdentity  	^self userPreferencesAt: #passwordIdentity  			ifAbsentPut: [ self defaultPasswordIdentity asValue]</body><body package="NetConfigTool" selector="proxyUserMenuAspect">proxyUserMenuAspect	^self userPreferences at: #proxyUserMenuAspect ifAbsent: [ nil asValue ]</body><body package="NetConfigTool" selector="rememberPassword">rememberPassword	^self userPreferencesAt: #rememberPassword  			ifAbsentPut: [ self defaultRememberPassword asValue]</body><body package="NetConfigTool" selector="selectedIdentity">selectedIdentity	^self userAsString: self netUser</body><body package="NetConfigTool" selector="selectedIdentity:">selectedIdentity: aNetUserString	self enableButtons: aNetUserString notNil.	aNetUserString notNil ifTrue: [ self netUser: (self detectUser: aNetUserString) ]</body><body package="NetConfigTool" selector="userIdentities">userIdentities	^self netUserMenu value menuItems collect: [ :it | it label ]</body><body package="NetConfigTool" selector="userNameIdentity">userNameIdentity 	^self userPreferencesAt: #userNameIdentity 			ifAbsentPut: [ self defaultUserNameIdentity  asValue]</body><body package="NetConfigTool" selector="verifyPasswordIdentity">verifyPasswordIdentity	^self userPreferencesAt: #verifyPasswordIdentity  ifAbsentPut: [ nil asValue ].</body></methods><methods><class-id>Net.UserPage</class-id> <category>actions</category><body package="NetConfigTool" selector="accept">accept	self registry resetIdentities.	self netUserMenu value menuItems 		do: [ :itemx |			self registry addIdentity: itemx value].	self defaultUser notNil		ifTrue: [ self registry defaultIdentity: self defaultUser].	self updateIdentityListAspects.</body><body package="NetConfigTool" selector="addIdentity">addIdentity	self netUser: (NetUser new savePassword: false; yourself).	AddNetUser openWithSpec: #addIdentitySpec parent: self</body><body package="NetConfigTool" selector="editIdentity">editIdentity	AddNetUser openWithSpec: #addIdentitySpec parent: self</body><body package="NetConfigTool" selector="removeIdentity">removeIdentity	| resp  | 	(self registry hasIdentityReference: self netUser)		ifTrue: 			[ resp := Dialog confirm: ((#IdentityIsUsedInServerSettings &lt;&lt; #net &gt;&gt; '&lt;1s&gt; identity is used in server settings. &lt;n&gt;Do you want to delete it?')			expandMacrosWith: self netUser fullName).			resp ifFalse: [^nil]]. 	self removeMenuItemFor: self netUser.	(self defaultUser notNil and: [self defaultUser fullName =  self netUser fullName])		ifTrue: [ self setAsDefaultIdentity: nil ].	(self proxyUserMenuAspect value notNil		and: [ self proxyUserMenuAspect value fullName =  self netUser fullName ])		ifTrue: [ self proxyUserMenuAspect value: nil ].	self identityListAspect listHolder changed: #value.	manager tickle.</body><body package="NetConfigTool" selector="reset">reset	self resetUIStateToDefault.</body><body package="NetConfigTool" selector="resetUIStateToDefault">resetUIStateToDefault	self netUserMenu  value: self defaultNetUserMenu.	self identityListAspect listHolder changed: #value.</body><body package="NetConfigTool" selector="setAsDefaultIdentity">setAsDefaultIdentity	self setAsDefaultIdentity: self netUser</body></methods><methods><class-id>Net.UserPage</class-id> <category>interface opening</category><body package="NetConfigTool" selector="enableButtons:">enableButtons: aBoolean	self builder isNil ifTrue: [ ^nil ].	(self builder componentAt: #editButton) widget isEnabled: aBoolean.	(self builder componentAt: #removeButton) widget isEnabled: aBoolean.	(self builder componentAt: #setAsDefaultButton) widget isEnabled: aBoolean.</body><body package="NetConfigTool" selector="postBuildWith:">postBuildWith: aBuilder	self enableButtons: false</body></methods><methods><class-id>Net.UserPage</class-id> <category>private</category><body package="NetConfigTool" selector="detectUser:">detectUser: aString	| item |	^(item := self 			netUserMenu value menuItems detect: [ :it | (self userAsString: it value ) = aString ] 			ifNone: [ nil]) isNil		ifTrue: [ NetUser new ]		ifFalse: [ item value]</body><body package="NetConfigTool" selector="removeMenuItemFor:">removeMenuItemFor: aNetUser	|  item |	(item := self netUserMenu value menuItems detect: [ :itemx | itemx value = aNetUser ] ifNone: [ nil ] ) notNil		ifTrue: [	self netUserMenu value removeItem: item].</body><body package="NetConfigTool" selector="setAsDefaultIdentity:">setAsDefaultIdentity: aNetUser	self defaultUser: (aNetUser isNil		ifTrue: 			[ self netUserMenu value menuItems notEmpty 				ifTrue: [self netUserMenu value menuItems first value]				ifFalse: [nil]]		ifFalse: [ aNetUser ]).	self netUserMenu value menuItems do: 		[ :itemx |  itemx label: ( self userAsString: itemx value )  ].	self identityListAspect listHolder changed: #value.	manager tickle.</body><body package="NetConfigTool" selector="updateIdentityListAspects">updateIdentityListAspects	| selectIndex |	selectIndex := self identityListAspect selectionIndex.	self identityListAspect listHolder changed:#value.	self identityListAspect selectionIndex: selectIndex.</body><body package="NetConfigTool" selector="updateIdentityValuesFrom:">updateIdentityValuesFrom: aNetUser	self fullNameIdentity value: aNetUser fullName.	self userNameIdentity value: 	aNetUser username.	self passwordIdentity value: 	aNetUser password.	self emailAddressIdentity value: aNetUser mailAddress.	self accountIdentity value: aNetUser account.	self verifyPasswordIdentity value: aNetUser password.	self rememberPassword value: aNetUser savePassword.</body><body package="NetConfigTool" selector="updateNetUser">updateNetUser	self removeMenuItemFor: self netUser.	netUser := (NetUser new					fullName: self fullNameIdentity value;					username: self userNameIdentity value;					password: self passwordIdentity value;					savePassword: self rememberPassword value;					mailAddress: self emailAddressIdentity value;					account: self accountIdentity value;					yourself).	self defaultUser isNil ifTrue: [ self defaultUser: netUser].	self netUserMenu value		addItemLabel: ( self userAsString: netUser ) 		value: netUser.	self identityListAspect listHolder changed:#value.	manager tickle</body><body package="NetConfigTool" selector="userAsString:">userAsString: aNetUser	| stream |	stream := String new writeStream.	aNetUser printNameOn: stream.	(self defaultUser notNil and: [ aNetUser fullName = self defaultUser fullName])			ifTrue: [ aNetUser printDefaultOn: stream ].	aNetUser printMailAddressOn: stream.		^stream contents</body></methods><methods><class-id>Net.UserPage</class-id> <category>initialize-release</category><body package="NetConfigTool" selector="initialize">initialize	| usr |	super initialize. 	(usr :=self registry httpProxyHost) notNil		ifTrue: [usr := self registry httpProxyHost netUser].	usr := (usr notNil		ifTrue: [ usr ]		ifFalse: [nil ]) asValue.	self  userPreferences 		at: #proxyUserMenuAspect		put: usr</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>persistance</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: xmlColl	^NetSettings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.HostSpec</class-id> <category>persistence</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString 	^NetSettings netObject: self asXmlNode: aString</body></methods><methods><class-id>Core.String class</class-id> <category>net clients</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	| els |	^(els := anXMLElement elements) isEmpty		ifTrue: [self new]		ifFalse: [ els first text ]</body></methods><methods><class-id>Core.String</class-id> <category>net clients</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: 'String' )).	node addNode: (XML.Text text: self ).	^node</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>net clients</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	| xmlColl dict key value |	xmlColl := anXMLElement realElements.	dict := self new: xmlColl size.	xmlColl do: 			[ :el |			key := el realElements first restoreValue.			value := el realElements last restoreValue.			dict at:  key put: value ].	^dict</body></methods><methods><class-id>Core.Dictionary</class-id> <category>net clients</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString	^Net.NetSettings dictionary: self  asXmlNode: aString</body></methods><methods><class-id>XML.Text</class-id> <category>net clients</category><body package="NetConfigTool" selector="restoreValue">restoreValue</body><body package="NetConfigTool" selector="restoreValueFor:">restoreValueFor: aClass	^aClass readFrom: self text</body></methods><methods><class-id>Core.Collection class</class-id> <category>net clients</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	| coll xmlColl |	xmlColl := anXMLElement realElements.	coll := self new: xmlColl size.	xmlColl do: 			[ :el |			coll add: el restoreValue ].	^coll</body></methods><methods><class-id>Core.Collection</class-id> <category>net clients</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString	^Net.NetSettings collection: self  asXmlNode: aString</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>persistence</category><body package="NetConfigTool" selector="restoreRegistryFrom:">restoreRegistryFrom: aDataSource	| xml |	xml := (XML.XMLParser on:  aDataSource)				validate: false;				scanDocument.	Registry := (Dictionary restoreValueFrom: xml root)</body><body package="NetConfigTool" selector="storeRegistryTo:">storeRegistryTo: aStream	aStream nextPutAll: '&lt;?xml version="1.0"?&gt;'.	(self registry asXmlNode: 'CookieRegistry' ) printOn: aStream.</body></methods><methods><class-id>XML.Element</class-id> <category>net clients</category><body package="NetConfigTool" selector="restoreValue">restoreValue	^Net.NetSettings restoreValueFrom: self</body></methods><methods><class-id>Net.NetClient class</class-id> <category>persistance</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: xmlColl	^NetSettings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.NetClient</class-id> <category>persistence</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString 	^NetSettings netObject: self asXmlNode: aString</body></methods><methods><class-id>Net.NetUser class</class-id> <category>persistance</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: xmlColl	^NetSettings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.NetUser</class-id> <category>persistence</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString 	^NetSettings netObject: self asXmlNode: aString</body></methods><methods><class-id>Core.Object class</class-id> <category>net clients</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^self readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Core.Object</class-id> <category>net clients</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString	^Net.NetSettings object: self asXmlNode: aString</body></methods><methods><class-id>Core.Symbol class</class-id> <category>net clients</category><body package="NetConfigTool" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^self readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Core.Symbol</class-id> <category>net clients</category><body package="NetConfigTool" selector="asXmlNode:">asXmlNode: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: 'Symbol' )).	node addNode: (XML.Text text: '#''', self, '''' ).	^node</body></methods><methods><class-id>Net.DeliveryMonitor class</class-id> <category>interface specs</category><body package="NetConfigTool" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #DeliveryMonitor #defaultString: 'Delivery Monitor' #catalogID: #net) 			#min: #(#{Core.Point} 256 45 ) 			#bounds: #(#{Graphics.Rectangle} 462 381 718 426 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #progress 					#isOpaque: true 					#model: #progress 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) ) ) )</body></methods><methods><class-id>Net.HttpProxyExceptions class</class-id> <category>interface specs</category><body package="NetConfigTool" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #AdvancedProxyOptions #defaultString: 'Advanced Proxy Options' #catalogID: #net) 			#min: #(#{Core.Point} 412 202 ) 			#max: #(#{Core.Point} 412 202 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 924 586 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 21 8 398 161 ) 					#name: 'GroupBox1' 					#label: #(#{Kernel.UserMessage} #key: #Exceptions #defaultString: 'Exceptions' #catalogID: #net) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 317 168 398 191 ) 					#name:  'ActionButton1'					#model: #cancelHttpException 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #net) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 233 168 314 191 ) 					#name: 'ActionButton2'					#model: #acceptHttpExceptions 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #net) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.Rectangle} 31 45 387 136 ) 					#name:  'TextEditor1' 					#model: #httpProxyExceptions 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 283 0 45 0 1 1 ) 					#name: 'Label1' 					#label: #(#{Kernel.UserMessage} #key: #DoNotUseProxyServersForDomains #defaultString: 'Do not use proxy servers for domains beginning with:' #catalogID: #net) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 217 0 158 0 1 1 ) 					#name:  'Label2' 					#label: #(#{Kernel.UserMessage} #key: #UseSemicolonSeparateDomains #defaultString: 'Use semicolon (;) to separate domains.' #catalogID: #net) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 233 168 314 191 ) 					#name:  'ActionButton3' 					#model: #acceptHttpExceptions 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #net) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Net.AddNetUser class</class-id> <category>interface specs</category><body package="NetConfigTool" selector="addIdentitySpec">addIdentitySpec	"Tools.UIPainter new openOnClass: self andSelector: #addIdentitySpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #AddIdentity 				#defaultString: 'Add Identity' 				#catalogID: #net ) 			#min: #(#{Core.Point} 371 290 ) 			#max: #(#{Core.Point} 371 290 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 883 674 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 98 0 64 0 1 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #UserNameC 						#defaultString: 'User Name:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 110 0 91 0 1 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #EmailAddress 						#defaultString: 'Email address:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 90 0 37 0 1 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #FullName 						#defaultString: 'Full name:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 38 204 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Enter 						#defaultString: 'Enter:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 85 0 118 0 1 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Account 						#defaultString: 'Account:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 38 233 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Confirm 						#defaultString: 'Confirm:' 						#catalogID: #net ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 22 154 281 269 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Password 						#defaultString: 'Password' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 116 10 269 32 ) 					#model: #fullNameIdentity ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.312668 39 0 0 0.725067 61 0 ) 					#model: #userNameIdentity 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 116 68 269 90 ) 					#model: #emailAddressIdentity 					#isReadOnly: false ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 116 97 269 119 ) 					#model: #accountIdentity ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 126 175 ) 					#model: #rememberPassword 					#label: 					#(#{Kernel.UserMessage} 						#key: #RememberPassword 						#defaultString: 'Remember password' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 131 204 269 227 ) 					#model: #passwordIdentity 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 131 234 269 255 ) 					#model: #verifyPasswordIdentity 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 289 10 360 31 ) 					#model: #okToAddIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 289 34 360 55 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #net ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Net.HttpProxyPage class</class-id> <category>interface specs</category><body package="NetConfigTool" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #HTTPSettings 				#defaultString: 'HTTP Settings' 				#catalogID: #net ) 			#min: #(#{Core.Point} 363 311 ) 			#max: #(#{Core.Point} 363 311 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1083 761 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 135 0 65 0 -10 1 90 0 ) 					#name: #proxyAddress 					#model: #httpHost ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 135 0 100 0 -10 1 125 0 ) 					#name: #proxyPort 					#model: #httpPort 					#type: #number ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 135 0 135 0 -10 1 160 0 ) 					#name: #proxyUserMenuAspect 					#model: #proxyUserMenuAspect 					#menu: #netUserMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 180 0 -95 1 205 0 ) 					#name: #addIdentityButton 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddUser 						#defaultString: 'Add User...' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 180 0 -10 1 205 0 ) 					#name: #advancedButton 					#model: #httpAdvanced 					#label: 					#(#{Kernel.UserMessage} 						#key: #Advandec 						#defaultString: 'Advanced...' 						#catalogID: #webservices ) 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.Rectangle} 10 20 100 37 ) 					#model: #httpUseProxy 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseProxy 						#defaultString: 'Use proxy' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 65 65 90 ) 					#name: #addressLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Address 						#defaultString: 'Address:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 100 60 125 ) 					#name: #portLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Port 						#defaultString: 'Port:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 135 90 160 ) 					#name: #proxyUserLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ProxyUser 						#defaultString: 'Proxy user:' 						#catalogID: #net ) ) ) ) )</body></methods><methods><class-id>Net.MailServerPage class</class-id> <category>interface specs</category><body package="NetConfigTool" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MailServerList 				#defaultString: 'Mail Server List' 				#catalogID: #net ) 			#min: #(#{Core.Point} 383 350 ) 			#max: #(#{Core.Point} 383 350 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 895 734 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.5 ) 					#model: #serverListAspect 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 5 0.5 -100 1 120 0.5 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Host 						#defaultString: 'Host' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 50 0.5 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Name 						#defaultString: 'Name:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 110 0.5 0 1 ) 					#name: #user 					#label: 					#(#{Kernel.UserMessage} 						#key: #User 						#defaultString: 'User:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 80 0.5 0 1 ) 					#name: #serverType 					#label: 					#(#{Kernel.UserMessage} 						#key: #Type 						#defaultString: 'Type:' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 25 0.5 -110 1 50 0.5 ) 					#name: #mailServerName 					#model: #mailServerName 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#type: #string ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 55 0.5 -110 1 80 0.5 ) 					#model: #mailServerTypeMenuAspect 					#menu: #mailServerTypeMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 85 0.5 -110 1 110 0.5 ) 					#model: #mailUserMenuAspect 					#menu: #netUserMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 15 0.5 0 0.994778 40 0.5 ) 					#name: #acceptButton 					#model: #okToAddServer 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddNoDots 						#defaultString: 'Add' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 40 0.5 0 0.994778 65 0.5 ) 					#name: #removeButton 					#model: #removeServer 					#label: 					#(#{Kernel.UserMessage} 						#key: #Remove 						#defaultString: 'Remove' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 65 0.5 0 0.994778 90 0.5 ) 					#name: #setAsDefaultButton 					#model: #setServerAsDefault 					#label: 					#(#{Kernel.UserMessage} 						#key: #SetAsDefault 						#defaultString: 'Set As Default' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 90 0.5 0 0.994778 115 0.5 ) 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddUser 						#defaultString: 'Add User...' 						#catalogID: #net ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Net.UserPage class</class-id> <category>interface specs</category><body package="NetConfigTool" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Identity 				#defaultString: 'Identity' 				#catalogID: #net ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 936 695 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 -100 1 0 1 ) 					#model: #identityListAspect 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 25 0 0 1 50 0 ) 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #Add 						#defaultString: 'Add...' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 50 0 0 1 75 0 ) 					#name: #editButton 					#model: #editIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #Edit 						#defaultString: 'Edit...' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 75 0 0 1 100 0 ) 					#name: #removeButton 					#model: #removeIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #Remove 						#defaultString: 'Remove' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 100 0 0 1 125 0 ) 					#name: #setAsDefaultButton 					#model: #setAsDefaultIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #SetAsDefault 						#defaultString: 'Set As Default' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 0 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #UserIdentitiesC 						#defaultString: 'User identities:' 						#catalogID: #net ) ) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http</category><body package="NetConfigTool" selector="c02EnableCookieProcessing">c02EnableCookieProcessing	&lt;setting: #(net http httpCookie enableCookieProcessing )&gt;	| class |	#{Net.HttpProtocolInterpreter } ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #enableCookieProcessing)		label: #HttpEnableCookieProcessing&lt;&lt; #net &gt;&gt; 'Enable cookie processing';		default: class defaultEnableCookieProcessing;		helpText: #HttpEnableCookieProcessingHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to process Http cookies.';		yourself</body><body package="NetConfigTool" selector="c1CacheCookies">c1CacheCookies	&lt;setting: #(net http httpCookie cacheCookies )&gt;	| class |	#{Net.CookieAgent } ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #cacheCookies)		label: #HttpCacheCookies&lt;&lt; #net &gt;&gt; 'Enable cookie caching';		default: class defaultCacheCookies;		helpText: #HttpCacheCookiesHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to cache Http cookies when a session is terminated.';		yourself</body><body package="NetConfigTool" selector="c2UseCachedCookies">c2UseCachedCookies	&lt;setting: #(net http httpCookie useCachedCookies )&gt;	| class |	#{Net.CookieAgent }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #useCachedCookies)		label: #HttpUseCachedCookies&lt;&lt; #net &gt;&gt; 'Use cached cookies';		default: class defaultUseCachedCookies;		helpText: #HttpUseCachedCookiesHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to use already cached cookies for each session.';		yourself</body><body package="NetConfigTool" selector="c3EnableLimits">c3EnableLimits	&lt;setting: #(net http httpCookie enableLimits )&gt;	| class |	#{Net.CookieAgent} ifDefinedDo: [:val | class := val] elseDo: [^nil].	^(BooleanSetting on: class aspect: #enableLimits)		label: #HttpEnableLimits &lt;&lt; #net &gt;&gt; 'Enable cookie processing limits';		default: class defaultEnableLimits;		helpText: #HttpEnableLimitsHelpText &lt;&lt; #net &gt;&gt; 'Enables enforcement of cookie registry limits.';		yourself</body><body package="NetConfigTool" selector="c4NumberRegistryEntries">c4NumberRegistryEntries	&lt;setting: #(net http  httpCookie numberRegistryEntries )&gt;	| class |	#{Net.CookieAgent }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #numberEntries)		label: #HttpNumberEntries&lt;&lt; #net &gt;&gt; 'Total number of cookies';		default: class defaultNumberEntries;		helpText: #HttpNumberEntriesHelpText &lt;&lt; #net &gt;&gt; 'Specifies the maximum number of cookies stored in the registry.';		yourself</body><body package="NetConfigTool" selector="c5NumberEntriesPerServer">c5NumberEntriesPerServer	&lt;setting: #(net  http httpCookie numberEntriesPerServer )&gt;	| class |	#{Net.CookieAgent }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #numberEntriesPerServer)		label: #HttpNumberEntriesPerServer&lt;&lt; #net &gt;&gt; 'Max cookies per host';		default: class defaultNumberEntriesPerServer;		helpText: #HttpNumberEntriesPerServerHelpText &lt;&lt; #net &gt;&gt; 'Specifies the maximum number of cookies per unique host stored in the registry.';		yourself</body><body package="NetConfigTool" selector="c6NumberBytesPerCookie">c6NumberBytesPerCookie	&lt;setting: #(net http httpCookie numberBytesPerCookie )&gt;	| class |	#{Net.CookieAgent} ifDefinedDo: [:val | class := val] elseDo: [^nil].	^(NumberSetting on: class aspect: #numberBytesPerCookie)		label: #HttpNumberBytesPerCookie &lt;&lt; #net &gt;&gt; 'Max bytes per cookie';		default: class defaultNumberBytesPerCookie;		helpText: #HttpNumberBytesPerCookieHelpText &lt;&lt; #net &gt;&gt; 'Specifies the maximum size of cookies in bytes.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="NetConfigTool" selector="ftp1AnonymousLoginPassword">ftp1AnonymousLoginPassword	&lt;setting: #(net ftp anonymousLoginPassword)&gt;	| class |	#{Net.FTPClient }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: Net.Settings aspect: #ftpAnonymousLoginPassword )		default: String new;		label: #AnonymousLoginPassword &lt;&lt; #net &gt;&gt; 'Anonymous login password';		helpText: #AnonymousLoginPasswordHelpText &lt;&lt; #net &gt;&gt; 'Specifies the email address to be used as the password for anonymous FTP connections.  Anonymous FTP sites typically accept "anonymous" as the user name and an email address as the password.';		yourself</body><body package="NetConfigTool" selector="ftp2UsePassiveMode">ftp2UsePassiveMode	&lt;setting: #(net ftp usePassiveMode)&gt;	| class |	#{Net.FTPClient }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: Net.Settings aspect: #ftpPassiveMode )		default: Net.Settings  ftpPassiveMode;		label: #UsePassiveMode &lt;&lt; #net &gt;&gt; 'Use passive mode';		helpText: #UsePassiveModeHelpText &lt;&lt; #net &gt;&gt; 'If checked, it causes the server to use passive mode for transactions. This means that the server listens for the client to make the connection instead of initiating it. This is often necessary for clients located behind a firewall.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool" selector="ftpPage">ftpPage	&lt;settingsPage: #(net ftp)&gt;	#{Net.FTPClient} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #FTP &lt;&lt; #labels &gt;&gt; 'FTP';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net ftp ));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http</category><body package="NetConfigTool" selector="http1KeepAlive">http1KeepAlive	&lt;setting: #(net http keepAlive)&gt;	| class |	#{Net.Settings }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #httpKeepAlive )		label: #keepAliveConnection &lt;&lt; #net &gt;&gt; 'Use persistent connections';		default: class httpKeepAliveDefault;		helpText: #keepAliveHelpText &lt;&lt; #net &gt;&gt; 'Persistent connection allows the client to reuse the same connection for several requests. Non-persistent connections close after each request. This setting controls the Connection: header field.';		yourself</body><body package="NetConfigTool" selector="http2Redirect">http2Redirect	&lt;setting: #(net http redirect)&gt;	| class |	#{Net.Settings }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #httpRedirectRequest )		label: #redirectRequest &lt;&lt; #net &gt;&gt; 'Automatically redirect requests';		default: class httpRedirectRequestDefault;		helpText: #redirectHelpText &lt;&lt; #net &gt;&gt; 'This settings controls handling of the HttpMovedError (301 and 302 response status codes) . There are a few scenarios:	a. An application does not have http error handling - in this case the http client uses its default error handling for the HttpMovedError and sends a new request to the new location specified in the server reply.	b. An application has http error handling and this option is unchecked - the http client passes the HttpMovedError exception to the application.	c. An application has http error handling and this option is checked - the http clients uses its default error handling for the HttpMovedError exception.';		yourself</body><body package="NetConfigTool" selector="http3NTLMDomain">http3NTLMDomain	&lt;setting: #(net http #ntlmDomain)&gt;	| class |	#{Net.Settings }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #httpDomain )		label: #ntlmDomain &lt;&lt; #net &gt;&gt; 'NTLM Domain';		default: class httpDomainDefaultValue;		helpText: #ntlmDomainHelpText &lt;&lt; #net &gt;&gt; 'The name of the default NTLM domain for NTLM authentication. User credentials being authenticated must belong to users from this domain. Correct domain name must be specified otherwise NTLM authentication will fail. The default value will be taken from a system evironment variable ''USERDOMAIN'', if it is present.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool" selector="httpCookiePage">httpCookiePage	&lt;settingsPage: #(net http httpCookie)&gt;	#{Net.CookieAgent} isDefined ifFalse: [^nil].	^(ModularSettingsPage new)		label: #HTTPCookies &lt;&lt; #net &gt;&gt; 'Cookies';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(#net http #httpCookie));		yourself</body><body package="NetConfigTool" selector="httpMessageParsingPage">httpMessageParsingPage	&lt;settingsPage: #(net http messageParsing)&gt;	#{Net.HttpBuildHandler} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #MessageParsing &lt;&lt; #labels &gt;&gt; 'Message Parsing';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net http messageParsing));		yourself</body><body package="NetConfigTool" selector="httpMessageWritingPage">httpMessageWritingPage	&lt;settingsPage: #(net http messageWriting)&gt;	#{Net.HttpWriteHandler} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #MessageWriting &lt;&lt; #labels &gt;&gt; 'Message Writing';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net http messageWriting));		yourself</body><body package="NetConfigTool" selector="httpPage">httpPage	&lt;settingsPage: #(net http)&gt;	#{Net.HttpClient} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #HttpSettings &lt;&lt; #labels &gt;&gt; 'HTTP';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net http ));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http</category><body package="NetConfigTool" selector="httpParse1DecodeContent">httpParse1DecodeContent	&lt;setting: #(net http messageParsing decodeContent)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #decodeContents )		label: #decodeContents &lt;&lt; #net &gt;&gt; 'Decode messages (content-type encoding)';		default: class decodeContentsValue;		helpText: #decodeContentHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to decode http message bodies into text using the charset specificied by the content-type header field. If this settings is turned off the body contents will contain raw bytes.';		yourself</body><body package="NetConfigTool" selector="httpParse2RemoveContentEncoding">httpParse2RemoveContentEncoding	&lt;setting: #(net http messageParsing removeContentEncoding)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #decompressContents )		label: #decompressContents &lt;&lt; #net &gt;&gt; 'Decompress messages (content-encoding gzip)';		default: class defaultDecompressContents;		helpText: #removeContentEncodingHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to decompress http message body if it has the "content-encoding: gzip" header field. If this setting is turned off the body will contain raw compressed bytes (if it is compressed)';		yourself</body><body package="NetConfigTool" selector="httpParse3SaveAttachmentAsFile">httpParse3SaveAttachmentAsFile	&lt;setting: #(net http messageParsing saveAttachmentAsFile)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #saveAttachmentsAsFiles )		label: #SaveAttachmentAsFileValue &lt;&lt; #net &gt;&gt; 'Save attachments as files';		default: class saveAttachmentsAsFilesValue;		helpText: #saveAttachmentAsFileValueHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to save attachments into files. This settings allows to process large attachments more efficiently. If this settings is turned off attachments will be reconstructed entirely in memory.';		yourself</body><body package="NetConfigTool" selector="httpParse4UploadDirectory">httpParse4UploadDirectory	&lt;setting: #(net http messageParsing uploadDirectory)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #defaultAttachmentDirectory )		label: #defaultAttachmentDirectory &lt;&lt; #net &gt;&gt; 'Save attachments in';		default: class defaultAttachmentDirectoryValue;		helpText: #defaultUploadDirectoryHelpText &lt;&lt; #net &gt;&gt; 'This setting specifies the directory that will be used to save file attachments.'		yourself</body><body package="NetConfigTool" selector="httpParse5ParameterValueEncoding">httpParse5ParameterValueEncoding	&lt;setting: #(net http messageParsing parameterValueEncoding)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: Net.ValueWithParams aspect: #defaultParameterValueEncoding )		label: #defaultParameterValueEncoding &lt;&lt; #net &gt;&gt; 'Decode header parameters with:';		default: Net.ValueWithParams defaultParameterValueEncodingValue;		helpText: #defaultParameterValueEncodingHelpText &lt;&lt; #net &gt;&gt; 'If set, the specified encoding will be applied if we encounter non-ascii characters in header field parameter values (technically this is against the MIME specification, but seems to be a widespread practice, e.g. many web browsers do that with filenames of uploaded files)'		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool" selector="httpProxyPage">httpProxyPage	&lt;settingsPage: #(net http httpProxy)&gt;	#{Net.HttpClient} isDefined ifFalse: [ ^nil]. 	^Net.HttpProxyPage new		label: #HttpProxyServer &lt;&lt; #labels &gt;&gt; 'Proxy Server';		icon: (ListIconLibrary visualFor: #net);		yourself</body><body package="NetConfigTool" selector="httpServersCacheCookiesFrom">httpServersCacheCookiesFrom	&lt;settingsPage: #(net http httpCookie serversCacheCookiesFrom)&gt;	| class |	#{Net.CookieAgent} ifDefinedDo: [:val | class := val] elseDo: [^nil].	^(SequenceSettingPage new)		label: #CookieServers &lt;&lt; #labels &gt;&gt; 'Cookie Servers';		icon: (ListIconLibrary visualFor: #net);		listHolder: class serversCacheCookiesFrom asValue displayBlock: [:value | value] acceptBlock: [:value | value];		helpText: #HttpServersCacheCookiesFromHelpText &lt;&lt; #net &gt;&gt; 'Specifies list of servers to cache cookies from. Empty list means to store cookies from all servers';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http</category><body package="NetConfigTool" selector="httpWrite1ChunkSize">httpWrite1ChunkSize	&lt;setting: #(net http messageWriting chunkSize)&gt;	| class |	#{Net.ChunkedWriteStream }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #defaultWriteLimit)		label: #HttpChunkSize&lt;&lt; #net &gt;&gt; 'Default chunk size';		default: class defaultWriteLimitValue;		helpText: #HttpChunkSizeHelpText &lt;&lt; #net &gt;&gt; 'If an http message body shorter than the specified chunk size it it will be sent as it is and the message header will include the content-length header field with corresponding byte size value. If the body is longer than that the body will be written out in chunked format and the header will include transfer-encoding field with value ''chunked'' instead of the content-length field.';		yourself</body><body package="NetConfigTool" selector="httpWrite2UseGZipTransfer">httpWrite2UseGZipTransfer	&lt;setting: #(net http messageWriting useGZipTransfer)&gt;	| class |	#{Net.HttpWriteHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #useGZipTransfer)		label: #UseGZipTransfer&lt;&lt; #net &gt;&gt; 'Compress messages (transfer-encoding: gzip)';		default: class useGZipTransferValue;		helpText: #UseGZipTransferHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to apply gzip compression to outgoing messages. If this option is checked the messages will be sent compressed with header field Transfer-Encoding: gzip.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="NetConfigTool" selector="mail1DefaultContentDisposition">mail1DefaultContentDisposition	&lt;setting: #(net mail defaultContentDisposition)&gt;	| class |	#{Net.ContentDispositionField }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^((EnumerationSetting 				choices: #(attachment inline)				labels: (Array with: (#attachment &lt;&lt; #net &gt;&gt; 'attachment') with: (#inline &lt;&lt; #net &gt;&gt; 'inline') ))			on: class aspect: #defaultContentDisposition )		default: class defaultContentDispositionValue;		label: #defaultContentDisposition &lt;&lt; #net &gt;&gt; 'Default content disposition type';		helpText: #defaultContentDispositionHelpText &lt;&lt; #net &gt;&gt; 'Specifies the default disposition type for bodyparts in multipart mail messages. A bodypart should be marked "inline" if it is intended to be displayed along with the message. Body parts can be designated "attachment" to indicate that they are separate from the main body of the message';		yourself</body><body package="NetConfigTool" selector="mail2DefaultCharsetEncoder">mail2DefaultCharsetEncoder	&lt;setting: #(net mail defaultCharsetEncoder)&gt;	| class |	#{Net.SimpleBody }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #defaultCharsetEncoder )		label: #defaultCharsetEncoder &lt;&lt; #net &gt;&gt; 'Default content encoding';		default: class defaultCharsetEncoderValue;		helpText: #defaultCharsetEncoderHelpText &lt;&lt; #net &gt;&gt; 'This is the default encoding used for a message body when an encoding is not specified by the message.';		yourself</body><body package="NetConfigTool" selector="mail3RemoveContentTransferEncoding">mail3RemoveContentTransferEncoding	&lt;setting: #(net mail removeContentTransferEncoding)&gt;	| class |	#{Net.MailBuildHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #removeContentTransferEncoding )		default: class  removeContentTransferEncodingValue;		label: #removeContentTransferEncoding &lt;&lt; #net &gt;&gt; 'Remove transfer encoding from messages';		helpText: #removeContentTransferEncodingrHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to automatically remove transfer encoding (quoted-printable, or base-64, etc) along with the corresponding Content-Transfer-Encoding field while parsing mail messages.';		yourself</body><body package="NetConfigTool" selector="mail4SaveAttachmentAsFile">mail4SaveAttachmentAsFile	&lt;setting: #(net mail saveAttachmentAsFile)&gt;	| class |	#{Net.MimeBuildHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #saveAttachmentsAsFiles )		label: #SaveAttachmentAsFileValue &lt;&lt; #net &gt;&gt; 'Save attachments as files';		default: class saveAttachmentsAsFilesValue;		helpText: #saveAttachmentAsFileValueHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to save attachments into files. This settings allows to process large attachments more efficiently. If this settings is turned off attachments will be reconstructed entirely in memory.';		yourself</body><body package="NetConfigTool" selector="mail5UploadDirectory">mail5UploadDirectory	&lt;setting: #(net mail uploadDirectory)&gt;	| class |	#{Net.MimeBuildHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #defaultAttachmentDirectory )		label: #defaultAttachmentDirectory &lt;&lt; #net &gt;&gt; 'Save attachments in';		default: class defaultAttachmentDirectoryValue;		helpText: #defaultUploadDirectoryHelpText &lt;&lt; #net &gt;&gt; 'This setting specifies the directory that will be used to save file attachments.'		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool" selector="mailMessagePage">mailMessagePage	&lt;settingsPage: #(net mail)&gt;	#{Net.MimeEntity} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #Mail &lt;&lt; #net &gt;&gt; 'Mail';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net mail ));		yourself</body><body package="NetConfigTool" selector="mailServerPage">mailServerPage	&lt;settingsPage: #(net mail mailServers)&gt;	(#{Net.IMAPClient} isDefined 		or: [#{POP3Client} isDefined 			or: [#{SMTPClient} isDefined]] ) ifFalse: [ ^nil]. 	^Net.MailServerPage new		label: #MailServers &lt;&lt; #labels &gt;&gt; 'Mail Servers';		icon: (ListIconLibrary visualFor: #net);		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="NetConfigTool" selector="netClient1DefaultTimeout">netClient1DefaultTimeout	&lt;setting: #(net defaultTimeout)&gt;	^(NumberSetting on: Net.NetClient aspect: #defaultTimeout)		label: #DefaultTimeout&lt;&lt; #net &gt;&gt; 'Default timeout (ms)';		default: Net.NetClient defaultTimeoutValue;		helpText: #NetDefaultTimeoutHelpText &lt;&lt; #net &gt;&gt; 'This is the number of milliseconds to wait for an issued command to complete before signaling an error.';		yourself</body><body package="NetConfigTool" selector="netClient2DefaultRetries">netClient2DefaultRetries	&lt;setting: #(net defaultRetries)&gt;	^(NumberSetting on: Net.NetClient aspect: #defaultRetries)		label: #DefaultRetries&lt;&lt; #net &gt;&gt; 'Default retries';		default: Net.NetClient defaultRetriesValue;		helpText: #NetDefaultRetriesHelpText &lt;&lt; #net &gt;&gt; 'This is the number of attempts to connect to the server before giving up.';		yourself</body><body package="NetConfigTool" selector="netClient3DefaultDelaySeconds">netClient3DefaultDelaySeconds	&lt;setting: #(net defaultDelaySeconds)&gt;	^(NumberSetting on: Net.NetClient aspect: #defaultDelaySeconds)		label: #DefaultDelaySeconds &lt;&lt; #net &gt;&gt; 'Default retry delay (s)';		default: Net.NetClient defaultDelaySecondsValue;		helpText: #NetDefaultDelaySecondsHelpText &lt;&lt; #net &gt;&gt; 'This is the number of seconds to wait between retries.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool" selector="netClientPage">netClientPage	&lt;settingsPage: #(net )&gt;	^ModularSettingsPage new		label: #NetClient &lt;&lt; #net &gt;&gt; 'Net Client';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net ));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="NetConfigTool" selector="smtp1UseAuthentication">smtp1UseAuthentication	&lt;setting: #(net mail useAuthentication)&gt;	| class |	#{Net.SMTPClient }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #useAuthentication )		default: class  useAuthenticationValue;		label: #useAuthenticationToConnectToSMTPServer &lt;&lt; #net &gt;&gt; 'Use authentication for SMTP';		helpText: #useAuthenticationToConnectToSMTPServerHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to use authentication while connecting to SMTP servers. With authentication the client sends EHLO and AUTH commands depending on the authentication schemes supported by the server. Without authentication the client will use simpler (unauthenticated) HELO command to start a session with the server. Many ISPs require authenticated SMTP sessions.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool" selector="userIdentityPage">userIdentityPage	&lt;settingsPage: #(net userIdentities )&gt;	^Net.UserPage new		label: #UserIdentities &lt;&lt; #labels &gt;&gt; 'User Identities';		icon: (ListIconLibrary visualFor: #net);		yourself</body></methods><initialize><class-id>Net.NetSettingsPage</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>HostSpec</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name netUser type port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account savePassword mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Text</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text stripped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>GenericSettingDescriptor</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id position definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>