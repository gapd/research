<?xml version="1.0"?><st-source><!-- Name: MQ-DLLCCFixesNotice: Copyright © 2008-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: DllCC  Overrides that were put in By Heeg. this package may go away if Fixes to DLLCC are implemented. These are fixes for finding the external libary to load and should not affect other DLLCC interfaces.DbIdentifier: bear73DbTrace: 108671DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))PackageName: MQ-DLLCCFixesParcel: #('MQ-DLLCCFixes')ParcelName: MQ-DLLCCFixesPrerequisiteParcels: #(#('DLLCC' ''))PrintStringCache: (76 1.0,gheeg)Version: 7.6Date: 1:10:41 pm February 1, 2008 --><time-stamp>From VisualWorks®, 7.6 of February 1, 2008 on February 1, 2008 at 1:10:41 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>External.ExternalMethod class</class-id> <category>private</category><body package="MQ-DLLCCFixes" selector="mapVirtualAddressFor:in:">mapVirtualAddressFor: anExternal in: theClass	"Answer true if the receiver can be mapped into the context of the argument; otherwise answer false.  The argument is typically an external interface class.  Mapping is the process of searching for the receiver's entry-point handle either in the argument's dynamic-link libraries or statically linked into the run-time system.  The dynamic-link library search starts at the argument and continues up its superclass chain.  If this search is exhausted then a check for a statically linked entry-point is performed."	| aHandle newVirtuals |	theClass instanceBehavior libraryFiles		detect: [:aLibrary |			aHandle := ([self mapAddressFor: anExternal library: aLibrary]				on: anExternal owner libraryFilesSearchSignals				do: [:ex | ex return: nil]).			aHandle notNil]		ifNone:			[aHandle := self mapStaticFor: anExternal.			aHandle isNil				ifTrue: [self externalObjectNotFoundSignal raiseWith: self. ^nil]].	newVirtuals := (anExternal virtuals isNil		ifTrue: [#()]		ifFalse: [anExternal virtuals]), (Array with: theClass with: aHandle).	anExternal virtuals: newVirtuals.	^newVirtuals</body></methods><methods><class-id>External.ExternalLibraryHolder</class-id> <category>finding</category><body package="MQ-DLLCCFixes" selector="findFile:inDirectories:">findFile: fileName inDirectories: directoryNames 	"Search for the file indicated by the argument fileName in the directories indicated by the argument, 	 directoryNames. FileName is a String; directoryNames is an array of Strings indicating the directory 	 paths to search. Answer a String indicating the full path of the argument, fileName, if a readable 	 copy is found. If the file could not be found, raise libraryNotFoundSignal.	 There are two useful conventions for both the fileName and each directoryName.	 1. If either the fileName or a directory name includes brackets then the string within the brackets	 is taken to be a pattern which is matched against the current platform id. If it matches then	 the attempt to search will occur.  For example, if directoryNames included the following names		[alpha_osf]dllcc.adux [solaris]dllcc.solaris [win32*i386]dllcc.nt [win32*AXP]dllcc.ant	 then dllcc.solaris would only be searched if the OSHandle's currentPlatformId matched *solaris*.	 Note that underscores are mapped to spaces, so dllcc.adux is searched if the platform id matches	 '*alpha osf*'.	 2. Environment varaibles are expanded within both the fileName and each directory name.  The	 unix convention is used, that is an environment variable is some alphanumeric string delimited by	$().  So the following directory name expands to the system32 subdirectrory of	 the current windows directory on Windows:			$(windir)\system32	Here's a realistic example that attempts to get at the C library on a number of platforms:			libraryFiles: '[unix]libc.so [win]msvcrt40.dll '			libraryDirectories: '[unix]/usr/shlib [unix]/usr/lib [win]$(windir)\system [win]$(windir)\system32 '	On platforms whose currentPlatformID matches *unix* search for libc.so in /usr/shlib and /usr/lib.	On platforms whose currentPlatformID matches *win* search for msvcrt40.dll in	%windir%\system and %windir%\system32"	"anExternalLibraryHolder findFile: 'stdio.h' inDirectories: (Array with: '/tmp' with: '/usr/include')"	"First check for a patterned fileName and attempt to match it against the platform."	| file fixedFile |	(fileName includes: $[) 		ifTrue: 			[| pattern |			pattern := fileName copyFrom: (fileName indexOf: $[)						to: (fileName indexOf: $]).			file := fileName copyReplaceAll: pattern with: ''.			pattern replaceAll: $_ with: Character space.			pattern at: 1 put: (pattern at: pattern size put: $*).			(pattern match: OSHandle currentPlatformID) 				ifFalse: [^self class libraryNotFoundSignal raiseWith: fileName]]		ifFalse: [file := fileName].	file := Filename expandEnvironmentIn: file.	"Support AIX's archive library loading of the form archive.a(object.o)"	('*.a(*.o)' match: file) 		ifTrue: 			[fixedFile := file 						copyReplaceFrom: (file lastIndexOf: $()						to: (file lastIndexOf: $))						with: ''].	"Second, enumerate over each directory searching for an expanded path."	directoryNames do: 			[:dirSpec | 			| dir pattern filePath |			(dirSpec includes: $[) 				ifTrue: 					[pattern := dirSpec copyFrom: (dirSpec indexOf: $[)								to: (dirSpec indexOf: $]).					dir := dirSpec copyReplaceAll: pattern with: ''.					pattern replaceAll: $_ with: Character space.					pattern at: 1 put: (pattern at: pattern size put: $*)]				ifFalse: 					[pattern := '*'.					dir := dirSpec].			(pattern match: OSHandle currentPlatformID) 				ifTrue: 					[dir isEmpty 						ifTrue: [^file]						ifFalse: 							[filePath := (Filename expandEnvironmentIn: dir) asFilename construct: file.							(filePath isReadable or: 									[fixedFile notNil and: 											[((Filename expandEnvironmentIn: dir) asFilename construct: fixedFile) 												isReadable]]) 								ifTrue: [^filePath asString]]]].	^self class libraryNotFoundSignal raiseWith: fileName</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ExternalLibraryHolder</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name directories library owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class></st-source>